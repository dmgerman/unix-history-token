begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2013-2015, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"ixl_pf.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PCI_IOV
end_ifdef

begin_include
include|#
directive|include
file|"ixl_pf_iov.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IXL_IW
end_ifdef

begin_include
include|#
directive|include
file|"ixl_iw.h"
end_include

begin_include
include|#
directive|include
file|"ixl_iw_int.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEV_NETMAP */
end_comment

begin_function_decl
specifier|static
name|int
name|ixl_setup_queue
parameter_list|(
name|struct
name|ixl_queue
modifier|*
parameter_list|,
name|struct
name|ixl_pf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u64
name|ixl_max_aq_speed_to_value
parameter_list|(
name|u8
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u8
name|ixl_convert_sysctl_aq_link_speed
parameter_list|(
name|u8
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Sysctls */
end_comment

begin_function_decl
specifier|static
name|int
name|ixl_set_flowcntl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_set_advertise
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_current_speed
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_show_fw
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_unallocated_queues
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_pf_tx_itr
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_pf_rx_itr
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Debug Sysctls */
end_comment

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_link_status
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_phy_abilities
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_sw_filter_list
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_hw_res_alloc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_switch_config
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_hkey
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_hena
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_hlut
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_fw_link_management
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_read_i2c_byte
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_write_i2c_byte
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_fec_fc_ability
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_fec_rs_ability
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_fec_fc_request
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_fec_rs_request
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_fec_auto_enable
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IXL_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_qtx_tail_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_qrx_tail_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IXL_IW
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|ixl_enable_iwarp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|uint8_t
name|ixl_bcast_addr
index|[
name|ETHER_ADDR_LEN
index|]
init|=
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|ixl_fc_string
index|[
literal|6
index|]
init|=
block|{
literal|"None"
block|,
literal|"Rx"
block|,
literal|"Tx"
block|,
literal|"Full"
block|,
literal|"Priority"
block|,
literal|"Default"
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IXL
argument_list|,
literal|"ixl"
argument_list|,
literal|"ixl driver allocations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|ixl_debug_core
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|enum
name|ixl_dbg_mask
name|mask
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mask
operator|&
name|pf
operator|->
name|dbg_mask
operator|)
condition|)
return|return;
comment|/* Re-implement device_printf() */
name|device_print_prettyname
argument_list|(
name|pf
operator|->
name|dev
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Put the FW, API, NVM, EEtrackID, and OEM version information into a string */
end_comment

begin_function
name|void
name|ixl_nvm_version_str
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|sbuf
modifier|*
name|buf
parameter_list|)
block|{
name|u8
name|oem_ver
init|=
call|(
name|u8
call|)
argument_list|(
name|hw
operator|->
name|nvm
operator|.
name|oem_ver
operator|>>
literal|24
argument_list|)
decl_stmt|;
name|u16
name|oem_build
init|=
call|(
name|u16
call|)
argument_list|(
operator|(
name|hw
operator|->
name|nvm
operator|.
name|oem_ver
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFF
argument_list|)
decl_stmt|;
name|u8
name|oem_patch
init|=
call|(
name|u8
call|)
argument_list|(
name|hw
operator|->
name|nvm
operator|.
name|oem_ver
operator|&
literal|0xFF
argument_list|)
decl_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"fw %d.%d.%05d api %d.%d nvm %x.%02x etid %08x oem %d.%d.%d"
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|fw_maj_ver
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|fw_min_ver
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|fw_build
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|api_maj_ver
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|api_min_ver
argument_list|,
operator|(
name|hw
operator|->
name|nvm
operator|.
name|version
operator|&
name|IXL_NVM_VERSION_HI_MASK
operator|)
operator|>>
name|IXL_NVM_VERSION_HI_SHIFT
argument_list|,
operator|(
name|hw
operator|->
name|nvm
operator|.
name|version
operator|&
name|IXL_NVM_VERSION_LO_MASK
operator|)
operator|>>
name|IXL_NVM_VERSION_LO_SHIFT
argument_list|,
name|hw
operator|->
name|nvm
operator|.
name|eetrack
argument_list|,
name|oem_ver
argument_list|,
name|oem_build
argument_list|,
name|oem_patch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixl_print_nvm_version
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sbuf
decl_stmt|;
name|sbuf
operator|=
name|sbuf_new_auto
argument_list|()
expr_stmt|;
name|ixl_nvm_version_str
argument_list|(
name|hw
argument_list|,
name|sbuf
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|sbuf
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s\n"
argument_list|,
name|sbuf_data
argument_list|(
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_configure_tx_itr
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|vsi
operator|->
name|tx_itr_setting
operator|=
name|pf
operator|->
name|tx_itr
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITRN
argument_list|(
name|IXL_TX_ITR
argument_list|,
name|i
argument_list|)
argument_list|,
name|vsi
operator|->
name|tx_itr_setting
argument_list|)
expr_stmt|;
name|txr
operator|->
name|itr
operator|=
name|vsi
operator|->
name|tx_itr_setting
expr_stmt|;
name|txr
operator|->
name|latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_configure_rx_itr
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|vsi
operator|->
name|rx_itr_setting
operator|=
name|pf
operator|->
name|rx_itr
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITRN
argument_list|(
name|IXL_RX_ITR
argument_list|,
name|i
argument_list|)
argument_list|,
name|vsi
operator|->
name|rx_itr_setting
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|itr
operator|=
name|vsi
operator|->
name|rx_itr_setting
expr_stmt|;
name|rxr
operator|->
name|latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Write PF ITR values to queue ITR registers.  */
end_comment

begin_function
name|void
name|ixl_configure_itr
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|ixl_configure_tx_itr
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_configure_rx_itr
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Init entry point  *  *  This routine is used in two ways. It is used by the stack as  *  init entry point in network interface structure. It is also used  *  by the driver as a hw/sw initialization routine to get to a  *  consistent state.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
name|void
name|ixl_init_locked
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|i40e_filter_control_settings
name|filter
decl_stmt|;
name|u8
name|tmpaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_init_locked: begin"
argument_list|)
expr_stmt|;
name|IXL_PF_LOCK_ASSERT
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_stop_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* 	 * If the aq is dead here, it probably means something outside of the driver 	 * did something to the adapter, like a PF reset. 	 * So rebuild the driver's state here if that occurs. 	 */
if|if
condition|(
operator|!
name|i40e_check_asq_alive
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Admin Queue is down; resetting...\n"
argument_list|)
expr_stmt|;
name|ixl_teardown_hw_structs
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_reset
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
comment|/* Get the latest mac address... User might use a LAA */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
argument_list|,
name|tmpaddr
argument_list|,
name|I40E_ETH_LENGTH_OF_ADDRESS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmp_etheraddr
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|tmpaddr
argument_list|)
operator|&&
operator|(
name|i40e_validate_mac_addr
argument_list|(
name|tmpaddr
argument_list|)
operator|==
name|I40E_SUCCESS
operator|)
condition|)
block|{
name|ixl_del_filter
argument_list|(
name|vsi
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tmpaddr
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|I40E_ETH_LENGTH_OF_ADDRESS
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i40e_aq_mac_address_write
argument_list|(
name|hw
argument_list|,
name|I40E_AQC_WRITE_TYPE_LAA_ONLY
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"LLA address"
literal|"change failed!!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ixl_add_filter
argument_list|(
name|vsi
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
comment|/* Set the various hardware offload abilities */
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP_IPV6
operator||
name|CSUM_UDP_IPV6
operator|)
expr_stmt|;
comment|/* Set up the device filtering */
name|bzero
argument_list|(
operator|&
name|filter
argument_list|,
sizeof|sizeof
argument_list|(
name|filter
argument_list|)
argument_list|)
expr_stmt|;
name|filter
operator|.
name|enable_ethtype
operator|=
name|TRUE
expr_stmt|;
name|filter
operator|.
name|enable_macvlan
operator|=
name|TRUE
expr_stmt|;
name|filter
operator|.
name|enable_fdir
operator|=
name|FALSE
expr_stmt|;
name|filter
operator|.
name|hash_lut_size
operator|=
name|I40E_HASH_LUT_SIZE_512
expr_stmt|;
if|if
condition|(
name|i40e_set_filter_control
argument_list|(
name|hw
argument_list|,
operator|&
name|filter
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"i40e_set_filter_control() failed\n"
argument_list|)
expr_stmt|;
comment|/* Prepare the VSI: rings, hmc contexts, etc... */
if|if
condition|(
name|ixl_initialize_vsi
argument_list|(
name|vsi
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"initialize vsi failed!!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Set up RSS */
name|ixl_config_rss
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* Add protocol filters to list */
name|ixl_init_filters
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
comment|/* Setup vlan's if needed */
name|ixl_setup_vlan_filters
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
comment|/* Set up MSI/X routing and the ITR settings */
if|if
condition|(
name|pf
operator|->
name|msix
operator|>
literal|1
condition|)
block|{
name|ixl_configure_queue_intr_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_configure_itr
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
else|else
name|ixl_configure_legacy
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_enable_rings
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|i40e_aq_set_default_vsi
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ixl_reconfigure_filters
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
comment|/* And now turn on interrupts */
name|ixl_enable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
comment|/* Get link info */
name|hw
operator|->
name|phy
operator|.
name|get_link_info
operator|=
name|TRUE
expr_stmt|;
name|i40e_get_link_status
argument_list|(
name|hw
argument_list|,
operator|&
name|pf
operator|->
name|link_up
argument_list|)
expr_stmt|;
name|ixl_update_link_status
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* Start the local timer */
name|callout_reset
argument_list|(
operator|&
name|pf
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ixl_local_timer
argument_list|,
name|pf
argument_list|)
expr_stmt|;
comment|/* Now inform the stack we're ready */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
ifdef|#
directive|ifdef
name|IXL_IW
if|if
condition|(
name|ixl_enable_iwarp
operator|&&
name|pf
operator|->
name|iw_enabled
condition|)
block|{
name|ret
operator|=
name|ixl_iw_pf_init
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"initialize iwarp failed, code %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Get the hardware capabilities  *  **********************************************************************/
end_comment

begin_function
name|int
name|ixl_get_hw_capabilities
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_aqc_list_capabilities_element_resp
modifier|*
name|buf
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|;
name|u16
name|needed
decl_stmt|;
name|bool
name|again
init|=
name|TRUE
decl_stmt|;
name|len
operator|=
literal|40
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_aqc_list_capabilities_element_resp
argument_list|)
expr_stmt|;
name|retry
label|:
if|if
condition|(
operator|!
operator|(
name|buf
operator|=
operator|(
expr|struct
name|i40e_aqc_list_capabilities_element_resp
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate cap memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* This populates the hw struct */
name|error
operator|=
name|i40e_aq_discover_capabilities
argument_list|(
name|hw
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|needed
argument_list|,
name|i40e_aqc_opc_list_func_capabilities
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pf
operator|->
name|hw
operator|.
name|aq
operator|.
name|asq_last_status
operator|==
name|I40E_AQ_RC_ENOMEM
operator|)
operator|&&
operator|(
name|again
operator|==
name|TRUE
operator|)
condition|)
block|{
comment|/* retry once with a larger buffer */
name|again
operator|=
name|FALSE
expr_stmt|;
name|len
operator|=
name|needed
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
elseif|else
if|if
condition|(
name|pf
operator|->
name|hw
operator|.
name|aq
operator|.
name|asq_last_status
operator|!=
name|I40E_AQ_RC_OK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"capability discovery failed: %d\n"
argument_list|,
name|pf
operator|->
name|hw
operator|.
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* Capture this PF's starting queue pair */
name|pf
operator|->
name|qbase
operator|=
name|hw
operator|->
name|func_caps
operator|.
name|base_queue
expr_stmt|;
ifdef|#
directive|ifdef
name|IXL_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"pf_id=%d, num_vfs=%d, msix_pf=%d, "
literal|"msix_vf=%d, fd_g=%d, fd_b=%d, tx_qp=%d rx_qp=%d qbase=%d\n"
argument_list|,
name|hw
operator|->
name|pf_id
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_vfs
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_msix_vectors
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_msix_vectors_vf
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|fd_filters_guaranteed
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|fd_filters_best_effort
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_tx_qp
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_rx_qp
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|base_queue
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Print a subset of the capability information. */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PF-ID[%d]: VFs %d, MSIX %d, VF MSIX %d, QPs %d, %s\n"
argument_list|,
name|hw
operator|->
name|pf_id
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_vfs
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_msix_vectors
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_msix_vectors_vf
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_tx_qp
argument_list|,
operator|(
name|hw
operator|->
name|func_caps
operator|.
name|mdio_port_mode
operator|==
literal|2
operator|)
condition|?
literal|"I2C"
else|:
operator|(
name|hw
operator|->
name|func_caps
operator|.
name|mdio_port_mode
operator|==
literal|1
operator|)
condition|?
literal|"MDIO dedicated"
else|:
literal|"MDIO shared"
argument_list|)
expr_stmt|;
name|struct
name|i40e_osdep
modifier|*
name|osdep
init|=
operator|(
expr|struct
name|i40e_osdep
operator|*
operator|)
name|hw
operator|->
name|back
decl_stmt|;
name|osdep
operator|->
name|i2c_intfc_num
operator|=
name|ixl_find_i2c_interface
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|osdep
operator|->
name|i2c_intfc_num
operator|!=
operator|-
literal|1
condition|)
name|pf
operator|->
name|has_i2c
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ixl_cap_txcsum_tso
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|vsi
operator|->
name|dev
decl_stmt|;
comment|/* Enable/disable TXCSUM/TSO4 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TXCSUM
expr_stmt|;
comment|/* enable TXCSUM, restore TSO if previously enabled */
if|if
condition|(
name|vsi
operator|->
name|flags
operator|&
name|IXL_FLAGS_KEEP_TSO4
condition|)
block|{
name|vsi
operator|->
name|flags
operator|&=
operator|~
name|IXL_FLAGS_KEEP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO4
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
operator|(
name|IFCAP_TXCSUM
operator||
name|IFCAP_TSO4
operator|)
expr_stmt|;
name|vsi
operator|->
name|flags
operator|&=
operator|~
name|IXL_FLAGS_KEEP_TSO4
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TSO4 requires txcsum, enabling both...\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TXCSUM
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|vsi
operator|->
name|flags
operator||=
name|IXL_FLAGS_KEEP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TXCSUM
operator||
name|IFCAP_TSO4
operator|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TSO4 requires txcsum, disabling both...\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO4
expr_stmt|;
block|}
comment|/* Enable/disable TXCSUM_IPV6/TSO6 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO6
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
if|if
condition|(
name|vsi
operator|->
name|flags
operator|&
name|IXL_FLAGS_KEEP_TSO6
condition|)
block|{
name|vsi
operator|->
name|flags
operator|&=
operator|~
name|IXL_FLAGS_KEEP_TSO6
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO6
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
operator|(
name|IFCAP_TXCSUM_IPV6
operator||
name|IFCAP_TSO6
operator|)
expr_stmt|;
name|vsi
operator|->
name|flags
operator|&=
operator|~
name|IXL_FLAGS_KEEP_TSO6
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TSO6 requires txcsum6, enabling both...\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO6
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO6
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
block|{
name|vsi
operator|->
name|flags
operator||=
name|IXL_FLAGS_KEEP_TSO6
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TXCSUM_IPV6
operator||
name|IFCAP_TSO6
operator|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TSO6 requires txcsum6, disabling both...\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO6
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For the set_advertise sysctl */
end_comment

begin_function
name|void
name|ixl_get_initial_advertised_speeds
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|enum
name|i40e_status_code
name|status
decl_stmt|;
name|struct
name|i40e_aq_get_phy_abilities_resp
name|abilities
decl_stmt|;
comment|/* Set initial sysctl values */
name|status
operator|=
name|i40e_aq_get_phy_capabilities
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|,
name|false
argument_list|,
operator|&
name|abilities
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
comment|/* Non-fatal error */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: i40e_aq_get_phy_capabilities() error %d\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
name|pf
operator|->
name|advertised_speed
operator|=
name|ixl_convert_sysctl_aq_link_speed
argument_list|(
name|abilities
operator|.
name|link_speed
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ixl_teardown_hw_structs
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|status
init|=
literal|0
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
comment|/* Shutdown LAN HMC */
if|if
condition|(
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
condition|)
block|{
name|status
operator|=
name|i40e_shutdown_lan_hmc
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: LAN HMC shutdown failure; status %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
block|}
comment|// XXX: This gets called when we know the adminq is inactive;
comment|// so we already know it's setup when we get here.
comment|/* Shutdown admin queue */
name|status
operator|=
name|i40e_shutdown_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: Admin Queue shutdown failure; status %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|err_out
label|:
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixl_reset
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|u8
name|set_fc_err_mask
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|// XXX: clear_hw() actually writes to hw registers -- maybe this isn't necessary
name|i40e_clear_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_pf_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: PF reset failure"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|error
operator|=
name|i40e_init_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: Admin queue init failure;"
literal|" status code %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|i40e_clear_pxe_mode
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|error
operator|=
name|ixl_get_hw_capabilities
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: Error retrieving HW capabilities;"
literal|" status code %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|error
operator|=
name|i40e_init_lan_hmc
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_tx_qp
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_rx_qp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: LAN HMC init failed; status code %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|error
operator|=
name|i40e_configure_lan_hmc
argument_list|(
name|hw
argument_list|,
name|I40E_HMC_MODEL_DIRECT_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: LAN HMC config failed; status code %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|// XXX: possible fix for panic, but our failure recovery is still broken
name|error
operator|=
name|ixl_switch_config
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: ixl_switch_config() failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|error
operator|=
name|i40e_aq_set_phy_int_mask
argument_list|(
name|hw
argument_list|,
name|IXL_DEFAULT_PHY_INT_MASK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: i40e_aq_set_phy_mask() failed: err %d,"
literal|" aq_err %d\n"
argument_list|,
name|error
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|error
operator|=
name|i40e_set_fc
argument_list|(
name|hw
argument_list|,
operator|&
name|set_fc_err_mask
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: setting link flow control failed; retcode %d,"
literal|" fc_err_mask 0x%02x\n"
argument_list|,
name|error
argument_list|,
name|set_fc_err_mask
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|// XXX: (Rebuild VSIs?)
comment|/* Firmware delay workaround */
if|if
condition|(
operator|(
operator|(
name|hw
operator|->
name|aq
operator|.
name|fw_maj_ver
operator|==
literal|4
operator|)
operator|&&
operator|(
name|hw
operator|->
name|aq
operator|.
name|fw_min_ver
operator|<
literal|33
operator|)
operator|)
operator|||
operator|(
name|hw
operator|->
name|aq
operator|.
name|fw_maj_ver
operator|<
literal|4
operator|)
condition|)
block|{
name|i40e_msec_delay
argument_list|(
literal|75
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_aq_set_link_restart_an
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: link restart failed, aq_err %d\n"
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
block|}
name|err_out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** MSIX Interrupt Handlers and Tasklets */
end_comment

begin_function
name|void
name|ixl_handle_que
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|context
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|bool
name|more
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|more
operator|=
name|ixl_rxeof
argument_list|(
name|que
argument_list|,
name|IXL_RX_LIMIT
argument_list|)
expr_stmt|;
name|IXL_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixl_txeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|ixl_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|IXL_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|task
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Reenable this interrupt - hmmm */
name|ixl_enable_queue
argument_list|(
name|hw
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Legacy Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
name|void
name|ixl_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|arg
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|u32
name|icr0
decl_stmt|;
name|bool
name|more_tx
decl_stmt|,
name|more_rx
decl_stmt|;
name|pf
operator|->
name|admin_irq
operator|++
expr_stmt|;
comment|/* Protect against spurious interrupts */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|icr0
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_IOV
if|if
condition|(
name|icr0
operator|&
name|I40E_PFINT_ICR0_VFLR_MASK
condition|)
name|taskqueue_enqueue
argument_list|(
name|pf
operator|->
name|tq
argument_list|,
operator|&
name|pf
operator|->
name|vflr_task
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|icr0
operator|&
name|I40E_PFINT_ICR0_ADMINQ_MASK
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|pf
operator|->
name|tq
argument_list|,
operator|&
name|pf
operator|->
name|adminq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|icr0
operator|&
name|I40E_PFINT_ICR0_QUEUE_0_MASK
condition|)
block|{
operator|++
name|que
operator|->
name|irqs
expr_stmt|;
name|more_rx
operator|=
name|ixl_rxeof
argument_list|(
name|que
argument_list|,
name|IXL_RX_LIMIT
argument_list|)
expr_stmt|;
name|IXL_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|more_tx
operator|=
name|ixl_txeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|more_tx
operator|=
literal|1
expr_stmt|;
name|IXL_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
name|ixl_enable_intr0
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  MSIX VSI Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
name|void
name|ixl_msix_que
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|arg
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|bool
name|more_tx
decl_stmt|,
name|more_rx
decl_stmt|;
comment|/* Protect against spurious interrupts */
if|if
condition|(
operator|!
operator|(
name|vsi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return;
operator|++
name|que
operator|->
name|irqs
expr_stmt|;
name|more_rx
operator|=
name|ixl_rxeof
argument_list|(
name|que
argument_list|,
name|IXL_RX_LIMIT
argument_list|)
expr_stmt|;
name|IXL_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|more_tx
operator|=
name|ixl_txeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
comment|/* 	** Make certain that if the stack  	** has anything queued the task gets 	** scheduled to handle it. 	*/
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|more_tx
operator|=
literal|1
expr_stmt|;
name|IXL_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixl_set_queue_rx_itr
argument_list|(
name|que
argument_list|)
expr_stmt|;
name|ixl_set_queue_tx_itr
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
name|more_tx
operator|||
name|more_rx
condition|)
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|task
argument_list|)
expr_stmt|;
else|else
name|ixl_enable_queue
argument_list|(
name|hw
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  MSIX Admin Queue Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
name|void
name|ixl_msix_adminq
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|arg
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|mask
decl_stmt|,
name|rstat_reg
decl_stmt|;
name|bool
name|do_task
init|=
name|FALSE
decl_stmt|;
operator|++
name|pf
operator|->
name|admin_irq
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0
argument_list|)
expr_stmt|;
name|mask
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|)
expr_stmt|;
comment|/* Check on the cause */
if|if
condition|(
name|reg
operator|&
name|I40E_PFINT_ICR0_ADMINQ_MASK
condition|)
block|{
name|mask
operator|&=
operator|~
name|I40E_PFINT_ICR0_ADMINQ_MASK
expr_stmt|;
name|do_task
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_PFINT_ICR0_MAL_DETECT_MASK
condition|)
block|{
name|ixl_handle_mdd_event
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|mask
operator|&=
operator|~
name|I40E_PFINT_ICR0_MAL_DETECT_MASK
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_PFINT_ICR0_GRST_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Reset Requested!\n"
argument_list|)
expr_stmt|;
name|rstat_reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLGEN_RSTAT
argument_list|)
expr_stmt|;
name|rstat_reg
operator|=
operator|(
name|rstat_reg
operator|&
name|I40E_GLGEN_RSTAT_RESET_TYPE_MASK
operator|)
operator|>>
name|I40E_GLGEN_RSTAT_RESET_TYPE_SHIFT
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Reset type: "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rstat_reg
condition|)
block|{
comment|/* These others might be handled similarly to an EMPR reset */
case|case
name|I40E_RESET_CORER
case|:
name|printf
argument_list|(
literal|"CORER\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_RESET_GLOBR
case|:
name|printf
argument_list|(
literal|"GLOBR\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_RESET_EMPR
case|:
name|printf
argument_list|(
literal|"EMPR\n"
argument_list|)
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|pf
operator|->
name|state
argument_list|,
name|IXL_PF_STATE_EMPR_RESETTING
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"POR\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* overload admin queue task to check reset progress */
name|do_task
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_PFINT_ICR0_ECC_ERR_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ECC Error detected!\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_PFINT_ICR0_HMC_ERR_MASK
condition|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFHMC_ERRORINFO
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_PFHMC_ERRORINFO_ERROR_DETECTED_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"HMC Error detected!\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"INFO 0x%08x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFHMC_ERRORDATA
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DATA 0x%08x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFHMC_ERRORINFO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_PFINT_ICR0_PCI_EXCEPTION_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCI Exception detected!\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PCI_IOV
if|if
condition|(
name|reg
operator|&
name|I40E_PFINT_ICR0_VFLR_MASK
condition|)
block|{
name|mask
operator|&=
operator|~
name|I40E_PFINT_ICR0_ENA_VFLR_MASK
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|pf
operator|->
name|tq
argument_list|,
operator|&
name|pf
operator|->
name|vflr_task
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|do_task
condition|)
name|taskqueue_enqueue
argument_list|(
name|pf
operator|->
name|tq
argument_list|,
operator|&
name|pf
operator|->
name|adminq
argument_list|)
expr_stmt|;
else|else
name|ixl_enable_intr0
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixl_set_promisc
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|int
name|err
decl_stmt|,
name|mcnt
init|=
literal|0
decl_stmt|;
name|bool
name|uni
init|=
name|FALSE
decl_stmt|,
name|multi
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
name|multi
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
comment|/* Need to count the multicast addresses */
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|mcnt
operator|==
name|MAX_MULTICAST_ADDR
condition|)
break|break;
name|mcnt
operator|++
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mcnt
operator|>=
name|MAX_MULTICAST_ADDR
condition|)
name|multi
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|uni
operator|=
name|TRUE
expr_stmt|;
name|err
operator|=
name|i40e_aq_set_vsi_unicast_promiscuous
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|,
name|uni
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|err
operator|=
name|i40e_aq_set_vsi_multicast_promiscuous
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|,
name|multi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  * 	Filter Routines  *  *	Routines for multicast and vlan filter management.  *  *********************************************************************/
end_comment

begin_function
name|void
name|ixl_add_multi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|,
name|flags
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ixl_add_multi: begin"
argument_list|)
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	** First just get a count, to decide if we 	** we simply use multicast promiscuous. 	*/
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|mcnt
operator|++
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|mcnt
operator|>=
name|MAX_MULTICAST_ADDR
argument_list|)
condition|)
block|{
comment|/* delete existing MC filters */
name|ixl_del_hw_filters
argument_list|(
name|vsi
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
name|i40e_aq_set_vsi_multicast_promiscuous
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|mcnt
operator|=
literal|0
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|ixl_add_mc_filter
argument_list|(
name|vsi
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|)
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcnt
operator|>
literal|0
condition|)
block|{
name|flags
operator|=
operator|(
name|IXL_FILTER_ADD
operator||
name|IXL_FILTER_USED
operator||
name|IXL_FILTER_MC
operator|)
expr_stmt|;
name|ixl_add_hw_filters
argument_list|(
name|vsi
argument_list|,
name|flags
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
block|}
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ixl_add_multi: end"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ixl_del_multi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|bool
name|match
init|=
name|FALSE
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ixl_del_multi: begin"
argument_list|)
expr_stmt|;
comment|/* Search for removed multicast addresses */
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
operator|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_USED
operator|)
operator|&&
operator|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_MC
operator|)
condition|)
block|{
name|match
operator|=
name|FALSE
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|u8
modifier|*
name|mc_addr
init|=
operator|(
name|u8
operator|*
operator|)
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp_etheraddr
argument_list|(
name|f
operator|->
name|macaddr
argument_list|,
name|mc_addr
argument_list|)
condition|)
block|{
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|match
operator|==
name|FALSE
condition|)
block|{
name|f
operator|->
name|flags
operator||=
name|IXL_FILTER_DEL
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
block|}
block|}
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcnt
operator|>
literal|0
condition|)
name|ixl_del_hw_filters
argument_list|(
name|vsi
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Timer routine  *  *  This routine checks for link status,updates statistics,  *  and runs the watchdog check.  *  *  Only runs when the driver is configured UP and RUNNING.  *  **********************************************************************/
end_comment

begin_function
name|void
name|ixl_local_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|arg
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|int
name|hung
init|=
literal|0
decl_stmt|;
name|u32
name|mask
decl_stmt|;
name|s32
name|timer
decl_stmt|,
name|new_timer
decl_stmt|;
name|IXL_PF_LOCK_ASSERT
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* Fire off the adminq task */
name|taskqueue_enqueue
argument_list|(
name|pf
operator|->
name|tq
argument_list|,
operator|&
name|pf
operator|->
name|adminq
argument_list|)
expr_stmt|;
comment|/* Update stats */
name|ixl_update_stats_counters
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* Check status of the queues */
name|mask
operator|=
operator|(
name|I40E_PFINT_DYN_CTLN_INTENA_MASK
operator||
name|I40E_PFINT_DYN_CTLN_SWINT_TRIG_MASK
operator||
name|I40E_PFINT_DYN_CTLN_ITR_INDX_MASK
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|txr
operator|=
operator|&
name|que
operator|->
name|txr
expr_stmt|;
name|timer
operator|=
name|atomic_load_acq_32
argument_list|(
operator|&
name|txr
operator|->
name|watchdog_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|timer
operator|>
literal|0
condition|)
block|{
name|new_timer
operator|=
name|timer
operator|-
name|hz
expr_stmt|;
if|if
condition|(
name|new_timer
operator|<=
literal|0
condition|)
block|{
name|atomic_store_rel_32
argument_list|(
operator|&
name|txr
operator|->
name|watchdog_timer
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"WARNING: queue %d "
literal|"appears to be hung!\n"
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
operator|++
name|hung
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * If this fails, that means something in the TX path has updated 				 * the watchdog, so it means the TX path is still working and 				 * the watchdog doesn't need to countdown. 				 */
name|atomic_cmpset_rel_32
argument_list|(
operator|&
name|txr
operator|->
name|watchdog_timer
argument_list|,
name|timer
argument_list|,
name|new_timer
argument_list|)
expr_stmt|;
comment|/* Any queues with outstanding work get a sw irq */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTLN
argument_list|(
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Reset when a queue shows hung */
if|if
condition|(
name|hung
condition|)
goto|goto
name|hung
goto|;
name|callout_reset
argument_list|(
operator|&
name|pf
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ixl_local_timer
argument_list|,
name|pf
argument_list|)
expr_stmt|;
return|return;
name|hung
label|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"WARNING: Resetting!\n"
argument_list|)
expr_stmt|;
name|pf
operator|->
name|watchdog_events
operator|++
expr_stmt|;
name|ixl_init_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixl_link_up_msg
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pf
operator|->
name|vsi
operator|.
name|ifp
decl_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s: Link is up, %s Full Duplex, FEC: %s, Autoneg: %s, Flow Control: %s\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|ixl_aq_speed_to_str
argument_list|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|link_speed
argument_list|)
argument_list|,
operator|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|fec_info
operator|&
name|I40E_AQ_CONFIG_FEC_KR_ENA
operator|)
condition|?
literal|"Clause 74 BASE-R FEC"
else|:
operator|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|fec_info
operator|&
name|I40E_AQ_CONFIG_FEC_RS_ENA
operator|)
condition|?
literal|"Clause 108 RS-FEC"
else|:
literal|"None"
argument_list|,
operator|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|an_info
operator|&
name|I40E_AQ_AN_COMPLETED
operator|)
condition|?
literal|"True"
else|:
literal|"False"
argument_list|,
operator|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|an_info
operator|&
name|I40E_AQ_LINK_PAUSE_TX
operator|&&
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|an_info
operator|&
name|I40E_AQ_LINK_PAUSE_RX
operator|)
condition|?
name|ixl_fc_string
index|[
literal|3
index|]
else|:
operator|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|an_info
operator|&
name|I40E_AQ_LINK_PAUSE_TX
operator|)
condition|?
name|ixl_fc_string
index|[
literal|2
index|]
else|:
operator|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|an_info
operator|&
name|I40E_AQ_LINK_PAUSE_RX
operator|)
condition|?
name|ixl_fc_string
index|[
literal|1
index|]
else|:
name|ixl_fc_string
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Note: this routine updates the OS on the link state **	the real check of the hardware only happens with **	a link interrupt. */
end_comment

begin_function
name|void
name|ixl_update_link_status
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
if|if
condition|(
name|pf
operator|->
name|link_up
condition|)
block|{
if|if
condition|(
name|vsi
operator|->
name|link_active
operator|==
name|FALSE
condition|)
block|{
name|vsi
operator|->
name|link_active
operator|=
name|TRUE
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
name|ixl_max_aq_speed_to_value
argument_list|(
name|pf
operator|->
name|link_speed
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
name|ixl_link_up_msg
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Link down */
if|if
condition|(
name|vsi
operator|->
name|link_active
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is Down\n"
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|link_active
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  This routine disables all traffic on the adapter by issuing a  *  global reset on the MAC and deallocates TX/RX buffers.  *  **********************************************************************/
end_comment

begin_function
name|void
name|ixl_stop_locked
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_stop: begin\n"
argument_list|)
expr_stmt|;
name|IXL_PF_LOCK_ASSERT
argument_list|(
name|pf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXL_IW
comment|/* Stop iWARP device */
if|if
condition|(
name|ixl_enable_iwarp
operator|&&
name|pf
operator|->
name|iw_enabled
condition|)
name|ixl_iw_pf_stop
argument_list|(
name|pf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Stop the local timer */
name|callout_stop
argument_list|(
operator|&
name|pf
operator|->
name|timer
argument_list|)
expr_stmt|;
name|ixl_disable_rings_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixl_disable_rings
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
comment|/* Tell the stack that the interface is no longer active */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixl_stop
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_stop_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup MSIX Interrupt resources and handlers for the VSI  *  **********************************************************************/
end_comment

begin_function
name|int
name|ixl_setup_legacy
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pf
operator|->
name|msix
operator|==
literal|1
condition|)
name|rid
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_alloc_resource_any() for"
literal|" legacy/msi interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set the handler function */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|pf
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixl_intr
argument_list|,
name|pf
argument_list|,
operator|&
name|pf
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|pf
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_setup_intr() for legacy/msi"
literal|" interrupt handler failed, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|pf
operator|->
name|res
argument_list|,
name|pf
operator|->
name|tag
argument_list|,
literal|"irq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* non-fatal */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_describe_intr() for Admin Queue"
literal|" interrupt name failed, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixl_setup_adminq_tq
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Tasklet for Admin Queue interrupts */
name|TASK_INIT
argument_list|(
operator|&
name|pf
operator|->
name|adminq
argument_list|,
literal|0
argument_list|,
name|ixl_do_adminq
argument_list|,
name|pf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_IOV
comment|/* VFLR Tasklet */
name|TASK_INIT
argument_list|(
operator|&
name|pf
operator|->
name|vflr_task
argument_list|,
literal|0
argument_list|,
name|ixl_handle_vflr
argument_list|,
name|pf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Create and start Admin Queue taskqueue */
name|pf
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixl_aq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|pf
operator|->
name|tq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pf
operator|->
name|tq
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"taskqueue_create_fast (for AQ) returned NULL!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|error
operator|=
name|taskqueue_start_threads
argument_list|(
operator|&
name|pf
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s aq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"taskqueue_start_threads (for AQ) error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|pf
operator|->
name|tq
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixl_setup_queue_tqs
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|device_t
name|dev
init|=
name|vsi
operator|->
name|dev
decl_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|int
name|cpu_id
init|=
literal|0
decl_stmt|;
name|cpuset_t
name|cpu_mask
decl_stmt|;
endif|#
directive|endif
comment|/* Create queue tasks and start queue taskqueues */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|tx_task
argument_list|,
literal|0
argument_list|,
name|ixl_deferred_mq_start
argument_list|,
name|que
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|ixl_handle_que
argument_list|,
name|que
argument_list|)
expr_stmt|;
name|que
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixl_que"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|CPU_SETOF
argument_list|(
name|cpu_id
argument_list|,
operator|&
name|cpu_mask
argument_list|)
expr_stmt|;
name|taskqueue_start_threads_cpuset
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
operator|&
name|cpu_mask
argument_list|,
literal|"%s (bucket %d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
else|#
directive|else
name|taskqueue_start_threads
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s (que %d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ixl_free_adminq_tq
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
if|if
condition|(
name|pf
operator|->
name|tq
condition|)
block|{
name|taskqueue_free
argument_list|(
name|pf
operator|->
name|tq
argument_list|)
expr_stmt|;
name|pf
operator|->
name|tq
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ixl_free_queue_tqs
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
if|if
condition|(
name|que
operator|->
name|tq
condition|)
block|{
name|taskqueue_free
argument_list|(
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
name|que
operator|->
name|tq
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|ixl_setup_adminq_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
comment|/* Admin IRQ rid is 1, vector is 0 */
name|rid
operator|=
literal|1
expr_stmt|;
comment|/* Get interrupt resource from bus */
name|pf
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pf
operator|->
name|res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_alloc_resource_any() for Admin Queue"
literal|" interrupt failed [rid=%d]\n"
argument_list|,
name|rid
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Then associate interrupt with handler */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|pf
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixl_msix_adminq
argument_list|,
name|pf
argument_list|,
operator|&
name|pf
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|pf
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_setup_intr() for Admin Queue"
literal|" interrupt handler failed, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|pf
operator|->
name|res
argument_list|,
name|pf
operator|->
name|tag
argument_list|,
literal|"aq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* non-fatal */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_describe_intr() for Admin Queue"
literal|" interrupt name failed, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|pf
operator|->
name|admvec
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate interrupt resources from bus and associate an interrupt handler  * to those for the VSI's queues.  */
end_comment

begin_function
name|int
name|ixl_setup_queue_msix
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|vsi
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|,
name|vector
init|=
literal|1
decl_stmt|;
comment|/* Queue interrupt vector numbers start at 1 (adminq intr is 0) */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|vector
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|int
name|cpu_id
init|=
name|i
decl_stmt|;
name|rid
operator|=
name|vector
operator|+
literal|1
expr_stmt|;
name|txr
operator|=
operator|&
name|que
operator|->
name|txr
expr_stmt|;
name|que
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|que
operator|->
name|res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_alloc_resource_any() for"
literal|" Queue %d interrupt failed [rid=%d]\n"
argument_list|,
name|que
operator|->
name|me
argument_list|,
name|rid
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set the handler function */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixl_msix_que
argument_list|,
name|que
argument_list|,
operator|&
name|que
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_setup_intr() for Queue %d"
literal|" interrupt handler failed, error %d\n"
argument_list|,
name|que
operator|->
name|me
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|que
operator|->
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|que
operator|->
name|tag
argument_list|,
literal|"q%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_describe_intr() for Queue %d"
literal|" interrupt name failed, error %d\n"
argument_list|,
name|que
operator|->
name|me
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* Bind the vector to a CPU */
ifdef|#
directive|ifdef
name|RSS
name|cpu_id
operator|=
name|rss_getcpu
argument_list|(
name|i
operator|%
name|rss_getnumbuckets
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|bus_bind_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_bind_intr() for Queue %d"
literal|" to CPU %d failed, error %d\n"
argument_list|,
name|que
operator|->
name|me
argument_list|,
name|cpu_id
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|que
operator|->
name|msix
operator|=
name|vector
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When used in a virtualized environment PCI BUSMASTER capability may not be set  * so explicity set it here and rewrite the ENABLE in the MSIX control register  * at this point to cause the host to successfully initialize us.  */
end_comment

begin_function
name|void
name|ixl_set_busmaster
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u16
name|pci_cmd_word
decl_stmt|;
name|pci_cmd_word
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_cmd_word
operator||=
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|pci_cmd_word
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rewrite the ENABLE in the MSIX control register  * to cause the host to successfully initialize us.  */
end_comment

begin_function
name|void
name|ixl_set_msix_enable
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|msix_ctrl
decl_stmt|,
name|rid
decl_stmt|;
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_MSIX
argument_list|,
operator|&
name|rid
argument_list|)
expr_stmt|;
name|rid
operator|+=
name|PCIR_MSIX_CTRL
expr_stmt|;
name|msix_ctrl
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|msix_ctrl
operator||=
name|PCIM_MSIXCTRL_MSIX_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
name|msix_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate MSI/X vectors from the OS.  * Returns 0 for legacy, 1 for MSI,>1 for MSIX.  */
end_comment

begin_function
name|int
name|ixl_init_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|int
name|auto_max_queues
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|want
decl_stmt|,
name|vectors
decl_stmt|,
name|queues
decl_stmt|,
name|available
decl_stmt|;
ifdef|#
directive|ifdef
name|IXL_IW
name|int
name|iw_want
decl_stmt|,
name|iw_vectors
decl_stmt|;
name|pf
operator|->
name|iw_msix
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Override by tuneable */
if|if
condition|(
operator|!
name|pf
operator|->
name|enable_msix
condition|)
goto|goto
name|no_msix
goto|;
comment|/* Ensure proper operation in virtualized environment */
name|ixl_set_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* First try MSI/X */
name|rid
operator|=
name|PCIR_BAR
argument_list|(
name|IXL_MSIX_BAR
argument_list|)
expr_stmt|;
name|pf
operator|->
name|msix_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pf
operator|->
name|msix_mem
condition|)
block|{
comment|/* May not be enabled */
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"Unable to map MSIX table\n"
argument_list|)
expr_stmt|;
goto|goto
name|no_msix
goto|;
block|}
name|available
operator|=
name|pci_msix_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|available
operator|<
literal|2
condition|)
block|{
comment|/* system has msix disabled (0), or only one vector (1) */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|pf
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
name|pf
operator|->
name|msix_mem
operator|=
name|NULL
expr_stmt|;
goto|goto
name|no_msix
goto|;
block|}
comment|/* Clamp max number of queues based on: 	 * - # of MSI-X vectors available 	 * - # of cpus available 	 * - # of queues that can be assigned to the LAN VSI 	 */
name|auto_max_queues
operator|=
name|min
argument_list|(
name|mp_ncpus
argument_list|,
name|available
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|I40E_MAC_X722
condition|)
name|auto_max_queues
operator|=
name|min
argument_list|(
name|auto_max_queues
argument_list|,
literal|128
argument_list|)
expr_stmt|;
else|else
name|auto_max_queues
operator|=
name|min
argument_list|(
name|auto_max_queues
argument_list|,
literal|64
argument_list|)
expr_stmt|;
comment|/* Override with tunable value if tunable is less than autoconfig count */
if|if
condition|(
operator|(
name|pf
operator|->
name|max_queues
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|pf
operator|->
name|max_queues
operator|<=
name|auto_max_queues
operator|)
condition|)
name|queues
operator|=
name|pf
operator|->
name|max_queues
expr_stmt|;
comment|/* Use autoconfig amount if that's lower */
elseif|else
if|if
condition|(
operator|(
name|pf
operator|->
name|max_queues
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|pf
operator|->
name|max_queues
operator|>
name|auto_max_queues
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixl_max_queues (%d) is too large, using "
literal|"autoconfig amount (%d)...\n"
argument_list|,
name|pf
operator|->
name|max_queues
argument_list|,
name|auto_max_queues
argument_list|)
expr_stmt|;
name|queues
operator|=
name|auto_max_queues
expr_stmt|;
block|}
comment|/* Limit maximum auto-configured queues to 8 if no user value is set */
else|else
name|queues
operator|=
name|min
argument_list|(
name|auto_max_queues
argument_list|,
literal|8
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
comment|/* If we're doing RSS, clamp at the number of RSS buckets */
if|if
condition|(
name|queues
operator|>
name|rss_getnumbuckets
argument_list|()
condition|)
name|queues
operator|=
name|rss_getnumbuckets
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	** Want one vector (RX/TX pair) per queue 	** plus an additional for the admin queue. 	*/
name|want
operator|=
name|queues
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|want
operator|<=
name|available
condition|)
comment|/* Have enough */
name|vectors
operator|=
name|want
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"MSIX Configuration Problem, "
literal|"%d vectors available but %d wanted!\n"
argument_list|,
name|available
argument_list|,
name|want
argument_list|)
expr_stmt|;
name|pf
operator|->
name|msix_mem
operator|=
name|NULL
expr_stmt|;
goto|goto
name|no_msix
goto|;
comment|/* Will go to Legacy setup */
block|}
ifdef|#
directive|ifdef
name|IXL_IW
if|if
condition|(
name|ixl_enable_iwarp
condition|)
block|{
comment|/* iWARP wants additional vector for CQP */
name|iw_want
operator|=
name|mp_ncpus
operator|+
literal|1
expr_stmt|;
name|available
operator|-=
name|vectors
expr_stmt|;
if|if
condition|(
name|available
operator|>
literal|0
condition|)
block|{
name|iw_vectors
operator|=
operator|(
name|available
operator|>=
name|iw_want
operator|)
condition|?
name|iw_want
else|:
name|available
expr_stmt|;
name|vectors
operator|+=
name|iw_vectors
expr_stmt|;
block|}
else|else
name|iw_vectors
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|ixl_set_msix_enable
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|vectors
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"Using MSIX interrupts with %d vectors\n"
argument_list|,
name|vectors
argument_list|)
expr_stmt|;
name|pf
operator|->
name|msix
operator|=
name|vectors
expr_stmt|;
ifdef|#
directive|ifdef
name|IXL_IW
if|if
condition|(
name|ixl_enable_iwarp
condition|)
name|pf
operator|->
name|iw_msix
operator|=
name|iw_vectors
expr_stmt|;
endif|#
directive|endif
name|pf
operator|->
name|vsi
operator|.
name|num_queues
operator|=
name|queues
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
comment|/* 		 * If we're doing RSS, the number of queues needs to 		 * match the number of RSS buckets that are configured. 		 * 		 * + If there's more queues than RSS buckets, we'll end 		 *   up with queues that get no traffic. 		 * 		 * + If there's more RSS buckets than queues, we'll end 		 *   up having multiple RSS buckets map to the same queue, 		 *   so there'll be some contention. 		 */
if|if
condition|(
name|queues
operator|!=
name|rss_getnumbuckets
argument_list|()
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: queues (%d) != RSS buckets (%d)"
literal|"; performance will be impacted.\n"
argument_list|,
name|__func__
argument_list|,
name|queues
argument_list|,
name|rss_getnumbuckets
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|vectors
operator|)
return|;
block|}
name|no_msix
label|:
name|vectors
operator|=
name|pci_msi_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pf
operator|->
name|vsi
operator|.
name|num_queues
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|max_queues
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vectors
operator|==
literal|1
operator|&&
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|vectors
argument_list|)
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"Using an MSI interrupt\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|vectors
operator|=
literal|0
expr_stmt|;
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"Using a Legacy interrupt\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|vectors
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Configure admin queue/misc interrupt cause registers in hardware.  */
end_comment

begin_function
name|void
name|ixl_configure_intr0_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|u32
name|reg
decl_stmt|;
comment|/* First set up the adminq - vector 0 */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable all */
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0
argument_list|)
expr_stmt|;
comment|/* read to clear */
name|reg
operator|=
name|I40E_PFINT_ICR0_ENA_ECC_ERR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_GRST_MASK
operator||
name|I40E_PFINT_ICR0_ENA_HMC_ERR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_ADMINQ_MASK
operator||
name|I40E_PFINT_ICR0_ENA_MAL_DETECT_MASK
operator||
name|I40E_PFINT_ICR0_ENA_VFLR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_PCI_EXCEPTION_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* 	 * 0x7FF is the end of the queue list. 	 * This means we won't use MSI-X vector 0 for a queue interrupt 	 * in MSIX mode. 	 */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_LNKLST0
argument_list|,
literal|0x7FF
argument_list|)
expr_stmt|;
comment|/* Value is in 2 usec units, so 0x3E is 62*2 = 124 usecs. */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITR0
argument_list|(
name|IXL_RX_ITR
argument_list|)
argument_list|,
literal|0x3E
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|,
name|I40E_PFINT_DYN_CTL0_SW_ITR_INDX_MASK
operator||
name|I40E_PFINT_DYN_CTL0_INTENA_MSK_MASK
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_STAT_CTL0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Configure queue interrupt cause registers in hardware.  */
end_comment

begin_function
name|void
name|ixl_configure_queue_intr_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|u16
name|vector
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|vector
operator|++
control|)
block|{
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTLN
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* First queue type is RX / 0 */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_LNKLSTN
argument_list|(
name|i
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|reg
operator|=
name|I40E_QINT_RQCTL_CAUSE_ENA_MASK
operator||
operator|(
name|IXL_RX_ITR
operator|<<
name|I40E_QINT_RQCTL_ITR_INDX_SHIFT
operator|)
operator||
operator|(
name|vector
operator|<<
name|I40E_QINT_RQCTL_MSIX_INDX_SHIFT
operator|)
operator||
operator|(
name|i
operator|<<
name|I40E_QINT_RQCTL_NEXTQ_INDX_SHIFT
operator|)
operator||
operator|(
name|I40E_QUEUE_TYPE_TX
operator|<<
name|I40E_QINT_RQCTL_NEXTQ_TYPE_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QINT_RQCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|I40E_QINT_TQCTL_CAUSE_ENA_MASK
operator||
operator|(
name|IXL_TX_ITR
operator|<<
name|I40E_QINT_TQCTL_ITR_INDX_SHIFT
operator|)
operator||
operator|(
name|vector
operator|<<
name|I40E_QINT_TQCTL_MSIX_INDX_SHIFT
operator|)
operator||
operator|(
name|IXL_QUEUE_EOL
operator|<<
name|I40E_QINT_TQCTL_NEXTQ_INDX_SHIFT
operator|)
operator||
operator|(
name|I40E_QUEUE_TYPE_RX
operator|<<
name|I40E_QINT_TQCTL_NEXTQ_TYPE_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QINT_TQCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Configure for MSI single vector operation   */
end_comment

begin_function
name|void
name|ixl_configure_legacy
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|u32
name|reg
decl_stmt|;
comment|/* Configure ITR */
name|vsi
operator|->
name|tx_itr_setting
operator|=
name|pf
operator|->
name|tx_itr
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITR0
argument_list|(
name|IXL_TX_ITR
argument_list|)
argument_list|,
name|vsi
operator|->
name|tx_itr_setting
argument_list|)
expr_stmt|;
name|txr
operator|->
name|itr
operator|=
name|vsi
operator|->
name|tx_itr_setting
expr_stmt|;
name|vsi
operator|->
name|rx_itr_setting
operator|=
name|pf
operator|->
name|rx_itr
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITR0
argument_list|(
name|IXL_RX_ITR
argument_list|)
argument_list|,
name|vsi
operator|->
name|rx_itr_setting
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|itr
operator|=
name|vsi
operator|->
name|rx_itr_setting
expr_stmt|;
comment|/* Setup "other" causes */
name|reg
operator|=
name|I40E_PFINT_ICR0_ENA_ECC_ERR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_MAL_DETECT_MASK
operator||
name|I40E_PFINT_ICR0_ENA_GRST_MASK
operator||
name|I40E_PFINT_ICR0_ENA_PCI_EXCEPTION_MASK
operator||
name|I40E_PFINT_ICR0_ENA_GPIO_MASK
operator||
name|I40E_PFINT_ICR0_ENA_LINK_STAT_CHANGE_MASK
operator||
name|I40E_PFINT_ICR0_ENA_HMC_ERR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_PE_CRITERR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_VFLR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_ADMINQ_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* No ITR for non-queue interrupts */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_STAT_CTL0
argument_list|,
name|IXL_ITR_NONE
operator|<<
name|I40E_PFINT_STAT_CTL0_OTHER_ITR_INDX_SHIFT
argument_list|)
expr_stmt|;
comment|/* FIRSTQ_INDX = 0, FIRSTQ_TYPE = 0 (rx) */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_LNKLST0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Associate the queue pair to the vector and enable the q int */
name|reg
operator|=
name|I40E_QINT_RQCTL_CAUSE_ENA_MASK
operator||
operator|(
name|IXL_RX_ITR
operator|<<
name|I40E_QINT_RQCTL_ITR_INDX_SHIFT
operator|)
operator||
operator|(
name|I40E_QUEUE_TYPE_TX
operator|<<
name|I40E_QINT_TQCTL_NEXTQ_TYPE_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QINT_RQCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|I40E_QINT_TQCTL_CAUSE_ENA_MASK
operator||
operator|(
name|IXL_TX_ITR
operator|<<
name|I40E_QINT_TQCTL_ITR_INDX_SHIFT
operator|)
operator||
operator|(
name|IXL_QUEUE_EOL
operator|<<
name|I40E_QINT_TQCTL_NEXTQ_INDX_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QINT_TQCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ixl_allocate_pci_resources
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|int
name|rid
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
comment|/* Map BAR0 */
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pf
operator|->
name|pci_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pf
operator|->
name|pci_mem
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: PCI memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Save off the PCI information */
name|hw
operator|->
name|vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|revision_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hw
operator|->
name|subsystem_vendor_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hw
operator|->
name|subsystem_device_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hw
operator|->
name|bus
operator|.
name|device
operator|=
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|bus
operator|.
name|func
operator|=
name|pci_get_function
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Save off register access information */
name|pf
operator|->
name|osdep
operator|.
name|mem_bus_space_tag
operator|=
name|rman_get_bustag
argument_list|(
name|pf
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|pf
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|pf
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|pf
operator|->
name|osdep
operator|.
name|mem_bus_space_size
operator|=
name|rman_get_size
argument_list|(
name|pf
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|pf
operator|->
name|osdep
operator|.
name|flush_reg
operator|=
name|I40E_GLGEN_STAT
expr_stmt|;
name|pf
operator|->
name|hw
operator|.
name|hw_addr
operator|=
operator|(
name|u8
operator|*
operator|)
operator|&
name|pf
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
expr_stmt|;
name|pf
operator|->
name|hw
operator|.
name|back
operator|=
operator|&
name|pf
operator|->
name|osdep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Teardown and release the admin queue/misc vector  * interrupt.  */
end_comment

begin_function
name|int
name|ixl_teardown_adminq_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pf
operator|->
name|admvec
condition|)
comment|/* we are doing MSIX */
name|rid
operator|=
name|pf
operator|->
name|admvec
operator|+
literal|1
expr_stmt|;
else|else
operator|(
name|pf
operator|->
name|msix
operator|!=
literal|0
operator|)
condition|?
operator|(
name|rid
operator|=
literal|1
operator|)
else|:
operator|(
name|rid
operator|=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|pf
operator|->
name|res
argument_list|,
name|pf
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_teardown_intr() for"
literal|" interrupt 0 failed\n"
argument_list|)
expr_stmt|;
comment|// return (ENXIO);
block|}
name|pf
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pf
operator|->
name|res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|pf
operator|->
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_release_resource() for"
literal|" interrupt 0 failed [rid=%d]\n"
argument_list|,
name|rid
argument_list|)
expr_stmt|;
comment|// return (ENXIO);
block|}
name|pf
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixl_teardown_queue_msix
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|device_t
name|dev
init|=
name|vsi
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
comment|/* We may get here before stations are setup */
if|if
condition|(
operator|(
name|pf
operator|->
name|msix
operator|<
literal|2
operator|)
operator|||
operator|(
name|que
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Release all MSIX queue resources */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|rid
operator|=
name|que
operator|->
name|msix
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|que
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|que
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_teardown_intr() for"
literal|" Queue %d interrupt failed\n"
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
comment|// return (ENXIO);
block|}
name|que
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|que
operator|->
name|res
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|que
operator|->
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_release_resource() for"
literal|" Queue %d interrupt failed [rid=%d]\n"
argument_list|,
name|que
operator|->
name|me
argument_list|,
name|rid
argument_list|)
expr_stmt|;
comment|// return (ENXIO);
block|}
name|que
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ixl_free_pci_resources
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|memrid
decl_stmt|;
name|ixl_teardown_queue_msix
argument_list|(
operator|&
name|pf
operator|->
name|vsi
argument_list|)
expr_stmt|;
name|ixl_teardown_adminq_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|msix
operator|>
literal|0
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|memrid
operator|=
name|PCIR_BAR
argument_list|(
name|IXL_MSIX_BAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|msix_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|memrid
argument_list|,
name|pf
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|pci_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|pf
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ixl_add_ifmedia
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|u64
name|phy_types
parameter_list|)
block|{
comment|/* Display supported media types */
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_100BASE_TX
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_1000BASE_T
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_1000BASE_SX
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_SX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_1000BASE_LX
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_LX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_XAUI
operator|)
operator|||
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_XFI
operator|)
operator|||
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_10GBASE_SFPP_CU
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_TWINAX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_10GBASE_SR
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_SR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_10GBASE_LR
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_LR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_10GBASE_T
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_40GBASE_CR4
operator|)
operator|||
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_40GBASE_CR4_CU
operator|)
operator|||
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_40GBASE_AOC
operator|)
operator|||
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_XLAUI
operator|)
operator|||
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_40GBASE_KR4
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_40G_CR4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_40GBASE_SR4
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_40G_SR4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_40GBASE_LR4
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_40G_LR4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_1000BASE_KX
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_KX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_10GBASE_CR1_CU
operator|)
operator|||
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_10GBASE_CR1
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_CR1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_10GBASE_AOC
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_TWINAX_LONG
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_SFI
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_SFI
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_10GBASE_KX4
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_KX4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_10GBASE_KR
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_KR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_20GBASE_KR2
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_20G_KR2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_40GBASE_KR4
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_40G_KR4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_XLPPI
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_40G_XLPPI
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_25GBASE_KR
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_25G_KR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_25GBASE_CR
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_25G_CR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_25GBASE_SR
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_25G_SR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_types
operator|&
operator|(
name|I40E_CAP_PHY_TYPE_25GBASE_LR
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_UNKNOWN
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup networking device structure and register an interface.  *  **********************************************************************/
end_comment

begin_function
name|int
name|ixl_setup_interface
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|i40e_aq_get_phy_abilities_resp
name|abilities
decl_stmt|;
name|enum
name|i40e_status_code
name|aq_error
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_setup_interface: begin"
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|vsi
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not allocate ifnet structure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ixl_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|vsi
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ixl_ioctl
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100036
name|if_setgetcounterfn
argument_list|(
name|ifp
argument_list|,
name|ixl_get_counter
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_transmit
operator|=
name|ixl_mq_start
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|ixl_qflush
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|que
operator|->
name|num_desc
operator|-
literal|2
expr_stmt|;
name|vsi
operator|->
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
comment|/* Set TSO limits */
name|ifp
operator|->
name|if_hw_tsomax
operator|=
name|IP_MAXPACKET
operator|-
operator|(
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomaxsegcount
operator|=
name|IXL_MAX_TSO_SEGS
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomaxsegsize
operator|=
name|PAGE_SIZE
expr_stmt|;
comment|/* 	 * Tell the upper layer(s) we support long frames. 	 */
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_HWCSUM_IPV6
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TSO
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_JUMBO_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_LRO
expr_stmt|;
comment|/* VLAN capabilties */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_HWTSO
operator||
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* 	** Don't turn this on by default, if vlans are 	** created on another pseudo device (eg. lagg) 	** then vlan events are not passed thru, breaking 	** operation, but with HW FILTER off it works. If 	** using vlans directly on the ixl driver you can 	** enable this and get full hardware tag filtering. 	*/
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
comment|/* 	 * Specify the media types supported by this adapter and register 	 * callbacks to update media and link information 	 */
name|ifmedia_init
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|ixl_media_change
argument_list|,
name|ixl_media_status
argument_list|)
expr_stmt|;
name|aq_error
operator|=
name|i40e_aq_get_phy_capabilities
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
operator|&
name|abilities
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* May need delay to detect fiber correctly */
if|if
condition|(
name|aq_error
operator|==
name|I40E_ERR_UNKNOWN_PHY
condition|)
block|{
name|i40e_msec_delay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|aq_error
operator|=
name|i40e_aq_get_phy_capabilities
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
operator|&
name|abilities
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aq_error
condition|)
block|{
if|if
condition|(
name|aq_error
operator|==
name|I40E_ERR_UNKNOWN_PHY
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unknown PHY type detected!\n"
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error getting supported media types, err %d,"
literal|" AQ error %d\n"
argument_list|,
name|aq_error
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pf
operator|->
name|supported_speeds
operator|=
name|abilities
operator|.
name|link_speed
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
name|ixl_max_aq_speed_to_value
argument_list|(
name|pf
operator|->
name|supported_speeds
argument_list|)
expr_stmt|;
name|ixl_add_ifmedia
argument_list|(
name|vsi
argument_list|,
name|hw
operator|->
name|phy
operator|.
name|phy_types
argument_list|)
expr_stmt|;
comment|/* Use autoselect media by default */
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Run when the Admin Queue gets a link state change interrupt. */
end_comment

begin_function
name|void
name|ixl_link_event
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|i40e_arq_event_info
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|i40e_aqc_get_link_status
modifier|*
name|status
init|=
operator|(
expr|struct
name|i40e_aqc_get_link_status
operator|*
operator|)
operator|&
name|e
operator|->
name|desc
operator|.
name|params
operator|.
name|raw
decl_stmt|;
comment|/* Request link status from adapter */
name|hw
operator|->
name|phy
operator|.
name|get_link_info
operator|=
name|TRUE
expr_stmt|;
name|i40e_get_link_status
argument_list|(
name|hw
argument_list|,
operator|&
name|pf
operator|->
name|link_up
argument_list|)
expr_stmt|;
comment|/* Print out message if an unqualified module is found */
if|if
condition|(
operator|(
name|status
operator|->
name|link_info
operator|&
name|I40E_AQ_MEDIA_AVAILABLE
operator|)
operator|&&
operator|(
operator|!
operator|(
name|status
operator|->
name|an_info
operator|&
name|I40E_AQ_QUALIFIED_MODULE
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|status
operator|->
name|link_info
operator|&
name|I40E_AQ_LINK_UP
operator|)
operator|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link failed because "
literal|"an unqualified module was detected!\n"
argument_list|)
expr_stmt|;
comment|/* Update OS link info */
name|ixl_update_link_status
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Get Firmware Switch configuration  *	- this will need to be more robust when more complex  *	  switch configurations are enabled.  *  **********************************************************************/
end_comment

begin_function
name|int
name|ixl_switch_config
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|device_t
name|dev
init|=
name|vsi
operator|->
name|dev
decl_stmt|;
name|struct
name|i40e_aqc_get_switch_config_resp
modifier|*
name|sw_config
decl_stmt|;
name|u8
name|aq_buf
index|[
name|I40E_AQ_LARGE_BUF
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|u16
name|next
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|aq_buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|aq_buf
argument_list|)
argument_list|)
expr_stmt|;
name|sw_config
operator|=
operator|(
expr|struct
name|i40e_aqc_get_switch_config_resp
operator|*
operator|)
name|aq_buf
expr_stmt|;
name|ret
operator|=
name|i40e_aq_get_switch_config
argument_list|(
name|hw
argument_list|,
name|sw_config
argument_list|,
sizeof|sizeof
argument_list|(
name|aq_buf
argument_list|)
argument_list|,
operator|&
name|next
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"aq_get_switch_config() failed, error %d,"
literal|" aq_error %d\n"
argument_list|,
name|ret
argument_list|,
name|pf
operator|->
name|hw
operator|.
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
name|pf
operator|->
name|dbg_mask
operator|&
name|IXL_DBG_SWITCH_INFO
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Switch config: header reported: %d in structure, %d total\n"
argument_list|,
name|sw_config
operator|->
name|header
operator|.
name|num_reported
argument_list|,
name|sw_config
operator|->
name|header
operator|.
name|num_total
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sw_config
operator|->
name|header
operator|.
name|num_reported
condition|;
name|i
operator|++
control|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"-> %d: type=%d seid=%d uplink=%d downlink=%d\n"
argument_list|,
name|i
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|element_type
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|seid
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|uplink_seid
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|downlink_seid
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Simplified due to a single VSI */
name|vsi
operator|->
name|uplink_seid
operator|=
name|sw_config
operator|->
name|element
index|[
literal|0
index|]
operator|.
name|uplink_seid
expr_stmt|;
name|vsi
operator|->
name|downlink_seid
operator|=
name|sw_config
operator|->
name|element
index|[
literal|0
index|]
operator|.
name|downlink_seid
expr_stmt|;
name|vsi
operator|->
name|seid
operator|=
name|sw_config
operator|->
name|element
index|[
literal|0
index|]
operator|.
name|seid
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize the VSI:  this handles contexts, which means things  *  			 like the number of descriptors, buffer size,  *			 plus we init the rings thru this function.  *  **********************************************************************/
end_comment

begin_function
name|int
name|ixl_initialize_vsi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|device_t
name|dev
init|=
name|vsi
operator|->
name|dev
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|i40e_vsi_context
name|ctxt
decl_stmt|;
name|int
name|tc_queues
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ctxt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctxt
argument_list|)
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|seid
operator|=
name|vsi
operator|->
name|seid
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|veb_seid
operator|!=
literal|0
condition|)
name|ctxt
operator|.
name|uplink_seid
operator|=
name|pf
operator|->
name|veb_seid
expr_stmt|;
name|ctxt
operator|.
name|pf_num
operator|=
name|hw
operator|->
name|pf_id
expr_stmt|;
name|err
operator|=
name|i40e_aq_get_vsi_params
argument_list|(
name|hw
argument_list|,
operator|&
name|ctxt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"i40e_aq_get_vsi_params() failed, error %d"
literal|" aq_error %d\n"
argument_list|,
name|err
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|ixl_dbg
argument_list|(
name|pf
argument_list|,
name|IXL_DBG_SWITCH_INFO
argument_list|,
literal|"get_vsi_params: seid: %d, uplinkseid: %d, vsi_number: %d, "
literal|"vsis_allocated: %d, vsis_unallocated: %d, flags: 0x%x, "
literal|"pfnum: %d, vfnum: %d, stat idx: %d, enabled: %d\n"
argument_list|,
name|ctxt
operator|.
name|seid
argument_list|,
name|ctxt
operator|.
name|uplink_seid
argument_list|,
name|ctxt
operator|.
name|vsi_number
argument_list|,
name|ctxt
operator|.
name|vsis_allocated
argument_list|,
name|ctxt
operator|.
name|vsis_unallocated
argument_list|,
name|ctxt
operator|.
name|flags
argument_list|,
name|ctxt
operator|.
name|pf_num
argument_list|,
name|ctxt
operator|.
name|vf_num
argument_list|,
name|ctxt
operator|.
name|info
operator|.
name|stat_counter_idx
argument_list|,
name|ctxt
operator|.
name|info
operator|.
name|up_enable_bits
argument_list|)
expr_stmt|;
comment|/* 	** Set the queue and traffic class bits 	**  - when multiple traffic classes are supported 	**    this will need to be more robust. 	*/
name|ctxt
operator|.
name|info
operator|.
name|valid_sections
operator|=
name|I40E_AQ_VSI_PROP_QUEUE_MAP_VALID
expr_stmt|;
name|ctxt
operator|.
name|info
operator|.
name|mapping_flags
operator||=
name|I40E_AQ_VSI_QUE_MAP_CONTIG
expr_stmt|;
comment|/* In contig mode, que_mapping[0] is first queue index used by this VSI */
name|ctxt
operator|.
name|info
operator|.
name|queue_mapping
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * This VSI will only use traffic class 0; start traffic class 0's 	 * queue allocation at queue 0, and assign it 2^tc_queues queues (though 	 * the driver may not use all of them). 	 */
name|tc_queues
operator|=
name|bsrl
argument_list|(
name|pf
operator|->
name|qtag
operator|.
name|num_allocated
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|info
operator|.
name|tc_mapping
index|[
literal|0
index|]
operator|=
operator|(
operator|(
literal|0
operator|<<
name|I40E_AQ_VSI_TC_QUE_OFFSET_SHIFT
operator|)
operator|&
name|I40E_AQ_VSI_TC_QUE_OFFSET_MASK
operator|)
operator||
operator|(
operator|(
name|tc_queues
operator|<<
name|I40E_AQ_VSI_TC_QUE_NUMBER_SHIFT
operator|)
operator|&
name|I40E_AQ_VSI_TC_QUE_NUMBER_MASK
operator|)
expr_stmt|;
comment|/* Set VLAN receive stripping mode */
name|ctxt
operator|.
name|info
operator|.
name|valid_sections
operator||=
name|I40E_AQ_VSI_PROP_VLAN_VALID
expr_stmt|;
name|ctxt
operator|.
name|info
operator|.
name|port_vlan_flags
operator|=
name|I40E_AQ_VSI_PVLAN_MODE_ALL
expr_stmt|;
if|if
condition|(
name|vsi
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
name|ctxt
operator|.
name|info
operator|.
name|port_vlan_flags
operator||=
name|I40E_AQ_VSI_PVLAN_EMOD_STR_BOTH
expr_stmt|;
else|else
name|ctxt
operator|.
name|info
operator|.
name|port_vlan_flags
operator||=
name|I40E_AQ_VSI_PVLAN_EMOD_NOTHING
expr_stmt|;
ifdef|#
directive|ifdef
name|IXL_IW
comment|/* Set TCP Enable for iWARP capable VSI */
if|if
condition|(
name|ixl_enable_iwarp
operator|&&
name|pf
operator|->
name|iw_enabled
condition|)
block|{
name|ctxt
operator|.
name|info
operator|.
name|valid_sections
operator||=
name|htole16
argument_list|(
name|I40E_AQ_VSI_PROP_QUEUE_OPT_VALID
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|info
operator|.
name|queueing_opt_flags
operator||=
name|I40E_AQ_VSI_QUE_OPT_TCP_ENA
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Save VSI number and info for use later */
name|vsi
operator|->
name|vsi_num
operator|=
name|ctxt
operator|.
name|vsi_number
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ctxt
operator|.
name|info
argument_list|,
operator|&
name|vsi
operator|->
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|vsi
operator|->
name|info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reset VSI statistics */
name|ixl_vsi_reset_stats
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|hw_filters_add
operator|=
literal|0
expr_stmt|;
name|vsi
operator|->
name|hw_filters_del
operator|=
literal|0
expr_stmt|;
name|ctxt
operator|.
name|flags
operator|=
name|htole16
argument_list|(
name|I40E_AQ_VSI_TYPE_PF
argument_list|)
expr_stmt|;
name|err
operator|=
name|i40e_aq_update_vsi_params
argument_list|(
name|hw
argument_list|,
operator|&
name|ctxt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"i40e_aq_update_vsi_params() failed, error %d,"
literal|" aq_error %d\n"
argument_list|,
name|err
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|struct
name|i40e_hmc_obj_txq
name|tctx
decl_stmt|;
name|struct
name|i40e_hmc_obj_rxq
name|rctx
decl_stmt|;
name|u32
name|txctl
decl_stmt|;
name|u16
name|size
decl_stmt|;
comment|/* Setup the HMC TX Context  */
name|size
operator|=
name|que
operator|->
name|num_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_tx_desc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|tctx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_hmc_obj_txq
argument_list|)
argument_list|)
expr_stmt|;
name|tctx
operator|.
name|new_context
operator|=
literal|1
expr_stmt|;
name|tctx
operator|.
name|base
operator|=
operator|(
name|txr
operator|->
name|dma
operator|.
name|pa
operator|/
name|IXL_TX_CTX_BASE_UNITS
operator|)
expr_stmt|;
name|tctx
operator|.
name|qlen
operator|=
name|que
operator|->
name|num_desc
expr_stmt|;
name|tctx
operator|.
name|fc_ena
operator|=
literal|0
expr_stmt|;
name|tctx
operator|.
name|rdylist
operator|=
name|vsi
operator|->
name|info
operator|.
name|qs_handle
index|[
literal|0
index|]
expr_stmt|;
comment|/* index is TC */
comment|/* Enable HEAD writeback */
name|tctx
operator|.
name|head_wb_ena
operator|=
literal|1
expr_stmt|;
name|tctx
operator|.
name|head_wb_addr
operator|=
name|txr
operator|->
name|dma
operator|.
name|pa
operator|+
operator|(
name|que
operator|->
name|num_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_tx_desc
argument_list|)
operator|)
expr_stmt|;
name|tctx
operator|.
name|rdylist_act
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|i40e_clear_lan_tx_queue_context
argument_list|(
name|hw
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to clear TX context\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|i40e_set_lan_tx_queue_context
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
operator|&
name|tctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to set TX context\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Associate the ring with this PF */
name|txctl
operator|=
name|I40E_QTX_CTL_PF_QUEUE
expr_stmt|;
name|txctl
operator||=
operator|(
operator|(
name|hw
operator|->
name|pf_id
operator|<<
name|I40E_QTX_CTL_PF_INDX_SHIFT
operator|)
operator|&
name|I40E_QTX_CTL_PF_INDX_MASK
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_CTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|txctl
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Do ring (re)init */
name|ixl_init_tx_ring
argument_list|(
name|que
argument_list|)
expr_stmt|;
comment|/* Next setup the HMC RX Context  */
if|if
condition|(
name|vsi
operator|->
name|max_frame_size
operator|<=
name|MCLBYTES
condition|)
name|rxr
operator|->
name|mbuf_sz
operator|=
name|MCLBYTES
expr_stmt|;
else|else
name|rxr
operator|->
name|mbuf_sz
operator|=
name|MJUMPAGESIZE
expr_stmt|;
name|u16
name|max_rxmax
init|=
name|rxr
operator|->
name|mbuf_sz
operator|*
name|hw
operator|->
name|func_caps
operator|.
name|rx_buf_chain_len
decl_stmt|;
comment|/* Set up an RX context for the HMC */
name|memset
argument_list|(
operator|&
name|rctx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_hmc_obj_rxq
argument_list|)
argument_list|)
expr_stmt|;
name|rctx
operator|.
name|dbuff
operator|=
name|rxr
operator|->
name|mbuf_sz
operator|>>
name|I40E_RXQ_CTX_DBUFF_SHIFT
expr_stmt|;
comment|/* ignore header split for now */
name|rctx
operator|.
name|hbuff
operator|=
literal|0
operator|>>
name|I40E_RXQ_CTX_HBUFF_SHIFT
expr_stmt|;
name|rctx
operator|.
name|rxmax
operator|=
operator|(
name|vsi
operator|->
name|max_frame_size
operator|<
name|max_rxmax
operator|)
condition|?
name|vsi
operator|->
name|max_frame_size
else|:
name|max_rxmax
expr_stmt|;
name|rctx
operator|.
name|dtype
operator|=
literal|0
expr_stmt|;
name|rctx
operator|.
name|dsize
operator|=
literal|1
expr_stmt|;
comment|/* do 32byte descriptors */
name|rctx
operator|.
name|hsplit_0
operator|=
literal|0
expr_stmt|;
comment|/* no HDR split initially */
name|rctx
operator|.
name|base
operator|=
operator|(
name|rxr
operator|->
name|dma
operator|.
name|pa
operator|/
name|IXL_RX_CTX_BASE_UNITS
operator|)
expr_stmt|;
name|rctx
operator|.
name|qlen
operator|=
name|que
operator|->
name|num_desc
expr_stmt|;
name|rctx
operator|.
name|tphrdesc_ena
operator|=
literal|1
expr_stmt|;
name|rctx
operator|.
name|tphwdesc_ena
operator|=
literal|1
expr_stmt|;
name|rctx
operator|.
name|tphdata_ena
operator|=
literal|0
expr_stmt|;
name|rctx
operator|.
name|tphhead_ena
operator|=
literal|0
expr_stmt|;
name|rctx
operator|.
name|lrxqthresh
operator|=
literal|2
expr_stmt|;
name|rctx
operator|.
name|crcstrip
operator|=
literal|1
expr_stmt|;
name|rctx
operator|.
name|l2tsel
operator|=
literal|1
expr_stmt|;
name|rctx
operator|.
name|showiv
operator|=
literal|1
expr_stmt|;
name|rctx
operator|.
name|fc_ena
operator|=
literal|0
expr_stmt|;
name|rctx
operator|.
name|prefena
operator|=
literal|1
expr_stmt|;
name|err
operator|=
name|i40e_clear_lan_rx_queue_context
argument_list|(
name|hw
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to clear RX context %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|i40e_set_lan_rx_queue_context
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
operator|&
name|rctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to set RX context %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|ixl_init_rx_ring
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Fail in init_rx_ring %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* preserve queue */
if|if
condition|(
name|vsi
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
condition|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
decl_stmt|;
name|int
name|t
init|=
name|na
operator|->
name|num_rx_desc
operator|-
literal|1
operator|-
name|nm_kr_rxspace
argument_list|(
name|kring
argument_list|)
decl_stmt|;
name|wr32
argument_list|(
name|vsi
operator|->
name|hw
argument_list|,
name|I40E_QRX_TAIL
argument_list|(
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|wr32
argument_list|(
name|vsi
operator|->
name|hw
argument_list|,
name|I40E_QRX_TAIL
argument_list|(
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|que
operator|->
name|num_desc
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free all VSI structs.  *  **********************************************************************/
end_comment

begin_function
name|void
name|ixl_free_vsi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
comment|/* Free station queues */
if|if
condition|(
operator|!
name|vsi
operator|->
name|queues
condition|)
goto|goto
name|free_filters
goto|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|)
condition|)
comment|/* uninitialized */
continue|continue;
name|IXL_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixl_free_que_tx
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|base
condition|)
name|i40e_free_dma_mem
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|,
operator|&
name|txr
operator|->
name|dma
argument_list|)
expr_stmt|;
name|IXL_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|IXL_TX_LOCK_DESTROY
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|rxr
operator|->
name|mtx
argument_list|)
condition|)
comment|/* uninitialized */
continue|continue;
name|IXL_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
name|ixl_free_que_rx
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxr
operator|->
name|base
condition|)
name|i40e_free_dma_mem
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|,
operator|&
name|rxr
operator|->
name|dma
argument_list|)
expr_stmt|;
name|IXL_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
name|IXL_RX_LOCK_DESTROY
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|vsi
operator|->
name|queues
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free_filters
label|:
comment|/* Free VSI filter list */
name|ixl_free_mac_filters
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixl_free_mac_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|vsi
operator|->
name|ftl
argument_list|)
condition|)
block|{
name|f
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|vsi
operator|->
name|ftl
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|vsi
operator|->
name|ftl
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Fill out fields in queue struct and setup tx/rx memory and structs  */
end_comment

begin_function
specifier|static
name|int
name|ixl_setup_queue
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|,
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|rsize
decl_stmt|,
name|tsize
decl_stmt|;
name|que
operator|->
name|num_desc
operator|=
name|pf
operator|->
name|ringsz
expr_stmt|;
name|que
operator|->
name|me
operator|=
name|index
expr_stmt|;
name|que
operator|->
name|vsi
operator|=
name|vsi
expr_stmt|;
name|txr
operator|->
name|que
operator|=
name|que
expr_stmt|;
name|txr
operator|->
name|tail
operator|=
name|I40E_QTX_TAIL
argument_list|(
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
comment|/* Initialize the TX lock */
name|snprintf
argument_list|(
name|txr
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|txr
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:tx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|,
name|txr
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Create the TX descriptor ring */
name|tsize
operator|=
name|roundup2
argument_list|(
operator|(
name|que
operator|->
name|num_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_tx_desc
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|DBA_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|i40e_allocate_dma_mem
argument_list|(
name|hw
argument_list|,
operator|&
name|txr
operator|->
name|dma
argument_list|,
name|i40e_mem_reserved
argument_list|,
name|tsize
argument_list|,
name|DBA_ALIGN
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX Descriptor memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|txr
operator|->
name|base
operator|=
operator|(
expr|struct
name|i40e_tx_desc
operator|*
operator|)
name|txr
operator|->
name|dma
operator|.
name|va
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|txr
operator|->
name|base
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
comment|/* Now allocate transmit soft structs for the ring */
if|if
condition|(
name|ixl_allocate_tx_data
argument_list|(
name|que
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up TX structures\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate a buf ring */
name|txr
operator|->
name|br
operator|=
name|buf_ring_alloc
argument_list|(
name|DEFAULT_TXBRSZ
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
operator|&
name|txr
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|br
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up TX buf ring\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rsize
operator|=
name|roundup2
argument_list|(
name|que
operator|->
name|num_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|i40e_rx_desc
argument_list|)
argument_list|,
name|DBA_ALIGN
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|que
operator|=
name|que
expr_stmt|;
name|rxr
operator|->
name|tail
operator|=
name|I40E_QRX_TAIL
argument_list|(
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
comment|/* Initialize the RX side lock */
name|snprintf
argument_list|(
name|rxr
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|rxr
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:rx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|rxr
operator|->
name|mtx
argument_list|,
name|rxr
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|i40e_allocate_dma_mem
argument_list|(
name|hw
argument_list|,
operator|&
name|rxr
operator|->
name|dma
argument_list|,
name|i40e_mem_reserved
argument_list|,
name|rsize
argument_list|,
literal|4096
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate RX Descriptor memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rxr
operator|->
name|base
operator|=
operator|(
expr|union
name|i40e_rx_desc
operator|*
operator|)
name|rxr
operator|->
name|dma
operator|.
name|va
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rxr
operator|->
name|base
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
comment|/* Allocate receive soft structs for the ring*/
if|if
condition|(
name|ixl_allocate_rx_data
argument_list|(
name|que
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up receive structs\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|rxr
operator|->
name|base
condition|)
name|i40e_free_dma_mem
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|,
operator|&
name|rxr
operator|->
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|rxr
operator|->
name|mtx
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|rxr
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|br
condition|)
block|{
name|buf_ring_free
argument_list|(
name|txr
operator|->
name|br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|txr
operator|->
name|br
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|txr
operator|->
name|base
condition|)
name|i40e_free_dma_mem
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|,
operator|&
name|txr
operator|->
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate memory for the VSI (virtual station interface) and their  *  associated queues, rings and the descriptors associated with each,  *  called only once at attach.  *  **********************************************************************/
end_comment

begin_function
name|int
name|ixl_setup_stations
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|vsi
operator|=
operator|&
name|pf
operator|->
name|vsi
expr_stmt|;
name|vsi
operator|->
name|back
operator|=
operator|(
name|void
operator|*
operator|)
name|pf
expr_stmt|;
name|vsi
operator|->
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
name|vsi
operator|->
name|id
operator|=
literal|0
expr_stmt|;
name|vsi
operator|->
name|num_vlans
operator|=
literal|0
expr_stmt|;
name|vsi
operator|->
name|back
operator|=
name|pf
expr_stmt|;
comment|/* Get memory for the station queues */
if|if
condition|(
operator|!
operator|(
name|vsi
operator|->
name|queues
operator|=
operator|(
expr|struct
name|ixl_queue
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixl_queue
argument_list|)
operator|*
name|vsi
operator|->
name|num_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate queue memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Then setup each queue */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|que
operator|=
operator|&
name|vsi
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
name|error
operator|=
name|ixl_setup_queue
argument_list|(
name|que
argument_list|,
name|pf
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Provide a update to the queue RX ** interrupt moderation value. */
end_comment

begin_function
name|void
name|ixl_set_queue_rx_itr
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|u16
name|rx_itr
decl_stmt|;
name|u16
name|rx_latency
init|=
literal|0
decl_stmt|;
name|int
name|rx_bytes
decl_stmt|;
comment|/* Idle, do nothing */
if|if
condition|(
name|rxr
operator|->
name|bytes
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|pf
operator|->
name|dynamic_rx_itr
condition|)
block|{
name|rx_bytes
operator|=
name|rxr
operator|->
name|bytes
operator|/
name|rxr
operator|->
name|itr
expr_stmt|;
name|rx_itr
operator|=
name|rxr
operator|->
name|itr
expr_stmt|;
comment|/* Adjust latency range */
switch|switch
condition|(
name|rxr
operator|->
name|latency
condition|)
block|{
case|case
name|IXL_LOW_LATENCY
case|:
if|if
condition|(
name|rx_bytes
operator|>
literal|10
condition|)
block|{
name|rx_latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|rx_itr
operator|=
name|IXL_ITR_20K
expr_stmt|;
block|}
break|break;
case|case
name|IXL_AVE_LATENCY
case|:
if|if
condition|(
name|rx_bytes
operator|>
literal|20
condition|)
block|{
name|rx_latency
operator|=
name|IXL_BULK_LATENCY
expr_stmt|;
name|rx_itr
operator|=
name|IXL_ITR_8K
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rx_bytes
operator|<=
literal|10
condition|)
block|{
name|rx_latency
operator|=
name|IXL_LOW_LATENCY
expr_stmt|;
name|rx_itr
operator|=
name|IXL_ITR_100K
expr_stmt|;
block|}
break|break;
case|case
name|IXL_BULK_LATENCY
case|:
if|if
condition|(
name|rx_bytes
operator|<=
literal|20
condition|)
block|{
name|rx_latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|rx_itr
operator|=
name|IXL_ITR_20K
expr_stmt|;
block|}
break|break;
block|}
name|rxr
operator|->
name|latency
operator|=
name|rx_latency
expr_stmt|;
if|if
condition|(
name|rx_itr
operator|!=
name|rxr
operator|->
name|itr
condition|)
block|{
comment|/* do an exponential smoothing */
name|rx_itr
operator|=
operator|(
literal|10
operator|*
name|rx_itr
operator|*
name|rxr
operator|->
name|itr
operator|)
operator|/
operator|(
operator|(
literal|9
operator|*
name|rx_itr
operator|)
operator|+
name|rxr
operator|->
name|itr
operator|)
expr_stmt|;
name|rxr
operator|->
name|itr
operator|=
name|min
argument_list|(
name|rx_itr
argument_list|,
name|IXL_MAX_ITR
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITRN
argument_list|(
name|IXL_RX_ITR
argument_list|,
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|rxr
operator|->
name|itr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We may have have toggled to non-dynamic */
if|if
condition|(
name|vsi
operator|->
name|rx_itr_setting
operator|&
name|IXL_ITR_DYNAMIC
condition|)
name|vsi
operator|->
name|rx_itr_setting
operator|=
name|pf
operator|->
name|rx_itr
expr_stmt|;
comment|/* Update the hardware if needed */
if|if
condition|(
name|rxr
operator|->
name|itr
operator|!=
name|vsi
operator|->
name|rx_itr_setting
condition|)
block|{
name|rxr
operator|->
name|itr
operator|=
name|vsi
operator|->
name|rx_itr_setting
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITRN
argument_list|(
name|IXL_RX_ITR
argument_list|,
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|rxr
operator|->
name|itr
argument_list|)
expr_stmt|;
block|}
block|}
name|rxr
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|packets
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** Provide a update to the queue TX ** interrupt moderation value. */
end_comment

begin_function
name|void
name|ixl_set_queue_tx_itr
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|u16
name|tx_itr
decl_stmt|;
name|u16
name|tx_latency
init|=
literal|0
decl_stmt|;
name|int
name|tx_bytes
decl_stmt|;
comment|/* Idle, do nothing */
if|if
condition|(
name|txr
operator|->
name|bytes
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|pf
operator|->
name|dynamic_tx_itr
condition|)
block|{
name|tx_bytes
operator|=
name|txr
operator|->
name|bytes
operator|/
name|txr
operator|->
name|itr
expr_stmt|;
name|tx_itr
operator|=
name|txr
operator|->
name|itr
expr_stmt|;
switch|switch
condition|(
name|txr
operator|->
name|latency
condition|)
block|{
case|case
name|IXL_LOW_LATENCY
case|:
if|if
condition|(
name|tx_bytes
operator|>
literal|10
condition|)
block|{
name|tx_latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|tx_itr
operator|=
name|IXL_ITR_20K
expr_stmt|;
block|}
break|break;
case|case
name|IXL_AVE_LATENCY
case|:
if|if
condition|(
name|tx_bytes
operator|>
literal|20
condition|)
block|{
name|tx_latency
operator|=
name|IXL_BULK_LATENCY
expr_stmt|;
name|tx_itr
operator|=
name|IXL_ITR_8K
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tx_bytes
operator|<=
literal|10
condition|)
block|{
name|tx_latency
operator|=
name|IXL_LOW_LATENCY
expr_stmt|;
name|tx_itr
operator|=
name|IXL_ITR_100K
expr_stmt|;
block|}
break|break;
case|case
name|IXL_BULK_LATENCY
case|:
if|if
condition|(
name|tx_bytes
operator|<=
literal|20
condition|)
block|{
name|tx_latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|tx_itr
operator|=
name|IXL_ITR_20K
expr_stmt|;
block|}
break|break;
block|}
name|txr
operator|->
name|latency
operator|=
name|tx_latency
expr_stmt|;
if|if
condition|(
name|tx_itr
operator|!=
name|txr
operator|->
name|itr
condition|)
block|{
comment|/* do an exponential smoothing */
name|tx_itr
operator|=
operator|(
literal|10
operator|*
name|tx_itr
operator|*
name|txr
operator|->
name|itr
operator|)
operator|/
operator|(
operator|(
literal|9
operator|*
name|tx_itr
operator|)
operator|+
name|txr
operator|->
name|itr
operator|)
expr_stmt|;
name|txr
operator|->
name|itr
operator|=
name|min
argument_list|(
name|tx_itr
argument_list|,
name|IXL_MAX_ITR
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITRN
argument_list|(
name|IXL_TX_ITR
argument_list|,
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|txr
operator|->
name|itr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We may have have toggled to non-dynamic */
if|if
condition|(
name|vsi
operator|->
name|tx_itr_setting
operator|&
name|IXL_ITR_DYNAMIC
condition|)
name|vsi
operator|->
name|tx_itr_setting
operator|=
name|pf
operator|->
name|tx_itr
expr_stmt|;
comment|/* Update the hardware if needed */
if|if
condition|(
name|txr
operator|->
name|itr
operator|!=
name|vsi
operator|->
name|tx_itr_setting
condition|)
block|{
name|txr
operator|->
name|itr
operator|=
name|vsi
operator|->
name|tx_itr_setting
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITRN
argument_list|(
name|IXL_TX_ITR
argument_list|,
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|txr
operator|->
name|itr
argument_list|)
expr_stmt|;
block|}
block|}
name|txr
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|packets
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ixl_add_vsi_sysctls
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|sysctl_name
parameter_list|)
block|{
name|struct
name|sysctl_oid
modifier|*
name|tree
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|vsi_list
decl_stmt|;
name|tree
operator|=
name|device_get_sysctl_tree
argument_list|(
name|pf
operator|->
name|dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|vsi_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|sysctl_name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"VSI Number"
argument_list|)
expr_stmt|;
name|vsi_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|vsi
operator|->
name|vsi_node
argument_list|)
expr_stmt|;
name|ixl_add_sysctls_eth_stats
argument_list|(
name|ctx
argument_list|,
name|vsi_list
argument_list|,
operator|&
name|vsi
operator|->
name|eth_stats
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IXL_DEBUG
end_ifdef

begin_comment
comment|/**  * ixl_sysctl_qtx_tail_handler  * Retrieves I40E_QTX_TAIL value from hardware  * for a sysctl.  */
end_comment

begin_function
specifier|static
name|int
name|ixl_sysctl_qtx_tail_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|que
operator|=
operator|(
operator|(
expr|struct
name|ixl_queue
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|que
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|rd32
argument_list|(
name|que
operator|->
name|vsi
operator|->
name|hw
argument_list|,
name|que
operator|->
name|txr
operator|.
name|tail
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixl_sysctl_qrx_tail_handler  * Retrieves I40E_QRX_TAIL value from hardware  * for a sysctl.  */
end_comment

begin_function
specifier|static
name|int
name|ixl_sysctl_qrx_tail_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|que
operator|=
operator|(
operator|(
expr|struct
name|ixl_queue
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|que
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|rd32
argument_list|(
name|que
operator|->
name|vsi
operator|->
name|hw
argument_list|,
name|que
operator|->
name|rxr
operator|.
name|tail
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Used to set the Tx ITR value for all of the PF LAN VSI's queues.  * Writes to the ITR registers immediately.  */
end_comment

begin_function
specifier|static
name|int
name|ixl_sysctl_pf_tx_itr
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|requested_tx_itr
decl_stmt|;
name|requested_tx_itr
operator|=
name|pf
operator|->
name|tx_itr
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|requested_tx_itr
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|pf
operator|->
name|dynamic_tx_itr
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot set TX itr value while dynamic TX itr is enabled\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|requested_tx_itr
operator|<
literal|0
operator|||
name|requested_tx_itr
operator|>
name|IXL_MAX_ITR
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid TX itr value; value must be between 0 and %d\n"
argument_list|,
name|IXL_MAX_ITR
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|pf
operator|->
name|tx_itr
operator|=
name|requested_tx_itr
expr_stmt|;
name|ixl_configure_tx_itr
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Used to set the Rx ITR value for all of the PF LAN VSI's queues.  * Writes to the ITR registers immediately.  */
end_comment

begin_function
specifier|static
name|int
name|ixl_sysctl_pf_rx_itr
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|requested_rx_itr
decl_stmt|;
name|requested_rx_itr
operator|=
name|pf
operator|->
name|rx_itr
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|requested_rx_itr
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|pf
operator|->
name|dynamic_rx_itr
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot set RX itr value while dynamic RX itr is enabled\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|requested_rx_itr
operator|<
literal|0
operator|||
name|requested_rx_itr
operator|>
name|IXL_MAX_ITR
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid RX itr value; value must be between 0 and %d\n"
argument_list|,
name|IXL_MAX_ITR
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|pf
operator|->
name|rx_itr
operator|=
name|requested_rx_itr
expr_stmt|;
name|ixl_configure_rx_itr
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ixl_add_hw_stats
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|queues
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|i40e_hw_port_stats
modifier|*
name|pf_stats
init|=
operator|&
name|pf
operator|->
name|stats
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|vsi_list
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|queue_node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|queue_list
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
decl_stmt|;
name|char
name|queue_namebuf
index|[
name|QUEUE_NAME_LEN
index|]
decl_stmt|;
comment|/* Driver statistics */
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"watchdog_events"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pf
operator|->
name|watchdog_events
argument_list|,
literal|"Watchdog timeouts"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"admin_irq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pf
operator|->
name|admin_irq
argument_list|,
literal|"Admin Queue IRQ Handled"
argument_list|)
expr_stmt|;
name|ixl_add_vsi_sysctls
argument_list|(
name|pf
argument_list|,
operator|&
name|pf
operator|->
name|vsi
argument_list|,
name|ctx
argument_list|,
literal|"pf"
argument_list|)
expr_stmt|;
name|vsi_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|pf
operator|->
name|vsi
operator|.
name|vsi_node
argument_list|)
expr_stmt|;
comment|/* Queue statistics */
for|for
control|(
name|int
name|q
init|=
literal|0
init|;
name|q
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|q
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|queue_namebuf
argument_list|,
name|QUEUE_NAME_LEN
argument_list|,
literal|"que%d"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|queue_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|vsi_list
argument_list|,
name|OID_AUTO
argument_list|,
name|queue_namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Queue #"
argument_list|)
expr_stmt|;
name|queue_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue_node
argument_list|)
expr_stmt|;
name|txr
operator|=
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|txr
operator|)
expr_stmt|;
name|rxr
operator|=
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|rxr
operator|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_defrag_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|mbuf_defrag_failed
operator|)
argument_list|,
literal|"m_defrag() failed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"irqs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|irqs
operator|)
argument_list|,
literal|"irqs on this queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tso_tx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|tso
operator|)
argument_list|,
literal|"TSO"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_dmamap_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|tx_dmamap_failed
operator|)
argument_list|,
literal|"Driver tx dma failure in xmit"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mss_too_small"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|mss_too_small
operator|)
argument_list|,
literal|"TSO sends with an MSS less than 64"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"no_desc_avail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|txr
operator|->
name|no_desc
operator|)
argument_list|,
literal|"Queue No Descriptor Available"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|txr
operator|->
name|total_packets
operator|)
argument_list|,
literal|"Queue Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_bytes"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|txr
operator|->
name|tx_bytes
operator|)
argument_list|,
literal|"Queue Bytes Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|rxr
operator|->
name|rx_packets
operator|)
argument_list|,
literal|"Queue Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_bytes"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|rxr
operator|->
name|rx_bytes
operator|)
argument_list|,
literal|"Queue Bytes Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_desc_err"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|rxr
operator|->
name|desc_errs
operator|)
argument_list|,
literal|"Queue Rx Descriptor Errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_itr"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|rxr
operator|->
name|itr
operator|)
argument_list|,
literal|0
argument_list|,
literal|"Queue Rx ITR Interval"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_itr"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|txr
operator|->
name|itr
operator|)
argument_list|,
literal|0
argument_list|,
literal|"Queue Tx ITR Interval"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXL_DEBUG
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_not_done"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|rxr
operator|->
name|not_done
operator|)
argument_list|,
literal|"Queue Rx Descriptors not Done"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_next_refresh"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|rxr
operator|->
name|next_refresh
operator|)
argument_list|,
literal|0
argument_list|,
literal|"Queue Rx Descriptors not Done"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_next_check"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|rxr
operator|->
name|next_check
operator|)
argument_list|,
literal|0
argument_list|,
literal|"Queue Rx Descriptors not Done"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"qtx_tail"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|queues
index|[
name|q
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ixl_queue
argument_list|)
argument_list|,
name|ixl_sysctl_qtx_tail_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Queue Transmit Descriptor Tail"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"qrx_tail"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|queues
index|[
name|q
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ixl_queue
argument_list|)
argument_list|,
name|ixl_sysctl_qrx_tail_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Queue Receive Descriptor Tail"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* MAC stats */
name|ixl_add_sysctls_mac_stats
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|pf_stats
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixl_add_sysctls_eth_stats
parameter_list|(
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
parameter_list|,
name|struct
name|sysctl_oid_list
modifier|*
name|child
parameter_list|,
name|struct
name|i40e_eth_stats
modifier|*
name|eth_stats
parameter_list|)
block|{
name|struct
name|ixl_sysctl_info
name|ctls
index|[]
init|=
block|{
block|{
operator|&
name|eth_stats
operator|->
name|rx_bytes
block|,
literal|"good_octets_rcvd"
block|,
literal|"Good Octets Received"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|rx_unicast
block|,
literal|"ucast_pkts_rcvd"
block|,
literal|"Unicast Packets Received"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|rx_multicast
block|,
literal|"mcast_pkts_rcvd"
block|,
literal|"Multicast Packets Received"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|rx_broadcast
block|,
literal|"bcast_pkts_rcvd"
block|,
literal|"Broadcast Packets Received"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|rx_discards
block|,
literal|"rx_discards"
block|,
literal|"Discarded RX packets"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|tx_bytes
block|,
literal|"good_octets_txd"
block|,
literal|"Good Octets Transmitted"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|tx_unicast
block|,
literal|"ucast_pkts_txd"
block|,
literal|"Unicast Packets Transmitted"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|tx_multicast
block|,
literal|"mcast_pkts_txd"
block|,
literal|"Multicast Packets Transmitted"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|tx_broadcast
block|,
literal|"bcast_pkts_txd"
block|,
literal|"Broadcast Packets Transmitted"
block|}
block|,
comment|// end
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|struct
name|ixl_sysctl_info
modifier|*
name|entry
init|=
name|ctls
decl_stmt|;
while|while
condition|(
name|entry
operator|->
name|stat
operator|!=
literal|0
condition|)
block|{
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|entry
operator|->
name|stat
argument_list|,
name|entry
operator|->
name|description
argument_list|)
expr_stmt|;
name|entry
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ixl_add_sysctls_mac_stats
parameter_list|(
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
parameter_list|,
name|struct
name|sysctl_oid_list
modifier|*
name|child
parameter_list|,
name|struct
name|i40e_hw_port_stats
modifier|*
name|stats
parameter_list|)
block|{
name|struct
name|sysctl_oid
modifier|*
name|stat_node
init|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mac"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Mac Statistics"
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|stat_list
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|stat_node
argument_list|)
decl_stmt|;
name|struct
name|i40e_eth_stats
modifier|*
name|eth_stats
init|=
operator|&
name|stats
operator|->
name|eth
decl_stmt|;
name|ixl_add_sysctls_eth_stats
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|eth_stats
argument_list|)
expr_stmt|;
name|struct
name|ixl_sysctl_info
name|ctls
index|[]
init|=
block|{
block|{
operator|&
name|stats
operator|->
name|crc_errors
block|,
literal|"crc_errors"
block|,
literal|"CRC Errors"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|illegal_bytes
block|,
literal|"illegal_bytes"
block|,
literal|"Illegal Byte Errors"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|mac_local_faults
block|,
literal|"local_faults"
block|,
literal|"MAC Local Faults"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|mac_remote_faults
block|,
literal|"remote_faults"
block|,
literal|"MAC Remote Faults"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_length_errors
block|,
literal|"rx_length_errors"
block|,
literal|"Receive Length Errors"
block|}
block|,
comment|/* Packet Reception Stats */
block|{
operator|&
name|stats
operator|->
name|rx_size_64
block|,
literal|"rx_frames_64"
block|,
literal|"64 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_size_127
block|,
literal|"rx_frames_65_127"
block|,
literal|"65-127 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_size_255
block|,
literal|"rx_frames_128_255"
block|,
literal|"128-255 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_size_511
block|,
literal|"rx_frames_256_511"
block|,
literal|"256-511 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_size_1023
block|,
literal|"rx_frames_512_1023"
block|,
literal|"512-1023 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_size_1522
block|,
literal|"rx_frames_1024_1522"
block|,
literal|"1024-1522 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_size_big
block|,
literal|"rx_frames_big"
block|,
literal|"1523-9522 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_undersize
block|,
literal|"rx_undersize"
block|,
literal|"Undersized packets received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_fragments
block|,
literal|"rx_fragmented"
block|,
literal|"Fragmented packets received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_oversize
block|,
literal|"rx_oversized"
block|,
literal|"Oversized packets received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_jabber
block|,
literal|"rx_jabber"
block|,
literal|"Received Jabber"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|checksum_error
block|,
literal|"checksum_errors"
block|,
literal|"Checksum Errors"
block|}
block|,
comment|/* Packet Transmission Stats */
block|{
operator|&
name|stats
operator|->
name|tx_size_64
block|,
literal|"tx_frames_64"
block|,
literal|"64 byte frames transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|tx_size_127
block|,
literal|"tx_frames_65_127"
block|,
literal|"65-127 byte frames transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|tx_size_255
block|,
literal|"tx_frames_128_255"
block|,
literal|"128-255 byte frames transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|tx_size_511
block|,
literal|"tx_frames_256_511"
block|,
literal|"256-511 byte frames transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|tx_size_1023
block|,
literal|"tx_frames_512_1023"
block|,
literal|"512-1023 byte frames transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|tx_size_1522
block|,
literal|"tx_frames_1024_1522"
block|,
literal|"1024-1522 byte frames transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|tx_size_big
block|,
literal|"tx_frames_big"
block|,
literal|"1523-9522 byte frames transmitted"
block|}
block|,
comment|/* Flow control */
block|{
operator|&
name|stats
operator|->
name|link_xon_tx
block|,
literal|"xon_txd"
block|,
literal|"Link XON transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|link_xon_rx
block|,
literal|"xon_recvd"
block|,
literal|"Link XON received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|link_xoff_tx
block|,
literal|"xoff_txd"
block|,
literal|"Link XOFF transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|link_xoff_rx
block|,
literal|"xoff_recvd"
block|,
literal|"Link XOFF received"
block|}
block|,
comment|/* End */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|struct
name|ixl_sysctl_info
modifier|*
name|entry
init|=
name|ctls
decl_stmt|;
while|while
condition|(
name|entry
operator|->
name|stat
operator|!=
literal|0
condition|)
block|{
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|entry
operator|->
name|stat
argument_list|,
name|entry
operator|->
name|description
argument_list|)
expr_stmt|;
name|entry
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ixl_set_rss_key
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|enum
name|i40e_status_code
name|status
decl_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|u32
name|rss_seed
index|[
name|IXL_RSS_KEY_SIZE_REG
index|]
decl_stmt|;
else|#
directive|else
name|u32
name|rss_seed
index|[
name|IXL_RSS_KEY_SIZE_REG
index|]
init|=
block|{
literal|0x41b01687
block|,
literal|0x183cfd8c
block|,
literal|0xce880440
block|,
literal|0x580cbc3c
block|,
literal|0x35897377
block|,
literal|0x328b25e1
block|,
literal|0x4fa98922
block|,
literal|0xb7d90c14
block|,
literal|0xd5bad70d
block|,
literal|0xcd15a2c1
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|}
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RSS
comment|/* Fetch the configured RSS key */
name|rss_getkey
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|rss_seed
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Fill out hash function seed */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|I40E_MAC_X722
condition|)
block|{
name|struct
name|i40e_aqc_get_set_rss_key_data
name|key_data
decl_stmt|;
name|bcopy
argument_list|(
name|rss_seed
argument_list|,
name|key_data
operator|.
name|standard_rss_key
argument_list|,
literal|40
argument_list|)
expr_stmt|;
name|status
operator|=
name|i40e_aq_set_rss_key
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|vsi_num
argument_list|,
operator|&
name|key_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"i40e_aq_set_rss_key status %s, error %s\n"
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|status
argument_list|)
argument_list|,
name|i40e_aq_str
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IXL_RSS_KEY_SIZE_REG
condition|;
name|i
operator|++
control|)
name|i40e_write_rx_ctl
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HKEY
argument_list|(
name|i
argument_list|)
argument_list|,
name|rss_seed
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Configure enabled PCTYPES for RSS.  */
end_comment

begin_function
name|void
name|ixl_set_rss_pctypes
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|u64
name|set_hena
init|=
literal|0
decl_stmt|,
name|hena
decl_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|u32
name|rss_hash_config
decl_stmt|;
name|rss_hash_config
operator|=
name|rss_gethashconfig
argument_list|()
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_IPV4
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_OTHER
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_TCP_IPV4
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_TCP
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_UDP_IPV4
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_UDP
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_IPV6
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_OTHER
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_IPV6_EX
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_FRAG_IPV6
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_TCP_IPV6
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_TCP
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_UDP_IPV6
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_UDP
operator|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|I40E_MAC_X722
condition|)
name|set_hena
operator|=
name|IXL_DEFAULT_RSS_HENA_X722
expr_stmt|;
else|else
name|set_hena
operator|=
name|IXL_DEFAULT_RSS_HENA_XL710
expr_stmt|;
endif|#
directive|endif
name|hena
operator|=
operator|(
name|u64
operator|)
name|i40e_read_rx_ctl
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HENA
argument_list|(
literal|0
argument_list|)
argument_list|)
operator||
operator|(
operator|(
name|u64
operator|)
name|i40e_read_rx_ctl
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HENA
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|hena
operator||=
name|set_hena
expr_stmt|;
name|i40e_write_rx_ctl
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HENA
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|u32
operator|)
name|hena
argument_list|)
expr_stmt|;
name|i40e_write_rx_ctl
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HENA
argument_list|(
literal|1
argument_list|)
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|hena
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixl_set_rss_hlut
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|int
name|i
decl_stmt|,
name|que_id
decl_stmt|;
name|int
name|lut_entry_width
decl_stmt|;
name|u32
name|lut
init|=
literal|0
decl_stmt|;
name|enum
name|i40e_status_code
name|status
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|I40E_MAC_X722
condition|)
name|lut_entry_width
operator|=
literal|7
expr_stmt|;
else|else
name|lut_entry_width
operator|=
name|pf
operator|->
name|hw
operator|.
name|func_caps
operator|.
name|rss_table_entry_width
expr_stmt|;
comment|/* Populate the LUT with max no. of queues in round robin fashion */
name|u8
name|hlut_buf
index|[
literal|512
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pf
operator|->
name|hw
operator|.
name|func_caps
operator|.
name|rss_table_size
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|RSS
comment|/* 		 * Fetch the RSS bucket id for the given indirection entry. 		 * Cap it at the number of configured buckets (which is 		 * num_queues.) 		 */
name|que_id
operator|=
name|rss_get_indirection_to_bucket
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|que_id
operator|=
name|que_id
operator|%
name|vsi
operator|->
name|num_queues
expr_stmt|;
else|#
directive|else
name|que_id
operator|=
name|i
operator|%
name|vsi
operator|->
name|num_queues
expr_stmt|;
endif|#
directive|endif
name|lut
operator|=
operator|(
name|que_id
operator|&
operator|(
operator|(
literal|0x1
operator|<<
name|lut_entry_width
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|hlut_buf
index|[
name|i
index|]
operator|=
name|lut
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|I40E_MAC_X722
condition|)
block|{
name|status
operator|=
name|i40e_aq_set_rss_lut
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|vsi_num
argument_list|,
name|TRUE
argument_list|,
name|hlut_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|hlut_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"i40e_aq_set_rss_lut status %s, error %s\n"
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|status
argument_list|)
argument_list|,
name|i40e_aq_str
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pf
operator|->
name|hw
operator|.
name|func_caps
operator|.
name|rss_table_size
operator|>>
literal|2
condition|;
name|i
operator|++
control|)
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HLUT
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
operator|(
name|u32
operator|*
operator|)
name|hlut_buf
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** Setup the PF's RSS parameters. */
end_comment

begin_function
name|void
name|ixl_config_rss
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|ixl_set_rss_key
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_set_rss_pctypes
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_set_rss_hlut
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine is run via an vlan config EVENT, ** it enables us to use the HW Filter table since ** we can get the vlan id. This just creates the ** entry in the soft version of the VFTA, init will ** repopulate the real table. */
end_comment

begin_function
name|void
name|ixl_register_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
comment|/* Not our event */
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
operator|++
name|vsi
operator|->
name|num_vlans
expr_stmt|;
name|ixl_add_filter
argument_list|(
name|vsi
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|vtag
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine is run via an vlan ** unconfig EVENT, remove our entry ** in the soft vfta. */
end_comment

begin_function
name|void
name|ixl_unregister_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
operator|--
name|vsi
operator|->
name|num_vlans
expr_stmt|;
name|ixl_del_filter
argument_list|(
name|vsi
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|vtag
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine updates vlan filters, called by init ** it scans the filter table and then updates the hw ** after a soft reset. */
end_comment

begin_function
name|void
name|ixl_setup_vlan_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|,
name|flags
decl_stmt|;
if|if
condition|(
name|vsi
operator|->
name|num_vlans
operator|==
literal|0
condition|)
return|return;
comment|/* 	** Scan the filter list for vlan entries, 	** mark them for addition and then call 	** for the AQ update. 	*/
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_VLAN
condition|)
block|{
name|f
operator|->
name|flags
operator||=
operator|(
name|IXL_FILTER_ADD
operator||
name|IXL_FILTER_USED
operator|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"setup vlan: no filters found!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|flags
operator|=
name|IXL_FILTER_VLAN
expr_stmt|;
name|flags
operator||=
operator|(
name|IXL_FILTER_ADD
operator||
name|IXL_FILTER_USED
operator|)
expr_stmt|;
name|ixl_add_hw_filters
argument_list|(
name|vsi
argument_list|,
name|flags
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** Initialize filter list and add filters that the hardware ** needs to know about. ** ** Requires VSI's filter list& seid to be set before calling. */
end_comment

begin_function
name|void
name|ixl_init_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
comment|/* Add broadcast address */
name|ixl_add_filter
argument_list|(
name|vsi
argument_list|,
name|ixl_bcast_addr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
comment|/* 	 * Prevent Tx flow control frames from being sent out by 	 * non-firmware transmitters. 	 * This affects every VSI in the PF. 	 */
if|if
condition|(
name|pf
operator|->
name|enable_tx_fc_filter
condition|)
name|i40e_add_filter_to_drop_tx_flow_control_frames
argument_list|(
name|vsi
operator|->
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine adds mulicast filters */
end_comment

begin_function
name|void
name|ixl_add_mc_filter
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|u8
modifier|*
name|macaddr
parameter_list|)
block|{
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
comment|/* Does one already exist */
name|f
operator|=
name|ixl_find_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
return|return;
name|f
operator|=
name|ixl_get_filter
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: no filter available!!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
name|macaddr
argument_list|,
name|f
operator|->
name|macaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|f
operator|->
name|vlan
operator|=
name|IXL_VLAN_ANY
expr_stmt|;
name|f
operator|->
name|flags
operator||=
operator|(
name|IXL_FILTER_ADD
operator||
name|IXL_FILTER_USED
operator||
name|IXL_FILTER_MC
operator|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ixl_reconfigure_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|ixl_add_hw_filters
argument_list|(
name|vsi
argument_list|,
name|IXL_FILTER_USED
argument_list|,
name|vsi
operator|->
name|num_macs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine adds macvlan filters */
end_comment

begin_function
name|void
name|ixl_add_filter
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
specifier|const
name|u8
modifier|*
name|macaddr
parameter_list|,
name|s16
name|vlan
parameter_list|)
block|{
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|DEBUGOUT
argument_list|(
literal|"ixl_add_filter: begin"
argument_list|)
expr_stmt|;
name|pf
operator|=
name|vsi
operator|->
name|back
expr_stmt|;
name|dev
operator|=
name|pf
operator|->
name|dev
expr_stmt|;
comment|/* Does one already exist */
name|f
operator|=
name|ixl_find_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
name|vlan
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
return|return;
comment|/* 	** Is this the first vlan being registered, if so we 	** need to remove the ANY filter that indicates we are 	** not in a vlan, and replace that with a 0 filter. 	*/
if|if
condition|(
operator|(
name|vlan
operator|!=
name|IXL_VLAN_ANY
operator|)
operator|&&
operator|(
name|vsi
operator|->
name|num_vlans
operator|==
literal|1
operator|)
condition|)
block|{
name|tmp
operator|=
name|ixl_find_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
name|ixl_del_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
name|ixl_add_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|f
operator|=
name|ixl_get_filter
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"WARNING: no filter available!!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
name|macaddr
argument_list|,
name|f
operator|->
name|macaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|f
operator|->
name|vlan
operator|=
name|vlan
expr_stmt|;
name|f
operator|->
name|flags
operator||=
operator|(
name|IXL_FILTER_ADD
operator||
name|IXL_FILTER_USED
operator|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|vlan
operator|!=
name|IXL_VLAN_ANY
condition|)
name|f
operator|->
name|flags
operator||=
name|IXL_FILTER_VLAN
expr_stmt|;
else|else
name|vsi
operator|->
name|num_macs
operator|++
expr_stmt|;
name|ixl_add_hw_filters
argument_list|(
name|vsi
argument_list|,
name|f
operator|->
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ixl_del_filter
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
specifier|const
name|u8
modifier|*
name|macaddr
parameter_list|,
name|s16
name|vlan
parameter_list|)
block|{
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|ixl_find_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
name|vlan
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return;
name|f
operator|->
name|flags
operator||=
name|IXL_FILTER_DEL
expr_stmt|;
name|ixl_del_hw_filters
argument_list|(
name|vsi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|num_macs
operator|--
expr_stmt|;
comment|/* Check if this is the last vlan removal */
if|if
condition|(
name|vlan
operator|!=
name|IXL_VLAN_ANY
operator|&&
name|vsi
operator|->
name|num_vlans
operator|==
literal|0
condition|)
block|{
comment|/* Switch back to a non-vlan filter */
name|ixl_del_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ixl_add_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ** Find the filter with both matching mac addr and vlan id */
end_comment

begin_function
name|struct
name|ixl_mac_filter
modifier|*
name|ixl_find_filter
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
specifier|const
name|u8
modifier|*
name|macaddr
parameter_list|,
name|s16
name|vlan
parameter_list|)
block|{
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
name|bool
name|match
init|=
name|FALSE
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
operator|!
name|cmp_etheraddr
argument_list|(
name|f
operator|->
name|macaddr
argument_list|,
name|macaddr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|f
operator|->
name|vlan
operator|==
name|vlan
condition|)
block|{
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|match
condition|)
name|f
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** This routine takes additions to the vsi filter ** table and creates an Admin Queue call to create ** the filters in the hardware. */
end_comment

begin_function
name|void
name|ixl_add_hw_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|struct
name|i40e_aqc_add_macvlan_element_data
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|int
name|err
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|pf
operator|=
name|vsi
operator|->
name|back
expr_stmt|;
name|dev
operator|=
name|pf
operator|->
name|dev
expr_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
name|IXL_PF_LOCK_ASSERT
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|a
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_aqc_add_macvlan_element_data
argument_list|)
operator|*
name|cnt
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"add_hw_filters failed to get memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	** Scan the filter list, each time we find one 	** we add it to the admin queue array and turn off 	** the add bit. 	*/
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|f
operator|->
name|flags
operator|==
name|flags
condition|)
block|{
name|b
operator|=
operator|&
name|a
index|[
name|j
index|]
expr_stmt|;
comment|// a pox on fvl long names :)
name|bcopy
argument_list|(
name|f
operator|->
name|macaddr
argument_list|,
name|b
operator|->
name|mac_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|vlan
operator|==
name|IXL_VLAN_ANY
condition|)
block|{
name|b
operator|->
name|vlan_tag
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|flags
operator|=
name|I40E_AQC_MACVLAN_ADD_IGNORE_VLAN
expr_stmt|;
block|}
else|else
block|{
name|b
operator|->
name|vlan_tag
operator|=
name|f
operator|->
name|vlan
expr_stmt|;
name|b
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|b
operator|->
name|flags
operator||=
name|I40E_AQC_MACVLAN_ADD_PERFECT_MATCH
expr_stmt|;
name|f
operator|->
name|flags
operator|&=
operator|~
name|IXL_FILTER_ADD
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
name|cnt
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|err
operator|=
name|i40e_aq_add_macvlan
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|,
name|a
argument_list|,
name|j
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"aq_add_macvlan err %d, "
literal|"aq_error %d\n"
argument_list|,
name|err
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
else|else
name|vsi
operator|->
name|hw_filters_add
operator|+=
name|j
expr_stmt|;
block|}
name|free
argument_list|(
name|a
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** This routine takes removals in the vsi filter ** table and creates an Admin Queue call to delete ** the filters in the hardware. */
end_comment

begin_function
name|void
name|ixl_del_hw_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|struct
name|i40e_aqc_remove_macvlan_element_data
modifier|*
name|d
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|,
modifier|*
name|f_temp
decl_stmt|;
name|int
name|err
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|DEBUGOUT
argument_list|(
literal|"ixl_del_hw_filters: begin\n"
argument_list|)
expr_stmt|;
name|pf
operator|=
name|vsi
operator|->
name|back
expr_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
name|dev
operator|=
name|pf
operator|->
name|dev
expr_stmt|;
name|d
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_aqc_remove_macvlan_element_data
argument_list|)
operator|*
name|cnt
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"del hw filter failed to get memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|SLIST_FOREACH_SAFE
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|,
argument|f_temp
argument_list|)
block|{
if|if
condition|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_DEL
condition|)
block|{
name|e
operator|=
operator|&
name|d
index|[
name|j
index|]
expr_stmt|;
comment|// a pox on fvl long names :)
name|bcopy
argument_list|(
name|f
operator|->
name|macaddr
argument_list|,
name|e
operator|->
name|mac_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|e
operator|->
name|vlan_tag
operator|=
operator|(
name|f
operator|->
name|vlan
operator|==
name|IXL_VLAN_ANY
condition|?
literal|0
else|:
name|f
operator|->
name|vlan
operator|)
expr_stmt|;
name|e
operator|->
name|flags
operator|=
name|I40E_AQC_MACVLAN_DEL_PERFECT_MATCH
expr_stmt|;
comment|/* delete entry from vsi list */
name|SLIST_REMOVE
argument_list|(
operator|&
name|vsi
operator|->
name|ftl
argument_list|,
name|f
argument_list|,
name|ixl_mac_filter
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
name|cnt
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|err
operator|=
name|i40e_aq_remove_macvlan
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|,
name|d
argument_list|,
name|j
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
operator|!=
name|I40E_AQ_RC_ENOENT
condition|)
block|{
name|int
name|sc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
name|sc
operator|+=
operator|(
operator|!
name|d
index|[
name|i
index|]
operator|.
name|error_code
operator|)
expr_stmt|;
name|vsi
operator|->
name|hw_filters_del
operator|+=
name|sc
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to remove %d/%d filters, aq error %d\n"
argument_list|,
name|j
operator|-
name|sc
argument_list|,
name|j
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
block|}
else|else
name|vsi
operator|->
name|hw_filters_del
operator|+=
name|j
expr_stmt|;
block|}
name|free
argument_list|(
name|d
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"ixl_del_hw_filters: end\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|ixl_enable_tx_ring
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_pf_qtag
modifier|*
name|qtag
parameter_list|,
name|u16
name|vsi_qidx
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|u16
name|pf_qidx
decl_stmt|;
name|pf_qidx
operator|=
name|ixl_pf_qidx_from_vsi_qidx
argument_list|(
name|qtag
argument_list|,
name|vsi_qidx
argument_list|)
expr_stmt|;
name|ixl_dbg
argument_list|(
name|pf
argument_list|,
name|IXL_DBG_EN_DIS
argument_list|,
literal|"Enabling PF TX ring %4d / VSI TX ring %4d...\n"
argument_list|,
name|pf_qidx
argument_list|,
name|vsi_qidx
argument_list|)
expr_stmt|;
name|i40e_pre_tx_queue_cfg
argument_list|(
name|hw
argument_list|,
name|pf_qidx
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_ENA
argument_list|(
name|pf_qidx
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator||=
name|I40E_QTX_ENA_QENA_REQ_MASK
operator||
name|I40E_QTX_ENA_QENA_STAT_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_ENA
argument_list|(
name|pf_qidx
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Verify the enable took */
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_ENA
argument_list|(
name|pf_qidx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_QTX_ENA_QENA_STAT_MASK
condition|)
break|break;
name|i40e_msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|reg
operator|&
name|I40E_QTX_ENA_QENA_STAT_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"TX queue %d still disabled!\n"
argument_list|,
name|pf_qidx
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixl_enable_rx_ring
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_pf_qtag
modifier|*
name|qtag
parameter_list|,
name|u16
name|vsi_qidx
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|u16
name|pf_qidx
decl_stmt|;
name|pf_qidx
operator|=
name|ixl_pf_qidx_from_vsi_qidx
argument_list|(
name|qtag
argument_list|,
name|vsi_qidx
argument_list|)
expr_stmt|;
name|ixl_dbg
argument_list|(
name|pf
argument_list|,
name|IXL_DBG_EN_DIS
argument_list|,
literal|"Enabling PF RX ring %4d / VSI RX ring %4d...\n"
argument_list|,
name|pf_qidx
argument_list|,
name|vsi_qidx
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QRX_ENA
argument_list|(
name|pf_qidx
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator||=
name|I40E_QRX_ENA_QENA_REQ_MASK
operator||
name|I40E_QRX_ENA_QENA_STAT_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QRX_ENA
argument_list|(
name|pf_qidx
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Verify the enable took */
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QRX_ENA
argument_list|(
name|pf_qidx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_QRX_ENA_QENA_STAT_MASK
condition|)
break|break;
name|i40e_msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|reg
operator|&
name|I40E_QRX_ENA_QENA_STAT_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"RX queue %d still disabled!\n"
argument_list|,
name|pf_qidx
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixl_enable_ring
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_pf_qtag
modifier|*
name|qtag
parameter_list|,
name|u16
name|vsi_qidx
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|error
operator|=
name|ixl_enable_tx_ring
argument_list|(
name|pf
argument_list|,
name|qtag
argument_list|,
name|vsi_qidx
argument_list|)
expr_stmt|;
comment|/* Called function already prints error message */
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ixl_enable_rx_ring
argument_list|(
name|pf
argument_list|,
name|qtag
argument_list|,
name|vsi_qidx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* For PF VSI only */
end_comment

begin_function
name|int
name|ixl_enable_rings
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|ixl_enable_ring
argument_list|(
name|pf
argument_list|,
operator|&
name|pf
operator|->
name|qtag
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixl_disable_tx_ring
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_pf_qtag
modifier|*
name|qtag
parameter_list|,
name|u16
name|vsi_qidx
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|u16
name|pf_qidx
decl_stmt|;
name|pf_qidx
operator|=
name|ixl_pf_qidx_from_vsi_qidx
argument_list|(
name|qtag
argument_list|,
name|vsi_qidx
argument_list|)
expr_stmt|;
name|i40e_pre_tx_queue_cfg
argument_list|(
name|hw
argument_list|,
name|pf_qidx
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|i40e_usec_delay
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_ENA
argument_list|(
name|pf_qidx
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|I40E_QTX_ENA_QENA_REQ_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_ENA
argument_list|(
name|pf_qidx
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Verify the disable took */
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_ENA
argument_list|(
name|pf_qidx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|reg
operator|&
name|I40E_QTX_ENA_QENA_STAT_MASK
operator|)
condition|)
break|break;
name|i40e_msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_QTX_ENA_QENA_STAT_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"TX queue %d still enabled!\n"
argument_list|,
name|pf_qidx
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixl_disable_rx_ring
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_pf_qtag
modifier|*
name|qtag
parameter_list|,
name|u16
name|vsi_qidx
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|u16
name|pf_qidx
decl_stmt|;
name|pf_qidx
operator|=
name|ixl_pf_qidx_from_vsi_qidx
argument_list|(
name|qtag
argument_list|,
name|vsi_qidx
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QRX_ENA
argument_list|(
name|pf_qidx
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|I40E_QRX_ENA_QENA_REQ_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QRX_ENA
argument_list|(
name|pf_qidx
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Verify the disable took */
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QRX_ENA
argument_list|(
name|pf_qidx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|reg
operator|&
name|I40E_QRX_ENA_QENA_STAT_MASK
operator|)
condition|)
break|break;
name|i40e_msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_QRX_ENA_QENA_STAT_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"RX queue %d still enabled!\n"
argument_list|,
name|pf_qidx
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixl_disable_ring
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_pf_qtag
modifier|*
name|qtag
parameter_list|,
name|u16
name|vsi_qidx
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|error
operator|=
name|ixl_disable_tx_ring
argument_list|(
name|pf
argument_list|,
name|qtag
argument_list|,
name|vsi_qidx
argument_list|)
expr_stmt|;
comment|/* Called function already prints error message */
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ixl_disable_rx_ring
argument_list|(
name|pf
argument_list|,
name|qtag
argument_list|,
name|vsi_qidx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* For PF VSI only */
end_comment

begin_function
name|int
name|ixl_disable_rings
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|ixl_disable_ring
argument_list|(
name|pf
argument_list|,
operator|&
name|pf
operator|->
name|qtag
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixl_handle_mdd_event  *  * Called from interrupt handler to identify possibly malicious vfs  * (But also detects events from the PF, as well)  **/
end_comment

begin_function
name|void
name|ixl_handle_mdd_event
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|bool
name|mdd_detected
init|=
name|false
decl_stmt|;
name|bool
name|pf_mdd_detected
init|=
name|false
decl_stmt|;
name|u32
name|reg
decl_stmt|;
comment|/* find what triggered the MDD event */
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GL_MDET_TX
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_GL_MDET_TX_VALID_MASK
condition|)
block|{
name|u8
name|pf_num
init|=
operator|(
name|reg
operator|&
name|I40E_GL_MDET_TX_PF_NUM_MASK
operator|)
operator|>>
name|I40E_GL_MDET_TX_PF_NUM_SHIFT
decl_stmt|;
name|u8
name|event
init|=
operator|(
name|reg
operator|&
name|I40E_GL_MDET_TX_EVENT_MASK
operator|)
operator|>>
name|I40E_GL_MDET_TX_EVENT_SHIFT
decl_stmt|;
name|u16
name|queue
init|=
operator|(
name|reg
operator|&
name|I40E_GL_MDET_TX_QUEUE_MASK
operator|)
operator|>>
name|I40E_GL_MDET_TX_QUEUE_SHIFT
decl_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Malicious Driver Detection event %d"
literal|" on TX queue %d, pf number %d\n"
argument_list|,
name|event
argument_list|,
name|queue
argument_list|,
name|pf_num
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_GL_MDET_TX
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|mdd_detected
operator|=
name|true
expr_stmt|;
block|}
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GL_MDET_RX
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_GL_MDET_RX_VALID_MASK
condition|)
block|{
name|u8
name|pf_num
init|=
operator|(
name|reg
operator|&
name|I40E_GL_MDET_RX_FUNCTION_MASK
operator|)
operator|>>
name|I40E_GL_MDET_RX_FUNCTION_SHIFT
decl_stmt|;
name|u8
name|event
init|=
operator|(
name|reg
operator|&
name|I40E_GL_MDET_RX_EVENT_MASK
operator|)
operator|>>
name|I40E_GL_MDET_RX_EVENT_SHIFT
decl_stmt|;
name|u16
name|queue
init|=
operator|(
name|reg
operator|&
name|I40E_GL_MDET_RX_QUEUE_MASK
operator|)
operator|>>
name|I40E_GL_MDET_RX_QUEUE_SHIFT
decl_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Malicious Driver Detection event %d"
literal|" on RX queue %d, pf number %d\n"
argument_list|,
name|event
argument_list|,
name|queue
argument_list|,
name|pf_num
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_GL_MDET_RX
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|mdd_detected
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|mdd_detected
condition|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PF_MDET_TX
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_PF_MDET_TX_VALID_MASK
condition|)
block|{
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PF_MDET_TX
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MDD TX event is for this function!"
argument_list|)
expr_stmt|;
name|pf_mdd_detected
operator|=
name|true
expr_stmt|;
block|}
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PF_MDET_RX
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_PF_MDET_RX_VALID_MASK
condition|)
block|{
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PF_MDET_RX
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MDD RX event is for this function!"
argument_list|)
expr_stmt|;
name|pf_mdd_detected
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* re-enable mdd interrupt cause */
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|)
expr_stmt|;
name|reg
operator||=
name|I40E_PFINT_ICR0_ENA_MAL_DETECT_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixl_enable_intr
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
if|if
condition|(
name|pf
operator|->
name|msix
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
name|ixl_enable_queue
argument_list|(
name|hw
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
block|}
else|else
name|ixl_enable_intr0
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixl_disable_rings_intr
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
name|ixl_disable_queue
argument_list|(
name|hw
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixl_enable_intr0
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
comment|/* Use IXL_ITR_NONE so ITR isn't updated here */
name|reg
operator|=
name|I40E_PFINT_DYN_CTL0_INTENA_MASK
operator||
name|I40E_PFINT_DYN_CTL0_CLEARPBA_MASK
operator||
operator|(
name|IXL_ITR_NONE
operator|<<
name|I40E_PFINT_DYN_CTL0_ITR_INDX_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixl_disable_intr0
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|IXL_ITR_NONE
operator|<<
name|I40E_PFINT_DYN_CTL0_ITR_INDX_SHIFT
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixl_enable_queue
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|I40E_PFINT_DYN_CTLN_INTENA_MASK
operator||
name|I40E_PFINT_DYN_CTLN_CLEARPBA_MASK
operator||
operator|(
name|IXL_ITR_NONE
operator|<<
name|I40E_PFINT_DYN_CTLN_ITR_INDX_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTLN
argument_list|(
name|id
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixl_disable_queue
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|IXL_ITR_NONE
operator|<<
name|I40E_PFINT_DYN_CTLN_ITR_INDX_SHIFT
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTLN
argument_list|(
name|id
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixl_update_stats_counters
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_vf
modifier|*
name|vf
decl_stmt|;
name|struct
name|i40e_hw_port_stats
modifier|*
name|nsd
init|=
operator|&
name|pf
operator|->
name|stats
decl_stmt|;
name|struct
name|i40e_hw_port_stats
modifier|*
name|osd
init|=
operator|&
name|pf
operator|->
name|stats_offsets
decl_stmt|;
comment|/* Update hw stats */
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_CRCERRS
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|crc_errors
argument_list|,
operator|&
name|nsd
operator|->
name|crc_errors
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_ILLERRC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|illegal_bytes
argument_list|,
operator|&
name|nsd
operator|->
name|illegal_bytes
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_GORCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_GORCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|rx_bytes
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|rx_bytes
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_GOTCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_GOTCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|tx_bytes
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|tx_bytes
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RDPC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|rx_discards
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|rx_discards
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_UPRCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_UPRCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|rx_unicast
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|rx_unicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_UPTCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_UPTCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|tx_unicast
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|tx_unicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_MPRCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_MPRCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|rx_multicast
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|rx_multicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_MPTCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_MPTCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|tx_multicast
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|tx_multicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_BPRCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_BPRCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|rx_broadcast
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|rx_broadcast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_BPTCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_BPTCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|tx_broadcast
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|tx_broadcast
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_TDOLD
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_dropped_link_down
argument_list|,
operator|&
name|nsd
operator|->
name|tx_dropped_link_down
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_MLFC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|mac_local_faults
argument_list|,
operator|&
name|nsd
operator|->
name|mac_local_faults
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_MRFC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|mac_remote_faults
argument_list|,
operator|&
name|nsd
operator|->
name|mac_remote_faults
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RLEC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_length_errors
argument_list|,
operator|&
name|nsd
operator|->
name|rx_length_errors
argument_list|)
expr_stmt|;
comment|/* Flow control (LFC) stats */
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_LXONRXC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|link_xon_rx
argument_list|,
operator|&
name|nsd
operator|->
name|link_xon_rx
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_LXONTXC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|link_xon_tx
argument_list|,
operator|&
name|nsd
operator|->
name|link_xon_tx
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_LXOFFRXC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|link_xoff_rx
argument_list|,
operator|&
name|nsd
operator|->
name|link_xoff_rx
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_LXOFFTXC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|link_xoff_tx
argument_list|,
operator|&
name|nsd
operator|->
name|link_xoff_tx
argument_list|)
expr_stmt|;
comment|/* Packet size stats rx */
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC64H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC64L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_64
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_64
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC127H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC127L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_127
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_127
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC255H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC255L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_255
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_255
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC511H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC511L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_511
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_511
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC1023H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC1023L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_1023
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_1023
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC1522H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC1522L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_1522
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_1522
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC9522H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC9522L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_big
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_big
argument_list|)
expr_stmt|;
comment|/* Packet size stats tx */
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC64H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC64L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_64
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_64
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC127H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC127L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_127
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_127
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC255H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC255L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_255
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_255
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC511H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC511L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_511
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_511
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC1023H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC1023L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_1023
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_1023
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC1522H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC1522L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_1522
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_1522
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC9522H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC9522L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_big
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_big
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RUC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_undersize
argument_list|,
operator|&
name|nsd
operator|->
name|rx_undersize
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RFC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_fragments
argument_list|,
operator|&
name|nsd
operator|->
name|rx_fragments
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_ROC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_oversize
argument_list|,
operator|&
name|nsd
operator|->
name|rx_oversize
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RJC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_jabber
argument_list|,
operator|&
name|nsd
operator|->
name|rx_jabber
argument_list|)
expr_stmt|;
name|pf
operator|->
name|stat_offsets_loaded
operator|=
name|true
expr_stmt|;
comment|/* End hw stats */
comment|/* Update vsi stats */
name|ixl_update_vsi_stats
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pf
operator|->
name|num_vfs
condition|;
name|i
operator|++
control|)
block|{
name|vf
operator|=
operator|&
name|pf
operator|->
name|vfs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|vf
operator|->
name|vf_flags
operator|&
name|VF_FLAG_ENABLED
condition|)
name|ixl_update_eth_stats
argument_list|(
operator|&
name|pf
operator|->
name|vfs
index|[
name|i
index|]
operator|.
name|vsi
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ixl_rebuild_hw_structs_after_reset
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|bool
name|is_up
init|=
name|false
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|is_up
operator|=
operator|!
operator|!
operator|(
name|vsi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
expr_stmt|;
comment|/* Teardown */
if|if
condition|(
name|is_up
condition|)
name|ixl_stop
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_shutdown_lan_hmc
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Shutdown LAN HMC failed with code %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ixl_disable_intr0
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixl_teardown_adminq_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_shutdown_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Shutdown Admin queue failed with code %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* Setup */
name|error
operator|=
name|i40e_init_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|I40E_ERR_FIRMWARE_API_VERSION
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to initialize Admin Queue, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|ixl_setup_adminq_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixl_setup_adminq_msix error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|ixl_configure_intr0_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_enable_intr0
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_init_lan_hmc
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_tx_qp
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_rx_qp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init_lan_hmc failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|i40e_configure_lan_hmc
argument_list|(
name|hw
argument_list|,
name|I40E_HMC_MODEL_DIRECT_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"configure_lan_hmc failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_up
condition|)
name|ixl_init
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ixl_handle_empr_reset
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|u32
name|reg
decl_stmt|;
comment|/* Typically finishes within 3-4 seconds */
while|while
condition|(
name|count
operator|++
operator|<
literal|100
condition|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLGEN_RSTAT
argument_list|)
operator|&
name|I40E_GLGEN_RSTAT_DEVSTATE_MASK
expr_stmt|;
if|if
condition|(
name|reg
condition|)
name|i40e_msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|ixl_dbg
argument_list|(
name|pf
argument_list|,
name|IXL_DBG_INFO
argument_list|,
literal|"EMPR reset wait count: %d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Rebuilding driver state...\n"
argument_list|)
expr_stmt|;
name|ixl_rebuild_hw_structs_after_reset
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Rebuilding driver state done.\n"
argument_list|)
expr_stmt|;
name|atomic_clear_int
argument_list|(
operator|&
name|pf
operator|->
name|state
argument_list|,
name|IXL_PF_STATE_EMPR_RESETTING
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Tasklet handler for MSIX Adminq interrupts **  - do outside interrupt since it might sleep */
end_comment

begin_function
name|void
name|ixl_do_adminq
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|context
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|i40e_arq_event_info
name|event
decl_stmt|;
name|i40e_status
name|ret
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|u32
name|loop
init|=
literal|0
decl_stmt|;
name|u16
name|opcode
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|pf
operator|->
name|state
operator|&
name|IXL_PF_STATE_EMPR_RESETTING
condition|)
block|{
comment|/* Flag cleared at end of this function */
name|ixl_handle_empr_reset
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Admin Queue handling */
name|event
operator|.
name|buf_len
operator|=
name|IXL_AQ_BUF_SZ
expr_stmt|;
name|event
operator|.
name|msg_buf
operator|=
name|malloc
argument_list|(
name|event
operator|.
name|buf_len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|event
operator|.
name|msg_buf
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Unable to allocate memory for Admin"
literal|" Queue event!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* clean and process any events */
do|do
block|{
name|ret
operator|=
name|i40e_clean_arq_element
argument_list|(
name|hw
argument_list|,
operator|&
name|event
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
name|opcode
operator|=
name|LE16_TO_CPU
argument_list|(
name|event
operator|.
name|desc
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|ixl_dbg
argument_list|(
name|pf
argument_list|,
name|IXL_DBG_AQ
argument_list|,
literal|"Admin Queue event: %#06x\n"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|i40e_aqc_opc_get_link_status
case|:
name|ixl_link_event
argument_list|(
name|pf
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|i40e_aqc_opc_send_msg_to_pf
case|:
ifdef|#
directive|ifdef
name|PCI_IOV
name|ixl_handle_vf_msg
argument_list|(
name|pf
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|i40e_aqc_opc_event_lan_overflow
case|:
default|default:
break|break;
block|}
block|}
do|while
condition|(
name|result
operator|&&
operator|(
name|loop
operator|++
operator|<
name|IXL_ADM_LIMIT
operator|)
condition|)
do|;
name|free
argument_list|(
name|event
operator|.
name|msg_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* 	 * If there are still messages to process, reschedule ourselves. 	 * Otherwise, re-enable our interrupt. 	 */
if|if
condition|(
name|result
operator|>
literal|0
condition|)
name|taskqueue_enqueue
argument_list|(
name|pf
operator|->
name|tq
argument_list|,
operator|&
name|pf
operator|->
name|adminq
argument_list|)
expr_stmt|;
else|else
name|ixl_enable_intr0
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Update VSI-specific ethernet statistics counters.  **/
end_comment

begin_function
name|void
name|ixl_update_eth_stats
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|i40e_eth_stats
modifier|*
name|es
decl_stmt|;
name|struct
name|i40e_eth_stats
modifier|*
name|oes
decl_stmt|;
name|struct
name|i40e_hw_port_stats
modifier|*
name|nsd
decl_stmt|;
name|u16
name|stat_idx
init|=
name|vsi
operator|->
name|info
operator|.
name|stat_counter_idx
decl_stmt|;
name|es
operator|=
operator|&
name|vsi
operator|->
name|eth_stats
expr_stmt|;
name|oes
operator|=
operator|&
name|vsi
operator|->
name|eth_stats_offsets
expr_stmt|;
name|nsd
operator|=
operator|&
name|pf
operator|->
name|stats
expr_stmt|;
comment|/* Gather up the stats that the hw collects */
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_TEPC
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|tx_errors
argument_list|,
operator|&
name|es
operator|->
name|tx_errors
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_RDPC
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|rx_discards
argument_list|,
operator|&
name|es
operator|->
name|rx_discards
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_GORCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_GORCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|rx_bytes
argument_list|,
operator|&
name|es
operator|->
name|rx_bytes
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_UPRCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_UPRCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|rx_unicast
argument_list|,
operator|&
name|es
operator|->
name|rx_unicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_MPRCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_MPRCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|rx_multicast
argument_list|,
operator|&
name|es
operator|->
name|rx_multicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_BPRCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_BPRCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|rx_broadcast
argument_list|,
operator|&
name|es
operator|->
name|rx_broadcast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_GOTCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_GOTCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|tx_bytes
argument_list|,
operator|&
name|es
operator|->
name|tx_bytes
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_UPTCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_UPTCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|tx_unicast
argument_list|,
operator|&
name|es
operator|->
name|tx_unicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_MPTCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_MPTCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|tx_multicast
argument_list|,
operator|&
name|es
operator|->
name|tx_multicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_BPTCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_BPTCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|tx_broadcast
argument_list|,
operator|&
name|es
operator|->
name|tx_broadcast
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|stat_offsets_loaded
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixl_update_vsi_stats
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|i40e_eth_stats
modifier|*
name|es
decl_stmt|;
name|u64
name|tx_discards
decl_stmt|;
name|struct
name|i40e_hw_port_stats
modifier|*
name|nsd
decl_stmt|;
name|pf
operator|=
name|vsi
operator|->
name|back
expr_stmt|;
name|ifp
operator|=
name|vsi
operator|->
name|ifp
expr_stmt|;
name|es
operator|=
operator|&
name|vsi
operator|->
name|eth_stats
expr_stmt|;
name|nsd
operator|=
operator|&
name|pf
operator|->
name|stats
expr_stmt|;
name|ixl_update_eth_stats
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|tx_discards
operator|=
name|es
operator|->
name|tx_discards
operator|+
name|nsd
operator|->
name|tx_dropped_link_down
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
name|tx_discards
operator|+=
name|vsi
operator|->
name|queues
index|[
name|i
index|]
operator|.
name|txr
operator|.
name|br
operator|->
name|br_drops
expr_stmt|;
comment|/* Update ifnet stats */
name|IXL_SET_IPACKETS
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|rx_unicast
operator|+
name|es
operator|->
name|rx_multicast
operator|+
name|es
operator|->
name|rx_broadcast
argument_list|)
expr_stmt|;
name|IXL_SET_OPACKETS
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|tx_unicast
operator|+
name|es
operator|->
name|tx_multicast
operator|+
name|es
operator|->
name|tx_broadcast
argument_list|)
expr_stmt|;
name|IXL_SET_IBYTES
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|rx_bytes
argument_list|)
expr_stmt|;
name|IXL_SET_OBYTES
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|tx_bytes
argument_list|)
expr_stmt|;
name|IXL_SET_IMCASTS
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|rx_multicast
argument_list|)
expr_stmt|;
name|IXL_SET_OMCASTS
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|tx_multicast
argument_list|)
expr_stmt|;
name|IXL_SET_IERRORS
argument_list|(
name|vsi
argument_list|,
name|nsd
operator|->
name|crc_errors
operator|+
name|nsd
operator|->
name|illegal_bytes
operator|+
name|nsd
operator|->
name|rx_undersize
operator|+
name|nsd
operator|->
name|rx_oversize
operator|+
name|nsd
operator|->
name|rx_fragments
operator|+
name|nsd
operator|->
name|rx_jabber
argument_list|)
expr_stmt|;
name|IXL_SET_OERRORS
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|tx_errors
argument_list|)
expr_stmt|;
name|IXL_SET_IQDROPS
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|rx_discards
operator|+
name|nsd
operator|->
name|eth
operator|.
name|rx_discards
argument_list|)
expr_stmt|;
name|IXL_SET_OQDROPS
argument_list|(
name|vsi
argument_list|,
name|tx_discards
argument_list|)
expr_stmt|;
name|IXL_SET_NOPROTO
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|rx_unknown_protocol
argument_list|)
expr_stmt|;
name|IXL_SET_COLLISIONS
argument_list|(
name|vsi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Reset all of the stats for the given pf  **/
end_comment

begin_function
name|void
name|ixl_pf_reset_stats
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|bzero
argument_list|(
operator|&
name|pf
operator|->
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_hw_port_stats
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pf
operator|->
name|stats_offsets
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_hw_port_stats
argument_list|)
argument_list|)
expr_stmt|;
name|pf
operator|->
name|stat_offsets_loaded
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Resets all stats of the given vsi  **/
end_comment

begin_function
name|void
name|ixl_vsi_reset_stats
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|bzero
argument_list|(
operator|&
name|vsi
operator|->
name|eth_stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_eth_stats
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|vsi
operator|->
name|eth_stats_offsets
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_eth_stats
argument_list|)
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|stat_offsets_loaded
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Read and update a 48 bit stat from the hw  *  * Since the device stats are not reset at PFReset, they likely will not  * be zeroed when the driver starts.  We'll save the first values read  * and use them as offsets to be subtracted from the raw values in order  * to report stats that count from zero.  **/
end_comment

begin_function
name|void
name|ixl_stat_update48
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|hireg
parameter_list|,
name|u32
name|loreg
parameter_list|,
name|bool
name|offset_loaded
parameter_list|,
name|u64
modifier|*
name|offset
parameter_list|,
name|u64
modifier|*
name|stat
parameter_list|)
block|{
name|u64
name|new_data
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|(
name|__FreeBSD_version
operator|>=
literal|1000000
operator|)
operator|&&
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|new_data
operator|=
name|rd64
argument_list|(
name|hw
argument_list|,
name|loreg
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * Use two rd32's instead of one rd64; FreeBSD versions before 	 * 10 don't support 64-bit bus reads/writes. 	 */
name|new_data
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|loreg
argument_list|)
expr_stmt|;
name|new_data
operator||=
operator|(
call|(
name|u64
call|)
argument_list|(
name|rd32
argument_list|(
name|hw
argument_list|,
name|hireg
argument_list|)
operator|&
literal|0xFFFF
argument_list|)
operator|)
operator|<<
literal|32
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|offset_loaded
condition|)
operator|*
name|offset
operator|=
name|new_data
expr_stmt|;
if|if
condition|(
name|new_data
operator|>=
operator|*
name|offset
condition|)
operator|*
name|stat
operator|=
name|new_data
operator|-
operator|*
name|offset
expr_stmt|;
else|else
operator|*
name|stat
operator|=
operator|(
name|new_data
operator|+
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
literal|48
operator|)
operator|)
operator|-
operator|*
name|offset
expr_stmt|;
operator|*
name|stat
operator|&=
literal|0xFFFFFFFFFFFFULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Read and update a 32 bit stat from the hw  **/
end_comment

begin_function
name|void
name|ixl_stat_update32
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg
parameter_list|,
name|bool
name|offset_loaded
parameter_list|,
name|u64
modifier|*
name|offset
parameter_list|,
name|u64
modifier|*
name|stat
parameter_list|)
block|{
name|u32
name|new_data
decl_stmt|;
name|new_data
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|offset_loaded
condition|)
operator|*
name|offset
operator|=
name|new_data
expr_stmt|;
if|if
condition|(
name|new_data
operator|>=
operator|*
name|offset
condition|)
operator|*
name|stat
operator|=
call|(
name|u32
call|)
argument_list|(
name|new_data
operator|-
operator|*
name|offset
argument_list|)
expr_stmt|;
else|else
operator|*
name|stat
operator|=
call|(
name|u32
call|)
argument_list|(
operator|(
name|new_data
operator|+
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
literal|32
operator|)
operator|)
operator|-
operator|*
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixl_add_device_sysctls
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|ctx_list
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|debug_node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|debug_list
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|fec_node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|fec_list
decl_stmt|;
comment|/* Set up sysctls */
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|ctx_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fc"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_set_flowcntl
argument_list|,
literal|"I"
argument_list|,
name|IXL_SYSCTL_HELP_FC
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|ctx_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"advertise_speed"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_set_advertise
argument_list|,
literal|"I"
argument_list|,
name|IXL_SYSCTL_HELP_SET_ADVERTISE
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|ctx_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"current_speed"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_current_speed
argument_list|,
literal|"A"
argument_list|,
literal|"Current Port Speed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|ctx_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fw_version"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_show_fw
argument_list|,
literal|"A"
argument_list|,
literal|"Firmware version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|ctx_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"unallocated_queues"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_unallocated_queues
argument_list|,
literal|"I"
argument_list|,
literal|"Queues not allocated to a PF or VF"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|ctx_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_itr"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_pf_tx_itr
argument_list|,
literal|"I"
argument_list|,
literal|"Immediately set TX ITR value for all queues"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|ctx_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_itr"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_pf_rx_itr
argument_list|,
literal|"I"
argument_list|,
literal|"Immediately set RX ITR value for all queues"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|ctx_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dynamic_rx_itr"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pf
operator|->
name|dynamic_rx_itr
argument_list|,
literal|0
argument_list|,
literal|"Enable dynamic RX ITR"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|ctx_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dynamic_tx_itr"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pf
operator|->
name|dynamic_tx_itr
argument_list|,
literal|0
argument_list|,
literal|"Enable dynamic TX ITR"
argument_list|)
expr_stmt|;
comment|/* Add FEC sysctls for 25G adapters */
comment|/* 	 * XXX: These settings can be changed, but that isn't supported, 	 * so these are read-only for now. 	 */
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|I40E_DEV_ID_25G_B
operator|||
name|hw
operator|->
name|device_id
operator|==
name|I40E_DEV_ID_25G_SFP28
condition|)
block|{
name|fec_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|ctx_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fec"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"FEC Sysctls"
argument_list|)
expr_stmt|;
name|fec_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|fec_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|fec_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fc_ability"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_fec_fc_ability
argument_list|,
literal|"I"
argument_list|,
literal|"FC FEC ability enabled"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|fec_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rs_ability"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_fec_rs_ability
argument_list|,
literal|"I"
argument_list|,
literal|"RS FEC ability enabled"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|fec_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fc_requested"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_fec_fc_request
argument_list|,
literal|"I"
argument_list|,
literal|"FC FEC mode requested on link"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|fec_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rs_requested"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_fec_rs_request
argument_list|,
literal|"I"
argument_list|,
literal|"RS FEC mode requested on link"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|fec_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"auto_fec_enabled"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_fec_auto_enable
argument_list|,
literal|"I"
argument_list|,
literal|"Let FW decide FEC ability/request modes"
argument_list|)
expr_stmt|;
block|}
comment|/* Add sysctls meant to print debug information, but don't list them 	 * in "sysctl -a" output. */
name|debug_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|ctx_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_SKIP
argument_list|,
name|NULL
argument_list|,
literal|"Debug Sysctls"
argument_list|)
expr_stmt|;
name|debug_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|debug_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|debug_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"shared_debug_mask"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pf
operator|->
name|hw
operator|.
name|debug_mask
argument_list|,
literal|0
argument_list|,
literal|"Shared code debug message level"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|debug_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"core_debug_mask"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pf
operator|->
name|dbg_mask
argument_list|,
literal|0
argument_list|,
literal|"Non-hared code debug message level"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|debug_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"link_status"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_link_status
argument_list|,
literal|"A"
argument_list|,
name|IXL_SYSCTL_HELP_LINK_STATUS
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|debug_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"phy_abilities"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_phy_abilities
argument_list|,
literal|"A"
argument_list|,
literal|"PHY Abilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|debug_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"filter_list"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_sw_filter_list
argument_list|,
literal|"A"
argument_list|,
literal|"SW Filter List"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|debug_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hw_res_alloc"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_hw_res_alloc
argument_list|,
literal|"A"
argument_list|,
literal|"HW Resource Allocation"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|debug_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"switch_config"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_switch_config
argument_list|,
literal|"A"
argument_list|,
literal|"HW Switch Configuration"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|debug_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rss_key"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_hkey
argument_list|,
literal|"A"
argument_list|,
literal|"View RSS key"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|debug_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rss_lut"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_hlut
argument_list|,
literal|"A"
argument_list|,
literal|"View RSS lookup table"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|debug_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rss_hena"
argument_list|,
name|CTLTYPE_ULONG
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_hena
argument_list|,
literal|"LU"
argument_list|,
literal|"View enabled packet types for RSS"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|debug_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"disable_fw_link_management"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_WR
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_fw_link_management
argument_list|,
literal|"I"
argument_list|,
literal|"Disable FW Link Management"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|has_i2c
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|debug_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"read_i2c_byte"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_read_i2c_byte
argument_list|,
literal|"I"
argument_list|,
literal|"Read byte from I2C bus"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|debug_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"write_i2c_byte"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_write_i2c_byte
argument_list|,
literal|"I"
argument_list|,
literal|"Write byte to I2C bus"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PCI_IOV
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|debug_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"vc_debug_level"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pf
operator|->
name|vc_debug_lvl
argument_list|,
literal|0
argument_list|,
literal|"PF/VF Virtual Channel debug level"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Primarily for finding out how many queues can be assigned to VFs,  * at runtime.  */
end_comment

begin_function
specifier|static
name|int
name|ixl_sysctl_unallocated_queues
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|queues
decl_stmt|;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|queues
operator|=
operator|(
name|int
operator|)
name|ixl_pf_qmgr_get_num_free
argument_list|(
operator|&
name|pf
operator|->
name|qmgr
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
name|NULL
argument_list|,
name|queues
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ** Set flow control using sysctl: ** 	0 - off **	1 - rx pause **	2 - tx pause **	3 - full */
end_comment

begin_function
name|int
name|ixl_set_flowcntl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|requested_fc
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|enum
name|i40e_status_code
name|aq_error
init|=
literal|0
decl_stmt|;
name|u8
name|fc_aq_err
init|=
literal|0
decl_stmt|;
comment|/* Get request */
name|requested_fc
operator|=
name|pf
operator|->
name|fc
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|requested_fc
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|requested_fc
operator|<
literal|0
operator|||
name|requested_fc
operator|>
literal|3
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid fc mode; valid modes are 0 through 3\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Set fc ability for port */
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|requested_fc
expr_stmt|;
name|aq_error
operator|=
name|i40e_set_fc
argument_list|(
name|hw
argument_list|,
operator|&
name|fc_aq_err
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|aq_error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Error setting new fc mode %d; fc_err %#x\n"
argument_list|,
name|__func__
argument_list|,
name|aq_error
argument_list|,
name|fc_aq_err
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|pf
operator|->
name|fc
operator|=
name|requested_fc
expr_stmt|;
comment|/* Get new link state */
name|i40e_msec_delay
argument_list|(
literal|250
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|get_link_info
operator|=
name|TRUE
expr_stmt|;
name|i40e_get_link_status
argument_list|(
name|hw
argument_list|,
operator|&
name|pf
operator|->
name|link_up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|ixl_aq_speed_to_str
parameter_list|(
name|enum
name|i40e_aq_link_speed
name|link_speed
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|char
modifier|*
name|speeds
index|[]
init|=
block|{
literal|"Unknown"
block|,
literal|"100 Mbps"
block|,
literal|"1 Gbps"
block|,
literal|"10 Gbps"
block|,
literal|"40 Gbps"
block|,
literal|"20 Gbps"
block|,
literal|"25 Gbps"
block|, 	}
decl_stmt|;
switch|switch
condition|(
name|link_speed
condition|)
block|{
case|case
name|I40E_LINK_SPEED_100MB
case|:
name|index
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|I40E_LINK_SPEED_1GB
case|:
name|index
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|I40E_LINK_SPEED_10GB
case|:
name|index
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|I40E_LINK_SPEED_40GB
case|:
name|index
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|I40E_LINK_SPEED_20GB
case|:
name|index
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|I40E_LINK_SPEED_25GB
case|:
name|index
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|I40E_LINK_SPEED_UNKNOWN
case|:
default|default:
name|index
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|speeds
index|[
name|index
index|]
return|;
block|}
end_function

begin_function
name|int
name|ixl_current_speed
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ixl_update_link_status
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|ixl_aq_speed_to_str
argument_list|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|link_speed
argument_list|)
argument_list|,
literal|8
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u8
name|ixl_convert_sysctl_aq_link_speed
parameter_list|(
name|u8
name|speeds
parameter_list|,
name|bool
name|to_aq
parameter_list|)
block|{
specifier|static
name|u16
name|speedmap
index|[
literal|6
index|]
init|=
block|{
operator|(
name|I40E_LINK_SPEED_100MB
operator||
operator|(
literal|0x1
operator|<<
literal|8
operator|)
operator|)
block|,
operator|(
name|I40E_LINK_SPEED_1GB
operator||
operator|(
literal|0x2
operator|<<
literal|8
operator|)
operator|)
block|,
operator|(
name|I40E_LINK_SPEED_10GB
operator||
operator|(
literal|0x4
operator|<<
literal|8
operator|)
operator|)
block|,
operator|(
name|I40E_LINK_SPEED_20GB
operator||
operator|(
literal|0x8
operator|<<
literal|8
operator|)
operator|)
block|,
operator|(
name|I40E_LINK_SPEED_25GB
operator||
operator|(
literal|0x10
operator|<<
literal|8
operator|)
operator|)
block|,
operator|(
name|I40E_LINK_SPEED_40GB
operator||
operator|(
literal|0x20
operator|<<
literal|8
operator|)
operator|)
block|}
decl_stmt|;
name|u8
name|retval
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|to_aq
condition|)
name|retval
operator||=
operator|(
name|speeds
operator|&
operator|(
name|speedmap
index|[
name|i
index|]
operator|>>
literal|8
operator|)
operator|)
condition|?
operator|(
name|speedmap
index|[
name|i
index|]
operator|&
literal|0xff
operator|)
else|:
literal|0
expr_stmt|;
else|else
name|retval
operator||=
operator|(
name|speeds
operator|&
name|speedmap
index|[
name|i
index|]
operator|)
condition|?
operator|(
name|speedmap
index|[
name|i
index|]
operator|>>
literal|8
operator|)
else|:
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixl_set_advertised_speeds
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|int
name|speeds
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|i40e_aq_get_phy_abilities_resp
name|abilities
decl_stmt|;
name|struct
name|i40e_aq_set_phy_config
name|config
decl_stmt|;
name|enum
name|i40e_status_code
name|aq_error
init|=
literal|0
decl_stmt|;
comment|/* Get current capability information */
name|aq_error
operator|=
name|i40e_aq_get_phy_capabilities
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|abilities
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|aq_error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Error getting phy capabilities %d,"
literal|" aq error: %d\n"
argument_list|,
name|__func__
argument_list|,
name|aq_error
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Prepare new config */
name|bzero
argument_list|(
operator|&
name|config
argument_list|,
sizeof|sizeof
argument_list|(
name|config
argument_list|)
argument_list|)
expr_stmt|;
name|config
operator|.
name|link_speed
operator|=
name|ixl_convert_sysctl_aq_link_speed
argument_list|(
name|speeds
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|config
operator|.
name|phy_type
operator|=
name|abilities
operator|.
name|phy_type
expr_stmt|;
name|config
operator|.
name|phy_type_ext
operator|=
name|abilities
operator|.
name|phy_type_ext
expr_stmt|;
name|config
operator|.
name|abilities
operator|=
name|abilities
operator|.
name|abilities
operator||
name|I40E_AQ_PHY_ENABLE_ATOMIC_LINK
expr_stmt|;
name|config
operator|.
name|eee_capability
operator|=
name|abilities
operator|.
name|eee_capability
expr_stmt|;
name|config
operator|.
name|eeer
operator|=
name|abilities
operator|.
name|eeer_val
expr_stmt|;
name|config
operator|.
name|low_power_ctrl
operator|=
name|abilities
operator|.
name|d3_lpan
expr_stmt|;
comment|/* Do aq command& restart link */
name|aq_error
operator|=
name|i40e_aq_set_phy_config
argument_list|(
name|hw
argument_list|,
operator|&
name|config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|aq_error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Error setting new phy config %d,"
literal|" aq error: %d\n"
argument_list|,
name|__func__
argument_list|,
name|aq_error
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Control link advertise speed: **	Flags: **	 0x1 - advertise 100 Mb **	 0x2 - advertise 1G **	 0x4 - advertise 10G **	 0x8 - advertise 20G **	0x10 - advertise 25G **	0x20 - advertise 40G ** **	Set to 0 to disable link */
end_comment

begin_function
name|int
name|ixl_set_advertise
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|u8
name|converted_speeds
decl_stmt|;
name|int
name|requested_ls
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Read in new mode */
name|requested_ls
operator|=
name|pf
operator|->
name|advertised_speed
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|requested_ls
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Check if changing speeds is supported */
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|I40E_DEV_ID_25G_B
case|:
case|case
name|I40E_DEV_ID_25G_SFP28
case|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Changing advertised speeds not supported"
literal|" on this device.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|requested_ls
operator|<
literal|0
operator|||
name|requested_ls
operator|>
literal|0xff
condition|)
block|{ 	}
comment|/* Check for valid value */
name|converted_speeds
operator|=
name|ixl_convert_sysctl_aq_link_speed
argument_list|(
operator|(
name|u8
operator|)
name|requested_ls
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|converted_speeds
operator||
name|pf
operator|->
name|supported_speeds
operator|)
operator|!=
name|pf
operator|->
name|supported_speeds
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid advertised speed; "
literal|"valid flags are: 0x%02x\n"
argument_list|,
name|ixl_convert_sysctl_aq_link_speed
argument_list|(
name|pf
operator|->
name|supported_speeds
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|ixl_set_advertised_speeds
argument_list|(
name|pf
argument_list|,
name|requested_ls
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pf
operator|->
name|advertised_speed
operator|=
name|requested_ls
expr_stmt|;
name|ixl_update_link_status
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Input: bitmap of enum i40e_aq_link_speed  */
end_comment

begin_function
specifier|static
name|u64
name|ixl_max_aq_speed_to_value
parameter_list|(
name|u8
name|link_speeds
parameter_list|)
block|{
if|if
condition|(
name|link_speeds
operator|&
name|I40E_LINK_SPEED_40GB
condition|)
return|return
name|IF_Gbps
argument_list|(
literal|40
argument_list|)
return|;
if|if
condition|(
name|link_speeds
operator|&
name|I40E_LINK_SPEED_25GB
condition|)
return|return
name|IF_Gbps
argument_list|(
literal|25
argument_list|)
return|;
if|if
condition|(
name|link_speeds
operator|&
name|I40E_LINK_SPEED_20GB
condition|)
return|return
name|IF_Gbps
argument_list|(
literal|20
argument_list|)
return|;
if|if
condition|(
name|link_speeds
operator|&
name|I40E_LINK_SPEED_10GB
condition|)
return|return
name|IF_Gbps
argument_list|(
literal|10
argument_list|)
return|;
if|if
condition|(
name|link_speeds
operator|&
name|I40E_LINK_SPEED_1GB
condition|)
return|return
name|IF_Gbps
argument_list|(
literal|1
argument_list|)
return|;
if|if
condition|(
name|link_speeds
operator|&
name|I40E_LINK_SPEED_100MB
condition|)
return|return
name|IF_Mbps
argument_list|(
literal|100
argument_list|)
return|;
else|else
comment|/* Minimum supported link speed */
return|return
name|IF_Mbps
argument_list|(
literal|100
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ** Get the width and transaction speed of ** the bus this adapter is plugged into. */
end_comment

begin_function
name|void
name|ixl_get_bus_info
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|u16
name|link
decl_stmt|;
name|u32
name|offset
decl_stmt|,
name|num_ports
decl_stmt|;
name|u64
name|max_speed
decl_stmt|;
comment|/* Some devices don't use PCIE */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|I40E_MAC_X722
condition|)
return|return;
comment|/* Read PCI Express Capabilities Link Status Register */
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|link
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|offset
operator|+
name|PCIER_LINK_STA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Fill out hw struct with PCIE info */
name|i40e_set_pci_config_data
argument_list|(
name|hw
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* Use info to print out bandwidth messages */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCI Express Bus: Speed %s %s\n"
argument_list|,
operator|(
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|==
name|i40e_bus_speed_8000
operator|)
condition|?
literal|"8.0GT/s"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|==
name|i40e_bus_speed_5000
operator|)
condition|?
literal|"5.0GT/s"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|==
name|i40e_bus_speed_2500
operator|)
condition|?
literal|"2.5GT/s"
else|:
literal|"Unknown"
operator|)
argument_list|,
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|==
name|i40e_bus_width_pcie_x8
operator|)
condition|?
literal|"Width x8"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|==
name|i40e_bus_width_pcie_x4
operator|)
condition|?
literal|"Width x4"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|==
name|i40e_bus_width_pcie_x2
operator|)
condition|?
literal|"Width x2"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|==
name|i40e_bus_width_pcie_x1
operator|)
condition|?
literal|"Width x1"
else|:
operator|(
literal|"Unknown"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If adapter is in slot with maximum supported speed, 	 * no warning message needs to be printed out. 	 */
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|>=
name|i40e_bus_speed_8000
operator|&&
name|hw
operator|->
name|bus
operator|.
name|width
operator|>=
name|i40e_bus_width_pcie_x8
condition|)
return|return;
name|num_ports
operator|=
name|bitcount32
argument_list|(
name|hw
operator|->
name|func_caps
operator|.
name|valid_functions
argument_list|)
expr_stmt|;
name|max_speed
operator|=
name|ixl_max_aq_speed_to_value
argument_list|(
name|pf
operator|->
name|supported_speeds
argument_list|)
operator|/
literal|1000000
expr_stmt|;
if|if
condition|(
operator|(
name|num_ports
operator|*
name|max_speed
operator|)
operator|>
name|hw
operator|->
name|bus
operator|.
name|speed
operator|*
name|hw
operator|->
name|bus
operator|.
name|width
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCI-Express bandwidth available"
literal|" for this device may be insufficient for"
literal|" optimal performance.\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Please move the device to a different"
literal|" PCI-e link with more lanes and/or higher"
literal|" transfer rate.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_show_fw
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sbuf
decl_stmt|;
name|sbuf
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|ixl_nvm_version_str
argument_list|(
name|hw
argument_list|,
name|sbuf
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|sbuf
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sbuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ixl_print_nvm_cmd
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|nvma
parameter_list|)
block|{
if|if
condition|(
operator|(
name|nvma
operator|->
name|command
operator|==
name|I40E_NVM_READ
operator|)
operator|&&
operator|(
operator|(
name|nvma
operator|->
name|config
operator|&
literal|0xFF
operator|)
operator|==
literal|0xF
operator|)
operator|&&
operator|(
operator|(
operator|(
name|nvma
operator|->
name|config
operator|&
literal|0xF00
operator|)
operator|>>
literal|8
operator|)
operator|==
literal|0xF
operator|)
operator|&&
operator|(
name|nvma
operator|->
name|offset
operator|==
literal|0
operator|)
operator|&&
operator|(
name|nvma
operator|->
name|data_size
operator|==
literal|1
operator|)
condition|)
block|{
comment|// device_printf(dev, "- Get Driver Status Command\n");
block|}
elseif|else
if|if
condition|(
name|nvma
operator|->
name|command
operator|==
name|I40E_NVM_READ
condition|)
block|{ 	 	}
else|else
block|{
switch|switch
condition|(
name|nvma
operator|->
name|command
condition|)
block|{
case|case
literal|0xB
case|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"- command: I40E_NVM_READ\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xC
case|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"- command: I40E_NVM_WRITE\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"- command: unknown 0x%08x\n"
argument_list|,
name|nvma
operator|->
name|command
argument_list|)
expr_stmt|;
break|break;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"- config (ptr)  : 0x%02x\n"
argument_list|,
name|nvma
operator|->
name|config
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"- config (flags): 0x%01x\n"
argument_list|,
operator|(
name|nvma
operator|->
name|config
operator|&
literal|0xF00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"- offset : 0x%08x\n"
argument_list|,
name|nvma
operator|->
name|offset
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"- data_s : 0x%08x\n"
argument_list|,
name|nvma
operator|->
name|data_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ixl_handle_nvmupd_cmd
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ifdrv
modifier|*
name|ifd
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|i40e_nvm_access
modifier|*
name|nvma
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|enum
name|i40e_status_code
name|status
init|=
literal|0
decl_stmt|;
name|int
name|perrno
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixl_handle_nvmupd_cmd"
argument_list|)
expr_stmt|;
comment|/* Sanity checks */
if|if
condition|(
name|ifd
operator|->
name|ifd_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_nvm_access
argument_list|)
operator|||
name|ifd
operator|->
name|ifd_data
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: incorrect ifdrv length or data pointer\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: ifdrv length: %lu, sizeof(struct i40e_nvm_access): %lu\n"
argument_list|,
name|__func__
argument_list|,
name|ifd
operator|->
name|ifd_len
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_nvm_access
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: data pointer: %p\n"
argument_list|,
name|__func__
argument_list|,
name|ifd
operator|->
name|ifd_data
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|nvma
operator|=
operator|(
expr|struct
name|i40e_nvm_access
operator|*
operator|)
name|ifd
operator|->
name|ifd_data
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|dbg_mask
operator|&
name|IXL_DBG_NVMUPD
condition|)
name|ixl_print_nvm_cmd
argument_list|(
name|dev
argument_list|,
name|nvma
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|state
operator|&
name|IXL_PF_STATE_EMPR_RESETTING
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|count
operator|++
operator|<
literal|100
condition|)
block|{
name|i40e_msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pf
operator|->
name|state
operator|&
name|IXL_PF_STATE_EMPR_RESETTING
operator|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|pf
operator|->
name|state
operator|&
name|IXL_PF_STATE_EMPR_RESETTING
operator|)
condition|)
block|{
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|status
operator|=
name|i40e_nvmupd_command
argument_list|(
name|hw
argument_list|,
name|nvma
argument_list|,
name|nvma
operator|->
name|data
argument_list|,
operator|&
name|perrno
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|perrno
operator|=
operator|-
name|EBUSY
expr_stmt|;
block|}
if|if
condition|(
name|status
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"i40e_nvmupd_command status %s, perrno %d\n"
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|status
argument_list|)
argument_list|,
name|perrno
argument_list|)
expr_stmt|;
comment|/* 	 * -EPERM is actually ERESTART, which the kernel interprets as it needing 	 * to run this ioctl again. So use -EACCES for -EPERM instead. 	 */
if|if
condition|(
name|perrno
operator|==
operator|-
name|EPERM
condition|)
return|return
operator|(
operator|-
name|EACCES
operator|)
return|;
else|else
return|return
operator|(
name|perrno
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called whenever the user queries the status of  *  the interface using ifconfig.  *  **********************************************************************/
end_comment

begin_function
name|void
name|ixl_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_media_status: begin"
argument_list|)
expr_stmt|;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|get_link_info
operator|=
name|TRUE
expr_stmt|;
name|i40e_get_link_status
argument_list|(
name|hw
argument_list|,
operator|&
name|pf
operator|->
name|link_up
argument_list|)
expr_stmt|;
name|ixl_update_link_status
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
name|pf
operator|->
name|link_up
condition|)
block|{
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
comment|/* Hardware always does full-duplex */
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|phy_type
condition|)
block|{
comment|/* 100 M */
case|case
name|I40E_PHY_TYPE_100BASE_TX
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_TX
expr_stmt|;
break|break;
comment|/* 1 G */
case|case
name|I40E_PHY_TYPE_1000BASE_T
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_T
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_1000BASE_SX
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_SX
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_1000BASE_LX
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_LX
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_1000BASE_T_OPTICAL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_OTHER
expr_stmt|;
break|break;
comment|/* 10 G */
case|case
name|I40E_PHY_TYPE_10GBASE_SFPP_CU
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_TWINAX
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_10GBASE_SR
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_SR
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_10GBASE_LR
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_LR
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_10GBASE_T
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_T
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_XAUI
case|:
case|case
name|I40E_PHY_TYPE_XFI
case|:
case|case
name|I40E_PHY_TYPE_10GBASE_AOC
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_OTHER
expr_stmt|;
break|break;
comment|/* 25 G */
case|case
name|I40E_PHY_TYPE_25GBASE_KR
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_25G_KR
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_25GBASE_CR
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_25G_CR
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_25GBASE_SR
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_25G_SR
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_25GBASE_LR
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_UNKNOWN
expr_stmt|;
break|break;
comment|/* 40 G */
case|case
name|I40E_PHY_TYPE_40GBASE_CR4
case|:
case|case
name|I40E_PHY_TYPE_40GBASE_CR4_CU
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_40G_CR4
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_40GBASE_SR4
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_40G_SR4
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_40GBASE_LR4
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_40G_LR4
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_XLAUI
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_OTHER
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_1000BASE_KX
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_KX
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_SGMII
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_SGMII
expr_stmt|;
break|break;
comment|/* ERJ: What's the difference between these? */
case|case
name|I40E_PHY_TYPE_10GBASE_CR1_CU
case|:
case|case
name|I40E_PHY_TYPE_10GBASE_CR1
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_CR1
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_10GBASE_KX4
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_KX4
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_10GBASE_KR
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_KR
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_SFI
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_SFI
expr_stmt|;
break|break;
comment|/* Our single 20G media type */
case|case
name|I40E_PHY_TYPE_20GBASE_KR2
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_20G_KR2
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_40GBASE_KR4
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_40G_KR4
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_XLPPI
case|:
case|case
name|I40E_PHY_TYPE_40GBASE_AOC
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_40G_XLPPI
expr_stmt|;
break|break;
comment|/* Unknown to driver */
default|default:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_UNKNOWN
expr_stmt|;
break|break;
block|}
comment|/* Report flow control status as well */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|an_info
operator|&
name|I40E_AQ_LINK_PAUSE_TX
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_ETH_TXPAUSE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|an_info
operator|&
name|I40E_AQ_LINK_PAUSE_RX
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_ETH_RXPAUSE
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixl_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|arg
decl_stmt|;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_init_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * NOTE: Fortville does not support forcing media speeds. Instead,  * use the set_advertise sysctl to set the speeds Fortville  * will advertise or be allowed to operate at.  */
end_comment

begin_function
name|int
name|ixl_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
init|=
operator|&
name|vsi
operator|->
name|media
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_media_change: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Use 'advertise_speed' sysctl to change advertised speeds\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Ioctl entry point  *  *  ixl_ioctl is called when the user wants to configure the  *  interface.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
name|int
name|ixl_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ifdrv
modifier|*
name|ifd
init|=
operator|(
expr|struct
name|ifdrv
operator|*
operator|)
name|data
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|bool
name|avoid_reset
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFADDR (Set Interface Address)"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
comment|/* 		** Calling init results in link renegotiation, 		** so we avoid doing it when possible. 		*/
if|if
condition|(
name|avoid_reset
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|ixl_init
argument_list|(
name|pf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_NOARP
operator|)
condition|)
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIOCSIFMTU
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFMTU (Set Interface MTU)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|IXL_MAX_FRAME
operator|-
name|ETHER_HDR_LEN
operator|-
name|ETHER_CRC_LEN
operator|-
name|ETHER_VLAN_ENCAP_LEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|vsi
operator|->
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ixl_init_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFFLAGS (Set Interface Flags)"
argument_list|)
expr_stmt|;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|pf
operator|->
name|if_flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
condition|)
block|{
name|ixl_set_promisc
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_init
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|ixl_stop_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
block|}
name|pf
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSDRVSPEC
case|:
case|case
name|SIOCGDRVSPEC
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCxDRVSPEC (Get/Set Driver-specific "
literal|"Info)\n"
argument_list|)
expr_stmt|;
comment|/* NVM update command */
if|if
condition|(
name|ifd
operator|->
name|ifd_cmd
operator|==
name|I40E_NVM_ACCESS
condition|)
name|error
operator|=
name|ixl_handle_nvmupd_cmd
argument_list|(
name|pf
argument_list|,
name|ifd
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCADDMULTI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_disable_rings_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixl_add_multi
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixl_enable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCDELMULTI
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCDELMULTI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_disable_rings_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixl_del_multi
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixl_enable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCGIFXMEDIA
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCxIFMEDIA (Get/Set Interface Media)"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
block|{
name|int
name|mask
init|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFCAP (Set Capabilities)"
argument_list|)
expr_stmt|;
name|ixl_cap_txcsum_tso
argument_list|(
name|vsi
argument_list|,
name|ifp
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM_IPV6
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTSO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTSO
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_init_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1003000
case|case
name|SIOCGI2C
case|:
block|{
name|struct
name|ifi2creq
name|i2c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCGI2C (Get I2C Data)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pf
operator|->
name|has_i2c
condition|)
return|return
operator|(
name|ENOTTY
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|i2c
argument_list|,
sizeof|sizeof
argument_list|(
name|i2c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|i2c
operator|.
name|dev_addr
operator|!=
literal|0xA0
operator|&&
name|i2c
operator|.
name|dev_addr
operator|!=
literal|0xA2
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i2c
operator|.
name|len
operator|>
sizeof|sizeof
argument_list|(
name|i2c
operator|.
name|data
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|i2c
operator|.
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ixl_read_i2c_byte
argument_list|(
name|pf
argument_list|,
name|i2c
operator|.
name|offset
operator|+
name|i
argument_list|,
name|i2c
operator|.
name|dev_addr
argument_list|,
operator|&
name|i2c
operator|.
name|data
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|i2c
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|i2c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: UNKNOWN (0x%X)\n"
argument_list|,
operator|(
name|int
operator|)
name|command
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixl_find_i2c_interface
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|bool
name|i2c_en
decl_stmt|,
name|port_matched
decl_stmt|;
name|u32
name|reg
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLGEN_MDIO_I2C_SEL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|i2c_en
operator|=
operator|(
name|reg
operator|&
name|I40E_GLGEN_MDIO_I2C_SEL_MDIO_I2C_SEL_MASK
operator|)
expr_stmt|;
name|port_matched
operator|=
operator|(
operator|(
name|reg
operator|&
name|I40E_GLGEN_MDIO_I2C_SEL_PHY_PORT_NUM_MASK
operator|)
operator|>>
name|I40E_GLGEN_MDIO_I2C_SEL_PHY_PORT_NUM_SHIFT
operator|)
operator|&
name|BIT
argument_list|(
name|hw
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2c_en
operator|&&
name|port_matched
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|ixl_phy_type_string
parameter_list|(
name|u32
name|bit_pos
parameter_list|,
name|bool
name|ext
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|phy_types_str
index|[
literal|32
index|]
init|=
block|{
literal|"SGMII"
block|,
literal|"1000BASE-KX"
block|,
literal|"10GBASE-KX4"
block|,
literal|"10GBASE-KR"
block|,
literal|"40GBASE-KR4"
block|,
literal|"XAUI"
block|,
literal|"XFI"
block|,
literal|"SFI"
block|,
literal|"XLAUI"
block|,
literal|"XLPPI"
block|,
literal|"40GBASE-CR4"
block|,
literal|"10GBASE-CR1"
block|,
literal|"Reserved (12)"
block|,
literal|"Reserved (13)"
block|,
literal|"Reserved (14)"
block|,
literal|"Reserved (15)"
block|,
literal|"Reserved (16)"
block|,
literal|"100BASE-TX"
block|,
literal|"1000BASE-T"
block|,
literal|"10GBASE-T"
block|,
literal|"10GBASE-SR"
block|,
literal|"10GBASE-LR"
block|,
literal|"10GBASE-SFP+Cu"
block|,
literal|"10GBASE-CR1"
block|,
literal|"40GBASE-CR4"
block|,
literal|"40GBASE-SR4"
block|,
literal|"40GBASE-LR4"
block|,
literal|"1000BASE-SX"
block|,
literal|"1000BASE-LX"
block|,
literal|"1000BASE-T Optical"
block|,
literal|"20GBASE-KR2"
block|,
literal|"Reserved (31)"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|ext_phy_types_str
index|[
literal|4
index|]
init|=
block|{
literal|"25GBASE-KR"
block|,
literal|"25GBASE-CR"
block|,
literal|"25GBASE-SR"
block|,
literal|"25GBASE-LR"
block|}
decl_stmt|;
if|if
condition|(
name|ext
operator|&&
name|bit_pos
operator|>
literal|3
condition|)
return|return
literal|"Invalid_Ext"
return|;
if|if
condition|(
name|bit_pos
operator|>
literal|31
condition|)
return|return
literal|"Invalid"
return|;
return|return
operator|(
name|ext
operator|)
condition|?
name|ext_phy_types_str
index|[
name|bit_pos
index|]
else|:
name|phy_types_str
index|[
name|bit_pos
index|]
return|;
block|}
end_function

begin_function
name|int
name|ixl_aq_get_link_status
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|i40e_aqc_get_link_status
modifier|*
name|link_status
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|i40e_aq_desc
name|desc
decl_stmt|;
name|enum
name|i40e_status_code
name|status
decl_stmt|;
name|struct
name|i40e_aqc_get_link_status
modifier|*
name|aq_link_status
init|=
operator|(
expr|struct
name|i40e_aqc_get_link_status
operator|*
operator|)
operator|&
name|desc
operator|.
name|params
operator|.
name|raw
decl_stmt|;
name|i40e_fill_default_direct_cmd_desc
argument_list|(
operator|&
name|desc
argument_list|,
name|i40e_aqc_opc_get_link_status
argument_list|)
expr_stmt|;
name|link_status
operator|->
name|command_flags
operator|=
name|CPU_TO_LE16
argument_list|(
name|I40E_AQ_LSE_ENABLE
argument_list|)
expr_stmt|;
name|status
operator|=
name|i40e_asq_send_command
argument_list|(
name|hw
argument_list|,
operator|&
name|desc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: i40e_aqc_opc_get_link_status status %s, aq error %s\n"
argument_list|,
name|__func__
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|status
argument_list|)
argument_list|,
name|i40e_aq_str
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|aq_link_status
argument_list|,
name|link_status
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_aqc_get_link_status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|ixl_phy_type_string_ls
parameter_list|(
name|u8
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|>=
literal|0x1F
condition|)
return|return
name|ixl_phy_type_string
argument_list|(
name|val
operator|-
literal|0x1F
argument_list|,
name|true
argument_list|)
return|;
else|else
return|return
name|ixl_phy_type_string
argument_list|(
name|val
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_link_status
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|buf
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|buf
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate sbuf for sysctl output.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|struct
name|i40e_aqc_get_link_status
name|link_status
decl_stmt|;
name|error
operator|=
name|ixl_aq_get_link_status
argument_list|(
name|pf
argument_list|,
operator|&
name|link_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* TODO: Add 25G types */
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"\n"
literal|"PHY Type : 0x%02x<%s>\n"
literal|"Speed    : 0x%02x\n"
literal|"Link info: 0x%02x\n"
literal|"AN info  : 0x%02x\n"
literal|"Ext info : 0x%02x\n"
literal|"Loopback : 0x%02x\n"
literal|"Max Frame: %d\n"
literal|"Config   : 0x%02x\n"
literal|"Power    : 0x%02x"
argument_list|,
name|link_status
operator|.
name|phy_type
argument_list|,
name|ixl_phy_type_string_ls
argument_list|(
name|link_status
operator|.
name|phy_type
argument_list|)
argument_list|,
name|link_status
operator|.
name|link_speed
argument_list|,
name|link_status
operator|.
name|link_info
argument_list|,
name|link_status
operator|.
name|an_info
argument_list|,
name|link_status
operator|.
name|ext_info
argument_list|,
name|link_status
operator|.
name|loopback
argument_list|,
name|link_status
operator|.
name|max_frame_size
argument_list|,
name|link_status
operator|.
name|config
argument_list|,
name|link_status
operator|.
name|power_desc
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_finish
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error finishing sbuf: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_phy_abilities
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|enum
name|i40e_status_code
name|status
decl_stmt|;
name|struct
name|i40e_aq_get_phy_abilities_resp
name|abilities
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|buf
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|buf
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate sbuf for sysctl output.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|status
operator|=
name|i40e_aq_get_phy_capabilities
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|abilities
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: i40e_aq_get_phy_capabilities() status %s, aq error %s\n"
argument_list|,
name|__func__
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|status
argument_list|)
argument_list|,
name|i40e_aq_str
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"\n"
literal|"PHY Type : %08x"
argument_list|,
name|abilities
operator|.
name|phy_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|abilities
operator|.
name|phy_type
operator|!=
literal|0
condition|)
block|{
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&
name|abilities
operator|.
name|phy_type
condition|)
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%s,"
argument_list|,
name|ixl_phy_type_string
argument_list|(
name|i
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|">\n"
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"PHY Ext  : %02x"
argument_list|,
name|abilities
operator|.
name|phy_type_ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|abilities
operator|.
name|phy_type_ext
operator|!=
literal|0
condition|)
block|{
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&
name|abilities
operator|.
name|phy_type_ext
condition|)
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%s,"
argument_list|,
name|ixl_phy_type_string
argument_list|(
name|i
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"Speed    : %02x\n"
literal|"Abilities: %02x\n"
literal|"EEE cap  : %04x\n"
literal|"EEER reg : %08x\n"
literal|"D3 Lpan  : %02x\n"
literal|"ID       : %02x %02x %02x %02x\n"
literal|"ModType  : %02x %02x %02x\n"
literal|"ModType E: %01x\n"
literal|"FEC Cfg  : %02x\n"
literal|"Ext CC   : %02x"
argument_list|,
name|abilities
operator|.
name|link_speed
argument_list|,
name|abilities
operator|.
name|abilities
argument_list|,
name|abilities
operator|.
name|eee_capability
argument_list|,
name|abilities
operator|.
name|eeer_val
argument_list|,
name|abilities
operator|.
name|d3_lpan
argument_list|,
name|abilities
operator|.
name|phy_id
index|[
literal|0
index|]
argument_list|,
name|abilities
operator|.
name|phy_id
index|[
literal|1
index|]
argument_list|,
name|abilities
operator|.
name|phy_id
index|[
literal|2
index|]
argument_list|,
name|abilities
operator|.
name|phy_id
index|[
literal|3
index|]
argument_list|,
name|abilities
operator|.
name|module_type
index|[
literal|0
index|]
argument_list|,
name|abilities
operator|.
name|module_type
index|[
literal|1
index|]
argument_list|,
name|abilities
operator|.
name|module_type
index|[
literal|2
index|]
argument_list|,
name|abilities
operator|.
name|phy_type_ext
operator|>>
literal|5
argument_list|,
name|abilities
operator|.
name|phy_type_ext
operator|&
literal|0x1F
argument_list|,
name|abilities
operator|.
name|ext_comp_code
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_finish
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error finishing sbuf: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_sw_filter_list
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|buf_i
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|ftl_len
init|=
literal|0
decl_stmt|;
name|int
name|ftl_counter
init|=
literal|0
decl_stmt|;
name|int
name|buf_len
init|=
literal|0
decl_stmt|;
name|int
name|entry_len
init|=
literal|42
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|)
block|{
name|ftl_len
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ftl_len
operator|<
literal|1
condition|)
block|{
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
literal|"(none)"
argument_list|,
literal|6
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|buf_len
operator|=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
operator|(
name|entry_len
operator|+
literal|1
operator|)
operator|*
name|ftl_len
operator|+
literal|2
expr_stmt|;
name|buf
operator|=
name|buf_i
operator|=
name|malloc
argument_list|(
name|buf_len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf_i
operator|++
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|)
block|{
name|sprintf
argument_list|(
name|buf_i
argument_list|,
name|MAC_FORMAT
literal|", vlan %4d, flags %#06x"
argument_list|,
name|MAC_FORMAT_ARGS
argument_list|(
name|f
operator|->
name|macaddr
argument_list|)
argument_list|,
name|f
operator|->
name|vlan
argument_list|,
name|f
operator|->
name|flags
argument_list|)
expr_stmt|;
name|buf_i
operator|+=
name|entry_len
expr_stmt|;
comment|/* don't print '\n' for last entry */
if|if
condition|(
operator|++
name|ftl_counter
operator|!=
name|ftl_len
condition|)
block|{
name|sprintf
argument_list|(
name|buf_i
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|buf_i
operator|++
expr_stmt|;
block|}
block|}
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"sysctl error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IXL_SW_RES_SIZE
value|0x14
end_define

begin_function
name|int
name|ixl_res_alloc_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|i40e_aqc_switch_resource_alloc_element_resp
modifier|*
name|one
decl_stmt|,
modifier|*
name|two
decl_stmt|;
name|one
operator|=
operator|(
specifier|const
expr|struct
name|i40e_aqc_switch_resource_alloc_element_resp
operator|*
operator|)
name|a
expr_stmt|;
name|two
operator|=
operator|(
specifier|const
expr|struct
name|i40e_aqc_switch_resource_alloc_element_resp
operator|*
operator|)
name|b
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|one
operator|->
name|resource_type
operator|-
operator|(
name|int
operator|)
name|two
operator|->
name|resource_type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Longest string length: 25   */
end_comment

begin_function
name|char
modifier|*
name|ixl_switch_res_type_string
parameter_list|(
name|u8
name|type
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|ixl_switch_res_type_strings
index|[
literal|0x14
index|]
init|=
block|{
literal|"VEB"
block|,
literal|"VSI"
block|,
literal|"Perfect Match MAC address"
block|,
literal|"S-tag"
block|,
literal|"(Reserved)"
block|,
literal|"Multicast hash entry"
block|,
literal|"Unicast hash entry"
block|,
literal|"VLAN"
block|,
literal|"VSI List entry"
block|,
literal|"(Reserved)"
block|,
literal|"VLAN Statistic Pool"
block|,
literal|"Mirror Rule"
block|,
literal|"Queue Set"
block|,
literal|"Inner VLAN Forward filter"
block|,
literal|"(Reserved)"
block|,
literal|"Inner MAC"
block|,
literal|"IP"
block|,
literal|"GRE/VN1 Key"
block|,
literal|"VN2 Key"
block|,
literal|"Tunneling Port"
block|}
decl_stmt|;
if|if
condition|(
name|type
operator|<
literal|0x14
condition|)
return|return
name|ixl_switch_res_type_strings
index|[
name|type
index|]
return|;
else|else
return|return
literal|"(Reserved)"
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_hw_res_alloc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|buf
decl_stmt|;
name|enum
name|i40e_status_code
name|status
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u8
name|num_entries
decl_stmt|;
name|struct
name|i40e_aqc_switch_resource_alloc_element_resp
name|resp
index|[
name|IXL_SW_RES_SIZE
index|]
decl_stmt|;
name|buf
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate sbuf for output.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
name|resp
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|i40e_aq_get_switch_resource_alloc
argument_list|(
name|hw
argument_list|,
operator|&
name|num_entries
argument_list|,
name|resp
argument_list|,
name|IXL_SW_RES_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: get_switch_resource_alloc() error %s, aq error %s\n"
argument_list|,
name|__func__
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|status
argument_list|)
argument_list|,
name|i40e_aq_str
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Sort entries by type for display */
name|qsort
argument_list|(
name|resp
argument_list|,
name|num_entries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_aqc_switch_resource_alloc_element_resp
argument_list|)
argument_list|,
operator|&
name|ixl_res_alloc_cmp
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"# of entries: %d\n"
argument_list|,
name|num_entries
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"                     Type | Guaranteed | Total | Used   | Un-allocated\n"
literal|"                          | (this)     | (all) | (this) | (all)       \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
name|i
operator|++
control|)
block|{
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%25s | %10d   %5d   %6d   %12d"
argument_list|,
name|ixl_switch_res_type_string
argument_list|(
name|resp
index|[
name|i
index|]
operator|.
name|resource_type
argument_list|)
argument_list|,
name|resp
index|[
name|i
index|]
operator|.
name|guaranteed
argument_list|,
name|resp
index|[
name|i
index|]
operator|.
name|total
argument_list|,
name|resp
index|[
name|i
index|]
operator|.
name|used
argument_list|,
name|resp
index|[
name|i
index|]
operator|.
name|total_unalloced
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|num_entries
operator|-
literal|1
condition|)
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sbuf_finish
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error finishing sbuf: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Caller must init and delete sbuf; this function will clear and ** finish it for caller. ** ** XXX: Cannot use the SEID for this, since there is no longer a  ** fixed mapping between SEID and element type. */
end_comment

begin_function
name|char
modifier|*
name|ixl_switch_element_string
parameter_list|(
name|struct
name|sbuf
modifier|*
name|s
parameter_list|,
name|struct
name|i40e_aqc_switch_config_element_resp
modifier|*
name|element
parameter_list|)
block|{
name|sbuf_clear
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|element
operator|->
name|element_type
condition|)
block|{
case|case
name|I40E_AQ_SW_ELEM_TYPE_MAC
case|:
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"MAC %3d"
argument_list|,
name|element
operator|->
name|element_info
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_AQ_SW_ELEM_TYPE_PF
case|:
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"PF  %3d"
argument_list|,
name|element
operator|->
name|element_info
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_AQ_SW_ELEM_TYPE_VF
case|:
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"VF  %3d"
argument_list|,
name|element
operator|->
name|element_info
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_AQ_SW_ELEM_TYPE_EMP
case|:
name|sbuf_cat
argument_list|(
name|s
argument_list|,
literal|"EMP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_AQ_SW_ELEM_TYPE_BMC
case|:
name|sbuf_cat
argument_list|(
name|s
argument_list|,
literal|"BMC"
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_AQ_SW_ELEM_TYPE_PV
case|:
name|sbuf_cat
argument_list|(
name|s
argument_list|,
literal|"PV"
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_AQ_SW_ELEM_TYPE_VEB
case|:
name|sbuf_cat
argument_list|(
name|s
argument_list|,
literal|"VEB"
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_AQ_SW_ELEM_TYPE_PA
case|:
name|sbuf_cat
argument_list|(
name|s
argument_list|,
literal|"PA"
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_AQ_SW_ELEM_TYPE_VSI
case|:
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"VSI %3d"
argument_list|,
name|element
operator|->
name|element_info
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sbuf_cat
argument_list|(
name|s
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
break|break;
block|}
name|sbuf_finish
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|sbuf_data
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_switch_config
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|buf
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|nmbuf
decl_stmt|;
name|enum
name|i40e_status_code
name|status
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u16
name|next
init|=
literal|0
decl_stmt|;
name|u8
name|aq_buf
index|[
name|I40E_AQ_LARGE_BUF
index|]
decl_stmt|;
name|struct
name|i40e_aqc_get_switch_config_resp
modifier|*
name|sw_config
decl_stmt|;
name|sw_config
operator|=
operator|(
expr|struct
name|i40e_aqc_get_switch_config_resp
operator|*
operator|)
name|aq_buf
expr_stmt|;
name|buf
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate sbuf for sysctl output.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|status
operator|=
name|i40e_aq_get_switch_config
argument_list|(
name|hw
argument_list|,
name|sw_config
argument_list|,
sizeof|sizeof
argument_list|(
name|aq_buf
argument_list|)
argument_list|,
operator|&
name|next
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: aq_get_switch_config() error %s, aq error %s\n"
argument_list|,
name|__func__
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|status
argument_list|)
argument_list|,
name|i40e_aq_str
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|next
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: TODO: get more config with SEID %d\n"
argument_list|,
name|__func__
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|nmbuf
operator|=
name|sbuf_new_auto
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|nmbuf
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate sbuf for name output.\n"
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Assuming<= 255 elements in switch */
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"# of reported elements: %d\n"
argument_list|,
name|sw_config
operator|->
name|header
operator|.
name|num_reported
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"total # of elements: %d\n"
argument_list|,
name|sw_config
operator|->
name|header
operator|.
name|num_total
argument_list|)
expr_stmt|;
comment|/* Exclude: 	** Revision -- all elements are revision 1 for now 	*/
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"SEID (  Name  ) |  Uplink  | Downlink | Conn Type\n"
literal|"                |          |          | (uplink)\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sw_config
operator|->
name|header
operator|.
name|num_reported
condition|;
name|i
operator|++
control|)
block|{
comment|// "%4d (%8s) | %8s   %8s   %#8x",
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%4d"
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|seid
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"(%8s)"
argument_list|,
name|ixl_switch_element_string
argument_list|(
name|nmbuf
argument_list|,
operator|&
name|sw_config
operator|->
name|element
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|" | "
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%8d"
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|uplink_seid
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"   "
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%8d"
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|downlink_seid
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"   "
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%#8x"
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|connection_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|sw_config
operator|->
name|header
operator|.
name|num_reported
operator|-
literal|1
condition|)
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|sbuf_delete
argument_list|(
name|nmbuf
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_finish
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error finishing sbuf: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_hkey
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|buf
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|enum
name|i40e_status_code
name|status
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|struct
name|i40e_aqc_get_set_rss_key_data
name|key_data
decl_stmt|;
name|buf
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate sbuf for output.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|I40E_MAC_X722
condition|)
block|{
name|bzero
argument_list|(
name|key_data
operator|.
name|standard_rss_key
argument_list|,
sizeof|sizeof
argument_list|(
name|key_data
operator|.
name|standard_rss_key
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|i40e_aq_get_rss_key
argument_list|(
name|hw
argument_list|,
name|pf
operator|->
name|vsi
operator|.
name|vsi_num
argument_list|,
operator|&
name|key_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"i40e_aq_get_rss_key status %s, error %s\n"
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|status
argument_list|)
argument_list|,
name|i40e_aq_str
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%40D"
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|key_data
operator|.
name|standard_rss_key
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IXL_RSS_KEY_SIZE_REG
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|i40e_read_rx_ctl
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HKEY
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%4D"
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|reg
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|sbuf_finish
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error finishing sbuf: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_hlut
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|buf
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|enum
name|i40e_status_code
name|status
decl_stmt|;
name|u8
name|hlut
index|[
literal|512
index|]
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|buf
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate sbuf for output.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|I40E_MAC_X722
condition|)
block|{
name|bzero
argument_list|(
name|hlut
argument_list|,
sizeof|sizeof
argument_list|(
name|hlut
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|i40e_aq_get_rss_lut
argument_list|(
name|hw
argument_list|,
name|pf
operator|->
name|vsi
operator|.
name|vsi_num
argument_list|,
name|TRUE
argument_list|,
name|hlut
argument_list|,
sizeof|sizeof
argument_list|(
name|hlut
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"i40e_aq_get_rss_lut status %s, error %s\n"
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|status
argument_list|)
argument_list|,
name|i40e_aq_str
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%512D"
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|hlut
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|func_caps
operator|.
name|rss_table_size
operator|>>
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HLUT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%4D"
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|reg
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|sbuf_finish
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error finishing sbuf: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_hena
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|u64
name|hena
decl_stmt|;
name|hena
operator|=
operator|(
name|u64
operator|)
name|i40e_read_rx_ctl
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HENA
argument_list|(
literal|0
argument_list|)
argument_list|)
operator||
operator|(
operator|(
name|u64
operator|)
name|i40e_read_rx_ctl
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HENA
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
return|return
name|sysctl_handle_long
argument_list|(
name|oidp
argument_list|,
name|NULL
argument_list|,
name|hena
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sysctl to disable firmware's link management  *  * 1 - Disable link management on this port  * 0 - Re-enable link management  *  * On normal NVMs, firmware manages link by default.  */
end_comment

begin_function
specifier|static
name|int
name|ixl_sysctl_fw_link_management
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|requested_mode
init|=
operator|-
literal|1
decl_stmt|;
name|enum
name|i40e_status_code
name|status
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Read in new mode */
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|requested_mode
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Check for sane value */
if|if
condition|(
name|requested_mode
operator|<
literal|0
operator|||
name|requested_mode
operator|>
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Valid modes are 0 or 1\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Set new mode */
name|status
operator|=
name|i40e_aq_set_phy_debug
argument_list|(
name|hw
argument_list|,
operator|!
operator|!
operator|(
name|requested_mode
operator|)
operator|<<
literal|4
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Error setting new phy debug mode %s,"
literal|" aq error: %s\n"
argument_list|,
name|__func__
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|status
argument_list|)
argument_list|,
name|i40e_aq_str
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sysctl to read a byte from I2C bus.  *  * Input: 32-bit value:  * 	bits 0-7:   device address (0xA0 or 0xA2)  * 	bits 8-15:  offset (0-255)  *	bits 16-31: unused  * Output: 8-bit value read  */
end_comment

begin_function
specifier|static
name|int
name|ixl_sysctl_read_i2c_byte
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|input
init|=
operator|-
literal|1
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: start\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|u8
name|dev_addr
decl_stmt|,
name|offset
decl_stmt|,
name|output
decl_stmt|;
comment|/* Read in I2C read parameters */
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|input
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Validate device address */
name|dev_addr
operator|=
name|input
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
name|dev_addr
operator|!=
literal|0xA0
operator|&&
name|dev_addr
operator|!=
literal|0xA2
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|offset
operator|=
operator|(
name|input
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|error
operator|=
name|ixl_read_i2c_byte
argument_list|(
name|pf
argument_list|,
name|offset
argument_list|,
name|dev_addr
argument_list|,
operator|&
name|output
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%02X\n"
argument_list|,
name|output
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sysctl to write a byte to the I2C bus.  *  * Input: 32-bit value:  * 	bits 0-7:   device address (0xA0 or 0xA2)  * 	bits 8-15:  offset (0-255)  *	bits 16-23: value to write  *	bits 24-31: unused  * Output: 8-bit value written  */
end_comment

begin_function
specifier|static
name|int
name|ixl_sysctl_write_i2c_byte
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|input
init|=
operator|-
literal|1
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|u8
name|dev_addr
decl_stmt|,
name|offset
decl_stmt|,
name|value
decl_stmt|;
comment|/* Read in I2C write parameters */
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|input
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Validate device address */
name|dev_addr
operator|=
name|input
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
name|dev_addr
operator|!=
literal|0xA0
operator|&&
name|dev_addr
operator|!=
literal|0xA2
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|offset
operator|=
operator|(
name|input
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|value
operator|=
operator|(
name|input
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|error
operator|=
name|ixl_write_i2c_byte
argument_list|(
name|pf
argument_list|,
name|offset
argument_list|,
name|dev_addr
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%02X written\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_get_fec_config
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|i40e_aq_get_phy_abilities_resp
modifier|*
name|abilities
parameter_list|,
name|u8
name|bit_pos
parameter_list|,
name|int
modifier|*
name|is_set
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|enum
name|i40e_status_code
name|status
decl_stmt|;
name|status
operator|=
name|i40e_aq_get_phy_capabilities
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|abilities
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: i40e_aq_get_phy_capabilities() status %s, aq error %s\n"
argument_list|,
name|__func__
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|status
argument_list|)
argument_list|,
name|i40e_aq_str
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
operator|*
name|is_set
operator|=
operator|!
operator|!
operator|(
name|abilities
operator|->
name|phy_type_ext
operator|&
name|bit_pos
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_set_fec_config
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|i40e_aq_get_phy_abilities_resp
modifier|*
name|abilities
parameter_list|,
name|u8
name|bit_pos
parameter_list|,
name|int
name|set
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|i40e_aq_set_phy_config
name|config
decl_stmt|;
name|enum
name|i40e_status_code
name|status
decl_stmt|;
comment|/* Set new PHY config */
name|memset
argument_list|(
operator|&
name|config
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|config
argument_list|)
argument_list|)
expr_stmt|;
name|config
operator|.
name|fec_config
operator|=
name|abilities
operator|->
name|phy_type_ext
operator|&
operator|~
operator|(
name|bit_pos
operator|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
name|config
operator|.
name|fec_config
operator||=
name|bit_pos
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|fec_config
operator|!=
name|abilities
operator|->
name|phy_type_ext
condition|)
block|{
name|config
operator|.
name|abilities
operator||=
name|I40E_AQ_PHY_ENABLE_ATOMIC_LINK
expr_stmt|;
name|config
operator|.
name|phy_type
operator|=
name|abilities
operator|->
name|phy_type
expr_stmt|;
name|config
operator|.
name|phy_type_ext
operator|=
name|abilities
operator|->
name|phy_type_ext
expr_stmt|;
name|config
operator|.
name|link_speed
operator|=
name|abilities
operator|->
name|link_speed
expr_stmt|;
name|config
operator|.
name|eee_capability
operator|=
name|abilities
operator|->
name|eee_capability
expr_stmt|;
name|config
operator|.
name|eeer
operator|=
name|abilities
operator|->
name|eeer_val
expr_stmt|;
name|config
operator|.
name|low_power_ctrl
operator|=
name|abilities
operator|->
name|d3_lpan
expr_stmt|;
name|status
operator|=
name|i40e_aq_set_phy_config
argument_list|(
name|hw
argument_list|,
operator|&
name|config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: i40e_aq_set_phy_config() status %s, aq error %s\n"
argument_list|,
name|__func__
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|status
argument_list|)
argument_list|,
name|i40e_aq_str
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_fec_fc_ability
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|i40e_aq_get_phy_abilities_resp
name|abilities
decl_stmt|;
name|error
operator|=
name|ixl_get_fec_config
argument_list|(
name|pf
argument_list|,
operator|&
name|abilities
argument_list|,
name|I40E_AQ_SET_FEC_ABILITY_KR
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Read in new mode */
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|mode
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
name|ixl_set_fec_config
argument_list|(
name|pf
argument_list|,
operator|&
name|abilities
argument_list|,
name|I40E_AQ_SET_FEC_ABILITY_KR
argument_list|,
operator|!
operator|!
operator|(
name|mode
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_fec_rs_ability
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|i40e_aq_get_phy_abilities_resp
name|abilities
decl_stmt|;
name|error
operator|=
name|ixl_get_fec_config
argument_list|(
name|pf
argument_list|,
operator|&
name|abilities
argument_list|,
name|I40E_AQ_SET_FEC_ABILITY_RS
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Read in new mode */
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|mode
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
name|ixl_set_fec_config
argument_list|(
name|pf
argument_list|,
operator|&
name|abilities
argument_list|,
name|I40E_AQ_SET_FEC_ABILITY_RS
argument_list|,
operator|!
operator|!
operator|(
name|mode
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_fec_fc_request
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|i40e_aq_get_phy_abilities_resp
name|abilities
decl_stmt|;
name|error
operator|=
name|ixl_get_fec_config
argument_list|(
name|pf
argument_list|,
operator|&
name|abilities
argument_list|,
name|I40E_AQ_SET_FEC_REQUEST_KR
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Read in new mode */
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|mode
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
name|ixl_set_fec_config
argument_list|(
name|pf
argument_list|,
operator|&
name|abilities
argument_list|,
name|I40E_AQ_SET_FEC_REQUEST_KR
argument_list|,
operator|!
operator|!
operator|(
name|mode
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_fec_rs_request
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|i40e_aq_get_phy_abilities_resp
name|abilities
decl_stmt|;
name|error
operator|=
name|ixl_get_fec_config
argument_list|(
name|pf
argument_list|,
operator|&
name|abilities
argument_list|,
name|I40E_AQ_SET_FEC_REQUEST_RS
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Read in new mode */
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|mode
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
name|ixl_set_fec_config
argument_list|(
name|pf
argument_list|,
operator|&
name|abilities
argument_list|,
name|I40E_AQ_SET_FEC_REQUEST_RS
argument_list|,
operator|!
operator|!
operator|(
name|mode
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_fec_auto_enable
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|i40e_aq_get_phy_abilities_resp
name|abilities
decl_stmt|;
name|error
operator|=
name|ixl_get_fec_config
argument_list|(
name|pf
argument_list|,
operator|&
name|abilities
argument_list|,
name|I40E_AQ_SET_FEC_AUTO
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Read in new mode */
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|mode
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
name|ixl_set_fec_config
argument_list|(
name|pf
argument_list|,
operator|&
name|abilities
argument_list|,
name|I40E_AQ_SET_FEC_AUTO
argument_list|,
operator|!
operator|!
operator|(
name|mode
operator|)
argument_list|)
return|;
block|}
end_function

end_unit

