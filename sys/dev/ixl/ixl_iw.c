begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2013-2015, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"ixl.h"
end_include

begin_include
include|#
directive|include
file|"ixl_pf.h"
end_include

begin_include
include|#
directive|include
file|"ixl_iw.h"
end_include

begin_include
include|#
directive|include
file|"ixl_iw_int.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IXL_IW
end_ifdef

begin_define
define|#
directive|define
name|IXL_IW_VEC_BASE
parameter_list|(
name|pf
parameter_list|)
value|((pf)->msix - (pf)->iw_msix)
end_define

begin_define
define|#
directive|define
name|IXL_IW_VEC_COUNT
parameter_list|(
name|pf
parameter_list|)
value|((pf)->iw_msix)
end_define

begin_define
define|#
directive|define
name|IXL_IW_VEC_LIMIT
parameter_list|(
name|pf
parameter_list|)
value|((pf)->msix)
end_define

begin_decl_stmt
specifier|extern
name|int
name|ixl_enable_iwarp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ixl_iw_state
name|ixl_iw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ixl_iw_ref_cnt
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ixl_iw_pf_msix_reset
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|int
name|vec
decl_stmt|;
for|for
control|(
name|vec
operator|=
name|IXL_IW_VEC_BASE
argument_list|(
name|pf
argument_list|)
init|;
name|vec
operator|<
name|IXL_IW_VEC_LIMIT
argument_list|(
name|pf
argument_list|)
condition|;
name|vec
operator|++
control|)
block|{
name|reg
operator|=
name|I40E_PFINT_LNKLSTN_FIRSTQ_INDX_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_LNKLSTN
argument_list|(
name|vec
operator|-
literal|1
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_iw_invoke_op
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ixl_iw_pf_entry
modifier|*
name|pf_entry
init|=
operator|(
expr|struct
name|ixl_iw_pf_entry
operator|*
operator|)
name|context
decl_stmt|;
name|struct
name|ixl_iw_pf
name|info
decl_stmt|;
name|bool
name|initialize
decl_stmt|;
name|int
name|err
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"begin"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ixl_iw
operator|.
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pf_entry
operator|->
name|state
operator|.
name|iw_scheduled
operator|==
name|IXL_IW_PF_STATE_ON
operator|)
operator|&&
operator|(
name|pf_entry
operator|->
name|state
operator|.
name|iw_current
operator|==
name|IXL_IW_PF_STATE_OFF
operator|)
condition|)
name|initialize
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pf_entry
operator|->
name|state
operator|.
name|iw_scheduled
operator|==
name|IXL_IW_PF_STATE_OFF
operator|)
operator|&&
operator|(
name|pf_entry
operator|->
name|state
operator|.
name|iw_current
operator|==
name|IXL_IW_PF_STATE_ON
operator|)
condition|)
name|initialize
operator|=
name|false
expr_stmt|;
else|else
block|{
comment|/* nothing to be done, so finish here */
name|mtx_unlock
argument_list|(
operator|&
name|ixl_iw
operator|.
name|mtx
argument_list|)
expr_stmt|;
return|return;
block|}
name|info
operator|=
name|pf_entry
operator|->
name|pf_info
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ixl_iw
operator|.
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialize
condition|)
block|{
name|err
operator|=
name|ixl_iw
operator|.
name|ops
operator|->
name|init
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|device_printf
argument_list|(
name|pf_entry
operator|->
name|pf
operator|->
name|dev
argument_list|,
literal|"%s: failed to initialize iwarp (err %d)\n"
argument_list|,
name|__func__
argument_list|,
name|err
argument_list|)
expr_stmt|;
else|else
name|pf_entry
operator|->
name|state
operator|.
name|iw_current
operator|=
name|IXL_IW_PF_STATE_ON
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|ixl_iw
operator|.
name|ops
operator|->
name|stop
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|device_printf
argument_list|(
name|pf_entry
operator|->
name|pf
operator|->
name|dev
argument_list|,
literal|"%s: failed to stop iwarp (err %d)\n"
argument_list|,
name|__func__
argument_list|,
name|err
argument_list|)
expr_stmt|;
else|else
block|{
name|ixl_iw_pf_msix_reset
argument_list|(
name|pf_entry
operator|->
name|pf
argument_list|)
expr_stmt|;
name|pf_entry
operator|->
name|state
operator|.
name|iw_current
operator|=
name|IXL_IW_PF_STATE_OFF
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_iw_uninit
parameter_list|(
name|void
parameter_list|)
block|{
name|INIT_DEBUGOUT
argument_list|(
literal|"begin"
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ixl_iw
operator|.
name|mtx
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_iw_init
parameter_list|(
name|void
parameter_list|)
block|{
name|INIT_DEBUGOUT
argument_list|(
literal|"begin"
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ixl_iw
operator|.
name|pfs
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ixl_iw
operator|.
name|mtx
argument_list|,
literal|"ixl_iw_pfs"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|ixl_iw
operator|.
name|registered
operator|=
name|false
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * if_ixl internal API  *****************************************************************************/
end_comment

begin_function
name|int
name|ixl_iw_pf_init
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|ixl_iw_pf_entry
modifier|*
name|pf_entry
decl_stmt|;
name|struct
name|ixl_iw_pf
modifier|*
name|pf_info
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"begin"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ixl_iw
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pf_entry
argument_list|,
argument|&ixl_iw.pfs
argument_list|,
argument|node
argument_list|)
if|if
condition|(
name|pf_entry
operator|->
name|pf
operator|==
name|pf
condition|)
break|break;
if|if
condition|(
name|pf_entry
operator|==
name|NULL
condition|)
block|{
comment|/* attempt to initialize PF not yet attached - sth is wrong */
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"%s: PF not found\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|pf_info
operator|=
operator|&
name|pf_entry
operator|->
name|pf_info
expr_stmt|;
name|pf_info
operator|->
name|handle
operator|=
operator|(
name|void
operator|*
operator|)
name|pf
expr_stmt|;
name|pf_info
operator|->
name|ifp
operator|=
name|pf
operator|->
name|vsi
operator|.
name|ifp
expr_stmt|;
name|pf_info
operator|->
name|dev
operator|=
name|pf
operator|->
name|dev
expr_stmt|;
name|pf_info
operator|->
name|pci_mem
operator|=
name|pf
operator|->
name|pci_mem
expr_stmt|;
name|pf_info
operator|->
name|pf_id
operator|=
name|pf
operator|->
name|hw
operator|.
name|pf_id
expr_stmt|;
name|pf_info
operator|->
name|mtu
operator|=
name|pf
operator|->
name|vsi
operator|.
name|ifp
operator|->
name|if_mtu
expr_stmt|;
name|pf_info
operator|->
name|iw_msix
operator|.
name|count
operator|=
name|IXL_IW_VEC_COUNT
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|pf_info
operator|->
name|iw_msix
operator|.
name|base
operator|=
name|IXL_IW_VEC_BASE
argument_list|(
name|pf
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IXL_IW_MAX_USER_PRIORITY
condition|;
name|i
operator|++
control|)
name|pf_info
operator|->
name|qs_handle
index|[
name|i
index|]
operator|=
name|le16_to_cpu
argument_list|(
name|pf
operator|->
name|vsi
operator|.
name|info
operator|.
name|qs_handle
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pf_entry
operator|->
name|state
operator|.
name|pf
operator|=
name|IXL_IW_PF_STATE_ON
expr_stmt|;
if|if
condition|(
name|ixl_iw
operator|.
name|registered
condition|)
block|{
name|pf_entry
operator|->
name|state
operator|.
name|iw_scheduled
operator|=
name|IXL_IW_PF_STATE_ON
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|ixl_iw
operator|.
name|tq
argument_list|,
operator|&
name|pf_entry
operator|->
name|iw_task
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|ixl_iw
operator|.
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ixl_iw_pf_stop
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|ixl_iw_pf_entry
modifier|*
name|pf_entry
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"begin"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ixl_iw
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pf_entry
argument_list|,
argument|&ixl_iw.pfs
argument_list|,
argument|node
argument_list|)
if|if
condition|(
name|pf_entry
operator|->
name|pf
operator|==
name|pf
condition|)
break|break;
if|if
condition|(
name|pf_entry
operator|==
name|NULL
condition|)
block|{
comment|/* attempt to stop PF which has not been attached - sth is wrong */
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"%s: PF not found\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|pf_entry
operator|->
name|state
operator|.
name|pf
operator|=
name|IXL_IW_PF_STATE_OFF
expr_stmt|;
if|if
condition|(
name|pf_entry
operator|->
name|state
operator|.
name|iw_scheduled
operator|==
name|IXL_IW_PF_STATE_ON
condition|)
block|{
name|pf_entry
operator|->
name|state
operator|.
name|iw_scheduled
operator|=
name|IXL_IW_PF_STATE_OFF
expr_stmt|;
if|if
condition|(
name|ixl_iw
operator|.
name|registered
condition|)
name|taskqueue_enqueue
argument_list|(
name|ixl_iw
operator|.
name|tq
argument_list|,
operator|&
name|pf_entry
operator|->
name|iw_task
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|ixl_iw
operator|.
name|mtx
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|ixl_iw_pf_attach
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|ixl_iw_pf_entry
modifier|*
name|pf_entry
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixl_iw_ref_cnt
operator|==
literal|0
condition|)
name|ixl_iw_init
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ixl_iw
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pf_entry
argument_list|,
argument|&ixl_iw.pfs
argument_list|,
argument|node
argument_list|)
if|if
condition|(
name|pf_entry
operator|->
name|pf
operator|==
name|pf
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"%s: PF already exists\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|err
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|pf_entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixl_iw_pf_entry
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf_entry
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"%s: failed to allocate memory to attach new PF\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|pf_entry
operator|->
name|pf
operator|=
name|pf
expr_stmt|;
name|pf_entry
operator|->
name|state
operator|.
name|pf
operator|=
name|IXL_IW_PF_STATE_OFF
expr_stmt|;
name|pf_entry
operator|->
name|state
operator|.
name|iw_scheduled
operator|=
name|IXL_IW_PF_STATE_OFF
expr_stmt|;
name|pf_entry
operator|->
name|state
operator|.
name|iw_current
operator|=
name|IXL_IW_PF_STATE_OFF
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ixl_iw
operator|.
name|pfs
argument_list|,
name|pf_entry
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|ixl_iw_ref_cnt
operator|++
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|pf_entry
operator|->
name|iw_task
argument_list|,
literal|0
argument_list|,
name|ixl_iw_invoke_op
argument_list|,
name|pf_entry
argument_list|)
expr_stmt|;
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|ixl_iw
operator|.
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixl_iw_pf_detach
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|ixl_iw_pf_entry
modifier|*
name|pf_entry
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"begin"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ixl_iw
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pf_entry
argument_list|,
argument|&ixl_iw.pfs
argument_list|,
argument|node
argument_list|)
if|if
condition|(
name|pf_entry
operator|->
name|pf
operator|==
name|pf
condition|)
break|break;
if|if
condition|(
name|pf_entry
operator|==
name|NULL
condition|)
block|{
comment|/* attempt to stop PF which has not been attached - sth is wrong */
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"%s: PF not found\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|pf_entry
operator|->
name|state
operator|.
name|pf
operator|!=
name|IXL_IW_PF_STATE_OFF
condition|)
block|{
comment|/* attempt to detach PF which has not yet been stopped - sth is wrong */
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"%s: failed - PF is still active\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|err
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|LIST_REMOVE
argument_list|(
name|pf_entry
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pf_entry
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ixl_iw_ref_cnt
operator|--
expr_stmt|;
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|ixl_iw
operator|.
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixl_iw_ref_cnt
operator|==
literal|0
condition|)
name|ixl_iw_uninit
argument_list|()
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * API exposed to iw_ixl module  *****************************************************************************/
end_comment

begin_function
name|int
name|ixl_iw_pf_reset
parameter_list|(
name|void
modifier|*
name|pf_handle
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|pf_handle
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"begin"
argument_list|)
expr_stmt|;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_init_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixl_iw_pf_msix_init
parameter_list|(
name|void
modifier|*
name|pf_handle
parameter_list|,
name|struct
name|ixl_iw_msix_mapping
modifier|*
name|msix_info
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|pf_handle
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|int
name|vec
decl_stmt|,
name|i
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"begin"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msix_info
operator|->
name|aeq_vector
operator|<
name|IXL_IW_VEC_BASE
argument_list|(
name|pf
argument_list|)
operator|)
operator|||
operator|(
name|msix_info
operator|->
name|aeq_vector
operator|>=
name|IXL_IW_VEC_LIMIT
argument_list|(
name|pf
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: invalid MSIX vector (%i) for AEQ\n"
argument_list|,
name|__func__
argument_list|,
name|msix_info
operator|->
name|aeq_vector
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|reg
operator|=
name|I40E_PFINT_AEQCTL_CAUSE_ENA_MASK
operator||
operator|(
name|msix_info
operator|->
name|aeq_vector
operator|<<
name|I40E_PFINT_AEQCTL_MSIX_INDX_SHIFT
operator|)
operator||
operator|(
name|msix_info
operator|->
name|itr_indx
operator|<<
name|I40E_PFINT_AEQCTL_ITR_INDX_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_AEQCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
for|for
control|(
name|vec
operator|=
name|IXL_IW_VEC_BASE
argument_list|(
name|pf
argument_list|)
init|;
name|vec
operator|<
name|IXL_IW_VEC_LIMIT
argument_list|(
name|pf
argument_list|)
condition|;
name|vec
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msix_info
operator|->
name|ceq_cnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|msix_info
operator|->
name|ceq_vector
index|[
name|i
index|]
operator|==
name|vec
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|msix_info
operator|->
name|ceq_cnt
condition|)
block|{
comment|/* this vector has no CEQ mapped */
name|reg
operator|=
name|I40E_PFINT_LNKLSTN_FIRSTQ_INDX_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_LNKLSTN
argument_list|(
name|vec
operator|-
literal|1
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
operator|(
name|i
operator|&
name|I40E_PFINT_LNKLSTN_FIRSTQ_INDX_MASK
operator|)
operator||
operator|(
name|I40E_QUEUE_TYPE_PE_CEQ
operator|<<
name|I40E_PFINT_LNKLSTN_FIRSTQ_TYPE_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_LNKLSTN
argument_list|(
name|vec
operator|-
literal|1
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|I40E_PFINT_CEQCTL_CAUSE_ENA_MASK
operator||
operator|(
name|vec
operator|<<
name|I40E_PFINT_CEQCTL_MSIX_INDX_SHIFT
operator|)
operator||
operator|(
name|msix_info
operator|->
name|itr_indx
operator|<<
name|I40E_PFINT_CEQCTL_ITR_INDX_SHIFT
operator|)
operator||
operator|(
name|IXL_QUEUE_EOL
operator|<<
name|I40E_PFINT_CEQCTL_NEXTQ_INDX_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_CEQCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixl_iw_register
parameter_list|(
name|struct
name|ixl_iw_ops
modifier|*
name|ops
parameter_list|)
block|{
name|struct
name|ixl_iw_pf_entry
modifier|*
name|pf_entry
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixl_enable_iwarp
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: enable_iwarp is off, registering dropped\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ops
operator|->
name|init
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ops
operator|->
name|stop
operator|==
name|NULL
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: invalid iwarp driver ops\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|ixl_iw
operator|.
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixl_iw
operator|.
name|registered
condition|)
block|{
name|printf
argument_list|(
literal|"%s: iwarp driver already registered\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|err
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ixl_iw
operator|.
name|tq
operator|=
name|taskqueue_create
argument_list|(
literal|"ixl_iw"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|ixl_iw
operator|.
name|tq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixl_iw
operator|.
name|tq
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: failed to create queue\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|taskqueue_start_threads
argument_list|(
operator|&
name|ixl_iw
operator|.
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"ixl iw"
argument_list|)
expr_stmt|;
name|ixl_iw
operator|.
name|ops
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixl_iw_ops
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixl_iw
operator|.
name|ops
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: failed to allocate memory\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|ixl_iw
operator|.
name|tq
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ixl_iw
operator|.
name|ops
operator|->
name|init
operator|=
name|ops
operator|->
name|init
expr_stmt|;
name|ixl_iw
operator|.
name|ops
operator|->
name|stop
operator|=
name|ops
operator|->
name|stop
expr_stmt|;
name|ixl_iw
operator|.
name|registered
operator|=
name|true
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pf_entry
argument_list|,
argument|&ixl_iw.pfs
argument_list|,
argument|node
argument_list|)
if|if
condition|(
name|pf_entry
operator|->
name|state
operator|.
name|pf
operator|==
name|IXL_IW_PF_STATE_ON
condition|)
block|{
name|pf_entry
operator|->
name|state
operator|.
name|iw_scheduled
operator|=
name|IXL_IW_PF_STATE_ON
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|ixl_iw
operator|.
name|tq
argument_list|,
operator|&
name|pf_entry
operator|->
name|iw_task
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|ixl_iw
operator|.
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixl_iw_unregister
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ixl_iw_pf_entry
modifier|*
name|pf_entry
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"begin"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ixl_iw
operator|.
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ixl_iw
operator|.
name|registered
condition|)
block|{
name|printf
argument_list|(
literal|"%s: failed - iwarp driver has not been registered\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ixl_iw
operator|.
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|pf_entry
argument_list|,
argument|&ixl_iw.pfs
argument_list|,
argument|node
argument_list|)
if|if
condition|(
name|pf_entry
operator|->
name|state
operator|.
name|iw_scheduled
operator|==
name|IXL_IW_PF_STATE_ON
condition|)
block|{
name|pf_entry
operator|->
name|state
operator|.
name|iw_scheduled
operator|=
name|IXL_IW_PF_STATE_OFF
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|ixl_iw
operator|.
name|tq
argument_list|,
operator|&
name|pf_entry
operator|->
name|iw_task
argument_list|)
expr_stmt|;
block|}
name|ixl_iw
operator|.
name|registered
operator|=
name|false
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ixl_iw
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pf_entry
argument_list|,
argument|&ixl_iw.pfs
argument_list|,
argument|node
argument_list|)
name|taskqueue_drain
argument_list|(
name|ixl_iw
operator|.
name|tq
argument_list|,
operator|&
name|pf_entry
operator|->
name|iw_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|ixl_iw
operator|.
name|tq
argument_list|)
expr_stmt|;
name|ixl_iw
operator|.
name|tq
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|ixl_iw
operator|.
name|ops
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ixl_iw
operator|.
name|ops
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IXL_IW */
end_comment

end_unit

