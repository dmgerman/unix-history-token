begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2013-2015, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"i40e_osdep.h"
end_include

begin_include
include|#
directive|include
file|"i40e_register.h"
end_include

begin_include
include|#
directive|include
file|"i40e_status.h"
end_include

begin_include
include|#
directive|include
file|"i40e_alloc.h"
end_include

begin_include
include|#
directive|include
file|"i40e_hmc.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|I40E_NO_TYPE_HEADER
end_ifndef

begin_include
include|#
directive|include
file|"i40e_type.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * i40e_add_sd_table_entry - Adds a segment descriptor to the table  * @hw: pointer to our hw struct  * @hmc_info: pointer to the HMC configuration information struct  * @sd_index: segment descriptor index to manipulate  * @type: what type of segment descriptor we're manipulating  * @direct_mode_sz: size to alloc in direct mode  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_add_sd_table_entry
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_hmc_info
modifier|*
name|hmc_info
parameter_list|,
name|u32
name|sd_index
parameter_list|,
name|enum
name|i40e_sd_entry_type
name|type
parameter_list|,
name|u64
name|direct_mode_sz
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|struct
name|i40e_hmc_sd_entry
modifier|*
name|sd_entry
decl_stmt|;
name|enum
name|i40e_memory_type
name|mem_type
decl_stmt|;
name|bool
name|dma_mem_alloc_done
init|=
name|FALSE
decl_stmt|;
name|struct
name|i40e_dma_mem
name|mem
decl_stmt|;
name|u64
name|alloc_len
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_entry
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_BAD_PTR
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"i40e_add_sd_table_entry: bad sd_entry\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|sd_index
operator|>=
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_cnt
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_INVALID_SD_INDEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"i40e_add_sd_table_entry: bad sd_index\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
name|sd_entry
operator|=
operator|&
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_entry
index|[
name|sd_index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|sd_entry
operator|->
name|valid
condition|)
block|{
if|if
condition|(
name|I40E_SD_TYPE_PAGED
operator|==
name|type
condition|)
block|{
name|mem_type
operator|=
name|i40e_mem_pd
expr_stmt|;
name|alloc_len
operator|=
name|I40E_HMC_PAGED_BP_SIZE
expr_stmt|;
block|}
else|else
block|{
name|mem_type
operator|=
name|i40e_mem_bp_jumbo
expr_stmt|;
name|alloc_len
operator|=
name|direct_mode_sz
expr_stmt|;
block|}
comment|/* allocate a 4K pd page or 2M backing page */
name|ret_code
operator|=
name|i40e_allocate_dma_mem
argument_list|(
name|hw
argument_list|,
operator|&
name|mem
argument_list|,
name|mem_type
argument_list|,
name|alloc_len
argument_list|,
name|I40E_HMC_PD_BP_BUF_ALIGNMENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
condition|)
goto|goto
name|exit
goto|;
name|dma_mem_alloc_done
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|I40E_SD_TYPE_PAGED
operator|==
name|type
condition|)
block|{
name|ret_code
operator|=
name|i40e_allocate_virt_mem
argument_list|(
name|hw
argument_list|,
operator|&
name|sd_entry
operator|->
name|u
operator|.
name|pd_table
operator|.
name|pd_entry_virt_mem
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_hmc_pd_entry
argument_list|)
operator|*
literal|512
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
condition|)
goto|goto
name|exit
goto|;
name|sd_entry
operator|->
name|u
operator|.
name|pd_table
operator|.
name|pd_entry
operator|=
operator|(
expr|struct
name|i40e_hmc_pd_entry
operator|*
operator|)
name|sd_entry
operator|->
name|u
operator|.
name|pd_table
operator|.
name|pd_entry_virt_mem
operator|.
name|va
expr_stmt|;
name|i40e_memcpy
argument_list|(
operator|&
name|sd_entry
operator|->
name|u
operator|.
name|pd_table
operator|.
name|pd_page_addr
argument_list|,
operator|&
name|mem
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_dma_mem
argument_list|)
argument_list|,
name|I40E_NONDMA_TO_NONDMA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i40e_memcpy
argument_list|(
operator|&
name|sd_entry
operator|->
name|u
operator|.
name|bp
operator|.
name|addr
argument_list|,
operator|&
name|mem
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_dma_mem
argument_list|)
argument_list|,
name|I40E_NONDMA_TO_NONDMA
argument_list|)
expr_stmt|;
name|sd_entry
operator|->
name|u
operator|.
name|bp
operator|.
name|sd_pd_index
operator|=
name|sd_index
expr_stmt|;
block|}
comment|/* initialize the sd entry */
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_entry
index|[
name|sd_index
index|]
operator|.
name|entry_type
operator|=
name|type
expr_stmt|;
comment|/* increment the ref count */
name|I40E_INC_SD_REFCNT
argument_list|(
operator|&
name|hmc_info
operator|->
name|sd_table
argument_list|)
expr_stmt|;
block|}
comment|/* Increment backing page reference count */
if|if
condition|(
name|I40E_SD_TYPE_DIRECT
operator|==
name|sd_entry
operator|->
name|entry_type
condition|)
name|I40E_INC_BP_REFCNT
argument_list|(
operator|&
name|sd_entry
operator|->
name|u
operator|.
name|bp
argument_list|)
expr_stmt|;
name|exit
label|:
if|if
condition|(
name|I40E_SUCCESS
operator|!=
name|ret_code
condition|)
if|if
condition|(
name|dma_mem_alloc_done
condition|)
name|i40e_free_dma_mem
argument_list|(
name|hw
argument_list|,
operator|&
name|mem
argument_list|)
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_add_pd_table_entry - Adds page descriptor to the specified table  * @hw: pointer to our HW structure  * @hmc_info: pointer to the HMC configuration information structure  * @pd_index: which page descriptor index to manipulate  * @rsrc_pg: if not NULL, use preallocated page instead of allocating new one.  *  * This function:  *	1. Initializes the pd entry  *	2. Adds pd_entry in the pd_table  *	3. Mark the entry valid in i40e_hmc_pd_entry structure  *	4. Initializes the pd_entry's ref count to 1  * assumptions:  *	1. The memory for pd should be pinned down, physically contiguous and  *	   aligned on 4K boundary and zeroed memory.  *	2. It should be 4K in size.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_add_pd_table_entry
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_hmc_info
modifier|*
name|hmc_info
parameter_list|,
name|u32
name|pd_index
parameter_list|,
name|struct
name|i40e_dma_mem
modifier|*
name|rsrc_pg
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|struct
name|i40e_hmc_pd_table
modifier|*
name|pd_table
decl_stmt|;
name|struct
name|i40e_hmc_pd_entry
modifier|*
name|pd_entry
decl_stmt|;
name|struct
name|i40e_dma_mem
name|mem
decl_stmt|;
name|struct
name|i40e_dma_mem
modifier|*
name|page
init|=
operator|&
name|mem
decl_stmt|;
name|u32
name|sd_idx
decl_stmt|,
name|rel_pd_idx
decl_stmt|;
name|u64
modifier|*
name|pd_addr
decl_stmt|;
name|u64
name|page_desc
decl_stmt|;
if|if
condition|(
name|pd_index
operator|/
name|I40E_HMC_PD_CNT_IN_SD
operator|>=
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_cnt
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_INVALID_PAGE_DESC_INDEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"i40e_add_pd_table_entry: bad pd_index\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* find corresponding sd */
name|sd_idx
operator|=
operator|(
name|pd_index
operator|/
name|I40E_HMC_PD_CNT_IN_SD
operator|)
expr_stmt|;
if|if
condition|(
name|I40E_SD_TYPE_PAGED
operator|!=
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_entry
index|[
name|sd_idx
index|]
operator|.
name|entry_type
condition|)
goto|goto
name|exit
goto|;
name|rel_pd_idx
operator|=
operator|(
name|pd_index
operator|%
name|I40E_HMC_PD_CNT_IN_SD
operator|)
expr_stmt|;
name|pd_table
operator|=
operator|&
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_entry
index|[
name|sd_idx
index|]
operator|.
name|u
operator|.
name|pd_table
expr_stmt|;
name|pd_entry
operator|=
operator|&
name|pd_table
operator|->
name|pd_entry
index|[
name|rel_pd_idx
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|pd_entry
operator|->
name|valid
condition|)
block|{
if|if
condition|(
name|rsrc_pg
condition|)
block|{
name|pd_entry
operator|->
name|rsrc_pg
operator|=
name|TRUE
expr_stmt|;
name|page
operator|=
name|rsrc_pg
expr_stmt|;
block|}
else|else
block|{
comment|/* allocate a 4K backing page */
name|ret_code
operator|=
name|i40e_allocate_dma_mem
argument_list|(
name|hw
argument_list|,
name|page
argument_list|,
name|i40e_mem_bp
argument_list|,
name|I40E_HMC_PAGED_BP_SIZE
argument_list|,
name|I40E_HMC_PD_BP_BUF_ALIGNMENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
condition|)
goto|goto
name|exit
goto|;
name|pd_entry
operator|->
name|rsrc_pg
operator|=
name|FALSE
expr_stmt|;
block|}
name|i40e_memcpy
argument_list|(
operator|&
name|pd_entry
operator|->
name|bp
operator|.
name|addr
argument_list|,
name|page
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_dma_mem
argument_list|)
argument_list|,
name|I40E_NONDMA_TO_NONDMA
argument_list|)
expr_stmt|;
name|pd_entry
operator|->
name|bp
operator|.
name|sd_pd_index
operator|=
name|pd_index
expr_stmt|;
name|pd_entry
operator|->
name|bp
operator|.
name|entry_type
operator|=
name|I40E_SD_TYPE_PAGED
expr_stmt|;
comment|/* Set page address and valid bit */
name|page_desc
operator|=
name|page
operator|->
name|pa
operator||
literal|0x1
expr_stmt|;
name|pd_addr
operator|=
operator|(
name|u64
operator|*
operator|)
name|pd_table
operator|->
name|pd_page_addr
operator|.
name|va
expr_stmt|;
name|pd_addr
operator|+=
name|rel_pd_idx
expr_stmt|;
comment|/* Add the backing page physical address in the pd entry */
name|i40e_memcpy
argument_list|(
name|pd_addr
argument_list|,
operator|&
name|page_desc
argument_list|,
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|,
name|I40E_NONDMA_TO_DMA
argument_list|)
expr_stmt|;
name|pd_entry
operator|->
name|sd_index
operator|=
name|sd_idx
expr_stmt|;
name|pd_entry
operator|->
name|valid
operator|=
name|TRUE
expr_stmt|;
name|I40E_INC_PD_REFCNT
argument_list|(
name|pd_table
argument_list|)
expr_stmt|;
block|}
name|I40E_INC_BP_REFCNT
argument_list|(
operator|&
name|pd_entry
operator|->
name|bp
argument_list|)
expr_stmt|;
name|exit
label|:
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_remove_pd_bp - remove a backing page from a page descriptor  * @hw: pointer to our HW structure  * @hmc_info: pointer to the HMC configuration information structure  * @idx: the page index  * @is_pf: distinguishes a VF from a PF  *  * This function:  *	1. Marks the entry in pd tabe (for paged address mode) or in sd table  *	   (for direct address mode) invalid.  *	2. Write to register PMPDINV to invalidate the backing page in FV cache  *	3. Decrement the ref count for the pd _entry  * assumptions:  *	1. Caller can deallocate the memory used by backing storage after this  *	   function returns.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_remove_pd_bp
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_hmc_info
modifier|*
name|hmc_info
parameter_list|,
name|u32
name|idx
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|struct
name|i40e_hmc_pd_entry
modifier|*
name|pd_entry
decl_stmt|;
name|struct
name|i40e_hmc_pd_table
modifier|*
name|pd_table
decl_stmt|;
name|struct
name|i40e_hmc_sd_entry
modifier|*
name|sd_entry
decl_stmt|;
name|u32
name|sd_idx
decl_stmt|,
name|rel_pd_idx
decl_stmt|;
name|u64
modifier|*
name|pd_addr
decl_stmt|;
comment|/* calculate index */
name|sd_idx
operator|=
name|idx
operator|/
name|I40E_HMC_PD_CNT_IN_SD
expr_stmt|;
name|rel_pd_idx
operator|=
name|idx
operator|%
name|I40E_HMC_PD_CNT_IN_SD
expr_stmt|;
if|if
condition|(
name|sd_idx
operator|>=
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_cnt
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_INVALID_PAGE_DESC_INDEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"i40e_remove_pd_bp: bad idx\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
name|sd_entry
operator|=
operator|&
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_entry
index|[
name|sd_idx
index|]
expr_stmt|;
if|if
condition|(
name|I40E_SD_TYPE_PAGED
operator|!=
name|sd_entry
operator|->
name|entry_type
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_INVALID_SD_TYPE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"i40e_remove_pd_bp: wrong sd_entry type\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* get the entry and decrease its ref counter */
name|pd_table
operator|=
operator|&
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_entry
index|[
name|sd_idx
index|]
operator|.
name|u
operator|.
name|pd_table
expr_stmt|;
name|pd_entry
operator|=
operator|&
name|pd_table
operator|->
name|pd_entry
index|[
name|rel_pd_idx
index|]
expr_stmt|;
name|I40E_DEC_BP_REFCNT
argument_list|(
operator|&
name|pd_entry
operator|->
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd_entry
operator|->
name|bp
operator|.
name|ref_cnt
condition|)
goto|goto
name|exit
goto|;
comment|/* mark the entry invalid */
name|pd_entry
operator|->
name|valid
operator|=
name|FALSE
expr_stmt|;
name|I40E_DEC_PD_REFCNT
argument_list|(
name|pd_table
argument_list|)
expr_stmt|;
name|pd_addr
operator|=
operator|(
name|u64
operator|*
operator|)
name|pd_table
operator|->
name|pd_page_addr
operator|.
name|va
expr_stmt|;
name|pd_addr
operator|+=
name|rel_pd_idx
expr_stmt|;
name|i40e_memset
argument_list|(
name|pd_addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|,
name|I40E_DMA_MEM
argument_list|)
expr_stmt|;
name|I40E_INVALIDATE_PF_HMC_PD
argument_list|(
name|hw
argument_list|,
name|sd_idx
argument_list|,
name|idx
argument_list|)
expr_stmt|;
comment|/* free memory here */
if|if
condition|(
operator|!
name|pd_entry
operator|->
name|rsrc_pg
condition|)
name|ret_code
operator|=
name|i40e_free_dma_mem
argument_list|(
name|hw
argument_list|,
operator|&
operator|(
name|pd_entry
operator|->
name|bp
operator|.
name|addr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|I40E_SUCCESS
operator|!=
name|ret_code
condition|)
goto|goto
name|exit
goto|;
if|if
condition|(
operator|!
name|pd_table
operator|->
name|ref_cnt
condition|)
name|i40e_free_virt_mem
argument_list|(
name|hw
argument_list|,
operator|&
name|pd_table
operator|->
name|pd_entry_virt_mem
argument_list|)
expr_stmt|;
name|exit
label|:
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_prep_remove_sd_bp - Prepares to remove a backing page from a sd entry  * @hmc_info: pointer to the HMC configuration information structure  * @idx: the page index  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_prep_remove_sd_bp
parameter_list|(
name|struct
name|i40e_hmc_info
modifier|*
name|hmc_info
parameter_list|,
name|u32
name|idx
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|struct
name|i40e_hmc_sd_entry
modifier|*
name|sd_entry
decl_stmt|;
comment|/* get the entry and decrease its ref counter */
name|sd_entry
operator|=
operator|&
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_entry
index|[
name|idx
index|]
expr_stmt|;
name|I40E_DEC_BP_REFCNT
argument_list|(
operator|&
name|sd_entry
operator|->
name|u
operator|.
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd_entry
operator|->
name|u
operator|.
name|bp
operator|.
name|ref_cnt
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_NOT_READY
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
name|I40E_DEC_SD_REFCNT
argument_list|(
operator|&
name|hmc_info
operator|->
name|sd_table
argument_list|)
expr_stmt|;
comment|/* mark the entry invalid */
name|sd_entry
operator|->
name|valid
operator|=
name|FALSE
expr_stmt|;
name|exit
label|:
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_remove_sd_bp_new - Removes a backing page from a segment descriptor  * @hw: pointer to our hw struct  * @hmc_info: pointer to the HMC configuration information structure  * @idx: the page index  * @is_pf: used to distinguish between VF and PF  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_remove_sd_bp_new
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_hmc_info
modifier|*
name|hmc_info
parameter_list|,
name|u32
name|idx
parameter_list|,
name|bool
name|is_pf
parameter_list|)
block|{
name|struct
name|i40e_hmc_sd_entry
modifier|*
name|sd_entry
decl_stmt|;
if|if
condition|(
operator|!
name|is_pf
condition|)
return|return
name|I40E_NOT_SUPPORTED
return|;
comment|/* get the entry and decrease its ref counter */
name|sd_entry
operator|=
operator|&
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_entry
index|[
name|idx
index|]
expr_stmt|;
name|I40E_CLEAR_PF_SD_ENTRY
argument_list|(
name|hw
argument_list|,
name|idx
argument_list|,
name|I40E_SD_TYPE_DIRECT
argument_list|)
expr_stmt|;
return|return
name|i40e_free_dma_mem
argument_list|(
name|hw
argument_list|,
operator|&
operator|(
name|sd_entry
operator|->
name|u
operator|.
name|bp
operator|.
name|addr
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_prep_remove_pd_page - Prepares to remove a PD page from sd entry.  * @hmc_info: pointer to the HMC configuration information structure  * @idx: segment descriptor index to find the relevant page descriptor  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_prep_remove_pd_page
parameter_list|(
name|struct
name|i40e_hmc_info
modifier|*
name|hmc_info
parameter_list|,
name|u32
name|idx
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|struct
name|i40e_hmc_sd_entry
modifier|*
name|sd_entry
decl_stmt|;
name|sd_entry
operator|=
operator|&
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_entry
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|sd_entry
operator|->
name|u
operator|.
name|pd_table
operator|.
name|ref_cnt
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_NOT_READY
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* mark the entry invalid */
name|sd_entry
operator|->
name|valid
operator|=
name|FALSE
expr_stmt|;
name|I40E_DEC_SD_REFCNT
argument_list|(
operator|&
name|hmc_info
operator|->
name|sd_table
argument_list|)
expr_stmt|;
name|exit
label|:
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_remove_pd_page_new - Removes a PD page from sd entry.  * @hw: pointer to our hw struct  * @hmc_info: pointer to the HMC configuration information structure  * @idx: segment descriptor index to find the relevant page descriptor  * @is_pf: used to distinguish between VF and PF  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_remove_pd_page_new
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_hmc_info
modifier|*
name|hmc_info
parameter_list|,
name|u32
name|idx
parameter_list|,
name|bool
name|is_pf
parameter_list|)
block|{
name|struct
name|i40e_hmc_sd_entry
modifier|*
name|sd_entry
decl_stmt|;
if|if
condition|(
operator|!
name|is_pf
condition|)
return|return
name|I40E_NOT_SUPPORTED
return|;
name|sd_entry
operator|=
operator|&
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_entry
index|[
name|idx
index|]
expr_stmt|;
name|I40E_CLEAR_PF_SD_ENTRY
argument_list|(
name|hw
argument_list|,
name|idx
argument_list|,
name|I40E_SD_TYPE_PAGED
argument_list|)
expr_stmt|;
return|return
name|i40e_free_dma_mem
argument_list|(
name|hw
argument_list|,
operator|&
operator|(
name|sd_entry
operator|->
name|u
operator|.
name|pd_table
operator|.
name|pd_page_addr
operator|)
argument_list|)
return|;
block|}
end_function

end_unit

