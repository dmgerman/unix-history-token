begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2013-2014, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"ixl.h"
end_include

begin_include
include|#
directive|include
file|"ixlv.h"
end_include

begin_comment
comment|/*********************************************************************  *  Driver version  *********************************************************************/
end_comment

begin_decl_stmt
name|char
name|ixlv_driver_version
index|[]
init|=
literal|"1.1.4"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  PCI Device ID Table  *  *  Used by probe to select devices to load on  *  Last field stores an index into ixlv_strings  *  Last entry must be all 0s  *  *  { Vendor ID, Device ID, SubVendor ID, SubDevice ID, String Index }  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|ixl_vendor_info_t
name|ixlv_vendor_info_array
index|[]
init|=
block|{
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_VF
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_VF_HV
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* required last entry */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Table of branding strings  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ixlv_strings
index|[]
init|=
block|{
literal|"Intel(R) Ethernet Connection XL710 VF Driver"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Function prototypes  *********************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|ixlv_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_init_locked
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_allocate_pci_resources
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_free_pci_resources
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_assign_msix
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_init_msix
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_init_taskqueue
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_setup_queues
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_config_rss
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_stop
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_add_multi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_del_multi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_update_link_status
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_free_queues
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_setup_interface
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_local_timer
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_add_mac_filter
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|,
name|u8
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_init_filters
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_free_filters
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_msix_que
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_msix_adminq
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_do_adminq
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_sched_aq
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_handle_que
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_reset
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_reset_complete
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_set_queue_rx_itr
parameter_list|(
name|struct
name|ixl_queue
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_set_queue_tx_itr
parameter_list|(
name|struct
name|ixl_queue
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_enable_adminq_irq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_disable_adminq_irq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_enable_queue_irq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_disable_queue_irq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_setup_vlan_filters
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_register_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_unregister_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_cap_txcsum_tso
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_add_stats_sysctls
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*********************************************************************  *  FreeBSD Device Interface Entry Points  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|ixlv_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ixlv_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ixlv_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ixlv_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|ixlv_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ixlv_driver
init|=
block|{
literal|"ixlv"
block|,
name|ixlv_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ixlv_sc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|ixlv_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ixlv
argument_list|,
name|pci
argument_list|,
name|ixlv_driver
argument_list|,
name|ixlv_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ixlv
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ixlv
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** TUNEABLE PARAMETERS: */
end_comment

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|ixlv
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"IXLV driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Number of descriptors per ring: **   - TX and RX are the same size */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixlv_ringsz
init|=
name|DEFAULT_RING
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixlv.ringsz"
argument_list|,
operator|&
name|ixlv_ringsz
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixlv
argument_list|,
name|OID_AUTO
argument_list|,
name|ring_size
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixlv_ringsz
argument_list|,
literal|0
argument_list|,
literal|"Descriptor Ring Size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Set to zero to auto calculate  */
end_comment

begin_decl_stmt
name|int
name|ixlv_max_queues
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixlv.max_queues"
argument_list|,
operator|&
name|ixlv_max_queues
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixlv
argument_list|,
name|OID_AUTO
argument_list|,
name|max_queues
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixlv_max_queues
argument_list|,
literal|0
argument_list|,
literal|"Number of Queues"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Number of entries in Tx queue buf_ring. ** Increasing this will reduce the number of ** errors when transmitting fragmented UDP ** packets. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixlv_txbrsz
init|=
name|DEFAULT_TXBRSZ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixlv.txbrsz"
argument_list|,
operator|&
name|ixlv_txbrsz
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixlv
argument_list|,
name|OID_AUTO
argument_list|,
name|txbr_size
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixlv_txbrsz
argument_list|,
literal|0
argument_list|,
literal|"TX Buf Ring Size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Controls for Interrupt Throttling **      - true/false for dynamic adjustment **      - default values for static ITR */
end_comment

begin_decl_stmt
name|int
name|ixlv_dynamic_rx_itr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixlv.dynamic_rx_itr"
argument_list|,
operator|&
name|ixlv_dynamic_rx_itr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixlv
argument_list|,
name|OID_AUTO
argument_list|,
name|dynamic_rx_itr
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixlv_dynamic_rx_itr
argument_list|,
literal|0
argument_list|,
literal|"Dynamic RX Interrupt Rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ixlv_dynamic_tx_itr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixlv.dynamic_tx_itr"
argument_list|,
operator|&
name|ixlv_dynamic_tx_itr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixlv
argument_list|,
name|OID_AUTO
argument_list|,
name|dynamic_tx_itr
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixlv_dynamic_tx_itr
argument_list|,
literal|0
argument_list|,
literal|"Dynamic TX Interrupt Rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ixlv_rx_itr
init|=
name|IXL_ITR_8K
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixlv.rx_itr"
argument_list|,
operator|&
name|ixlv_rx_itr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixlv
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_itr
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixlv_rx_itr
argument_list|,
literal|0
argument_list|,
literal|"RX Interrupt Rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ixlv_tx_itr
init|=
name|IXL_ITR_4K
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixlv.tx_itr"
argument_list|,
operator|&
name|ixlv_tx_itr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixlv
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_itr
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixlv_tx_itr
argument_list|,
literal|0
argument_list|,
literal|"TX Interrupt Rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*********************************************************************  *  Device identification routine  *  *  ixlv_probe determines if the driver should be loaded on  *  the hardware based on PCI vendor/device id of the device.  *  *  return BUS_PROBE_DEFAULT on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixlv_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ixl_vendor_info_t
modifier|*
name|ent
decl_stmt|;
name|u16
name|pci_vendor_id
decl_stmt|,
name|pci_device_id
decl_stmt|;
name|u16
name|pci_subvendor_id
decl_stmt|,
name|pci_subdevice_id
decl_stmt|;
name|char
name|device_name
index|[
literal|256
index|]
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixlv_probe: begin"
argument_list|)
expr_stmt|;
name|pci_vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_vendor_id
operator|!=
name|I40E_INTEL_VENDOR_ID
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pci_device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subvendor_id
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subdevice_id
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ent
operator|=
name|ixlv_vendor_info_array
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|vendor_id
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pci_vendor_id
operator|==
name|ent
operator|->
name|vendor_id
operator|)
operator|&&
operator|(
name|pci_device_id
operator|==
name|ent
operator|->
name|device_id
operator|)
operator|&&
operator|(
operator|(
name|pci_subvendor_id
operator|==
name|ent
operator|->
name|subvendor_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subvendor_id
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|pci_subdevice_id
operator|==
name|ent
operator|->
name|subdevice_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subdevice_id
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|device_name
argument_list|,
literal|"%s, Version - %s"
argument_list|,
name|ixlv_strings
index|[
name|ent
operator|->
name|index
index|]
argument_list|,
name|ixlv_driver_version
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|device_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
name|ent
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device initialization routine  *  *  The attach entry point is called when the driver is being loaded.  *  This routine identifies the type of hardware, allocates all resources  *  and initializes the hardware.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixlv_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ixlv_sc
modifier|*
name|sc
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
decl_stmt|;
name|int
name|bufsz
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|retries
init|=
literal|0
decl_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
comment|/* Allocate, clear, and link in our primary soft structure */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|sc
operator|->
name|osdep
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|hw
operator|=
operator|&
name|sc
operator|->
name|hw
expr_stmt|;
name|vsi
operator|=
operator|&
name|sc
operator|->
name|vsi
expr_stmt|;
name|vsi
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/* Allocate filter lists */
name|ixlv_init_filters
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Core Lock Init*/
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"IXL SC Lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|aq_task_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"IXL AQ Task Lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Set up the timer& aq watchdog callouts */
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|timer
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|aq_task
argument_list|,
operator|&
name|sc
operator|->
name|aq_task_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Save off the information about this board */
name|hw
operator|->
name|vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|revision_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hw
operator|->
name|subsystem_vendor_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hw
operator|->
name|subsystem_device_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hw
operator|->
name|bus
operator|.
name|device
operator|=
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|bus
operator|.
name|func
operator|=
name|pci_get_function
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Do PCI setup - map BAR0, etc */
if|if
condition|(
name|ixlv_allocate_pci_resources
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Allocation of PCI resources failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_early
goto|;
block|}
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"Allocated PCI resources and MSIX vectors"
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_set_mac_type
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: set_mac_type failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_pci_res
goto|;
block|}
name|error
operator|=
name|ixlv_reset_complete
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Device is still being reset\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|err_pci_res
goto|;
block|}
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"VF Device is ready for configuration"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|aq
operator|.
name|num_arq_entries
operator|=
name|IXL_AQ_LEN
expr_stmt|;
name|hw
operator|->
name|aq
operator|.
name|num_asq_entries
operator|=
name|IXL_AQ_LEN
expr_stmt|;
name|hw
operator|->
name|aq
operator|.
name|arq_buf_size
operator|=
name|IXL_AQ_BUFSZ
expr_stmt|;
name|hw
operator|->
name|aq
operator|.
name|asq_buf_size
operator|=
name|IXL_AQ_BUFSZ
expr_stmt|;
name|error
operator|=
name|i40e_init_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: init_adminq failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_pci_res
goto|;
block|}
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"Initialized Admin Queue"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ixlv_send_api_ver
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: unable to send to PF (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_aq
goto|;
block|}
while|while
condition|(
operator|!
name|i40e_asq_done
argument_list|(
name|hw
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|retries
operator|>
name|IXLV_AQ_MAX_ERR
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Admin Queue timeout "
literal|"(waiting for send_api_ver)\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_aq
goto|;
block|}
name|i40e_msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"Sent API version message to PF"
argument_list|)
expr_stmt|;
comment|/* Wait for API version msg to arrive */
name|error
operator|=
name|ixlv_verify_api_ver
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Unable to verify API version, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_aq
goto|;
block|}
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"PF API version verified"
argument_list|)
expr_stmt|;
comment|/* Need API version before sending reset message */
name|error
operator|=
name|ixlv_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"VF reset failed; reload the driver\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_aq
goto|;
block|}
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"VF reset complete"
argument_list|)
expr_stmt|;
comment|/* Ask for VF config from PF */
name|error
operator|=
name|ixlv_send_vf_config_msg
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Unable to send VF config request, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_aq
goto|;
block|}
name|retries
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|i40e_asq_done
argument_list|(
name|hw
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|retries
operator|>
name|IXLV_AQ_MAX_ERR
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Admin Queue timeout "
literal|"(waiting for send_vf_config_msg)\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_aq
goto|;
block|}
name|i40e_msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"Sent VF config message to PF"
argument_list|)
expr_stmt|;
name|bufsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_virtchnl_vf_resource
argument_list|)
operator|+
operator|(
name|I40E_MAX_VF_VSI
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_virtchnl_vsi_resource
argument_list|)
operator|)
expr_stmt|;
name|sc
operator|->
name|vf_res
operator|=
name|malloc
argument_list|(
name|bufsz
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|vf_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Unable to allocate memory for VF configuration"
literal|" message from PF\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_aq
goto|;
block|}
comment|/* Check for VF config response */
name|error
operator|=
name|ixlv_get_vf_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Unable to get VF configuration from PF\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|err_res_buf
goto|;
block|}
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"Received valid VF config from PF"
argument_list|)
expr_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"VSIs %d, Queues %d, Max Vectors %d, Max MTU %d"
argument_list|,
name|sc
operator|->
name|vf_res
operator|->
name|num_vsis
argument_list|,
name|sc
operator|->
name|vf_res
operator|->
name|num_queue_pairs
argument_list|,
name|sc
operator|->
name|vf_res
operator|->
name|max_vectors
argument_list|,
name|sc
operator|->
name|vf_res
operator|->
name|max_mtu
argument_list|)
expr_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"Offload flags: %#010x"
argument_list|,
name|sc
operator|->
name|vf_res
operator|->
name|vf_offload_flags
argument_list|)
expr_stmt|;
comment|/* got VF config message back from PF, now we can parse it */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vf_res
operator|->
name|num_vsis
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|vf_res
operator|->
name|vsi_res
index|[
name|i
index|]
operator|.
name|vsi_type
operator|==
name|I40E_VSI_SRIOV
condition|)
name|sc
operator|->
name|vsi_res
operator|=
operator|&
name|sc
operator|->
name|vf_res
operator|->
name|vsi_res
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|vsi_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: no LAN VSI found\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|err_res_buf
goto|;
block|}
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"Resource Acquisition complete"
argument_list|)
expr_stmt|;
comment|/* If no mac address was assigned just make a random one */
if|if
condition|(
operator|!
name|ixlv_check_ether_addr
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
condition|)
block|{
name|u8
name|addr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|arc4rand
argument_list|(
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
index|[
literal|0
index|]
operator|&=
literal|0xFE
expr_stmt|;
name|addr
index|[
literal|0
index|]
operator||=
literal|0x02
expr_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|vsi
operator|->
name|id
operator|=
name|sc
operator|->
name|vsi_res
operator|->
name|vsi_id
expr_stmt|;
name|vsi
operator|->
name|back
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
expr_stmt|;
comment|/* Link in this virtual environment is always 'up' */
name|vsi
operator|->
name|link_up
operator|=
name|TRUE
expr_stmt|;
comment|/* This allocates the memory and early settings */
if|if
condition|(
name|ixlv_setup_queues
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: setup queues failed!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Setup the stack interface */
if|if
condition|(
name|ixlv_setup_interface
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: setup interface failed!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"Queue memory and interface setup"
argument_list|)
expr_stmt|;
comment|/* Do queue interrupt setup */
name|ixlv_assign_msix
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Start AdminQ taskqueue */
name|ixlv_init_taskqueue
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Start the admin queue scheduler timer */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|aq_task
argument_list|,
literal|2
operator|*
name|hz
argument_list|,
name|ixlv_sched_aq
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize stats */
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|vsi
operator|.
name|eth_stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_eth_stats
argument_list|)
argument_list|)
expr_stmt|;
name|ixlv_add_stats_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Register for VLAN events */
name|vsi
operator|->
name|vlan_attach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_config
argument_list|,
name|ixlv_register_vlan
argument_list|,
name|vsi
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|vlan_detach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|ixlv_unregister_vlan
argument_list|,
name|vsi
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
comment|/* We want AQ enabled early */
name|ixlv_enable_adminq_irq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set things up to run init */
name|sc
operator|->
name|aq_pending
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|aq_required
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|init_state
operator|=
name|IXLV_INIT_READY
expr_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|out
label|:
name|ixlv_free_queues
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|err_res_buf
label|:
name|free
argument_list|(
name|sc
operator|->
name|vf_res
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|err_aq
label|:
name|i40e_shutdown_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|err_pci_res
label|:
name|ixlv_free_pci_resources
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err_early
label|:
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|aq_task_mtx
argument_list|)
expr_stmt|;
name|ixlv_free_filters
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"end: error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device removal routine  *  *  The detach entry point is called when the driver is being removed.  *  This routine stops the adapter and deallocates all the resources  *  that were allocated for driver operation.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixlv_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|int
name|retries
init|=
literal|0
decl_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
comment|/* Make sure VLANS are not using driver */
if|if
condition|(
name|vsi
operator|->
name|ifp
operator|->
name|if_vlantrunk
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Vlan in use, detach first\n"
argument_list|)
expr_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Stop driver */
if|if
condition|(
name|vsi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ixlv_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* 		** Ensure queues are disabled before examining 		** admin queue state later in detach. 		*/
while|while
condition|(
name|vsi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
operator|++
name|retries
operator|<
name|IXLV_AQ_MAX_ERR
condition|)
block|{
name|i40e_msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IXL_DEBUG
if|if
condition|(
name|retries
operator|>=
name|IXLV_AQ_MAX_ERR
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Issue disabling queues for detach\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Unregister VLAN events */
if|if
condition|(
name|vsi
operator|->
name|vlan_attach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_config
argument_list|,
name|vsi
operator|->
name|vlan_attach
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsi
operator|->
name|vlan_detach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|vsi
operator|->
name|vlan_detach
argument_list|)
expr_stmt|;
comment|/* Stop AQ callout */
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|aq_task
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|aq_task
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXL_DEBUG
comment|/* Report on possible AQ failures */
if|if
condition|(
name|sc
operator|->
name|aq_required
operator|||
name|sc
operator|->
name|aq_pending
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AQ status on detach:\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"required  : 0x%4b\n"
argument_list|,
name|sc
operator|->
name|aq_required
argument_list|,
name|IXLV_FLAGS
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"pending   : 0x%4b\n"
argument_list|,
name|sc
operator|->
name|aq_pending
argument_list|,
name|IXLV_FLAGS
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"current_op: %d\n"
argument_list|,
name|sc
operator|->
name|current_op
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|i40e_shutdown_adminq
argument_list|(
operator|&
name|sc
operator|->
name|hw
argument_list|)
expr_stmt|;
while|while
condition|(
name|taskqueue_cancel
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|aq_irq
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|aq_irq
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|tq
argument_list|)
expr_stmt|;
comment|/* force the state down */
name|vsi
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|vf_res
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ixlv_free_pci_resources
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ixlv_free_queues
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|aq_task_mtx
argument_list|)
expr_stmt|;
name|ixlv_free_filters
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Shutdown entry point  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixlv_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ixlv_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Configure TXCSUM(IPV6) and TSO(4/6)  *	- the hardware handles these together so we  *	  need to tweak them   */
end_comment

begin_function
specifier|static
name|void
name|ixlv_cap_txcsum_tso
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
comment|/* Enable/disable TXCSUM/TSO4 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TXCSUM
expr_stmt|;
comment|/* enable TXCSUM, restore TSO if previously enabled */
if|if
condition|(
name|vsi
operator|->
name|flags
operator|&
name|IXL_FLAGS_KEEP_TSO4
condition|)
block|{
name|vsi
operator|->
name|flags
operator|&=
operator|~
name|IXL_FLAGS_KEEP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO4
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
operator|(
name|IFCAP_TXCSUM
operator||
name|IFCAP_TSO4
operator|)
expr_stmt|;
name|vsi
operator|->
name|flags
operator|&=
operator|~
name|IXL_FLAGS_KEEP_TSO4
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"TSO4 requires txcsum, enabling both...\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TXCSUM
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|vsi
operator|->
name|flags
operator||=
name|IXL_FLAGS_KEEP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TXCSUM
operator||
name|IFCAP_TSO4
operator|)
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"TSO4 requires txcsum, disabling both...\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO4
expr_stmt|;
block|}
comment|/* Enable/disable TXCSUM_IPV6/TSO6 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO6
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
if|if
condition|(
name|vsi
operator|->
name|flags
operator|&
name|IXL_FLAGS_KEEP_TSO6
condition|)
block|{
name|vsi
operator|->
name|flags
operator|&=
operator|~
name|IXL_FLAGS_KEEP_TSO6
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO6
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
operator|(
name|IFCAP_TXCSUM_IPV6
operator||
name|IFCAP_TSO6
operator|)
expr_stmt|;
name|vsi
operator|->
name|flags
operator|&=
operator|~
name|IXL_FLAGS_KEEP_TSO6
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"TSO6 requires txcsum6, enabling both...\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO6
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO6
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
block|{
name|vsi
operator|->
name|flags
operator||=
name|IXL_FLAGS_KEEP_TSO6
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TXCSUM_IPV6
operator||
name|IFCAP_TSO6
operator|)
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"TSO6 requires txcsum6, disabling both...\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO6
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Ioctl entry point  *  *  ixlv_ioctl is called when the user wants to configure the  *  interface.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixlv_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|bool
name|avoid_reset
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
comment|/* 		** Calling init results in link renegotiation, 		** so we avoid doing it when possible. 		*/
if|if
condition|(
name|avoid_reset
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|ixlv_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_NOARP
operator|)
condition|)
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIOCSIFMTU
case|:
name|IOCTL_DBG_IF2
argument_list|(
name|ifp
argument_list|,
literal|"SIOCSIFMTU (Set Interface MTU)"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|IXL_MAX_FRAME
operator|-
name|ETHER_HDR_LEN
operator|-
name|ETHER_CRC_LEN
operator|-
name|ETHER_VLAN_ENCAP_LEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|IOCTL_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"mtu too large"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOCTL_DBG_IF2
argument_list|(
name|ifp
argument_list|,
literal|"mtu: %lu -> %d"
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
comment|// ERJ: Interestingly enough, these types don't match
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|vsi
operator|->
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|ixlv_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|IOCTL_DBG_IF2
argument_list|(
name|ifp
argument_list|,
literal|"SIOCSIFFLAGS (Set Interface Flags)"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
name|ixlv_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ixlv_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
name|IOCTL_DBG_IF2
argument_list|(
name|ifp
argument_list|,
literal|"SIOCADDMULTI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ixlv_disable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixlv_add_multi
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixlv_enable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCDELMULTI
case|:
name|IOCTL_DBG_IF2
argument_list|(
name|ifp
argument_list|,
literal|"SIOCDELMULTI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|init_state
operator|==
name|IXLV_RUNNING
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ixlv_disable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixlv_del_multi
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixlv_enable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|IOCTL_DBG_IF2
argument_list|(
name|ifp
argument_list|,
literal|"SIOCxIFMEDIA (Get/Set Interface Media)"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
block|{
name|int
name|mask
init|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
decl_stmt|;
name|IOCTL_DBG_IF2
argument_list|(
name|ifp
argument_list|,
literal|"SIOCSIFCAP (Set Capabilities)"
argument_list|)
expr_stmt|;
name|ixlv_cap_txcsum_tso
argument_list|(
name|vsi
argument_list|,
name|ifp
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM_IPV6
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTSO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTSO
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|ixlv_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|IOCTL_DBG_IF2
argument_list|(
name|ifp
argument_list|,
literal|"UNKNOWN (0x%X)"
argument_list|,
operator|(
name|int
operator|)
name|command
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** To do a reinit on the VF is unfortunately more complicated ** than a physical device, we must have the PF more or less ** completely recreate our memory, so many things that were ** done only once at attach in traditional drivers now must be ** redone at each reinitialization. This function does that ** 'prelude' so we can then call the normal locked init code. */
end_comment

begin_function
name|int
name|ixlv_reinit_locked
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|sc
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|ixlv_vlan_filter
modifier|*
name|vf
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ixlv_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|init_state
operator|==
name|IXLV_RESET_REQUIRED
operator|)
operator|||
operator|(
name|sc
operator|->
name|init_state
operator|==
name|IXLV_RESET_PENDING
operator|)
condition|)
name|error
operator|=
name|ixlv_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set the state in case we went thru RESET */
name|sc
operator|->
name|init_state
operator|=
name|IXLV_RUNNING
expr_stmt|;
if|if
condition|(
name|vsi
operator|->
name|num_vlans
operator|!=
literal|0
condition|)
name|SLIST_FOREACH
argument_list|(
argument|vf
argument_list|,
argument|sc->vlan_filters
argument_list|,
argument|next
argument_list|)
name|vf
operator|->
name|flags
operator|=
name|IXL_FILTER_ADD
expr_stmt|;
else|else
block|{
comment|/* clean any stale filters */
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
name|sc
operator|->
name|vlan_filters
argument_list|)
condition|)
block|{
name|vf
operator|=
name|SLIST_FIRST
argument_list|(
name|sc
operator|->
name|vlan_filters
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
name|sc
operator|->
name|vlan_filters
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
name|ixlv_enable_adminq_irq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aq_pending
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|aq_required
operator|=
literal|0
expr_stmt|;
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_init_locked
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|sc
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
comment|/* Verify we have the core lock */
if|if
condition|(
operator|!
name|mtx_owned
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: sc mutex not owned; acquire"
literal|"before calling this function!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|init_done
goto|;
block|}
comment|/* Do a reinit first if an init has already been done */
if|if
condition|(
operator|(
name|sc
operator|->
name|init_state
operator|==
name|IXLV_RUNNING
operator|)
operator|||
operator|(
name|sc
operator|->
name|init_state
operator|==
name|IXLV_RESET_REQUIRED
operator|)
operator|||
operator|(
name|sc
operator|->
name|init_state
operator|==
name|IXLV_RESET_PENDING
operator|)
condition|)
name|error
operator|=
name|ixlv_reinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Don't bother with init if we failed reinit */
if|if
condition|(
name|error
condition|)
goto|goto
name|init_done
goto|;
comment|/* Check for an LAA mac address... */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_OFFLOAD_IPV4
operator|&
operator|~
name|CSUM_IP
operator|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_OFFLOAD_IPV6
expr_stmt|;
comment|/* Add mac filter for this VF to PF */
name|error
operator|=
name|ixlv_add_mac_filter
argument_list|(
name|sc
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// send message, then enqueue another task
if|if
condition|(
operator|!
name|error
operator|||
name|error
operator|==
name|EEXIST
condition|)
block|{
name|sc
operator|->
name|aq_required
operator||=
name|IXLV_FLAG_AQ_ADD_MAC_FILTER
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|aq_task
argument_list|,
name|IXLV_CALLOUT_TIMO
argument_list|,
name|ixlv_sched_aq
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Setup vlan's if needed */
name|ixlv_setup_vlan_filters
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	** Prepare the queues for operation 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|ixl_init_tx_ring
argument_list|(
name|que
argument_list|)
expr_stmt|;
comment|/* Need to set mbuf size now */
if|if
condition|(
name|vsi
operator|->
name|max_frame_size
operator|<=
literal|2048
condition|)
name|rxr
operator|->
name|mbuf_sz
operator|=
name|MCLBYTES
expr_stmt|;
else|else
name|rxr
operator|->
name|mbuf_sz
operator|=
name|MJUMPAGESIZE
expr_stmt|;
name|ixl_init_rx_ring
argument_list|(
name|que
argument_list|)
expr_stmt|;
block|}
comment|/* Configure queues */
name|sc
operator|->
name|aq_required
operator||=
name|IXLV_FLAG_AQ_CONFIGURE_QUEUES
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|aq_task
argument_list|,
name|IXLV_CALLOUT_TIMO
argument_list|,
name|ixlv_sched_aq
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Set up RSS */
name|ixlv_config_rss
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Map vectors */
name|sc
operator|->
name|aq_required
operator||=
name|IXLV_FLAG_AQ_MAP_VECTORS
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|aq_task
argument_list|,
name|IXLV_CALLOUT_TIMO
argument_list|,
name|ixlv_sched_aq
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable queues */
name|sc
operator|->
name|aq_required
operator||=
name|IXLV_FLAG_AQ_ENABLE_QUEUES
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|aq_task
argument_list|,
name|IXLV_CALLOUT_TIMO
argument_list|,
name|ixlv_sched_aq
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Start the local timer */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ixlv_local_timer
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|init_state
operator|=
name|IXLV_RUNNING
expr_stmt|;
name|init_done
label|:
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* **  Init entry point for the stack */
end_comment

begin_function
name|void
name|ixlv_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ixlv_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Allocate MSI/X vectors, setup the AQ vector early  */
end_comment

begin_function
specifier|static
name|int
name|ixlv_init_msix
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|want
decl_stmt|,
name|vectors
decl_stmt|,
name|queues
decl_stmt|,
name|available
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
name|IXL_BAR
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|msix_mem
condition|)
block|{
comment|/* May not be enabled */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unable to map MSIX table \n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|available
operator|=
name|pci_msix_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|available
operator|==
literal|0
condition|)
block|{
comment|/* system has msix disabled */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|sc
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_mem
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Figure out a reasonable auto config value */
name|queues
operator|=
operator|(
name|mp_ncpus
operator|>
operator|(
name|available
operator|-
literal|1
operator|)
operator|)
condition|?
operator|(
name|available
operator|-
literal|1
operator|)
else|:
name|mp_ncpus
expr_stmt|;
comment|/* Override with hardcoded value if sane */
if|if
condition|(
operator|(
name|ixlv_max_queues
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ixlv_max_queues
operator|<=
name|queues
operator|)
condition|)
name|queues
operator|=
name|ixlv_max_queues
expr_stmt|;
comment|/* Enforce the VF max value */
if|if
condition|(
name|queues
operator|>
name|IXLV_MAX_QUEUES
condition|)
name|queues
operator|=
name|IXLV_MAX_QUEUES
expr_stmt|;
comment|/* 	** Want one vector (RX/TX pair) per queue 	** plus an additional for the admin queue. 	*/
name|want
operator|=
name|queues
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|want
operator|<=
name|available
condition|)
comment|/* Have enough */
name|vectors
operator|=
name|want
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"MSIX Configuration Problem, "
literal|"%d vectors available but %d wanted!\n"
argument_list|,
name|available
argument_list|,
name|want
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|vectors
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Using MSIX interrupts with %d vectors\n"
argument_list|,
name|vectors
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix
operator|=
name|vectors
expr_stmt|;
name|sc
operator|->
name|vsi
operator|.
name|num_queues
operator|=
name|queues
expr_stmt|;
block|}
comment|/* 	** Explicitly set the guest PCI BUSMASTER capability 	** and we must rewrite the ENABLE in the MSIX control 	** register again at this point to cause the host to 	** successfully initialize us. 	*/
block|{
name|u16
name|pci_cmd_word
decl_stmt|;
name|int
name|msix_ctrl
decl_stmt|;
name|pci_cmd_word
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_cmd_word
operator||=
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|pci_cmd_word
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_MSIX
argument_list|,
operator|&
name|rid
argument_list|)
expr_stmt|;
name|rid
operator|+=
name|PCIR_MSIX_CTRL
expr_stmt|;
name|msix_ctrl
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|msix_ctrl
operator||=
name|PCIM_MSIXCTRL_MSIX_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
name|msix_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Next we need to setup the vector for the Admin Queue */
name|rid
operator|=
literal|1
expr_stmt|;
comment|// zero vector + 1
name|sc
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate"
literal|" bus resource: AQ interrupt \n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixlv_msix_adminq
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|tag
argument_list|)
condition|)
block|{
name|sc
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register AQ handler"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|res
argument_list|,
name|sc
operator|->
name|tag
argument_list|,
literal|"adminq"
argument_list|)
expr_stmt|;
return|return
operator|(
name|vectors
operator|)
return|;
name|fail
label|:
comment|/* The VF driver MUST use MSIX */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixlv_allocate_pci_resources
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rid
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pci_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|pci_mem
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|osdep
operator|.
name|mem_bus_space_tag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|osdep
operator|.
name|mem_bus_space_size
operator|=
name|rman_get_size
argument_list|(
name|sc
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|osdep
operator|.
name|flush_reg
operator|=
name|I40E_VFGEN_RSTAT
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|hw_addr
operator|=
operator|(
name|u8
operator|*
operator|)
operator|&
name|sc
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|back
operator|=
operator|&
name|sc
operator|->
name|osdep
expr_stmt|;
comment|/* May need to pre-emptively disable adminq interrupts */
name|ixlv_disable_adminq_irq
argument_list|(
operator|&
name|sc
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* 	** Now setup MSI/X, it will return 	** us the number of supported vectors 	*/
name|sc
operator|->
name|msix
operator|=
name|ixlv_init_msix
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* We fail without MSIX support */
if|if
condition|(
name|sc
operator|->
name|msix
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_free_pci_resources
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
comment|/* We may get here before stations are setup */
if|if
condition|(
name|que
operator|==
name|NULL
condition|)
goto|goto
name|early
goto|;
comment|/* 	**  Release all msix queue resources: 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|int
name|rid
init|=
name|que
operator|->
name|msix
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|que
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|que
operator|->
name|tag
argument_list|)
expr_stmt|;
name|que
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|que
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|que
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
name|early
label|:
comment|/* Clean the AdminQ interrupt */
if|if
condition|(
name|sc
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|res
argument_list|,
name|sc
operator|->
name|tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|1
argument_list|,
name|sc
operator|->
name|res
argument_list|)
expr_stmt|;
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msix_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
name|IXL_BAR
argument_list|)
argument_list|,
name|sc
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pci_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|sc
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ixlv_init_taskqueue
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Tasklet for AQ Interrupts */
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|aq_irq
argument_list|,
literal|0
argument_list|,
name|ixlv_do_adminq
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixl_adm"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s sc->tq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup MSIX Interrupt resources and handlers for the VSI queues  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixlv_assign_msix
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|,
name|vector
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|vector
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|rid
operator|=
name|vector
operator|+
literal|1
expr_stmt|;
name|txr
operator|=
operator|&
name|que
operator|->
name|txr
expr_stmt|;
name|que
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|que
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate"
literal|" bus resource: que interrupt [%d]\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set the handler function */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixlv_msix_que
argument_list|,
name|que
argument_list|,
operator|&
name|que
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|que
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register que handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|que
operator|->
name|tag
argument_list|,
literal|"que %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Bind the vector to a CPU */
name|bus_bind_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|que
operator|->
name|msix
operator|=
name|vector
expr_stmt|;
name|vsi
operator|->
name|que_mask
operator||=
call|(
name|u64
call|)
argument_list|(
literal|1
operator|<<
name|que
operator|->
name|msix
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|tx_task
argument_list|,
literal|0
argument_list|,
name|ixl_deferred_mq_start
argument_list|,
name|que
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|ixlv_handle_que
argument_list|,
name|que
argument_list|)
expr_stmt|;
name|que
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixlv_que"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s que"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** XXX: Assumes the vf's admin queue has been initialized. */
end_comment

begin_function
specifier|static
name|int
name|ixlv_reset
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|sc
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Ask the PF to reset us if we are initiating */
if|if
condition|(
name|sc
operator|->
name|init_state
operator|!=
name|IXLV_RESET_PENDING
condition|)
name|ixlv_request_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|i40e_msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|error
operator|=
name|ixlv_reset_complete
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: VF reset failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|i40e_shutdown_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: shutdown_adminq failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|i40e_init_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: init_adminq failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixlv_reset_complete
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VFGEN_RSTAT
argument_list|)
operator|&
name|I40E_VFGEN_RSTAT_VFR_STATE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|==
name|I40E_VFR_VFACTIVE
operator|)
operator|||
operator|(
name|reg
operator|==
name|I40E_VFR_COMPLETED
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|i40e_usec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup networking device structure and register an interface.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixlv_setup_interface
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|vsi
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not allocate ifnet structure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|4000000000
expr_stmt|;
comment|// ??
name|ifp
operator|->
name|if_init
operator|=
name|ixlv_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|vsi
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ixlv_ioctl
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100000
name|if_setgetcounterfn
argument_list|(
name|ifp
argument_list|,
name|ixl_get_counter
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_transmit
operator|=
name|ixl_mq_start
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|ixl_qflush
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|que
operator|->
name|num_desc
operator|-
literal|2
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
comment|/* 	 * Tell the upper layer(s) we support long frames. 	 */
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_HWCSUM_IPV6
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TSO
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_JUMBO_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_HWTSO
operator||
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_VLAN_HWCSUM
operator||
name|IFCAP_LRO
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* 	** Don't turn this on by default, if vlans are 	** created on another pseudo device (eg. lagg) 	** then vlan events are not passed thru, breaking 	** operation, but with HW FILTER off it works. If 	** using vlans directly on the ixl driver you can 	** enable this and get full hardware tag filtering. 	*/
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
comment|/* 	 * Specify the media types supported by this adapter and register 	 * callbacks to update media and link information 	 */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|ixlv_media_change
argument_list|,
name|ixlv_media_status
argument_list|)
expr_stmt|;
comment|// JFV Add media types later?
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Allocate and setup the interface queues */
end_comment

begin_function
specifier|static
name|int
name|ixlv_setup_queues
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
decl_stmt|;
name|int
name|rsize
decl_stmt|,
name|tsize
decl_stmt|;
name|int
name|error
init|=
name|I40E_SUCCESS
decl_stmt|;
name|vsi
operator|=
operator|&
name|sc
operator|->
name|vsi
expr_stmt|;
name|vsi
operator|->
name|back
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
expr_stmt|;
name|vsi
operator|->
name|hw
operator|=
operator|&
name|sc
operator|->
name|hw
expr_stmt|;
name|vsi
operator|->
name|num_vlans
operator|=
literal|0
expr_stmt|;
comment|/* Get memory for the station queues */
if|if
condition|(
operator|!
operator|(
name|vsi
operator|->
name|queues
operator|=
operator|(
expr|struct
name|ixl_queue
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixl_queue
argument_list|)
operator|*
name|vsi
operator|->
name|num_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate queue memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|early
goto|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|que
operator|=
operator|&
name|vsi
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
name|que
operator|->
name|num_desc
operator|=
name|ixlv_ringsz
expr_stmt|;
name|que
operator|->
name|me
operator|=
name|i
expr_stmt|;
name|que
operator|->
name|vsi
operator|=
name|vsi
expr_stmt|;
comment|/* mark the queue as active */
name|vsi
operator|->
name|active_queues
operator||=
operator|(
name|u64
operator|)
literal|1
operator|<<
name|que
operator|->
name|me
expr_stmt|;
name|txr
operator|=
operator|&
name|que
operator|->
name|txr
expr_stmt|;
name|txr
operator|->
name|que
operator|=
name|que
expr_stmt|;
name|txr
operator|->
name|tail
operator|=
name|I40E_QTX_TAIL1
argument_list|(
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
comment|/* Initialize the TX lock */
name|snprintf
argument_list|(
name|txr
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|txr
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:tx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|,
name|txr
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 		** Create the TX descriptor ring, the extra int is 		** added as the location for HEAD WB. 		*/
name|tsize
operator|=
name|roundup2
argument_list|(
operator|(
name|que
operator|->
name|num_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_tx_desc
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|DBA_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|i40e_allocate_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|hw
argument_list|,
operator|&
name|txr
operator|->
name|dma
argument_list|,
name|i40e_mem_reserved
argument_list|,
name|tsize
argument_list|,
name|DBA_ALIGN
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX Descriptor memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|txr
operator|->
name|base
operator|=
operator|(
expr|struct
name|i40e_tx_desc
operator|*
operator|)
name|txr
operator|->
name|dma
operator|.
name|va
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|txr
operator|->
name|base
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
comment|/* Now allocate transmit soft structs for the ring */
if|if
condition|(
name|ixl_allocate_tx_data
argument_list|(
name|que
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up TX structures\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate a buf ring */
name|txr
operator|->
name|br
operator|=
name|buf_ring_alloc
argument_list|(
name|ixlv_txbrsz
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
operator|&
name|txr
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|br
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up TX buf ring\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 		 * Next the RX queues... 		 */
name|rsize
operator|=
name|roundup2
argument_list|(
name|que
operator|->
name|num_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|i40e_rx_desc
argument_list|)
argument_list|,
name|DBA_ALIGN
argument_list|)
expr_stmt|;
name|rxr
operator|=
operator|&
name|que
operator|->
name|rxr
expr_stmt|;
name|rxr
operator|->
name|que
operator|=
name|que
expr_stmt|;
name|rxr
operator|->
name|tail
operator|=
name|I40E_QRX_TAIL1
argument_list|(
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
comment|/* Initialize the RX side lock */
name|snprintf
argument_list|(
name|rxr
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|rxr
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:rx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|rxr
operator|->
name|mtx
argument_list|,
name|rxr
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|i40e_allocate_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|hw
argument_list|,
operator|&
name|rxr
operator|->
name|dma
argument_list|,
name|i40e_mem_reserved
argument_list|,
name|rsize
argument_list|,
literal|4096
argument_list|)
condition|)
block|{
comment|//JFV - should this be DBA?
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate RX Descriptor memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rxr
operator|->
name|base
operator|=
operator|(
expr|union
name|i40e_rx_desc
operator|*
operator|)
name|rxr
operator|->
name|dma
operator|.
name|va
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rxr
operator|->
name|base
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
comment|/* Allocate receive soft structs for the ring*/
if|if
condition|(
name|ixl_allocate_rx_data
argument_list|(
name|que
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up receive structs\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|free
argument_list|(
name|vsi
operator|->
name|queues
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|que
operator|=
operator|&
name|vsi
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
name|rxr
operator|=
operator|&
name|que
operator|->
name|rxr
expr_stmt|;
name|txr
operator|=
operator|&
name|que
operator|->
name|txr
expr_stmt|;
if|if
condition|(
name|rxr
operator|->
name|base
condition|)
name|i40e_free_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|hw
argument_list|,
operator|&
name|rxr
operator|->
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|base
condition|)
name|i40e_free_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|hw
argument_list|,
operator|&
name|txr
operator|->
name|dma
argument_list|)
expr_stmt|;
block|}
name|early
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** This routine is run via an vlan config EVENT, ** it enables us to use the HW Filter table since ** we can get the vlan id. This just creates the ** entry in the soft version of the VFTA, init will ** repopulate the real table. */
end_comment

begin_function
specifier|static
name|void
name|ixlv_register_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|ixlv_vlan_filter
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
comment|/* Not our event */
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
comment|/* Sanity check - make sure it doesn't already exist */
name|SLIST_FOREACH
argument_list|(
argument|v
argument_list|,
argument|sc->vlan_filters
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|v
operator|->
name|vlan
operator|==
name|vtag
condition|)
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
operator|++
name|vsi
operator|->
name|num_vlans
expr_stmt|;
name|v
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixlv_vlan_filter
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
name|sc
operator|->
name|vlan_filters
argument_list|,
name|v
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|v
operator|->
name|vlan
operator|=
name|vtag
expr_stmt|;
name|v
operator|->
name|flags
operator|=
name|IXL_FILTER_ADD
expr_stmt|;
name|sc
operator|->
name|aq_required
operator||=
name|IXLV_FLAG_AQ_ADD_VLAN_FILTER
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** This routine is run via an vlan ** unconfig EVENT, remove our entry ** in the soft vfta. */
end_comment

begin_function
specifier|static
name|void
name|ixlv_unregister_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|ixlv_vlan_filter
modifier|*
name|v
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|v
argument_list|,
argument|sc->vlan_filters
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|v
operator|->
name|vlan
operator|==
name|vtag
condition|)
block|{
name|v
operator|->
name|flags
operator|=
name|IXL_FILTER_DEL
expr_stmt|;
operator|++
name|i
expr_stmt|;
operator|--
name|vsi
operator|->
name|num_vlans
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
condition|)
name|sc
operator|->
name|aq_required
operator||=
name|IXLV_FLAG_AQ_DEL_VLAN_FILTER
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** Get a new filter and add it to the mac filter list. */
end_comment

begin_function
specifier|static
name|struct
name|ixlv_mac_filter
modifier|*
name|ixlv_get_mac_filter
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ixlv_mac_filter
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixlv_mac_filter
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
name|sc
operator|->
name|mac_filters
argument_list|,
name|f
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Find the filter with matching MAC address */
end_comment

begin_function
specifier|static
name|struct
name|ixlv_mac_filter
modifier|*
name|ixlv_find_mac_filter
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|,
name|u8
modifier|*
name|macaddr
parameter_list|)
block|{
name|struct
name|ixlv_mac_filter
modifier|*
name|f
decl_stmt|;
name|bool
name|match
init|=
name|FALSE
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|sc->mac_filters
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|cmp_etheraddr
argument_list|(
name|f
operator|->
name|macaddr
argument_list|,
name|macaddr
argument_list|)
condition|)
block|{
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|match
condition|)
name|f
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Admin Queue interrupt handler */
end_comment

begin_function
specifier|static
name|void
name|ixlv_msix_adminq
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|sc
operator|->
name|hw
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|mask
decl_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_ICR01
argument_list|)
expr_stmt|;
name|mask
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_ICR0_ENA1
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_DYN_CTL01
argument_list|)
expr_stmt|;
name|reg
operator||=
name|I40E_PFINT_DYN_CTL0_CLEARPBA_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_DYN_CTL01
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* re-enable interrupt causes */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_ICR0_ENA1
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_DYN_CTL01
argument_list|,
name|I40E_VFINT_DYN_CTL01_INTENA_MASK
argument_list|)
expr_stmt|;
comment|/* schedule task */
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|aq_irq
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ixlv_enable_intr
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|ixlv_enable_adminq_irq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
name|ixlv_enable_queue_irq
argument_list|(
name|hw
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixlv_disable_intr
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|ixlv_disable_adminq_irq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
name|ixlv_disable_queue_irq
argument_list|(
name|hw
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_disable_adminq_irq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_DYN_CTL01
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_ICR0_ENA1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* flush */
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VFGEN_RSTAT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_enable_adminq_irq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_DYN_CTL01
argument_list|,
name|I40E_VFINT_DYN_CTL01_INTENA_MASK
operator||
name|I40E_VFINT_DYN_CTL01_ITR_INDX_MASK
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_ICR0_ENA1
argument_list|,
name|I40E_VFINT_ICR0_ENA_ADMINQ_MASK
argument_list|)
expr_stmt|;
comment|/* flush */
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VFGEN_RSTAT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_enable_queue_irq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|I40E_VFINT_DYN_CTLN1_INTENA_MASK
operator||
name|I40E_VFINT_DYN_CTLN_CLEARPBA_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_DYN_CTLN1
argument_list|(
name|id
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_disable_queue_irq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_DYN_CTLN1
argument_list|(
name|id
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VFGEN_RSTAT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** Provide a update to the queue RX ** interrupt moderation value. */
end_comment

begin_function
specifier|static
name|void
name|ixlv_set_queue_rx_itr
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|u16
name|rx_itr
decl_stmt|;
name|u16
name|rx_latency
init|=
literal|0
decl_stmt|;
name|int
name|rx_bytes
decl_stmt|;
comment|/* Idle, do nothing */
if|if
condition|(
name|rxr
operator|->
name|bytes
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|ixlv_dynamic_rx_itr
condition|)
block|{
name|rx_bytes
operator|=
name|rxr
operator|->
name|bytes
operator|/
name|rxr
operator|->
name|itr
expr_stmt|;
name|rx_itr
operator|=
name|rxr
operator|->
name|itr
expr_stmt|;
comment|/* Adjust latency range */
switch|switch
condition|(
name|rxr
operator|->
name|latency
condition|)
block|{
case|case
name|IXL_LOW_LATENCY
case|:
if|if
condition|(
name|rx_bytes
operator|>
literal|10
condition|)
block|{
name|rx_latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|rx_itr
operator|=
name|IXL_ITR_20K
expr_stmt|;
block|}
break|break;
case|case
name|IXL_AVE_LATENCY
case|:
if|if
condition|(
name|rx_bytes
operator|>
literal|20
condition|)
block|{
name|rx_latency
operator|=
name|IXL_BULK_LATENCY
expr_stmt|;
name|rx_itr
operator|=
name|IXL_ITR_8K
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rx_bytes
operator|<=
literal|10
condition|)
block|{
name|rx_latency
operator|=
name|IXL_LOW_LATENCY
expr_stmt|;
name|rx_itr
operator|=
name|IXL_ITR_100K
expr_stmt|;
block|}
break|break;
case|case
name|IXL_BULK_LATENCY
case|:
if|if
condition|(
name|rx_bytes
operator|<=
literal|20
condition|)
block|{
name|rx_latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|rx_itr
operator|=
name|IXL_ITR_20K
expr_stmt|;
block|}
break|break;
block|}
name|rxr
operator|->
name|latency
operator|=
name|rx_latency
expr_stmt|;
if|if
condition|(
name|rx_itr
operator|!=
name|rxr
operator|->
name|itr
condition|)
block|{
comment|/* do an exponential smoothing */
name|rx_itr
operator|=
operator|(
literal|10
operator|*
name|rx_itr
operator|*
name|rxr
operator|->
name|itr
operator|)
operator|/
operator|(
operator|(
literal|9
operator|*
name|rx_itr
operator|)
operator|+
name|rxr
operator|->
name|itr
operator|)
expr_stmt|;
name|rxr
operator|->
name|itr
operator|=
name|rx_itr
operator|&
name|IXL_MAX_ITR
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_ITRN1
argument_list|(
name|IXL_RX_ITR
argument_list|,
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|rxr
operator|->
name|itr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We may have have toggled to non-dynamic */
if|if
condition|(
name|vsi
operator|->
name|rx_itr_setting
operator|&
name|IXL_ITR_DYNAMIC
condition|)
name|vsi
operator|->
name|rx_itr_setting
operator|=
name|ixlv_rx_itr
expr_stmt|;
comment|/* Update the hardware if needed */
if|if
condition|(
name|rxr
operator|->
name|itr
operator|!=
name|vsi
operator|->
name|rx_itr_setting
condition|)
block|{
name|rxr
operator|->
name|itr
operator|=
name|vsi
operator|->
name|rx_itr_setting
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_ITRN1
argument_list|(
name|IXL_RX_ITR
argument_list|,
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|rxr
operator|->
name|itr
argument_list|)
expr_stmt|;
block|}
block|}
name|rxr
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|packets
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** Provide a update to the queue TX ** interrupt moderation value. */
end_comment

begin_function
specifier|static
name|void
name|ixlv_set_queue_tx_itr
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|u16
name|tx_itr
decl_stmt|;
name|u16
name|tx_latency
init|=
literal|0
decl_stmt|;
name|int
name|tx_bytes
decl_stmt|;
comment|/* Idle, do nothing */
if|if
condition|(
name|txr
operator|->
name|bytes
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|ixlv_dynamic_tx_itr
condition|)
block|{
name|tx_bytes
operator|=
name|txr
operator|->
name|bytes
operator|/
name|txr
operator|->
name|itr
expr_stmt|;
name|tx_itr
operator|=
name|txr
operator|->
name|itr
expr_stmt|;
switch|switch
condition|(
name|txr
operator|->
name|latency
condition|)
block|{
case|case
name|IXL_LOW_LATENCY
case|:
if|if
condition|(
name|tx_bytes
operator|>
literal|10
condition|)
block|{
name|tx_latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|tx_itr
operator|=
name|IXL_ITR_20K
expr_stmt|;
block|}
break|break;
case|case
name|IXL_AVE_LATENCY
case|:
if|if
condition|(
name|tx_bytes
operator|>
literal|20
condition|)
block|{
name|tx_latency
operator|=
name|IXL_BULK_LATENCY
expr_stmt|;
name|tx_itr
operator|=
name|IXL_ITR_8K
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tx_bytes
operator|<=
literal|10
condition|)
block|{
name|tx_latency
operator|=
name|IXL_LOW_LATENCY
expr_stmt|;
name|tx_itr
operator|=
name|IXL_ITR_100K
expr_stmt|;
block|}
break|break;
case|case
name|IXL_BULK_LATENCY
case|:
if|if
condition|(
name|tx_bytes
operator|<=
literal|20
condition|)
block|{
name|tx_latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|tx_itr
operator|=
name|IXL_ITR_20K
expr_stmt|;
block|}
break|break;
block|}
name|txr
operator|->
name|latency
operator|=
name|tx_latency
expr_stmt|;
if|if
condition|(
name|tx_itr
operator|!=
name|txr
operator|->
name|itr
condition|)
block|{
comment|/* do an exponential smoothing */
name|tx_itr
operator|=
operator|(
literal|10
operator|*
name|tx_itr
operator|*
name|txr
operator|->
name|itr
operator|)
operator|/
operator|(
operator|(
literal|9
operator|*
name|tx_itr
operator|)
operator|+
name|txr
operator|->
name|itr
operator|)
expr_stmt|;
name|txr
operator|->
name|itr
operator|=
name|tx_itr
operator|&
name|IXL_MAX_ITR
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_ITRN1
argument_list|(
name|IXL_TX_ITR
argument_list|,
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|txr
operator|->
name|itr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We may have have toggled to non-dynamic */
if|if
condition|(
name|vsi
operator|->
name|tx_itr_setting
operator|&
name|IXL_ITR_DYNAMIC
condition|)
name|vsi
operator|->
name|tx_itr_setting
operator|=
name|ixlv_tx_itr
expr_stmt|;
comment|/* Update the hardware if needed */
if|if
condition|(
name|txr
operator|->
name|itr
operator|!=
name|vsi
operator|->
name|tx_itr_setting
condition|)
block|{
name|txr
operator|->
name|itr
operator|=
name|vsi
operator|->
name|tx_itr_setting
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_ITRN1
argument_list|(
name|IXL_TX_ITR
argument_list|,
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|txr
operator|->
name|itr
argument_list|)
expr_stmt|;
block|}
block|}
name|txr
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|packets
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** ** MSIX Interrupt Handlers and Tasklets ** */
end_comment

begin_function
specifier|static
name|void
name|ixlv_handle_que
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|context
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|bool
name|more
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|more
operator|=
name|ixl_rxeof
argument_list|(
name|que
argument_list|,
name|IXL_RX_LIMIT
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ixl_txeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|ixl_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|task
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Reenable this interrupt - hmmm */
name|ixlv_enable_queue_irq
argument_list|(
name|hw
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  MSIX Queue Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixlv_msix_que
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|arg
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|bool
name|more_tx
decl_stmt|,
name|more_rx
decl_stmt|;
comment|/* Spurious interrupts are ignored */
if|if
condition|(
operator|!
operator|(
name|vsi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return;
operator|++
name|que
operator|->
name|irqs
expr_stmt|;
name|more_rx
operator|=
name|ixl_rxeof
argument_list|(
name|que
argument_list|,
name|IXL_RX_LIMIT
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|more_tx
operator|=
name|ixl_txeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
comment|/* 	** Make certain that if the stack  	** has anything queued the task gets 	** scheduled to handle it. 	*/
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|more_tx
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ixlv_set_queue_rx_itr
argument_list|(
name|que
argument_list|)
expr_stmt|;
name|ixlv_set_queue_tx_itr
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
name|more_tx
operator|||
name|more_rx
condition|)
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|task
argument_list|)
expr_stmt|;
else|else
name|ixlv_enable_queue_irq
argument_list|(
name|hw
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called whenever the user queries the status of  *  the interface using ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixlv_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ixlv_update_link_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
name|vsi
operator|->
name|link_up
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"end: link not up"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
comment|/* Hardware is always full-duplex */
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called when the user changes speed/duplex using  *  media/mediopt option with ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixlv_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
init|=
operator|&
name|vsi
operator|->
name|media
decl_stmt|;
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Multicast Initialization  *  *  This routine is called by init to reset a fresh state.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixlv_init_multi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixlv_mac_filter
modifier|*
name|f
decl_stmt|;
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|IOCTL_DBG_IF
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
comment|/* First clear any multicast filters */
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|sc->mac_filters
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
operator|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_USED
operator|)
operator|&&
operator|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_MC
operator|)
condition|)
block|{
name|f
operator|->
name|flags
operator||=
name|IXL_FILTER_DEL
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mcnt
operator|>
literal|0
condition|)
name|sc
operator|->
name|aq_required
operator||=
name|IXLV_FLAG_AQ_DEL_MAC_FILTER
expr_stmt|;
name|IOCTL_DBG_IF
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_add_multi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|IOCTL_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	** Get a count, to decide if we 	** simply use multicast promiscuous. 	*/
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|mcnt
operator|++
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|mcnt
operator|>=
name|MAX_MULTICAST_ADDR
argument_list|)
condition|)
block|{
comment|/* delete all multicast filters */
name|ixlv_init_multi
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|sc
operator|->
name|promiscuous_flags
operator||=
name|I40E_FLAG_VF_MULTICAST_PROMISC
expr_stmt|;
name|sc
operator|->
name|aq_required
operator||=
name|IXLV_FLAG_AQ_CONFIGURE_PROMISC
expr_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"%s: end: too many filters"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|mcnt
operator|=
literal|0
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ixlv_add_mac_filter
argument_list|(
name|sc
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|IXL_FILTER_MC
argument_list|)
condition|)
name|mcnt
operator|++
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	** Notify AQ task that sw filters need to be 	** added to hw list 	*/
if|if
condition|(
name|mcnt
operator|>
literal|0
condition|)
name|sc
operator|->
name|aq_required
operator||=
name|IXLV_FLAG_AQ_ADD_MAC_FILTER
expr_stmt|;
name|IOCTL_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_del_multi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixlv_mac_filter
modifier|*
name|f
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|bool
name|match
init|=
name|FALSE
decl_stmt|;
name|IOCTL_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
comment|/* Search for removed multicast addresses */
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|sc->mac_filters
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
operator|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_USED
operator|)
operator|&&
operator|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_MC
operator|)
condition|)
block|{
comment|/* check if mac address in filter is in sc's list */
name|match
operator|=
name|FALSE
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|u8
modifier|*
name|mc_addr
init|=
operator|(
name|u8
operator|*
operator|)
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp_etheraddr
argument_list|(
name|f
operator|->
name|macaddr
argument_list|,
name|mc_addr
argument_list|)
condition|)
block|{
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
comment|/* if this filter is not in the sc's list, remove it */
if|if
condition|(
name|match
operator|==
name|FALSE
operator|&&
operator|!
operator|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_DEL
operator|)
condition|)
block|{
name|f
operator|->
name|flags
operator||=
name|IXL_FILTER_DEL
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
name|IOCTL_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"marked: "
name|MAC_FORMAT
argument_list|,
name|MAC_FORMAT_ARGS
argument_list|(
name|f
operator|->
name|macaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|match
operator|==
name|FALSE
condition|)
name|IOCTL_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"exists: "
name|MAC_FORMAT
argument_list|,
name|MAC_FORMAT_ARGS
argument_list|(
name|f
operator|->
name|macaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcnt
operator|>
literal|0
condition|)
name|sc
operator|->
name|aq_required
operator||=
name|IXLV_FLAG_AQ_DEL_MAC_FILTER
expr_stmt|;
name|IOCTL_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Timer routine  *  *  This routine checks for link status,updates statistics,  *  and runs the watchdog check.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixlv_local_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|sc
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|int
name|hung
init|=
literal|0
decl_stmt|;
name|u32
name|mask
decl_stmt|,
name|val
decl_stmt|,
name|oldval
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* If Reset is in progress just bail */
if|if
condition|(
name|sc
operator|->
name|init_state
operator|==
name|IXLV_RESET_PENDING
condition|)
return|return;
comment|/* Check for when PF triggers a VF reset */
name|val
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VFGEN_RSTAT
argument_list|)
operator|&
name|I40E_VFGEN_RSTAT_VFR_STATE_MASK
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|I40E_VFR_VFACTIVE
operator|&&
name|val
operator|!=
name|I40E_VFR_COMPLETED
condition|)
block|{
ifdef|#
directive|ifdef
name|IXL_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: reset in progress! (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* check for Admin queue errors */
name|val
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|arq
operator|.
name|len
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|I40E_VF_ARQLEN_ARQVFE_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ARQ VF Error detected\n"
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|I40E_VF_ARQLEN_ARQVFE_MASK
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|I40E_VF_ARQLEN_ARQOVFL_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ARQ Overflow Error detected\n"
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|I40E_VF_ARQLEN_ARQOVFL_MASK
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|I40E_VF_ARQLEN_ARQCRIT_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ARQ Critical Error detected\n"
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|I40E_VF_ARQLEN_ARQCRIT_MASK
expr_stmt|;
block|}
if|if
condition|(
name|oldval
operator|!=
name|val
condition|)
name|wr32
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|arq
operator|.
name|len
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq
operator|.
name|len
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|I40E_VF_ATQLEN_ATQVFE_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ASQ VF Error detected\n"
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|I40E_VF_ATQLEN_ATQVFE_MASK
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|I40E_VF_ATQLEN_ATQOVFL_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ASQ Overflow Error detected\n"
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|I40E_VF_ATQLEN_ATQOVFL_MASK
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|I40E_VF_ATQLEN_ATQCRIT_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ASQ Critical Error detected\n"
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|I40E_VF_ATQLEN_ATQCRIT_MASK
expr_stmt|;
block|}
if|if
condition|(
name|oldval
operator|!=
name|val
condition|)
name|wr32
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq
operator|.
name|len
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* clean and process any events */
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|aq_irq
argument_list|)
expr_stmt|;
comment|/* 	** Check status on the queues for a hang 	*/
name|mask
operator|=
operator|(
name|I40E_VFINT_DYN_CTLN_INTENA_MASK
operator||
name|I40E_VFINT_DYN_CTLN_SWINT_TRIG_MASK
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
comment|/* Any queues with outstanding work get a sw irq */
if|if
condition|(
name|que
operator|->
name|busy
condition|)
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_DYN_CTLN1
argument_list|(
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* 		** Each time txeof runs without cleaning, but there 		** are uncleaned descriptors it increments busy. If 		** we get to 5 we declare it hung. 		*/
if|if
condition|(
name|que
operator|->
name|busy
operator|==
name|IXL_QUEUE_HUNG
condition|)
block|{
operator|++
name|hung
expr_stmt|;
comment|/* Mark the queue as inactive */
name|vsi
operator|->
name|active_queues
operator|&=
operator|~
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|que
operator|->
name|me
operator|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* Check if we've come back from hung */
if|if
condition|(
operator|(
name|vsi
operator|->
name|active_queues
operator|&
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|que
operator|->
name|me
operator|)
operator|)
operator|==
literal|0
condition|)
name|vsi
operator|->
name|active_queues
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|que
operator|->
name|me
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|que
operator|->
name|busy
operator|>=
name|IXL_MAX_TX_BUSY
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Warning queue %d "
literal|"appears to be hung!\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|que
operator|->
name|busy
operator|=
name|IXL_QUEUE_HUNG
expr_stmt|;
operator|++
name|hung
expr_stmt|;
block|}
block|}
comment|/* Only reset when all queues show hung */
if|if
condition|(
name|hung
operator|==
name|vsi
operator|->
name|num_queues
condition|)
goto|goto
name|hung
goto|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ixlv_local_timer
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return;
name|hung
label|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Local Timer: TX HANG DETECTED - Resetting!!\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|init_state
operator|=
name|IXLV_RESET_REQUIRED
expr_stmt|;
name|ixlv_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Note: this routine updates the OS on the link state **	the real check of the hardware only happens with **	a link interrupt. */
end_comment

begin_function
specifier|static
name|void
name|ixlv_update_link_status
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
if|if
condition|(
name|vsi
operator|->
name|link_up
condition|)
block|{
if|if
condition|(
name|vsi
operator|->
name|link_active
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is Up, %d Gbps\n"
argument_list|,
operator|(
name|vsi
operator|->
name|link_speed
operator|==
name|I40E_LINK_SPEED_40GB
operator|)
condition|?
literal|40
else|:
literal|10
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|link_active
operator|=
name|TRUE
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Link down */
if|if
condition|(
name|vsi
operator|->
name|link_active
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is Down\n"
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|link_active
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  This routine disables all traffic on the adapter by issuing a  *  global reset on the MAC and deallocates TX/RX buffers.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixlv_stop
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|INIT_DBG_IF
argument_list|(
operator|&
name|sc
operator|->
name|vsi
operator|->
name|ifp
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aq_required
operator||=
name|IXLV_FLAG_AQ_DISABLE_QUEUES
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|aq_task
argument_list|,
name|IXLV_CALLOUT_TIMO
argument_list|,
name|ixlv_sched_aq
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Stop the local timer */
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|timer
argument_list|)
expr_stmt|;
name|INIT_DBG_IF
argument_list|(
operator|&
name|sc
operator|->
name|vsi
operator|->
name|ifp
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free all station queue structs.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixlv_free_queues
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ixlv_sc
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|)
condition|)
comment|/* uninitialized */
continue|continue;
name|IXL_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixl_free_que_tx
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|base
condition|)
name|i40e_free_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|hw
argument_list|,
operator|&
name|txr
operator|->
name|dma
argument_list|)
expr_stmt|;
name|IXL_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|IXL_TX_LOCK_DESTROY
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|rxr
operator|->
name|mtx
argument_list|)
condition|)
comment|/* uninitialized */
continue|continue;
name|IXL_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
name|ixl_free_que_rx
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxr
operator|->
name|base
condition|)
name|i40e_free_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|hw
argument_list|,
operator|&
name|rxr
operator|->
name|dma
argument_list|)
expr_stmt|;
name|IXL_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
name|IXL_RX_LOCK_DESTROY
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|vsi
operator|->
name|queues
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** ixlv_config_rss - setup RSS  */
end_comment

begin_function
specifier|static
name|void
name|ixlv_config_rss
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|sc
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|u32
name|lut
init|=
literal|0
decl_stmt|;
name|u64
name|set_hena
decl_stmt|,
name|hena
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* set up random bits */
specifier|static
specifier|const
name|u32
name|seed
index|[
name|I40E_VFQF_HKEY_MAX_INDEX
operator|+
literal|1
index|]
init|=
block|{
literal|0x794221b4
block|,
literal|0xbca0c5ab
block|,
literal|0x6cd5ebd9
block|,
literal|0x1ada6127
block|,
literal|0x983b3aa1
block|,
literal|0x1c4e71eb
block|,
literal|0x7f6328b2
block|,
literal|0xfcdc0da0
block|,
literal|0xc135cafa
block|,
literal|0x7a6f7e2d
block|,
literal|0xe7102d28
block|,
literal|0x163cd12e
block|,
literal|0x4954b126
block|}
decl_stmt|;
comment|/* Fill out hash function seed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|I40E_VFQF_HKEY_MAX_INDEX
condition|;
name|i
operator|++
control|)
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFQF_HKEY
argument_list|(
name|i
argument_list|)
argument_list|,
name|seed
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Enable PCTYPES for RSS: */
name|set_hena
operator|=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_UDP
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_TCP
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_SCTP
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_OTHER
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_FRAG_IPV4
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_UDP
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_TCP
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_SCTP
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_OTHER
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_FRAG_IPV6
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_L2_PAYLOAD
operator|)
expr_stmt|;
name|hena
operator|=
operator|(
name|u64
operator|)
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VFQF_HENA
argument_list|(
literal|0
argument_list|)
argument_list|)
operator||
operator|(
operator|(
name|u64
operator|)
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VFQF_HENA
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|hena
operator||=
name|set_hena
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFQF_HENA
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|u32
operator|)
name|hena
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFQF_HENA
argument_list|(
literal|1
argument_list|)
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|hena
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Populate the LUT with max no. of queues in round robin fashion */
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|func_caps
operator|.
name|rss_table_size
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|vsi
operator|->
name|num_queues
condition|)
name|j
operator|=
literal|0
expr_stmt|;
comment|/* lut = 4-byte sliding window of 4 lut entries */
name|lut
operator|=
operator|(
name|lut
operator|<<
literal|8
operator|)
operator||
operator|(
name|j
operator|&
operator|(
operator|(
literal|0x1
operator|<<
name|hw
operator|->
name|func_caps
operator|.
name|rss_table_entry_width
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* On i = 3, we have 4 entries in lut; write to the register */
if|if
condition|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFQF_HLUT
argument_list|(
name|i
operator|>>
literal|2
argument_list|)
argument_list|,
name|lut
argument_list|)
expr_stmt|;
block|}
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine refreshes vlan filters, called by init ** it scans the filter table and then updates the AQ */
end_comment

begin_function
specifier|static
name|void
name|ixlv_setup_vlan_filters
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixlv_vlan_filter
modifier|*
name|f
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vsi
operator|->
name|num_vlans
operator|==
literal|0
condition|)
return|return;
comment|/* 	** Scan the filter table for vlan entries, 	** and if found call for the AQ update. 	*/
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|sc->vlan_filters
argument_list|,
argument|next
argument_list|)
if|if
condition|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_ADD
condition|)
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
return|return;
name|sc
operator|->
name|aq_required
operator||=
name|IXLV_FLAG_AQ_ADD_VLAN_FILTER
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** This routine adds new MAC filters to the sc's list; ** these are later added in hardware by the periodic ** aq task. */
end_comment

begin_function
specifier|static
name|int
name|ixlv_add_mac_filter
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|,
name|u8
modifier|*
name|macaddr
parameter_list|,
name|u16
name|flags
parameter_list|)
block|{
name|struct
name|ixlv_mac_filter
modifier|*
name|f
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
comment|/* Does one already exist? */
name|f
operator|=
name|ixlv_find_mac_filter
argument_list|(
name|sc
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
name|IDPRINTF
argument_list|(
name|sc
operator|->
name|vsi
operator|.
name|ifp
argument_list|,
literal|"exists: "
name|MAC_FORMAT
argument_list|,
name|MAC_FORMAT_ARGS
argument_list|(
name|macaddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* If not, get a new empty filter */
name|f
operator|=
name|ixlv_get_mac_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: no filters available!!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|IDPRINTF
argument_list|(
name|sc
operator|->
name|vsi
operator|.
name|ifp
argument_list|,
literal|"marked: "
name|MAC_FORMAT
argument_list|,
name|MAC_FORMAT_ARGS
argument_list|(
name|macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|macaddr
argument_list|,
name|f
operator|->
name|macaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|f
operator|->
name|flags
operator||=
operator|(
name|IXL_FILTER_ADD
operator||
name|IXL_FILTER_USED
operator|)
expr_stmt|;
name|f
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Tasklet handler for MSIX Adminq interrupts **  - done outside interrupt context since it might sleep */
end_comment

begin_function
specifier|static
name|void
name|ixlv_do_adminq
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|context
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|sc
operator|->
name|hw
decl_stmt|;
name|struct
name|i40e_arq_event_info
name|event
decl_stmt|;
name|struct
name|i40e_virtchnl_msg
modifier|*
name|v_msg
decl_stmt|;
name|i40e_status
name|ret
decl_stmt|;
name|u16
name|result
init|=
literal|0
decl_stmt|;
name|event
operator|.
name|buf_len
operator|=
name|IXL_AQ_BUF_SZ
expr_stmt|;
name|event
operator|.
name|msg_buf
operator|=
name|malloc
argument_list|(
name|event
operator|.
name|buf_len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|event
operator|.
name|msg_buf
condition|)
block|{
name|printf
argument_list|(
literal|"Unable to allocate adminq memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|v_msg
operator|=
operator|(
expr|struct
name|i40e_virtchnl_msg
operator|*
operator|)
operator|&
name|event
operator|.
name|desc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* clean and process any events */
do|do
block|{
name|ret
operator|=
name|i40e_clean_arq_element
argument_list|(
name|hw
argument_list|,
operator|&
name|event
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
name|ixlv_vc_completion
argument_list|(
name|sc
argument_list|,
name|v_msg
operator|->
name|v_opcode
argument_list|,
name|v_msg
operator|->
name|v_retval
argument_list|,
name|event
operator|.
name|msg_buf
argument_list|,
name|event
operator|.
name|msg_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
name|bzero
argument_list|(
name|event
operator|.
name|msg_buf
argument_list|,
name|IXL_AQ_BUF_SZ
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|result
condition|)
do|;
name|ixlv_enable_adminq_irq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|event
operator|.
name|msg_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** ixlv_sched_aq - Periodic scheduling tasklet **  */
end_comment

begin_function
specifier|static
name|void
name|ixlv_sched_aq
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|context
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
comment|/* This is driven by a callout, don't spin */
if|if
condition|(
operator|!
name|mtx_trylock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
condition|)
goto|goto
name|done_nolock
goto|;
if|if
condition|(
name|sc
operator|->
name|init_state
operator|==
name|IXLV_RESET_PENDING
condition|)
goto|goto
name|done
goto|;
comment|/* Process requested admin queue tasks */
if|if
condition|(
name|sc
operator|->
name|aq_pending
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|sc
operator|->
name|aq_required
operator|&
name|IXLV_FLAG_AQ_MAP_VECTORS
condition|)
block|{
name|ixlv_map_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|aq_required
operator|&
name|IXLV_FLAG_AQ_ADD_MAC_FILTER
condition|)
block|{
name|ixlv_add_ether_filters
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|aq_required
operator|&
name|IXLV_FLAG_AQ_ADD_VLAN_FILTER
condition|)
block|{
name|ixlv_add_vlans
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|aq_required
operator|&
name|IXLV_FLAG_AQ_DEL_MAC_FILTER
condition|)
block|{
name|ixlv_del_ether_filters
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|aq_required
operator|&
name|IXLV_FLAG_AQ_DEL_VLAN_FILTER
condition|)
block|{
name|ixlv_del_vlans
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|aq_required
operator|&
name|IXLV_FLAG_AQ_CONFIGURE_QUEUES
condition|)
block|{
name|ixlv_configure_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|aq_required
operator|&
name|IXLV_FLAG_AQ_DISABLE_QUEUES
condition|)
block|{
name|ixlv_disable_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|aq_required
operator|&
name|IXLV_FLAG_AQ_ENABLE_QUEUES
condition|)
block|{
name|ixlv_enable_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Do stats request only if no other AQ operations requested */
if|if
condition|(
name|vsi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ixlv_request_stats
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|done_nolock
label|:
if|if
condition|(
name|sc
operator|->
name|aq_required
condition|)
comment|/* Reschedule */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|aq_task
argument_list|,
name|IXLV_CALLOUT_TIMO
argument_list|,
name|ixlv_sched_aq
argument_list|,
name|sc
argument_list|)
expr_stmt|;
else|else
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|aq_task
argument_list|,
literal|2
operator|*
name|hz
argument_list|,
name|ixlv_sched_aq
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_add_stats_sysctls
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_eth_stats
modifier|*
name|es
init|=
operator|&
name|vsi
operator|->
name|eth_stats
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|vsi_node
decl_stmt|,
modifier|*
name|queue_node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|vsi_list
decl_stmt|,
modifier|*
name|queue_list
decl_stmt|;
define|#
directive|define
name|QUEUE_NAME_LEN
value|32
name|char
name|queue_namebuf
index|[
name|QUEUE_NAME_LEN
index|]
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|queues
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
decl_stmt|;
comment|/* Driver statistics */
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"watchdog_events"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|watchdog_events
argument_list|,
literal|"Watchdog timeouts"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"admin_irq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|admin_irq
argument_list|,
literal|"Admin Queue IRQ Handled"
argument_list|)
expr_stmt|;
comment|/* VSI statistics */
name|vsi_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"vsi"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"VSI-specific statistics"
argument_list|)
expr_stmt|;
name|vsi_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|vsi_node
argument_list|)
expr_stmt|;
name|struct
name|ixl_sysctl_info
name|ctls
index|[]
init|=
block|{
block|{
operator|&
name|es
operator|->
name|rx_bytes
block|,
literal|"good_octets_rcvd"
block|,
literal|"Good Octets Received"
block|}
block|,
block|{
operator|&
name|es
operator|->
name|rx_unicast
block|,
literal|"ucast_pkts_rcvd"
block|,
literal|"Unicast Packets Received"
block|}
block|,
block|{
operator|&
name|es
operator|->
name|rx_multicast
block|,
literal|"mcast_pkts_rcvd"
block|,
literal|"Multicast Packets Received"
block|}
block|,
block|{
operator|&
name|es
operator|->
name|rx_broadcast
block|,
literal|"bcast_pkts_rcvd"
block|,
literal|"Broadcast Packets Received"
block|}
block|,
block|{
operator|&
name|es
operator|->
name|rx_discards
block|,
literal|"rx_discards"
block|,
literal|"Discarded RX packets"
block|}
block|,
block|{
operator|&
name|es
operator|->
name|tx_bytes
block|,
literal|"good_octets_txd"
block|,
literal|"Good Octets Transmitted"
block|}
block|,
block|{
operator|&
name|es
operator|->
name|tx_unicast
block|,
literal|"ucast_pkts_txd"
block|,
literal|"Unicast Packets Transmitted"
block|}
block|,
block|{
operator|&
name|es
operator|->
name|tx_multicast
block|,
literal|"mcast_pkts_txd"
block|,
literal|"Multicast Packets Transmitted"
block|}
block|,
block|{
operator|&
name|es
operator|->
name|tx_broadcast
block|,
literal|"bcast_pkts_txd"
block|,
literal|"Broadcast Packets Transmitted"
block|}
block|,
block|{
operator|&
name|es
operator|->
name|tx_discards
block|,
literal|"tx_discards"
block|,
literal|"Discarded TX packets"
block|}
block|,
comment|// end
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|struct
name|ixl_sysctl_info
modifier|*
name|entry
init|=
name|ctls
decl_stmt|;
while|while
condition|(
name|entry
operator|->
name|stat
operator|!=
literal|0
condition|)
block|{
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|entry
operator|->
name|stat
argument_list|,
name|entry
operator|->
name|description
argument_list|)
expr_stmt|;
name|entry
operator|++
expr_stmt|;
block|}
comment|/* Queue statistics */
for|for
control|(
name|int
name|q
init|=
literal|0
init|;
name|q
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|q
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|queue_namebuf
argument_list|,
name|QUEUE_NAME_LEN
argument_list|,
literal|"que%d"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|queue_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|vsi_list
argument_list|,
name|OID_AUTO
argument_list|,
name|queue_namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Queue Name"
argument_list|)
expr_stmt|;
name|queue_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue_node
argument_list|)
expr_stmt|;
name|txr
operator|=
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|txr
operator|)
expr_stmt|;
name|rxr
operator|=
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|rxr
operator|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_defrag_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|mbuf_defrag_failed
operator|)
argument_list|,
literal|"m_defrag() failed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|dropped_pkts
operator|)
argument_list|,
literal|"Driver dropped packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"irqs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|irqs
operator|)
argument_list|,
literal|"irqs on this queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tso_tx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|tso
operator|)
argument_list|,
literal|"TSO"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_dma_setup"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|tx_dma_setup
operator|)
argument_list|,
literal|"Driver tx dma failure in xmit"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"no_desc_avail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|txr
operator|->
name|no_desc
operator|)
argument_list|,
literal|"Queue No Descriptor Available"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|txr
operator|->
name|total_packets
operator|)
argument_list|,
literal|"Queue Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_bytes"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|txr
operator|->
name|tx_bytes
operator|)
argument_list|,
literal|"Queue Bytes Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|rxr
operator|->
name|rx_packets
operator|)
argument_list|,
literal|"Queue Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_bytes"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|rxr
operator|->
name|rx_bytes
operator|)
argument_list|,
literal|"Queue Bytes Received"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_init_filters
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|mac_filters
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixlv_mac_filter
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
name|sc
operator|->
name|mac_filters
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vlan_filters
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixlv_vlan_filter
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
name|sc
operator|->
name|vlan_filters
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_free_filters
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ixlv_mac_filter
modifier|*
name|f
decl_stmt|;
name|struct
name|ixlv_vlan_filter
modifier|*
name|v
decl_stmt|;
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
name|sc
operator|->
name|mac_filters
argument_list|)
condition|)
block|{
name|f
operator|=
name|SLIST_FIRST
argument_list|(
name|sc
operator|->
name|mac_filters
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
name|sc
operator|->
name|mac_filters
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
name|sc
operator|->
name|vlan_filters
argument_list|)
condition|)
block|{
name|v
operator|=
name|SLIST_FIRST
argument_list|(
name|sc
operator|->
name|vlan_filters
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
name|sc
operator|->
name|vlan_filters
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

