begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2013-2015, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"ixl.h"
end_include

begin_include
include|#
directive|include
file|"ixlv.h"
end_include

begin_comment
comment|/*********************************************************************  *  Driver version  *********************************************************************/
end_comment

begin_decl_stmt
name|char
name|ixlv_driver_version
index|[]
init|=
literal|"1.4.12-k"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  PCI Device ID Table  *  *  Used by probe to select devices to load on  *  Last field stores an index into ixlv_strings  *  Last entry must be all 0s  *  *  { Vendor ID, Device ID, SubVendor ID, SubDevice ID, String Index }  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|ixl_vendor_info_t
name|ixlv_vendor_info_array
index|[]
init|=
block|{
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_VF
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_X722_VF
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_X722_A0_VF
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* required last entry */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Table of branding strings  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ixlv_strings
index|[]
init|=
block|{
literal|"Intel(R) Ethernet Connection XL710/X722 VF Driver"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Function prototypes  *********************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|ixlv_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_init_locked
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_allocate_pci_resources
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_free_pci_resources
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_assign_msix
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_init_msix
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_init_taskqueue
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_setup_queues
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_config_rss
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_stop
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_add_multi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_del_multi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_free_queues
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_setup_interface
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_teardown_adminq_msix
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_local_timer
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_add_mac_filter
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|,
name|u8
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_del_mac_filter
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|,
name|u8
modifier|*
name|macaddr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_init_filters
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_free_filters
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_msix_que
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_msix_adminq
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_do_adminq
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_do_adminq_locked
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_handle_que
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_reset
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_reset_complete
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_set_queue_rx_itr
parameter_list|(
name|struct
name|ixl_queue
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_set_queue_tx_itr
parameter_list|(
name|struct
name|ixl_queue
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_init_cmd_complete
parameter_list|(
name|struct
name|ixl_vc_cmd
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|enum
name|i40e_status_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_configure_itr
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_enable_adminq_irq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_disable_adminq_irq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_enable_queue_irq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_disable_queue_irq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_setup_vlan_filters
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_register_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_unregister_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_init_hw
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_setup_vc
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_vf_config
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_cap_txcsum_tso
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixlv_add_sysctls
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IXL_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|int
name|ixlv_sysctl_qtx_tail_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixlv_sysctl_qrx_tail_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*********************************************************************  *  FreeBSD Device Interface Entry Points  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|ixlv_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ixlv_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ixlv_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ixlv_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|ixlv_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ixlv_driver
init|=
block|{
literal|"ixlv"
block|,
name|ixlv_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ixlv_sc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|ixlv_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ixlv
argument_list|,
name|pci
argument_list|,
name|ixlv_driver
argument_list|,
name|ixlv_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ixlv
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ixlv
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** TUNEABLE PARAMETERS: */
end_comment

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|ixlv
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"IXLV driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Number of descriptors per ring: **   - TX and RX are the same size */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixlv_ringsz
init|=
name|IXL_DEFAULT_RING
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixlv.ringsz"
argument_list|,
operator|&
name|ixlv_ringsz
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixlv
argument_list|,
name|OID_AUTO
argument_list|,
name|ring_size
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixlv_ringsz
argument_list|,
literal|0
argument_list|,
literal|"Descriptor Ring Size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Set to zero to auto calculate  */
end_comment

begin_decl_stmt
name|int
name|ixlv_max_queues
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixlv.max_queues"
argument_list|,
operator|&
name|ixlv_max_queues
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixlv
argument_list|,
name|OID_AUTO
argument_list|,
name|max_queues
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixlv_max_queues
argument_list|,
literal|0
argument_list|,
literal|"Number of Queues"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Number of entries in Tx queue buf_ring. ** Increasing this will reduce the number of ** errors when transmitting fragmented UDP ** packets. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixlv_txbrsz
init|=
name|DEFAULT_TXBRSZ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixlv.txbrsz"
argument_list|,
operator|&
name|ixlv_txbrsz
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixlv
argument_list|,
name|OID_AUTO
argument_list|,
name|txbr_size
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixlv_txbrsz
argument_list|,
literal|0
argument_list|,
literal|"TX Buf Ring Size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Controls for Interrupt Throttling **      - true/false for dynamic adjustment **      - default values for static ITR */
end_comment

begin_decl_stmt
name|int
name|ixlv_dynamic_rx_itr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixlv.dynamic_rx_itr"
argument_list|,
operator|&
name|ixlv_dynamic_rx_itr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixlv
argument_list|,
name|OID_AUTO
argument_list|,
name|dynamic_rx_itr
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixlv_dynamic_rx_itr
argument_list|,
literal|0
argument_list|,
literal|"Dynamic RX Interrupt Rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ixlv_dynamic_tx_itr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixlv.dynamic_tx_itr"
argument_list|,
operator|&
name|ixlv_dynamic_tx_itr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixlv
argument_list|,
name|OID_AUTO
argument_list|,
name|dynamic_tx_itr
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixlv_dynamic_tx_itr
argument_list|,
literal|0
argument_list|,
literal|"Dynamic TX Interrupt Rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ixlv_rx_itr
init|=
name|IXL_ITR_8K
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixlv.rx_itr"
argument_list|,
operator|&
name|ixlv_rx_itr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixlv
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_itr
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixlv_rx_itr
argument_list|,
literal|0
argument_list|,
literal|"RX Interrupt Rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ixlv_tx_itr
init|=
name|IXL_ITR_4K
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixlv.tx_itr"
argument_list|,
operator|&
name|ixlv_tx_itr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixlv
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_itr
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixlv_tx_itr
argument_list|,
literal|0
argument_list|,
literal|"TX Interrupt Rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*********************************************************************  *  Device identification routine  *  *  ixlv_probe determines if the driver should be loaded on  *  the hardware based on PCI vendor/device id of the device.  *  *  return BUS_PROBE_DEFAULT on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixlv_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ixl_vendor_info_t
modifier|*
name|ent
decl_stmt|;
name|u16
name|pci_vendor_id
decl_stmt|,
name|pci_device_id
decl_stmt|;
name|u16
name|pci_subvendor_id
decl_stmt|,
name|pci_subdevice_id
decl_stmt|;
name|char
name|device_name
index|[
literal|256
index|]
decl_stmt|;
if|#
directive|if
literal|0
block|INIT_DEBUGOUT("ixlv_probe: begin");
endif|#
directive|endif
name|pci_vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_vendor_id
operator|!=
name|I40E_INTEL_VENDOR_ID
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pci_device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subvendor_id
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subdevice_id
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ent
operator|=
name|ixlv_vendor_info_array
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|vendor_id
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pci_vendor_id
operator|==
name|ent
operator|->
name|vendor_id
operator|)
operator|&&
operator|(
name|pci_device_id
operator|==
name|ent
operator|->
name|device_id
operator|)
operator|&&
operator|(
operator|(
name|pci_subvendor_id
operator|==
name|ent
operator|->
name|subvendor_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subvendor_id
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|pci_subdevice_id
operator|==
name|ent
operator|->
name|subdevice_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subdevice_id
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|device_name
argument_list|,
literal|"%s, Version - %s"
argument_list|,
name|ixlv_strings
index|[
name|ent
operator|->
name|index
index|]
argument_list|,
name|ixlv_driver_version
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|device_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
name|ent
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device initialization routine  *  *  The attach entry point is called when the driver is being loaded.  *  This routine identifies the type of hardware, allocates all resources  *  and initializes the hardware.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixlv_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ixlv_sc
modifier|*
name|sc
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
comment|/* Allocate, clear, and link in our primary soft structure */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|sc
operator|->
name|osdep
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|hw
operator|=
operator|&
name|sc
operator|->
name|hw
expr_stmt|;
name|vsi
operator|=
operator|&
name|sc
operator|->
name|vsi
expr_stmt|;
name|vsi
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/* Initialize hw struct */
name|ixlv_init_hw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Allocate filter lists */
name|ixlv_init_filters
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Core Lock Init */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"IXL SC Lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Set up the timer callout */
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|timer
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Do PCI setup - map BAR0, etc */
if|if
condition|(
name|ixlv_allocate_pci_resources
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Allocation of PCI resources failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_early
goto|;
block|}
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"Allocated PCI resources and MSIX vectors"
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_set_mac_type
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: set_mac_type failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_pci_res
goto|;
block|}
name|error
operator|=
name|ixlv_reset_complete
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Device is still being reset\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|err_pci_res
goto|;
block|}
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"VF Device is ready for configuration"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ixlv_setup_vc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Error setting up PF comms, %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_pci_res
goto|;
block|}
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"PF API version verified"
argument_list|)
expr_stmt|;
comment|/* Need API version before sending reset message */
name|error
operator|=
name|ixlv_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"VF reset failed; reload the driver\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_aq
goto|;
block|}
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"VF reset complete"
argument_list|)
expr_stmt|;
comment|/* Ask for VF config from PF */
name|error
operator|=
name|ixlv_vf_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error getting configuration from PF: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_aq
goto|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"VSIs %d, QPs %d, MSIX %d, RSS sizes: key %d lut %d\n"
argument_list|,
name|sc
operator|->
name|vf_res
operator|->
name|num_vsis
argument_list|,
name|sc
operator|->
name|vf_res
operator|->
name|num_queue_pairs
argument_list|,
name|sc
operator|->
name|vf_res
operator|->
name|max_vectors
argument_list|,
name|sc
operator|->
name|vf_res
operator|->
name|rss_key_size
argument_list|,
name|sc
operator|->
name|vf_res
operator|->
name|rss_lut_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXL_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Offload flags: 0x%b\n"
argument_list|,
name|sc
operator|->
name|vf_res
operator|->
name|vf_offload_flags
argument_list|,
name|IXLV_PRINTF_VF_OFFLOAD_FLAGS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* got VF config message back from PF, now we can parse it */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vf_res
operator|->
name|num_vsis
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|vf_res
operator|->
name|vsi_res
index|[
name|i
index|]
operator|.
name|vsi_type
operator|==
name|I40E_VSI_SRIOV
condition|)
name|sc
operator|->
name|vsi_res
operator|=
operator|&
name|sc
operator|->
name|vf_res
operator|->
name|vsi_res
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|vsi_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: no LAN VSI found\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_res_buf
goto|;
block|}
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"Resource Acquisition complete"
argument_list|)
expr_stmt|;
comment|/* If no mac address was assigned just make a random one */
if|if
condition|(
operator|!
name|ixlv_check_ether_addr
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
condition|)
block|{
name|u8
name|addr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|arc4rand
argument_list|(
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
index|[
literal|0
index|]
operator|&=
literal|0xFE
expr_stmt|;
name|addr
index|[
literal|0
index|]
operator||=
literal|0x02
expr_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now that the number of queues for this VF is known, set up interrupts */
name|sc
operator|->
name|msix
operator|=
name|ixlv_init_msix
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* We fail without MSIX support */
if|if
condition|(
name|sc
operator|->
name|msix
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_res_buf
goto|;
block|}
name|vsi
operator|->
name|id
operator|=
name|sc
operator|->
name|vsi_res
operator|->
name|vsi_id
expr_stmt|;
name|vsi
operator|->
name|back
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
expr_stmt|;
name|sc
operator|->
name|link_up
operator|=
name|TRUE
expr_stmt|;
comment|/* This allocates the memory and early settings */
if|if
condition|(
name|ixlv_setup_queues
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: setup queues failed!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Setup the stack interface */
if|if
condition|(
name|ixlv_setup_interface
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: setup interface failed!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"Queue memory and interface setup"
argument_list|)
expr_stmt|;
comment|/* Do queue interrupt setup */
if|if
condition|(
name|ixlv_assign_msix
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: allocating queue interrupts failed!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Start AdminQ taskqueue */
name|ixlv_init_taskqueue
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize stats */
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|vsi
operator|.
name|eth_stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_eth_stats
argument_list|)
argument_list|)
expr_stmt|;
name|ixlv_add_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Register for VLAN events */
name|vsi
operator|->
name|vlan_attach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_config
argument_list|,
name|ixlv_register_vlan
argument_list|,
name|vsi
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|vlan_detach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|ixlv_unregister_vlan
argument_list|,
name|vsi
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
comment|/* We want AQ enabled early */
name|ixlv_enable_adminq_irq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set things up to run init */
name|sc
operator|->
name|init_state
operator|=
name|IXLV_INIT_READY
expr_stmt|;
name|ixl_vc_init_mgr
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|vc_mgr
argument_list|)
expr_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|out
label|:
name|ixlv_free_queues
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|err_res_buf
label|:
name|free
argument_list|(
name|sc
operator|->
name|vf_res
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|err_aq
label|:
name|i40e_shutdown_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|err_pci_res
label|:
name|ixlv_free_pci_resources
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err_early
label|:
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ixlv_free_filters
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"end: error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device removal routine  *  *  The detach entry point is called when the driver is being removed.  *  This routine stops the adapter and deallocates all the resources  *  that were allocated for driver operation.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixlv_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|sc
operator|->
name|hw
decl_stmt|;
name|enum
name|i40e_status_code
name|status
decl_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
comment|/* Make sure VLANS are not using driver */
if|if
condition|(
name|vsi
operator|->
name|ifp
operator|->
name|if_vlantrunk
operator|!=
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|,
literal|"Vlan in use, detach first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Stop driver */
name|ether_ifdetach
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ixlv_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
comment|/* Unregister VLAN events */
if|if
condition|(
name|vsi
operator|->
name|vlan_attach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_config
argument_list|,
name|vsi
operator|->
name|vlan_attach
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsi
operator|->
name|vlan_detach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|vsi
operator|->
name|vlan_detach
argument_list|)
expr_stmt|;
comment|/* Drain VC mgr */
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|vc_mgr
operator|.
name|callout
argument_list|)
expr_stmt|;
name|ixlv_disable_adminq_irq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixlv_teardown_adminq_msix
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Drain admin queue taskqueue */
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|tq
argument_list|)
expr_stmt|;
name|status
operator|=
name|i40e_shutdown_adminq
argument_list|(
operator|&
name|sc
operator|->
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|I40E_SUCCESS
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"i40e_shutdown_adminq() failed with status %s\n"
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|if_free
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|vf_res
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ixlv_free_pci_resources
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ixlv_free_queues
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixlv_free_filters
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Shutdown entry point  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixlv_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ixlv_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Configure TXCSUM(IPV6) and TSO(4/6)  *	- the hardware handles these together so we  *	  need to tweak them   */
end_comment

begin_function
specifier|static
name|void
name|ixlv_cap_txcsum_tso
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
comment|/* Enable/disable TXCSUM/TSO4 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TXCSUM
expr_stmt|;
comment|/* enable TXCSUM, restore TSO if previously enabled */
if|if
condition|(
name|vsi
operator|->
name|flags
operator|&
name|IXL_FLAGS_KEEP_TSO4
condition|)
block|{
name|vsi
operator|->
name|flags
operator|&=
operator|~
name|IXL_FLAGS_KEEP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO4
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
operator|(
name|IFCAP_TXCSUM
operator||
name|IFCAP_TSO4
operator|)
expr_stmt|;
name|vsi
operator|->
name|flags
operator|&=
operator|~
name|IXL_FLAGS_KEEP_TSO4
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"TSO4 requires txcsum, enabling both...\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TXCSUM
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|vsi
operator|->
name|flags
operator||=
name|IXL_FLAGS_KEEP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TXCSUM
operator||
name|IFCAP_TSO4
operator|)
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"TSO4 requires txcsum, disabling both...\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO4
expr_stmt|;
block|}
comment|/* Enable/disable TXCSUM_IPV6/TSO6 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO6
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
if|if
condition|(
name|vsi
operator|->
name|flags
operator|&
name|IXL_FLAGS_KEEP_TSO6
condition|)
block|{
name|vsi
operator|->
name|flags
operator|&=
operator|~
name|IXL_FLAGS_KEEP_TSO6
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO6
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
operator|(
name|IFCAP_TXCSUM_IPV6
operator||
name|IFCAP_TSO6
operator|)
expr_stmt|;
name|vsi
operator|->
name|flags
operator|&=
operator|~
name|IXL_FLAGS_KEEP_TSO6
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"TSO6 requires txcsum6, enabling both...\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO6
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO6
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
block|{
name|vsi
operator|->
name|flags
operator||=
name|IXL_FLAGS_KEEP_TSO6
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TXCSUM_IPV6
operator||
name|IFCAP_TSO6
operator|)
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"TSO6 requires txcsum6, disabling both...\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO6
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Ioctl entry point  *  *  ixlv_ioctl is called when the user wants to configure the  *  interface.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixlv_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|bool
name|avoid_reset
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
comment|/* 		** Calling init results in link renegotiation, 		** so we avoid doing it when possible. 		*/
if|if
condition|(
name|avoid_reset
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|ixlv_init
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_NOARP
operator|)
condition|)
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIOCSIFMTU
case|:
name|IOCTL_DBG_IF2
argument_list|(
name|ifp
argument_list|,
literal|"SIOCSIFMTU (Set Interface MTU)"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|IXL_MAX_FRAME
operator|-
name|ETHER_HDR_LEN
operator|-
name|ETHER_CRC_LEN
operator|-
name|ETHER_VLAN_ENCAP_LEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|IOCTL_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"mtu too large"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOCTL_DBG_IF2
argument_list|(
name|ifp
argument_list|,
literal|"mtu: %lu -> %d"
argument_list|,
operator|(
name|u_long
operator|)
name|ifp
operator|->
name|if_mtu
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
comment|// ERJ: Interestingly enough, these types don't match
name|ifp
operator|->
name|if_mtu
operator|=
operator|(
name|u_long
operator|)
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|vsi
operator|->
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ixlv_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|IOCTL_DBG_IF2
argument_list|(
name|ifp
argument_list|,
literal|"SIOCSIFFLAGS (Set Interface Flags)"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
name|ixlv_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ixlv_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
name|IOCTL_DBG_IF2
argument_list|(
name|ifp
argument_list|,
literal|"SIOCADDMULTI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ixlv_disable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixlv_add_multi
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixlv_enable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCDELMULTI
case|:
name|IOCTL_DBG_IF2
argument_list|(
name|ifp
argument_list|,
literal|"SIOCDELMULTI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|init_state
operator|==
name|IXLV_RUNNING
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ixlv_disable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixlv_del_multi
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixlv_enable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|IOCTL_DBG_IF2
argument_list|(
name|ifp
argument_list|,
literal|"SIOCxIFMEDIA (Get/Set Interface Media)"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
block|{
name|int
name|mask
init|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
decl_stmt|;
name|IOCTL_DBG_IF2
argument_list|(
name|ifp
argument_list|,
literal|"SIOCSIFCAP (Set Capabilities)"
argument_list|)
expr_stmt|;
name|ixlv_cap_txcsum_tso
argument_list|(
name|vsi
argument_list|,
name|ifp
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM_IPV6
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTSO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTSO
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|ixlv_init
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
block|}
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|IOCTL_DBG_IF2
argument_list|(
name|ifp
argument_list|,
literal|"UNKNOWN (0x%X)"
argument_list|,
operator|(
name|int
operator|)
name|command
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** To do a reinit on the VF is unfortunately more complicated ** than a physical device, we must have the PF more or less ** completely recreate our memory, so many things that were ** done only once at attach in traditional drivers now must be ** redone at each reinitialization. This function does that ** 'prelude' so we can then call the normal locked init code. */
end_comment

begin_function
name|int
name|ixlv_reinit_locked
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|sc
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|ixlv_mac_filter
modifier|*
name|mf
decl_stmt|,
modifier|*
name|mf_temp
decl_stmt|;
name|struct
name|ixlv_vlan_filter
modifier|*
name|vf
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ixlv_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|ixlv_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"VF was reset"
argument_list|)
expr_stmt|;
comment|/* set the state in case we went thru RESET */
name|sc
operator|->
name|init_state
operator|=
name|IXLV_RUNNING
expr_stmt|;
comment|/* 	** Resetting the VF drops all filters from hardware; 	** we need to mark them to be re-added in init. 	*/
name|SLIST_FOREACH_SAFE
argument_list|(
argument|mf
argument_list|,
argument|sc->mac_filters
argument_list|,
argument|next
argument_list|,
argument|mf_temp
argument_list|)
block|{
if|if
condition|(
name|mf
operator|->
name|flags
operator|&
name|IXL_FILTER_DEL
condition|)
block|{
name|SLIST_REMOVE
argument_list|(
name|sc
operator|->
name|mac_filters
argument_list|,
name|mf
argument_list|,
name|ixlv_mac_filter
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
else|else
name|mf
operator|->
name|flags
operator||=
name|IXL_FILTER_ADD
expr_stmt|;
block|}
if|if
condition|(
name|vsi
operator|->
name|num_vlans
operator|!=
literal|0
condition|)
name|SLIST_FOREACH
argument_list|(
argument|vf
argument_list|,
argument|sc->vlan_filters
argument_list|,
argument|next
argument_list|)
name|vf
operator|->
name|flags
operator|=
name|IXL_FILTER_ADD
expr_stmt|;
else|else
block|{
comment|/* clean any stale filters */
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
name|sc
operator|->
name|vlan_filters
argument_list|)
condition|)
block|{
name|vf
operator|=
name|SLIST_FIRST
argument_list|(
name|sc
operator|->
name|vlan_filters
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
name|sc
operator|->
name|vlan_filters
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
name|ixlv_enable_adminq_irq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixl_vc_flush
argument_list|(
operator|&
name|sc
operator|->
name|vc_mgr
argument_list|)
expr_stmt|;
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_init_cmd_complete
parameter_list|(
name|struct
name|ixl_vc_cmd
modifier|*
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|enum
name|i40e_status_code
name|code
parameter_list|)
block|{
name|struct
name|ixlv_sc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
comment|/* 	 * Ignore "Adapter Stopped" message as that happens if an ifconfig down 	 * happens while a command is in progress, so we don't print an error 	 * in that case. 	 */
if|if
condition|(
name|code
operator|!=
name|I40E_SUCCESS
operator|&&
name|code
operator|!=
name|I40E_ERR_ADAPTER_STOPPED
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|vsi
operator|.
name|ifp
argument_list|,
literal|"Error %s waiting for PF to complete operation %d\n"
argument_list|,
name|i40e_stat_str
argument_list|(
operator|&
name|sc
operator|->
name|hw
argument_list|,
name|code
argument_list|)
argument_list|,
name|cmd
operator|->
name|request
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_init_locked
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|sc
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
name|IXLV_CORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Do a reinit first if an init has already been done */
if|if
condition|(
operator|(
name|sc
operator|->
name|init_state
operator|==
name|IXLV_RUNNING
operator|)
operator|||
operator|(
name|sc
operator|->
name|init_state
operator|==
name|IXLV_RESET_REQUIRED
operator|)
operator|||
operator|(
name|sc
operator|->
name|init_state
operator|==
name|IXLV_RESET_PENDING
operator|)
condition|)
name|error
operator|=
name|ixlv_reinit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Don't bother with init if we failed reinit */
if|if
condition|(
name|error
condition|)
goto|goto
name|init_done
goto|;
comment|/* Remove existing MAC filter if new MAC addr is set */
if|if
condition|(
name|bcmp
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ixlv_del_mac_filter
argument_list|(
name|sc
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|ixl_vc_enqueue
argument_list|(
operator|&
name|sc
operator|->
name|vc_mgr
argument_list|,
operator|&
name|sc
operator|->
name|del_mac_cmd
argument_list|,
name|IXLV_FLAG_AQ_DEL_MAC_FILTER
argument_list|,
name|ixl_init_cmd_complete
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Check for an LAA mac address... */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_OFFLOAD_IPV4
operator|&
operator|~
name|CSUM_IP
operator|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_OFFLOAD_IPV6
expr_stmt|;
comment|/* Add mac filter for this VF to PF */
if|if
condition|(
name|i40e_validate_mac_addr
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
operator|==
name|I40E_SUCCESS
condition|)
block|{
name|error
operator|=
name|ixlv_add_mac_filter
argument_list|(
name|sc
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|||
name|error
operator|==
name|EEXIST
condition|)
name|ixl_vc_enqueue
argument_list|(
operator|&
name|sc
operator|->
name|vc_mgr
argument_list|,
operator|&
name|sc
operator|->
name|add_mac_cmd
argument_list|,
name|IXLV_FLAG_AQ_ADD_MAC_FILTER
argument_list|,
name|ixl_init_cmd_complete
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Setup vlan's if needed */
name|ixlv_setup_vlan_filters
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Prepare the queues for operation */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|ixl_init_tx_ring
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsi
operator|->
name|max_frame_size
operator|<=
name|MCLBYTES
condition|)
name|rxr
operator|->
name|mbuf_sz
operator|=
name|MCLBYTES
expr_stmt|;
else|else
name|rxr
operator|->
name|mbuf_sz
operator|=
name|MJUMPAGESIZE
expr_stmt|;
name|ixl_init_rx_ring
argument_list|(
name|que
argument_list|)
expr_stmt|;
block|}
comment|/* Set initial ITR values */
name|ixlv_configure_itr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Configure queues */
name|ixl_vc_enqueue
argument_list|(
operator|&
name|sc
operator|->
name|vc_mgr
argument_list|,
operator|&
name|sc
operator|->
name|config_queues_cmd
argument_list|,
name|IXLV_FLAG_AQ_CONFIGURE_QUEUES
argument_list|,
name|ixl_init_cmd_complete
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Set up RSS */
name|ixlv_config_rss
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Map vectors */
name|ixl_vc_enqueue
argument_list|(
operator|&
name|sc
operator|->
name|vc_mgr
argument_list|,
operator|&
name|sc
operator|->
name|map_vectors_cmd
argument_list|,
name|IXLV_FLAG_AQ_MAP_VECTORS
argument_list|,
name|ixl_init_cmd_complete
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable queues */
name|ixl_vc_enqueue
argument_list|(
operator|&
name|sc
operator|->
name|vc_mgr
argument_list|,
operator|&
name|sc
operator|->
name|enable_queues_cmd
argument_list|,
name|IXLV_FLAG_AQ_ENABLE_QUEUES
argument_list|,
name|ixl_init_cmd_complete
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Start the local timer */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ixlv_local_timer
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|init_state
operator|=
name|IXLV_RUNNING
expr_stmt|;
name|init_done
label|:
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* **  Init entry point for the stack */
end_comment

begin_function
name|void
name|ixlv_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|(
expr|struct
name|ixl_vsi
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|int
name|retries
init|=
literal|0
decl_stmt|;
comment|/* Prevent init from running again while waiting for AQ calls 	 * made in init_locked() to complete. */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|init_in_progress
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|sc
operator|->
name|init_in_progress
operator|=
name|true
expr_stmt|;
name|ixlv_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* Wait for init_locked to finish */
while|while
condition|(
operator|!
operator|(
name|vsi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|&&
operator|++
name|retries
operator|<
name|IXLV_MAX_INIT_WAIT
condition|)
block|{
name|i40e_msec_pause
argument_list|(
literal|25
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retries
operator|>=
name|IXLV_MAX_INIT_WAIT
condition|)
block|{
name|if_printf
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|,
literal|"Init failed to complete in allotted time!\n"
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|init_in_progress
operator|=
name|false
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ixlv_attach() helper function; gathers information about  * the (virtual) hardware for use elsewhere in the driver.  */
end_comment

begin_function
specifier|static
name|void
name|ixlv_init_hw
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|sc
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
comment|/* Save off the information about this board */
name|hw
operator|->
name|vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|revision_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hw
operator|->
name|subsystem_vendor_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hw
operator|->
name|subsystem_device_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hw
operator|->
name|bus
operator|.
name|device
operator|=
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|bus
operator|.
name|func
operator|=
name|pci_get_function
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ixlv_attach() helper function; initalizes the admin queue  * and attempts to establish contact with the PF by  * retrying the initial "API version" message several times  * or until the PF responds.  */
end_comment

begin_function
specifier|static
name|int
name|ixlv_setup_vc
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|sc
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|ret_error
init|=
literal|0
decl_stmt|,
name|asq_retries
init|=
literal|0
decl_stmt|;
name|bool
name|send_api_ver_retried
init|=
literal|0
decl_stmt|;
comment|/* Need to set these AQ paramters before initializing AQ */
name|hw
operator|->
name|aq
operator|.
name|num_arq_entries
operator|=
name|IXL_AQ_LEN
expr_stmt|;
name|hw
operator|->
name|aq
operator|.
name|num_asq_entries
operator|=
name|IXL_AQ_LEN
expr_stmt|;
name|hw
operator|->
name|aq
operator|.
name|arq_buf_size
operator|=
name|IXL_AQ_BUF_SZ
expr_stmt|;
name|hw
operator|->
name|aq
operator|.
name|asq_buf_size
operator|=
name|IXL_AQ_BUF_SZ
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IXLV_AQ_MAX_ERR
condition|;
name|i
operator|++
control|)
block|{
comment|/* Initialize admin queue */
name|error
operator|=
name|i40e_init_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: init_adminq failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ret_error
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"Initialized Admin Queue; starting"
literal|" send_api_ver attempt %d"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|retry_send
label|:
comment|/* Send VF's API version */
name|error
operator|=
name|ixlv_send_api_ver
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|i40e_shutdown_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_error
operator|=
literal|2
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: unable to send api"
literal|" version to PF on attempt %d, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|asq_retries
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|i40e_asq_done
argument_list|(
name|hw
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|asq_retries
operator|>
name|IXLV_AQ_MAX_ERR
condition|)
block|{
name|i40e_shutdown_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Admin Queue timeout "
literal|"(waiting for send_api_ver), %d more tries...\n"
argument_list|,
name|IXLV_AQ_MAX_ERR
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|ret_error
operator|=
literal|3
expr_stmt|;
break|break;
block|}
name|i40e_msec_pause
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asq_retries
operator|>
name|IXLV_AQ_MAX_ERR
condition|)
continue|continue;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"Sent API version message to PF"
argument_list|)
expr_stmt|;
comment|/* Verify that the VF accepts the PF's API version */
name|error
operator|=
name|ixlv_verify_api_ver
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ETIMEDOUT
condition|)
block|{
if|if
condition|(
operator|!
name|send_api_ver_retried
condition|)
block|{
comment|/* Resend message, one more time */
name|send_api_ver_retried
operator|=
name|true
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Timeout while verifying API version on first"
literal|" try!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|retry_send
goto|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Timeout while verifying API version on second"
literal|" try!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ret_error
operator|=
literal|4
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Unable to verify API version,"
literal|" error %s\n"
argument_list|,
name|__func__
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|ret_error
operator|=
literal|5
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|ret_error
operator|>=
literal|4
condition|)
name|i40e_shutdown_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret_error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ixlv_attach() helper function; asks the PF for this VF's  * configuration, and saves the information if it receives it.  */
end_comment

begin_function
specifier|static
name|int
name|ixlv_vf_config
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|sc
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|int
name|bufsz
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|ret_error
init|=
literal|0
decl_stmt|;
name|int
name|asq_retries
decl_stmt|,
name|retried
init|=
literal|0
decl_stmt|;
name|retry_config
label|:
name|error
operator|=
name|ixlv_send_vf_config_msg
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Unable to send VF config request, attempt %d,"
literal|" error %d\n"
argument_list|,
name|__func__
argument_list|,
name|retried
operator|+
literal|1
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ret_error
operator|=
literal|2
expr_stmt|;
block|}
name|asq_retries
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|i40e_asq_done
argument_list|(
name|hw
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|asq_retries
operator|>
name|IXLV_AQ_MAX_ERR
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Admin Queue timeout "
literal|"(waiting for send_vf_config_msg), attempt %d\n"
argument_list|,
name|__func__
argument_list|,
name|retried
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ret_error
operator|=
literal|3
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|i40e_msec_pause
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"Sent VF config message to PF, attempt %d"
argument_list|,
name|retried
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|vf_res
condition|)
block|{
name|bufsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_virtchnl_vf_resource
argument_list|)
operator|+
operator|(
name|I40E_MAX_VF_VSI
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_virtchnl_vsi_resource
argument_list|)
operator|)
expr_stmt|;
name|sc
operator|->
name|vf_res
operator|=
name|malloc
argument_list|(
name|bufsz
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|vf_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Unable to allocate memory for VF configuration"
literal|" message from PF on attempt %d\n"
argument_list|,
name|__func__
argument_list|,
name|retried
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ret_error
operator|=
literal|1
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Check for VF config response */
name|error
operator|=
name|ixlv_get_vf_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ETIMEDOUT
condition|)
block|{
comment|/* The 1st time we timeout, send the configuration message again */
if|if
condition|(
operator|!
name|retried
condition|)
block|{
name|retried
operator|++
expr_stmt|;
goto|goto
name|retry_config
goto|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: ixlv_get_vf_config() timed out waiting for a response\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Unable to get VF configuration from PF after %d tries!\n"
argument_list|,
name|__func__
argument_list|,
name|retried
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ret_error
operator|=
literal|4
expr_stmt|;
block|}
goto|goto
name|done
goto|;
name|fail
label|:
name|free
argument_list|(
name|sc
operator|->
name|vf_res
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|done
label|:
return|return
operator|(
name|ret_error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate MSI/X vectors, setup the AQ vector early  */
end_comment

begin_function
specifier|static
name|int
name|ixlv_init_msix
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|want
decl_stmt|,
name|vectors
decl_stmt|,
name|queues
decl_stmt|,
name|available
decl_stmt|;
name|int
name|auto_max_queues
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
name|IXL_MSIX_BAR
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|msix_mem
condition|)
block|{
comment|/* May not be enabled */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unable to map MSIX table\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|available
operator|=
name|pci_msix_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|available
operator|==
literal|0
condition|)
block|{
comment|/* system has msix disabled */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|sc
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_mem
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Clamp queues to number of CPUs and # of MSI-X vectors available */
name|auto_max_queues
operator|=
name|min
argument_list|(
name|mp_ncpus
argument_list|,
name|available
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Clamp queues to # assigned to VF by PF */
name|auto_max_queues
operator|=
name|min
argument_list|(
name|auto_max_queues
argument_list|,
name|sc
operator|->
name|vf_res
operator|->
name|num_queue_pairs
argument_list|)
expr_stmt|;
comment|/* Override with tunable value if tunable is less than autoconfig count */
if|if
condition|(
operator|(
name|ixlv_max_queues
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ixlv_max_queues
operator|<=
name|auto_max_queues
operator|)
condition|)
name|queues
operator|=
name|ixlv_max_queues
expr_stmt|;
comment|/* Use autoconfig amount if that's lower */
elseif|else
if|if
condition|(
operator|(
name|ixlv_max_queues
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ixlv_max_queues
operator|>
name|auto_max_queues
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixlv_max_queues (%d) is too large, using "
literal|"autoconfig amount (%d)...\n"
argument_list|,
name|ixlv_max_queues
argument_list|,
name|auto_max_queues
argument_list|)
expr_stmt|;
name|queues
operator|=
name|auto_max_queues
expr_stmt|;
block|}
comment|/* Limit maximum auto-configured queues to 8 if no user value is set */
else|else
name|queues
operator|=
name|min
argument_list|(
name|auto_max_queues
argument_list|,
literal|8
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
comment|/* If we're doing RSS, clamp at the number of RSS buckets */
if|if
condition|(
name|queues
operator|>
name|rss_getnumbuckets
argument_list|()
condition|)
name|queues
operator|=
name|rss_getnumbuckets
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	** Want one vector (RX/TX pair) per queue 	** plus an additional for the admin queue. 	*/
name|want
operator|=
name|queues
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|want
operator|<=
name|available
condition|)
comment|/* Have enough */
name|vectors
operator|=
name|want
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"MSIX Configuration Problem, "
literal|"%d vectors available but %d wanted!\n"
argument_list|,
name|available
argument_list|,
name|want
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
ifdef|#
directive|ifdef
name|RSS
comment|/* 	* If we're doing RSS, the number of queues needs to 	* match the number of RSS buckets that are configured. 	* 	* + If there's more queues than RSS buckets, we'll end 	*   up with queues that get no traffic. 	* 	* + If there's more RSS buckets than queues, we'll end 	*   up having multiple RSS buckets map to the same queue, 	*   so there'll be some contention. 	*/
if|if
condition|(
name|queues
operator|!=
name|rss_getnumbuckets
argument_list|()
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: queues (%d) != RSS buckets (%d)"
literal|"; performance will be impacted.\n"
argument_list|,
name|__func__
argument_list|,
name|queues
argument_list|,
name|rss_getnumbuckets
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|vectors
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Using MSIX interrupts with %d vectors\n"
argument_list|,
name|vectors
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix
operator|=
name|vectors
expr_stmt|;
name|sc
operator|->
name|vsi
operator|.
name|num_queues
operator|=
name|queues
expr_stmt|;
block|}
comment|/* Next we need to setup the vector for the Admin Queue */
name|rid
operator|=
literal|1
expr_stmt|;
comment|/* zero vector + 1 */
name|sc
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate"
literal|" bus resource: AQ interrupt \n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixlv_msix_adminq
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|tag
argument_list|)
condition|)
block|{
name|sc
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register AQ handler"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|res
argument_list|,
name|sc
operator|->
name|tag
argument_list|,
literal|"adminq"
argument_list|)
expr_stmt|;
return|return
operator|(
name|vectors
operator|)
return|;
name|fail
label|:
comment|/* The VF driver MUST use MSIX */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixlv_allocate_pci_resources
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rid
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pci_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|pci_mem
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|osdep
operator|.
name|mem_bus_space_tag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|osdep
operator|.
name|mem_bus_space_size
operator|=
name|rman_get_size
argument_list|(
name|sc
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|osdep
operator|.
name|flush_reg
operator|=
name|I40E_VFGEN_RSTAT
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|hw_addr
operator|=
operator|(
name|u8
operator|*
operator|)
operator|&
name|sc
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|back
operator|=
operator|&
name|sc
operator|->
name|osdep
expr_stmt|;
comment|/* 	** Explicitly set the guest PCI BUSMASTER capability 	** and we must rewrite the ENABLE in the MSIX control 	** register again at this point to cause the host to 	** successfully initialize us. 	** 	** This must be set before accessing any registers. 	*/
block|{
name|u16
name|pci_cmd_word
decl_stmt|;
name|int
name|msix_ctrl
decl_stmt|;
name|pci_cmd_word
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_cmd_word
operator||=
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|pci_cmd_word
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_MSIX
argument_list|,
operator|&
name|rid
argument_list|)
expr_stmt|;
name|rid
operator|+=
name|PCIR_MSIX_CTRL
expr_stmt|;
name|msix_ctrl
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|msix_ctrl
operator||=
name|PCIM_MSIXCTRL_MSIX_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
name|msix_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Disable adminq interrupts (just in case) */
name|ixlv_disable_adminq_irq
argument_list|(
operator|&
name|sc
operator|->
name|hw
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_free_pci_resources
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
comment|/* We may get here before stations are setup */
if|if
condition|(
name|que
operator|==
name|NULL
condition|)
goto|goto
name|early
goto|;
comment|/* 	**  Release all msix queue resources: 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|int
name|rid
init|=
name|que
operator|->
name|msix
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|que
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|que
operator|->
name|tag
argument_list|)
expr_stmt|;
name|que
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|que
operator|->
name|res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|que
operator|->
name|res
argument_list|)
expr_stmt|;
name|que
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|early
label|:
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msix_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
name|IXL_MSIX_BAR
argument_list|)
argument_list|,
name|sc
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pci_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|sc
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create taskqueue and tasklet for Admin Queue interrupts.  */
end_comment

begin_function
specifier|static
name|int
name|ixlv_init_taskqueue
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|aq_irq
argument_list|,
literal|0
argument_list|,
name|ixlv_do_adminq
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixl_adm"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s sc->tq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup MSIX Interrupt resources and handlers for the VSI queues  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixlv_assign_msix
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|,
name|vector
init|=
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|cpuset_t
name|cpu_mask
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|vector
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|int
name|cpu_id
init|=
name|i
decl_stmt|;
name|rid
operator|=
name|vector
operator|+
literal|1
expr_stmt|;
name|txr
operator|=
operator|&
name|que
operator|->
name|txr
expr_stmt|;
name|que
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|que
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate"
literal|" bus resource: que interrupt [%d]\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set the handler function */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixlv_msix_que
argument_list|,
name|que
argument_list|,
operator|&
name|que
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|que
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register que handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|que
operator|->
name|tag
argument_list|,
literal|"que %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Bind the vector to a CPU */
ifdef|#
directive|ifdef
name|RSS
name|cpu_id
operator|=
name|rss_getcpu
argument_list|(
name|i
operator|%
name|rss_getnumbuckets
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bus_bind_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
name|que
operator|->
name|msix
operator|=
name|vector
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|tx_task
argument_list|,
literal|0
argument_list|,
name|ixl_deferred_mq_start
argument_list|,
name|que
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|ixlv_handle_que
argument_list|,
name|que
argument_list|)
expr_stmt|;
name|que
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixlv_que"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|CPU_SETOF
argument_list|(
name|cpu_id
argument_list|,
operator|&
name|cpu_mask
argument_list|)
expr_stmt|;
name|taskqueue_start_threads_cpuset
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
operator|&
name|cpu_mask
argument_list|,
literal|"%s (bucket %d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
else|#
directive|else
name|taskqueue_start_threads
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s que"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Requests a VF reset from the PF. ** ** Requires the VF's Admin Queue to be initialized. */
end_comment

begin_function
specifier|static
name|int
name|ixlv_reset
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|sc
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Ask the PF to reset us if we are initiating */
if|if
condition|(
name|sc
operator|->
name|init_state
operator|!=
name|IXLV_RESET_PENDING
condition|)
name|ixlv_request_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|i40e_msec_pause
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|error
operator|=
name|ixlv_reset_complete
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: VF reset failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|i40e_shutdown_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: shutdown_adminq failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|i40e_init_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: init_adminq failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixlv_reset_complete
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
comment|/* Wait up to ~10 seconds */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VFGEN_RSTAT
argument_list|)
operator|&
name|I40E_VFGEN_RSTAT_VFR_STATE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|==
name|I40E_VFR_VFACTIVE
operator|)
operator|||
operator|(
name|reg
operator|==
name|I40E_VFR_COMPLETED
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|i40e_msec_pause
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup networking device structure and register an interface.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixlv_setup_interface
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|vsi
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: could not allocate ifnet"
literal|" structure!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Gbps
argument_list|(
literal|40
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ixlv_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|vsi
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ixlv_ioctl
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100000
name|if_setgetcounterfn
argument_list|(
name|ifp
argument_list|,
name|ixl_get_counter
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_transmit
operator|=
name|ixl_mq_start
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|ixl_qflush
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|que
operator|->
name|num_desc
operator|-
literal|2
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
comment|/* 	 * Tell the upper layer(s) we support long frames. 	 */
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_HWCSUM_IPV6
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TSO
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_JUMBO_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_HWTSO
operator||
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_VLAN_HWCSUM
operator||
name|IFCAP_LRO
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* 	** Don't turn this on by default, if vlans are 	** created on another pseudo device (eg. lagg) 	** then vlan events are not passed thru, breaking 	** operation, but with HW FILTER off it works. If 	** using vlans directly on the ixl driver you can 	** enable this and get full hardware tag filtering. 	*/
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
comment|/* 	 * Specify the media types supported by this adapter and register 	 * callbacks to update media and link information 	 */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|ixlv_media_change
argument_list|,
name|ixlv_media_status
argument_list|)
expr_stmt|;
comment|// JFV Add media types later?
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
name|INIT_DBG_DEV
argument_list|(
name|dev
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Allocate and setup the interface queues */
end_comment

begin_function
specifier|static
name|int
name|ixlv_setup_queues
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
decl_stmt|;
name|int
name|rsize
decl_stmt|,
name|tsize
decl_stmt|;
name|int
name|error
init|=
name|I40E_SUCCESS
decl_stmt|;
name|vsi
operator|=
operator|&
name|sc
operator|->
name|vsi
expr_stmt|;
name|vsi
operator|->
name|back
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
expr_stmt|;
name|vsi
operator|->
name|hw
operator|=
operator|&
name|sc
operator|->
name|hw
expr_stmt|;
name|vsi
operator|->
name|num_vlans
operator|=
literal|0
expr_stmt|;
comment|/* Get memory for the station queues */
if|if
condition|(
operator|!
operator|(
name|vsi
operator|->
name|queues
operator|=
operator|(
expr|struct
name|ixl_queue
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixl_queue
argument_list|)
operator|*
name|vsi
operator|->
name|num_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate queue memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|early
goto|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|que
operator|=
operator|&
name|vsi
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
name|que
operator|->
name|num_desc
operator|=
name|ixlv_ringsz
expr_stmt|;
name|que
operator|->
name|me
operator|=
name|i
expr_stmt|;
name|que
operator|->
name|vsi
operator|=
name|vsi
expr_stmt|;
name|txr
operator|=
operator|&
name|que
operator|->
name|txr
expr_stmt|;
name|txr
operator|->
name|que
operator|=
name|que
expr_stmt|;
name|txr
operator|->
name|tail
operator|=
name|I40E_QTX_TAIL1
argument_list|(
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
comment|/* Initialize the TX lock */
name|snprintf
argument_list|(
name|txr
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|txr
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:tx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|,
name|txr
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 		** Create the TX descriptor ring, the extra int is 		** added as the location for HEAD WB. 		*/
name|tsize
operator|=
name|roundup2
argument_list|(
operator|(
name|que
operator|->
name|num_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_tx_desc
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|DBA_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|i40e_allocate_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|hw
argument_list|,
operator|&
name|txr
operator|->
name|dma
argument_list|,
name|i40e_mem_reserved
argument_list|,
name|tsize
argument_list|,
name|DBA_ALIGN
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX Descriptor memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|txr
operator|->
name|base
operator|=
operator|(
expr|struct
name|i40e_tx_desc
operator|*
operator|)
name|txr
operator|->
name|dma
operator|.
name|va
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|txr
operator|->
name|base
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
comment|/* Now allocate transmit soft structs for the ring */
if|if
condition|(
name|ixl_allocate_tx_data
argument_list|(
name|que
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up TX structures\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate a buf ring */
name|txr
operator|->
name|br
operator|=
name|buf_ring_alloc
argument_list|(
name|ixlv_txbrsz
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
operator|&
name|txr
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|br
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up TX buf ring\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 		 * Next the RX queues... 		 */
name|rsize
operator|=
name|roundup2
argument_list|(
name|que
operator|->
name|num_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|i40e_rx_desc
argument_list|)
argument_list|,
name|DBA_ALIGN
argument_list|)
expr_stmt|;
name|rxr
operator|=
operator|&
name|que
operator|->
name|rxr
expr_stmt|;
name|rxr
operator|->
name|que
operator|=
name|que
expr_stmt|;
name|rxr
operator|->
name|tail
operator|=
name|I40E_QRX_TAIL1
argument_list|(
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
comment|/* Initialize the RX side lock */
name|snprintf
argument_list|(
name|rxr
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|rxr
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:rx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|rxr
operator|->
name|mtx
argument_list|,
name|rxr
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|i40e_allocate_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|hw
argument_list|,
operator|&
name|rxr
operator|->
name|dma
argument_list|,
name|i40e_mem_reserved
argument_list|,
name|rsize
argument_list|,
literal|4096
argument_list|)
condition|)
block|{
comment|//JFV - should this be DBA?
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate RX Descriptor memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rxr
operator|->
name|base
operator|=
operator|(
expr|union
name|i40e_rx_desc
operator|*
operator|)
name|rxr
operator|->
name|dma
operator|.
name|va
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rxr
operator|->
name|base
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
comment|/* Allocate receive soft structs for the ring */
if|if
condition|(
name|ixl_allocate_rx_data
argument_list|(
name|que
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up receive structs\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|que
operator|=
operator|&
name|vsi
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
name|rxr
operator|=
operator|&
name|que
operator|->
name|rxr
expr_stmt|;
name|txr
operator|=
operator|&
name|que
operator|->
name|txr
expr_stmt|;
if|if
condition|(
name|rxr
operator|->
name|base
condition|)
name|i40e_free_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|hw
argument_list|,
operator|&
name|rxr
operator|->
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|base
condition|)
name|i40e_free_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|hw
argument_list|,
operator|&
name|txr
operator|->
name|dma
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|vsi
operator|->
name|queues
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|early
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** This routine is run via an vlan config EVENT, ** it enables us to use the HW Filter table since ** we can get the vlan id. This just creates the ** entry in the soft version of the VFTA, init will ** repopulate the real table. */
end_comment

begin_function
specifier|static
name|void
name|ixlv_register_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|arg
decl_stmt|;
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|ixlv_vlan_filter
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
comment|/* Not our event */
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
comment|/* Sanity check - make sure it doesn't already exist */
name|SLIST_FOREACH
argument_list|(
argument|v
argument_list|,
argument|sc->vlan_filters
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|v
operator|->
name|vlan
operator|==
name|vtag
condition|)
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
operator|++
name|vsi
operator|->
name|num_vlans
expr_stmt|;
name|v
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixlv_vlan_filter
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
name|sc
operator|->
name|vlan_filters
argument_list|,
name|v
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|v
operator|->
name|vlan
operator|=
name|vtag
expr_stmt|;
name|v
operator|->
name|flags
operator|=
name|IXL_FILTER_ADD
expr_stmt|;
name|ixl_vc_enqueue
argument_list|(
operator|&
name|sc
operator|->
name|vc_mgr
argument_list|,
operator|&
name|sc
operator|->
name|add_vlan_cmd
argument_list|,
name|IXLV_FLAG_AQ_ADD_VLAN_FILTER
argument_list|,
name|ixl_init_cmd_complete
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** This routine is run via an vlan ** unconfig EVENT, remove our entry ** in the soft vfta. */
end_comment

begin_function
specifier|static
name|void
name|ixlv_unregister_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|arg
decl_stmt|;
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|ixlv_vlan_filter
modifier|*
name|v
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|v
argument_list|,
argument|sc->vlan_filters
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|v
operator|->
name|vlan
operator|==
name|vtag
condition|)
block|{
name|v
operator|->
name|flags
operator|=
name|IXL_FILTER_DEL
expr_stmt|;
operator|++
name|i
expr_stmt|;
operator|--
name|vsi
operator|->
name|num_vlans
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
condition|)
name|ixl_vc_enqueue
argument_list|(
operator|&
name|sc
operator|->
name|vc_mgr
argument_list|,
operator|&
name|sc
operator|->
name|del_vlan_cmd
argument_list|,
name|IXLV_FLAG_AQ_DEL_VLAN_FILTER
argument_list|,
name|ixl_init_cmd_complete
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** Get a new filter and add it to the mac filter list. */
end_comment

begin_function
specifier|static
name|struct
name|ixlv_mac_filter
modifier|*
name|ixlv_get_mac_filter
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ixlv_mac_filter
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixlv_mac_filter
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
name|SLIST_INSERT_HEAD
argument_list|(
name|sc
operator|->
name|mac_filters
argument_list|,
name|f
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Find the filter with matching MAC address */
end_comment

begin_function
specifier|static
name|struct
name|ixlv_mac_filter
modifier|*
name|ixlv_find_mac_filter
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|,
name|u8
modifier|*
name|macaddr
parameter_list|)
block|{
name|struct
name|ixlv_mac_filter
modifier|*
name|f
decl_stmt|;
name|bool
name|match
init|=
name|FALSE
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|sc->mac_filters
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|cmp_etheraddr
argument_list|(
name|f
operator|->
name|macaddr
argument_list|,
name|macaddr
argument_list|)
condition|)
block|{
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|match
condition|)
name|f
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixlv_teardown_adminq_msix
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|res
argument_list|,
name|sc
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_teardown_intr() for"
literal|" interrupt 0 failed\n"
argument_list|)
expr_stmt|;
comment|// return (ENXIO);
block|}
name|sc
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|1
argument_list|,
name|sc
operator|->
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_release_resource() for"
literal|" interrupt 0 failed\n"
argument_list|)
expr_stmt|;
comment|// return (ENXIO);
block|}
name|sc
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Admin Queue interrupt handler */
end_comment

begin_function
specifier|static
name|void
name|ixlv_msix_adminq
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|sc
operator|->
name|hw
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|mask
decl_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_ICR01
argument_list|)
expr_stmt|;
name|mask
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_ICR0_ENA1
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_DYN_CTL01
argument_list|)
expr_stmt|;
name|reg
operator||=
name|I40E_VFINT_DYN_CTL01_CLEARPBA_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_DYN_CTL01
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* schedule task */
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|aq_irq
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ixlv_enable_intr
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|ixlv_enable_adminq_irq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
name|ixlv_enable_queue_irq
argument_list|(
name|hw
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixlv_disable_intr
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|ixlv_disable_adminq_irq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
name|ixlv_disable_queue_irq
argument_list|(
name|hw
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_disable_adminq_irq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_DYN_CTL01
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_ICR0_ENA1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* flush */
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VFGEN_RSTAT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_enable_adminq_irq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_DYN_CTL01
argument_list|,
name|I40E_VFINT_DYN_CTL01_INTENA_MASK
operator||
name|I40E_VFINT_DYN_CTL01_ITR_INDX_MASK
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_ICR0_ENA1
argument_list|,
name|I40E_VFINT_ICR0_ENA1_ADMINQ_MASK
argument_list|)
expr_stmt|;
comment|/* flush */
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VFGEN_RSTAT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_enable_queue_irq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|I40E_VFINT_DYN_CTLN1_INTENA_MASK
operator||
name|I40E_VFINT_DYN_CTLN1_CLEARPBA_MASK
operator||
name|I40E_VFINT_DYN_CTLN1_ITR_INDX_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_DYN_CTLN1
argument_list|(
name|id
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_disable_queue_irq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_DYN_CTLN1
argument_list|(
name|id
argument_list|)
argument_list|,
name|I40E_VFINT_DYN_CTLN1_ITR_INDX_MASK
argument_list|)
expr_stmt|;
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VFGEN_RSTAT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Get initial ITR values from tunable values.  */
end_comment

begin_function
specifier|static
name|void
name|ixlv_configure_itr
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|sc
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|vsi
operator|->
name|rx_itr_setting
operator|=
name|ixlv_rx_itr
expr_stmt|;
name|vsi
operator|->
name|tx_itr_setting
operator|=
name|ixlv_tx_itr
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_ITRN1
argument_list|(
name|IXL_RX_ITR
argument_list|,
name|i
argument_list|)
argument_list|,
name|vsi
operator|->
name|rx_itr_setting
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|itr
operator|=
name|vsi
operator|->
name|rx_itr_setting
expr_stmt|;
name|rxr
operator|->
name|latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_ITRN1
argument_list|(
name|IXL_TX_ITR
argument_list|,
name|i
argument_list|)
argument_list|,
name|vsi
operator|->
name|tx_itr_setting
argument_list|)
expr_stmt|;
name|txr
operator|->
name|itr
operator|=
name|vsi
operator|->
name|tx_itr_setting
expr_stmt|;
name|txr
operator|->
name|latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** Provide a update to the queue RX ** interrupt moderation value. */
end_comment

begin_function
specifier|static
name|void
name|ixlv_set_queue_rx_itr
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|u16
name|rx_itr
decl_stmt|;
name|u16
name|rx_latency
init|=
literal|0
decl_stmt|;
name|int
name|rx_bytes
decl_stmt|;
comment|/* Idle, do nothing */
if|if
condition|(
name|rxr
operator|->
name|bytes
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|ixlv_dynamic_rx_itr
condition|)
block|{
name|rx_bytes
operator|=
name|rxr
operator|->
name|bytes
operator|/
name|rxr
operator|->
name|itr
expr_stmt|;
name|rx_itr
operator|=
name|rxr
operator|->
name|itr
expr_stmt|;
comment|/* Adjust latency range */
switch|switch
condition|(
name|rxr
operator|->
name|latency
condition|)
block|{
case|case
name|IXL_LOW_LATENCY
case|:
if|if
condition|(
name|rx_bytes
operator|>
literal|10
condition|)
block|{
name|rx_latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|rx_itr
operator|=
name|IXL_ITR_20K
expr_stmt|;
block|}
break|break;
case|case
name|IXL_AVE_LATENCY
case|:
if|if
condition|(
name|rx_bytes
operator|>
literal|20
condition|)
block|{
name|rx_latency
operator|=
name|IXL_BULK_LATENCY
expr_stmt|;
name|rx_itr
operator|=
name|IXL_ITR_8K
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rx_bytes
operator|<=
literal|10
condition|)
block|{
name|rx_latency
operator|=
name|IXL_LOW_LATENCY
expr_stmt|;
name|rx_itr
operator|=
name|IXL_ITR_100K
expr_stmt|;
block|}
break|break;
case|case
name|IXL_BULK_LATENCY
case|:
if|if
condition|(
name|rx_bytes
operator|<=
literal|20
condition|)
block|{
name|rx_latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|rx_itr
operator|=
name|IXL_ITR_20K
expr_stmt|;
block|}
break|break;
block|}
name|rxr
operator|->
name|latency
operator|=
name|rx_latency
expr_stmt|;
if|if
condition|(
name|rx_itr
operator|!=
name|rxr
operator|->
name|itr
condition|)
block|{
comment|/* do an exponential smoothing */
name|rx_itr
operator|=
operator|(
literal|10
operator|*
name|rx_itr
operator|*
name|rxr
operator|->
name|itr
operator|)
operator|/
operator|(
operator|(
literal|9
operator|*
name|rx_itr
operator|)
operator|+
name|rxr
operator|->
name|itr
operator|)
expr_stmt|;
name|rxr
operator|->
name|itr
operator|=
name|min
argument_list|(
name|rx_itr
argument_list|,
name|IXL_MAX_ITR
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_ITRN1
argument_list|(
name|IXL_RX_ITR
argument_list|,
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|rxr
operator|->
name|itr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We may have have toggled to non-dynamic */
if|if
condition|(
name|vsi
operator|->
name|rx_itr_setting
operator|&
name|IXL_ITR_DYNAMIC
condition|)
name|vsi
operator|->
name|rx_itr_setting
operator|=
name|ixlv_rx_itr
expr_stmt|;
comment|/* Update the hardware if needed */
if|if
condition|(
name|rxr
operator|->
name|itr
operator|!=
name|vsi
operator|->
name|rx_itr_setting
condition|)
block|{
name|rxr
operator|->
name|itr
operator|=
name|vsi
operator|->
name|rx_itr_setting
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_ITRN1
argument_list|(
name|IXL_RX_ITR
argument_list|,
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|rxr
operator|->
name|itr
argument_list|)
expr_stmt|;
block|}
block|}
name|rxr
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|packets
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** Provide a update to the queue TX ** interrupt moderation value. */
end_comment

begin_function
specifier|static
name|void
name|ixlv_set_queue_tx_itr
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|u16
name|tx_itr
decl_stmt|;
name|u16
name|tx_latency
init|=
literal|0
decl_stmt|;
name|int
name|tx_bytes
decl_stmt|;
comment|/* Idle, do nothing */
if|if
condition|(
name|txr
operator|->
name|bytes
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|ixlv_dynamic_tx_itr
condition|)
block|{
name|tx_bytes
operator|=
name|txr
operator|->
name|bytes
operator|/
name|txr
operator|->
name|itr
expr_stmt|;
name|tx_itr
operator|=
name|txr
operator|->
name|itr
expr_stmt|;
switch|switch
condition|(
name|txr
operator|->
name|latency
condition|)
block|{
case|case
name|IXL_LOW_LATENCY
case|:
if|if
condition|(
name|tx_bytes
operator|>
literal|10
condition|)
block|{
name|tx_latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|tx_itr
operator|=
name|IXL_ITR_20K
expr_stmt|;
block|}
break|break;
case|case
name|IXL_AVE_LATENCY
case|:
if|if
condition|(
name|tx_bytes
operator|>
literal|20
condition|)
block|{
name|tx_latency
operator|=
name|IXL_BULK_LATENCY
expr_stmt|;
name|tx_itr
operator|=
name|IXL_ITR_8K
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tx_bytes
operator|<=
literal|10
condition|)
block|{
name|tx_latency
operator|=
name|IXL_LOW_LATENCY
expr_stmt|;
name|tx_itr
operator|=
name|IXL_ITR_100K
expr_stmt|;
block|}
break|break;
case|case
name|IXL_BULK_LATENCY
case|:
if|if
condition|(
name|tx_bytes
operator|<=
literal|20
condition|)
block|{
name|tx_latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|tx_itr
operator|=
name|IXL_ITR_20K
expr_stmt|;
block|}
break|break;
block|}
name|txr
operator|->
name|latency
operator|=
name|tx_latency
expr_stmt|;
if|if
condition|(
name|tx_itr
operator|!=
name|txr
operator|->
name|itr
condition|)
block|{
comment|/* do an exponential smoothing */
name|tx_itr
operator|=
operator|(
literal|10
operator|*
name|tx_itr
operator|*
name|txr
operator|->
name|itr
operator|)
operator|/
operator|(
operator|(
literal|9
operator|*
name|tx_itr
operator|)
operator|+
name|txr
operator|->
name|itr
operator|)
expr_stmt|;
name|txr
operator|->
name|itr
operator|=
name|min
argument_list|(
name|tx_itr
argument_list|,
name|IXL_MAX_ITR
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_ITRN1
argument_list|(
name|IXL_TX_ITR
argument_list|,
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|txr
operator|->
name|itr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We may have have toggled to non-dynamic */
if|if
condition|(
name|vsi
operator|->
name|tx_itr_setting
operator|&
name|IXL_ITR_DYNAMIC
condition|)
name|vsi
operator|->
name|tx_itr_setting
operator|=
name|ixlv_tx_itr
expr_stmt|;
comment|/* Update the hardware if needed */
if|if
condition|(
name|txr
operator|->
name|itr
operator|!=
name|vsi
operator|->
name|tx_itr_setting
condition|)
block|{
name|txr
operator|->
name|itr
operator|=
name|vsi
operator|->
name|tx_itr_setting
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_ITRN1
argument_list|(
name|IXL_TX_ITR
argument_list|,
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|txr
operator|->
name|itr
argument_list|)
expr_stmt|;
block|}
block|}
name|txr
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|packets
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** ** MSIX Interrupt Handlers and Tasklets ** */
end_comment

begin_function
specifier|static
name|void
name|ixlv_handle_que
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|context
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|bool
name|more
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|more
operator|=
name|ixl_rxeof
argument_list|(
name|que
argument_list|,
name|IXL_RX_LIMIT
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ixl_txeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|ixl_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|task
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Reenable this interrupt - hmmm */
name|ixlv_enable_queue_irq
argument_list|(
name|hw
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  MSIX Queue Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixlv_msix_que
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|arg
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|bool
name|more_tx
decl_stmt|,
name|more_rx
decl_stmt|;
comment|/* Spurious interrupts are ignored */
if|if
condition|(
operator|!
operator|(
name|vsi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return;
operator|++
name|que
operator|->
name|irqs
expr_stmt|;
name|more_rx
operator|=
name|ixl_rxeof
argument_list|(
name|que
argument_list|,
name|IXL_RX_LIMIT
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|more_tx
operator|=
name|ixl_txeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
comment|/* 	** Make certain that if the stack  	** has anything queued the task gets 	** scheduled to handle it. 	*/
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|more_tx
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ixlv_set_queue_rx_itr
argument_list|(
name|que
argument_list|)
expr_stmt|;
name|ixlv_set_queue_tx_itr
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
name|more_tx
operator|||
name|more_rx
condition|)
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|task
argument_list|)
expr_stmt|;
else|else
name|ixlv_enable_queue_irq
argument_list|(
name|hw
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called whenever the user queries the status of  *  the interface using ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixlv_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ixlv_update_link_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|link_up
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"end: link not up"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
comment|/* Hardware is always full-duplex */
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called when the user changes speed/duplex using  *  media/mediopt option with ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixlv_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
init|=
operator|&
name|vsi
operator|->
name|media
decl_stmt|;
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Multicast Initialization  *  *  This routine is called by init to reset a fresh state.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixlv_init_multi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixlv_mac_filter
modifier|*
name|f
decl_stmt|;
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|IOCTL_DBG_IF
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
comment|/* First clear any multicast filters */
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|sc->mac_filters
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
operator|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_USED
operator|)
operator|&&
operator|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_MC
operator|)
condition|)
block|{
name|f
operator|->
name|flags
operator||=
name|IXL_FILTER_DEL
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mcnt
operator|>
literal|0
condition|)
name|ixl_vc_enqueue
argument_list|(
operator|&
name|sc
operator|->
name|vc_mgr
argument_list|,
operator|&
name|sc
operator|->
name|del_multi_cmd
argument_list|,
name|IXLV_FLAG_AQ_DEL_MAC_FILTER
argument_list|,
name|ixl_init_cmd_complete
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|IOCTL_DBG_IF
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_add_multi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|IOCTL_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	** Get a count, to decide if we 	** simply use multicast promiscuous. 	*/
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|mcnt
operator|++
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* TODO: Remove -- cannot set promiscuous mode in a VF */
if|if
condition|(
name|__predict_false
argument_list|(
name|mcnt
operator|>=
name|MAX_MULTICAST_ADDR
argument_list|)
condition|)
block|{
comment|/* delete all multicast filters */
name|ixlv_init_multi
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|sc
operator|->
name|promiscuous_flags
operator||=
name|I40E_FLAG_VF_MULTICAST_PROMISC
expr_stmt|;
name|ixl_vc_enqueue
argument_list|(
operator|&
name|sc
operator|->
name|vc_mgr
argument_list|,
operator|&
name|sc
operator|->
name|add_multi_cmd
argument_list|,
name|IXLV_FLAG_AQ_CONFIGURE_PROMISC
argument_list|,
name|ixl_init_cmd_complete
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"%s: end: too many filters"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|mcnt
operator|=
literal|0
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ixlv_add_mac_filter
argument_list|(
name|sc
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|IXL_FILTER_MC
argument_list|)
condition|)
name|mcnt
operator|++
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	** Notify AQ task that sw filters need to be 	** added to hw list 	*/
if|if
condition|(
name|mcnt
operator|>
literal|0
condition|)
name|ixl_vc_enqueue
argument_list|(
operator|&
name|sc
operator|->
name|vc_mgr
argument_list|,
operator|&
name|sc
operator|->
name|add_multi_cmd
argument_list|,
name|IXLV_FLAG_AQ_ADD_MAC_FILTER
argument_list|,
name|ixl_init_cmd_complete
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|IOCTL_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_del_multi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixlv_mac_filter
modifier|*
name|f
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|bool
name|match
init|=
name|FALSE
decl_stmt|;
name|IOCTL_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
comment|/* Search for removed multicast addresses */
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|sc->mac_filters
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
operator|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_USED
operator|)
operator|&&
operator|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_MC
operator|)
condition|)
block|{
comment|/* check if mac address in filter is in sc's list */
name|match
operator|=
name|FALSE
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|u8
modifier|*
name|mc_addr
init|=
operator|(
name|u8
operator|*
operator|)
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp_etheraddr
argument_list|(
name|f
operator|->
name|macaddr
argument_list|,
name|mc_addr
argument_list|)
condition|)
block|{
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
comment|/* if this filter is not in the sc's list, remove it */
if|if
condition|(
name|match
operator|==
name|FALSE
operator|&&
operator|!
operator|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_DEL
operator|)
condition|)
block|{
name|f
operator|->
name|flags
operator||=
name|IXL_FILTER_DEL
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
name|IOCTL_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"marked: "
name|MAC_FORMAT
argument_list|,
name|MAC_FORMAT_ARGS
argument_list|(
name|f
operator|->
name|macaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|match
operator|==
name|FALSE
condition|)
name|IOCTL_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"exists: "
name|MAC_FORMAT
argument_list|,
name|MAC_FORMAT_ARGS
argument_list|(
name|f
operator|->
name|macaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcnt
operator|>
literal|0
condition|)
name|ixl_vc_enqueue
argument_list|(
operator|&
name|sc
operator|->
name|vc_mgr
argument_list|,
operator|&
name|sc
operator|->
name|del_multi_cmd
argument_list|,
name|IXLV_FLAG_AQ_DEL_MAC_FILTER
argument_list|,
name|ixl_init_cmd_complete
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|IOCTL_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Timer routine  *  *  This routine checks for link status,updates statistics,  *  and runs the watchdog check.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixlv_local_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|sc
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|int
name|hung
init|=
literal|0
decl_stmt|;
name|u32
name|mask
decl_stmt|,
name|val
decl_stmt|;
name|s32
name|timer
decl_stmt|,
name|new_timer
decl_stmt|;
name|IXLV_CORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If Reset is in progress just bail */
if|if
condition|(
name|sc
operator|->
name|init_state
operator|==
name|IXLV_RESET_PENDING
condition|)
return|return;
comment|/* Check for when PF triggers a VF reset */
name|val
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VFGEN_RSTAT
argument_list|)
operator|&
name|I40E_VFGEN_RSTAT_VFR_STATE_MASK
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|I40E_VFR_VFACTIVE
operator|&&
name|val
operator|!=
name|I40E_VFR_COMPLETED
condition|)
block|{
name|DDPRINTF
argument_list|(
name|dev
argument_list|,
literal|"reset in progress! (%d)"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
name|ixlv_request_stats
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* clean and process any events */
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|aq_irq
argument_list|)
expr_stmt|;
comment|/* 	** Check status on the queues for a hang 	*/
name|mask
operator|=
operator|(
name|I40E_VFINT_DYN_CTLN1_INTENA_MASK
operator||
name|I40E_VFINT_DYN_CTLN1_SWINT_TRIG_MASK
operator||
name|I40E_VFINT_DYN_CTLN1_ITR_INDX_MASK
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|txr
operator|=
operator|&
name|que
operator|->
name|txr
expr_stmt|;
name|timer
operator|=
name|atomic_load_acq_32
argument_list|(
operator|&
name|txr
operator|->
name|watchdog_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|timer
operator|>
literal|0
condition|)
block|{
name|new_timer
operator|=
name|timer
operator|-
name|hz
expr_stmt|;
if|if
condition|(
name|new_timer
operator|<=
literal|0
condition|)
block|{
name|atomic_store_rel_32
argument_list|(
operator|&
name|txr
operator|->
name|watchdog_timer
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"WARNING: queue %d "
literal|"appears to be hung!\n"
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
operator|++
name|hung
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * If this fails, that means something in the TX path has updated 				 * the watchdog, so it means the TX path is still working and 				 * the watchdog doesn't need to countdown. 				 */
name|atomic_cmpset_rel_32
argument_list|(
operator|&
name|txr
operator|->
name|watchdog_timer
argument_list|,
name|timer
argument_list|,
name|new_timer
argument_list|)
expr_stmt|;
comment|/* Any queues with outstanding work get a sw irq */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_DYN_CTLN1
argument_list|(
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Reset when a queue shows hung */
if|if
condition|(
name|hung
condition|)
goto|goto
name|hung
goto|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ixlv_local_timer
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return;
name|hung
label|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"WARNING: Resetting!\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|init_state
operator|=
name|IXLV_RESET_REQUIRED
expr_stmt|;
name|sc
operator|->
name|watchdog_events
operator|++
expr_stmt|;
name|ixlv_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ixlv_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Note: this routine updates the OS on the link state **	the real check of the hardware only happens with **	a link interrupt. */
end_comment

begin_function
name|void
name|ixlv_update_link_status
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_up
condition|)
block|{
if|if
condition|(
name|vsi
operator|->
name|link_active
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Link is Up, %d Gbps\n"
argument_list|,
operator|(
name|sc
operator|->
name|link_speed
operator|==
name|I40E_LINK_SPEED_40GB
operator|)
condition|?
literal|40
else|:
literal|10
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|link_active
operator|=
name|TRUE
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Link down */
if|if
condition|(
name|vsi
operator|->
name|link_active
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Link is Down\n"
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|link_active
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  This routine disables all traffic on the adapter by issuing a  *  global reset on the MAC and deallocates TX/RX buffers.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixlv_stop
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|start
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vsi
operator|.
name|ifp
expr_stmt|;
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
name|IXLV_CORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ixl_vc_flush
argument_list|(
operator|&
name|sc
operator|->
name|vc_mgr
argument_list|)
expr_stmt|;
name|ixlv_disable_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|start
operator|=
name|ticks
expr_stmt|;
while|while
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|&&
operator|(
operator|(
name|ticks
operator|-
name|start
operator|)
operator|<
name|hz
operator|/
literal|10
operator|)
condition|)
name|ixlv_do_adminq_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Stop the local timer */
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|timer
argument_list|)
expr_stmt|;
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free all station queue structs.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixlv_free_queues
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ixlv_sc
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|)
condition|)
comment|/* uninitialized */
continue|continue;
name|IXL_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixl_free_que_tx
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|base
condition|)
name|i40e_free_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|hw
argument_list|,
operator|&
name|txr
operator|->
name|dma
argument_list|)
expr_stmt|;
name|IXL_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|IXL_TX_LOCK_DESTROY
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|rxr
operator|->
name|mtx
argument_list|)
condition|)
comment|/* uninitialized */
continue|continue;
name|IXL_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
name|ixl_free_que_rx
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxr
operator|->
name|base
condition|)
name|i40e_free_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|hw
argument_list|,
operator|&
name|rxr
operator|->
name|dma
argument_list|)
expr_stmt|;
name|IXL_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
name|IXL_RX_LOCK_DESTROY
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|vsi
operator|->
name|queues
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_config_rss_reg
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|sc
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|u32
name|lut
init|=
literal|0
decl_stmt|;
name|u64
name|set_hena
init|=
literal|0
decl_stmt|,
name|hena
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|que_id
decl_stmt|;
name|u32
name|rss_seed
index|[
name|IXL_RSS_KEY_SIZE_REG
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|u32
name|rss_hash_config
decl_stmt|;
endif|#
directive|endif
comment|/* Don't set up RSS if using a single queue */
if|if
condition|(
name|vsi
operator|->
name|num_queues
operator|==
literal|1
condition|)
block|{
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFQF_HENA
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFQF_HENA
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|RSS
comment|/* Fetch the configured RSS key */
name|rss_getkey
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|rss_seed
argument_list|)
expr_stmt|;
else|#
directive|else
name|ixl_get_default_rss_key
argument_list|(
name|rss_seed
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Fill out hash function seed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXL_RSS_KEY_SIZE_REG
condition|;
name|i
operator|++
control|)
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFQF_HKEY
argument_list|(
name|i
argument_list|)
argument_list|,
name|rss_seed
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Enable PCTYPES for RSS: */
ifdef|#
directive|ifdef
name|RSS
name|rss_hash_config
operator|=
name|rss_gethashconfig
argument_list|()
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_IPV4
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_OTHER
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_TCP_IPV4
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_TCP
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_UDP_IPV4
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_UDP
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_IPV6
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_OTHER
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_IPV6_EX
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_FRAG_IPV6
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_TCP_IPV6
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_TCP
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_UDP_IPV6
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_UDP
operator|)
expr_stmt|;
else|#
directive|else
name|set_hena
operator|=
name|IXL_DEFAULT_RSS_HENA_XL710
expr_stmt|;
endif|#
directive|endif
name|hena
operator|=
operator|(
name|u64
operator|)
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VFQF_HENA
argument_list|(
literal|0
argument_list|)
argument_list|)
operator||
operator|(
operator|(
name|u64
operator|)
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VFQF_HENA
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|hena
operator||=
name|set_hena
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFQF_HENA
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|u32
operator|)
name|hena
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFQF_HENA
argument_list|(
literal|1
argument_list|)
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|hena
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Populate the LUT with max no. of queues in round robin fashion */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|IXL_RSS_VSI_LUT_SIZE
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|vsi
operator|->
name|num_queues
condition|)
name|j
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
comment|/* 		 * Fetch the RSS bucket id for the given indirection entry. 		 * Cap it at the number of configured buckets (which is 		 * num_queues.) 		 */
name|que_id
operator|=
name|rss_get_indirection_to_bucket
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|que_id
operator|=
name|que_id
operator|%
name|vsi
operator|->
name|num_queues
expr_stmt|;
else|#
directive|else
name|que_id
operator|=
name|j
expr_stmt|;
endif|#
directive|endif
comment|/* lut = 4-byte sliding window of 4 lut entries */
name|lut
operator|=
operator|(
name|lut
operator|<<
literal|8
operator|)
operator||
operator|(
name|que_id
operator|&
name|IXL_RSS_VF_LUT_ENTRY_MASK
operator|)
expr_stmt|;
comment|/* On i = 3, we have 4 entries in lut; write to the register */
if|if
condition|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
block|{
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFQF_HLUT
argument_list|(
name|i
operator|>>
literal|2
argument_list|)
argument_list|,
name|lut
argument_list|)
expr_stmt|;
name|DDPRINTF
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"HLUT(%2d): %#010x"
argument_list|,
name|i
argument_list|,
name|lut
argument_list|)
expr_stmt|;
block|}
block|}
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_config_rss_pf
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|ixl_vc_enqueue
argument_list|(
operator|&
name|sc
operator|->
name|vc_mgr
argument_list|,
operator|&
name|sc
operator|->
name|config_rss_key_cmd
argument_list|,
name|IXLV_FLAG_AQ_CONFIG_RSS_KEY
argument_list|,
name|ixl_init_cmd_complete
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ixl_vc_enqueue
argument_list|(
operator|&
name|sc
operator|->
name|vc_mgr
argument_list|,
operator|&
name|sc
operator|->
name|set_rss_hena_cmd
argument_list|,
name|IXLV_FLAG_AQ_SET_RSS_HENA
argument_list|,
name|ixl_init_cmd_complete
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ixl_vc_enqueue
argument_list|(
operator|&
name|sc
operator|->
name|vc_mgr
argument_list|,
operator|&
name|sc
operator|->
name|config_rss_lut_cmd
argument_list|,
name|IXLV_FLAG_AQ_CONFIG_RSS_LUT
argument_list|,
name|ixl_init_cmd_complete
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** ixlv_config_rss - setup RSS  ** ** RSS keys and table are cleared on VF reset. */
end_comment

begin_function
specifier|static
name|void
name|ixlv_config_rss
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|vf_res
operator|->
name|vf_offload_flags
operator|&
name|I40E_VIRTCHNL_VF_OFFLOAD_RSS_REG
condition|)
block|{
name|DDPRINTF
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Setting up RSS using VF registers..."
argument_list|)
expr_stmt|;
name|ixlv_config_rss_reg
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|vf_res
operator|->
name|vf_offload_flags
operator|&
name|I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF
condition|)
block|{
name|DDPRINTF
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Setting up RSS using messages to PF..."
argument_list|)
expr_stmt|;
name|ixlv_config_rss_pf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"VF does not support RSS capability sent by PF.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine refreshes vlan filters, called by init ** it scans the filter table and then updates the AQ */
end_comment

begin_function
specifier|static
name|void
name|ixlv_setup_vlan_filters
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixlv_vlan_filter
modifier|*
name|f
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vsi
operator|->
name|num_vlans
operator|==
literal|0
condition|)
return|return;
comment|/* 	** Scan the filter table for vlan entries, 	** and if found call for the AQ update. 	*/
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|sc->vlan_filters
argument_list|,
argument|next
argument_list|)
if|if
condition|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_ADD
condition|)
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
name|ixl_vc_enqueue
argument_list|(
operator|&
name|sc
operator|->
name|vc_mgr
argument_list|,
operator|&
name|sc
operator|->
name|add_vlan_cmd
argument_list|,
name|IXLV_FLAG_AQ_ADD_VLAN_FILTER
argument_list|,
name|ixl_init_cmd_complete
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine adds new MAC filters to the sc's list; ** these are later added in hardware by sending a virtual ** channel message. */
end_comment

begin_function
specifier|static
name|int
name|ixlv_add_mac_filter
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|,
name|u8
modifier|*
name|macaddr
parameter_list|,
name|u16
name|flags
parameter_list|)
block|{
name|struct
name|ixlv_mac_filter
modifier|*
name|f
decl_stmt|;
comment|/* Does one already exist? */
name|f
operator|=
name|ixlv_find_mac_filter
argument_list|(
name|sc
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
name|IDPRINTF
argument_list|(
name|sc
operator|->
name|vsi
operator|.
name|ifp
argument_list|,
literal|"exists: "
name|MAC_FORMAT
argument_list|,
name|MAC_FORMAT_ARGS
argument_list|(
name|macaddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* If not, get a new empty filter */
name|f
operator|=
name|ixlv_get_mac_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|vsi
operator|.
name|ifp
argument_list|,
literal|"%s: no filters available!!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|IDPRINTF
argument_list|(
name|sc
operator|->
name|vsi
operator|.
name|ifp
argument_list|,
literal|"marked: "
name|MAC_FORMAT
argument_list|,
name|MAC_FORMAT_ARGS
argument_list|(
name|macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|macaddr
argument_list|,
name|f
operator|->
name|macaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|f
operator|->
name|flags
operator||=
operator|(
name|IXL_FILTER_ADD
operator||
name|IXL_FILTER_USED
operator|)
expr_stmt|;
name|f
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Marks a MAC filter for deletion. */
end_comment

begin_function
specifier|static
name|int
name|ixlv_del_mac_filter
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|,
name|u8
modifier|*
name|macaddr
parameter_list|)
block|{
name|struct
name|ixlv_mac_filter
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|ixlv_find_mac_filter
argument_list|(
name|sc
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|f
operator|->
name|flags
operator||=
name|IXL_FILTER_DEL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Tasklet handler for MSIX Adminq interrupts **  - done outside interrupt context since it might sleep */
end_comment

begin_function
specifier|static
name|void
name|ixlv_do_adminq
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ixlv_sc
modifier|*
name|sc
init|=
name|context
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ixlv_do_adminq_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_do_adminq_locked
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|sc
operator|->
name|hw
decl_stmt|;
name|struct
name|i40e_arq_event_info
name|event
decl_stmt|;
name|struct
name|i40e_virtchnl_msg
modifier|*
name|v_msg
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|u16
name|result
init|=
literal|0
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|oldreg
decl_stmt|;
name|i40e_status
name|ret
decl_stmt|;
name|bool
name|aq_error
init|=
name|false
decl_stmt|;
name|IXLV_CORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|event
operator|.
name|buf_len
operator|=
name|IXL_AQ_BUF_SZ
expr_stmt|;
name|event
operator|.
name|msg_buf
operator|=
name|sc
operator|->
name|aq_buffer
expr_stmt|;
name|v_msg
operator|=
operator|(
expr|struct
name|i40e_virtchnl_msg
operator|*
operator|)
operator|&
name|event
operator|.
name|desc
expr_stmt|;
do|do
block|{
name|ret
operator|=
name|i40e_clean_arq_element
argument_list|(
name|hw
argument_list|,
operator|&
name|event
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
name|ixlv_vc_completion
argument_list|(
name|sc
argument_list|,
name|v_msg
operator|->
name|v_opcode
argument_list|,
name|v_msg
operator|->
name|v_retval
argument_list|,
name|event
operator|.
name|msg_buf
argument_list|,
name|event
operator|.
name|msg_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
name|bzero
argument_list|(
name|event
operator|.
name|msg_buf
argument_list|,
name|IXL_AQ_BUF_SZ
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|result
condition|)
do|;
comment|/* check for Admin queue errors */
name|oldreg
operator|=
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|arq
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_VF_ARQLEN1_ARQVFE_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ARQ VF Error detected\n"
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|I40E_VF_ARQLEN1_ARQVFE_MASK
expr_stmt|;
name|aq_error
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_VF_ARQLEN1_ARQOVFL_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ARQ Overflow Error detected\n"
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|I40E_VF_ARQLEN1_ARQOVFL_MASK
expr_stmt|;
name|aq_error
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_VF_ARQLEN1_ARQCRIT_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ARQ Critical Error detected\n"
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|I40E_VF_ARQLEN1_ARQCRIT_MASK
expr_stmt|;
name|aq_error
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|oldreg
operator|!=
name|reg
condition|)
name|wr32
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|arq
operator|.
name|len
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|oldreg
operator|=
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_VF_ATQLEN1_ATQVFE_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ASQ VF Error detected\n"
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|I40E_VF_ATQLEN1_ATQVFE_MASK
expr_stmt|;
name|aq_error
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_VF_ATQLEN1_ATQOVFL_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ASQ Overflow Error detected\n"
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|I40E_VF_ATQLEN1_ATQOVFL_MASK
expr_stmt|;
name|aq_error
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_VF_ATQLEN1_ATQCRIT_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ASQ Critical Error detected\n"
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|I40E_VF_ATQLEN1_ATQCRIT_MASK
expr_stmt|;
name|aq_error
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|oldreg
operator|!=
name|reg
condition|)
name|wr32
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq
operator|.
name|len
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|aq_error
condition|)
block|{
comment|/* Need to reset adapter */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"WARNING: Resetting!\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|init_state
operator|=
name|IXLV_RESET_REQUIRED
expr_stmt|;
name|ixlv_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ixlv_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|ixlv_enable_adminq_irq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_add_sysctls
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|sc
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_eth_stats
modifier|*
name|es
init|=
operator|&
name|vsi
operator|->
name|eth_stats
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|vsi_node
decl_stmt|,
modifier|*
name|queue_node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|vsi_list
decl_stmt|,
modifier|*
name|queue_list
decl_stmt|;
define|#
directive|define
name|QUEUE_NAME_LEN
value|32
name|char
name|queue_namebuf
index|[
name|QUEUE_NAME_LEN
index|]
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|queues
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
decl_stmt|;
comment|/* Driver statistics sysctls */
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"watchdog_events"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|watchdog_events
argument_list|,
literal|"Watchdog timeouts"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"admin_irq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|admin_irq
argument_list|,
literal|"Admin Queue IRQ Handled"
argument_list|)
expr_stmt|;
comment|/* VSI statistics sysctls */
name|vsi_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"vsi"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"VSI-specific statistics"
argument_list|)
expr_stmt|;
name|vsi_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|vsi_node
argument_list|)
expr_stmt|;
name|struct
name|ixl_sysctl_info
name|ctls
index|[]
init|=
block|{
block|{
operator|&
name|es
operator|->
name|rx_bytes
block|,
literal|"good_octets_rcvd"
block|,
literal|"Good Octets Received"
block|}
block|,
block|{
operator|&
name|es
operator|->
name|rx_unicast
block|,
literal|"ucast_pkts_rcvd"
block|,
literal|"Unicast Packets Received"
block|}
block|,
block|{
operator|&
name|es
operator|->
name|rx_multicast
block|,
literal|"mcast_pkts_rcvd"
block|,
literal|"Multicast Packets Received"
block|}
block|,
block|{
operator|&
name|es
operator|->
name|rx_broadcast
block|,
literal|"bcast_pkts_rcvd"
block|,
literal|"Broadcast Packets Received"
block|}
block|,
block|{
operator|&
name|es
operator|->
name|rx_discards
block|,
literal|"rx_discards"
block|,
literal|"Discarded RX packets"
block|}
block|,
block|{
operator|&
name|es
operator|->
name|rx_unknown_protocol
block|,
literal|"rx_unknown_proto"
block|,
literal|"RX unknown protocol packets"
block|}
block|,
block|{
operator|&
name|es
operator|->
name|tx_bytes
block|,
literal|"good_octets_txd"
block|,
literal|"Good Octets Transmitted"
block|}
block|,
block|{
operator|&
name|es
operator|->
name|tx_unicast
block|,
literal|"ucast_pkts_txd"
block|,
literal|"Unicast Packets Transmitted"
block|}
block|,
block|{
operator|&
name|es
operator|->
name|tx_multicast
block|,
literal|"mcast_pkts_txd"
block|,
literal|"Multicast Packets Transmitted"
block|}
block|,
block|{
operator|&
name|es
operator|->
name|tx_broadcast
block|,
literal|"bcast_pkts_txd"
block|,
literal|"Broadcast Packets Transmitted"
block|}
block|,
block|{
operator|&
name|es
operator|->
name|tx_errors
block|,
literal|"tx_errors"
block|,
literal|"TX packet errors"
block|}
block|,
comment|// end
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|struct
name|ixl_sysctl_info
modifier|*
name|entry
init|=
name|ctls
decl_stmt|;
while|while
condition|(
name|entry
operator|->
name|stat
operator|!=
name|NULL
condition|)
block|{
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|entry
operator|->
name|stat
argument_list|,
name|entry
operator|->
name|description
argument_list|)
expr_stmt|;
name|entry
operator|++
expr_stmt|;
block|}
comment|/* Queue sysctls */
for|for
control|(
name|int
name|q
init|=
literal|0
init|;
name|q
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|q
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|queue_namebuf
argument_list|,
name|QUEUE_NAME_LEN
argument_list|,
literal|"que%d"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|queue_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|vsi_list
argument_list|,
name|OID_AUTO
argument_list|,
name|queue_namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Queue Name"
argument_list|)
expr_stmt|;
name|queue_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue_node
argument_list|)
expr_stmt|;
name|txr
operator|=
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|txr
operator|)
expr_stmt|;
name|rxr
operator|=
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|rxr
operator|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_defrag_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|mbuf_defrag_failed
operator|)
argument_list|,
literal|"m_defrag() failed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|dropped_pkts
operator|)
argument_list|,
literal|"Driver dropped packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"irqs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|irqs
operator|)
argument_list|,
literal|"irqs on this queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tso_tx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|tso
operator|)
argument_list|,
literal|"TSO"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_dmamap_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|tx_dmamap_failed
operator|)
argument_list|,
literal|"Driver tx dma failure in xmit"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"no_desc_avail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|txr
operator|->
name|no_desc
operator|)
argument_list|,
literal|"Queue No Descriptor Available"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|txr
operator|->
name|total_packets
operator|)
argument_list|,
literal|"Queue Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_bytes"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|txr
operator|->
name|tx_bytes
operator|)
argument_list|,
literal|"Queue Bytes Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|rxr
operator|->
name|rx_packets
operator|)
argument_list|,
literal|"Queue Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_bytes"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|rxr
operator|->
name|rx_bytes
operator|)
argument_list|,
literal|"Queue Bytes Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_itr"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|rxr
operator|->
name|itr
operator|)
argument_list|,
literal|0
argument_list|,
literal|"Queue Rx ITR Interval"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_itr"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|txr
operator|->
name|itr
operator|)
argument_list|,
literal|0
argument_list|,
literal|"Queue Tx ITR Interval"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXL_DEBUG
comment|/* Examine queue state */
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"qtx_head"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|queues
index|[
name|q
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ixl_queue
argument_list|)
argument_list|,
name|ixlv_sysctl_qtx_tail_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Queue Transmit Descriptor Tail"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"qrx_head"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|queues
index|[
name|q
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ixl_queue
argument_list|)
argument_list|,
name|ixlv_sysctl_qrx_tail_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Queue Receive Descriptor Tail"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"watchdog_timer"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|txr
operator|.
name|watchdog_timer
operator|)
argument_list|,
literal|0
argument_list|,
literal|"Ticks before watchdog event is triggered"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_init_filters
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|mac_filters
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixlv_mac_filter
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
name|sc
operator|->
name|mac_filters
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vlan_filters
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixlv_vlan_filter
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
name|sc
operator|->
name|vlan_filters
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixlv_free_filters
parameter_list|(
name|struct
name|ixlv_sc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ixlv_mac_filter
modifier|*
name|f
decl_stmt|;
name|struct
name|ixlv_vlan_filter
modifier|*
name|v
decl_stmt|;
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
name|sc
operator|->
name|mac_filters
argument_list|)
condition|)
block|{
name|f
operator|=
name|SLIST_FIRST
argument_list|(
name|sc
operator|->
name|mac_filters
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
name|sc
operator|->
name|mac_filters
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
name|sc
operator|->
name|vlan_filters
argument_list|)
condition|)
block|{
name|v
operator|=
name|SLIST_FIRST
argument_list|(
name|sc
operator|->
name|vlan_filters
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
name|sc
operator|->
name|vlan_filters
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IXL_DEBUG
end_ifdef

begin_comment
comment|/**  * ixlv_sysctl_qtx_tail_handler  * Retrieves I40E_QTX_TAIL1 value from hardware  * for a sysctl.  */
end_comment

begin_function
specifier|static
name|int
name|ixlv_sysctl_qtx_tail_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|que
operator|=
operator|(
operator|(
expr|struct
name|ixl_queue
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|que
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|rd32
argument_list|(
name|que
operator|->
name|vsi
operator|->
name|hw
argument_list|,
name|que
operator|->
name|txr
operator|.
name|tail
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixlv_sysctl_qrx_tail_handler  * Retrieves I40E_QRX_TAIL1 value from hardware  * for a sysctl.  */
end_comment

begin_function
specifier|static
name|int
name|ixlv_sysctl_qrx_tail_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u32
name|val
decl_stmt|;
name|que
operator|=
operator|(
operator|(
expr|struct
name|ixl_queue
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|que
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|rd32
argument_list|(
name|que
operator|->
name|vsi
operator|->
name|hw
argument_list|,
name|que
operator|->
name|rxr
operator|.
name|tail
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

