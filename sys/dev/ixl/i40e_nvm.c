begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2013-2014, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"i40e_prototype.h"
end_include

begin_function_decl
name|enum
name|i40e_status_code
name|i40e_read_nvm_word_srctl
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|i40e_status_code
name|i40e_read_nvm_word_aq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|i40e_status_code
name|i40e_read_nvm_buffer_srctl
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|i40e_status_code
name|i40e_read_nvm_buffer_aq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|i40e_status_code
name|i40e_read_nvm_aq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|module_pointer
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|bool
name|last_command
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * i40e_init_nvm_ops - Initialize NVM function pointers  * @hw: pointer to the HW structure  *  * Setup the function pointers and the NVM info structure. Should be called  * once per NVM initialization, e.g. inside the i40e_init_shared_code().  * Please notice that the NVM term is used here (& in all methods covered  * in this file) as an equivalent of the FLASH part mapped into the SR.  * We are accessing FLASH always thru the Shadow RAM.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_init_nvm
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|i40e_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|u32
name|fla
decl_stmt|,
name|gens
decl_stmt|;
name|u8
name|sr_size
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_init_nvm"
argument_list|)
expr_stmt|;
comment|/* The SR size is stored regardless of the nvm programming mode 	 * as the blank mode may be used in the factory line. 	 */
name|gens
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLNVM_GENS
argument_list|)
expr_stmt|;
name|sr_size
operator|=
operator|(
operator|(
name|gens
operator|&
name|I40E_GLNVM_GENS_SR_SIZE_MASK
operator|)
operator|>>
name|I40E_GLNVM_GENS_SR_SIZE_SHIFT
operator|)
expr_stmt|;
comment|/* Switching to words (sr_size contains power of 2KB) */
name|nvm
operator|->
name|sr_size
operator|=
operator|(
literal|1
operator|<<
name|sr_size
operator|)
operator|*
name|I40E_SR_WORDS_IN_1KB
expr_stmt|;
comment|/* Check if we are in the normal or blank NVM programming mode */
name|fla
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLNVM_FLA
argument_list|)
expr_stmt|;
if|if
condition|(
name|fla
operator|&
name|I40E_GLNVM_FLA_LOCKED_MASK
condition|)
block|{
comment|/* Normal programming mode */
comment|/* Max NVM timeout */
name|nvm
operator|->
name|timeout
operator|=
name|I40E_MAX_NVM_TIMEOUT
expr_stmt|;
name|nvm
operator|->
name|blank_nvm_mode
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* Blank programming mode */
name|nvm
operator|->
name|blank_nvm_mode
operator|=
name|TRUE
expr_stmt|;
name|ret_code
operator|=
name|I40E_ERR_NVM_BLANK_MODE
expr_stmt|;
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVM init error: unsupported blank mode.\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_acquire_nvm - Generic request for acquiring the NVM ownership  * @hw: pointer to the HW structure  * @access: NVM access type (read or write)  *  * This function will request NVM ownership for reading  * via the proper Admin Command.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_acquire_nvm
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|enum
name|i40e_aq_resource_access_type
name|access
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|u64
name|gtime
decl_stmt|,
name|timeout
decl_stmt|;
name|u64
name|time_left
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_acquire_nvm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|nvm
operator|.
name|blank_nvm_mode
condition|)
goto|goto
name|i40e_i40e_acquire_nvm_exit
goto|;
name|ret_code
operator|=
name|i40e_aq_request_resource
argument_list|(
name|hw
argument_list|,
name|I40E_NVM_RESOURCE_ID
argument_list|,
name|access
argument_list|,
literal|0
argument_list|,
operator|&
name|time_left
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Reading the Global Device Timer */
name|gtime
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLVFGEN_TIMER
argument_list|)
expr_stmt|;
comment|/* Store the timeout */
name|hw
operator|->
name|nvm
operator|.
name|hw_semaphore_timeout
operator|=
name|I40E_MS_TO_GTIME
argument_list|(
name|time_left
argument_list|)
operator|+
name|gtime
expr_stmt|;
if|if
condition|(
name|ret_code
condition|)
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVM acquire type %d failed time_left=%llu ret=%d aq_err=%d\n"
argument_list|,
name|access
argument_list|,
name|time_left
argument_list|,
name|ret_code
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|&&
name|time_left
condition|)
block|{
comment|/* Poll until the current NVM owner timeouts */
name|timeout
operator|=
name|I40E_MS_TO_GTIME
argument_list|(
name|I40E_MAX_NVM_TIMEOUT
argument_list|)
operator|+
name|gtime
expr_stmt|;
while|while
condition|(
operator|(
name|gtime
operator|<
name|timeout
operator|)
operator|&&
name|time_left
condition|)
block|{
name|i40e_msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|gtime
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLVFGEN_TIMER
argument_list|)
expr_stmt|;
name|ret_code
operator|=
name|i40e_aq_request_resource
argument_list|(
name|hw
argument_list|,
name|I40E_NVM_RESOURCE_ID
argument_list|,
name|access
argument_list|,
literal|0
argument_list|,
operator|&
name|time_left
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|==
name|I40E_SUCCESS
condition|)
block|{
name|hw
operator|->
name|nvm
operator|.
name|hw_semaphore_timeout
operator|=
name|I40E_MS_TO_GTIME
argument_list|(
name|time_left
argument_list|)
operator|+
name|gtime
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ret_code
operator|!=
name|I40E_SUCCESS
condition|)
block|{
name|hw
operator|->
name|nvm
operator|.
name|hw_semaphore_timeout
operator|=
literal|0
expr_stmt|;
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVM acquire timed out, wait %llu ms before trying again. status=%d aq_err=%d\n"
argument_list|,
name|time_left
argument_list|,
name|ret_code
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
block|}
block|}
name|i40e_i40e_acquire_nvm_exit
label|:
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_release_nvm - Generic request for releasing the NVM ownership  * @hw: pointer to the HW structure  *  * This function will release NVM resource via the proper Admin Command.  **/
end_comment

begin_function
name|void
name|i40e_release_nvm
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"i40e_release_nvm"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|nvm
operator|.
name|blank_nvm_mode
condition|)
name|i40e_aq_release_resource
argument_list|(
name|hw
argument_list|,
name|I40E_NVM_RESOURCE_ID
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * i40e_poll_sr_srctl_done_bit - Polls the GLNVM_SRCTL done bit  * @hw: pointer to the HW structure  *  * Polls the SRCTL Shadow RAM register done bit.  **/
end_comment

begin_function
specifier|static
name|enum
name|i40e_status_code
name|i40e_poll_sr_srctl_done_bit
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_ERR_TIMEOUT
decl_stmt|;
name|u32
name|srctl
decl_stmt|,
name|wait_cnt
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_poll_sr_srctl_done_bit"
argument_list|)
expr_stmt|;
comment|/* Poll the I40E_GLNVM_SRCTL until the done bit is set */
for|for
control|(
name|wait_cnt
operator|=
literal|0
init|;
name|wait_cnt
operator|<
name|I40E_SRRD_SRCTL_ATTEMPTS
condition|;
name|wait_cnt
operator|++
control|)
block|{
name|srctl
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLNVM_SRCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|srctl
operator|&
name|I40E_GLNVM_SRCTL_DONE_MASK
condition|)
block|{
name|ret_code
operator|=
name|I40E_SUCCESS
expr_stmt|;
break|break;
block|}
name|i40e_usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret_code
operator|==
name|I40E_ERR_TIMEOUT
condition|)
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"Done bit in GLNVM_SRCTL not set"
argument_list|)
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_read_nvm_word - Reads Shadow RAM  * @hw: pointer to the HW structure  * @offset: offset of the Shadow RAM word to read (0x000000 - 0x001FFF)  * @data: word read from the Shadow RAM  *  * Reads one 16 bit word from the Shadow RAM using the GLNVM_SRCTL register.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_read_nvm_word
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
return|return
name|i40e_read_nvm_word_srctl
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_read_nvm_word_srctl - Reads Shadow RAM via SRCTL register  * @hw: pointer to the HW structure  * @offset: offset of the Shadow RAM word to read (0x000000 - 0x001FFF)  * @data: word read from the Shadow RAM  *  * Reads one 16 bit word from the Shadow RAM using the GLNVM_SRCTL register.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_read_nvm_word_srctl
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_ERR_TIMEOUT
decl_stmt|;
name|u32
name|sr_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_read_nvm_word_srctl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|hw
operator|->
name|nvm
operator|.
name|sr_size
condition|)
block|{
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVM read error: Offset %d beyond Shadow RAM limit %d\n"
argument_list|,
name|offset
argument_list|,
name|hw
operator|->
name|nvm
operator|.
name|sr_size
argument_list|)
expr_stmt|;
name|ret_code
operator|=
name|I40E_ERR_PARAM
expr_stmt|;
goto|goto
name|read_nvm_exit
goto|;
block|}
comment|/* Poll the done bit first */
name|ret_code
operator|=
name|i40e_poll_sr_srctl_done_bit
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|==
name|I40E_SUCCESS
condition|)
block|{
comment|/* Write the address and start reading */
name|sr_reg
operator|=
call|(
name|u32
call|)
argument_list|(
name|offset
operator|<<
name|I40E_GLNVM_SRCTL_ADDR_SHIFT
argument_list|)
operator||
operator|(
literal|1
operator|<<
name|I40E_GLNVM_SRCTL_START_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_GLNVM_SRCTL
argument_list|,
name|sr_reg
argument_list|)
expr_stmt|;
comment|/* Poll I40E_GLNVM_SRCTL until the done bit is set */
name|ret_code
operator|=
name|i40e_poll_sr_srctl_done_bit
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|==
name|I40E_SUCCESS
condition|)
block|{
name|sr_reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLNVM_SRDATA
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
call|(
name|u16
call|)
argument_list|(
operator|(
name|sr_reg
operator|&
name|I40E_GLNVM_SRDATA_RDDATA_MASK
operator|)
operator|>>
name|I40E_GLNVM_SRDATA_RDDATA_SHIFT
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret_code
operator|!=
name|I40E_SUCCESS
condition|)
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVM read error: Couldn't access Shadow RAM address: 0x%x\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|read_nvm_exit
label|:
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_read_nvm_word_aq - Reads Shadow RAM via AQ  * @hw: pointer to the HW structure  * @offset: offset of the Shadow RAM word to read (0x000000 - 0x001FFF)  * @data: word read from the Shadow RAM  *  * Reads one 16 bit word from the Shadow RAM using the GLNVM_SRCTL register.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_read_nvm_word_aq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_ERR_TIMEOUT
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_read_nvm_word_aq"
argument_list|)
expr_stmt|;
name|ret_code
operator|=
name|i40e_read_nvm_aq
argument_list|(
name|hw
argument_list|,
literal|0x0
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|LE16_TO_CPU
argument_list|(
operator|*
operator|(
name|__le16
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_read_nvm_buffer - Reads Shadow RAM buffer  * @hw: pointer to the HW structure  * @offset: offset of the Shadow RAM word to read (0x000000 - 0x001FFF).  * @words: (in) number of words to read; (out) number of words actually read  * @data: words read from the Shadow RAM  *  * Reads 16 bit words (data buffer) from the SR using the i40e_read_nvm_srrd()  * method. The buffer read is preceded by the NVM ownership take  * and followed by the release.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_read_nvm_buffer
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
return|return
name|i40e_read_nvm_buffer_srctl
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_read_nvm_buffer_srctl - Reads Shadow RAM buffer via SRCTL register  * @hw: pointer to the HW structure  * @offset: offset of the Shadow RAM word to read (0x000000 - 0x001FFF).  * @words: (in) number of words to read; (out) number of words actually read  * @data: words read from the Shadow RAM  *  * Reads 16 bit words (data buffer) from the SR using the i40e_read_nvm_srrd()  * method. The buffer read is preceded by the NVM ownership take  * and followed by the release.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_read_nvm_buffer_srctl
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|u16
name|index
decl_stmt|,
name|word
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_read_nvm_buffer_srctl"
argument_list|)
expr_stmt|;
comment|/* Loop thru the selected region */
for|for
control|(
name|word
operator|=
literal|0
init|;
name|word
operator|<
operator|*
name|words
condition|;
name|word
operator|++
control|)
block|{
name|index
operator|=
name|offset
operator|+
name|word
expr_stmt|;
name|ret_code
operator|=
name|i40e_read_nvm_word_srctl
argument_list|(
name|hw
argument_list|,
name|index
argument_list|,
operator|&
name|data
index|[
name|word
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|!=
name|I40E_SUCCESS
condition|)
break|break;
block|}
comment|/* Update the number of words read from the Shadow RAM */
operator|*
name|words
operator|=
name|word
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_read_nvm_buffer_aq - Reads Shadow RAM buffer via AQ  * @hw: pointer to the HW structure  * @offset: offset of the Shadow RAM word to read (0x000000 - 0x001FFF).  * @words: (in) number of words to read; (out) number of words actually read  * @data: words read from the Shadow RAM  *  * Reads 16 bit words (data buffer) from the SR using the i40e_read_nvm_aq()  * method. The buffer read is preceded by the NVM ownership take  * and followed by the release.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_read_nvm_buffer_aq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
decl_stmt|;
name|u16
name|read_size
init|=
operator|*
name|words
decl_stmt|;
name|bool
name|last_cmd
init|=
name|FALSE
decl_stmt|;
name|u16
name|words_read
init|=
literal|0
decl_stmt|;
name|u16
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_read_nvm_buffer_aq"
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* Calculate number of bytes we should read in this step. 		 * FVL AQ do not allow to read more than one page at a time or 		 * to cross page boundaries. 		 */
if|if
condition|(
name|offset
operator|%
name|I40E_SR_SECTOR_SIZE_IN_WORDS
condition|)
name|read_size
operator|=
name|min
argument_list|(
operator|*
name|words
argument_list|,
call|(
name|u16
call|)
argument_list|(
name|I40E_SR_SECTOR_SIZE_IN_WORDS
operator|-
operator|(
name|offset
operator|%
name|I40E_SR_SECTOR_SIZE_IN_WORDS
operator|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|read_size
operator|=
name|min
argument_list|(
operator|(
operator|*
name|words
operator|-
name|words_read
operator|)
argument_list|,
name|I40E_SR_SECTOR_SIZE_IN_WORDS
argument_list|)
expr_stmt|;
comment|/* Check if this is last command, if so set proper flag */
if|if
condition|(
operator|(
name|words_read
operator|+
name|read_size
operator|)
operator|>=
operator|*
name|words
condition|)
name|last_cmd
operator|=
name|TRUE
expr_stmt|;
name|ret_code
operator|=
name|i40e_read_nvm_aq
argument_list|(
name|hw
argument_list|,
literal|0x0
argument_list|,
name|offset
argument_list|,
name|read_size
argument_list|,
name|data
operator|+
name|words_read
argument_list|,
name|last_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|!=
name|I40E_SUCCESS
condition|)
goto|goto
name|read_nvm_buffer_aq_exit
goto|;
comment|/* Increment counter for words already read and move offset to 		 * new read location 		 */
name|words_read
operator|+=
name|read_size
expr_stmt|;
name|offset
operator|+=
name|read_size
expr_stmt|;
block|}
do|while
condition|(
name|words_read
operator|<
operator|*
name|words
condition|)
do|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|words
condition|;
name|i
operator|++
control|)
name|data
index|[
name|i
index|]
operator|=
name|LE16_TO_CPU
argument_list|(
operator|(
operator|(
name|__le16
operator|*
operator|)
name|data
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|read_nvm_buffer_aq_exit
label|:
operator|*
name|words
operator|=
name|words_read
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_read_nvm_aq - Read Shadow RAM.  * @hw: pointer to the HW structure.  * @module_pointer: module pointer location in words from the NVM beginning  * @offset: offset in words from module start  * @words: number of words to write  * @data: buffer with words to write to the Shadow RAM  * @last_command: tells the AdminQ that this is the last command  *  * Writes a 16 bit words buffer to the Shadow RAM using the admin command.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_read_nvm_aq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|module_pointer
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|bool
name|last_command
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_ERR_NVM
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_read_nvm_aq"
argument_list|)
expr_stmt|;
comment|/* Here we are checking the SR limit only for the flat memory model. 	 * We cannot do it for the module-based model, as we did not acquire 	 * the NVM resource yet (we cannot get the module pointer value). 	 * Firmware will check the module-based model. 	 */
if|if
condition|(
operator|(
name|offset
operator|+
name|words
operator|)
operator|>
name|hw
operator|->
name|nvm
operator|.
name|sr_size
condition|)
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVM write error: offset %d beyond Shadow RAM limit %d\n"
argument_list|,
operator|(
name|offset
operator|+
name|words
operator|)
argument_list|,
name|hw
operator|->
name|nvm
operator|.
name|sr_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|words
operator|>
name|I40E_SR_SECTOR_SIZE_IN_WORDS
condition|)
comment|/* We can write only up to 4KB (one sector), in one AQ write */
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVM write fail error: tried to write %d words, limit is %d.\n"
argument_list|,
name|words
argument_list|,
name|I40E_SR_SECTOR_SIZE_IN_WORDS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|offset
operator|+
operator|(
name|words
operator|-
literal|1
operator|)
operator|)
operator|/
name|I40E_SR_SECTOR_SIZE_IN_WORDS
operator|)
operator|!=
operator|(
name|offset
operator|/
name|I40E_SR_SECTOR_SIZE_IN_WORDS
operator|)
condition|)
comment|/* A single write cannot spread over two sectors */
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVM write error: cannot spread over two sectors in a single write offset=%d words=%d\n"
argument_list|,
name|offset
argument_list|,
name|words
argument_list|)
expr_stmt|;
else|else
name|ret_code
operator|=
name|i40e_aq_read_nvm
argument_list|(
name|hw
argument_list|,
name|module_pointer
argument_list|,
literal|2
operator|*
name|offset
argument_list|,
comment|/*bytes*/
literal|2
operator|*
name|words
argument_list|,
comment|/*bytes*/
name|data
argument_list|,
name|last_command
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_write_nvm_aq - Writes Shadow RAM.  * @hw: pointer to the HW structure.  * @module_pointer: module pointer location in words from the NVM beginning  * @offset: offset in words from module start  * @words: number of words to write  * @data: buffer with words to write to the Shadow RAM  * @last_command: tells the AdminQ that this is the last command  *  * Writes a 16 bit words buffer to the Shadow RAM using the admin command.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_write_nvm_aq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|module_pointer
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|bool
name|last_command
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_ERR_NVM
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_write_nvm_aq"
argument_list|)
expr_stmt|;
comment|/* Here we are checking the SR limit only for the flat memory model. 	 * We cannot do it for the module-based model, as we did not acquire 	 * the NVM resource yet (we cannot get the module pointer value). 	 * Firmware will check the module-based model. 	 */
if|if
condition|(
operator|(
name|offset
operator|+
name|words
operator|)
operator|>
name|hw
operator|->
name|nvm
operator|.
name|sr_size
condition|)
name|DEBUGOUT
argument_list|(
literal|"NVM write error: offset beyond Shadow RAM limit.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|words
operator|>
name|I40E_SR_SECTOR_SIZE_IN_WORDS
condition|)
comment|/* We can write only up to 4KB (one sector), in one AQ write */
name|DEBUGOUT
argument_list|(
literal|"NVM write fail error: cannot write more than 4KB in a single write.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|offset
operator|+
operator|(
name|words
operator|-
literal|1
operator|)
operator|)
operator|/
name|I40E_SR_SECTOR_SIZE_IN_WORDS
operator|)
operator|!=
operator|(
name|offset
operator|/
name|I40E_SR_SECTOR_SIZE_IN_WORDS
operator|)
condition|)
comment|/* A single write cannot spread over two sectors */
name|DEBUGOUT
argument_list|(
literal|"NVM write error: cannot spread over two sectors in a single write.\n"
argument_list|)
expr_stmt|;
else|else
name|ret_code
operator|=
name|i40e_aq_update_nvm
argument_list|(
name|hw
argument_list|,
name|module_pointer
argument_list|,
literal|2
operator|*
name|offset
argument_list|,
comment|/*bytes*/
literal|2
operator|*
name|words
argument_list|,
comment|/*bytes*/
name|data
argument_list|,
name|last_command
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_write_nvm_word - Writes Shadow RAM word  * @hw: pointer to the HW structure  * @offset: offset of the Shadow RAM word to write  * @data: word to write to the Shadow RAM  *  * Writes a 16 bit word to the SR using the i40e_write_nvm_aq() method.  * NVM ownership have to be acquired and released (on ARQ completion event  * reception) by caller. To commit SR to NVM update checksum function  * should be called.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_write_nvm_word
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"i40e_write_nvm_word"
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|__le16
operator|*
operator|)
name|data
operator|)
operator|=
name|CPU_TO_LE16
argument_list|(
operator|*
operator|(
operator|(
name|u16
operator|*
operator|)
name|data
operator|)
argument_list|)
expr_stmt|;
comment|/* Value 0x00 below means that we treat SR as a flat mem */
return|return
name|i40e_write_nvm_aq
argument_list|(
name|hw
argument_list|,
literal|0x00
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|data
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_write_nvm_buffer - Writes Shadow RAM buffer  * @hw: pointer to the HW structure  * @module_pointer: module pointer location in words from the NVM beginning  * @offset: offset of the Shadow RAM buffer to write  * @words: number of words to write  * @data: words to write to the Shadow RAM  *  * Writes a 16 bit words buffer to the Shadow RAM using the admin command.  * NVM ownership must be acquired before calling this function and released  * on ARQ completion event reception by caller. To commit SR to NVM update  * checksum function should be called.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_write_nvm_buffer
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|module_pointer
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|__le16
modifier|*
name|le_word_ptr
init|=
operator|(
name|__le16
operator|*
operator|)
name|data
decl_stmt|;
name|u16
modifier|*
name|word_ptr
init|=
operator|(
name|u16
operator|*
operator|)
name|data
decl_stmt|;
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_write_nvm_buffer"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
name|le_word_ptr
index|[
name|i
index|]
operator|=
name|CPU_TO_LE16
argument_list|(
name|word_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Here we will only write one buffer as the size of the modules 	 * mirrored in the Shadow RAM is always less than 4K. 	 */
return|return
name|i40e_write_nvm_aq
argument_list|(
name|hw
argument_list|,
name|module_pointer
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_calc_nvm_checksum - Calculates and returns the checksum  * @hw: pointer to hardware structure  * @checksum: pointer to the checksum  *  * This function calculates SW Checksum that covers the whole 64kB shadow RAM  * except the VPD and PCIe ALT Auto-load modules. The structure and size of VPD  * is customer specific and unknown. Therefore, this function skips all maximum  * possible size of VPD (1kB).  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_calc_nvm_checksum
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|checksum
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|struct
name|i40e_virt_mem
name|vmem
decl_stmt|;
name|u16
name|pcie_alt_module
init|=
literal|0
decl_stmt|;
name|u16
name|checksum_local
init|=
literal|0
decl_stmt|;
name|u16
name|vpd_module
init|=
literal|0
decl_stmt|;
name|u16
modifier|*
name|data
decl_stmt|;
name|u16
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_calc_nvm_checksum"
argument_list|)
expr_stmt|;
name|ret_code
operator|=
name|i40e_allocate_virt_mem
argument_list|(
name|hw
argument_list|,
operator|&
name|vmem
argument_list|,
name|I40E_SR_SECTOR_SIZE_IN_WORDS
operator|*
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
condition|)
goto|goto
name|i40e_calc_nvm_checksum_exit
goto|;
name|data
operator|=
operator|(
name|u16
operator|*
operator|)
name|vmem
operator|.
name|va
expr_stmt|;
comment|/* read pointer to VPD area */
name|ret_code
operator|=
name|i40e_read_nvm_word
argument_list|(
name|hw
argument_list|,
name|I40E_SR_VPD_PTR
argument_list|,
operator|&
name|vpd_module
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|!=
name|I40E_SUCCESS
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_NVM_CHECKSUM
expr_stmt|;
goto|goto
name|i40e_calc_nvm_checksum_exit
goto|;
block|}
comment|/* read pointer to PCIe Alt Auto-load module */
name|ret_code
operator|=
name|i40e_read_nvm_word
argument_list|(
name|hw
argument_list|,
name|I40E_SR_PCIE_ALT_AUTO_LOAD_PTR
argument_list|,
operator|&
name|pcie_alt_module
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|!=
name|I40E_SUCCESS
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_NVM_CHECKSUM
expr_stmt|;
goto|goto
name|i40e_calc_nvm_checksum_exit
goto|;
block|}
comment|/* Calculate SW checksum that covers the whole 64kB shadow RAM 	 * except the VPD and PCIe ALT Auto-load modules 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|nvm
operator|.
name|sr_size
condition|;
name|i
operator|++
control|)
block|{
comment|/* Read SR page */
if|if
condition|(
operator|(
name|i
operator|%
name|I40E_SR_SECTOR_SIZE_IN_WORDS
operator|)
operator|==
literal|0
condition|)
block|{
name|u16
name|words
init|=
name|I40E_SR_SECTOR_SIZE_IN_WORDS
decl_stmt|;
name|ret_code
operator|=
name|i40e_read_nvm_buffer
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
operator|&
name|words
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|!=
name|I40E_SUCCESS
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_NVM_CHECKSUM
expr_stmt|;
goto|goto
name|i40e_calc_nvm_checksum_exit
goto|;
block|}
block|}
comment|/* Skip Checksum word */
if|if
condition|(
name|i
operator|==
name|I40E_SR_SW_CHECKSUM_WORD
condition|)
continue|continue;
comment|/* Skip VPD module (convert byte size to word count) */
if|if
condition|(
operator|(
name|i
operator|>=
operator|(
name|u32
operator|)
name|vpd_module
operator|)
operator|&&
operator|(
name|i
operator|<
operator|(
operator|(
name|u32
operator|)
name|vpd_module
operator|+
operator|(
name|I40E_SR_VPD_MODULE_MAX_SIZE
operator|/
literal|2
operator|)
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* Skip PCIe ALT module (convert byte size to word count) */
if|if
condition|(
operator|(
name|i
operator|>=
operator|(
name|u32
operator|)
name|pcie_alt_module
operator|)
operator|&&
operator|(
name|i
operator|<
operator|(
operator|(
name|u32
operator|)
name|pcie_alt_module
operator|+
operator|(
name|I40E_SR_PCIE_ALT_MODULE_MAX_SIZE
operator|/
literal|2
operator|)
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
name|checksum_local
operator|+=
name|data
index|[
name|i
operator|%
name|I40E_SR_SECTOR_SIZE_IN_WORDS
index|]
expr_stmt|;
block|}
operator|*
name|checksum
operator|=
operator|(
name|u16
operator|)
name|I40E_SR_SW_CHECKSUM_BASE
operator|-
name|checksum_local
expr_stmt|;
name|i40e_calc_nvm_checksum_exit
label|:
name|i40e_free_virt_mem
argument_list|(
name|hw
argument_list|,
operator|&
name|vmem
argument_list|)
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_update_nvm_checksum - Updates the NVM checksum  * @hw: pointer to hardware structure  *  * NVM ownership must be acquired before calling this function and released  * on ARQ completion event reception by caller.  * This function will commit SR to NVM.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_update_nvm_checksum
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|u16
name|checksum
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_update_nvm_checksum"
argument_list|)
expr_stmt|;
name|ret_code
operator|=
name|i40e_calc_nvm_checksum
argument_list|(
name|hw
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|==
name|I40E_SUCCESS
condition|)
name|ret_code
operator|=
name|i40e_write_nvm_aq
argument_list|(
name|hw
argument_list|,
literal|0x00
argument_list|,
name|I40E_SR_SW_CHECKSUM_WORD
argument_list|,
literal|1
argument_list|,
operator|&
name|checksum
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_validate_nvm_checksum - Validate EEPROM checksum  * @hw: pointer to hardware structure  * @checksum: calculated checksum  *  * Performs checksum calculation and validates the NVM SW checksum. If the  * caller does not need checksum, the value can be NULL.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_validate_nvm_checksum
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|checksum
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|u16
name|checksum_sr
init|=
literal|0
decl_stmt|;
name|u16
name|checksum_local
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_validate_nvm_checksum"
argument_list|)
expr_stmt|;
name|ret_code
operator|=
name|i40e_calc_nvm_checksum
argument_list|(
name|hw
argument_list|,
operator|&
name|checksum_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|!=
name|I40E_SUCCESS
condition|)
goto|goto
name|i40e_validate_nvm_checksum_exit
goto|;
comment|/* Do not use i40e_read_nvm_word() because we do not want to take 	 * the synchronization semaphores twice here. 	 */
name|i40e_read_nvm_word
argument_list|(
name|hw
argument_list|,
name|I40E_SR_SW_CHECKSUM_WORD
argument_list|,
operator|&
name|checksum_sr
argument_list|)
expr_stmt|;
comment|/* Verify read checksum from EEPROM is the same as 	 * calculated checksum 	 */
if|if
condition|(
name|checksum_local
operator|!=
name|checksum_sr
condition|)
name|ret_code
operator|=
name|I40E_ERR_NVM_CHECKSUM
expr_stmt|;
comment|/* If the user cares, return the calculated checksum */
if|if
condition|(
name|checksum
condition|)
operator|*
name|checksum
operator|=
name|checksum_local
expr_stmt|;
name|i40e_validate_nvm_checksum_exit
label|:
return|return
name|ret_code
return|;
block|}
end_function

end_unit

