begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2013-2015, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"i40e_prototype.h"
end_include

begin_function_decl
name|enum
name|i40e_status_code
name|i40e_read_nvm_word_srctl
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|i40e_status_code
name|i40e_read_nvm_word_aq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|i40e_status_code
name|i40e_read_nvm_buffer_srctl
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|i40e_status_code
name|i40e_read_nvm_buffer_aq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|i40e_status_code
name|i40e_read_nvm_aq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|module_pointer
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|bool
name|last_command
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * i40e_init_nvm_ops - Initialize NVM function pointers  * @hw: pointer to the HW structure  *  * Setup the function pointers and the NVM info structure. Should be called  * once per NVM initialization, e.g. inside the i40e_init_shared_code().  * Please notice that the NVM term is used here (& in all methods covered  * in this file) as an equivalent of the FLASH part mapped into the SR.  * We are accessing FLASH always through the Shadow RAM.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_init_nvm
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|i40e_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|u32
name|fla
decl_stmt|,
name|gens
decl_stmt|;
name|u8
name|sr_size
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_init_nvm"
argument_list|)
expr_stmt|;
comment|/* The SR size is stored regardless of the nvm programming mode 	 * as the blank mode may be used in the factory line. 	 */
name|gens
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLNVM_GENS
argument_list|)
expr_stmt|;
name|sr_size
operator|=
operator|(
operator|(
name|gens
operator|&
name|I40E_GLNVM_GENS_SR_SIZE_MASK
operator|)
operator|>>
name|I40E_GLNVM_GENS_SR_SIZE_SHIFT
operator|)
expr_stmt|;
comment|/* Switching to words (sr_size contains power of 2KB) */
name|nvm
operator|->
name|sr_size
operator|=
name|BIT
argument_list|(
name|sr_size
argument_list|)
operator|*
name|I40E_SR_WORDS_IN_1KB
expr_stmt|;
comment|/* Check if we are in the normal or blank NVM programming mode */
name|fla
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLNVM_FLA
argument_list|)
expr_stmt|;
if|if
condition|(
name|fla
operator|&
name|I40E_GLNVM_FLA_LOCKED_MASK
condition|)
block|{
comment|/* Normal programming mode */
comment|/* Max NVM timeout */
name|nvm
operator|->
name|timeout
operator|=
name|I40E_MAX_NVM_TIMEOUT
expr_stmt|;
name|nvm
operator|->
name|blank_nvm_mode
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* Blank programming mode */
name|nvm
operator|->
name|blank_nvm_mode
operator|=
name|TRUE
expr_stmt|;
name|ret_code
operator|=
name|I40E_ERR_NVM_BLANK_MODE
expr_stmt|;
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVM init error: unsupported blank mode.\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_acquire_nvm - Generic request for acquiring the NVM ownership  * @hw: pointer to the HW structure  * @access: NVM access type (read or write)  *  * This function will request NVM ownership for reading  * via the proper Admin Command.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_acquire_nvm
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|enum
name|i40e_aq_resource_access_type
name|access
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|u64
name|gtime
decl_stmt|,
name|timeout
decl_stmt|;
name|u64
name|time_left
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_acquire_nvm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|nvm
operator|.
name|blank_nvm_mode
condition|)
goto|goto
name|i40e_i40e_acquire_nvm_exit
goto|;
name|ret_code
operator|=
name|i40e_aq_request_resource
argument_list|(
name|hw
argument_list|,
name|I40E_NVM_RESOURCE_ID
argument_list|,
name|access
argument_list|,
literal|0
argument_list|,
operator|&
name|time_left
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Reading the Global Device Timer */
name|gtime
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLVFGEN_TIMER
argument_list|)
expr_stmt|;
comment|/* Store the timeout */
name|hw
operator|->
name|nvm
operator|.
name|hw_semaphore_timeout
operator|=
name|I40E_MS_TO_GTIME
argument_list|(
name|time_left
argument_list|)
operator|+
name|gtime
expr_stmt|;
if|if
condition|(
name|ret_code
condition|)
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVM acquire type %d failed time_left=%llu ret=%d aq_err=%d\n"
argument_list|,
name|access
argument_list|,
name|time_left
argument_list|,
name|ret_code
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|&&
name|time_left
condition|)
block|{
comment|/* Poll until the current NVM owner timeouts */
name|timeout
operator|=
name|I40E_MS_TO_GTIME
argument_list|(
name|I40E_MAX_NVM_TIMEOUT
argument_list|)
operator|+
name|gtime
expr_stmt|;
while|while
condition|(
operator|(
name|gtime
operator|<
name|timeout
operator|)
operator|&&
name|time_left
condition|)
block|{
name|i40e_msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|gtime
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLVFGEN_TIMER
argument_list|)
expr_stmt|;
name|ret_code
operator|=
name|i40e_aq_request_resource
argument_list|(
name|hw
argument_list|,
name|I40E_NVM_RESOURCE_ID
argument_list|,
name|access
argument_list|,
literal|0
argument_list|,
operator|&
name|time_left
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|==
name|I40E_SUCCESS
condition|)
block|{
name|hw
operator|->
name|nvm
operator|.
name|hw_semaphore_timeout
operator|=
name|I40E_MS_TO_GTIME
argument_list|(
name|time_left
argument_list|)
operator|+
name|gtime
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ret_code
operator|!=
name|I40E_SUCCESS
condition|)
block|{
name|hw
operator|->
name|nvm
operator|.
name|hw_semaphore_timeout
operator|=
literal|0
expr_stmt|;
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVM acquire timed out, wait %llu ms before trying again. status=%d aq_err=%d\n"
argument_list|,
name|time_left
argument_list|,
name|ret_code
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
block|}
block|}
name|i40e_i40e_acquire_nvm_exit
label|:
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_release_nvm - Generic request for releasing the NVM ownership  * @hw: pointer to the HW structure  *  * This function will release NVM resource via the proper Admin Command.  **/
end_comment

begin_function
name|void
name|i40e_release_nvm
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|u32
name|total_delay
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_release_nvm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|nvm
operator|.
name|blank_nvm_mode
condition|)
return|return;
name|ret_code
operator|=
name|i40e_aq_release_resource
argument_list|(
name|hw
argument_list|,
name|I40E_NVM_RESOURCE_ID
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* there are some rare cases when trying to release the resource 	 * results in an admin Q timeout, so handle them correctly 	 */
while|while
condition|(
operator|(
name|ret_code
operator|==
name|I40E_ERR_ADMIN_QUEUE_TIMEOUT
operator|)
operator|&&
operator|(
name|total_delay
operator|<
name|hw
operator|->
name|aq
operator|.
name|asq_cmd_timeout
operator|)
condition|)
block|{
name|i40e_msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ret_code
operator|=
name|i40e_aq_release_resource
argument_list|(
name|hw
argument_list|,
name|I40E_NVM_RESOURCE_ID
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|total_delay
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * i40e_poll_sr_srctl_done_bit - Polls the GLNVM_SRCTL done bit  * @hw: pointer to the HW structure  *  * Polls the SRCTL Shadow RAM register done bit.  **/
end_comment

begin_function
specifier|static
name|enum
name|i40e_status_code
name|i40e_poll_sr_srctl_done_bit
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_ERR_TIMEOUT
decl_stmt|;
name|u32
name|srctl
decl_stmt|,
name|wait_cnt
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_poll_sr_srctl_done_bit"
argument_list|)
expr_stmt|;
comment|/* Poll the I40E_GLNVM_SRCTL until the done bit is set */
for|for
control|(
name|wait_cnt
operator|=
literal|0
init|;
name|wait_cnt
operator|<
name|I40E_SRRD_SRCTL_ATTEMPTS
condition|;
name|wait_cnt
operator|++
control|)
block|{
name|srctl
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLNVM_SRCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|srctl
operator|&
name|I40E_GLNVM_SRCTL_DONE_MASK
condition|)
block|{
name|ret_code
operator|=
name|I40E_SUCCESS
expr_stmt|;
break|break;
block|}
name|i40e_usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret_code
operator|==
name|I40E_ERR_TIMEOUT
condition|)
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"Done bit in GLNVM_SRCTL not set"
argument_list|)
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_read_nvm_word - Reads nvm word and acquire lock if necessary  * @hw: pointer to the HW structure  * @offset: offset of the Shadow RAM word to read (0x000000 - 0x001FFF)  * @data: word read from the Shadow RAM  *  * Reads one 16 bit word from the Shadow RAM using the GLNVM_SRCTL register.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_read_nvm_word
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|ret_code
operator|=
name|i40e_acquire_nvm
argument_list|(
name|hw
argument_list|,
name|I40E_RESOURCE_READ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_code
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|flags
operator|&
name|I40E_HW_FLAG_AQ_SRCTL_ACCESS_ENABLE
condition|)
block|{
name|ret_code
operator|=
name|i40e_read_nvm_word_aq
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret_code
operator|=
name|i40e_read_nvm_word_srctl
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|i40e_release_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * __i40e_read_nvm_word - Reads nvm word, assumes caller does the locking  * @hw: pointer to the HW structure  * @offset: offset of the Shadow RAM word to read (0x000000 - 0x001FFF)  * @data: word read from the Shadow RAM  *  * Reads one 16 bit word from the Shadow RAM using the GLNVM_SRCTL register.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|__i40e_read_nvm_word
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|flags
operator|&
name|I40E_HW_FLAG_AQ_SRCTL_ACCESS_ENABLE
condition|)
name|ret_code
operator|=
name|i40e_read_nvm_word_aq
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|ret_code
operator|=
name|i40e_read_nvm_word_srctl
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_read_nvm_word_srctl - Reads Shadow RAM via SRCTL register  * @hw: pointer to the HW structure  * @offset: offset of the Shadow RAM word to read (0x000000 - 0x001FFF)  * @data: word read from the Shadow RAM  *  * Reads one 16 bit word from the Shadow RAM using the GLNVM_SRCTL register.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_read_nvm_word_srctl
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_ERR_TIMEOUT
decl_stmt|;
name|u32
name|sr_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_read_nvm_word_srctl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|hw
operator|->
name|nvm
operator|.
name|sr_size
condition|)
block|{
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVM read error: Offset %d beyond Shadow RAM limit %d\n"
argument_list|,
name|offset
argument_list|,
name|hw
operator|->
name|nvm
operator|.
name|sr_size
argument_list|)
expr_stmt|;
name|ret_code
operator|=
name|I40E_ERR_PARAM
expr_stmt|;
goto|goto
name|read_nvm_exit
goto|;
block|}
comment|/* Poll the done bit first */
name|ret_code
operator|=
name|i40e_poll_sr_srctl_done_bit
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|==
name|I40E_SUCCESS
condition|)
block|{
comment|/* Write the address and start reading */
name|sr_reg
operator|=
operator|(
operator|(
name|u32
operator|)
name|offset
operator|<<
name|I40E_GLNVM_SRCTL_ADDR_SHIFT
operator|)
operator||
name|BIT
argument_list|(
name|I40E_GLNVM_SRCTL_START_SHIFT
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_GLNVM_SRCTL
argument_list|,
name|sr_reg
argument_list|)
expr_stmt|;
comment|/* Poll I40E_GLNVM_SRCTL until the done bit is set */
name|ret_code
operator|=
name|i40e_poll_sr_srctl_done_bit
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|==
name|I40E_SUCCESS
condition|)
block|{
name|sr_reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLNVM_SRDATA
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
call|(
name|u16
call|)
argument_list|(
operator|(
name|sr_reg
operator|&
name|I40E_GLNVM_SRDATA_RDDATA_MASK
operator|)
operator|>>
name|I40E_GLNVM_SRDATA_RDDATA_SHIFT
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret_code
operator|!=
name|I40E_SUCCESS
condition|)
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVM read error: Couldn't access Shadow RAM address: 0x%x\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|read_nvm_exit
label|:
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_read_nvm_word_aq - Reads Shadow RAM via AQ  * @hw: pointer to the HW structure  * @offset: offset of the Shadow RAM word to read (0x000000 - 0x001FFF)  * @data: word read from the Shadow RAM  *  * Reads one 16 bit word from the Shadow RAM using the GLNVM_SRCTL register.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_read_nvm_word_aq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_ERR_TIMEOUT
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_read_nvm_word_aq"
argument_list|)
expr_stmt|;
name|ret_code
operator|=
name|i40e_read_nvm_aq
argument_list|(
name|hw
argument_list|,
literal|0x0
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|LE16_TO_CPU
argument_list|(
operator|*
operator|(
name|__le16
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * __i40e_read_nvm_buffer - Reads nvm buffer, caller must acquire lock  * @hw: pointer to the HW structure  * @offset: offset of the Shadow RAM word to read (0x000000 - 0x001FFF).  * @words: (in) number of words to read; (out) number of words actually read  * @data: words read from the Shadow RAM  *  * Reads 16 bit words (data buffer) from the SR using the i40e_read_nvm_srrd()  * method. The buffer read is preceded by the NVM ownership take  * and followed by the release.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|__i40e_read_nvm_buffer
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|flags
operator|&
name|I40E_HW_FLAG_AQ_SRCTL_ACCESS_ENABLE
condition|)
name|ret_code
operator|=
name|i40e_read_nvm_buffer_aq
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|ret_code
operator|=
name|i40e_read_nvm_buffer_srctl
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_read_nvm_buffer - Reads Shadow RAM buffer and acuire lock if necessary  * @hw: pointer to the HW structure  * @offset: offset of the Shadow RAM word to read (0x000000 - 0x001FFF).  * @words: (in) number of words to read; (out) number of words actually read  * @data: words read from the Shadow RAM  *  * Reads 16 bit words (data buffer) from the SR using the i40e_read_nvm_srrd()  * method. The buffer read is preceded by the NVM ownership take  * and followed by the release.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_read_nvm_buffer
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|flags
operator|&
name|I40E_HW_FLAG_AQ_SRCTL_ACCESS_ENABLE
condition|)
block|{
name|ret_code
operator|=
name|i40e_acquire_nvm
argument_list|(
name|hw
argument_list|,
name|I40E_RESOURCE_READ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_code
condition|)
block|{
name|ret_code
operator|=
name|i40e_read_nvm_buffer_aq
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|i40e_release_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret_code
operator|=
name|i40e_read_nvm_buffer_srctl
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_read_nvm_buffer_srctl - Reads Shadow RAM buffer via SRCTL register  * @hw: pointer to the HW structure  * @offset: offset of the Shadow RAM word to read (0x000000 - 0x001FFF).  * @words: (in) number of words to read; (out) number of words actually read  * @data: words read from the Shadow RAM  *  * Reads 16 bit words (data buffer) from the SR using the i40e_read_nvm_srrd()  * method. The buffer read is preceded by the NVM ownership take  * and followed by the release.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_read_nvm_buffer_srctl
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|u16
name|index
decl_stmt|,
name|word
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_read_nvm_buffer_srctl"
argument_list|)
expr_stmt|;
comment|/* Loop through the selected region */
for|for
control|(
name|word
operator|=
literal|0
init|;
name|word
operator|<
operator|*
name|words
condition|;
name|word
operator|++
control|)
block|{
name|index
operator|=
name|offset
operator|+
name|word
expr_stmt|;
name|ret_code
operator|=
name|i40e_read_nvm_word_srctl
argument_list|(
name|hw
argument_list|,
name|index
argument_list|,
operator|&
name|data
index|[
name|word
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|!=
name|I40E_SUCCESS
condition|)
break|break;
block|}
comment|/* Update the number of words read from the Shadow RAM */
operator|*
name|words
operator|=
name|word
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_read_nvm_buffer_aq - Reads Shadow RAM buffer via AQ  * @hw: pointer to the HW structure  * @offset: offset of the Shadow RAM word to read (0x000000 - 0x001FFF).  * @words: (in) number of words to read; (out) number of words actually read  * @data: words read from the Shadow RAM  *  * Reads 16 bit words (data buffer) from the SR using the i40e_read_nvm_aq()  * method. The buffer read is preceded by the NVM ownership take  * and followed by the release.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_read_nvm_buffer_aq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
decl_stmt|;
name|u16
name|read_size
init|=
operator|*
name|words
decl_stmt|;
name|bool
name|last_cmd
init|=
name|FALSE
decl_stmt|;
name|u16
name|words_read
init|=
literal|0
decl_stmt|;
name|u16
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_read_nvm_buffer_aq"
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* Calculate number of bytes we should read in this step. 		 * FVL AQ do not allow to read more than one page at a time or 		 * to cross page boundaries. 		 */
if|if
condition|(
name|offset
operator|%
name|I40E_SR_SECTOR_SIZE_IN_WORDS
condition|)
name|read_size
operator|=
name|min
argument_list|(
operator|*
name|words
argument_list|,
call|(
name|u16
call|)
argument_list|(
name|I40E_SR_SECTOR_SIZE_IN_WORDS
operator|-
operator|(
name|offset
operator|%
name|I40E_SR_SECTOR_SIZE_IN_WORDS
operator|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|read_size
operator|=
name|min
argument_list|(
operator|(
operator|*
name|words
operator|-
name|words_read
operator|)
argument_list|,
name|I40E_SR_SECTOR_SIZE_IN_WORDS
argument_list|)
expr_stmt|;
comment|/* Check if this is last command, if so set proper flag */
if|if
condition|(
operator|(
name|words_read
operator|+
name|read_size
operator|)
operator|>=
operator|*
name|words
condition|)
name|last_cmd
operator|=
name|TRUE
expr_stmt|;
name|ret_code
operator|=
name|i40e_read_nvm_aq
argument_list|(
name|hw
argument_list|,
literal|0x0
argument_list|,
name|offset
argument_list|,
name|read_size
argument_list|,
name|data
operator|+
name|words_read
argument_list|,
name|last_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|!=
name|I40E_SUCCESS
condition|)
goto|goto
name|read_nvm_buffer_aq_exit
goto|;
comment|/* Increment counter for words already read and move offset to 		 * new read location 		 */
name|words_read
operator|+=
name|read_size
expr_stmt|;
name|offset
operator|+=
name|read_size
expr_stmt|;
block|}
do|while
condition|(
name|words_read
operator|<
operator|*
name|words
condition|)
do|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|words
condition|;
name|i
operator|++
control|)
name|data
index|[
name|i
index|]
operator|=
name|LE16_TO_CPU
argument_list|(
operator|(
operator|(
name|__le16
operator|*
operator|)
name|data
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|read_nvm_buffer_aq_exit
label|:
operator|*
name|words
operator|=
name|words_read
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_read_nvm_aq - Read Shadow RAM.  * @hw: pointer to the HW structure.  * @module_pointer: module pointer location in words from the NVM beginning  * @offset: offset in words from module start  * @words: number of words to write  * @data: buffer with words to write to the Shadow RAM  * @last_command: tells the AdminQ that this is the last command  *  * Writes a 16 bit words buffer to the Shadow RAM using the admin command.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_read_nvm_aq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|module_pointer
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|bool
name|last_command
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_ERR_NVM
decl_stmt|;
name|struct
name|i40e_asq_cmd_details
name|cmd_details
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_read_nvm_aq"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd_details
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd_details
argument_list|)
argument_list|)
expr_stmt|;
name|cmd_details
operator|.
name|wb_desc
operator|=
operator|&
name|hw
operator|->
name|nvm_wb_desc
expr_stmt|;
comment|/* Here we are checking the SR limit only for the flat memory model. 	 * We cannot do it for the module-based model, as we did not acquire 	 * the NVM resource yet (we cannot get the module pointer value). 	 * Firmware will check the module-based model. 	 */
if|if
condition|(
operator|(
name|offset
operator|+
name|words
operator|)
operator|>
name|hw
operator|->
name|nvm
operator|.
name|sr_size
condition|)
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVM write error: offset %d beyond Shadow RAM limit %d\n"
argument_list|,
operator|(
name|offset
operator|+
name|words
operator|)
argument_list|,
name|hw
operator|->
name|nvm
operator|.
name|sr_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|words
operator|>
name|I40E_SR_SECTOR_SIZE_IN_WORDS
condition|)
comment|/* We can write only up to 4KB (one sector), in one AQ write */
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVM write fail error: tried to write %d words, limit is %d.\n"
argument_list|,
name|words
argument_list|,
name|I40E_SR_SECTOR_SIZE_IN_WORDS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|offset
operator|+
operator|(
name|words
operator|-
literal|1
operator|)
operator|)
operator|/
name|I40E_SR_SECTOR_SIZE_IN_WORDS
operator|)
operator|!=
operator|(
name|offset
operator|/
name|I40E_SR_SECTOR_SIZE_IN_WORDS
operator|)
condition|)
comment|/* A single write cannot spread over two sectors */
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVM write error: cannot spread over two sectors in a single write offset=%d words=%d\n"
argument_list|,
name|offset
argument_list|,
name|words
argument_list|)
expr_stmt|;
else|else
name|ret_code
operator|=
name|i40e_aq_read_nvm
argument_list|(
name|hw
argument_list|,
name|module_pointer
argument_list|,
literal|2
operator|*
name|offset
argument_list|,
comment|/*bytes*/
literal|2
operator|*
name|words
argument_list|,
comment|/*bytes*/
name|data
argument_list|,
name|last_command
argument_list|,
operator|&
name|cmd_details
argument_list|)
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_write_nvm_aq - Writes Shadow RAM.  * @hw: pointer to the HW structure.  * @module_pointer: module pointer location in words from the NVM beginning  * @offset: offset in words from module start  * @words: number of words to write  * @data: buffer with words to write to the Shadow RAM  * @last_command: tells the AdminQ that this is the last command  *  * Writes a 16 bit words buffer to the Shadow RAM using the admin command.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_write_nvm_aq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|module_pointer
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|bool
name|last_command
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_ERR_NVM
decl_stmt|;
name|struct
name|i40e_asq_cmd_details
name|cmd_details
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_write_nvm_aq"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd_details
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd_details
argument_list|)
argument_list|)
expr_stmt|;
name|cmd_details
operator|.
name|wb_desc
operator|=
operator|&
name|hw
operator|->
name|nvm_wb_desc
expr_stmt|;
comment|/* Here we are checking the SR limit only for the flat memory model. 	 * We cannot do it for the module-based model, as we did not acquire 	 * the NVM resource yet (we cannot get the module pointer value). 	 * Firmware will check the module-based model. 	 */
if|if
condition|(
operator|(
name|offset
operator|+
name|words
operator|)
operator|>
name|hw
operator|->
name|nvm
operator|.
name|sr_size
condition|)
name|DEBUGOUT
argument_list|(
literal|"NVM write error: offset beyond Shadow RAM limit.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|words
operator|>
name|I40E_SR_SECTOR_SIZE_IN_WORDS
condition|)
comment|/* We can write only up to 4KB (one sector), in one AQ write */
name|DEBUGOUT
argument_list|(
literal|"NVM write fail error: cannot write more than 4KB in a single write.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|offset
operator|+
operator|(
name|words
operator|-
literal|1
operator|)
operator|)
operator|/
name|I40E_SR_SECTOR_SIZE_IN_WORDS
operator|)
operator|!=
operator|(
name|offset
operator|/
name|I40E_SR_SECTOR_SIZE_IN_WORDS
operator|)
condition|)
comment|/* A single write cannot spread over two sectors */
name|DEBUGOUT
argument_list|(
literal|"NVM write error: cannot spread over two sectors in a single write.\n"
argument_list|)
expr_stmt|;
else|else
name|ret_code
operator|=
name|i40e_aq_update_nvm
argument_list|(
name|hw
argument_list|,
name|module_pointer
argument_list|,
literal|2
operator|*
name|offset
argument_list|,
comment|/*bytes*/
literal|2
operator|*
name|words
argument_list|,
comment|/*bytes*/
name|data
argument_list|,
name|last_command
argument_list|,
operator|&
name|cmd_details
argument_list|)
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * __i40e_write_nvm_word - Writes Shadow RAM word  * @hw: pointer to the HW structure  * @offset: offset of the Shadow RAM word to write  * @data: word to write to the Shadow RAM  *  * Writes a 16 bit word to the SR using the i40e_write_nvm_aq() method.  * NVM ownership have to be acquired and released (on ARQ completion event  * reception) by caller. To commit SR to NVM update checksum function  * should be called.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|__i40e_write_nvm_word
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"i40e_write_nvm_word"
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|__le16
operator|*
operator|)
name|data
operator|)
operator|=
name|CPU_TO_LE16
argument_list|(
operator|*
operator|(
operator|(
name|u16
operator|*
operator|)
name|data
operator|)
argument_list|)
expr_stmt|;
comment|/* Value 0x00 below means that we treat SR as a flat mem */
return|return
name|i40e_write_nvm_aq
argument_list|(
name|hw
argument_list|,
literal|0x00
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|data
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * __i40e_write_nvm_buffer - Writes Shadow RAM buffer  * @hw: pointer to the HW structure  * @module_pointer: module pointer location in words from the NVM beginning  * @offset: offset of the Shadow RAM buffer to write  * @words: number of words to write  * @data: words to write to the Shadow RAM  *  * Writes a 16 bit words buffer to the Shadow RAM using the admin command.  * NVM ownership must be acquired before calling this function and released  * on ARQ completion event reception by caller. To commit SR to NVM update  * checksum function should be called.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|__i40e_write_nvm_buffer
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|module_pointer
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|__le16
modifier|*
name|le_word_ptr
init|=
operator|(
name|__le16
operator|*
operator|)
name|data
decl_stmt|;
name|u16
modifier|*
name|word_ptr
init|=
operator|(
name|u16
operator|*
operator|)
name|data
decl_stmt|;
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_write_nvm_buffer"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
name|le_word_ptr
index|[
name|i
index|]
operator|=
name|CPU_TO_LE16
argument_list|(
name|word_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Here we will only write one buffer as the size of the modules 	 * mirrored in the Shadow RAM is always less than 4K. 	 */
return|return
name|i40e_write_nvm_aq
argument_list|(
name|hw
argument_list|,
name|module_pointer
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_calc_nvm_checksum - Calculates and returns the checksum  * @hw: pointer to hardware structure  * @checksum: pointer to the checksum  *  * This function calculates SW Checksum that covers the whole 64kB shadow RAM  * except the VPD and PCIe ALT Auto-load modules. The structure and size of VPD  * is customer specific and unknown. Therefore, this function skips all maximum  * possible size of VPD (1kB).  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_calc_nvm_checksum
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|checksum
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|struct
name|i40e_virt_mem
name|vmem
decl_stmt|;
name|u16
name|pcie_alt_module
init|=
literal|0
decl_stmt|;
name|u16
name|checksum_local
init|=
literal|0
decl_stmt|;
name|u16
name|vpd_module
init|=
literal|0
decl_stmt|;
name|u16
modifier|*
name|data
decl_stmt|;
name|u16
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_calc_nvm_checksum"
argument_list|)
expr_stmt|;
name|ret_code
operator|=
name|i40e_allocate_virt_mem
argument_list|(
name|hw
argument_list|,
operator|&
name|vmem
argument_list|,
name|I40E_SR_SECTOR_SIZE_IN_WORDS
operator|*
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
condition|)
goto|goto
name|i40e_calc_nvm_checksum_exit
goto|;
name|data
operator|=
operator|(
name|u16
operator|*
operator|)
name|vmem
operator|.
name|va
expr_stmt|;
comment|/* read pointer to VPD area */
name|ret_code
operator|=
name|__i40e_read_nvm_word
argument_list|(
name|hw
argument_list|,
name|I40E_SR_VPD_PTR
argument_list|,
operator|&
name|vpd_module
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|!=
name|I40E_SUCCESS
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_NVM_CHECKSUM
expr_stmt|;
goto|goto
name|i40e_calc_nvm_checksum_exit
goto|;
block|}
comment|/* read pointer to PCIe Alt Auto-load module */
name|ret_code
operator|=
name|__i40e_read_nvm_word
argument_list|(
name|hw
argument_list|,
name|I40E_SR_PCIE_ALT_AUTO_LOAD_PTR
argument_list|,
operator|&
name|pcie_alt_module
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|!=
name|I40E_SUCCESS
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_NVM_CHECKSUM
expr_stmt|;
goto|goto
name|i40e_calc_nvm_checksum_exit
goto|;
block|}
comment|/* Calculate SW checksum that covers the whole 64kB shadow RAM 	 * except the VPD and PCIe ALT Auto-load modules 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|nvm
operator|.
name|sr_size
condition|;
name|i
operator|++
control|)
block|{
comment|/* Read SR page */
if|if
condition|(
operator|(
name|i
operator|%
name|I40E_SR_SECTOR_SIZE_IN_WORDS
operator|)
operator|==
literal|0
condition|)
block|{
name|u16
name|words
init|=
name|I40E_SR_SECTOR_SIZE_IN_WORDS
decl_stmt|;
name|ret_code
operator|=
name|__i40e_read_nvm_buffer
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
operator|&
name|words
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|!=
name|I40E_SUCCESS
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_NVM_CHECKSUM
expr_stmt|;
goto|goto
name|i40e_calc_nvm_checksum_exit
goto|;
block|}
block|}
comment|/* Skip Checksum word */
if|if
condition|(
name|i
operator|==
name|I40E_SR_SW_CHECKSUM_WORD
condition|)
continue|continue;
comment|/* Skip VPD module (convert byte size to word count) */
if|if
condition|(
operator|(
name|i
operator|>=
operator|(
name|u32
operator|)
name|vpd_module
operator|)
operator|&&
operator|(
name|i
operator|<
operator|(
operator|(
name|u32
operator|)
name|vpd_module
operator|+
operator|(
name|I40E_SR_VPD_MODULE_MAX_SIZE
operator|/
literal|2
operator|)
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* Skip PCIe ALT module (convert byte size to word count) */
if|if
condition|(
operator|(
name|i
operator|>=
operator|(
name|u32
operator|)
name|pcie_alt_module
operator|)
operator|&&
operator|(
name|i
operator|<
operator|(
operator|(
name|u32
operator|)
name|pcie_alt_module
operator|+
operator|(
name|I40E_SR_PCIE_ALT_MODULE_MAX_SIZE
operator|/
literal|2
operator|)
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
name|checksum_local
operator|+=
name|data
index|[
name|i
operator|%
name|I40E_SR_SECTOR_SIZE_IN_WORDS
index|]
expr_stmt|;
block|}
operator|*
name|checksum
operator|=
operator|(
name|u16
operator|)
name|I40E_SR_SW_CHECKSUM_BASE
operator|-
name|checksum_local
expr_stmt|;
name|i40e_calc_nvm_checksum_exit
label|:
name|i40e_free_virt_mem
argument_list|(
name|hw
argument_list|,
operator|&
name|vmem
argument_list|)
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_update_nvm_checksum - Updates the NVM checksum  * @hw: pointer to hardware structure  *  * NVM ownership must be acquired before calling this function and released  * on ARQ completion event reception by caller.  * This function will commit SR to NVM.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_update_nvm_checksum
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|u16
name|checksum
decl_stmt|;
name|__le16
name|le_sum
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_update_nvm_checksum"
argument_list|)
expr_stmt|;
name|ret_code
operator|=
name|i40e_calc_nvm_checksum
argument_list|(
name|hw
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
name|le_sum
operator|=
name|CPU_TO_LE16
argument_list|(
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|==
name|I40E_SUCCESS
condition|)
name|ret_code
operator|=
name|i40e_write_nvm_aq
argument_list|(
name|hw
argument_list|,
literal|0x00
argument_list|,
name|I40E_SR_SW_CHECKSUM_WORD
argument_list|,
literal|1
argument_list|,
operator|&
name|le_sum
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_validate_nvm_checksum - Validate EEPROM checksum  * @hw: pointer to hardware structure  * @checksum: calculated checksum  *  * Performs checksum calculation and validates the NVM SW checksum. If the  * caller does not need checksum, the value can be NULL.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_validate_nvm_checksum
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|checksum
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|u16
name|checksum_sr
init|=
literal|0
decl_stmt|;
name|u16
name|checksum_local
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_validate_nvm_checksum"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|flags
operator|&
name|I40E_HW_FLAG_AQ_SRCTL_ACCESS_ENABLE
condition|)
name|ret_code
operator|=
name|i40e_acquire_nvm
argument_list|(
name|hw
argument_list|,
name|I40E_RESOURCE_READ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_code
condition|)
block|{
name|ret_code
operator|=
name|i40e_calc_nvm_checksum
argument_list|(
name|hw
argument_list|,
operator|&
name|checksum_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|flags
operator|&
name|I40E_HW_FLAG_AQ_SRCTL_ACCESS_ENABLE
condition|)
name|i40e_release_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|!=
name|I40E_SUCCESS
condition|)
goto|goto
name|i40e_validate_nvm_checksum_exit
goto|;
block|}
else|else
block|{
goto|goto
name|i40e_validate_nvm_checksum_exit
goto|;
block|}
name|i40e_read_nvm_word
argument_list|(
name|hw
argument_list|,
name|I40E_SR_SW_CHECKSUM_WORD
argument_list|,
operator|&
name|checksum_sr
argument_list|)
expr_stmt|;
comment|/* Verify read checksum from EEPROM is the same as 	 * calculated checksum 	 */
if|if
condition|(
name|checksum_local
operator|!=
name|checksum_sr
condition|)
name|ret_code
operator|=
name|I40E_ERR_NVM_CHECKSUM
expr_stmt|;
comment|/* If the user cares, return the calculated checksum */
if|if
condition|(
name|checksum
condition|)
operator|*
name|checksum
operator|=
name|checksum_local
expr_stmt|;
name|i40e_validate_nvm_checksum_exit
label|:
return|return
name|ret_code
return|;
block|}
end_function

begin_function_decl
specifier|static
name|enum
name|i40e_status_code
name|i40e_nvmupd_state_init
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|cmd
parameter_list|,
name|u8
modifier|*
name|bytes
parameter_list|,
name|int
modifier|*
name|perrno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|i40e_status_code
name|i40e_nvmupd_state_reading
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|cmd
parameter_list|,
name|u8
modifier|*
name|bytes
parameter_list|,
name|int
modifier|*
name|perrno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|i40e_status_code
name|i40e_nvmupd_state_writing
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|cmd
parameter_list|,
name|u8
modifier|*
name|bytes
parameter_list|,
name|int
modifier|*
name|perrno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|i40e_nvmupd_cmd
name|i40e_nvmupd_validate_command
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|cmd
parameter_list|,
name|int
modifier|*
name|perrno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|i40e_status_code
name|i40e_nvmupd_nvm_erase
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|cmd
parameter_list|,
name|int
modifier|*
name|perrno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|i40e_status_code
name|i40e_nvmupd_nvm_write
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|cmd
parameter_list|,
name|u8
modifier|*
name|bytes
parameter_list|,
name|int
modifier|*
name|perrno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|i40e_status_code
name|i40e_nvmupd_nvm_read
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|cmd
parameter_list|,
name|u8
modifier|*
name|bytes
parameter_list|,
name|int
modifier|*
name|perrno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|i40e_status_code
name|i40e_nvmupd_exec_aq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|cmd
parameter_list|,
name|u8
modifier|*
name|bytes
parameter_list|,
name|int
modifier|*
name|perrno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|i40e_status_code
name|i40e_nvmupd_get_aq_result
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|cmd
parameter_list|,
name|u8
modifier|*
name|bytes
parameter_list|,
name|int
modifier|*
name|perrno
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|INLINE
name|u8
name|i40e_nvmupd_get_module
parameter_list|(
name|u32
name|val
parameter_list|)
block|{
return|return
call|(
name|u8
call|)
argument_list|(
name|val
operator|&
name|I40E_NVM_MOD_PNT_MASK
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|u8
name|i40e_nvmupd_get_transaction
parameter_list|(
name|u32
name|val
parameter_list|)
block|{
return|return
call|(
name|u8
call|)
argument_list|(
operator|(
name|val
operator|&
name|I40E_NVM_TRANS_MASK
operator|)
operator|>>
name|I40E_NVM_TRANS_SHIFT
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|i40e_nvm_update_state_str
index|[]
init|=
block|{
literal|"I40E_NVMUPD_INVALID"
block|,
literal|"I40E_NVMUPD_READ_CON"
block|,
literal|"I40E_NVMUPD_READ_SNT"
block|,
literal|"I40E_NVMUPD_READ_LCB"
block|,
literal|"I40E_NVMUPD_READ_SA"
block|,
literal|"I40E_NVMUPD_WRITE_ERA"
block|,
literal|"I40E_NVMUPD_WRITE_CON"
block|,
literal|"I40E_NVMUPD_WRITE_SNT"
block|,
literal|"I40E_NVMUPD_WRITE_LCB"
block|,
literal|"I40E_NVMUPD_WRITE_SA"
block|,
literal|"I40E_NVMUPD_CSUM_CON"
block|,
literal|"I40E_NVMUPD_CSUM_SA"
block|,
literal|"I40E_NVMUPD_CSUM_LCB"
block|,
literal|"I40E_NVMUPD_STATUS"
block|,
literal|"I40E_NVMUPD_EXEC_AQ"
block|,
literal|"I40E_NVMUPD_GET_AQ_RESULT"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * i40e_nvmupd_command - Process an NVM update command  * @hw: pointer to hardware structure  * @cmd: pointer to nvm update command  * @bytes: pointer to the data buffer  * @perrno: pointer to return error code  *  * Dispatches command depending on what update state is current  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_nvmupd_command
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|cmd
parameter_list|,
name|u8
modifier|*
name|bytes
parameter_list|,
name|int
modifier|*
name|perrno
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|status
decl_stmt|;
name|enum
name|i40e_nvmupd_cmd
name|upd_cmd
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_nvmupd_command"
argument_list|)
expr_stmt|;
comment|/* assume success */
operator|*
name|perrno
operator|=
literal|0
expr_stmt|;
comment|/* early check for status command and debug msgs */
name|upd_cmd
operator|=
name|i40e_nvmupd_validate_command
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
name|perrno
argument_list|)
expr_stmt|;
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"%s state %d nvm_release_on_hold %d opc 0x%04x cmd 0x%08x config 0x%08x offset 0x%08x data_size 0x%08x\n"
argument_list|,
name|i40e_nvm_update_state_str
index|[
name|upd_cmd
index|]
argument_list|,
name|hw
operator|->
name|nvmupd_state
argument_list|,
name|hw
operator|->
name|nvm_release_on_done
argument_list|,
name|hw
operator|->
name|nvm_wait_opcode
argument_list|,
name|cmd
operator|->
name|command
argument_list|,
name|cmd
operator|->
name|config
argument_list|,
name|cmd
operator|->
name|offset
argument_list|,
name|cmd
operator|->
name|data_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|upd_cmd
operator|==
name|I40E_NVMUPD_INVALID
condition|)
block|{
operator|*
name|perrno
operator|=
operator|-
name|EFAULT
expr_stmt|;
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"i40e_nvmupd_validate_command returns %d errno %d\n"
argument_list|,
name|upd_cmd
argument_list|,
operator|*
name|perrno
argument_list|)
expr_stmt|;
block|}
comment|/* a status request returns immediately rather than 	 * going into the state machine 	 */
if|if
condition|(
name|upd_cmd
operator|==
name|I40E_NVMUPD_STATUS
condition|)
block|{
if|if
condition|(
operator|!
name|cmd
operator|->
name|data_size
condition|)
block|{
operator|*
name|perrno
operator|=
operator|-
name|EFAULT
expr_stmt|;
return|return
name|I40E_ERR_BUF_TOO_SHORT
return|;
block|}
name|bytes
index|[
literal|0
index|]
operator|=
name|hw
operator|->
name|nvmupd_state
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|data_size
operator|>=
literal|4
condition|)
block|{
name|bytes
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
operator|(
name|u16
operator|*
operator|)
operator|&
name|bytes
index|[
literal|2
index|]
operator|)
operator|=
name|hw
operator|->
name|nvm_wait_opcode
expr_stmt|;
block|}
comment|/* Clear error status on read */
if|if
condition|(
name|hw
operator|->
name|nvmupd_state
operator|==
name|I40E_NVMUPD_STATE_ERROR
condition|)
name|hw
operator|->
name|nvmupd_state
operator|=
name|I40E_NVMUPD_STATE_INIT
expr_stmt|;
return|return
name|I40E_SUCCESS
return|;
block|}
comment|/* Clear status even it is not read and log */
if|if
condition|(
name|hw
operator|->
name|nvmupd_state
operator|==
name|I40E_NVMUPD_STATE_ERROR
condition|)
block|{
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"Clearing I40E_NVMUPD_STATE_ERROR state without reading\n"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|nvmupd_state
operator|=
name|I40E_NVMUPD_STATE_INIT
expr_stmt|;
block|}
switch|switch
condition|(
name|hw
operator|->
name|nvmupd_state
condition|)
block|{
case|case
name|I40E_NVMUPD_STATE_INIT
case|:
name|status
operator|=
name|i40e_nvmupd_state_init
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
name|bytes
argument_list|,
name|perrno
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_NVMUPD_STATE_READING
case|:
name|status
operator|=
name|i40e_nvmupd_state_reading
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
name|bytes
argument_list|,
name|perrno
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_NVMUPD_STATE_WRITING
case|:
name|status
operator|=
name|i40e_nvmupd_state_writing
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
name|bytes
argument_list|,
name|perrno
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_NVMUPD_STATE_INIT_WAIT
case|:
case|case
name|I40E_NVMUPD_STATE_WRITE_WAIT
case|:
comment|/* if we need to stop waiting for an event, clear 		 * the wait info and return before doing anything else 		 */
if|if
condition|(
name|cmd
operator|->
name|offset
operator|==
literal|0xffff
condition|)
block|{
name|i40e_nvmupd_check_wait_event
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|nvm_wait_opcode
argument_list|)
expr_stmt|;
return|return
name|I40E_SUCCESS
return|;
block|}
name|status
operator|=
name|I40E_ERR_NOT_READY
expr_stmt|;
operator|*
name|perrno
operator|=
operator|-
name|EBUSY
expr_stmt|;
break|break;
default|default:
comment|/* invalid state, should never happen */
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVMUPD: no such state %d\n"
argument_list|,
name|hw
operator|->
name|nvmupd_state
argument_list|)
expr_stmt|;
name|status
operator|=
name|I40E_NOT_SUPPORTED
expr_stmt|;
operator|*
name|perrno
operator|=
operator|-
name|ESRCH
expr_stmt|;
break|break;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_nvmupd_state_init - Handle NVM update state Init  * @hw: pointer to hardware structure  * @cmd: pointer to nvm update command buffer  * @bytes: pointer to the data buffer  * @perrno: pointer to return error code  *  * Process legitimate commands of the Init state and conditionally set next  * state. Reject all other commands.  **/
end_comment

begin_function
specifier|static
name|enum
name|i40e_status_code
name|i40e_nvmupd_state_init
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|cmd
parameter_list|,
name|u8
modifier|*
name|bytes
parameter_list|,
name|int
modifier|*
name|perrno
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|status
init|=
name|I40E_SUCCESS
decl_stmt|;
name|enum
name|i40e_nvmupd_cmd
name|upd_cmd
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_nvmupd_state_init"
argument_list|)
expr_stmt|;
name|upd_cmd
operator|=
name|i40e_nvmupd_validate_command
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
name|perrno
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|upd_cmd
condition|)
block|{
case|case
name|I40E_NVMUPD_READ_SA
case|:
name|status
operator|=
name|i40e_acquire_nvm
argument_list|(
name|hw
argument_list|,
name|I40E_RESOURCE_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
operator|*
name|perrno
operator|=
name|i40e_aq_rc_to_posix
argument_list|(
name|status
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|i40e_nvmupd_nvm_read
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
name|bytes
argument_list|,
name|perrno
argument_list|)
expr_stmt|;
name|i40e_release_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|I40E_NVMUPD_READ_SNT
case|:
name|status
operator|=
name|i40e_acquire_nvm
argument_list|(
name|hw
argument_list|,
name|I40E_RESOURCE_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
operator|*
name|perrno
operator|=
name|i40e_aq_rc_to_posix
argument_list|(
name|status
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|i40e_nvmupd_nvm_read
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
name|bytes
argument_list|,
name|perrno
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|i40e_release_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
else|else
name|hw
operator|->
name|nvmupd_state
operator|=
name|I40E_NVMUPD_STATE_READING
expr_stmt|;
block|}
break|break;
case|case
name|I40E_NVMUPD_WRITE_ERA
case|:
name|status
operator|=
name|i40e_acquire_nvm
argument_list|(
name|hw
argument_list|,
name|I40E_RESOURCE_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
operator|*
name|perrno
operator|=
name|i40e_aq_rc_to_posix
argument_list|(
name|status
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|i40e_nvmupd_nvm_erase
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
name|perrno
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|i40e_release_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|nvm_release_on_done
operator|=
name|TRUE
expr_stmt|;
name|hw
operator|->
name|nvm_wait_opcode
operator|=
name|i40e_aqc_opc_nvm_erase
expr_stmt|;
name|hw
operator|->
name|nvmupd_state
operator|=
name|I40E_NVMUPD_STATE_INIT_WAIT
expr_stmt|;
block|}
block|}
break|break;
case|case
name|I40E_NVMUPD_WRITE_SA
case|:
name|status
operator|=
name|i40e_acquire_nvm
argument_list|(
name|hw
argument_list|,
name|I40E_RESOURCE_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
operator|*
name|perrno
operator|=
name|i40e_aq_rc_to_posix
argument_list|(
name|status
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|i40e_nvmupd_nvm_write
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
name|bytes
argument_list|,
name|perrno
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|i40e_release_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|nvm_release_on_done
operator|=
name|TRUE
expr_stmt|;
name|hw
operator|->
name|nvm_wait_opcode
operator|=
name|i40e_aqc_opc_nvm_update
expr_stmt|;
name|hw
operator|->
name|nvmupd_state
operator|=
name|I40E_NVMUPD_STATE_INIT_WAIT
expr_stmt|;
block|}
block|}
break|break;
case|case
name|I40E_NVMUPD_WRITE_SNT
case|:
name|status
operator|=
name|i40e_acquire_nvm
argument_list|(
name|hw
argument_list|,
name|I40E_RESOURCE_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
operator|*
name|perrno
operator|=
name|i40e_aq_rc_to_posix
argument_list|(
name|status
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|i40e_nvmupd_nvm_write
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
name|bytes
argument_list|,
name|perrno
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|i40e_release_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|nvm_wait_opcode
operator|=
name|i40e_aqc_opc_nvm_update
expr_stmt|;
name|hw
operator|->
name|nvmupd_state
operator|=
name|I40E_NVMUPD_STATE_WRITE_WAIT
expr_stmt|;
block|}
block|}
break|break;
case|case
name|I40E_NVMUPD_CSUM_SA
case|:
name|status
operator|=
name|i40e_acquire_nvm
argument_list|(
name|hw
argument_list|,
name|I40E_RESOURCE_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
operator|*
name|perrno
operator|=
name|i40e_aq_rc_to_posix
argument_list|(
name|status
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|i40e_update_nvm_checksum
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
operator|*
name|perrno
operator|=
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
condition|?
name|i40e_aq_rc_to_posix
argument_list|(
name|status
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
else|:
operator|-
name|EIO
expr_stmt|;
name|i40e_release_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|nvm_release_on_done
operator|=
name|TRUE
expr_stmt|;
name|hw
operator|->
name|nvm_wait_opcode
operator|=
name|i40e_aqc_opc_nvm_update
expr_stmt|;
name|hw
operator|->
name|nvmupd_state
operator|=
name|I40E_NVMUPD_STATE_INIT_WAIT
expr_stmt|;
block|}
block|}
break|break;
case|case
name|I40E_NVMUPD_EXEC_AQ
case|:
name|status
operator|=
name|i40e_nvmupd_exec_aq
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
name|bytes
argument_list|,
name|perrno
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_NVMUPD_GET_AQ_RESULT
case|:
name|status
operator|=
name|i40e_nvmupd_get_aq_result
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
name|bytes
argument_list|,
name|perrno
argument_list|)
expr_stmt|;
break|break;
default|default:
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVMUPD: bad cmd %s in init state\n"
argument_list|,
name|i40e_nvm_update_state_str
index|[
name|upd_cmd
index|]
argument_list|)
expr_stmt|;
name|status
operator|=
name|I40E_ERR_NVM
expr_stmt|;
operator|*
name|perrno
operator|=
operator|-
name|ESRCH
expr_stmt|;
break|break;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_nvmupd_state_reading - Handle NVM update state Reading  * @hw: pointer to hardware structure  * @cmd: pointer to nvm update command buffer  * @bytes: pointer to the data buffer  * @perrno: pointer to return error code  *  * NVM ownership is already held.  Process legitimate commands and set any  * change in state; reject all other commands.  **/
end_comment

begin_function
specifier|static
name|enum
name|i40e_status_code
name|i40e_nvmupd_state_reading
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|cmd
parameter_list|,
name|u8
modifier|*
name|bytes
parameter_list|,
name|int
modifier|*
name|perrno
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|status
init|=
name|I40E_SUCCESS
decl_stmt|;
name|enum
name|i40e_nvmupd_cmd
name|upd_cmd
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_nvmupd_state_reading"
argument_list|)
expr_stmt|;
name|upd_cmd
operator|=
name|i40e_nvmupd_validate_command
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
name|perrno
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|upd_cmd
condition|)
block|{
case|case
name|I40E_NVMUPD_READ_SA
case|:
case|case
name|I40E_NVMUPD_READ_CON
case|:
name|status
operator|=
name|i40e_nvmupd_nvm_read
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
name|bytes
argument_list|,
name|perrno
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_NVMUPD_READ_LCB
case|:
name|status
operator|=
name|i40e_nvmupd_nvm_read
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
name|bytes
argument_list|,
name|perrno
argument_list|)
expr_stmt|;
name|i40e_release_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|nvmupd_state
operator|=
name|I40E_NVMUPD_STATE_INIT
expr_stmt|;
break|break;
default|default:
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVMUPD: bad cmd %s in reading state.\n"
argument_list|,
name|i40e_nvm_update_state_str
index|[
name|upd_cmd
index|]
argument_list|)
expr_stmt|;
name|status
operator|=
name|I40E_NOT_SUPPORTED
expr_stmt|;
operator|*
name|perrno
operator|=
operator|-
name|ESRCH
expr_stmt|;
break|break;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_nvmupd_state_writing - Handle NVM update state Writing  * @hw: pointer to hardware structure  * @cmd: pointer to nvm update command buffer  * @bytes: pointer to the data buffer  * @perrno: pointer to return error code  *  * NVM ownership is already held.  Process legitimate commands and set any  * change in state; reject all other commands  **/
end_comment

begin_function
specifier|static
name|enum
name|i40e_status_code
name|i40e_nvmupd_state_writing
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|cmd
parameter_list|,
name|u8
modifier|*
name|bytes
parameter_list|,
name|int
modifier|*
name|perrno
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|status
init|=
name|I40E_SUCCESS
decl_stmt|;
name|enum
name|i40e_nvmupd_cmd
name|upd_cmd
decl_stmt|;
name|bool
name|retry_attempt
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_nvmupd_state_writing"
argument_list|)
expr_stmt|;
name|upd_cmd
operator|=
name|i40e_nvmupd_validate_command
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
name|perrno
argument_list|)
expr_stmt|;
name|retry
label|:
switch|switch
condition|(
name|upd_cmd
condition|)
block|{
case|case
name|I40E_NVMUPD_WRITE_CON
case|:
name|status
operator|=
name|i40e_nvmupd_nvm_write
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
name|bytes
argument_list|,
name|perrno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
block|{
name|hw
operator|->
name|nvm_wait_opcode
operator|=
name|i40e_aqc_opc_nvm_update
expr_stmt|;
name|hw
operator|->
name|nvmupd_state
operator|=
name|I40E_NVMUPD_STATE_WRITE_WAIT
expr_stmt|;
block|}
break|break;
case|case
name|I40E_NVMUPD_WRITE_LCB
case|:
name|status
operator|=
name|i40e_nvmupd_nvm_write
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
name|bytes
argument_list|,
name|perrno
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
operator|*
name|perrno
operator|=
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
condition|?
name|i40e_aq_rc_to_posix
argument_list|(
name|status
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
else|:
operator|-
name|EIO
expr_stmt|;
name|hw
operator|->
name|nvmupd_state
operator|=
name|I40E_NVMUPD_STATE_INIT
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|nvm_release_on_done
operator|=
name|TRUE
expr_stmt|;
name|hw
operator|->
name|nvm_wait_opcode
operator|=
name|i40e_aqc_opc_nvm_update
expr_stmt|;
name|hw
operator|->
name|nvmupd_state
operator|=
name|I40E_NVMUPD_STATE_INIT_WAIT
expr_stmt|;
block|}
break|break;
case|case
name|I40E_NVMUPD_CSUM_CON
case|:
comment|/* Assumes the caller has acquired the nvm */
name|status
operator|=
name|i40e_update_nvm_checksum
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
operator|*
name|perrno
operator|=
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
condition|?
name|i40e_aq_rc_to_posix
argument_list|(
name|status
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
else|:
operator|-
name|EIO
expr_stmt|;
name|hw
operator|->
name|nvmupd_state
operator|=
name|I40E_NVMUPD_STATE_INIT
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|nvm_wait_opcode
operator|=
name|i40e_aqc_opc_nvm_update
expr_stmt|;
name|hw
operator|->
name|nvmupd_state
operator|=
name|I40E_NVMUPD_STATE_WRITE_WAIT
expr_stmt|;
block|}
break|break;
case|case
name|I40E_NVMUPD_CSUM_LCB
case|:
comment|/* Assumes the caller has acquired the nvm */
name|status
operator|=
name|i40e_update_nvm_checksum
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
operator|*
name|perrno
operator|=
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
condition|?
name|i40e_aq_rc_to_posix
argument_list|(
name|status
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
else|:
operator|-
name|EIO
expr_stmt|;
name|hw
operator|->
name|nvmupd_state
operator|=
name|I40E_NVMUPD_STATE_INIT
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|nvm_release_on_done
operator|=
name|TRUE
expr_stmt|;
name|hw
operator|->
name|nvm_wait_opcode
operator|=
name|i40e_aqc_opc_nvm_update
expr_stmt|;
name|hw
operator|->
name|nvmupd_state
operator|=
name|I40E_NVMUPD_STATE_INIT_WAIT
expr_stmt|;
block|}
break|break;
default|default:
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVMUPD: bad cmd %s in writing state.\n"
argument_list|,
name|i40e_nvm_update_state_str
index|[
name|upd_cmd
index|]
argument_list|)
expr_stmt|;
name|status
operator|=
name|I40E_NOT_SUPPORTED
expr_stmt|;
operator|*
name|perrno
operator|=
operator|-
name|ESRCH
expr_stmt|;
break|break;
block|}
comment|/* In some circumstances, a multi-write transaction takes longer 	 * than the default 3 minute timeout on the write semaphore.  If 	 * the write failed with an EBUSY status, this is likely the problem, 	 * so here we try to reacquire the semaphore then retry the write. 	 * We only do one retry, then give up. 	 */
if|if
condition|(
name|status
operator|&&
operator|(
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
operator|==
name|I40E_AQ_RC_EBUSY
operator|)
operator|&&
operator|!
name|retry_attempt
condition|)
block|{
name|enum
name|i40e_status_code
name|old_status
init|=
name|status
decl_stmt|;
name|u32
name|old_asq_status
init|=
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
decl_stmt|;
name|u32
name|gtime
decl_stmt|;
name|gtime
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLVFGEN_TIMER
argument_list|)
expr_stmt|;
if|if
condition|(
name|gtime
operator|>=
name|hw
operator|->
name|nvm
operator|.
name|hw_semaphore_timeout
condition|)
block|{
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_ALL
argument_list|,
literal|"NVMUPD: write semaphore expired (%d>= %lld), retrying\n"
argument_list|,
name|gtime
argument_list|,
name|hw
operator|->
name|nvm
operator|.
name|hw_semaphore_timeout
argument_list|)
expr_stmt|;
name|i40e_release_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|status
operator|=
name|i40e_acquire_nvm
argument_list|(
name|hw
argument_list|,
name|I40E_RESOURCE_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_ALL
argument_list|,
literal|"NVMUPD: write semaphore reacquire failed aq_err = %d\n"
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
name|status
operator|=
name|old_status
expr_stmt|;
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
operator|=
name|old_asq_status
expr_stmt|;
block|}
else|else
block|{
name|retry_attempt
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_nvmupd_check_wait_event - handle NVM update operation events  * @hw: pointer to the hardware structure  * @opcode: the event that just happened  **/
end_comment

begin_function
name|void
name|i40e_nvmupd_check_wait_event
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|opcode
parameter_list|)
block|{
if|if
condition|(
name|opcode
operator|==
name|hw
operator|->
name|nvm_wait_opcode
condition|)
block|{
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVMUPD: clearing wait on opcode 0x%04x\n"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|nvm_release_on_done
condition|)
block|{
name|i40e_release_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|nvm_release_on_done
operator|=
name|FALSE
expr_stmt|;
block|}
name|hw
operator|->
name|nvm_wait_opcode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|aq
operator|.
name|arq_last_status
condition|)
block|{
name|hw
operator|->
name|nvmupd_state
operator|=
name|I40E_NVMUPD_STATE_ERROR
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|hw
operator|->
name|nvmupd_state
condition|)
block|{
case|case
name|I40E_NVMUPD_STATE_INIT_WAIT
case|:
name|hw
operator|->
name|nvmupd_state
operator|=
name|I40E_NVMUPD_STATE_INIT
expr_stmt|;
break|break;
case|case
name|I40E_NVMUPD_STATE_WRITE_WAIT
case|:
name|hw
operator|->
name|nvmupd_state
operator|=
name|I40E_NVMUPD_STATE_WRITING
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * i40e_nvmupd_validate_command - Validate given command  * @hw: pointer to hardware structure  * @cmd: pointer to nvm update command buffer  * @perrno: pointer to return error code  *  * Return one of the valid command types or I40E_NVMUPD_INVALID  **/
end_comment

begin_function
specifier|static
name|enum
name|i40e_nvmupd_cmd
name|i40e_nvmupd_validate_command
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|cmd
parameter_list|,
name|int
modifier|*
name|perrno
parameter_list|)
block|{
name|enum
name|i40e_nvmupd_cmd
name|upd_cmd
decl_stmt|;
name|u8
name|module
decl_stmt|,
name|transaction
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"i40e_nvmupd_validate_command\n"
argument_list|)
expr_stmt|;
comment|/* anything that doesn't match a recognized case is an error */
name|upd_cmd
operator|=
name|I40E_NVMUPD_INVALID
expr_stmt|;
name|transaction
operator|=
name|i40e_nvmupd_get_transaction
argument_list|(
name|cmd
operator|->
name|config
argument_list|)
expr_stmt|;
name|module
operator|=
name|i40e_nvmupd_get_module
argument_list|(
name|cmd
operator|->
name|config
argument_list|)
expr_stmt|;
comment|/* limits on data size */
if|if
condition|(
operator|(
name|cmd
operator|->
name|data_size
operator|<
literal|1
operator|)
operator|||
operator|(
name|cmd
operator|->
name|data_size
operator|>
name|I40E_NVMUPD_MAX_DATA
operator|)
condition|)
block|{
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"i40e_nvmupd_validate_command data_size %d\n"
argument_list|,
name|cmd
operator|->
name|data_size
argument_list|)
expr_stmt|;
operator|*
name|perrno
operator|=
operator|-
name|EFAULT
expr_stmt|;
return|return
name|I40E_NVMUPD_INVALID
return|;
block|}
switch|switch
condition|(
name|cmd
operator|->
name|command
condition|)
block|{
case|case
name|I40E_NVM_READ
case|:
switch|switch
condition|(
name|transaction
condition|)
block|{
case|case
name|I40E_NVM_CON
case|:
name|upd_cmd
operator|=
name|I40E_NVMUPD_READ_CON
expr_stmt|;
break|break;
case|case
name|I40E_NVM_SNT
case|:
name|upd_cmd
operator|=
name|I40E_NVMUPD_READ_SNT
expr_stmt|;
break|break;
case|case
name|I40E_NVM_LCB
case|:
name|upd_cmd
operator|=
name|I40E_NVMUPD_READ_LCB
expr_stmt|;
break|break;
case|case
name|I40E_NVM_SA
case|:
name|upd_cmd
operator|=
name|I40E_NVMUPD_READ_SA
expr_stmt|;
break|break;
case|case
name|I40E_NVM_EXEC
case|:
if|if
condition|(
name|module
operator|==
literal|0xf
condition|)
name|upd_cmd
operator|=
name|I40E_NVMUPD_STATUS
expr_stmt|;
elseif|else
if|if
condition|(
name|module
operator|==
literal|0
condition|)
name|upd_cmd
operator|=
name|I40E_NVMUPD_GET_AQ_RESULT
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|I40E_NVM_WRITE
case|:
switch|switch
condition|(
name|transaction
condition|)
block|{
case|case
name|I40E_NVM_CON
case|:
name|upd_cmd
operator|=
name|I40E_NVMUPD_WRITE_CON
expr_stmt|;
break|break;
case|case
name|I40E_NVM_SNT
case|:
name|upd_cmd
operator|=
name|I40E_NVMUPD_WRITE_SNT
expr_stmt|;
break|break;
case|case
name|I40E_NVM_LCB
case|:
name|upd_cmd
operator|=
name|I40E_NVMUPD_WRITE_LCB
expr_stmt|;
break|break;
case|case
name|I40E_NVM_SA
case|:
name|upd_cmd
operator|=
name|I40E_NVMUPD_WRITE_SA
expr_stmt|;
break|break;
case|case
name|I40E_NVM_ERA
case|:
name|upd_cmd
operator|=
name|I40E_NVMUPD_WRITE_ERA
expr_stmt|;
break|break;
case|case
name|I40E_NVM_CSUM
case|:
name|upd_cmd
operator|=
name|I40E_NVMUPD_CSUM_CON
expr_stmt|;
break|break;
case|case
operator|(
name|I40E_NVM_CSUM
operator||
name|I40E_NVM_SA
operator|)
case|:
name|upd_cmd
operator|=
name|I40E_NVMUPD_CSUM_SA
expr_stmt|;
break|break;
case|case
operator|(
name|I40E_NVM_CSUM
operator||
name|I40E_NVM_LCB
operator|)
case|:
name|upd_cmd
operator|=
name|I40E_NVMUPD_CSUM_LCB
expr_stmt|;
break|break;
case|case
name|I40E_NVM_EXEC
case|:
if|if
condition|(
name|module
operator|==
literal|0
condition|)
name|upd_cmd
operator|=
name|I40E_NVMUPD_EXEC_AQ
expr_stmt|;
break|break;
block|}
break|break;
block|}
return|return
name|upd_cmd
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_nvmupd_exec_aq - Run an AQ command  * @hw: pointer to hardware structure  * @cmd: pointer to nvm update command buffer  * @bytes: pointer to the data buffer  * @perrno: pointer to return error code  *  * cmd structure contains identifiers and data buffer  **/
end_comment

begin_function
specifier|static
name|enum
name|i40e_status_code
name|i40e_nvmupd_exec_aq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|cmd
parameter_list|,
name|u8
modifier|*
name|bytes
parameter_list|,
name|int
modifier|*
name|perrno
parameter_list|)
block|{
name|struct
name|i40e_asq_cmd_details
name|cmd_details
decl_stmt|;
name|enum
name|i40e_status_code
name|status
decl_stmt|;
name|struct
name|i40e_aq_desc
modifier|*
name|aq_desc
decl_stmt|;
name|u32
name|buff_size
init|=
literal|0
decl_stmt|;
name|u8
modifier|*
name|buff
init|=
name|NULL
decl_stmt|;
name|u32
name|aq_desc_len
decl_stmt|;
name|u32
name|aq_data_len
decl_stmt|;
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVMUPD: %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd_details
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd_details
argument_list|)
argument_list|)
expr_stmt|;
name|cmd_details
operator|.
name|wb_desc
operator|=
operator|&
name|hw
operator|->
name|nvm_wb_desc
expr_stmt|;
name|aq_desc_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_aq_desc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hw
operator|->
name|nvm_wb_desc
argument_list|,
literal|0
argument_list|,
name|aq_desc_len
argument_list|)
expr_stmt|;
comment|/* get the aq descriptor */
if|if
condition|(
name|cmd
operator|->
name|data_size
operator|<
name|aq_desc_len
condition|)
block|{
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVMUPD: not enough aq desc bytes for exec, size %d< %d\n"
argument_list|,
name|cmd
operator|->
name|data_size
argument_list|,
name|aq_desc_len
argument_list|)
expr_stmt|;
operator|*
name|perrno
operator|=
operator|-
name|EINVAL
expr_stmt|;
return|return
name|I40E_ERR_PARAM
return|;
block|}
name|aq_desc
operator|=
operator|(
expr|struct
name|i40e_aq_desc
operator|*
operator|)
name|bytes
expr_stmt|;
comment|/* if data buffer needed, make sure it's ready */
name|aq_data_len
operator|=
name|cmd
operator|->
name|data_size
operator|-
name|aq_desc_len
expr_stmt|;
name|buff_size
operator|=
name|max
argument_list|(
name|aq_data_len
argument_list|,
operator|(
name|u32
operator|)
name|LE16_TO_CPU
argument_list|(
name|aq_desc
operator|->
name|datalen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff_size
condition|)
block|{
if|if
condition|(
operator|!
name|hw
operator|->
name|nvm_buff
operator|.
name|va
condition|)
block|{
name|status
operator|=
name|i40e_allocate_virt_mem
argument_list|(
name|hw
argument_list|,
operator|&
name|hw
operator|->
name|nvm_buff
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVMUPD: i40e_allocate_virt_mem for exec buff failed, %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|nvm_buff
operator|.
name|va
condition|)
block|{
name|buff
operator|=
name|hw
operator|->
name|nvm_buff
operator|.
name|va
expr_stmt|;
name|i40e_memcpy
argument_list|(
name|buff
argument_list|,
operator|&
name|bytes
index|[
name|aq_desc_len
index|]
argument_list|,
name|aq_data_len
argument_list|,
name|I40E_NONDMA_TO_NONDMA
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* and away we go! */
name|status
operator|=
name|i40e_asq_send_command
argument_list|(
name|hw
argument_list|,
name|aq_desc
argument_list|,
name|buff
argument_list|,
name|buff_size
argument_list|,
operator|&
name|cmd_details
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"i40e_nvmupd_exec_aq err %s aq_err %s\n"
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|status
argument_list|)
argument_list|,
name|i40e_aq_str
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|perrno
operator|=
name|i40e_aq_rc_to_posix
argument_list|(
name|status
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
block|}
comment|/* should we wait for a followup event? */
if|if
condition|(
name|cmd
operator|->
name|offset
condition|)
block|{
name|hw
operator|->
name|nvm_wait_opcode
operator|=
name|cmd
operator|->
name|offset
expr_stmt|;
name|hw
operator|->
name|nvmupd_state
operator|=
name|I40E_NVMUPD_STATE_INIT_WAIT
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_nvmupd_get_aq_result - Get the results from the previous exec_aq  * @hw: pointer to hardware structure  * @cmd: pointer to nvm update command buffer  * @bytes: pointer to the data buffer  * @perrno: pointer to return error code  *  * cmd structure contains identifiers and data buffer  **/
end_comment

begin_function
specifier|static
name|enum
name|i40e_status_code
name|i40e_nvmupd_get_aq_result
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|cmd
parameter_list|,
name|u8
modifier|*
name|bytes
parameter_list|,
name|int
modifier|*
name|perrno
parameter_list|)
block|{
name|u32
name|aq_total_len
decl_stmt|;
name|u32
name|aq_desc_len
decl_stmt|;
name|int
name|remainder
decl_stmt|;
name|u8
modifier|*
name|buff
decl_stmt|;
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"NVMUPD: %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|aq_desc_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_aq_desc
argument_list|)
expr_stmt|;
name|aq_total_len
operator|=
name|aq_desc_len
operator|+
name|LE16_TO_CPU
argument_list|(
name|hw
operator|->
name|nvm_wb_desc
operator|.
name|datalen
argument_list|)
expr_stmt|;
comment|/* check offset range */
if|if
condition|(
name|cmd
operator|->
name|offset
operator|>
name|aq_total_len
condition|)
block|{
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"%s: offset too big %d> %d\n"
argument_list|,
name|__func__
argument_list|,
name|cmd
operator|->
name|offset
argument_list|,
name|aq_total_len
argument_list|)
expr_stmt|;
operator|*
name|perrno
operator|=
operator|-
name|EINVAL
expr_stmt|;
return|return
name|I40E_ERR_PARAM
return|;
block|}
comment|/* check copylength range */
if|if
condition|(
name|cmd
operator|->
name|data_size
operator|>
operator|(
name|aq_total_len
operator|-
name|cmd
operator|->
name|offset
operator|)
condition|)
block|{
name|int
name|new_len
init|=
name|aq_total_len
operator|-
name|cmd
operator|->
name|offset
decl_stmt|;
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"%s: copy length %d too big, trimming to %d\n"
argument_list|,
name|__func__
argument_list|,
name|cmd
operator|->
name|data_size
argument_list|,
name|new_len
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|data_size
operator|=
name|new_len
expr_stmt|;
block|}
name|remainder
operator|=
name|cmd
operator|->
name|data_size
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|offset
operator|<
name|aq_desc_len
condition|)
block|{
name|u32
name|len
init|=
name|aq_desc_len
operator|-
name|cmd
operator|->
name|offset
decl_stmt|;
name|len
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|cmd
operator|->
name|data_size
argument_list|)
expr_stmt|;
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"%s: aq_desc bytes %d to %d\n"
argument_list|,
name|__func__
argument_list|,
name|cmd
operator|->
name|offset
argument_list|,
name|cmd
operator|->
name|offset
operator|+
name|len
argument_list|)
expr_stmt|;
name|buff
operator|=
operator|(
operator|(
name|u8
operator|*
operator|)
operator|&
name|hw
operator|->
name|nvm_wb_desc
operator|)
operator|+
name|cmd
operator|->
name|offset
expr_stmt|;
name|i40e_memcpy
argument_list|(
name|bytes
argument_list|,
name|buff
argument_list|,
name|len
argument_list|,
name|I40E_NONDMA_TO_NONDMA
argument_list|)
expr_stmt|;
name|bytes
operator|+=
name|len
expr_stmt|;
name|remainder
operator|-=
name|len
expr_stmt|;
name|buff
operator|=
name|hw
operator|->
name|nvm_buff
operator|.
name|va
expr_stmt|;
block|}
else|else
block|{
name|buff
operator|=
operator|(
name|u8
operator|*
operator|)
name|hw
operator|->
name|nvm_buff
operator|.
name|va
operator|+
operator|(
name|cmd
operator|->
name|offset
operator|-
name|aq_desc_len
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|remainder
operator|>
literal|0
condition|)
block|{
name|int
name|start_byte
init|=
name|buff
operator|-
operator|(
name|u8
operator|*
operator|)
name|hw
operator|->
name|nvm_buff
operator|.
name|va
decl_stmt|;
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"%s: databuf bytes %d to %d\n"
argument_list|,
name|__func__
argument_list|,
name|start_byte
argument_list|,
name|start_byte
operator|+
name|remainder
argument_list|)
expr_stmt|;
name|i40e_memcpy
argument_list|(
name|bytes
argument_list|,
name|buff
argument_list|,
name|remainder
argument_list|,
name|I40E_NONDMA_TO_NONDMA
argument_list|)
expr_stmt|;
block|}
return|return
name|I40E_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_nvmupd_nvm_read - Read NVM  * @hw: pointer to hardware structure  * @cmd: pointer to nvm update command buffer  * @bytes: pointer to the data buffer  * @perrno: pointer to return error code  *  * cmd structure contains identifiers and data buffer  **/
end_comment

begin_function
specifier|static
name|enum
name|i40e_status_code
name|i40e_nvmupd_nvm_read
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|cmd
parameter_list|,
name|u8
modifier|*
name|bytes
parameter_list|,
name|int
modifier|*
name|perrno
parameter_list|)
block|{
name|struct
name|i40e_asq_cmd_details
name|cmd_details
decl_stmt|;
name|enum
name|i40e_status_code
name|status
decl_stmt|;
name|u8
name|module
decl_stmt|,
name|transaction
decl_stmt|;
name|bool
name|last
decl_stmt|;
name|transaction
operator|=
name|i40e_nvmupd_get_transaction
argument_list|(
name|cmd
operator|->
name|config
argument_list|)
expr_stmt|;
name|module
operator|=
name|i40e_nvmupd_get_module
argument_list|(
name|cmd
operator|->
name|config
argument_list|)
expr_stmt|;
name|last
operator|=
operator|(
name|transaction
operator|==
name|I40E_NVM_LCB
operator|)
operator|||
operator|(
name|transaction
operator|==
name|I40E_NVM_SA
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd_details
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd_details
argument_list|)
argument_list|)
expr_stmt|;
name|cmd_details
operator|.
name|wb_desc
operator|=
operator|&
name|hw
operator|->
name|nvm_wb_desc
expr_stmt|;
name|status
operator|=
name|i40e_aq_read_nvm
argument_list|(
name|hw
argument_list|,
name|module
argument_list|,
name|cmd
operator|->
name|offset
argument_list|,
operator|(
name|u16
operator|)
name|cmd
operator|->
name|data_size
argument_list|,
name|bytes
argument_list|,
name|last
argument_list|,
operator|&
name|cmd_details
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"i40e_nvmupd_nvm_read mod 0x%x  off 0x%x  len 0x%x\n"
argument_list|,
name|module
argument_list|,
name|cmd
operator|->
name|offset
argument_list|,
name|cmd
operator|->
name|data_size
argument_list|)
expr_stmt|;
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"i40e_nvmupd_nvm_read status %d aq %d\n"
argument_list|,
name|status
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
operator|*
name|perrno
operator|=
name|i40e_aq_rc_to_posix
argument_list|(
name|status
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_nvmupd_nvm_erase - Erase an NVM module  * @hw: pointer to hardware structure  * @cmd: pointer to nvm update command buffer  * @perrno: pointer to return error code  *  * module, offset, data_size and data are in cmd structure  **/
end_comment

begin_function
specifier|static
name|enum
name|i40e_status_code
name|i40e_nvmupd_nvm_erase
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|cmd
parameter_list|,
name|int
modifier|*
name|perrno
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|status
init|=
name|I40E_SUCCESS
decl_stmt|;
name|struct
name|i40e_asq_cmd_details
name|cmd_details
decl_stmt|;
name|u8
name|module
decl_stmt|,
name|transaction
decl_stmt|;
name|bool
name|last
decl_stmt|;
name|transaction
operator|=
name|i40e_nvmupd_get_transaction
argument_list|(
name|cmd
operator|->
name|config
argument_list|)
expr_stmt|;
name|module
operator|=
name|i40e_nvmupd_get_module
argument_list|(
name|cmd
operator|->
name|config
argument_list|)
expr_stmt|;
name|last
operator|=
operator|(
name|transaction
operator|&
name|I40E_NVM_LCB
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd_details
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd_details
argument_list|)
argument_list|)
expr_stmt|;
name|cmd_details
operator|.
name|wb_desc
operator|=
operator|&
name|hw
operator|->
name|nvm_wb_desc
expr_stmt|;
name|status
operator|=
name|i40e_aq_erase_nvm
argument_list|(
name|hw
argument_list|,
name|module
argument_list|,
name|cmd
operator|->
name|offset
argument_list|,
operator|(
name|u16
operator|)
name|cmd
operator|->
name|data_size
argument_list|,
name|last
argument_list|,
operator|&
name|cmd_details
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"i40e_nvmupd_nvm_erase mod 0x%x  off 0x%x len 0x%x\n"
argument_list|,
name|module
argument_list|,
name|cmd
operator|->
name|offset
argument_list|,
name|cmd
operator|->
name|data_size
argument_list|)
expr_stmt|;
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"i40e_nvmupd_nvm_erase status %d aq %d\n"
argument_list|,
name|status
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
operator|*
name|perrno
operator|=
name|i40e_aq_rc_to_posix
argument_list|(
name|status
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_nvmupd_nvm_write - Write NVM  * @hw: pointer to hardware structure  * @cmd: pointer to nvm update command buffer  * @bytes: pointer to the data buffer  * @perrno: pointer to return error code  *  * module, offset, data_size and data are in cmd structure  **/
end_comment

begin_function
specifier|static
name|enum
name|i40e_status_code
name|i40e_nvmupd_nvm_write
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|cmd
parameter_list|,
name|u8
modifier|*
name|bytes
parameter_list|,
name|int
modifier|*
name|perrno
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|status
init|=
name|I40E_SUCCESS
decl_stmt|;
name|struct
name|i40e_asq_cmd_details
name|cmd_details
decl_stmt|;
name|u8
name|module
decl_stmt|,
name|transaction
decl_stmt|;
name|bool
name|last
decl_stmt|;
name|transaction
operator|=
name|i40e_nvmupd_get_transaction
argument_list|(
name|cmd
operator|->
name|config
argument_list|)
expr_stmt|;
name|module
operator|=
name|i40e_nvmupd_get_module
argument_list|(
name|cmd
operator|->
name|config
argument_list|)
expr_stmt|;
name|last
operator|=
operator|(
name|transaction
operator|&
name|I40E_NVM_LCB
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd_details
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd_details
argument_list|)
argument_list|)
expr_stmt|;
name|cmd_details
operator|.
name|wb_desc
operator|=
operator|&
name|hw
operator|->
name|nvm_wb_desc
expr_stmt|;
name|status
operator|=
name|i40e_aq_update_nvm
argument_list|(
name|hw
argument_list|,
name|module
argument_list|,
name|cmd
operator|->
name|offset
argument_list|,
operator|(
name|u16
operator|)
name|cmd
operator|->
name|data_size
argument_list|,
name|bytes
argument_list|,
name|last
argument_list|,
operator|&
name|cmd_details
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"i40e_nvmupd_nvm_write mod 0x%x off 0x%x len 0x%x\n"
argument_list|,
name|module
argument_list|,
name|cmd
operator|->
name|offset
argument_list|,
name|cmd
operator|->
name|data_size
argument_list|)
expr_stmt|;
name|i40e_debug
argument_list|(
name|hw
argument_list|,
name|I40E_DEBUG_NVM
argument_list|,
literal|"i40e_nvmupd_nvm_write status %d aq %d\n"
argument_list|,
name|status
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
operator|*
name|perrno
operator|=
name|i40e_aq_rc_to_posix
argument_list|(
name|status
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

end_unit

