begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2013-2015, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"ixl_pf_qmgr.h"
end_include

begin_function_decl
specifier|static
name|int
name|ixl_pf_qmgr_find_free_contiguous_block
parameter_list|(
name|struct
name|ixl_pf_qmgr
modifier|*
name|qmgr
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|ixl_pf_qmgr_init
parameter_list|(
name|struct
name|ixl_pf_qmgr
modifier|*
name|qmgr
parameter_list|,
name|u16
name|num_queues
parameter_list|)
block|{
if|if
condition|(
name|num_queues
operator|<
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|qmgr
operator|->
name|num_queues
operator|=
name|num_queues
expr_stmt|;
name|qmgr
operator|->
name|qinfo
operator|=
name|malloc
argument_list|(
name|num_queues
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ixl_pf_qmgr_qinfo
argument_list|)
argument_list|,
name|M_IXL
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|qmgr
operator|->
name|qinfo
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixl_pf_qmgr_alloc_contiguous
parameter_list|(
name|struct
name|ixl_pf_qmgr
modifier|*
name|qmgr
parameter_list|,
name|u16
name|num
parameter_list|,
name|struct
name|ixl_pf_qtag
modifier|*
name|qtag
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|avail
decl_stmt|;
name|int
name|block_start
decl_stmt|;
name|u16
name|alloc_size
decl_stmt|;
if|if
condition|(
name|qtag
operator|==
name|NULL
operator|||
name|num
operator|<
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* We have to allocate in power-of-two chunks, so get next power of two */
name|alloc_size
operator|=
operator|(
name|u16
operator|)
name|next_power_of_two
argument_list|(
name|num
argument_list|)
expr_stmt|;
comment|/* Don't try if there aren't enough queues */
name|avail
operator|=
name|ixl_pf_qmgr_get_num_free
argument_list|(
name|qmgr
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail
operator|<
name|alloc_size
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|block_start
operator|=
name|ixl_pf_qmgr_find_free_contiguous_block
argument_list|(
name|qmgr
argument_list|,
name|alloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|block_start
operator|<
literal|0
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* Mark queues as allocated */
for|for
control|(
name|i
operator|=
name|block_start
init|;
name|i
operator|<
name|block_start
operator|+
name|alloc_size
condition|;
name|i
operator|++
control|)
name|qmgr
operator|->
name|qinfo
index|[
name|i
index|]
operator|.
name|allocated
operator|=
name|true
expr_stmt|;
name|bzero
argument_list|(
name|qtag
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|qtag
argument_list|)
argument_list|)
expr_stmt|;
name|qtag
operator|->
name|qmgr
operator|=
name|qmgr
expr_stmt|;
name|qtag
operator|->
name|type
operator|=
name|IXL_PF_QALLOC_CONTIGUOUS
expr_stmt|;
name|qtag
operator|->
name|qidx
index|[
literal|0
index|]
operator|=
name|block_start
expr_stmt|;
name|qtag
operator|->
name|num_allocated
operator|=
name|num
expr_stmt|;
name|qtag
operator|->
name|num_active
operator|=
name|alloc_size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NB: indices is u16 because this is the queue index width used in the Add VSI AQ command  */
end_comment

begin_function
name|int
name|ixl_pf_qmgr_alloc_scattered
parameter_list|(
name|struct
name|ixl_pf_qmgr
modifier|*
name|qmgr
parameter_list|,
name|u16
name|num
parameter_list|,
name|struct
name|ixl_pf_qtag
modifier|*
name|qtag
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|avail
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|u16
name|alloc_size
decl_stmt|;
if|if
condition|(
name|qtag
operator|==
name|NULL
operator|||
name|num
operator|<
literal|1
operator|||
name|num
operator|>
literal|16
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* We have to allocate in power-of-two chunks, so get next power of two */
name|alloc_size
operator|=
operator|(
name|u16
operator|)
name|next_power_of_two
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|avail
operator|=
name|ixl_pf_qmgr_get_num_free
argument_list|(
name|qmgr
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail
operator|<
name|alloc_size
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|bzero
argument_list|(
name|qtag
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|qtag
argument_list|)
argument_list|)
expr_stmt|;
name|qtag
operator|->
name|qmgr
operator|=
name|qmgr
expr_stmt|;
name|qtag
operator|->
name|type
operator|=
name|IXL_PF_QALLOC_SCATTERED
expr_stmt|;
name|qtag
operator|->
name|num_active
operator|=
name|num
expr_stmt|;
name|qtag
operator|->
name|num_allocated
operator|=
name|alloc_size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qmgr
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|qmgr
operator|->
name|qinfo
index|[
name|i
index|]
operator|.
name|allocated
condition|)
block|{
name|qtag
operator|->
name|qidx
index|[
name|count
index|]
operator|=
name|i
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|qmgr
operator|->
name|qinfo
index|[
name|i
index|]
operator|.
name|allocated
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|alloc_size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|// Shouldn't get here
return|return
operator|(
name|EDOOFUS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixl_pf_qmgr_release
parameter_list|(
name|struct
name|ixl_pf_qmgr
modifier|*
name|qmgr
parameter_list|,
name|struct
name|ixl_pf_qtag
modifier|*
name|qtag
parameter_list|)
block|{
name|u16
name|i
decl_stmt|,
name|qidx
decl_stmt|;
if|if
condition|(
name|qtag
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|qtag
operator|->
name|type
operator|==
name|IXL_PF_QALLOC_SCATTERED
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qtag
operator|->
name|num_allocated
condition|;
name|i
operator|++
control|)
block|{
name|qidx
operator|=
name|qtag
operator|->
name|qidx
index|[
name|i
index|]
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|qmgr
operator|->
name|qinfo
index|[
name|qidx
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|qmgr
operator|->
name|qinfo
index|[
name|qidx
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|u16
name|first_index
init|=
name|qtag
operator|->
name|qidx
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
name|first_index
init|;
name|i
operator|<
name|first_index
operator|+
name|qtag
operator|->
name|num_allocated
condition|;
name|i
operator|++
control|)
name|bzero
argument_list|(
operator|&
name|qmgr
operator|->
name|qinfo
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|qmgr
operator|->
name|qinfo
index|[
name|qidx
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|qtag
operator|->
name|qmgr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixl_pf_qmgr_get_num_queues
parameter_list|(
name|struct
name|ixl_pf_qmgr
modifier|*
name|qmgr
parameter_list|)
block|{
return|return
operator|(
name|qmgr
operator|->
name|num_queues
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ERJ: This assumes the info array isn't longer than INT_MAX.  * This assumption might cause a y3k bug or something, I'm sure.  */
end_comment

begin_function
name|int
name|ixl_pf_qmgr_get_num_free
parameter_list|(
name|struct
name|ixl_pf_qmgr
modifier|*
name|qmgr
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|qmgr
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|qmgr
operator|->
name|qinfo
index|[
name|i
index|]
operator|.
name|allocated
condition|)
name|count
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixl_pf_qmgr_get_first_free
parameter_list|(
name|struct
name|ixl_pf_qmgr
modifier|*
name|qmgr
parameter_list|,
name|u16
name|start
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|start
operator|>
name|qmgr
operator|->
name|num_queues
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|qmgr
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qmgr
operator|->
name|qinfo
index|[
name|i
index|]
operator|.
name|allocated
condition|)
continue|continue;
else|else
return|return
operator|(
name|i
operator|)
return|;
block|}
comment|// No free queues
return|return
operator|(
operator|-
name|ENOSPC
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ixl_pf_qmgr_destroy
parameter_list|(
name|struct
name|ixl_pf_qmgr
modifier|*
name|qmgr
parameter_list|)
block|{
name|free
argument_list|(
name|qmgr
operator|->
name|qinfo
argument_list|,
name|M_IXL
argument_list|)
expr_stmt|;
name|qmgr
operator|->
name|qinfo
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixl_pf_qmgr_mark_queue_enabled
parameter_list|(
name|struct
name|ixl_pf_qtag
modifier|*
name|qtag
parameter_list|,
name|u16
name|vsi_qidx
parameter_list|,
name|bool
name|tx
parameter_list|)
block|{
name|MPASS
argument_list|(
name|qtag
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|struct
name|ixl_pf_qmgr
modifier|*
name|qmgr
init|=
name|qtag
operator|->
name|qmgr
decl_stmt|;
name|u16
name|pf_qidx
init|=
name|ixl_pf_qidx_from_vsi_qidx
argument_list|(
name|qtag
argument_list|,
name|vsi_qidx
argument_list|)
decl_stmt|;
if|if
condition|(
name|tx
condition|)
name|qmgr
operator|->
name|qinfo
index|[
name|pf_qidx
index|]
operator|.
name|tx_enabled
operator|=
name|true
expr_stmt|;
else|else
name|qmgr
operator|->
name|qinfo
index|[
name|pf_qidx
index|]
operator|.
name|rx_enabled
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixl_pf_qmgr_mark_queue_disabled
parameter_list|(
name|struct
name|ixl_pf_qtag
modifier|*
name|qtag
parameter_list|,
name|u16
name|vsi_qidx
parameter_list|,
name|bool
name|tx
parameter_list|)
block|{
name|MPASS
argument_list|(
name|qtag
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|struct
name|ixl_pf_qmgr
modifier|*
name|qmgr
init|=
name|qtag
operator|->
name|qmgr
decl_stmt|;
name|u16
name|pf_qidx
init|=
name|ixl_pf_qidx_from_vsi_qidx
argument_list|(
name|qtag
argument_list|,
name|vsi_qidx
argument_list|)
decl_stmt|;
if|if
condition|(
name|tx
condition|)
name|qmgr
operator|->
name|qinfo
index|[
name|pf_qidx
index|]
operator|.
name|tx_enabled
operator|=
name|false
expr_stmt|;
else|else
name|qmgr
operator|->
name|qinfo
index|[
name|pf_qidx
index|]
operator|.
name|rx_enabled
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixl_pf_qmgr_mark_queue_configured
parameter_list|(
name|struct
name|ixl_pf_qtag
modifier|*
name|qtag
parameter_list|,
name|u16
name|vsi_qidx
parameter_list|,
name|bool
name|tx
parameter_list|)
block|{
name|MPASS
argument_list|(
name|qtag
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|struct
name|ixl_pf_qmgr
modifier|*
name|qmgr
init|=
name|qtag
operator|->
name|qmgr
decl_stmt|;
name|u16
name|pf_qidx
init|=
name|ixl_pf_qidx_from_vsi_qidx
argument_list|(
name|qtag
argument_list|,
name|vsi_qidx
argument_list|)
decl_stmt|;
if|if
condition|(
name|tx
condition|)
name|qmgr
operator|->
name|qinfo
index|[
name|pf_qidx
index|]
operator|.
name|tx_configured
operator|=
name|true
expr_stmt|;
else|else
name|qmgr
operator|->
name|qinfo
index|[
name|pf_qidx
index|]
operator|.
name|rx_configured
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|ixl_pf_qmgr_is_queue_enabled
parameter_list|(
name|struct
name|ixl_pf_qtag
modifier|*
name|qtag
parameter_list|,
name|u16
name|vsi_qidx
parameter_list|,
name|bool
name|tx
parameter_list|)
block|{
name|MPASS
argument_list|(
name|qtag
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|struct
name|ixl_pf_qmgr
modifier|*
name|qmgr
init|=
name|qtag
operator|->
name|qmgr
decl_stmt|;
name|u16
name|pf_qidx
init|=
name|ixl_pf_qidx_from_vsi_qidx
argument_list|(
name|qtag
argument_list|,
name|vsi_qidx
argument_list|)
decl_stmt|;
if|if
condition|(
name|tx
condition|)
return|return
operator|(
name|qmgr
operator|->
name|qinfo
index|[
name|pf_qidx
index|]
operator|.
name|tx_enabled
operator|)
return|;
else|else
return|return
operator|(
name|qmgr
operator|->
name|qinfo
index|[
name|pf_qidx
index|]
operator|.
name|rx_enabled
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|ixl_pf_qmgr_is_queue_configured
parameter_list|(
name|struct
name|ixl_pf_qtag
modifier|*
name|qtag
parameter_list|,
name|u16
name|vsi_qidx
parameter_list|,
name|bool
name|tx
parameter_list|)
block|{
name|MPASS
argument_list|(
name|qtag
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|struct
name|ixl_pf_qmgr
modifier|*
name|qmgr
init|=
name|qtag
operator|->
name|qmgr
decl_stmt|;
name|u16
name|pf_qidx
init|=
name|ixl_pf_qidx_from_vsi_qidx
argument_list|(
name|qtag
argument_list|,
name|vsi_qidx
argument_list|)
decl_stmt|;
if|if
condition|(
name|tx
condition|)
return|return
operator|(
name|qmgr
operator|->
name|qinfo
index|[
name|pf_qidx
index|]
operator|.
name|tx_configured
operator|)
return|;
else|else
return|return
operator|(
name|qmgr
operator|->
name|qinfo
index|[
name|pf_qidx
index|]
operator|.
name|rx_configured
operator|)
return|;
block|}
end_function

begin_function
name|u16
name|ixl_pf_qidx_from_vsi_qidx
parameter_list|(
name|struct
name|ixl_pf_qtag
modifier|*
name|qtag
parameter_list|,
name|u16
name|index
parameter_list|)
block|{
name|MPASS
argument_list|(
name|index
operator|<
name|qtag
operator|->
name|num_allocated
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtag
operator|->
name|type
operator|==
name|IXL_PF_QALLOC_CONTIGUOUS
condition|)
return|return
name|qtag
operator|->
name|qidx
index|[
literal|0
index|]
operator|+
name|index
return|;
else|else
return|return
name|qtag
operator|->
name|qidx
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Static Functions */
end_comment

begin_function
specifier|static
name|int
name|ixl_pf_qmgr_find_free_contiguous_block
parameter_list|(
name|struct
name|ixl_pf_qmgr
modifier|*
name|qmgr
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|bool
name|block_started
init|=
name|false
decl_stmt|;
name|int
name|possible_start
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qmgr
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|qmgr
operator|->
name|qinfo
index|[
name|i
index|]
operator|.
name|allocated
condition|)
block|{
if|if
condition|(
operator|!
name|block_started
condition|)
block|{
name|block_started
operator|=
name|true
expr_stmt|;
name|possible_start
operator|=
name|i
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|num
condition|)
return|return
operator|(
name|possible_start
operator|)
return|;
block|}
else|else
block|{
comment|/* this queue is already allocated */
name|block_started
operator|=
name|false
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Can't find a contiguous block of the requested size */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

end_unit

