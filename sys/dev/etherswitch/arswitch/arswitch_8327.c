begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011-2012 Stefan Bethke.  * Copyright (c) 2014 Adrian Chadd.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iic.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iiconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iicbus.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/etherswitch/mdio.h>
end_include

begin_include
include|#
directive|include
file|<dev/etherswitch/etherswitch.h>
end_include

begin_include
include|#
directive|include
file|<dev/etherswitch/arswitch/arswitchreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/etherswitch/arswitch/arswitchvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/etherswitch/arswitch/arswitch_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/etherswitch/arswitch/arswitch_8327.h>
end_include

begin_include
include|#
directive|include
file|"mdio_if.h"
end_include

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_include
include|#
directive|include
file|"etherswitch_if.h"
end_include

begin_function
specifier|static
name|void
name|ar8327_phy_fixup
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|int
name|phy
parameter_list|)
block|{
switch|switch
condition|(
name|sc
operator|->
name|chip_rev
condition|)
block|{
case|case
literal|1
case|:
comment|/* For 100M waveform */
name|arswitch_writedbg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0
argument_list|,
literal|0x02ea
argument_list|)
expr_stmt|;
comment|/* Turn on Gigabit clock */
name|arswitch_writedbg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x3d
argument_list|,
literal|0x68a0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|arswitch_writemmd
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x7
argument_list|,
literal|0x3c
argument_list|)
expr_stmt|;
name|arswitch_writemmd
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x4007
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* fallthrough */
case|case
literal|4
case|:
name|arswitch_writemmd
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x3
argument_list|,
literal|0x800d
argument_list|)
expr_stmt|;
name|arswitch_writemmd
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x4003
argument_list|,
literal|0x803f
argument_list|)
expr_stmt|;
name|arswitch_writedbg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x3d
argument_list|,
literal|0x6860
argument_list|)
expr_stmt|;
name|arswitch_writedbg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x5
argument_list|,
literal|0x2c46
argument_list|)
expr_stmt|;
name|arswitch_writedbg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x3c
argument_list|,
literal|0x6000
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|ar8327_get_pad_cfg
parameter_list|(
name|struct
name|ar8327_pad_cfg
modifier|*
name|cfg
parameter_list|)
block|{
name|uint32_t
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|cfg
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|t
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cfg
operator|->
name|mode
condition|)
block|{
case|case
name|AR8327_PAD_NC
case|:
break|break;
case|case
name|AR8327_PAD_MAC2MAC_MII
case|:
name|t
operator|=
name|AR8327_PAD_MAC_MII_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|rxclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_MAC_MII_RXCLK_SEL
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|txclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_MAC_MII_TXCLK_SEL
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_MAC2MAC_GMII
case|:
name|t
operator|=
name|AR8327_PAD_MAC_GMII_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|rxclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_MAC_GMII_RXCLK_SEL
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|txclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_MAC_GMII_TXCLK_SEL
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_MAC_SGMII
case|:
name|t
operator|=
name|AR8327_PAD_SGMII_EN
expr_stmt|;
comment|/* 		 * WAR for the Qualcomm Atheros AP136 board. 		 * It seems that RGMII TX/RX delay settings needs to be 		 * applied for SGMII mode as well, The ethernet is not 		 * reliable without this. 		 */
name|t
operator||=
name|cfg
operator|->
name|txclk_delay_sel
operator|<<
name|AR8327_PAD_RGMII_TXCLK_DELAY_SEL_S
expr_stmt|;
name|t
operator||=
name|cfg
operator|->
name|rxclk_delay_sel
operator|<<
name|AR8327_PAD_RGMII_RXCLK_DELAY_SEL_S
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|rxclk_delay_en
condition|)
name|t
operator||=
name|AR8327_PAD_RGMII_RXCLK_DELAY_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|txclk_delay_en
condition|)
name|t
operator||=
name|AR8327_PAD_RGMII_TXCLK_DELAY_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|sgmii_delay_en
condition|)
name|t
operator||=
name|AR8327_PAD_SGMII_DELAY_EN
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_MAC2PHY_MII
case|:
name|t
operator|=
name|AR8327_PAD_PHY_MII_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|rxclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_PHY_MII_RXCLK_SEL
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|txclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_PHY_MII_TXCLK_SEL
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_MAC2PHY_GMII
case|:
name|t
operator|=
name|AR8327_PAD_PHY_GMII_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|pipe_rxclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_PHY_GMII_PIPE_RXCLK_SEL
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|rxclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_PHY_GMII_RXCLK_SEL
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|txclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_PHY_GMII_TXCLK_SEL
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_MAC_RGMII
case|:
name|t
operator|=
name|AR8327_PAD_RGMII_EN
expr_stmt|;
name|t
operator||=
name|cfg
operator|->
name|txclk_delay_sel
operator|<<
name|AR8327_PAD_RGMII_TXCLK_DELAY_SEL_S
expr_stmt|;
name|t
operator||=
name|cfg
operator|->
name|rxclk_delay_sel
operator|<<
name|AR8327_PAD_RGMII_RXCLK_DELAY_SEL_S
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|rxclk_delay_en
condition|)
name|t
operator||=
name|AR8327_PAD_RGMII_RXCLK_DELAY_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|txclk_delay_en
condition|)
name|t
operator||=
name|AR8327_PAD_RGMII_TXCLK_DELAY_EN
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_PHY_GMII
case|:
name|t
operator|=
name|AR8327_PAD_PHYX_GMII_EN
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_PHY_RGMII
case|:
name|t
operator|=
name|AR8327_PAD_PHYX_RGMII_EN
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_PHY_MII
case|:
name|t
operator|=
name|AR8327_PAD_PHYX_MII_EN
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map the hard-coded port config from the switch setup to  * the chipset port config (status, duplex, flow, etc.)  */
end_comment

begin_function
specifier|static
name|uint32_t
name|ar8327_get_port_init_status
parameter_list|(
name|struct
name|ar8327_port_cfg
modifier|*
name|cfg
parameter_list|)
block|{
name|uint32_t
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|cfg
operator|->
name|force_link
condition|)
return|return
operator|(
name|AR8X16_PORT_STS_LINK_AUTO
operator|)
return|;
name|t
operator|=
name|AR8X16_PORT_STS_TXMAC
operator||
name|AR8X16_PORT_STS_RXMAC
expr_stmt|;
name|t
operator||=
name|cfg
operator|->
name|duplex
condition|?
name|AR8X16_PORT_STS_DUPLEX
else|:
literal|0
expr_stmt|;
name|t
operator||=
name|cfg
operator|->
name|rxpause
condition|?
name|AR8X16_PORT_STS_RXFLOW
else|:
literal|0
expr_stmt|;
name|t
operator||=
name|cfg
operator|->
name|txpause
condition|?
name|AR8X16_PORT_STS_TXFLOW
else|:
literal|0
expr_stmt|;
switch|switch
condition|(
name|cfg
operator|->
name|speed
condition|)
block|{
case|case
name|AR8327_PORT_SPEED_10
case|:
name|t
operator||=
name|AR8X16_PORT_STS_SPEED_10
expr_stmt|;
break|break;
case|case
name|AR8327_PORT_SPEED_100
case|:
name|t
operator||=
name|AR8X16_PORT_STS_SPEED_100
expr_stmt|;
break|break;
case|case
name|AR8327_PORT_SPEED_1000
case|:
name|t
operator||=
name|AR8X16_PORT_STS_SPEED_1000
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch the port data for the given port.  *  * This goes and does dirty things with the hints space  * to determine what the configuration parameters should be.  *  * Returns 1 if the structure was successfully parsed and  * the contents are valid; 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ar8327_fetch_pdata_port
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ar8327_port_cfg
modifier|*
name|pcfg
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|char
name|sbuf
index|[
literal|128
index|]
decl_stmt|;
comment|/* Check if force_link exists */
name|val
operator|=
literal|0
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"port.%d.force_link"
argument_list|,
name|port
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pcfg
operator|->
name|force_link
operator|=
literal|1
expr_stmt|;
comment|/* force_link is set; let's parse the rest of the fields */
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"port.%d.speed"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|val
condition|)
block|{
case|case
literal|10
case|:
name|pcfg
operator|->
name|speed
operator|=
name|AR8327_PORT_SPEED_10
expr_stmt|;
break|break;
case|case
literal|100
case|:
name|pcfg
operator|->
name|speed
operator|=
name|AR8327_PORT_SPEED_100
expr_stmt|;
break|break;
case|case
literal|1000
case|:
name|pcfg
operator|->
name|speed
operator|=
name|AR8327_PORT_SPEED_1000
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: invalid port %d duplex value (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|port
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"port.%d.duplex"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pcfg
operator|->
name|duplex
operator|=
name|val
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"port.%d.txpause"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pcfg
operator|->
name|txpause
operator|=
name|val
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"port.%d.rxpause"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pcfg
operator|->
name|rxpause
operator|=
name|val
expr_stmt|;
if|#
directive|if
literal|0
block|device_printf(sc->sc_dev, 	    "%s: port %d: speed=%d, duplex=%d, txpause=%d, rxpause=%d\n", 	    __func__, 	    port, 	    pcfg->speed, 	    pcfg->duplex, 	    pcfg->txpause, 	    pcfg->rxpause);
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the pad configuration from the boot hints.  *  * The (mostly optional) fields are:  *  * uint32_t mode;  * uint32_t rxclk_sel;  * uint32_t txclk_sel;  * uint32_t txclk_delay_sel;  * uint32_t rxclk_delay_sel;  * uint32_t txclk_delay_en;  * uint32_t rxclk_delay_en;  * uint32_t sgmii_delay_en;  * uint32_t pipe_rxclk_sel;  *  * If mode isn't in the hints, 0 is returned.  * Else the structure is fleshed out and 1 is returned.  */
end_comment

begin_function
specifier|static
name|int
name|ar8327_fetch_pdata_pad
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ar8327_pad_cfg
modifier|*
name|pc
parameter_list|,
name|int
name|pad
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|char
name|sbuf
index|[
literal|128
index|]
decl_stmt|;
comment|/* Check if mode exists */
name|val
operator|=
literal|0
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"pad.%d.mode"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* assume that 'mode' exists and was found */
name|pc
operator|->
name|mode
operator|=
name|val
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"pad.%d.rxclk_sel"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pc
operator|->
name|rxclk_sel
operator|=
name|val
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"pad.%d.txclk_sel"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pc
operator|->
name|txclk_sel
operator|=
name|val
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"pad.%d.txclk_delay_sel"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pc
operator|->
name|txclk_delay_sel
operator|=
name|val
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"pad.%d.rxclk_delay_sel"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pc
operator|->
name|rxclk_delay_sel
operator|=
name|val
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"pad.%d.txclk_delay_en"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pc
operator|->
name|txclk_delay_en
operator|=
name|val
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"pad.%d.rxclk_delay_en"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pc
operator|->
name|rxclk_delay_en
operator|=
name|val
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"pad.%d.sgmii_delay_en"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pc
operator|->
name|sgmii_delay_en
operator|=
name|val
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"pad.%d.pipe_rxclk_sel"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pc
operator|->
name|pipe_rxclk_sel
operator|=
name|val
expr_stmt|;
if|#
directive|if
literal|0
block|device_printf(sc->sc_dev, 	    "%s: pad %d: mode=%d, rxclk_sel=%d, txclk_sel=%d, " 	    "txclk_delay_sel=%d, rxclk_delay_sel=%d, txclk_delay_en=%d, " 	    "rxclk_enable_en=%d, sgmii_delay_en=%d, pipe_rxclk_sel=%d\n", 	    __func__, 	    pad, 	    pc->mode, 	    pc->rxclk_sel, 	    pc->txclk_sel, 	    pc->txclk_delay_sel, 	    pc->rxclk_delay_sel, 	    pc->txclk_delay_en, 	    pc->rxclk_delay_en, 	    pc->sgmii_delay_en, 	    pc->pipe_rxclk_sel);
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch the SGMII configuration block from the boot hints.  */
end_comment

begin_function
specifier|static
name|int
name|ar8327_fetch_pdata_sgmii
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ar8327_sgmii_cfg
modifier|*
name|scfg
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
comment|/* sgmii_ctrl */
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"sgmii.ctrl"
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|scfg
operator|->
name|sgmii_ctrl
operator|=
name|val
expr_stmt|;
comment|/* serdes_aen */
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"sgmii.serdes_aen"
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|scfg
operator|->
name|serdes_aen
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch the LED configuration from the boot hints.  */
end_comment

begin_function
specifier|static
name|int
name|ar8327_fetch_pdata_led
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ar8327_led_cfg
modifier|*
name|lcfg
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"led.ctrl0"
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lcfg
operator|->
name|led_ctrl0
operator|=
name|val
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"led.ctrl1"
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lcfg
operator|->
name|led_ctrl1
operator|=
name|val
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"led.ctrl2"
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lcfg
operator|->
name|led_ctrl2
operator|=
name|val
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"led.ctrl3"
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lcfg
operator|->
name|led_ctrl3
operator|=
name|val
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"led.open_drain"
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lcfg
operator|->
name|open_drain
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialise the ar8327 specific hardware features from  * the hints provided in the boot environment.  */
end_comment

begin_function
specifier|static
name|int
name|ar8327_init_pdata
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ar8327_pad_cfg
name|pc
decl_stmt|;
name|struct
name|ar8327_port_cfg
name|port_cfg
decl_stmt|;
name|struct
name|ar8327_sgmii_cfg
name|scfg
decl_stmt|;
name|struct
name|ar8327_led_cfg
name|lcfg
decl_stmt|;
name|uint32_t
name|t
decl_stmt|,
name|new_pos
decl_stmt|,
name|pos
decl_stmt|;
comment|/* Port 0 */
name|bzero
argument_list|(
operator|&
name|port_cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|port_cfg
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ar8327
operator|.
name|port0_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ar8327_fetch_pdata_port
argument_list|(
name|sc
argument_list|,
operator|&
name|port_cfg
argument_list|,
literal|0
argument_list|)
condition|)
name|sc
operator|->
name|ar8327
operator|.
name|port0_status
operator|=
name|ar8327_get_port_init_status
argument_list|(
operator|&
name|port_cfg
argument_list|)
expr_stmt|;
comment|/* Port 6 */
name|bzero
argument_list|(
operator|&
name|port_cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|port_cfg
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ar8327
operator|.
name|port6_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ar8327_fetch_pdata_port
argument_list|(
name|sc
argument_list|,
operator|&
name|port_cfg
argument_list|,
literal|6
argument_list|)
condition|)
name|sc
operator|->
name|ar8327
operator|.
name|port6_status
operator|=
name|ar8327_get_port_init_status
argument_list|(
operator|&
name|port_cfg
argument_list|)
expr_stmt|;
comment|/* Pad 0 */
name|bzero
argument_list|(
operator|&
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ar8327_fetch_pdata_pad
argument_list|(
name|sc
argument_list|,
operator|&
name|pc
argument_list|,
literal|0
argument_list|)
condition|)
name|t
operator|=
name|ar8327_get_pad_cfg
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (AR8X16_IS_SWITCH(sc, AR8337)) 			t |= AR8337_PAD_MAC06_EXCHANGE_EN;
endif|#
directive|endif
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PAD0_MODE
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Pad 5 */
name|bzero
argument_list|(
operator|&
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ar8327_fetch_pdata_pad
argument_list|(
name|sc
argument_list|,
operator|&
name|pc
argument_list|,
literal|5
argument_list|)
condition|)
name|t
operator|=
name|ar8327_get_pad_cfg
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PAD5_MODE
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Pad 6 */
name|bzero
argument_list|(
operator|&
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ar8327_fetch_pdata_pad
argument_list|(
name|sc
argument_list|,
operator|&
name|pc
argument_list|,
literal|6
argument_list|)
condition|)
name|t
operator|=
name|ar8327_get_pad_cfg
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PAD6_MODE
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pos
operator|=
name|arswitch_readreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_POWER_ON_STRIP
argument_list|)
expr_stmt|;
name|new_pos
operator|=
name|pos
expr_stmt|;
comment|/* XXX LED config */
name|bzero
argument_list|(
operator|&
name|lcfg
argument_list|,
sizeof|sizeof
argument_list|(
name|lcfg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar8327_fetch_pdata_led
argument_list|(
name|sc
argument_list|,
operator|&
name|lcfg
argument_list|)
condition|)
block|{
if|if
condition|(
name|lcfg
operator|.
name|open_drain
condition|)
name|new_pos
operator||=
name|AR8327_POWER_ON_STRIP_LED_OPEN_EN
expr_stmt|;
else|else
name|new_pos
operator|&=
operator|~
name|AR8327_POWER_ON_STRIP_LED_OPEN_EN
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_LED_CTRL0
argument_list|,
name|lcfg
operator|.
name|led_ctrl0
argument_list|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_LED_CTRL1
argument_list|,
name|lcfg
operator|.
name|led_ctrl1
argument_list|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_LED_CTRL2
argument_list|,
name|lcfg
operator|.
name|led_ctrl2
argument_list|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_LED_CTRL3
argument_list|,
name|lcfg
operator|.
name|led_ctrl3
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_pos
operator|!=
name|pos
condition|)
name|new_pos
operator||=
name|AR8327_POWER_ON_STRIP_POWER_ON_SEL
expr_stmt|;
block|}
comment|/* SGMII config */
name|bzero
argument_list|(
operator|&
name|scfg
argument_list|,
sizeof|sizeof
argument_list|(
name|scfg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar8327_fetch_pdata_sgmii
argument_list|(
name|sc
argument_list|,
operator|&
name|scfg
argument_list|)
condition|)
block|{
name|t
operator|=
name|scfg
operator|.
name|sgmii_ctrl
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chip_rev
operator|==
literal|1
condition|)
name|t
operator||=
name|AR8327_SGMII_CTRL_EN_PLL
operator||
name|AR8327_SGMII_CTRL_EN_RX
operator||
name|AR8327_SGMII_CTRL_EN_TX
expr_stmt|;
else|else
name|t
operator|&=
operator|~
operator|(
name|AR8327_SGMII_CTRL_EN_PLL
operator||
name|AR8327_SGMII_CTRL_EN_RX
operator||
name|AR8327_SGMII_CTRL_EN_TX
operator|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_SGMII_CTRL
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|scfg
operator|.
name|serdes_aen
condition|)
name|new_pos
operator|&=
operator|~
name|AR8327_POWER_ON_STRIP_SERDES_AEN
expr_stmt|;
else|else
name|new_pos
operator||=
name|AR8327_POWER_ON_STRIP_SERDES_AEN
expr_stmt|;
block|}
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_POWER_ON_STRIP
argument_list|,
name|new_pos
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_hw_setup
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* pdata fetch and setup */
name|err
operator|=
name|ar8327_init_pdata
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* XXX init leds */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR8327_NUM_PHYS
condition|;
name|i
operator|++
control|)
block|{
comment|/* phy fixup */
name|ar8327_phy_fixup
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* start PHY autonegotiation? */
comment|/* XXX is this done as part of the normal PHY setup? */
block|}
empty_stmt|;
comment|/* Let things settle */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialise other global values, for the AR8327.  */
end_comment

begin_function
specifier|static
name|int
name|ar8327_hw_global_setup
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|t
decl_stmt|;
comment|/* enable CPU port and disable mirror port */
name|t
operator|=
name|AR8327_FWD_CTRL0_CPU_PORT_EN
operator||
name|AR8327_FWD_CTRL0_MIRROR_PORT
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_FWD_CTRL0
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* forward multicast and broadcast frames to CPU */
name|t
operator|=
operator|(
name|AR8327_PORTS_ALL
operator|<<
name|AR8327_FWD_CTRL1_UC_FLOOD_S
operator|)
operator||
operator|(
name|AR8327_PORTS_ALL
operator|<<
name|AR8327_FWD_CTRL1_MC_FLOOD_S
operator|)
operator||
operator|(
name|AR8327_PORTS_ALL
operator|<<
name|AR8327_FWD_CTRL1_BC_FLOOD_S
operator|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_FWD_CTRL1
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* enable jumbo frames */
comment|/* XXX need to macro-shift the value! */
name|arswitch_modifyreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_MAX_FRAME_SIZE
argument_list|,
name|AR8327_MAX_FRAME_SIZE_MTU
argument_list|,
literal|9018
operator|+
literal|8
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Enable MIB counters */
name|arswitch_modifyreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_MODULE_EN
argument_list|,
name|AR8327_MODULE_EN_MIB
argument_list|,
name|AR8327_MODULE_EN_MIB
argument_list|)
expr_stmt|;
comment|/* Set the right number of ports */
name|sc
operator|->
name|info
operator|.
name|es_nports
operator|=
literal|6
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Port setup.  */
end_comment

begin_function
specifier|static
name|void
name|ar8327_port_init
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|uint32_t
name|t
decl_stmt|;
if|if
condition|(
name|port
operator|==
name|AR8X16_PORT_CPU
condition|)
name|t
operator|=
name|sc
operator|->
name|ar8327
operator|.
name|port0_status
expr_stmt|;
elseif|else
if|if
condition|(
name|port
operator|==
literal|6
condition|)
name|t
operator|=
name|sc
operator|->
name|ar8327
operator|.
name|port6_status
expr_stmt|;
else|else
name|t
operator|=
name|AR8X16_PORT_STS_LINK_AUTO
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_STATUS
argument_list|(
name|port
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_HEADER
argument_list|(
name|port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Default to 1 port group. 	 */
name|t
operator|=
literal|1
operator|<<
name|AR8327_PORT_VLAN0_DEF_SVID_S
expr_stmt|;
name|t
operator||=
literal|1
operator|<<
name|AR8327_PORT_VLAN0_DEF_CVID_S
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_VLAN0
argument_list|(
name|port
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|AR8327_PORT_VLAN1_OUT_MODE_UNTOUCH
operator|<<
name|AR8327_PORT_VLAN1_OUT_MODE_S
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_VLAN1
argument_list|(
name|port
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* 	 * This doesn't configure any ports which this port can "see". 	 * bits 0-6 control which ports a frame coming into this port 	 * can be sent out to. 	 * 	 * So by doing this, we're making it impossible to send frames out 	 * to that port. 	 */
name|t
operator|=
name|AR8327_PORT_LOOKUP_LEARN
expr_stmt|;
name|t
operator||=
name|AR8X16_PORT_CTRL_STATE_FORWARD
operator|<<
name|AR8327_PORT_LOOKUP_STATE_S
expr_stmt|;
comment|/* So this allows traffic to any port except ourselves */
name|t
operator||=
operator|(
literal|0x3f
operator|&
operator|~
operator|(
literal|1
operator|<<
name|port
operator|)
operator|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_LOOKUP
argument_list|(
name|port
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_port_vlan_setup
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|etherswitch_port_t
modifier|*
name|p
parameter_list|)
block|{
comment|/* XXX stub for now */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_port_vlan_get
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|etherswitch_port_t
modifier|*
name|p
parameter_list|)
block|{
comment|/* XXX stub for now */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar8327_reset_vlans
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|mode
decl_stmt|,
name|t
decl_stmt|;
comment|/* 	 * Disable mirroring. 	 */
name|arswitch_modifyreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_FWD_CTRL0
argument_list|,
name|AR8327_FWD_CTRL0_MIRROR_PORT
argument_list|,
operator|(
literal|0xF
operator|<<
name|AR8327_FWD_CTRL0_MIRROR_PORT_S
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * For now, let's default to one portgroup, just so traffic 	 * flows.  All ports can see other ports. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR8327_NUM_PORTS
condition|;
name|i
operator|++
control|)
block|{
comment|/* set pvid = 1; there's only one vlangroup */
name|t
operator|=
literal|1
operator|<<
name|AR8327_PORT_VLAN0_DEF_SVID_S
expr_stmt|;
name|t
operator||=
literal|1
operator|<<
name|AR8327_PORT_VLAN0_DEF_CVID_S
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_VLAN0
argument_list|(
name|i
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* set egress == out_keep */
name|mode
operator|=
name|AR8327_PORT_VLAN1_OUT_MODE_UNTOUCH
expr_stmt|;
name|t
operator|=
name|AR8327_PORT_VLAN1_PORT_VLAN_PROP
expr_stmt|;
name|t
operator||=
name|mode
operator|<<
name|AR8327_PORT_VLAN1_OUT_MODE_S
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_VLAN1
argument_list|(
name|i
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Ports can see other ports */
name|t
operator|=
operator|(
literal|0x3f
operator|&
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
expr_stmt|;
comment|/* all ports besides us */
name|t
operator||=
name|AR8327_PORT_LOOKUP_LEARN
expr_stmt|;
comment|/* in_port_only, forward */
name|t
operator||=
name|AR8X16_PORT_VLAN_MODE_PORT_ONLY
operator|<<
name|AR8327_PORT_LOOKUP_IN_MODE_S
expr_stmt|;
name|t
operator||=
name|AR8X16_PORT_CTRL_STATE_FORWARD
operator|<<
name|AR8327_PORT_LOOKUP_STATE_S
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_LOOKUP
argument_list|(
name|i
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* 		 * Disable port mirroring entirely. 		 */
name|arswitch_modifyreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_LOOKUP
argument_list|(
name|i
argument_list|)
argument_list|,
name|AR8327_PORT_LOOKUP_ING_MIRROR_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arswitch_modifyreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_HOL_CTRL1
argument_list|(
name|i
argument_list|)
argument_list|,
name|AR8327_PORT_HOL_CTRL1_EG_MIRROR_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_vlan_getvgroup
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|etherswitch_vlangroup_t
modifier|*
name|vg
parameter_list|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_vlan_setvgroup
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|etherswitch_vlangroup_t
modifier|*
name|vg
parameter_list|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_get_pvid
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|int
name|port
parameter_list|,
name|int
modifier|*
name|pvid
parameter_list|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_set_pvid
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|pvid
parameter_list|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_atu_flush
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|arswitch_waitreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_ATU_FUNC
argument_list|,
name|AR8327_ATU_FUNC_BUSY
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: waitreg failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_ATU_FUNC
argument_list|,
name|AR8327_ATU_FUNC_OP_FLUSH
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ar8327_attach
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|hal
operator|.
name|arswitch_hw_setup
operator|=
name|ar8327_hw_setup
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_hw_global_setup
operator|=
name|ar8327_hw_global_setup
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_port_init
operator|=
name|ar8327_port_init
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_port_vlan_setup
operator|=
name|ar8327_port_vlan_setup
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_port_vlan_get
operator|=
name|ar8327_port_vlan_get
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_vlan_init_hw
operator|=
name|ar8327_reset_vlans
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_vlan_getvgroup
operator|=
name|ar8327_vlan_getvgroup
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_vlan_setvgroup
operator|=
name|ar8327_vlan_setvgroup
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_vlan_get_pvid
operator|=
name|ar8327_get_pvid
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_vlan_set_pvid
operator|=
name|ar8327_set_pvid
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_atu_flush
operator|=
name|ar8327_atu_flush
expr_stmt|;
comment|/* Set the switch vlan capabilities. */
name|sc
operator|->
name|info
operator|.
name|es_vlan_caps
operator|=
name|ETHERSWITCH_VLAN_DOT1Q
operator||
name|ETHERSWITCH_VLAN_PORT
operator||
name|ETHERSWITCH_VLAN_DOUBLE_TAG
expr_stmt|;
name|sc
operator|->
name|info
operator|.
name|es_nvlangroups
operator|=
name|AR8X16_MAX_VLANS
expr_stmt|;
block|}
end_function

end_unit

