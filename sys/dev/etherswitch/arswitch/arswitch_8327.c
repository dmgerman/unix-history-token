begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011-2012 Stefan Bethke.  * Copyright (c) 2014 Adrian Chadd.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iic.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iiconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iicbus.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mdio/mdio.h>
end_include

begin_include
include|#
directive|include
file|<dev/etherswitch/etherswitch.h>
end_include

begin_include
include|#
directive|include
file|<dev/etherswitch/arswitch/arswitchreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/etherswitch/arswitch/arswitchvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/etherswitch/arswitch/arswitch_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/etherswitch/arswitch/arswitch_phy.h>
end_include

begin_include
include|#
directive|include
file|<dev/etherswitch/arswitch/arswitch_vlans.h>
end_include

begin_include
include|#
directive|include
file|<dev/etherswitch/arswitch/arswitch_8327.h>
end_include

begin_include
include|#
directive|include
file|"mdio_if.h"
end_include

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_include
include|#
directive|include
file|"etherswitch_if.h"
end_include

begin_comment
comment|/*  * AR8327 TODO:  *  * There should be a default hardware setup hint set for the default  * switch config.  Otherwise the default is "all ports in one vlangroup",  * which means both CPU ports can see each other and that will quickly  * lead to traffic storms/loops.  */
end_comment

begin_function
specifier|static
name|int
name|ar8327_vlan_op
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|op
parameter_list|,
name|uint32_t
name|vid
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * Wait for the "done" bit to finish. 	 */
if|if
condition|(
name|arswitch_waitreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_VTU_FUNC1
argument_list|,
name|AR8327_VTU_FUNC1_BUSY
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* 	 * If it's a "load" operation, then ensure 'data' is loaded 	 * in first. 	 */
if|if
condition|(
operator|(
name|op
operator|&
name|AR8327_VTU_FUNC1_OP
operator|)
operator|==
name|AR8327_VTU_FUNC1_OP_LOAD
condition|)
block|{
name|err
operator|=
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_VTU_FUNC0
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 	 * Set the VID. 	 */
name|op
operator||=
operator|(
operator|(
name|vid
operator|&
literal|0xfff
operator|)
operator|<<
name|AR8327_VTU_FUNC1_VID_S
operator|)
expr_stmt|;
comment|/* 	 * Set busy bit to start loading in the command. 	 */
name|op
operator||=
name|AR8327_VTU_FUNC1_BUSY
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_VTU_FUNC1
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* 	 * Finally - wait for it to load. 	 */
if|if
condition|(
name|arswitch_waitreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_VTU_FUNC1
argument_list|,
name|AR8327_VTU_FUNC1_BUSY
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar8327_phy_fixup
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|int
name|phy
parameter_list|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called; phy=%d; chiprev=%d\n"
argument_list|,
name|__func__
argument_list|,
name|phy
argument_list|,
name|sc
operator|->
name|chip_rev
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|chip_rev
condition|)
block|{
case|case
literal|1
case|:
comment|/* For 100M waveform */
name|arswitch_writedbg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0
argument_list|,
literal|0x02ea
argument_list|)
expr_stmt|;
comment|/* Turn on Gigabit clock */
name|arswitch_writedbg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x3d
argument_list|,
literal|0x68a0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|arswitch_writemmd
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x7
argument_list|,
literal|0x3c
argument_list|)
expr_stmt|;
name|arswitch_writemmd
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x4007
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* fallthrough */
case|case
literal|4
case|:
name|arswitch_writemmd
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x3
argument_list|,
literal|0x800d
argument_list|)
expr_stmt|;
name|arswitch_writemmd
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x4003
argument_list|,
literal|0x803f
argument_list|)
expr_stmt|;
name|arswitch_writedbg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x3d
argument_list|,
literal|0x6860
argument_list|)
expr_stmt|;
name|arswitch_writedbg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x5
argument_list|,
literal|0x2c46
argument_list|)
expr_stmt|;
name|arswitch_writedbg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x3c
argument_list|,
literal|0x6000
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|ar8327_get_pad_cfg
parameter_list|(
name|struct
name|ar8327_pad_cfg
modifier|*
name|cfg
parameter_list|)
block|{
name|uint32_t
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|cfg
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|t
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cfg
operator|->
name|mode
condition|)
block|{
case|case
name|AR8327_PAD_NC
case|:
break|break;
case|case
name|AR8327_PAD_MAC2MAC_MII
case|:
name|t
operator|=
name|AR8327_PAD_MAC_MII_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|rxclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_MAC_MII_RXCLK_SEL
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|txclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_MAC_MII_TXCLK_SEL
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_MAC2MAC_GMII
case|:
name|t
operator|=
name|AR8327_PAD_MAC_GMII_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|rxclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_MAC_GMII_RXCLK_SEL
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|txclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_MAC_GMII_TXCLK_SEL
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_MAC_SGMII
case|:
name|t
operator|=
name|AR8327_PAD_SGMII_EN
expr_stmt|;
comment|/* 		 * WAR for the Qualcomm Atheros AP136 board. 		 * It seems that RGMII TX/RX delay settings needs to be 		 * applied for SGMII mode as well, The ethernet is not 		 * reliable without this. 		 */
name|t
operator||=
name|cfg
operator|->
name|txclk_delay_sel
operator|<<
name|AR8327_PAD_RGMII_TXCLK_DELAY_SEL_S
expr_stmt|;
name|t
operator||=
name|cfg
operator|->
name|rxclk_delay_sel
operator|<<
name|AR8327_PAD_RGMII_RXCLK_DELAY_SEL_S
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|rxclk_delay_en
condition|)
name|t
operator||=
name|AR8327_PAD_RGMII_RXCLK_DELAY_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|txclk_delay_en
condition|)
name|t
operator||=
name|AR8327_PAD_RGMII_TXCLK_DELAY_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|sgmii_delay_en
condition|)
name|t
operator||=
name|AR8327_PAD_SGMII_DELAY_EN
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_MAC2PHY_MII
case|:
name|t
operator|=
name|AR8327_PAD_PHY_MII_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|rxclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_PHY_MII_RXCLK_SEL
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|txclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_PHY_MII_TXCLK_SEL
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_MAC2PHY_GMII
case|:
name|t
operator|=
name|AR8327_PAD_PHY_GMII_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|pipe_rxclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_PHY_GMII_PIPE_RXCLK_SEL
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|rxclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_PHY_GMII_RXCLK_SEL
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|txclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_PHY_GMII_TXCLK_SEL
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_MAC_RGMII
case|:
name|t
operator|=
name|AR8327_PAD_RGMII_EN
expr_stmt|;
name|t
operator||=
name|cfg
operator|->
name|txclk_delay_sel
operator|<<
name|AR8327_PAD_RGMII_TXCLK_DELAY_SEL_S
expr_stmt|;
name|t
operator||=
name|cfg
operator|->
name|rxclk_delay_sel
operator|<<
name|AR8327_PAD_RGMII_RXCLK_DELAY_SEL_S
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|rxclk_delay_en
condition|)
name|t
operator||=
name|AR8327_PAD_RGMII_RXCLK_DELAY_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|txclk_delay_en
condition|)
name|t
operator||=
name|AR8327_PAD_RGMII_TXCLK_DELAY_EN
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_PHY_GMII
case|:
name|t
operator|=
name|AR8327_PAD_PHYX_GMII_EN
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_PHY_RGMII
case|:
name|t
operator|=
name|AR8327_PAD_PHYX_RGMII_EN
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_PHY_MII
case|:
name|t
operator|=
name|AR8327_PAD_PHYX_MII_EN
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map the hard-coded port config from the switch setup to  * the chipset port config (status, duplex, flow, etc.)  */
end_comment

begin_function
specifier|static
name|uint32_t
name|ar8327_get_port_init_status
parameter_list|(
name|struct
name|ar8327_port_cfg
modifier|*
name|cfg
parameter_list|)
block|{
name|uint32_t
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|cfg
operator|->
name|force_link
condition|)
return|return
operator|(
name|AR8X16_PORT_STS_LINK_AUTO
operator|)
return|;
name|t
operator|=
name|AR8X16_PORT_STS_TXMAC
operator||
name|AR8X16_PORT_STS_RXMAC
expr_stmt|;
name|t
operator||=
name|cfg
operator|->
name|duplex
condition|?
name|AR8X16_PORT_STS_DUPLEX
else|:
literal|0
expr_stmt|;
name|t
operator||=
name|cfg
operator|->
name|rxpause
condition|?
name|AR8X16_PORT_STS_RXFLOW
else|:
literal|0
expr_stmt|;
name|t
operator||=
name|cfg
operator|->
name|txpause
condition|?
name|AR8X16_PORT_STS_TXFLOW
else|:
literal|0
expr_stmt|;
switch|switch
condition|(
name|cfg
operator|->
name|speed
condition|)
block|{
case|case
name|AR8327_PORT_SPEED_10
case|:
name|t
operator||=
name|AR8X16_PORT_STS_SPEED_10
expr_stmt|;
break|break;
case|case
name|AR8327_PORT_SPEED_100
case|:
name|t
operator||=
name|AR8X16_PORT_STS_SPEED_100
expr_stmt|;
break|break;
case|case
name|AR8327_PORT_SPEED_1000
case|:
name|t
operator||=
name|AR8X16_PORT_STS_SPEED_1000
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch the port data for the given port.  *  * This goes and does dirty things with the hints space  * to determine what the configuration parameters should be.  *  * Returns 1 if the structure was successfully parsed and  * the contents are valid; 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ar8327_fetch_pdata_port
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ar8327_port_cfg
modifier|*
name|pcfg
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|char
name|sbuf
index|[
literal|128
index|]
decl_stmt|;
comment|/* Check if force_link exists */
name|val
operator|=
literal|0
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"port.%d.force_link"
argument_list|,
name|port
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pcfg
operator|->
name|force_link
operator|=
literal|1
expr_stmt|;
comment|/* force_link is set; let's parse the rest of the fields */
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"port.%d.speed"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|val
condition|)
block|{
case|case
literal|10
case|:
name|pcfg
operator|->
name|speed
operator|=
name|AR8327_PORT_SPEED_10
expr_stmt|;
break|break;
case|case
literal|100
case|:
name|pcfg
operator|->
name|speed
operator|=
name|AR8327_PORT_SPEED_100
expr_stmt|;
break|break;
case|case
literal|1000
case|:
name|pcfg
operator|->
name|speed
operator|=
name|AR8327_PORT_SPEED_1000
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: invalid port %d duplex value (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|port
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"port.%d.duplex"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pcfg
operator|->
name|duplex
operator|=
name|val
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"port.%d.txpause"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pcfg
operator|->
name|txpause
operator|=
name|val
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"port.%d.rxpause"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pcfg
operator|->
name|rxpause
operator|=
name|val
expr_stmt|;
if|#
directive|if
literal|1
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: port %d: speed=%d, duplex=%d, txpause=%d, rxpause=%d\n"
argument_list|,
name|__func__
argument_list|,
name|port
argument_list|,
name|pcfg
operator|->
name|speed
argument_list|,
name|pcfg
operator|->
name|duplex
argument_list|,
name|pcfg
operator|->
name|txpause
argument_list|,
name|pcfg
operator|->
name|rxpause
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the pad configuration from the boot hints.  *  * The (mostly optional) fields are:  *  * uint32_t mode;  * uint32_t rxclk_sel;  * uint32_t txclk_sel;  * uint32_t txclk_delay_sel;  * uint32_t rxclk_delay_sel;  * uint32_t txclk_delay_en;  * uint32_t rxclk_delay_en;  * uint32_t sgmii_delay_en;  * uint32_t pipe_rxclk_sel;  *  * If mode isn't in the hints, 0 is returned.  * Else the structure is fleshed out and 1 is returned.  */
end_comment

begin_function
specifier|static
name|int
name|ar8327_fetch_pdata_pad
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ar8327_pad_cfg
modifier|*
name|pc
parameter_list|,
name|int
name|pad
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|char
name|sbuf
index|[
literal|128
index|]
decl_stmt|;
comment|/* Check if mode exists */
name|val
operator|=
literal|0
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"pad.%d.mode"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* assume that 'mode' exists and was found */
name|pc
operator|->
name|mode
operator|=
name|val
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"pad.%d.rxclk_sel"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pc
operator|->
name|rxclk_sel
operator|=
name|val
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"pad.%d.txclk_sel"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pc
operator|->
name|txclk_sel
operator|=
name|val
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"pad.%d.txclk_delay_sel"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pc
operator|->
name|txclk_delay_sel
operator|=
name|val
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"pad.%d.rxclk_delay_sel"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pc
operator|->
name|rxclk_delay_sel
operator|=
name|val
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"pad.%d.txclk_delay_en"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pc
operator|->
name|txclk_delay_en
operator|=
name|val
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"pad.%d.rxclk_delay_en"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pc
operator|->
name|rxclk_delay_en
operator|=
name|val
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"pad.%d.sgmii_delay_en"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pc
operator|->
name|sgmii_delay_en
operator|=
name|val
expr_stmt|;
name|snprintf
argument_list|(
name|sbuf
argument_list|,
literal|128
argument_list|,
literal|"pad.%d.pipe_rxclk_sel"
argument_list|,
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sbuf
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|pc
operator|->
name|pipe_rxclk_sel
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: pad %d: mode=%d, rxclk_sel=%d, txclk_sel=%d, "
literal|"txclk_delay_sel=%d, rxclk_delay_sel=%d, txclk_delay_en=%d, "
literal|"rxclk_enable_en=%d, sgmii_delay_en=%d, pipe_rxclk_sel=%d\n"
argument_list|,
name|__func__
argument_list|,
name|pad
argument_list|,
name|pc
operator|->
name|mode
argument_list|,
name|pc
operator|->
name|rxclk_sel
argument_list|,
name|pc
operator|->
name|txclk_sel
argument_list|,
name|pc
operator|->
name|txclk_delay_sel
argument_list|,
name|pc
operator|->
name|rxclk_delay_sel
argument_list|,
name|pc
operator|->
name|txclk_delay_en
argument_list|,
name|pc
operator|->
name|rxclk_delay_en
argument_list|,
name|pc
operator|->
name|sgmii_delay_en
argument_list|,
name|pc
operator|->
name|pipe_rxclk_sel
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch the SGMII configuration block from the boot hints.  */
end_comment

begin_function
specifier|static
name|int
name|ar8327_fetch_pdata_sgmii
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ar8327_sgmii_cfg
modifier|*
name|scfg
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
comment|/* sgmii_ctrl */
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"sgmii.ctrl"
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|scfg
operator|->
name|sgmii_ctrl
operator|=
name|val
expr_stmt|;
comment|/* serdes_aen */
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"sgmii.serdes_aen"
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|scfg
operator|->
name|serdes_aen
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch the LED configuration from the boot hints.  */
end_comment

begin_function
specifier|static
name|int
name|ar8327_fetch_pdata_led
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ar8327_led_cfg
modifier|*
name|lcfg
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"led.ctrl0"
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lcfg
operator|->
name|led_ctrl0
operator|=
name|val
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"led.ctrl1"
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lcfg
operator|->
name|led_ctrl1
operator|=
name|val
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"led.ctrl2"
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lcfg
operator|->
name|led_ctrl2
operator|=
name|val
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"led.ctrl3"
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lcfg
operator|->
name|led_ctrl3
operator|=
name|val
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"led.open_drain"
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lcfg
operator|->
name|open_drain
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialise the ar8327 specific hardware features from  * the hints provided in the boot environment.  */
end_comment

begin_function
specifier|static
name|int
name|ar8327_init_pdata
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ar8327_pad_cfg
name|pc
decl_stmt|;
name|struct
name|ar8327_port_cfg
name|port_cfg
decl_stmt|;
name|struct
name|ar8327_sgmii_cfg
name|scfg
decl_stmt|;
name|struct
name|ar8327_led_cfg
name|lcfg
decl_stmt|;
name|uint32_t
name|t
decl_stmt|,
name|new_pos
decl_stmt|,
name|pos
decl_stmt|;
comment|/* Port 0 */
name|bzero
argument_list|(
operator|&
name|port_cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|port_cfg
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ar8327
operator|.
name|port0_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ar8327_fetch_pdata_port
argument_list|(
name|sc
argument_list|,
operator|&
name|port_cfg
argument_list|,
literal|0
argument_list|)
condition|)
name|sc
operator|->
name|ar8327
operator|.
name|port0_status
operator|=
name|ar8327_get_port_init_status
argument_list|(
operator|&
name|port_cfg
argument_list|)
expr_stmt|;
comment|/* Port 6 */
name|bzero
argument_list|(
operator|&
name|port_cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|port_cfg
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ar8327
operator|.
name|port6_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ar8327_fetch_pdata_port
argument_list|(
name|sc
argument_list|,
operator|&
name|port_cfg
argument_list|,
literal|6
argument_list|)
condition|)
name|sc
operator|->
name|ar8327
operator|.
name|port6_status
operator|=
name|ar8327_get_port_init_status
argument_list|(
operator|&
name|port_cfg
argument_list|)
expr_stmt|;
comment|/* Pad 0 */
name|bzero
argument_list|(
operator|&
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ar8327_fetch_pdata_pad
argument_list|(
name|sc
argument_list|,
operator|&
name|pc
argument_list|,
literal|0
argument_list|)
condition|)
name|t
operator|=
name|ar8327_get_pad_cfg
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (AR8X16_IS_SWITCH(sc, AR8337)) 			t |= AR8337_PAD_MAC06_EXCHANGE_EN;
endif|#
directive|endif
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PAD0_MODE
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Pad 5 */
name|bzero
argument_list|(
operator|&
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ar8327_fetch_pdata_pad
argument_list|(
name|sc
argument_list|,
operator|&
name|pc
argument_list|,
literal|5
argument_list|)
condition|)
name|t
operator|=
name|ar8327_get_pad_cfg
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PAD5_MODE
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Pad 6 */
name|bzero
argument_list|(
operator|&
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ar8327_fetch_pdata_pad
argument_list|(
name|sc
argument_list|,
operator|&
name|pc
argument_list|,
literal|6
argument_list|)
condition|)
name|t
operator|=
name|ar8327_get_pad_cfg
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PAD6_MODE
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pos
operator|=
name|arswitch_readreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_POWER_ON_STRIP
argument_list|)
expr_stmt|;
name|new_pos
operator|=
name|pos
expr_stmt|;
comment|/* XXX LED config */
name|bzero
argument_list|(
operator|&
name|lcfg
argument_list|,
sizeof|sizeof
argument_list|(
name|lcfg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar8327_fetch_pdata_led
argument_list|(
name|sc
argument_list|,
operator|&
name|lcfg
argument_list|)
condition|)
block|{
if|if
condition|(
name|lcfg
operator|.
name|open_drain
condition|)
name|new_pos
operator||=
name|AR8327_POWER_ON_STRIP_LED_OPEN_EN
expr_stmt|;
else|else
name|new_pos
operator|&=
operator|~
name|AR8327_POWER_ON_STRIP_LED_OPEN_EN
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_LED_CTRL0
argument_list|,
name|lcfg
operator|.
name|led_ctrl0
argument_list|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_LED_CTRL1
argument_list|,
name|lcfg
operator|.
name|led_ctrl1
argument_list|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_LED_CTRL2
argument_list|,
name|lcfg
operator|.
name|led_ctrl2
argument_list|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_LED_CTRL3
argument_list|,
name|lcfg
operator|.
name|led_ctrl3
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_pos
operator|!=
name|pos
condition|)
name|new_pos
operator||=
name|AR8327_POWER_ON_STRIP_POWER_ON_SEL
expr_stmt|;
block|}
comment|/* SGMII config */
name|bzero
argument_list|(
operator|&
name|scfg
argument_list|,
sizeof|sizeof
argument_list|(
name|scfg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar8327_fetch_pdata_sgmii
argument_list|(
name|sc
argument_list|,
operator|&
name|scfg
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: SGMII cfg?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|t
operator|=
name|scfg
operator|.
name|sgmii_ctrl
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chip_rev
operator|==
literal|1
condition|)
name|t
operator||=
name|AR8327_SGMII_CTRL_EN_PLL
operator||
name|AR8327_SGMII_CTRL_EN_RX
operator||
name|AR8327_SGMII_CTRL_EN_TX
expr_stmt|;
else|else
name|t
operator|&=
operator|~
operator|(
name|AR8327_SGMII_CTRL_EN_PLL
operator||
name|AR8327_SGMII_CTRL_EN_RX
operator||
name|AR8327_SGMII_CTRL_EN_TX
operator|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_SGMII_CTRL
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|scfg
operator|.
name|serdes_aen
condition|)
name|new_pos
operator|&=
operator|~
name|AR8327_POWER_ON_STRIP_SERDES_AEN
expr_stmt|;
else|else
name|new_pos
operator||=
name|AR8327_POWER_ON_STRIP_SERDES_AEN
expr_stmt|;
block|}
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_POWER_ON_STRIP
argument_list|,
name|new_pos
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_hw_setup
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* pdata fetch and setup */
name|err
operator|=
name|ar8327_init_pdata
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* XXX init leds */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR8327_NUM_PHYS
condition|;
name|i
operator|++
control|)
block|{
comment|/* phy fixup */
name|ar8327_phy_fixup
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* start PHY autonegotiation? */
comment|/* XXX is this done as part of the normal PHY setup? */
block|}
comment|/* Let things settle */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialise other global values, for the AR8327.  */
end_comment

begin_function
specifier|static
name|int
name|ar8327_hw_global_setup
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|t
decl_stmt|;
comment|/* enable CPU port and disable mirror port */
name|t
operator|=
name|AR8327_FWD_CTRL0_CPU_PORT_EN
operator||
name|AR8327_FWD_CTRL0_MIRROR_PORT
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_FWD_CTRL0
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* forward multicast and broadcast frames to CPU */
name|t
operator|=
operator|(
name|AR8327_PORTS_ALL
operator|<<
name|AR8327_FWD_CTRL1_UC_FLOOD_S
operator|)
operator||
operator|(
name|AR8327_PORTS_ALL
operator|<<
name|AR8327_FWD_CTRL1_MC_FLOOD_S
operator|)
operator||
operator|(
name|AR8327_PORTS_ALL
operator|<<
name|AR8327_FWD_CTRL1_BC_FLOOD_S
operator|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_FWD_CTRL1
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* enable jumbo frames */
comment|/* XXX need to macro-shift the value! */
name|arswitch_modifyreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_MAX_FRAME_SIZE
argument_list|,
name|AR8327_MAX_FRAME_SIZE_MTU
argument_list|,
literal|9018
operator|+
literal|8
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Enable MIB counters */
name|arswitch_modifyreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_MODULE_EN
argument_list|,
name|AR8327_MODULE_EN_MIB
argument_list|,
name|AR8327_MODULE_EN_MIB
argument_list|)
expr_stmt|;
comment|/* Disable EEE on all ports due to stability issues */
name|t
operator|=
name|arswitch_readreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_EEE_CTRL
argument_list|)
expr_stmt|;
name|t
operator||=
name|AR8327_EEE_CTRL_DISABLE_PHY
argument_list|(
literal|0
argument_list|)
operator||
name|AR8327_EEE_CTRL_DISABLE_PHY
argument_list|(
literal|1
argument_list|)
operator||
name|AR8327_EEE_CTRL_DISABLE_PHY
argument_list|(
literal|2
argument_list|)
operator||
name|AR8327_EEE_CTRL_DISABLE_PHY
argument_list|(
literal|3
argument_list|)
operator||
name|AR8327_EEE_CTRL_DISABLE_PHY
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_EEE_CTRL
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Set the right number of ports */
comment|/* GMAC0 (CPU), GMAC1..5 (PHYs), GMAC6 (CPU) */
name|sc
operator|->
name|info
operator|.
name|es_nports
operator|=
literal|7
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Port setup.  Called at attach time.  */
end_comment

begin_function
specifier|static
name|void
name|ar8327_port_init
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|uint32_t
name|t
decl_stmt|;
name|int
name|ports
decl_stmt|;
comment|/* For now, port can see all other ports */
name|ports
operator|=
literal|0x7f
expr_stmt|;
if|if
condition|(
name|port
operator|==
name|AR8X16_PORT_CPU
condition|)
name|t
operator|=
name|sc
operator|->
name|ar8327
operator|.
name|port0_status
expr_stmt|;
elseif|else
if|if
condition|(
name|port
operator|==
literal|6
condition|)
name|t
operator|=
name|sc
operator|->
name|ar8327
operator|.
name|port6_status
expr_stmt|;
else|else
name|t
operator|=
name|AR8X16_PORT_STS_LINK_AUTO
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_STATUS
argument_list|(
name|port
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_HEADER
argument_list|(
name|port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Default to 1 port group. 	 */
name|t
operator|=
literal|1
operator|<<
name|AR8327_PORT_VLAN0_DEF_SVID_S
expr_stmt|;
name|t
operator||=
literal|1
operator|<<
name|AR8327_PORT_VLAN0_DEF_CVID_S
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_VLAN0
argument_list|(
name|port
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|AR8327_PORT_VLAN1_OUT_MODE_UNTOUCH
operator|<<
name|AR8327_PORT_VLAN1_OUT_MODE_S
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_VLAN1
argument_list|(
name|port
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* 	 * This doesn't configure any ports which this port can "see". 	 * bits 0-6 control which ports a frame coming into this port 	 * can be sent out to. 	 * 	 * So by doing this, we're making it impossible to send frames out 	 * to that port. 	 */
name|t
operator|=
name|AR8327_PORT_LOOKUP_LEARN
expr_stmt|;
name|t
operator||=
name|AR8X16_PORT_CTRL_STATE_FORWARD
operator|<<
name|AR8327_PORT_LOOKUP_STATE_S
expr_stmt|;
comment|/* So this allows traffic to any port except ourselves */
name|t
operator||=
operator|(
name|ports
operator|&
operator|~
operator|(
literal|1
operator|<<
name|port
operator|)
operator|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_LOOKUP
argument_list|(
name|port
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_port_vlan_setup
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|etherswitch_port_t
modifier|*
name|p
parameter_list|)
block|{
comment|/* Check: ADDTAG/STRIPTAG - exclusive */
name|ARSWITCH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set the PVID. */
if|if
condition|(
name|p
operator|->
name|es_pvid
operator|!=
literal|0
condition|)
name|sc
operator|->
name|hal
operator|.
name|arswitch_vlan_set_pvid
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|es_port
argument_list|,
name|p
operator|->
name|es_pvid
argument_list|)
expr_stmt|;
comment|/* 	 * DOUBLE_TAG 	 * VLAN_MODE_ADD 	 * VLAN_MODE_STRIP 	 */
name|ARSWITCH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the port VLAN configuration.  */
end_comment

begin_function
specifier|static
name|int
name|ar8327_port_vlan_get
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|etherswitch_port_t
modifier|*
name|p
parameter_list|)
block|{
name|ARSWITCH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Retrieve the PVID */
name|sc
operator|->
name|hal
operator|.
name|arswitch_vlan_get_pvid
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|es_port
argument_list|,
operator|&
name|p
operator|->
name|es_pvid
argument_list|)
expr_stmt|;
comment|/* Retrieve the current port configuration from the VTU */
comment|/* 	 * DOUBLE_TAG 	 * VLAN_MODE_ADD 	 * VLAN_MODE_STRIP 	 */
name|ARSWITCH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar8327_port_disable_mirror
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|arswitch_modifyreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_LOOKUP
argument_list|(
name|port
argument_list|)
argument_list|,
name|AR8327_PORT_LOOKUP_ING_MIRROR_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arswitch_modifyreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_HOL_CTRL1
argument_list|(
name|port
argument_list|)
argument_list|,
name|AR8327_PORT_HOL_CTRL1_EG_MIRROR_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar8327_reset_vlans
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|t
decl_stmt|;
name|int
name|ports
decl_stmt|;
name|ARSWITCH_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|ARSWITCH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Clear the existing VLAN configuration */
name|memset
argument_list|(
name|sc
operator|->
name|vid
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|vid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Disable mirroring. 	 */
name|arswitch_modifyreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_FWD_CTRL0
argument_list|,
name|AR8327_FWD_CTRL0_MIRROR_PORT
argument_list|,
operator|(
literal|0xF
operator|<<
name|AR8327_FWD_CTRL0_MIRROR_PORT_S
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXX TODO: disable any Q-in-Q port configuration, 	 * tagging, egress filters, etc. 	 */
comment|/* 	 * For now, let's default to one portgroup, just so traffic 	 * flows.  All ports can see other ports. There are two CPU GMACs 	 * (GMAC0, GMAC6), GMAC1..GMAC5 are external PHYs. 	 * 	 * (ETHERSWITCH_VLAN_PORT) 	 */
name|ports
operator|=
literal|0x7f
expr_stmt|;
comment|/* 	 * XXX TODO: set things up correctly for vlans! 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR8327_NUM_PORTS
condition|;
name|i
operator|++
control|)
block|{
name|int
name|egress
decl_stmt|,
name|ingress
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|vlan_mode
operator|==
name|ETHERSWITCH_VLAN_PORT
condition|)
block|{
name|sc
operator|->
name|vid
index|[
name|i
index|]
operator|=
name|i
operator||
name|ETHERSWITCH_VID_VALID
expr_stmt|;
comment|/* set egress == out_keep */
name|ingress
operator|=
name|AR8X16_PORT_VLAN_MODE_PORT_ONLY
expr_stmt|;
comment|/* in_port_only, forward */
name|egress
operator|=
name|AR8327_PORT_VLAN1_OUT_MODE_UNTOUCH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|vlan_mode
operator|==
name|ETHERSWITCH_VLAN_DOT1Q
condition|)
block|{
name|ingress
operator|=
name|AR8X16_PORT_VLAN_MODE_SECURE
expr_stmt|;
name|egress
operator|=
name|AR8327_PORT_VLAN1_OUT_MODE_UNMOD
expr_stmt|;
block|}
else|else
block|{
comment|/* set egress == out_keep */
name|ingress
operator|=
name|AR8X16_PORT_VLAN_MODE_PORT_ONLY
expr_stmt|;
comment|/* in_port_only, forward */
name|egress
operator|=
name|AR8327_PORT_VLAN1_OUT_MODE_UNTOUCH
expr_stmt|;
block|}
comment|/* set pvid = 1; there's only one vlangroup to start with */
name|t
operator|=
literal|1
operator|<<
name|AR8327_PORT_VLAN0_DEF_SVID_S
expr_stmt|;
name|t
operator||=
literal|1
operator|<<
name|AR8327_PORT_VLAN0_DEF_CVID_S
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_VLAN0
argument_list|(
name|i
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|AR8327_PORT_VLAN1_PORT_VLAN_PROP
expr_stmt|;
name|t
operator||=
name|egress
operator|<<
name|AR8327_PORT_VLAN1_OUT_MODE_S
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_VLAN1
argument_list|(
name|i
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Ports can see other ports */
comment|/* XXX not entirely true for dot1q? */
name|t
operator|=
operator|(
name|ports
operator|&
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
expr_stmt|;
comment|/* all ports besides us */
name|t
operator||=
name|AR8327_PORT_LOOKUP_LEARN
expr_stmt|;
name|t
operator||=
name|ingress
operator|<<
name|AR8327_PORT_LOOKUP_IN_MODE_S
expr_stmt|;
name|t
operator||=
name|AR8X16_PORT_CTRL_STATE_FORWARD
operator|<<
name|AR8327_PORT_LOOKUP_STATE_S
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_LOOKUP
argument_list|(
name|i
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Disable port mirroring entirely. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR8327_NUM_PORTS
condition|;
name|i
operator|++
control|)
block|{
name|ar8327_port_disable_mirror
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If dot1q - set pvid; dot1q, etc. 	 */
if|if
condition|(
name|sc
operator|->
name|vlan_mode
operator|==
name|ETHERSWITCH_VLAN_DOT1Q
condition|)
block|{
name|sc
operator|->
name|vid
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR8327_NUM_PORTS
condition|;
name|i
operator|++
control|)
block|{
comment|/* Each port - pvid 1 */
name|sc
operator|->
name|hal
operator|.
name|arswitch_vlan_set_pvid
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|vid
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Initialise vlan1 - all ports, untagged */
name|sc
operator|->
name|hal
operator|.
name|arswitch_set_dot1q_vlan
argument_list|(
name|sc
argument_list|,
name|ports
argument_list|,
name|ports
argument_list|,
name|sc
operator|->
name|vid
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vid
index|[
literal|0
index|]
operator||=
name|ETHERSWITCH_VID_VALID
expr_stmt|;
block|}
name|ARSWITCH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_vlan_get_port
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|ports
parameter_list|,
name|int
name|vid
parameter_list|)
block|{
name|int
name|port
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|ARSWITCH_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* For port based vlans the vlanid is the same as the port index. */
name|port
operator|=
name|vid
operator|&
name|ETHERSWITCH_VID_MASK
expr_stmt|;
name|reg
operator|=
name|arswitch_readreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_LOOKUP
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ports
operator|=
name|reg
operator|&
literal|0x7f
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_vlan_set_port
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|ports
parameter_list|,
name|int
name|vid
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|port
decl_stmt|;
name|ARSWITCH_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* For port based vlans the vlanid is the same as the port index. */
name|port
operator|=
name|vid
operator|&
name|ETHERSWITCH_VID_MASK
expr_stmt|;
name|err
operator|=
name|arswitch_modifyreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_LOOKUP
argument_list|(
name|port
argument_list|)
argument_list|,
literal|0x7f
argument_list|,
comment|/* vlan membership mask */
operator|(
name|ports
operator|&
literal|0x7f
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_vlan_getvgroup
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|etherswitch_vlangroup_t
modifier|*
name|vg
parameter_list|)
block|{
return|return
operator|(
name|ar8xxx_getvgroup
argument_list|(
name|sc
argument_list|,
name|vg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_vlan_setvgroup
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|etherswitch_vlangroup_t
modifier|*
name|vg
parameter_list|)
block|{
return|return
operator|(
name|ar8xxx_setvgroup
argument_list|(
name|sc
argument_list|,
name|vg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_get_pvid
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|int
name|port
parameter_list|,
name|int
modifier|*
name|pvid
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|ARSWITCH_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * XXX for now, assuming it's CVID; likely very wrong! 	 */
name|port
operator|=
name|port
operator|&
name|ETHERSWITCH_VID_MASK
expr_stmt|;
name|reg
operator|=
name|arswitch_readreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_VLAN0
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|reg
operator|>>
name|AR8327_PORT_VLAN0_DEF_CVID_S
expr_stmt|;
name|reg
operator|=
name|reg
operator|&
literal|0xfff
expr_stmt|;
operator|*
name|pvid
operator|=
name|reg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_set_pvid
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|pvid
parameter_list|)
block|{
name|uint32_t
name|t
decl_stmt|;
comment|/* Limit pvid to valid values */
name|pvid
operator|&=
literal|0x7f
expr_stmt|;
name|t
operator|=
name|pvid
operator|<<
name|AR8327_PORT_VLAN0_DEF_SVID_S
expr_stmt|;
name|t
operator||=
name|pvid
operator|<<
name|AR8327_PORT_VLAN0_DEF_CVID_S
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_VLAN0
argument_list|(
name|port
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_atu_flush
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|arswitch_waitreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_ATU_FUNC
argument_list|,
name|AR8327_ATU_FUNC_BUSY
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: waitreg failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_ATU_FUNC
argument_list|,
name|AR8327_ATU_FUNC_OP_FLUSH
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_flush_dot1q_vlan
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|ar8327_vlan_op
argument_list|(
name|sc
argument_list|,
name|AR8327_VTU_FUNC1_OP_FLUSH
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_purge_dot1q_vlan
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vid
parameter_list|)
block|{
return|return
operator|(
name|ar8327_vlan_op
argument_list|(
name|sc
argument_list|,
name|AR8327_VTU_FUNC1_OP_PURGE
argument_list|,
name|vid
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_get_dot1q_vlan
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|ports
parameter_list|,
name|uint32_t
modifier|*
name|untagged_ports
parameter_list|,
name|int
name|vid
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
name|uint32_t
name|op
decl_stmt|,
name|reg
decl_stmt|,
name|val
decl_stmt|;
name|op
operator|=
name|AR8327_VTU_FUNC1_OP_GET_ONE
expr_stmt|;
comment|/* Filter out the vid flags; only grab the VLAN ID */
name|vid
operator|&=
literal|0xfff
expr_stmt|;
comment|/* XXX TODO: the VTU here stores egress mode - keep, tag, untagged, none */
name|r
operator|=
name|ar8327_vlan_op
argument_list|(
name|sc
argument_list|,
name|op
argument_list|,
name|vid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: %d: op failed\n"
argument_list|,
name|__func__
argument_list|,
name|vid
argument_list|)
expr_stmt|;
block|}
name|reg
operator|=
name|arswitch_readreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_VTU_FUNC0
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: %d: reg=0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|vid
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* 	 * If any of the bits are set, update the port mask. 	 * Worry about the port config itself when getport() is called. 	 */
operator|*
name|ports
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR8327_NUM_PORTS
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|reg
operator|>>
name|AR8327_VTU_FUNC0_EG_MODE_S
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|val
operator|=
name|val
operator|&
literal|0x3
expr_stmt|;
comment|/* XXX KEEP (unmodified?) */
if|if
condition|(
name|val
operator|==
name|AR8327_VTU_FUNC0_EG_MODE_TAG
condition|)
block|{
operator|*
name|ports
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|==
name|AR8327_VTU_FUNC0_EG_MODE_UNTAG
condition|)
block|{
operator|*
name|ports
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
operator|*
name|untagged_ports
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_set_dot1q_vlan
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|ports
parameter_list|,
name|uint32_t
name|untagged_ports
parameter_list|,
name|int
name|vid
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|op
decl_stmt|,
name|val
decl_stmt|,
name|mode
decl_stmt|;
name|op
operator|=
name|AR8327_VTU_FUNC1_OP_LOAD
expr_stmt|;
name|vid
operator|&=
literal|0xfff
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: vid: %d, ports=0x%08x, untagged_ports=0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|vid
argument_list|,
name|ports
argument_list|,
name|untagged_ports
argument_list|)
expr_stmt|;
comment|/* 	 * Mark it as valid; and that it should use per-VLAN MAC table, 	 * not VID=0 when doing MAC lookups 	 */
name|val
operator|=
name|AR8327_VTU_FUNC0_VALID
operator||
name|AR8327_VTU_FUNC0_IVL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR8327_NUM_PORTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ports
operator|&
name|BIT
argument_list|(
name|i
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|mode
operator|=
name|AR8327_VTU_FUNC0_EG_MODE_NOT
expr_stmt|;
elseif|else
if|if
condition|(
name|untagged_ports
operator|&
name|BIT
argument_list|(
name|i
argument_list|)
condition|)
name|mode
operator|=
name|AR8327_VTU_FUNC0_EG_MODE_UNTAG
expr_stmt|;
else|else
name|mode
operator|=
name|AR8327_VTU_FUNC0_EG_MODE_TAG
expr_stmt|;
name|val
operator||=
name|mode
operator|<<
name|AR8327_VTU_FUNC0_EG_MODE_S
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ar8327_vlan_op
argument_list|(
name|sc
argument_list|,
name|op
argument_list|,
name|vid
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ar8327_attach
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|hal
operator|.
name|arswitch_hw_setup
operator|=
name|ar8327_hw_setup
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_hw_global_setup
operator|=
name|ar8327_hw_global_setup
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_port_init
operator|=
name|ar8327_port_init
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_vlan_getvgroup
operator|=
name|ar8327_vlan_getvgroup
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_vlan_setvgroup
operator|=
name|ar8327_vlan_setvgroup
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_port_vlan_setup
operator|=
name|ar8327_port_vlan_setup
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_port_vlan_get
operator|=
name|ar8327_port_vlan_get
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_flush_dot1q_vlan
operator|=
name|ar8327_flush_dot1q_vlan
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_purge_dot1q_vlan
operator|=
name|ar8327_purge_dot1q_vlan
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_set_dot1q_vlan
operator|=
name|ar8327_set_dot1q_vlan
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_get_dot1q_vlan
operator|=
name|ar8327_get_dot1q_vlan
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_vlan_init_hw
operator|=
name|ar8327_reset_vlans
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_vlan_get_pvid
operator|=
name|ar8327_get_pvid
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_vlan_set_pvid
operator|=
name|ar8327_set_pvid
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_get_port_vlan
operator|=
name|ar8327_vlan_get_port
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_set_port_vlan
operator|=
name|ar8327_vlan_set_port
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_atu_flush
operator|=
name|ar8327_atu_flush
expr_stmt|;
comment|/* 	 * Reading the PHY via the MDIO interface currently doesn't 	 * work correctly. 	 * 	 * So for now, just go direct to the PHY registers themselves. 	 * This has always worked  on external devices, but not internal 	 * devices (AR934x, AR724x, AR933x.) 	 */
name|sc
operator|->
name|hal
operator|.
name|arswitch_phy_read
operator|=
name|arswitch_readphy_external
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_phy_write
operator|=
name|arswitch_writephy_external
expr_stmt|;
comment|/* Set the switch vlan capabilities. */
name|sc
operator|->
name|info
operator|.
name|es_vlan_caps
operator|=
name|ETHERSWITCH_VLAN_DOT1Q
operator||
name|ETHERSWITCH_VLAN_PORT
operator||
name|ETHERSWITCH_VLAN_DOUBLE_TAG
expr_stmt|;
name|sc
operator|->
name|info
operator|.
name|es_nvlangroups
operator|=
name|AR8X16_MAX_VLANS
expr_stmt|;
block|}
end_function

end_unit

