begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011-2012 Stefan Bethke.  * Copyright (c) 2014 Adrian Chadd.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iic.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iiconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iicbus.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/etherswitch/mdio.h>
end_include

begin_include
include|#
directive|include
file|<dev/etherswitch/etherswitch.h>
end_include

begin_include
include|#
directive|include
file|<dev/etherswitch/arswitch/arswitchreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/etherswitch/arswitch/arswitchvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/etherswitch/arswitch/arswitch_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/etherswitch/arswitch/arswitch_8327.h>
end_include

begin_include
include|#
directive|include
file|"mdio_if.h"
end_include

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_include
include|#
directive|include
file|"etherswitch_if.h"
end_include

begin_function
specifier|static
name|void
name|ar8327_phy_fixup
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|int
name|phy
parameter_list|)
block|{
switch|switch
condition|(
name|sc
operator|->
name|chip_rev
condition|)
block|{
case|case
literal|1
case|:
comment|/* For 100M waveform */
name|arswitch_writedbg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0
argument_list|,
literal|0x02ea
argument_list|)
expr_stmt|;
comment|/* Turn on Gigabit clock */
name|arswitch_writedbg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x3d
argument_list|,
literal|0x68a0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|arswitch_writemmd
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x7
argument_list|,
literal|0x3c
argument_list|)
expr_stmt|;
name|arswitch_writemmd
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x4007
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* fallthrough */
case|case
literal|4
case|:
name|arswitch_writemmd
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x3
argument_list|,
literal|0x800d
argument_list|)
expr_stmt|;
name|arswitch_writemmd
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x4003
argument_list|,
literal|0x803f
argument_list|)
expr_stmt|;
name|arswitch_writedbg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x3d
argument_list|,
literal|0x6860
argument_list|)
expr_stmt|;
name|arswitch_writedbg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x5
argument_list|,
literal|0x2c46
argument_list|)
expr_stmt|;
name|arswitch_writedbg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|phy
argument_list|,
literal|0x3c
argument_list|,
literal|0x6000
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|ar8327_get_pad_cfg
parameter_list|(
name|struct
name|ar8327_pad_cfg
modifier|*
name|cfg
parameter_list|)
block|{
name|uint32_t
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|cfg
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|t
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cfg
operator|->
name|mode
condition|)
block|{
case|case
name|AR8327_PAD_NC
case|:
break|break;
case|case
name|AR8327_PAD_MAC2MAC_MII
case|:
name|t
operator|=
name|AR8327_PAD_MAC_MII_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|rxclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_MAC_MII_RXCLK_SEL
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|txclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_MAC_MII_TXCLK_SEL
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_MAC2MAC_GMII
case|:
name|t
operator|=
name|AR8327_PAD_MAC_GMII_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|rxclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_MAC_GMII_RXCLK_SEL
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|txclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_MAC_GMII_TXCLK_SEL
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_MAC_SGMII
case|:
name|t
operator|=
name|AR8327_PAD_SGMII_EN
expr_stmt|;
comment|/* 		 * WAR for the QUalcomm Atheros AP136 board. 		 * It seems that RGMII TX/RX delay settings needs to be 		 * applied for SGMII mode as well, The ethernet is not 		 * reliable without this. 		 */
name|t
operator||=
name|cfg
operator|->
name|txclk_delay_sel
operator|<<
name|AR8327_PAD_RGMII_TXCLK_DELAY_SEL_S
expr_stmt|;
name|t
operator||=
name|cfg
operator|->
name|rxclk_delay_sel
operator|<<
name|AR8327_PAD_RGMII_RXCLK_DELAY_SEL_S
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|rxclk_delay_en
condition|)
name|t
operator||=
name|AR8327_PAD_RGMII_RXCLK_DELAY_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|txclk_delay_en
condition|)
name|t
operator||=
name|AR8327_PAD_RGMII_TXCLK_DELAY_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|sgmii_delay_en
condition|)
name|t
operator||=
name|AR8327_PAD_SGMII_DELAY_EN
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_MAC2PHY_MII
case|:
name|t
operator|=
name|AR8327_PAD_PHY_MII_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|rxclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_PHY_MII_RXCLK_SEL
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|txclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_PHY_MII_TXCLK_SEL
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_MAC2PHY_GMII
case|:
name|t
operator|=
name|AR8327_PAD_PHY_GMII_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|pipe_rxclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_PHY_GMII_PIPE_RXCLK_SEL
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|rxclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_PHY_GMII_RXCLK_SEL
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|txclk_sel
condition|)
name|t
operator||=
name|AR8327_PAD_PHY_GMII_TXCLK_SEL
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_MAC_RGMII
case|:
name|t
operator|=
name|AR8327_PAD_RGMII_EN
expr_stmt|;
name|t
operator||=
name|cfg
operator|->
name|txclk_delay_sel
operator|<<
name|AR8327_PAD_RGMII_TXCLK_DELAY_SEL_S
expr_stmt|;
name|t
operator||=
name|cfg
operator|->
name|rxclk_delay_sel
operator|<<
name|AR8327_PAD_RGMII_RXCLK_DELAY_SEL_S
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|rxclk_delay_en
condition|)
name|t
operator||=
name|AR8327_PAD_RGMII_RXCLK_DELAY_EN
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|txclk_delay_en
condition|)
name|t
operator||=
name|AR8327_PAD_RGMII_TXCLK_DELAY_EN
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_PHY_GMII
case|:
name|t
operator|=
name|AR8327_PAD_PHYX_GMII_EN
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_PHY_RGMII
case|:
name|t
operator|=
name|AR8327_PAD_PHYX_RGMII_EN
expr_stmt|;
break|break;
case|case
name|AR8327_PAD_PHY_MII
case|:
name|t
operator|=
name|AR8327_PAD_PHYX_MII_EN
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialise the ar8327 specific hardware features from  * the hints provided in the boot environment.  */
end_comment

begin_function
specifier|static
name|int
name|ar8327_init_pdata
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ar8327_pad_cfg
name|pc
decl_stmt|;
name|uint32_t
name|t
decl_stmt|;
comment|/* XXX hard-coded DB120 defaults for now! */
comment|/* Port 0 - rgmii; 1000/full */
comment|/* Port 6 - ignore */
comment|/* Pad 0 */
name|bzero
argument_list|(
operator|&
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|pc
operator|.
name|mode
operator|=
name|AR8327_PAD_MAC_RGMII
operator|,
name|pc
operator|.
name|txclk_delay_en
operator|=
name|true
operator|,
name|pc
operator|.
name|rxclk_delay_en
operator|=
name|true
operator|,
name|pc
operator|.
name|txclk_delay_sel
operator|=
name|AR8327_CLK_DELAY_SEL1
operator|,
name|pc
operator|.
name|rxclk_delay_sel
operator|=
name|AR8327_CLK_DELAY_SEL2
operator|,
name|t
operator|=
name|ar8327_get_pad_cfg
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (AR8X16_IS_SWITCH(sc, AR8337)) 		t |= AR8337_PAD_MAC06_EXCHANGE_EN;
endif|#
directive|endif
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PAD0_MODE
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Pad 5 */
name|bzero
argument_list|(
operator|&
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|ar8327_get_pad_cfg
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PAD5_MODE
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Pad 6 */
name|bzero
argument_list|(
operator|&
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|ar8327_get_pad_cfg
argument_list|(
operator|&
name|pc
argument_list|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PAD6_MODE
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* LED config */
comment|/* SGMII config */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Map the hard-coded port config from the switch setup to  * the chipset port config (status, duplex, flow, etc.)  */
end_comment

begin_endif
unit|static uint32_t ar8327_get_port_init_status(struct ar8327_port_cfg *cfg) { 	uint32_t t;  	if (!cfg->force_link) 		return (AR8X16_PORT_STS_LINK_AUTO);  	t = AR8X16_PORT_STS_TXMAC | AR8X16_PORT_STS_RXMAC; 	t |= cfg->duplex ? AR8X16_PORT_STS_DUPLEX : 0; 	t |= cfg->rxpause ? AR8X16_PORT_STS_RXFLOW : 0; 	t |= cfg->txpause ? AR8X16_PORT_STS_TXFLOW : 0;  	switch (cfg->speed) { 	case AR8327_PORT_SPEED_10: 		t |= AR8X16_PORT_STS_SPEED_10; 		break; 	case AR8327_PORT_SPEED_100: 		t |= AR8X16_PORT_STS_SPEED_100; 		break; 	case AR8327_PORT_SPEED_1000: 		t |= AR8X16_PORT_STS_SPEED_1000; 		break; 	}  	return (t); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|ar8327_hw_setup
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* pdata fetch and setup */
name|err
operator|=
name|ar8327_init_pdata
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* XXX init leds */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR8327_NUM_PHYS
condition|;
name|i
operator|++
control|)
block|{
comment|/* phy fixup */
name|ar8327_phy_fixup
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* start PHY autonegotiation? */
comment|/* XXX is this done as part of the normal PHY setup? */
block|}
empty_stmt|;
comment|/* Let things settle */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialise other global values, for the AR8327.  */
end_comment

begin_function
specifier|static
name|int
name|ar8327_hw_global_setup
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|t
decl_stmt|;
comment|/* enable CPU port and disable mirror port */
name|t
operator|=
name|AR8327_FWD_CTRL0_CPU_PORT_EN
operator||
name|AR8327_FWD_CTRL0_MIRROR_PORT
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_FWD_CTRL0
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* forward multicast and broadcast frames to CPU */
name|t
operator|=
operator|(
name|AR8327_PORTS_ALL
operator|<<
name|AR8327_FWD_CTRL1_UC_FLOOD_S
operator|)
operator||
operator|(
name|AR8327_PORTS_ALL
operator|<<
name|AR8327_FWD_CTRL1_MC_FLOOD_S
operator|)
operator||
operator|(
name|AR8327_PORTS_ALL
operator|<<
name|AR8327_FWD_CTRL1_BC_FLOOD_S
operator|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_FWD_CTRL1
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* enable jumbo frames */
comment|/* XXX need to macro-shift the value! */
name|arswitch_modifyreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_MAX_FRAME_SIZE
argument_list|,
name|AR8327_MAX_FRAME_SIZE_MTU
argument_list|,
literal|9018
operator|+
literal|8
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Enable MIB counters */
name|arswitch_modifyreg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_MODULE_EN
argument_list|,
name|AR8327_MODULE_EN_MIB
argument_list|,
name|AR8327_MODULE_EN_MIB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Port setup.  */
end_comment

begin_function
specifier|static
name|void
name|ar8327_port_init
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|uint32_t
name|t
decl_stmt|;
comment|/* XXX TODO: need to initialise port0/port6 status in pdata */
if|#
directive|if
literal|0
block|if (port == AR8216_PORT_CPU)                 t = sc->chip_data.ar8327.port0_status;         else if (port == 6)                 t = sc->chip_data.ar8327.port6_status;         else
endif|#
directive|endif
comment|/* XXX DB120 - hard-code port0 to 1000/full */
if|if
condition|(
name|port
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|AR8X16_PORT_STS_SPEED_1000
expr_stmt|;
name|t
operator||=
name|AR8X16_PORT_STS_TXMAC
operator||
name|AR8X16_PORT_STS_RXMAC
expr_stmt|;
name|t
operator||=
name|AR8X16_PORT_STS_DUPLEX
expr_stmt|;
name|t
operator||=
name|AR8X16_PORT_STS_RXFLOW
expr_stmt|;
name|t
operator||=
name|AR8X16_PORT_STS_TXFLOW
expr_stmt|;
block|}
else|else
name|t
operator|=
name|AR8X16_PORT_STS_LINK_AUTO
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_STATUS
argument_list|(
name|port
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_HEADER
argument_list|(
name|port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
literal|1
operator|<<
name|AR8327_PORT_VLAN0_DEF_SVID_S
expr_stmt|;
name|t
operator||=
literal|1
operator|<<
name|AR8327_PORT_VLAN0_DEF_CVID_S
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_VLAN0
argument_list|(
name|port
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|AR8327_PORT_VLAN1_OUT_MODE_UNTOUCH
operator|<<
name|AR8327_PORT_VLAN1_OUT_MODE_S
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_VLAN1
argument_list|(
name|port
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|AR8327_PORT_LOOKUP_LEARN
expr_stmt|;
name|t
operator||=
name|AR8X16_PORT_CTRL_STATE_FORWARD
operator|<<
name|AR8327_PORT_LOOKUP_STATE_S
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_LOOKUP
argument_list|(
name|port
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_port_vlan_setup
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|etherswitch_port_t
modifier|*
name|p
parameter_list|)
block|{
comment|/* XXX stub for now */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_port_vlan_get
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|etherswitch_port_t
modifier|*
name|p
parameter_list|)
block|{
comment|/* XXX stub for now */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar8327_reset_vlans
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|mode
decl_stmt|,
name|t
decl_stmt|;
comment|/* 	 * For now, let's default to one portgroup, just so traffic 	 * flows.  All ports can see other ports. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR8327_NUM_PORTS
condition|;
name|i
operator|++
control|)
block|{
comment|/* set pvid = i */
name|t
operator|=
name|i
operator|<<
name|AR8327_PORT_VLAN0_DEF_SVID_S
expr_stmt|;
name|t
operator||=
name|i
operator|<<
name|AR8327_PORT_VLAN0_DEF_CVID_S
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_VLAN0
argument_list|(
name|i
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* set egress == out_keep */
name|mode
operator|=
name|AR8327_PORT_VLAN1_OUT_MODE_UNTOUCH
expr_stmt|;
name|t
operator|=
name|AR8327_PORT_VLAN1_PORT_VLAN_PROP
expr_stmt|;
name|t
operator||=
name|mode
operator|<<
name|AR8327_PORT_VLAN1_OUT_MODE_S
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_VLAN1
argument_list|(
name|i
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Set ingress = out_keep; members = 0x3f for all ports */
name|t
operator|=
literal|0x3f
expr_stmt|;
comment|/* all ports */
name|t
operator||=
name|AR8327_PORT_LOOKUP_LEARN
expr_stmt|;
comment|/* in_port_only, forward */
name|t
operator||=
name|AR8X16_PORT_VLAN_MODE_PORT_ONLY
operator|<<
name|AR8327_PORT_LOOKUP_IN_MODE_S
expr_stmt|;
name|t
operator||=
name|AR8X16_PORT_CTRL_STATE_FORWARD
operator|<<
name|AR8327_PORT_LOOKUP_STATE_S
expr_stmt|;
name|arswitch_writereg
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|AR8327_REG_PORT_LOOKUP
argument_list|(
name|i
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_vlan_getvgroup
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|etherswitch_vlangroup_t
modifier|*
name|vg
parameter_list|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_vlan_setvgroup
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|etherswitch_vlangroup_t
modifier|*
name|vg
parameter_list|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_get_pvid
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|int
name|port
parameter_list|,
name|int
modifier|*
name|pvid
parameter_list|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar8327_set_pvid
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|pvid
parameter_list|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ar8327_attach
parameter_list|(
name|struct
name|arswitch_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|hal
operator|.
name|arswitch_hw_setup
operator|=
name|ar8327_hw_setup
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_hw_global_setup
operator|=
name|ar8327_hw_global_setup
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_port_init
operator|=
name|ar8327_port_init
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_port_vlan_setup
operator|=
name|ar8327_port_vlan_setup
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_port_vlan_get
operator|=
name|ar8327_port_vlan_get
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_vlan_init_hw
operator|=
name|ar8327_reset_vlans
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_vlan_getvgroup
operator|=
name|ar8327_vlan_getvgroup
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_vlan_setvgroup
operator|=
name|ar8327_vlan_setvgroup
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_vlan_get_pvid
operator|=
name|ar8327_get_pvid
expr_stmt|;
name|sc
operator|->
name|hal
operator|.
name|arswitch_vlan_set_pvid
operator|=
name|ar8327_set_pvid
expr_stmt|;
comment|/* Set the switch vlan capabilities. */
name|sc
operator|->
name|info
operator|.
name|es_vlan_caps
operator|=
name|ETHERSWITCH_VLAN_DOT1Q
operator||
name|ETHERSWITCH_VLAN_PORT
operator||
name|ETHERSWITCH_VLAN_DOUBLE_TAG
expr_stmt|;
name|sc
operator|->
name|info
operator|.
name|es_nvlangroups
operator|=
name|AR8X16_MAX_VLANS
expr_stmt|;
block|}
end_function

end_unit

