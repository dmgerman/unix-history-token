begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$NecBSD: dp83932subr.c,v 1.5.6.2 1999/10/09 05:47:23 kmatsuda Exp $	*/
end_comment

begin_comment
comment|/*	$NetBSD$	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1997, 1998, 1999  *	Kouichi Matsuda.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Kouichi Matsuda for  *      NetBSD/pc98.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Routines of NEC PC-9801-83, 84, 103, 104, PC-9801N-25 and PC-9801N-J02, J02R   * Ethernet interface for NetBSD/pc98, ported by Kouichi Matsuda.  *  * These cards use National Semiconductor DP83934AVQB as Ethernet Controller  * and National Semiconductor NS46C46 as (64 * 16 bits) Microwire Serial EEPROM.  */
end_comment

begin_comment
comment|/*  * Modified for FreeBSD(98) 4.0 from NetBSD/pc98 1.4.2 by Motomichi Matsuzaki.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_inarp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/snc/dp83932reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/snc/dp83932var.h>
end_include

begin_include
include|#
directive|include
file|<dev/snc/if_sncreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/snc/dp83932subr.h>
end_include

begin_function_decl
name|integrate
name|u_int16_t
name|snc_nec16_select_bank
parameter_list|(
name|struct
name|snc_softc
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Interface exists: make available by filling in network interface  * record.  System will initialize the interface when it is ready  * to accept packets.  */
end_comment

begin_function
name|int
name|sncsetup
parameter_list|(
name|sc
parameter_list|,
name|lladdr
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
name|u_int8_t
modifier|*
name|lladdr
decl_stmt|;
block|{
name|u_int32_t
name|p
decl_stmt|,
name|pp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/* 	 * Put the pup in reset mode (sncinit() will fix it later), 	 * stop the timer, disable all interrupts and clear any interrupts. 	 */
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_CR
argument_list|,
name|CR_STP
argument_list|)
expr_stmt|;
name|wbflush
argument_list|()
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_CR
argument_list|,
name|CR_RST
argument_list|)
expr_stmt|;
name|wbflush
argument_list|()
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_IMR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wbflush
argument_list|()
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_ISR
argument_list|,
name|ISR_ALL
argument_list|)
expr_stmt|;
name|wbflush
argument_list|()
expr_stmt|;
comment|/* 	 * because the SONIC is basically 16bit device it 'concatenates' 	 * a higher buffer address to a 16 bit offset--this will cause wrap 	 * around problems near the end of 64k !! 	 */
name|p
operator|=
name|pp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRRA
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|v_rra
index|[
name|i
index|]
operator|=
name|SONIC_GETDMA
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|RXRSRC_SIZE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|v_rea
operator|=
name|SONIC_GETDMA
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|SOALIGN
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|sc
operator|->
name|v_cda
operator|=
name|SONIC_GETDMA
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|CDA_SIZE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|p
operator|=
name|SOALIGN
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTDA
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|mtd
modifier|*
name|mtdp
init|=
operator|&
name|sc
operator|->
name|mtda
index|[
name|i
index|]
decl_stmt|;
name|mtdp
operator|->
name|mtd_vtxp
operator|=
name|SONIC_GETDMA
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|TXP_SIZE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|SOALIGN
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|-
name|pp
operator|)
operator|>
name|NBPG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"sizeof RRA (%ld) + CDA (%ld) +"
literal|"TDA (%ld)> NBPG (%d). Punt!\n"
argument_list|,
operator|(
name|ulong
operator|)
name|sc
operator|->
name|v_cda
operator|-
operator|(
name|ulong
operator|)
name|sc
operator|->
name|v_rra
index|[
literal|0
index|]
argument_list|,
operator|(
name|ulong
operator|)
name|sc
operator|->
name|mtda
index|[
literal|0
index|]
operator|.
name|mtd_vtxp
operator|-
operator|(
name|ulong
operator|)
name|sc
operator|->
name|v_cda
argument_list|,
operator|(
name|ulong
operator|)
name|p
operator|-
operator|(
name|ulong
operator|)
name|sc
operator|->
name|mtda
index|[
literal|0
index|]
operator|.
name|mtd_vtxp
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|p
operator|=
name|pp
operator|+
name|NBPG
expr_stmt|;
name|pp
operator|=
name|p
expr_stmt|;
name|sc
operator|->
name|sc_nrda
operator|=
name|NBPG
operator|/
name|RXPKT_SIZE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|v_rda
operator|=
name|SONIC_GETDMA
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|pp
operator|+
name|NBPG
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRBA
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|rbuf
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|NBPG
expr_stmt|;
block|}
name|pp
operator|=
name|p
expr_stmt|;
name|offset
operator|=
name|TXBSIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTDA
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|mtd
modifier|*
name|mtdp
init|=
operator|&
name|sc
operator|->
name|mtda
index|[
name|i
index|]
decl_stmt|;
name|mtdp
operator|->
name|mtd_vbuf
operator|=
name|SONIC_GETDMA
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|TXBSIZE
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|NBPG
condition|)
block|{
name|p
operator|+=
name|TXBSIZE
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|pp
operator|+
name|NBPG
expr_stmt|;
name|pp
operator|=
name|p
expr_stmt|;
name|offset
operator|=
name|TXBSIZE
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * miscellaneous NEC/SONIC detect functions.  */
end_comment

begin_comment
comment|/*  * check if a specified irq is acceptable.  */
end_comment

begin_function
name|u_int8_t
name|snc_nec16_validate_irq
parameter_list|(
name|irq
parameter_list|)
name|int
name|irq
decl_stmt|;
block|{
specifier|const
name|u_int8_t
name|encoded_irq
index|[
literal|16
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|3
block|,
literal|4
block|,
operator|-
literal|1
block|,
literal|5
block|,
literal|6
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
return|return
name|encoded_irq
index|[
name|irq
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * specify irq to board.  */
end_comment

begin_function
name|int
name|snc_nec16_register_irq
parameter_list|(
name|sc
parameter_list|,
name|irq
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|irq
decl_stmt|;
block|{
name|bus_space_tag_t
name|iot
init|=
name|sc
operator|->
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|ioh
init|=
name|sc
operator|->
name|sc_ioh
decl_stmt|;
name|u_int8_t
name|encoded_irq
decl_stmt|;
name|encoded_irq
operator|=
name|snc_nec16_validate_irq
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoded_irq
operator|==
operator|(
name|u_int8_t
operator|)
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"snc_nec16_register_irq: unsupported irq (%d)\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* select SNECR_IRQSEL register */
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_ADDR
argument_list|,
name|SNECR_IRQSEL
argument_list|)
expr_stmt|;
comment|/* write encoded irq value */
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|encoded_irq
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * check if a specified memory base address is acceptable.  */
end_comment

begin_function
name|int
name|snc_nec16_validate_mem
parameter_list|(
name|maddr
parameter_list|)
name|int
name|maddr
decl_stmt|;
block|{
comment|/* Check on Normal mode with max range, only */
if|if
condition|(
operator|(
name|maddr
operator|&
operator|~
literal|0x1E000
operator|)
operator|!=
literal|0xC0000
condition|)
block|{
name|printf
argument_list|(
literal|"snc_nec16_validate_mem: "
literal|"unsupported window base (0x%x)\n"
argument_list|,
name|maddr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * specify memory base address to board and map to first bank.  */
end_comment

begin_function
name|int
name|snc_nec16_register_mem
parameter_list|(
name|sc
parameter_list|,
name|maddr
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|maddr
decl_stmt|;
block|{
name|bus_space_tag_t
name|iot
init|=
name|sc
operator|->
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|ioh
init|=
name|sc
operator|->
name|sc_ioh
decl_stmt|;
if|if
condition|(
name|snc_nec16_validate_mem
argument_list|(
name|maddr
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* select SNECR_MEMSEL register */
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_ADDR
argument_list|,
name|SNECR_MEMSEL
argument_list|)
expr_stmt|;
comment|/* write encoded memory base select value */
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_MEMSEL_PHYS2EN
argument_list|(
name|maddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * set current bank to 0 (bottom) and map 	 */
comment|/* select SNECR_MEMBS register */
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_ADDR
argument_list|,
name|SNECR_MEMBS
argument_list|)
expr_stmt|;
comment|/* select new bank */
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_MEMBS_B2EB
argument_list|(
literal|0
argument_list|)
operator||
name|SNECR_MEMBS_BSEN
argument_list|)
expr_stmt|;
comment|/* set current bank to 0 */
name|sc
operator|->
name|curbank
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|snc_nec16_check_memory
parameter_list|(
name|iot
parameter_list|,
name|ioh
parameter_list|,
name|memt
parameter_list|,
name|memh
parameter_list|)
name|bus_space_tag_t
name|iot
decl_stmt|;
name|bus_space_handle_t
name|ioh
decl_stmt|;
name|bus_space_tag_t
name|memt
decl_stmt|;
name|bus_space_handle_t
name|memh
decl_stmt|;
block|{
name|u_int16_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SNEC_NBANK
condition|;
name|i
operator|++
control|)
block|{
comment|/* select new bank */
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_ADDR
argument_list|,
name|SNECR_MEMBS
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_MEMBS_B2EB
argument_list|(
name|i
argument_list|)
operator||
name|SNECR_MEMBS_BSEN
argument_list|)
expr_stmt|;
comment|/* write test pattern */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SNEC_NMEMS
operator|/
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|bus_space_write_2
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|j
operator|*
literal|2
argument_list|,
name|val
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
name|val
operator|+=
literal|0x1000
expr_stmt|;
block|}
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SNEC_NBANK
condition|;
name|i
operator|++
control|)
block|{
comment|/* select new bank */
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_ADDR
argument_list|,
name|SNECR_MEMBS
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_MEMBS_B2EB
argument_list|(
name|i
argument_list|)
operator||
name|SNECR_MEMBS_BSEN
argument_list|)
expr_stmt|;
comment|/* read test pattern */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SNEC_NMEMS
operator|/
literal|2
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|bus_space_read_2
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|j
operator|*
literal|2
argument_list|)
operator|!=
name|val
operator|+
name|j
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|<
name|SNEC_NMEMS
operator|/
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"snc_nec16_check_memory: "
literal|"memory check failed at 0x%04x%04x"
literal|"val 0x%04x != expected 0x%04x\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|bus_space_read_2
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|j
operator|*
literal|2
argument_list|)
argument_list|,
name|val
operator|+
name|j
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|val
operator|+=
literal|0x1000
expr_stmt|;
block|}
comment|/* zero clear mem */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SNEC_NBANK
condition|;
name|i
operator|++
control|)
block|{
comment|/* select new bank */
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_ADDR
argument_list|,
name|SNECR_MEMBS
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_MEMBS_B2EB
argument_list|(
name|i
argument_list|)
operator||
name|SNECR_MEMBS_BSEN
argument_list|)
expr_stmt|;
name|bus_space_set_region_4
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SNEC_NMEMS
operator|>>
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* again read test if these are 0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SNEC_NBANK
condition|;
name|i
operator|++
control|)
block|{
comment|/* select new bank */
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_ADDR
argument_list|,
name|SNECR_MEMBS
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_MEMBS_B2EB
argument_list|(
name|i
argument_list|)
operator||
name|SNECR_MEMBS_BSEN
argument_list|)
expr_stmt|;
comment|/* check if cleared */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SNEC_NMEMS
condition|;
name|j
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|bus_space_read_2
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|j
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|!=
name|SNEC_NMEMS
condition|)
block|{
name|printf
argument_list|(
literal|"snc_nec16_check_memory: "
literal|"memory zero clear failed at 0x%04x%04x\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|snc_nec16_detectsubr
parameter_list|(
name|iot
parameter_list|,
name|ioh
parameter_list|,
name|memt
parameter_list|,
name|memh
parameter_list|,
name|irq
parameter_list|,
name|maddr
parameter_list|,
name|type
parameter_list|)
name|bus_space_tag_t
name|iot
decl_stmt|;
name|bus_space_handle_t
name|ioh
decl_stmt|;
name|bus_space_tag_t
name|memt
decl_stmt|;
name|bus_space_handle_t
name|memh
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|int
name|maddr
decl_stmt|;
name|u_int8_t
name|type
decl_stmt|;
block|{
name|u_int16_t
name|cr
decl_stmt|;
name|u_int8_t
name|ident
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|snc_nec16_validate_irq
argument_list|(
name|irq
argument_list|)
operator|==
operator|(
name|u_int8_t
operator|)
operator|-
literal|1
condition|)
return|return
literal|0
return|;
comment|/* XXX: maddr already checked */
if|if
condition|(
name|snc_nec16_validate_mem
argument_list|(
name|maddr
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_ADDR
argument_list|,
name|SNECR_IDENT
argument_list|)
expr_stmt|;
name|ident
operator|=
name|bus_space_read_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|)
expr_stmt|;
if|if
condition|(
name|ident
operator|==
literal|0xff
operator|||
name|ident
operator|==
literal|0x00
condition|)
block|{
comment|/* not found */
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SNEC_TYPE_LEGACY
case|:
name|rv
operator|=
operator|(
name|ident
operator|==
name|SNECR_IDENT_LEGACY_CBUS
operator|)
expr_stmt|;
break|break;
case|case
name|SNEC_TYPE_PNP
case|:
name|rv
operator|=
operator|(
operator|(
name|ident
operator|==
name|SNECR_IDENT_PNP_CBUS
operator|)
operator|||
operator|(
name|ident
operator|==
name|SNECR_IDENT_PNP_PCMCIABUS
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"snc_nec16_detectsubr: parent bus mismatch\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* select SONIC register SNCR_CR */
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_ADDR
argument_list|,
name|SNCR_CR
argument_list|)
expr_stmt|;
name|bus_space_write_2
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRL
argument_list|,
name|CR_RXDIS
operator||
name|CR_STP
operator||
name|CR_RST
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|400
argument_list|)
expr_stmt|;
name|cr
operator|=
name|bus_space_read_2
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|!=
operator|(
name|CR_RXDIS
operator||
name|CR_STP
operator||
name|CR_RST
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"snc_nec16_detectsubr: card reset failed, cr = 0x%04x\n"
argument_list|,
name|cr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
if|if
condition|(
name|snc_nec16_check_memory
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|memt
argument_list|,
name|memh
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|SNC_VENDOR_NEC
value|0x00004c
end_define

begin_define
define|#
directive|define
name|SNC_NEC_SERIES_LEGACY_CBUS
value|0xa5
end_define

begin_define
define|#
directive|define
name|SNC_NEC_SERIES_PNP_PCMCIA
value|0xd5
end_define

begin_define
define|#
directive|define
name|SNC_NEC_SERIES_PNP_PCMCIA2
value|0x6d
end_define

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|SNC_NEC_SERIES_PNP_CBUS
value|0x0d
end_define

begin_define
define|#
directive|define
name|SNC_NEC_SERIES_PNP_CBUS2
value|0x3d
end_define

begin_function
name|u_int8_t
modifier|*
name|snc_nec16_detect_type
parameter_list|(
name|myea
parameter_list|)
name|u_int8_t
modifier|*
name|myea
decl_stmt|;
block|{
name|u_int32_t
name|vendor
init|=
operator|(
name|myea
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|myea
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|myea
index|[
literal|2
index|]
decl_stmt|;
name|u_int8_t
name|series
init|=
name|myea
index|[
literal|3
index|]
decl_stmt|;
name|u_int8_t
name|type
init|=
name|myea
index|[
literal|4
index|]
operator|&
literal|0x80
decl_stmt|;
name|u_int8_t
modifier|*
name|typestr
decl_stmt|;
switch|switch
condition|(
name|vendor
condition|)
block|{
case|case
name|SNC_VENDOR_NEC
case|:
switch|switch
condition|(
name|series
condition|)
block|{
case|case
name|SNC_NEC_SERIES_LEGACY_CBUS
case|:
if|if
condition|(
name|type
condition|)
name|typestr
operator|=
literal|"NEC PC-9801-84"
expr_stmt|;
else|else
name|typestr
operator|=
literal|"NEC PC-9801-83"
expr_stmt|;
break|break;
case|case
name|SNC_NEC_SERIES_PNP_CBUS
case|:
case|case
name|SNC_NEC_SERIES_PNP_CBUS2
case|:
if|if
condition|(
name|type
condition|)
name|typestr
operator|=
literal|"NEC PC-9801-104"
expr_stmt|;
else|else
name|typestr
operator|=
literal|"NEC PC-9801-103"
expr_stmt|;
break|break;
case|case
name|SNC_NEC_SERIES_PNP_PCMCIA
case|:
case|case
name|SNC_NEC_SERIES_PNP_PCMCIA2
case|:
comment|/* XXX: right ? */
if|if
condition|(
name|type
condition|)
name|typestr
operator|=
literal|"NEC PC-9801N-J02R"
expr_stmt|;
else|else
name|typestr
operator|=
literal|"NEC PC-9801N-J02"
expr_stmt|;
break|break;
default|default:
name|typestr
operator|=
literal|"NEC unknown (PC-9801N-25?)"
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|typestr
operator|=
literal|"unknown (3rd vendor?)"
expr_stmt|;
break|break;
block|}
return|return
name|typestr
return|;
block|}
end_function

begin_function
name|int
name|snc_nec16_get_enaddr
parameter_list|(
name|iot
parameter_list|,
name|ioh
parameter_list|,
name|myea
parameter_list|)
name|bus_space_tag_t
name|iot
decl_stmt|;
name|bus_space_handle_t
name|ioh
decl_stmt|;
name|u_int8_t
modifier|*
name|myea
decl_stmt|;
block|{
name|u_int8_t
name|eeprom
index|[
name|SNEC_EEPROM_SIZE
index|]
decl_stmt|;
name|u_int8_t
name|rom_sum
decl_stmt|,
name|sum
init|=
literal|0x00
decl_stmt|;
name|int
name|i
decl_stmt|;
name|snc_nec16_read_eeprom
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|eeprom
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SNEC_EEPROM_KEY0
init|;
name|i
operator|<
name|SNEC_EEPROM_CKSUM
condition|;
name|i
operator|++
control|)
block|{
name|sum
operator|=
name|sum
operator|^
name|eeprom
index|[
name|i
index|]
expr_stmt|;
block|}
name|rom_sum
operator|=
name|eeprom
index|[
name|SNEC_EEPROM_CKSUM
index|]
expr_stmt|;
if|if
condition|(
name|sum
operator|!=
name|rom_sum
condition|)
block|{
name|printf
argument_list|(
literal|"snc_nec16_get_enaddr: "
literal|"checksum mismatch; calculated %02x != read %02x"
argument_list|,
name|sum
argument_list|,
name|rom_sum
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|myea
index|[
name|i
index|]
operator|=
name|eeprom
index|[
name|SNEC_EEPROM_SA0
operator|+
name|i
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * read from NEC/SONIC NIC register.  */
end_comment

begin_function
name|u_int16_t
name|snc_nec16_nic_get
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
name|u_int8_t
name|reg
decl_stmt|;
block|{
name|u_int16_t
name|val
decl_stmt|;
comment|/* select SONIC register */
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|sc
operator|->
name|sc_ioh
argument_list|,
name|SNEC_ADDR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|val
operator|=
name|bus_space_read_2
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|sc
operator|->
name|sc_ioh
argument_list|,
name|SNEC_CTRL
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/*  * write to NEC/SONIC NIC register.  */
end_comment

begin_function
name|void
name|snc_nec16_nic_put
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
name|u_int8_t
name|reg
decl_stmt|;
name|u_int16_t
name|val
decl_stmt|;
block|{
comment|/* select SONIC register */
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|sc
operator|->
name|sc_ioh
argument_list|,
name|SNEC_ADDR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|bus_space_write_2
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|sc
operator|->
name|sc_ioh
argument_list|,
name|SNEC_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * select memory bank and map  * where exists specified (internal buffer memory) offset.  */
end_comment

begin_function
name|integrate
name|u_int16_t
name|snc_nec16_select_bank
parameter_list|(
name|sc
parameter_list|,
name|base
parameter_list|,
name|offset
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|base
decl_stmt|;
name|u_int32_t
name|offset
decl_stmt|;
block|{
name|bus_space_tag_t
name|iot
init|=
name|sc
operator|->
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|ioh
init|=
name|sc
operator|->
name|sc_ioh
decl_stmt|;
name|u_int8_t
name|bank
decl_stmt|;
name|u_int16_t
name|noffset
decl_stmt|;
comment|/* bitmode is fixed to 16 bit. */
name|bank
operator|=
operator|(
name|base
operator|+
name|offset
operator|*
literal|2
operator|)
operator|>>
literal|13
expr_stmt|;
name|noffset
operator|=
operator|(
name|base
operator|+
name|offset
operator|*
literal|2
operator|)
operator|&
operator|(
name|SNEC_NMEMS
operator|-
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SNCDEBUG
if|if
condition|(
name|noffset
operator|%
literal|2
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"noffset is odd (0x%04x)\n"
argument_list|,
name|noffset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SNCDEBUG */
if|if
condition|(
name|sc
operator|->
name|curbank
operator|!=
name|bank
condition|)
block|{
comment|/* select SNECR_MEMBS register */
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_ADDR
argument_list|,
name|SNECR_MEMBS
argument_list|)
expr_stmt|;
comment|/* select new bank */
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_MEMBS_B2EB
argument_list|(
name|bank
argument_list|)
operator||
name|SNECR_MEMBS_BSEN
argument_list|)
expr_stmt|;
comment|/* update current bank */
name|sc
operator|->
name|curbank
operator|=
name|bank
expr_stmt|;
block|}
return|return
name|noffset
return|;
block|}
end_function

begin_comment
comment|/*  * write to SONIC descriptors.  */
end_comment

begin_function
name|void
name|snc_nec16_writetodesc
parameter_list|(
name|sc
parameter_list|,
name|base
parameter_list|,
name|offset
parameter_list|,
name|val
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|base
decl_stmt|;
name|u_int32_t
name|offset
decl_stmt|;
name|u_int16_t
name|val
decl_stmt|;
block|{
name|bus_space_tag_t
name|memt
init|=
name|sc
operator|->
name|sc_memt
decl_stmt|;
name|bus_space_handle_t
name|memh
init|=
name|sc
operator|->
name|sc_memh
decl_stmt|;
name|u_int16_t
name|noffset
decl_stmt|;
name|noffset
operator|=
name|snc_nec16_select_bank
argument_list|(
name|sc
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|bus_space_write_2
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|noffset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * read from SONIC descriptors.  */
end_comment

begin_function
name|u_int16_t
name|snc_nec16_readfromdesc
parameter_list|(
name|sc
parameter_list|,
name|base
parameter_list|,
name|offset
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|base
decl_stmt|;
name|u_int32_t
name|offset
decl_stmt|;
block|{
name|bus_space_tag_t
name|memt
init|=
name|sc
operator|->
name|sc_memt
decl_stmt|;
name|bus_space_handle_t
name|memh
init|=
name|sc
operator|->
name|sc_memh
decl_stmt|;
name|u_int16_t
name|noffset
decl_stmt|;
name|noffset
operator|=
name|snc_nec16_select_bank
argument_list|(
name|sc
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|bus_space_read_2
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|noffset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * read from SONIC data buffer.  */
end_comment

begin_function
name|void
name|snc_nec16_copyfrombuf
parameter_list|(
name|sc
parameter_list|,
name|dst
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
name|void
modifier|*
name|dst
decl_stmt|;
name|u_int32_t
name|offset
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|bus_space_tag_t
name|memt
init|=
name|sc
operator|->
name|sc_memt
decl_stmt|;
name|bus_space_handle_t
name|memh
init|=
name|sc
operator|->
name|sc_memh
decl_stmt|;
name|u_int16_t
name|noffset
decl_stmt|;
name|u_int8_t
modifier|*
name|bptr
init|=
name|dst
decl_stmt|;
name|noffset
operator|=
name|snc_nec16_select_bank
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX: should check if offset + size< 0x2000. */
name|bus_space_barrier
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|noffset
argument_list|,
name|size
argument_list|,
name|BUS_SPACE_BARRIER_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|noffset
operator|&
literal|3
condition|)
block|{
name|size_t
name|asize
init|=
operator|(
operator|~
name|noffset
operator|&
literal|3
operator|)
decl_stmt|;
name|bus_space_read_region_1
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|noffset
argument_list|,
name|bptr
argument_list|,
name|asize
argument_list|)
expr_stmt|;
name|bptr
operator|+=
name|asize
expr_stmt|;
name|noffset
operator|+=
name|asize
expr_stmt|;
name|size
operator|-=
name|asize
expr_stmt|;
block|}
name|bus_space_read_region_4
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|noffset
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|bptr
argument_list|,
name|size
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|bptr
operator|+=
name|size
operator|&
operator|~
literal|3
expr_stmt|;
name|noffset
operator|+=
name|size
operator|&
operator|~
literal|3
expr_stmt|;
name|size
operator|&=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|size
condition|)
name|bus_space_read_region_1
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|noffset
argument_list|,
name|bptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * write to SONIC data buffer.  */
end_comment

begin_function
name|void
name|snc_nec16_copytobuf
parameter_list|(
name|sc
parameter_list|,
name|src
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
name|void
modifier|*
name|src
decl_stmt|;
name|u_int32_t
name|offset
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|bus_space_tag_t
name|memt
init|=
name|sc
operator|->
name|sc_memt
decl_stmt|;
name|bus_space_handle_t
name|memh
init|=
name|sc
operator|->
name|sc_memh
decl_stmt|;
name|u_int16_t
name|noffset
decl_stmt|,
name|onoffset
decl_stmt|;
name|size_t
name|osize
init|=
name|size
decl_stmt|;
name|u_int8_t
modifier|*
name|bptr
init|=
name|src
decl_stmt|;
name|noffset
operator|=
name|snc_nec16_select_bank
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|onoffset
operator|=
name|noffset
expr_stmt|;
comment|/* XXX: should check if offset + size< 0x2000. */
if|if
condition|(
name|size
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|noffset
operator|&
literal|3
condition|)
block|{
name|size_t
name|asize
init|=
operator|(
operator|~
name|noffset
operator|&
literal|3
operator|)
decl_stmt|;
name|bus_space_write_region_1
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|noffset
argument_list|,
name|bptr
argument_list|,
name|asize
argument_list|)
expr_stmt|;
name|bptr
operator|+=
name|asize
expr_stmt|;
name|noffset
operator|+=
name|asize
expr_stmt|;
name|size
operator|-=
name|asize
expr_stmt|;
block|}
name|bus_space_write_region_4
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|noffset
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|bptr
argument_list|,
name|size
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|bptr
operator|+=
name|size
operator|&
operator|~
literal|3
expr_stmt|;
name|noffset
operator|+=
name|size
operator|&
operator|~
literal|3
expr_stmt|;
name|size
operator|-=
name|size
operator|&
operator|~
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|size
condition|)
name|bus_space_write_region_1
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|noffset
argument_list|,
name|bptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|bus_space_barrier
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|onoffset
argument_list|,
name|osize
argument_list|,
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * write (fill) 0 to SONIC data buffer.  */
end_comment

begin_function
name|void
name|snc_nec16_zerobuf
parameter_list|(
name|sc
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|offset
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|bus_space_tag_t
name|memt
init|=
name|sc
operator|->
name|sc_memt
decl_stmt|;
name|bus_space_handle_t
name|memh
init|=
name|sc
operator|->
name|sc_memh
decl_stmt|;
name|u_int16_t
name|noffset
decl_stmt|,
name|onoffset
decl_stmt|;
name|size_t
name|osize
init|=
name|size
decl_stmt|;
name|noffset
operator|=
name|snc_nec16_select_bank
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|onoffset
operator|=
name|noffset
expr_stmt|;
comment|/* XXX: should check if offset + size< 0x2000. */
if|if
condition|(
name|size
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|noffset
operator|&
literal|3
condition|)
block|{
name|size_t
name|asize
init|=
operator|(
operator|~
name|noffset
operator|&
literal|3
operator|)
decl_stmt|;
name|bus_space_set_region_1
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|noffset
argument_list|,
literal|0
argument_list|,
name|asize
argument_list|)
expr_stmt|;
name|noffset
operator|+=
name|asize
expr_stmt|;
name|size
operator|-=
name|asize
expr_stmt|;
block|}
name|bus_space_set_region_4
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|noffset
argument_list|,
literal|0
argument_list|,
name|size
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|noffset
operator|+=
name|size
operator|&
operator|~
literal|3
expr_stmt|;
name|size
operator|-=
name|size
operator|&
operator|~
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|size
condition|)
name|bus_space_set_region_1
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|noffset
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|bus_space_barrier
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|onoffset
argument_list|,
name|osize
argument_list|,
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Routines to read bytes sequentially from EEPROM through NEC PC-9801-83,  * 84, 103, 104, PC-9801N-25 and PC-9801N-J02, J02R for NetBSD/pc98.  * Ported by Kouichi Matsuda.  *   * This algorism is generic to read data sequentially from 4-Wire  * Microwire Serial EEPROM.  */
end_comment

begin_define
define|#
directive|define
name|SNEC_EEP_DELAY
value|1000
end_define

begin_function
name|void
name|snc_nec16_read_eeprom
parameter_list|(
name|iot
parameter_list|,
name|ioh
parameter_list|,
name|data
parameter_list|)
name|bus_space_tag_t
name|iot
decl_stmt|;
name|bus_space_handle_t
name|ioh
decl_stmt|;
name|u_int8_t
modifier|*
name|data
decl_stmt|;
block|{
name|u_int8_t
name|n
decl_stmt|,
name|val
decl_stmt|,
name|bit
decl_stmt|;
comment|/* Read bytes from EEPROM; two bytes per an iteration. */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|SNEC_EEPROM_SIZE
operator|/
literal|2
condition|;
name|n
operator|++
control|)
block|{
comment|/* select SNECR_EEP */
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_ADDR
argument_list|,
name|SNECR_EEP
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|SNEC_EEP_DELAY
argument_list|)
expr_stmt|;
comment|/* Start EEPROM access. */
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_EEP_CS
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|SNEC_EEP_DELAY
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_EEP_CS
operator||
name|SNECR_EEP_SK
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|SNEC_EEP_DELAY
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_EEP_CS
operator||
name|SNECR_EEP_DI
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|SNEC_EEP_DELAY
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_EEP_CS
operator||
name|SNECR_EEP_SK
operator||
name|SNECR_EEP_DI
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|SNEC_EEP_DELAY
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_EEP_CS
operator||
name|SNECR_EEP_DI
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|SNEC_EEP_DELAY
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_EEP_CS
operator||
name|SNECR_EEP_SK
operator||
name|SNECR_EEP_DI
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|SNEC_EEP_DELAY
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_EEP_CS
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|SNEC_EEP_DELAY
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_EEP_CS
operator||
name|SNECR_EEP_SK
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|SNEC_EEP_DELAY
argument_list|)
expr_stmt|;
comment|/* Pass the iteration count to the chip. */
for|for
control|(
name|bit
operator|=
literal|0x20
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_EEP_CS
operator||
operator|(
operator|(
name|n
operator|&
name|bit
operator|)
condition|?
name|SNECR_EEP_DI
else|:
literal|0x00
operator|)
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|SNEC_EEP_DELAY
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_EEP_CS
operator||
name|SNECR_EEP_SK
operator||
operator|(
operator|(
name|n
operator|&
name|bit
operator|)
condition|?
name|SNECR_EEP_DI
else|:
literal|0x00
operator|)
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|SNEC_EEP_DELAY
argument_list|)
expr_stmt|;
block|}
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_EEP_CS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bus_space_read_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|)
expr_stmt|;
comment|/* ACK */
name|delay
argument_list|(
name|SNEC_EEP_DELAY
argument_list|)
expr_stmt|;
comment|/* Read a byte. */
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_EEP_CS
operator||
name|SNECR_EEP_SK
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|SNEC_EEP_DELAY
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_EEP_CS
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_space_read_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|)
operator|&
name|SNECR_EEP_DO
condition|)
name|val
operator||=
name|bit
expr_stmt|;
block|}
operator|*
name|data
operator|++
operator|=
name|val
expr_stmt|;
comment|/* Read one more byte. */
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_EEP_CS
operator||
name|SNECR_EEP_SK
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|SNEC_EEP_DELAY
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
name|SNECR_EEP_CS
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_space_read_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|)
operator|&
name|SNECR_EEP_DO
condition|)
name|val
operator||=
name|bit
expr_stmt|;
block|}
operator|*
name|data
operator|++
operator|=
name|val
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|SNEC_EEP_DELAY
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SNCDEBUG
comment|/* Report what we got. */
name|data
operator|-=
name|SNEC_EEPROM_SIZE
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: EEPROM:"
literal|" %02x%02x%02x%02x %02x%02x%02x%02x -"
literal|" %02x%02x%02x%02x %02x%02x%02x%02x -"
literal|" %02x%02x%02x%02x %02x%02x%02x%02x -"
literal|" %02x%02x%02x%02x %02x%02x%02x%02x\n"
argument_list|,
literal|"snc_nec16_read_eeprom"
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|,
name|data
index|[
literal|4
index|]
argument_list|,
name|data
index|[
literal|5
index|]
argument_list|,
name|data
index|[
literal|6
index|]
argument_list|,
name|data
index|[
literal|7
index|]
argument_list|,
name|data
index|[
literal|8
index|]
argument_list|,
name|data
index|[
literal|9
index|]
argument_list|,
name|data
index|[
literal|10
index|]
argument_list|,
name|data
index|[
literal|11
index|]
argument_list|,
name|data
index|[
literal|12
index|]
argument_list|,
name|data
index|[
literal|13
index|]
argument_list|,
name|data
index|[
literal|14
index|]
argument_list|,
name|data
index|[
literal|15
index|]
argument_list|,
name|data
index|[
literal|16
index|]
argument_list|,
name|data
index|[
literal|17
index|]
argument_list|,
name|data
index|[
literal|18
index|]
argument_list|,
name|data
index|[
literal|19
index|]
argument_list|,
name|data
index|[
literal|20
index|]
argument_list|,
name|data
index|[
literal|21
index|]
argument_list|,
name|data
index|[
literal|22
index|]
argument_list|,
name|data
index|[
literal|23
index|]
argument_list|,
name|data
index|[
literal|24
index|]
argument_list|,
name|data
index|[
literal|25
index|]
argument_list|,
name|data
index|[
literal|26
index|]
argument_list|,
name|data
index|[
literal|27
index|]
argument_list|,
name|data
index|[
literal|28
index|]
argument_list|,
name|data
index|[
literal|29
index|]
argument_list|,
name|data
index|[
literal|30
index|]
argument_list|,
name|data
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SNCDEBUG
end_ifdef

begin_function
name|void
name|snc_nec16_dump_reg
parameter_list|(
name|iot
parameter_list|,
name|ioh
parameter_list|)
name|bus_space_tag_t
name|iot
decl_stmt|;
name|bus_space_handle_t
name|ioh
decl_stmt|;
block|{
name|u_int8_t
name|n
decl_stmt|;
name|u_int16_t
name|val
decl_stmt|;
name|printf
argument_list|(
literal|"SONIC registers (word):"
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|SNC_NREGS
condition|;
name|n
operator|++
control|)
block|{
comment|/* select required SONIC register */
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_ADDR
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|val
operator|=
name|bus_space_read_2
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|%
literal|0x10
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n%04x "
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%04x "
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"NEC/SONIC registers (byte):\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|SNECR_MEMBS
init|;
name|n
operator|<=
name|SNECR_IDENT
condition|;
name|n
operator|+=
literal|2
control|)
block|{
comment|/* select required SONIC register */
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_ADDR
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|u_int16_t
operator|)
name|bus_space_read_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|SNEC_CTRLB
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%04x "
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SNCDEBUG */
end_comment

end_unit

