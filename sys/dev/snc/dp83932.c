begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$NecBSD: dp83932.c,v 1.5 1999/07/29 05:08:44 kmatsuda Exp $	*/
end_comment

begin_comment
comment|/*	$NetBSD: if_snc.c,v 1.18 1998/04/25 21:27:40 scottr Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1997, 1998, 1999  *	Kouichi Matsuda.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Kouichi Matsuda for  *      NetBSD/pc98.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Modified for FreeBSD(98) 4.0 from NetBSD/pc98 1.4.2 by Motomichi Matsuzaki.  */
end_comment

begin_comment
comment|/*  * Modified for NetBSD/pc98 1.2G from NetBSD/mac68k 1.2G by Kouichi Matsuda.  * Make adapted for NEC PC-9801-83, 84, PC-9801-103, 104, PC-9801N-25 and  * PC-9801N-J02, J02R, which uses National Semiconductor DP83934AVQB as  * Ethernet Controller and National Semiconductor NS46C46 as  * (64 * 16 bits) Microwire Serial EEPROM.  */
end_comment

begin_comment
comment|/*  * National Semiconductor  DP8393X SONIC Driver  * Copyright (c) 1991   Algorithmics Ltd (http://www.algor.co.uk)  * You may use, copy, and modify this program so long as you retain the  * copyright line.  *  * This driver has been substantially modified since Algorithmics donated  * it.  *  *   Denton Gentry<denny1@home.com>  * and also  *   Yanagisawa Takeshi<yanagisw@aa.ap.titech.ac.jp>  * did the work to get this running on the Macintosh.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_if
if|#
directive|if
name|NRND
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/rnd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/snc/dp83932reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/snc/dp83932var.h>
end_include

begin_decl_stmt
name|hide
name|void
name|sncwatchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hide
name|void
name|sncinit
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hide
name|int
name|sncstop
name|__P
argument_list|(
operator|(
expr|struct
name|snc_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hide
name|int
name|sncioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
name|u_long
name|cmd
operator|,
name|caddr_t
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hide
name|void
name|sncstart
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hide
name|void
name|sncreset
name|__P
argument_list|(
operator|(
expr|struct
name|snc_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hide
name|void
name|caminitialise
name|__P
argument_list|(
operator|(
expr|struct
name|snc_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hide
name|void
name|camentry
name|__P
argument_list|(
operator|(
expr|struct
name|snc_softc
operator|*
operator|,
name|int
operator|,
name|u_char
operator|*
name|ea
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hide
name|void
name|camprogram
name|__P
argument_list|(
operator|(
expr|struct
name|snc_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hide
name|void
name|initialise_tda
name|__P
argument_list|(
operator|(
expr|struct
name|snc_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hide
name|void
name|initialise_rda
name|__P
argument_list|(
operator|(
expr|struct
name|snc_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hide
name|void
name|initialise_rra
name|__P
argument_list|(
operator|(
expr|struct
name|snc_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SNCDEBUG
end_ifdef

begin_decl_stmt
name|hide
name|void
name|camdump
name|__P
argument_list|(
operator|(
expr|struct
name|snc_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|hide
name|void
name|sonictxint
name|__P
argument_list|(
operator|(
expr|struct
name|snc_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hide
name|void
name|sonicrxint
name|__P
argument_list|(
operator|(
expr|struct
name|snc_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hide
name|u_int
name|sonicput
name|__P
argument_list|(
operator|(
expr|struct
name|snc_softc
operator|*
name|sc
operator|,
expr|struct
name|mbuf
operator|*
name|m0
operator|,
name|int
name|mtd_next
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hide
name|int
name|sonic_read
name|__P
argument_list|(
operator|(
expr|struct
name|snc_softc
operator|*
operator|,
name|u_int32_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hide
name|struct
name|mbuf
modifier|*
name|sonic_get
name|__P
argument_list|(
operator|(
expr|struct
name|snc_softc
operator|*
operator|,
name|u_int32_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|snc_enable
name|__P
argument_list|(
operator|(
expr|struct
name|snc_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|snc_disable
name|__P
argument_list|(
operator|(
expr|struct
name|snc_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|snc_mediachange
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|snc_mediastatus
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
expr|struct
name|ifmediareq
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NetBSD
end_ifdef

begin_if
if|#
directive|if
name|NetBSD
operator|<=
literal|199714
end_if

begin_decl_stmt
name|struct
name|cfdriver
name|snc_cd
init|=
block|{
name|NULL
block|,
literal|"snc"
block|,
name|DV_IFNET
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|assert
end_undef

begin_undef
undef|#
directive|undef
name|_assert
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|NDEBUG
end_ifdef

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|e
parameter_list|)
value|((void)0)
end_define

begin_define
define|#
directive|define
name|_assert
parameter_list|(
name|e
parameter_list|)
value|((void)0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_assert
parameter_list|(
name|e
parameter_list|)
value|assert(e)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|e
parameter_list|)
value|((e) ? (void)0 : __assert("snc ", __FILE__, __LINE__, #e))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* PCC */
end_comment

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|e
parameter_list|)
value|((e) ? (void)0 : __assert("snc "__FILE__, __LINE__, "e"))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SNCDEBUG
end_ifdef

begin_define
define|#
directive|define
name|SNC_SHOWTXHDR
value|0x01
end_define

begin_comment
comment|/* show tx ether_header */
end_comment

begin_define
define|#
directive|define
name|SNC_SHOWRXHDR
value|0x02
end_define

begin_comment
comment|/* show rx ether_header */
end_comment

begin_define
define|#
directive|define
name|SNC_SHOWCAMENT
value|0x04
end_define

begin_comment
comment|/* show CAM entry */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SNCDEBUG */
end_comment

begin_decl_stmt
name|int
name|sncdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sncconfig
parameter_list|(
name|sc
parameter_list|,
name|media
parameter_list|,
name|nmedia
parameter_list|,
name|defmedia
parameter_list|,
name|myea
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
name|int
modifier|*
name|media
decl_stmt|,
name|nmedia
decl_stmt|,
name|defmedia
decl_stmt|;
name|u_int8_t
modifier|*
name|myea
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|SNCDEBUG
if|if
condition|(
operator|(
name|sncdebug
operator|&
name|SNC_SHOWCAMENT
operator|)
operator|!=
literal|0
condition|)
block|{
name|camdump
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"address %6D\n"
argument_list|,
name|myea
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SNCDEBUG
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"buffers: rra=0x%x cda=0x%x rda=0x%x tda=0x%x\n"
argument_list|,
name|sc
operator|->
name|v_rra
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|v_cda
argument_list|,
name|sc
operator|->
name|v_rda
argument_list|,
name|sc
operator|->
name|mtda
index|[
literal|0
index|]
operator|.
name|mtd_vtxp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"snc"
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|sncioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|sncstart
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|sncwatchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|sncinit
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|bcopy
argument_list|(
name|myea
argument_list|,
name|sc
operator|->
name|sc_ethercom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Initialize media goo. */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
literal|0
argument_list|,
name|snc_mediachange
argument_list|,
name|snc_mediastatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|media
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmedia
condition|;
name|i
operator|++
control|)
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|media
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|defmedia
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_MANUAL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_MANUAL
argument_list|)
expr_stmt|;
block|}
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
if|#
directive|if
name|NRND
operator|>
literal|0
name|rnd_attach_source
argument_list|(
operator|&
name|sc
operator|->
name|rnd_source
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|RND_TYPE_NET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|sncshutdown
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|sncstop
argument_list|(
operator|(
expr|struct
name|snc_softc
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Media change callback.  */
end_comment

begin_function
name|int
name|snc_mediachange
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|snc_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mediachange
condition|)
return|return
operator|(
call|(
modifier|*
name|sc
operator|->
name|sc_mediachange
call|)
argument_list|(
name|sc
argument_list|)
operator|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Media status callback.  */
end_comment

begin_function
name|void
name|snc_mediastatus
parameter_list|(
name|ifp
parameter_list|,
name|ifmr
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmediareq
modifier|*
name|ifmr
decl_stmt|;
block|{
name|struct
name|snc_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_enabled
operator|==
literal|0
condition|)
block|{
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_NONE
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_mediastatus
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_mediastatus
call|)
argument_list|(
name|sc
argument_list|,
name|ifmr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|hide
name|int
name|sncioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|struct
name|snc_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|int
name|temp
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|err
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * If interface is marked down and it is running, 			 * then stop it. 			 */
name|sncstop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|snc_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If interface is marked up and it is stopped, 			 * then start it. 			 */
if|if
condition|(
operator|(
name|err
operator|=
name|snc_enable
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|sncinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_enabled
condition|)
block|{
comment|/* 			 * reset the interface to pick up any other changes 			 * in flags 			 */
name|temp
operator|=
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
expr_stmt|;
name|sncreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|temp
expr_stmt|;
name|sncstart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
if|if
condition|(
name|sc
operator|->
name|sc_enabled
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
name|temp
operator|=
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
expr_stmt|;
name|sncreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|temp
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
name|err
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encapsulate a packet of type family for the local net.  */
end_comment

begin_function
name|hide
name|void
name|sncstart
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|snc_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|mtd_next
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_RUNNING
condition|)
return|return;
name|outloop
label|:
comment|/* Check for room in the xmit buffer. */
if|if
condition|(
operator|(
name|mtd_next
operator|=
operator|(
name|sc
operator|->
name|mtd_free
operator|+
literal|1
operator|)
operator|)
operator|==
name|NTDA
condition|)
name|mtd_next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mtd_next
operator|==
name|sc
operator|->
name|mtd_hw
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
comment|/* We need the header for m_pkthdr.len. */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: sncstart: no header mbuf"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If bpf is listening on this interface, let it 	 * see the packet before we commit it to the wire. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * If there is nothing in the o/p queue, and there is room in 	 * the Tx ring, then send the packet directly.  Otherwise append 	 * it to the o/p queue. 	 */
if|if
condition|(
operator|(
name|sonicput
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|mtd_next
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|mtd_prev
operator|=
name|sc
operator|->
name|mtd_free
expr_stmt|;
name|sc
operator|->
name|mtd_free
operator|=
name|mtd_next
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
comment|/* # of pkts */
comment|/* Jump back for possibly more punishment. */
goto|goto
name|outloop
goto|;
block|}
end_function

begin_comment
comment|/*  * reset and restart the SONIC.  Called in case of fatal  * hardware/software errors.  */
end_comment

begin_function
name|hide
name|void
name|sncreset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|sncstop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sncinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|hide
name|void
name|sncinit
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|snc_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|u_long
name|s_rcr
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
comment|/* already running */
return|return;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_CR
argument_list|,
name|CR_RST
argument_list|)
expr_stmt|;
comment|/* DCR only accessable in reset mode! */
comment|/* config it */
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_DCR
argument_list|,
operator|(
name|sc
operator|->
name|sncr_dcr
operator||
operator|(
name|sc
operator|->
name|bitmode
condition|?
name|DCR_DW32
else|:
name|DCR_DW16
operator|)
operator|)
argument_list|)
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_DCR2
argument_list|,
name|sc
operator|->
name|sncr_dcr2
argument_list|)
expr_stmt|;
name|s_rcr
operator|=
name|RCR_BRD
operator||
name|RCR_LBNONE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|s_rcr
operator||=
name|RCR_PRO
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
name|s_rcr
operator||=
name|RCR_AMC
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_RCR
argument_list|,
name|s_rcr
argument_list|)
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_IMR
argument_list|,
operator|(
name|IMR_PRXEN
operator||
name|IMR_PTXEN
operator||
name|IMR_TXEREN
operator||
name|IMR_LCDEN
operator|)
argument_list|)
expr_stmt|;
comment|/* clear pending interrupts */
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_ISR
argument_list|,
name|ISR_ALL
argument_list|)
expr_stmt|;
comment|/* clear tally counters */
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_CRCT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_FAET
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_MPT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|initialise_tda
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|initialise_rda
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|initialise_rra
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* enable the chip */
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wbflush
argument_list|()
expr_stmt|;
comment|/* program the CAM */
name|camprogram
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* get it to read resource descriptors */
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_CR
argument_list|,
name|CR_RRRA
argument_list|)
expr_stmt|;
name|wbflush
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|NIC_GET
argument_list|(
name|sc
argument_list|,
name|SNCR_CR
argument_list|)
operator|)
operator|&
name|CR_RRRA
condition|)
continue|continue;
comment|/* enable rx */
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_CR
argument_list|,
name|CR_RXEN
argument_list|)
expr_stmt|;
name|wbflush
argument_list|()
expr_stmt|;
comment|/* flag interface as "running" */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * close down an interface and free its buffers  * Called on final close of device, or if sncinit() fails  * part way through.  */
end_comment

begin_function
name|hide
name|int
name|sncstop
parameter_list|(
name|sc
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|mtd
modifier|*
name|mtd
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* stick chip in reset */
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_CR
argument_list|,
name|CR_RST
argument_list|)
expr_stmt|;
name|wbflush
argument_list|()
expr_stmt|;
comment|/* free all receive buffers (currently static so nothing to do) */
comment|/* free all pending transmit mbufs */
while|while
condition|(
name|sc
operator|->
name|mtd_hw
operator|!=
name|sc
operator|->
name|mtd_free
condition|)
block|{
name|mtd
operator|=
operator|&
name|sc
operator|->
name|mtda
index|[
name|sc
operator|->
name|mtd_hw
index|]
expr_stmt|;
if|if
condition|(
name|mtd
operator|->
name|mtd_mbuf
condition|)
name|m_freem
argument_list|(
name|mtd
operator|->
name|mtd_mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|sc
operator|->
name|mtd_hw
operator|==
name|NTDA
condition|)
name|sc
operator|->
name|mtd_hw
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|sc_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_UP
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called if any Tx packets remain unsent after 5 seconds,  * In all cases we just reset the chip, and any retransmission  * will be handled by higher level protocol timeouts.  */
end_comment

begin_function
name|hide
name|void
name|sncwatchdog
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|snc_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mtd
modifier|*
name|mtd
decl_stmt|;
name|int
name|temp
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|mtd_hw
operator|!=
name|sc
operator|->
name|mtd_free
condition|)
block|{
comment|/* something still pending for transmit */
name|mtd
operator|=
operator|&
name|sc
operator|->
name|mtda
index|[
name|sc
operator|->
name|mtd_hw
index|]
expr_stmt|;
if|if
condition|(
name|SRO
argument_list|(
name|sc
argument_list|,
name|mtd
operator|->
name|mtd_vtxp
argument_list|,
name|TXP_STATUS
argument_list|)
operator|==
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: Tx - timeout\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: Tx - lost interrupt\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
expr_stmt|;
name|sncreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|temp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * stuff packet into sonic (at splnet)  */
end_comment

begin_function
name|hide
name|u_int
name|sonicput
parameter_list|(
name|sc
parameter_list|,
name|m0
parameter_list|,
name|mtd_next
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|int
name|mtd_next
decl_stmt|;
block|{
name|struct
name|mtd
modifier|*
name|mtdp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int32_t
name|buff
decl_stmt|;
name|u_int32_t
name|txp
decl_stmt|;
name|u_int
name|len
init|=
literal|0
decl_stmt|;
name|u_int
name|totlen
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|whyonearthwouldyoudothis
if|if
condition|(
name|NIC_GET
argument_list|(
name|sc
argument_list|,
name|SNCR_CR
argument_list|)
operator|&
name|CR_TXP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* grab the replacement mtd */
name|mtdp
operator|=
operator|&
name|sc
operator|->
name|mtda
index|[
name|sc
operator|->
name|mtd_free
index|]
expr_stmt|;
name|buff
operator|=
name|mtdp
operator|->
name|mtd_vbuf
expr_stmt|;
comment|/* this packet goes to mtdnext fill in the TDA */
name|mtdp
operator|->
name|mtd_mbuf
operator|=
name|m0
expr_stmt|;
name|txp
operator|=
name|mtdp
operator|->
name|mtd_vtxp
expr_stmt|;
comment|/* Write to the config word. Every (NTDA/2)+1 packets we set an intr */
if|if
condition|(
name|sc
operator|->
name|mtd_pint
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|mtd_pint
operator|=
name|NTDA
operator|/
literal|2
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|txp
argument_list|,
name|TXP_CONFIG
argument_list|,
name|TCR_PINT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|mtd_pint
operator|--
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|txp
argument_list|,
name|TXP_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|totlen
operator|+=
name|len
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_copytobuf
call|)
argument_list|(
name|sc
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|buff
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buff
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|totlen
operator|>=
name|TXBSIZE
condition|)
block|{
name|panic
argument_list|(
literal|"%s: sonicput: packet overflow"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SWO
argument_list|(
name|sc
argument_list|,
name|txp
argument_list|,
name|TXP_FRAGOFF
operator|+
operator|(
literal|0
operator|*
name|TXP_FRAGSIZE
operator|)
operator|+
name|TXP_FPTRLO
argument_list|,
name|LOWER
argument_list|(
name|mtdp
operator|->
name|mtd_vbuf
argument_list|)
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|txp
argument_list|,
name|TXP_FRAGOFF
operator|+
operator|(
literal|0
operator|*
name|TXP_FRAGSIZE
operator|)
operator|+
name|TXP_FPTRHI
argument_list|,
name|UPPER
argument_list|(
name|mtdp
operator|->
name|mtd_vbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|totlen
operator|<
name|ETHERMIN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
condition|)
block|{
name|int
name|pad
init|=
name|ETHERMIN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|-
name|totlen
decl_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_zerobuf
call|)
argument_list|(
name|sc
argument_list|,
name|mtdp
operator|->
name|mtd_vbuf
operator|+
name|totlen
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|totlen
operator|=
name|ETHERMIN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
block|}
name|SWO
argument_list|(
name|sc
argument_list|,
name|txp
argument_list|,
name|TXP_FRAGOFF
operator|+
operator|(
literal|0
operator|*
name|TXP_FRAGSIZE
operator|)
operator|+
name|TXP_FSIZE
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|txp
argument_list|,
name|TXP_FRAGCNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|txp
argument_list|,
name|TXP_PKTSIZE
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
comment|/* link onto the next mtd that will be used */
name|SWO
argument_list|(
name|sc
argument_list|,
name|txp
argument_list|,
name|TXP_FRAGOFF
operator|+
operator|(
literal|1
operator|*
name|TXP_FRAGSIZE
operator|)
operator|+
name|TXP_FPTRLO
argument_list|,
name|LOWER
argument_list|(
name|sc
operator|->
name|mtda
index|[
name|mtd_next
index|]
operator|.
name|mtd_vtxp
argument_list|)
operator||
name|EOL
argument_list|)
expr_stmt|;
comment|/* 	 * The previous txp.tlink currently contains a pointer to 	 * our txp | EOL. Want to clear the EOL, so write our 	 * pointer to the previous txp. 	 */
name|SWO
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mtda
index|[
name|sc
operator|->
name|mtd_prev
index|]
operator|.
name|mtd_vtxp
argument_list|,
name|sc
operator|->
name|mtd_tlinko
argument_list|,
name|LOWER
argument_list|(
name|mtdp
operator|->
name|mtd_vtxp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* make sure chip is running */
name|wbflush
argument_list|()
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_CR
argument_list|,
name|CR_TXP
argument_list|)
expr_stmt|;
name|wbflush
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_timer
operator|=
literal|5
expr_stmt|;
comment|/* 5 seconds to watch for failing to transmit */
return|return
operator|(
name|totlen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * These are called from sonicioctl() when /etc/ifconfig is run to set  * the address or switch the i/f on.  */
end_comment

begin_comment
comment|/*  * CAM support  */
end_comment

begin_function
name|hide
name|void
name|caminitialise
parameter_list|(
name|sc
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|u_int32_t
name|v_cda
init|=
name|sc
operator|->
name|v_cda
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|camoffset
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCAM
condition|;
name|i
operator|++
control|)
block|{
name|camoffset
operator|=
name|i
operator|*
name|CDA_CAMDESC
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|v_cda
argument_list|,
operator|(
name|camoffset
operator|+
name|CDA_CAMEP
operator|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|v_cda
argument_list|,
operator|(
name|camoffset
operator|+
name|CDA_CAMAP2
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|v_cda
argument_list|,
operator|(
name|camoffset
operator|+
name|CDA_CAMAP1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|v_cda
argument_list|,
operator|(
name|camoffset
operator|+
name|CDA_CAMAP0
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|SWO
argument_list|(
name|sc
argument_list|,
name|v_cda
argument_list|,
name|CDA_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SNCDEBUG
if|if
condition|(
operator|(
name|sncdebug
operator|&
name|SNC_SHOWCAMENT
operator|)
operator|!=
literal|0
condition|)
block|{
name|camdump
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|hide
name|void
name|camentry
parameter_list|(
name|sc
parameter_list|,
name|entry
parameter_list|,
name|ea
parameter_list|)
name|int
name|entry
decl_stmt|;
name|u_char
modifier|*
name|ea
decl_stmt|;
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|u_int32_t
name|v_cda
init|=
name|sc
operator|->
name|v_cda
decl_stmt|;
name|int
name|camoffset
init|=
name|entry
operator|*
name|CDA_CAMDESC
decl_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|v_cda
argument_list|,
name|camoffset
operator|+
name|CDA_CAMEP
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|v_cda
argument_list|,
name|camoffset
operator|+
name|CDA_CAMAP2
argument_list|,
operator|(
name|ea
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|ea
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|v_cda
argument_list|,
name|camoffset
operator|+
name|CDA_CAMAP1
argument_list|,
operator|(
name|ea
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
name|ea
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|v_cda
argument_list|,
name|camoffset
operator|+
name|CDA_CAMAP0
argument_list|,
operator|(
name|ea
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|ea
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|v_cda
argument_list|,
name|CDA_ENABLE
argument_list|,
operator|(
name|SRO
argument_list|(
name|sc
argument_list|,
name|v_cda
argument_list|,
name|CDA_ENABLE
argument_list|)
operator||
operator|(
literal|1
operator|<<
name|entry
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|hide
name|void
name|camprogram
parameter_list|(
name|sc
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|int
name|mcount
init|=
literal|0
decl_stmt|;
name|caminitialise
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|sc_if
expr_stmt|;
comment|/* Always load our own address first. */
name|camentry
argument_list|(
name|sc
argument_list|,
name|mcount
argument_list|,
name|sc
operator|->
name|sc_ethercom
operator|.
name|ac_enaddr
argument_list|)
expr_stmt|;
name|mcount
operator|++
expr_stmt|;
comment|/* Assume we won't need allmulti bit. */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_ALLMULTI
expr_stmt|;
comment|/* Loop through multicast addresses */
for|for
control|(
name|ifma
operator|=
name|ifp
operator|->
name|if_multiaddrs
operator|.
name|lh_first
init|;
name|ifma
operator|!=
name|NULL
condition|;
name|ifma
operator|=
name|ifma
operator|->
name|ifma_link
operator|.
name|le_next
control|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|mcount
operator|==
name|MAXCAM
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
break|break;
block|}
comment|/* program the CAM with the specified entry */
name|camentry
argument_list|(
name|sc
argument_list|,
name|mcount
argument_list|,
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|)
expr_stmt|;
name|mcount
operator|++
expr_stmt|;
block|}
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_CDP
argument_list|,
name|LOWER
argument_list|(
name|sc
operator|->
name|v_cda
argument_list|)
argument_list|)
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_CDC
argument_list|,
name|MAXCAM
argument_list|)
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_CR
argument_list|,
name|CR_LCAM
argument_list|)
expr_stmt|;
name|wbflush
argument_list|()
expr_stmt|;
name|timeout
operator|=
literal|10000
expr_stmt|;
while|while
condition|(
operator|(
name|NIC_GET
argument_list|(
name|sc
argument_list|,
name|SNCR_CR
argument_list|)
operator|&
name|CR_LCAM
operator|)
operator|&&
name|timeout
operator|--
condition|)
continue|continue;
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
comment|/* XXX */
name|panic
argument_list|(
literal|"%s: CAM initialisation failed\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|timeout
operator|=
literal|10000
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|NIC_GET
argument_list|(
name|sc
argument_list|,
name|SNCR_ISR
argument_list|)
operator|&
name|ISR_LCD
operator|)
operator|==
literal|0
operator|)
operator|&&
name|timeout
operator|--
condition|)
continue|continue;
if|if
condition|(
name|NIC_GET
argument_list|(
name|sc
argument_list|,
name|SNCR_ISR
argument_list|)
operator|&
name|ISR_LCD
condition|)
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_ISR
argument_list|,
name|ISR_LCD
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"CAM initialisation without interrupt\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SNCDEBUG
end_ifdef

begin_function
name|hide
name|void
name|camdump
parameter_list|(
name|sc
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"CAM entries:\n"
argument_list|)
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_CR
argument_list|,
name|CR_RST
argument_list|)
expr_stmt|;
name|wbflush
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|ushort
name|ap2
decl_stmt|,
name|ap1
decl_stmt|,
name|ap0
decl_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_CEP
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|wbflush
argument_list|()
expr_stmt|;
name|ap2
operator|=
name|NIC_GET
argument_list|(
name|sc
argument_list|,
name|SNCR_CAP2
argument_list|)
expr_stmt|;
name|ap1
operator|=
name|NIC_GET
argument_list|(
name|sc
argument_list|,
name|SNCR_CAP1
argument_list|)
expr_stmt|;
name|ap0
operator|=
name|NIC_GET
argument_list|(
name|sc
argument_list|,
name|SNCR_CAP0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d: ap2=0x%x ap1=0x%x ap0=0x%x\n"
argument_list|,
name|i
argument_list|,
name|ap2
argument_list|,
name|ap1
argument_list|,
name|ap0
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"CAM enable 0x%x\n"
argument_list|,
name|NIC_GET
argument_list|(
name|sc
argument_list|,
name|SNCR_CEP
argument_list|)
argument_list|)
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wbflush
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|hide
name|void
name|initialise_tda
parameter_list|(
name|sc
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|mtd
modifier|*
name|mtd
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTDA
condition|;
name|i
operator|++
control|)
block|{
name|mtd
operator|=
operator|&
name|sc
operator|->
name|mtda
index|[
name|i
index|]
expr_stmt|;
name|mtd
operator|->
name|mtd_mbuf
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|mtd_hw
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mtd_prev
operator|=
name|NTDA
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|mtd_free
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mtd_tlinko
operator|=
name|TXP_FRAGOFF
operator|+
literal|1
operator|*
name|TXP_FRAGSIZE
operator|+
name|TXP_FPTRLO
expr_stmt|;
name|sc
operator|->
name|mtd_pint
operator|=
name|NTDA
operator|/
literal|2
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_UTDA
argument_list|,
name|UPPER
argument_list|(
name|sc
operator|->
name|mtda
index|[
literal|0
index|]
operator|.
name|mtd_vtxp
argument_list|)
argument_list|)
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_CTDA
argument_list|,
name|LOWER
argument_list|(
name|sc
operator|->
name|mtda
index|[
literal|0
index|]
operator|.
name|mtd_vtxp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|hide
name|void
name|initialise_rda
parameter_list|(
name|sc
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_int32_t
name|vv_rda
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|v_rda
init|=
literal|0
decl_stmt|;
comment|/* link the RDA's together into a circular list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|->
name|sc_nrda
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|v_rda
operator|=
name|sc
operator|->
name|v_rda
operator|+
operator|(
name|i
operator|*
name|RXPKT_SIZE
argument_list|(
name|sc
argument_list|)
operator|)
expr_stmt|;
name|vv_rda
operator|=
name|sc
operator|->
name|v_rda
operator|+
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|RXPKT_SIZE
argument_list|(
name|sc
argument_list|)
operator|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|v_rda
argument_list|,
name|RXPKT_RLINK
argument_list|,
name|LOWER
argument_list|(
name|vv_rda
argument_list|)
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|v_rda
argument_list|,
name|RXPKT_INUSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|v_rda
operator|=
name|sc
operator|->
name|v_rda
operator|+
operator|(
operator|(
name|sc
operator|->
name|sc_nrda
operator|-
literal|1
operator|)
operator|*
name|RXPKT_SIZE
argument_list|(
name|sc
argument_list|)
operator|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|v_rda
argument_list|,
name|RXPKT_RLINK
argument_list|,
name|LOWER
argument_list|(
name|sc
operator|->
name|v_rda
argument_list|)
operator||
name|EOL
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|v_rda
argument_list|,
name|RXPKT_INUSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* mark end of receive descriptor list */
name|sc
operator|->
name|sc_rdamark
operator|=
name|sc
operator|->
name|sc_nrda
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_rxmark
operator|=
literal|0
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_URDA
argument_list|,
name|UPPER
argument_list|(
name|sc
operator|->
name|v_rda
argument_list|)
argument_list|)
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_CRDA
argument_list|,
name|LOWER
argument_list|(
name|sc
operator|->
name|v_rda
argument_list|)
argument_list|)
expr_stmt|;
name|wbflush
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|hide
name|void
name|initialise_rra
parameter_list|(
name|sc
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_int
name|v
decl_stmt|;
name|int
name|bitmode
init|=
name|sc
operator|->
name|bitmode
decl_stmt|;
if|if
condition|(
name|bitmode
condition|)
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_EOBC
argument_list|,
name|RBASIZE
argument_list|(
name|sc
argument_list|)
operator|/
literal|2
operator|-
literal|2
argument_list|)
expr_stmt|;
else|else
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_EOBC
argument_list|,
name|RBASIZE
argument_list|(
name|sc
argument_list|)
operator|/
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_URRA
argument_list|,
name|UPPER
argument_list|(
name|sc
operator|->
name|v_rra
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_RSA
argument_list|,
name|LOWER
argument_list|(
name|sc
operator|->
name|v_rra
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* rea must point just past the end of the rra space */
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_REA
argument_list|,
name|LOWER
argument_list|(
name|sc
operator|->
name|v_rea
argument_list|)
argument_list|)
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_RRP
argument_list|,
name|LOWER
argument_list|(
name|sc
operator|->
name|v_rra
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_RSC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* fill up SOME of the rra with buffers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRBA
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
name|SONIC_GETDMA
argument_list|(
name|sc
operator|->
name|rbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|v_rra
index|[
name|i
index|]
argument_list|,
name|RXRSRC_PTRHI
argument_list|,
name|UPPER
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|v_rra
index|[
name|i
index|]
argument_list|,
name|RXRSRC_PTRLO
argument_list|,
name|LOWER
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|v_rra
index|[
name|i
index|]
argument_list|,
name|RXRSRC_WCHI
argument_list|,
name|UPPER
argument_list|(
name|NBPG
operator|/
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|v_rra
index|[
name|i
index|]
argument_list|,
name|RXRSRC_WCLO
argument_list|,
name|LOWER
argument_list|(
name|NBPG
operator|/
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_rramark
operator|=
name|NRBA
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_RWP
argument_list|,
name|LOWER
argument_list|(
name|sc
operator|->
name|v_rra
index|[
name|sc
operator|->
name|sc_rramark
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|wbflush
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sncintr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|snc_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|snc_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|isr
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_enabled
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
operator|(
name|isr
operator|=
operator|(
name|NIC_GET
argument_list|(
name|sc
argument_list|,
name|SNCR_ISR
argument_list|)
operator|&
name|ISR_ALL
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* scrub the interrupts that we are going to service */
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_ISR
argument_list|,
name|isr
argument_list|)
expr_stmt|;
name|wbflush
argument_list|()
expr_stmt|;
if|if
condition|(
name|isr
operator|&
operator|(
name|ISR_BR
operator||
name|ISR_LCD
operator||
name|ISR_TC
operator|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unexpected interrupt status 0x%x\n"
argument_list|,
name|isr
argument_list|)
expr_stmt|;
if|if
condition|(
name|isr
operator|&
operator|(
name|ISR_TXDN
operator||
name|ISR_TXER
operator||
name|ISR_PINT
operator|)
condition|)
name|sonictxint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|isr
operator|&
name|ISR_PKTRX
condition|)
name|sonicrxint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|isr
operator|&
operator|(
name|ISR_HBL
operator||
name|ISR_RDE
operator||
name|ISR_RBE
operator||
name|ISR_RBAE
operator||
name|ISR_RFO
operator|)
condition|)
block|{
if|if
condition|(
name|isr
operator|&
name|ISR_HBL
condition|)
comment|/* 				 * The repeater is not providing a heartbeat. 				 * In itself this isn't harmful, lots of the 				 * cheap repeater hubs don't supply a heartbeat. 				 * So ignore the lack of heartbeat. Its only 				 * if we can't detect a carrier that we have a 				 * problem. 				 */
empty_stmt|;
if|if
condition|(
name|isr
operator|&
name|ISR_RDE
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"receive descriptors exhausted\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isr
operator|&
name|ISR_RBE
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"receive buffers exhausted\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isr
operator|&
name|ISR_RBAE
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"receive buffer area exhausted\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isr
operator|&
name|ISR_RFO
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"receive FIFO overrun\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isr
operator|&
operator|(
name|ISR_CRC
operator||
name|ISR_FAE
operator||
name|ISR_MP
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|isr
operator|&
name|ISR_CRC
condition|)
name|sc
operator|->
name|sc_crctally
operator|++
expr_stmt|;
if|if
condition|(
name|isr
operator|&
name|ISR_FAE
condition|)
name|sc
operator|->
name|sc_faetally
operator|++
expr_stmt|;
if|if
condition|(
name|isr
operator|&
name|ISR_MP
condition|)
name|sc
operator|->
name|sc_mptally
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
name|sncstart
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
if|#
directive|if
name|NRND
operator|>
literal|0
if|if
condition|(
name|isr
condition|)
name|rnd_add_uint32
argument_list|(
operator|&
name|sc
operator|->
name|rnd_source
argument_list|,
name|isr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Transmit interrupt routine  */
end_comment

begin_function
name|hide
name|void
name|sonictxint
parameter_list|(
name|sc
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|mtd
modifier|*
name|mtd
decl_stmt|;
name|u_int32_t
name|txp
decl_stmt|;
name|unsigned
name|short
name|txp_status
decl_stmt|;
name|int
name|mtd_hw
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
name|mtd_hw
operator|=
name|sc
operator|->
name|mtd_hw
expr_stmt|;
if|if
condition|(
name|mtd_hw
operator|==
name|sc
operator|->
name|mtd_free
condition|)
return|return;
while|while
condition|(
name|mtd_hw
operator|!=
name|sc
operator|->
name|mtd_free
condition|)
block|{
name|mtd
operator|=
operator|&
name|sc
operator|->
name|mtda
index|[
name|mtd_hw
index|]
expr_stmt|;
name|txp
operator|=
name|mtd
operator|->
name|mtd_vtxp
expr_stmt|;
if|if
condition|(
name|SRO
argument_list|(
name|sc
argument_list|,
name|txp
argument_list|,
name|TXP_STATUS
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
comment|/* it hasn't really gone yet */
block|}
ifdef|#
directive|ifdef
name|SNCDEBUG
if|if
condition|(
operator|(
name|sncdebug
operator|&
name|SNC_SHOWTXHDR
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ether_header
name|eh
decl_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_copyfrombuf
call|)
argument_list|(
name|sc
argument_list|,
operator|&
name|eh
argument_list|,
name|mtd
operator|->
name|mtd_vbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"xmit status=0x%x len=%d type=0x%x from %6D"
argument_list|,
name|SRO
argument_list|(
name|sc
argument_list|,
name|txp
argument_list|,
name|TXP_STATUS
argument_list|)
argument_list|,
name|SRO
argument_list|(
name|sc
argument_list|,
name|txp
argument_list|,
name|TXP_PKTSIZE
argument_list|)
argument_list|,
name|htons
argument_list|(
name|eh
operator|.
name|ether_type
argument_list|)
argument_list|,
name|eh
operator|.
name|ether_shost
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (to %6D)\n"
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SNCDEBUG */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
if|if
condition|(
name|mtd
operator|->
name|mtd_mbuf
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|mtd
operator|->
name|mtd_mbuf
argument_list|)
expr_stmt|;
name|mtd
operator|->
name|mtd_mbuf
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|mtd_hw
operator|==
name|NTDA
condition|)
name|mtd_hw
operator|=
literal|0
expr_stmt|;
name|txp_status
operator|=
name|SRO
argument_list|(
name|sc
argument_list|,
name|txp
argument_list|,
name|TXP_STATUS
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|+=
operator|(
name|txp_status
operator|&
name|TCR_EXC
operator|)
condition|?
literal|16
else|:
operator|(
operator|(
name|txp_status
operator|&
name|TCR_NC
operator|)
operator|>>
literal|12
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|txp_status
operator|&
name|TCR_PTX
operator|)
operator|==
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Tx packet status=0x%x\n"
argument_list|,
name|txp_status
argument_list|)
expr_stmt|;
comment|/* XXX - DG This looks bogus */
if|if
condition|(
name|mtd_hw
operator|!=
name|sc
operator|->
name|mtd_free
condition|)
block|{
name|printf
argument_list|(
literal|"resubmitting remaining packets\n"
argument_list|)
expr_stmt|;
name|mtd
operator|=
operator|&
name|sc
operator|->
name|mtda
index|[
name|mtd_hw
index|]
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_CTDA
argument_list|,
name|LOWER
argument_list|(
name|mtd
operator|->
name|mtd_vtxp
argument_list|)
argument_list|)
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_CR
argument_list|,
name|CR_TXP
argument_list|)
expr_stmt|;
name|wbflush
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
name|sc
operator|->
name|mtd_hw
operator|=
name|mtd_hw
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Receive interrupt routine  */
end_comment

begin_function
name|hide
name|void
name|sonicrxint
parameter_list|(
name|sc
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|u_int32_t
name|rda
decl_stmt|;
name|int
name|orra
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|rramark
decl_stmt|;
name|int
name|rdamark
decl_stmt|;
name|u_int16_t
name|rxpkt_ptr
decl_stmt|;
name|rda
operator|=
name|sc
operator|->
name|v_rda
operator|+
operator|(
name|sc
operator|->
name|sc_rxmark
operator|*
name|RXPKT_SIZE
argument_list|(
name|sc
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
name|SRO
argument_list|(
name|sc
argument_list|,
name|rda
argument_list|,
name|RXPKT_INUSE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|u_int
name|status
init|=
name|SRO
argument_list|(
name|sc
argument_list|,
name|rda
argument_list|,
name|RXPKT_STATUS
argument_list|)
decl_stmt|;
name|orra
operator|=
name|RBASEQ
argument_list|(
name|SRO
argument_list|(
name|sc
argument_list|,
name|rda
argument_list|,
name|RXPKT_SEQNO
argument_list|)
argument_list|)
operator|&
name|RRAMASK
expr_stmt|;
name|rxpkt_ptr
operator|=
name|SRO
argument_list|(
name|sc
argument_list|,
name|rda
argument_list|,
name|RXPKT_PTRLO
argument_list|)
expr_stmt|;
comment|/* 		 * Do not trunc ether_header length. 		 * Our sonic_read() and sonic_get() require it. 		 */
name|len
operator|=
name|SRO
argument_list|(
name|sc
argument_list|,
name|rda
argument_list|,
name|RXPKT_BYTEC
argument_list|)
operator|-
name|FCSSIZE
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|RCR_PRX
condition|)
block|{
comment|/* XXX: Does PGOFSET require? */
name|u_int32_t
name|pkt
init|=
name|sc
operator|->
name|rbuf
index|[
name|orra
operator|&
name|RBAMASK
index|]
operator|+
operator|(
name|rxpkt_ptr
operator|&
name|PGOFSET
operator|)
decl_stmt|;
if|if
condition|(
name|sonic_read
argument_list|(
name|sc
argument_list|,
name|pkt
argument_list|,
name|len
argument_list|)
condition|)
name|sc
operator|->
name|sc_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
else|else
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
comment|/* 		 * give receive buffer area back to chip. 		 * 		 * If this was the last packet in the RRA, give the RRA to 		 * the chip again. 		 * If sonic read didnt copy it out then we would have to 		 * wait !! 		 * (dont bother add it back in again straight away) 		 * 		 * Really, we're doing v_rra[rramark] = v_rra[orra] but 		 * we have to use the macros because SONIC might be in 		 * 16 or 32 bit mode. 		 */
if|if
condition|(
name|status
operator|&
name|RCR_LPKT
condition|)
block|{
name|u_int32_t
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|rramark
operator|=
name|sc
operator|->
name|sc_rramark
expr_stmt|;
name|tmp1
operator|=
name|sc
operator|->
name|v_rra
index|[
name|rramark
index|]
expr_stmt|;
name|tmp2
operator|=
name|sc
operator|->
name|v_rra
index|[
name|orra
index|]
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|tmp1
argument_list|,
name|RXRSRC_PTRLO
argument_list|,
name|SRO
argument_list|(
name|sc
argument_list|,
name|tmp2
argument_list|,
name|RXRSRC_PTRLO
argument_list|)
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|tmp1
argument_list|,
name|RXRSRC_PTRHI
argument_list|,
name|SRO
argument_list|(
name|sc
argument_list|,
name|tmp2
argument_list|,
name|RXRSRC_PTRHI
argument_list|)
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|tmp1
argument_list|,
name|RXRSRC_WCLO
argument_list|,
name|SRO
argument_list|(
name|sc
argument_list|,
name|tmp2
argument_list|,
name|RXRSRC_WCLO
argument_list|)
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|tmp1
argument_list|,
name|RXRSRC_WCHI
argument_list|,
name|SRO
argument_list|(
name|sc
argument_list|,
name|tmp2
argument_list|,
name|RXRSRC_WCHI
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zap old rra for fun */
name|SWO
argument_list|(
name|sc
argument_list|,
name|tmp2
argument_list|,
name|RXRSRC_WCHI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|tmp2
argument_list|,
name|RXRSRC_WCLO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rramark
operator|=
operator|(
operator|++
name|rramark
operator|)
operator|&
name|RRAMASK
expr_stmt|;
name|NIC_PUT
argument_list|(
name|sc
argument_list|,
name|SNCR_RWP
argument_list|,
name|LOWER
argument_list|(
name|sc
operator|->
name|v_rra
index|[
name|rramark
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|wbflush
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * give receive descriptor back to chip simple 		 * list is circular 		 */
name|rdamark
operator|=
name|sc
operator|->
name|sc_rdamark
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|rda
argument_list|,
name|RXPKT_INUSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
name|rda
argument_list|,
name|RXPKT_RLINK
argument_list|,
name|SRO
argument_list|(
name|sc
argument_list|,
name|rda
argument_list|,
name|RXPKT_RLINK
argument_list|)
operator||
name|EOL
argument_list|)
expr_stmt|;
name|SWO
argument_list|(
name|sc
argument_list|,
operator|(
name|sc
operator|->
name|v_rda
operator|+
operator|(
name|rdamark
operator|*
name|RXPKT_SIZE
argument_list|(
name|sc
argument_list|)
operator|)
operator|)
argument_list|,
name|RXPKT_RLINK
argument_list|,
name|SRO
argument_list|(
name|sc
argument_list|,
operator|(
name|sc
operator|->
name|v_rda
operator|+
operator|(
name|rdamark
operator|*
name|RXPKT_SIZE
argument_list|(
name|sc
argument_list|)
operator|)
operator|)
argument_list|,
name|RXPKT_RLINK
argument_list|)
operator|&
operator|~
name|EOL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rdamark
operator|=
name|sc
operator|->
name|sc_rxmark
expr_stmt|;
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_rxmark
operator|>=
name|sc
operator|->
name|sc_nrda
condition|)
name|sc
operator|->
name|sc_rxmark
operator|=
literal|0
expr_stmt|;
name|rda
operator|=
name|sc
operator|->
name|v_rda
operator|+
operator|(
name|sc
operator|->
name|sc_rxmark
operator|*
name|RXPKT_SIZE
argument_list|(
name|sc
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * sonic_read -- pull packet off interface and forward to  * appropriate protocol handler  */
end_comment

begin_function
name|hide
name|int
name|sonic_read
parameter_list|(
name|sc
parameter_list|,
name|pkt
parameter_list|,
name|len
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|pkt
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|et
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|len
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|||
name|len
operator|>
name|ETHERMTU
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"invalid packet length %d bytes\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Pull packet off interface. */
name|m
operator|=
name|sonic_get
argument_list|(
name|sc
argument_list|,
name|pkt
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* We assume that the header fit entirely in one mbuf. */
name|et
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SNCDEBUG
if|if
condition|(
operator|(
name|sncdebug
operator|&
name|SNC_SHOWRXHDR
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"rcvd 0x%x len=%d type=0x%x from %6D"
argument_list|,
name|pkt
argument_list|,
name|len
argument_list|,
name|htons
argument_list|(
name|et
operator|->
name|ether_type
argument_list|)
argument_list|,
name|et
operator|->
name|ether_shost
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (to %6D)\n"
argument_list|,
name|et
operator|->
name|ether_dhost
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SNCDEBUG */
comment|/* Pass the packet up, with the ether header sort-of removed. */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|et
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * munge the received packet into an mbuf chain  */
end_comment

begin_function
name|hide
name|struct
name|mbuf
modifier|*
name|sonic_get
parameter_list|(
name|sc
parameter_list|,
name|pkt
parameter_list|,
name|datalen
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|pkt
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|top
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* 	 * Do not trunc ether_header length. 	 * Our sonic_read() and sonic_get() require it. 	 */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|sc_if
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|datalen
expr_stmt|;
name|len
operator|=
name|MHLEN
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
operator|&
name|top
expr_stmt|;
while|while
condition|(
name|datalen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|top
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|len
operator|=
name|MLEN
expr_stmt|;
block|}
if|if
condition|(
name|datalen
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|top
condition|)
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* XXX: Require? */
block|if (!top) { 			register int pad = 			    ALIGN(sizeof(struct ether_header)) - 			        sizeof(struct ether_header); 			m->m_data += pad; 			len -= pad; 		}
endif|#
directive|endif
name|m
operator|->
name|m_len
operator|=
name|len
operator|=
name|min
argument_list|(
name|datalen
argument_list|,
name|len
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_copyfrombuf
call|)
argument_list|(
name|sc
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|pkt
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pkt
operator|+=
name|len
expr_stmt|;
name|datalen
operator|-=
name|len
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
block|}
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enable power on the interface.  */
end_comment

begin_function
name|int
name|snc_enable
parameter_list|(
name|sc
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SNCDEBUG
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"snc_enable()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SNCDEBUG */
if|if
condition|(
name|sc
operator|->
name|sc_enabled
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_enable
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|sc
operator|->
name|sc_enable
call|)
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"device enable failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
name|sc
operator|->
name|sc_enabled
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Disable power on the interface.  */
end_comment

begin_function
name|void
name|snc_disable
parameter_list|(
name|sc
parameter_list|)
name|struct
name|snc_softc
modifier|*
name|sc
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SNCDEBUG
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"snc_disable()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SNCDEBUG */
if|if
condition|(
name|sc
operator|->
name|sc_enabled
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|sc_disable
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|sc
operator|->
name|sc_disable
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_enabled
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

end_unit

