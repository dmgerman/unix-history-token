begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 2013 Intel Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|"ntb_regs.h"
end_include

begin_include
include|#
directive|include
file|"ntb_hw.h"
end_include

begin_comment
comment|/*  * The Non-Transparent Bridge (NTB) is a device on some Intel processors that  * allows you to connect two systems using a PCI-e link.  *  * This module contains the hardware abstraction layer for the NTB. It allows  * you to send and recieve interrupts, map the memory windows and send and  * receive messages in the scratch-pad registers.  *  * NOTE: Much of the code in this module is shared with Linux. Any patches may  * be picked up and redistributed in Linux with a dual GPL/BSD license.  */
end_comment

begin_define
define|#
directive|define
name|NTB_CONFIG_BAR
value|0
end_define

begin_define
define|#
directive|define
name|NTB_B2B_BAR_1
value|1
end_define

begin_define
define|#
directive|define
name|NTB_B2B_BAR_2
value|2
end_define

begin_define
define|#
directive|define
name|NTB_MAX_BARS
value|3
end_define

begin_define
define|#
directive|define
name|NTB_MW_TO_BAR
parameter_list|(
name|mw
parameter_list|)
value|((mw) + 1)
end_define

begin_define
define|#
directive|define
name|MAX_MSIX_INTERRUPTS
value|MAX(XEON_MAX_DB_BITS, SOC_MAX_DB_BITS)
end_define

begin_define
define|#
directive|define
name|NTB_HB_TIMEOUT
value|1
end_define

begin_comment
comment|/* second */
end_comment

begin_define
define|#
directive|define
name|SOC_LINK_RECOVERY_TIME
value|500
end_define

begin_define
define|#
directive|define
name|DEVICE2SOFTC
parameter_list|(
name|dev
parameter_list|)
value|((struct ntb_softc *) device_get_softc(dev))
end_define

begin_enum
enum|enum
name|ntb_device_type
block|{
name|NTB_XEON
block|,
name|NTB_SOC
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ntb_hw_info
block|{
name|uint32_t
name|device_id
decl_stmt|;
name|enum
name|ntb_device_type
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_pci_bar_info
block|{
name|bus_space_tag_t
name|pci_bus_tag
decl_stmt|;
name|bus_space_handle_t
name|pci_bus_handle
decl_stmt|;
name|int
name|pci_resource_id
decl_stmt|;
name|struct
name|resource
modifier|*
name|pci_resource
decl_stmt|;
name|vm_paddr_t
name|pbase
decl_stmt|;
name|void
modifier|*
name|vbase
decl_stmt|;
name|u_long
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_int_info
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|void
modifier|*
name|tag
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_db_cb
block|{
name|ntb_db_callback
name|callback
decl_stmt|;
name|unsigned
name|int
name|db_num
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|struct
name|ntb_softc
modifier|*
name|ntb
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_softc
block|{
name|device_t
name|device
decl_stmt|;
name|enum
name|ntb_device_type
name|type
decl_stmt|;
name|struct
name|ntb_pci_bar_info
name|bar_info
index|[
name|NTB_MAX_BARS
index|]
decl_stmt|;
name|struct
name|ntb_int_info
name|int_info
index|[
name|MAX_MSIX_INTERRUPTS
index|]
decl_stmt|;
name|uint32_t
name|allocated_interrupts
decl_stmt|;
name|struct
name|callout
name|heartbeat_timer
decl_stmt|;
name|struct
name|callout
name|lr_timer
decl_stmt|;
name|void
modifier|*
name|ntb_transport
decl_stmt|;
name|ntb_event_callback
name|event_cb
decl_stmt|;
name|struct
name|ntb_db_cb
modifier|*
name|db_cb
decl_stmt|;
struct|struct
block|{
name|uint32_t
name|max_spads
decl_stmt|;
name|uint32_t
name|max_db_bits
decl_stmt|;
name|uint32_t
name|msix_cnt
decl_stmt|;
block|}
name|limits
struct|;
struct|struct
block|{
name|uint32_t
name|pdb
decl_stmt|;
name|uint32_t
name|pdb_mask
decl_stmt|;
name|uint32_t
name|sdb
decl_stmt|;
name|uint32_t
name|sbar2_xlat
decl_stmt|;
name|uint32_t
name|sbar4_xlat
decl_stmt|;
name|uint32_t
name|spad_remote
decl_stmt|;
name|uint32_t
name|spad_local
decl_stmt|;
name|uint32_t
name|lnk_cntl
decl_stmt|;
name|uint32_t
name|lnk_stat
decl_stmt|;
name|uint32_t
name|spci_cmd
decl_stmt|;
block|}
name|reg_ofs
struct|;
name|uint8_t
name|conn_type
decl_stmt|;
name|uint8_t
name|dev_type
decl_stmt|;
name|uint8_t
name|bits_per_vector
decl_stmt|;
name|uint8_t
name|link_status
decl_stmt|;
name|uint8_t
name|link_width
decl_stmt|;
name|uint8_t
name|link_speed
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ntb_reg_read
parameter_list|(
name|SIZE
parameter_list|,
name|offset
parameter_list|)
define|\
value|bus_space_read_ ## SIZE (ntb->bar_info[NTB_CONFIG_BAR].pci_bus_tag, \ 	    ntb->bar_info[NTB_CONFIG_BAR].pci_bus_handle, (offset))
end_define

begin_define
define|#
directive|define
name|ntb_reg_write
parameter_list|(
name|SIZE
parameter_list|,
name|offset
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_space_write_ ## SIZE (ntb->bar_info[NTB_CONFIG_BAR].pci_bus_tag, \ 	    ntb->bar_info[NTB_CONFIG_BAR].pci_bus_handle, (offset), (val))
end_define

begin_define
define|#
directive|define
name|ntb_read_1
parameter_list|(
name|offset
parameter_list|)
value|ntb_reg_read(1, (offset))
end_define

begin_define
define|#
directive|define
name|ntb_read_2
parameter_list|(
name|offset
parameter_list|)
value|ntb_reg_read(2, (offset))
end_define

begin_define
define|#
directive|define
name|ntb_read_4
parameter_list|(
name|offset
parameter_list|)
value|ntb_reg_read(4, (offset))
end_define

begin_define
define|#
directive|define
name|ntb_read_8
parameter_list|(
name|offset
parameter_list|)
value|ntb_reg_read(8, (offset))
end_define

begin_define
define|#
directive|define
name|ntb_write_1
parameter_list|(
name|offset
parameter_list|,
name|val
parameter_list|)
value|ntb_reg_write(1, (offset), (val))
end_define

begin_define
define|#
directive|define
name|ntb_write_2
parameter_list|(
name|offset
parameter_list|,
name|val
parameter_list|)
value|ntb_reg_write(2, (offset), (val))
end_define

begin_define
define|#
directive|define
name|ntb_write_4
parameter_list|(
name|offset
parameter_list|,
name|val
parameter_list|)
value|ntb_reg_write(4, (offset), (val))
end_define

begin_define
define|#
directive|define
name|ntb_write_8
parameter_list|(
name|offset
parameter_list|,
name|val
parameter_list|)
value|ntb_reg_write(8, (offset), (val))
end_define

begin_function_decl
specifier|static
name|int
name|ntb_probe
parameter_list|(
name|device_t
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_attach
parameter_list|(
name|device_t
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_detach
parameter_list|(
name|device_t
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_map_pci_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_unmap_pci_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_setup_interrupts
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_teardown_interrupts
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_soc_irq
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_xeon_irq
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_xeon_event_irq
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_handle_legacy_interrupt
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_create_callbacks
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|int
name|num_vectors
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_free_callbacks
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ntb_hw_info
modifier|*
name|ntb_get_device_info
parameter_list|(
name|uint32_t
name|device_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_initialize_hw
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_setup_xeon
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_setup_soc
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_handle_heartbeat
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_handle_link_event
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|int
name|link_state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|recover_soc_link
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_check_link_status
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_bar_for_data_transfer
parameter_list|(
name|int
name|bar_num
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|ntb_hw_info
name|pci_ids
index|[]
init|=
block|{
block|{
literal|0x3C0D8086
block|,
name|NTB_XEON
block|,
literal|"Xeon E5/Core i7 Non-Transparent Bridge B2B"
block|}
block|,
block|{
literal|0x0C4E8086
block|,
name|NTB_SOC
block|,
literal|"Atom Processor S1200 NTB Primary B2B"
block|}
block|,
block|{
literal|0x0E0D8086
block|,
name|NTB_XEON
block|,
literal|"Xeon E5 V2 Non-Transparent Bridge B2B"
block|}
block|,
block|{
literal|0x00000000
block|,
name|NTB_SOC
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * OS<-> Driver interface structures  */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NTB
argument_list|,
literal|"ntb_hw"
argument_list|,
literal|"ntb_hw driver memory allocations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|ntb_pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ntb_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ntb_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ntb_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ntb_pci_driver
init|=
block|{
literal|"ntb_hw"
block|,
name|ntb_pci_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ntb_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ntb_hw
argument_list|,
name|pci
argument_list|,
name|ntb_pci_driver
argument_list|,
name|ntb_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ntb_hw
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * OS<-> Driver linkage functions  */
end_comment

begin_function
specifier|static
name|int
name|ntb_probe
parameter_list|(
name|device_t
name|device
parameter_list|)
block|{
name|struct
name|ntb_hw_info
modifier|*
name|p
init|=
name|ntb_get_device_info
argument_list|(
name|pci_get_devid
argument_list|(
name|device
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|device_set_desc
argument_list|(
name|device
argument_list|,
name|p
operator|->
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DETACH_ON_ERROR
parameter_list|(
name|func
parameter_list|)
define|\
value|error = func;		        \ 	if (error< 0) {		\ 		ntb_detach(device);	\ 		return (error);		\ 	}
end_define

begin_function
specifier|static
name|int
name|ntb_attach
parameter_list|(
name|device_t
name|device
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|DEVICE2SOFTC
argument_list|(
name|device
argument_list|)
decl_stmt|;
name|struct
name|ntb_hw_info
modifier|*
name|p
init|=
name|ntb_get_device_info
argument_list|(
name|pci_get_devid
argument_list|(
name|device
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ntb
operator|->
name|device
operator|=
name|device
expr_stmt|;
name|ntb
operator|->
name|type
operator|=
name|p
operator|->
name|type
expr_stmt|;
comment|/* Heartbeat timer for NTB_SOC since there is no link interrupt */
name|callout_init
argument_list|(
operator|&
name|ntb
operator|->
name|heartbeat_timer
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|ntb
operator|->
name|lr_timer
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|DETACH_ON_ERROR
argument_list|(
name|ntb_map_pci_bar
argument_list|(
name|ntb
argument_list|)
argument_list|)
expr_stmt|;
name|DETACH_ON_ERROR
argument_list|(
name|ntb_initialize_hw
argument_list|(
name|ntb
argument_list|)
argument_list|)
expr_stmt|;
name|DETACH_ON_ERROR
argument_list|(
name|ntb_setup_interrupts
argument_list|(
name|ntb
argument_list|)
argument_list|)
expr_stmt|;
name|pci_enable_busmaster
argument_list|(
name|ntb
operator|->
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_detach
parameter_list|(
name|device_t
name|device
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|DEVICE2SOFTC
argument_list|(
name|device
argument_list|)
decl_stmt|;
name|callout_drain
argument_list|(
operator|&
name|ntb
operator|->
name|heartbeat_timer
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|ntb
operator|->
name|lr_timer
argument_list|)
expr_stmt|;
name|ntb_teardown_interrupts
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|ntb_unmap_pci_bar
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_map_pci_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|struct
name|ntb_pci_bar_info
modifier|*
name|current_bar
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_CONFIG_BAR
index|]
operator|.
name|pci_resource_id
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_1
index|]
operator|.
name|pci_resource_id
operator|=
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_2
index|]
operator|.
name|pci_resource_id
operator|=
name|PCIR_BAR
argument_list|(
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTB_MAX_BARS
condition|;
name|i
operator|++
control|)
block|{
name|current_bar
operator|=
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|i
index|]
expr_stmt|;
name|current_bar
operator|->
name|pci_resource
operator|=
name|bus_alloc_resource
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|current_bar
operator|->
name|pci_resource_id
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_bar
operator|->
name|pci_resource
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"unable to allocate pci resource\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
else|else
block|{
name|current_bar
operator|->
name|pci_bus_tag
operator|=
name|rman_get_bustag
argument_list|(
name|current_bar
operator|->
name|pci_resource
argument_list|)
expr_stmt|;
name|current_bar
operator|->
name|pci_bus_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|current_bar
operator|->
name|pci_resource
argument_list|)
expr_stmt|;
name|current_bar
operator|->
name|pbase
operator|=
name|rman_get_start
argument_list|(
name|current_bar
operator|->
name|pci_resource
argument_list|)
expr_stmt|;
name|current_bar
operator|->
name|size
operator|=
name|rman_get_size
argument_list|(
name|current_bar
operator|->
name|pci_resource
argument_list|)
expr_stmt|;
name|current_bar
operator|->
name|vbase
operator|=
name|rman_get_virtual
argument_list|(
name|current_bar
operator|->
name|pci_resource
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_bar_for_data_transfer
argument_list|(
name|i
argument_list|)
condition|)
block|{
comment|/* 				 * Mark bar region as write combining to improve 				 * performance. 				 */
name|rc
operator|=
name|pmap_change_attr
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|current_bar
operator|->
name|vbase
argument_list|,
name|current_bar
operator|->
name|size
argument_list|,
name|VM_MEMATTR_WRITE_COMBINING
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Couldn't mark bar as"
literal|" WRITE_COMBINING\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Bar size = %lx, v %p, p %p\n"
argument_list|,
name|current_bar
operator|->
name|size
argument_list|,
name|current_bar
operator|->
name|vbase
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|current_bar
operator|->
name|pbase
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_unmap_pci_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|struct
name|ntb_pci_bar_info
modifier|*
name|current_bar
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTB_MAX_BARS
condition|;
name|i
operator|++
control|)
block|{
name|current_bar
operator|=
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|current_bar
operator|->
name|pci_resource
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|current_bar
operator|->
name|pci_resource_id
argument_list|,
name|current_bar
operator|->
name|pci_resource
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_setup_interrupts
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|void
function_decl|(
modifier|*
name|interrupt_handler
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|int_arg
decl_stmt|;
name|bool
name|use_msix
init|=
literal|0
decl_stmt|;
name|uint32_t
name|num_vectors
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ntb
operator|->
name|allocated_interrupts
operator|=
literal|0
expr_stmt|;
comment|/* 	 * On SOC, disable all interrupts.  On XEON, disable all but Link 	 * Interrupt.  The rest will be unmasked as callbacks are registered. 	 */
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_SOC
condition|)
name|ntb_write_8
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|pdb_mask
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
else|else
name|ntb_write_2
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|pdb_mask
argument_list|,
operator|~
operator|(
literal|1
operator|<<
name|ntb
operator|->
name|limits
operator|.
name|max_db_bits
operator|)
argument_list|)
expr_stmt|;
name|num_vectors
operator|=
name|MIN
argument_list|(
name|pci_msix_count
argument_list|(
name|ntb
operator|->
name|device
argument_list|)
argument_list|,
name|ntb
operator|->
name|limits
operator|.
name|max_db_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_vectors
operator|>=
literal|1
condition|)
block|{
name|pci_alloc_msix
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
operator|&
name|num_vectors
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_vectors
operator|>=
literal|4
condition|)
name|use_msix
operator|=
name|TRUE
expr_stmt|;
block|}
name|ntb_create_callbacks
argument_list|(
name|ntb
argument_list|,
name|num_vectors
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_msix
operator|==
name|TRUE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_vectors
condition|;
name|i
operator|++
control|)
block|{
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|rid
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"bus_alloc_resource failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|tag
operator|=
name|NULL
expr_stmt|;
name|ntb
operator|->
name|allocated_interrupts
operator|++
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_SOC
condition|)
block|{
name|interrupt_handler
operator|=
name|handle_soc_irq
expr_stmt|;
name|int_arg
operator|=
operator|&
name|ntb
operator|->
name|db_cb
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|==
name|num_vectors
operator|-
literal|1
condition|)
block|{
name|interrupt_handler
operator|=
name|handle_xeon_event_irq
expr_stmt|;
name|int_arg
operator|=
name|ntb
expr_stmt|;
block|}
else|else
block|{
name|interrupt_handler
operator|=
name|handle_xeon_irq
expr_stmt|;
name|int_arg
operator|=
operator|&
name|ntb
operator|->
name|db_cb
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_MISC
argument_list|,
name|NULL
argument_list|,
name|interrupt_handler
argument_list|,
name|int_arg
argument_list|,
operator|&
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|tag
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"bus_setup_intr failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|rid
operator|=
literal|0
expr_stmt|;
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
name|interrupt_handler
operator|=
name|ntb_handle_legacy_interrupt
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"bus_alloc_resource failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|tag
operator|=
name|NULL
expr_stmt|;
name|ntb
operator|->
name|allocated_interrupts
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_MISC
argument_list|,
name|NULL
argument_list|,
name|interrupt_handler
argument_list|,
name|ntb
argument_list|,
operator|&
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|tag
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"bus_setup_intr failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_teardown_interrupts
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|struct
name|ntb_int_info
modifier|*
name|current_int
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntb
operator|->
name|allocated_interrupts
condition|;
name|i
operator|++
control|)
block|{
name|current_int
operator|=
operator|&
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|current_int
operator|->
name|tag
operator|!=
name|NULL
condition|)
name|bus_teardown_intr
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|current_int
operator|->
name|res
argument_list|,
name|current_int
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_int
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rman_get_rid
argument_list|(
name|current_int
operator|->
name|res
argument_list|)
argument_list|,
name|current_int
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
name|ntb_free_callbacks
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|pci_release_msi
argument_list|(
name|ntb
operator|->
name|device
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_soc_irq
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_db_cb
modifier|*
name|db_cb
init|=
name|arg
decl_stmt|;
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|db_cb
operator|->
name|ntb
decl_stmt|;
name|ntb_write_8
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|pdb
argument_list|,
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
name|db_cb
operator|->
name|db_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_cb
operator|->
name|callback
operator|!=
name|NULL
condition|)
name|db_cb
operator|->
name|callback
argument_list|(
name|db_cb
operator|->
name|data
argument_list|,
name|db_cb
operator|->
name|db_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_xeon_irq
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_db_cb
modifier|*
name|db_cb
init|=
name|arg
decl_stmt|;
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|db_cb
operator|->
name|ntb
decl_stmt|;
comment|/* 	 * On Xeon, there are 16 bits in the interrupt register 	 * but only 4 vectors.  So, 5 bits are assigned to the first 3 	 * vectors, with the 4th having a single bit for link 	 * interrupts. 	 */
name|ntb_write_2
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|pdb
argument_list|,
operator|(
operator|(
literal|1
operator|<<
name|ntb
operator|->
name|bits_per_vector
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
name|db_cb
operator|->
name|db_num
operator|*
name|ntb
operator|->
name|bits_per_vector
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_cb
operator|->
name|callback
operator|!=
name|NULL
condition|)
name|db_cb
operator|->
name|callback
argument_list|(
name|db_cb
operator|->
name|data
argument_list|,
name|db_cb
operator|->
name|db_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Since we do not have a HW doorbell in SOC, this is only used in JF/JT */
end_comment

begin_function
specifier|static
name|void
name|handle_xeon_event_irq
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|arg
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|ntb_check_link_status
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Error determining link status\n"
argument_list|)
expr_stmt|;
comment|/* bit 15 is always the link bit */
name|ntb_write_2
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|pdb
argument_list|,
literal|1
operator|<<
name|ntb
operator|->
name|limits
operator|.
name|max_db_bits
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_handle_legacy_interrupt
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|arg
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|uint64_t
name|pdb64
decl_stmt|;
name|uint16_t
name|pdb16
decl_stmt|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_SOC
condition|)
block|{
name|pdb64
operator|=
name|ntb_read_8
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|pdb
argument_list|)
expr_stmt|;
while|while
condition|(
name|pdb64
condition|)
block|{
name|i
operator|=
name|ffs
argument_list|(
name|pdb64
argument_list|)
expr_stmt|;
name|pdb64
operator|&=
name|pdb64
operator|-
literal|1
expr_stmt|;
name|handle_soc_irq
argument_list|(
operator|&
name|ntb
operator|->
name|db_cb
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pdb16
operator|=
name|ntb_read_2
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|pdb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pdb16
operator|&
name|XEON_DB_HW_LINK
operator|)
operator|!=
literal|0
condition|)
block|{
name|handle_xeon_event_irq
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|pdb16
operator|&=
operator|~
name|XEON_DB_HW_LINK
expr_stmt|;
block|}
while|while
condition|(
name|pdb16
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|ffs
argument_list|(
name|pdb16
argument_list|)
expr_stmt|;
name|pdb16
operator|&=
name|pdb16
operator|-
literal|1
expr_stmt|;
name|handle_xeon_irq
argument_list|(
operator|&
name|ntb
operator|->
name|db_cb
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_create_callbacks
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|int
name|num_vectors
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ntb
operator|->
name|db_cb
operator|=
name|malloc
argument_list|(
name|num_vectors
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_db_cb
argument_list|)
argument_list|,
name|M_NTB
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_vectors
condition|;
name|i
operator|++
control|)
block|{
name|ntb
operator|->
name|db_cb
index|[
name|i
index|]
operator|.
name|db_num
operator|=
name|i
expr_stmt|;
name|ntb
operator|->
name|db_cb
index|[
name|i
index|]
operator|.
name|ntb
operator|=
name|ntb
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_free_callbacks
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntb
operator|->
name|limits
operator|.
name|max_db_bits
condition|;
name|i
operator|++
control|)
name|ntb_unregister_db_callback
argument_list|(
name|ntb
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ntb
operator|->
name|db_cb
argument_list|,
name|M_NTB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ntb_hw_info
modifier|*
name|ntb_get_device_info
parameter_list|(
name|uint32_t
name|device_id
parameter_list|)
block|{
name|struct
name|ntb_hw_info
modifier|*
name|ep
init|=
name|pci_ids
decl_stmt|;
while|while
condition|(
name|ep
operator|->
name|device_id
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|device_id
operator|==
name|device_id
condition|)
return|return
operator|(
name|ep
operator|)
return|;
operator|++
name|ep
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_initialize_hw
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_SOC
condition|)
return|return
operator|(
name|ntb_setup_soc
argument_list|(
name|ntb
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|ntb_setup_xeon
argument_list|(
name|ntb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_setup_xeon
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|uint8_t
name|val
decl_stmt|,
name|connection_type
decl_stmt|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|NTB_PPD_OFFSET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|connection_type
operator|=
name|val
operator|&
name|XEON_PPD_CONN_TYPE
expr_stmt|;
switch|switch
condition|(
name|connection_type
condition|)
block|{
case|case
name|NTB_CONN_B2B
case|:
name|ntb
operator|->
name|conn_type
operator|=
name|NTB_CONN_B2B
expr_stmt|;
break|break;
case|case
name|NTB_CONN_CLASSIC
case|:
case|case
name|NTB_CONN_RP
case|:
default|default:
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Connection type %d not supported\n"
argument_list|,
name|connection_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|val
operator|&
name|XEON_PPD_DEV_TYPE
operator|)
operator|!=
literal|0
condition|)
name|ntb
operator|->
name|dev_type
operator|=
name|NTB_DEV_DSD
expr_stmt|;
else|else
name|ntb
operator|->
name|dev_type
operator|=
name|NTB_DEV_USD
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|pdb
operator|=
name|XEON_PDOORBELL_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|pdb_mask
operator|=
name|XEON_PDBMSK_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|sbar2_xlat
operator|=
name|XEON_SBAR2XLAT_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|sbar4_xlat
operator|=
name|XEON_SBAR4XLAT_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|lnk_cntl
operator|=
name|XEON_NTBCNTL_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|lnk_stat
operator|=
name|XEON_LINK_STATUS_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|spad_local
operator|=
name|XEON_SPAD_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|spci_cmd
operator|=
name|XEON_PCICMD_OFFSET
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|conn_type
operator|==
name|NTB_CONN_B2B
condition|)
block|{
name|ntb
operator|->
name|reg_ofs
operator|.
name|sdb
operator|=
name|XEON_B2B_DOORBELL_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|spad_remote
operator|=
name|XEON_B2B_SPAD_OFFSET
expr_stmt|;
name|ntb
operator|->
name|limits
operator|.
name|max_spads
operator|=
name|XEON_MAX_SPADS
expr_stmt|;
block|}
else|else
block|{
name|ntb
operator|->
name|reg_ofs
operator|.
name|sdb
operator|=
name|XEON_SDOORBELL_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|spad_remote
operator|=
name|XEON_SPAD_OFFSET
expr_stmt|;
name|ntb
operator|->
name|limits
operator|.
name|max_spads
operator|=
name|XEON_MAX_COMPAT_SPADS
expr_stmt|;
block|}
name|ntb
operator|->
name|limits
operator|.
name|max_db_bits
operator|=
name|XEON_MAX_DB_BITS
expr_stmt|;
name|ntb
operator|->
name|limits
operator|.
name|msix_cnt
operator|=
name|XEON_MSIX_CNT
expr_stmt|;
name|ntb
operator|->
name|bits_per_vector
operator|=
name|XEON_DB_BITS_PER_VEC
expr_stmt|;
comment|/* Enable Bus Master and Memory Space on the secondary side */
name|ntb_write_2
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|spci_cmd
argument_list|,
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
argument_list|)
expr_stmt|;
comment|/* Enable link training */
name|ntb_write_4
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|lnk_cntl
argument_list|,
name|NTB_CNTL_BAR23_SNOOP
operator||
name|NTB_CNTL_BAR45_SNOOP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_setup_soc
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|,
name|connection_type
decl_stmt|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|NTB_PPD_OFFSET
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|connection_type
operator|=
operator|(
name|val
operator|&
name|SOC_PPD_CONN_TYPE
operator|)
operator|>>
literal|8
expr_stmt|;
switch|switch
condition|(
name|connection_type
condition|)
block|{
case|case
name|NTB_CONN_B2B
case|:
name|ntb
operator|->
name|conn_type
operator|=
name|NTB_CONN_B2B
expr_stmt|;
break|break;
case|case
name|NTB_CONN_RP
case|:
default|default:
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Connection type %d not supported\n"
argument_list|,
name|connection_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|val
operator|&
name|SOC_PPD_DEV_TYPE
operator|)
operator|!=
literal|0
condition|)
name|ntb
operator|->
name|dev_type
operator|=
name|NTB_DEV_DSD
expr_stmt|;
else|else
name|ntb
operator|->
name|dev_type
operator|=
name|NTB_DEV_USD
expr_stmt|;
comment|/* Initiate PCI-E link training */
name|pci_write_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|NTB_PPD_OFFSET
argument_list|,
name|val
operator||
name|SOC_PPD_INIT_LINK
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|pdb
operator|=
name|SOC_PDOORBELL_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|pdb_mask
operator|=
name|SOC_PDBMSK_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|sbar2_xlat
operator|=
name|SOC_SBAR2XLAT_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|sbar4_xlat
operator|=
name|SOC_SBAR4XLAT_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|lnk_cntl
operator|=
name|SOC_NTBCNTL_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|lnk_stat
operator|=
name|SOC_LINK_STATUS_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|spad_local
operator|=
name|SOC_SPAD_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|spci_cmd
operator|=
name|SOC_PCICMD_OFFSET
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|conn_type
operator|==
name|NTB_CONN_B2B
condition|)
block|{
name|ntb
operator|->
name|reg_ofs
operator|.
name|sdb
operator|=
name|SOC_B2B_DOORBELL_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|spad_remote
operator|=
name|SOC_B2B_SPAD_OFFSET
expr_stmt|;
name|ntb
operator|->
name|limits
operator|.
name|max_spads
operator|=
name|SOC_MAX_SPADS
expr_stmt|;
block|}
else|else
block|{
name|ntb
operator|->
name|reg_ofs
operator|.
name|sdb
operator|=
name|SOC_PDOORBELL_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|spad_remote
operator|=
name|SOC_SPAD_OFFSET
expr_stmt|;
name|ntb
operator|->
name|limits
operator|.
name|max_spads
operator|=
name|SOC_MAX_COMPAT_SPADS
expr_stmt|;
block|}
name|ntb
operator|->
name|limits
operator|.
name|max_db_bits
operator|=
name|SOC_MAX_DB_BITS
expr_stmt|;
name|ntb
operator|->
name|limits
operator|.
name|msix_cnt
operator|=
name|SOC_MSIX_CNT
expr_stmt|;
name|ntb
operator|->
name|bits_per_vector
operator|=
name|SOC_DB_BITS_PER_VEC
expr_stmt|;
comment|/* 	 * FIXME - MSI-X bug on early SOC HW, remove once internal issue is 	 * resolved.  Mask transaction layer internal parity errors. 	 */
name|pci_write_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|0xFC
argument_list|,
literal|0x4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* 	 * Some BIOSes aren't filling out the XLAT offsets. 	 * Check and correct the issue. 	 */
if|if
condition|(
name|ntb
operator|->
name|dev_type
operator|==
name|NTB_DEV_USD
condition|)
block|{
if|if
condition|(
name|ntb_read_8
argument_list|(
name|SOC_PBAR2XLAT_OFFSET
argument_list|)
operator|==
literal|0
condition|)
name|ntb_write_8
argument_list|(
name|SOC_PBAR2XLAT_OFFSET
argument_list|,
name|SOC_PBAR2XLAT_USD_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb_read_8
argument_list|(
name|SOC_PBAR4XLAT_OFFSET
argument_list|)
operator|==
literal|0
condition|)
name|ntb_write_8
argument_list|(
name|SOC_PBAR4XLAT_OFFSET
argument_list|,
name|SOC_PBAR4XLAT_USD_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb_read_8
argument_list|(
name|SOC_MBAR23_OFFSET
argument_list|)
operator|==
literal|0xC
condition|)
name|ntb_write_8
argument_list|(
name|SOC_MBAR23_OFFSET
argument_list|,
name|SOC_MBAR23_USD_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb_read_8
argument_list|(
name|SOC_MBAR45_OFFSET
argument_list|)
operator|==
literal|0xC
condition|)
name|ntb_write_8
argument_list|(
name|SOC_MBAR45_OFFSET
argument_list|,
name|SOC_MBAR45_USD_ADDR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ntb_read_8
argument_list|(
name|SOC_PBAR2XLAT_OFFSET
argument_list|)
operator|==
literal|0
condition|)
name|ntb_write_8
argument_list|(
name|SOC_PBAR2XLAT_OFFSET
argument_list|,
name|SOC_PBAR2XLAT_DSD_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb_read_8
argument_list|(
name|SOC_PBAR4XLAT_OFFSET
argument_list|)
operator|==
literal|0
condition|)
name|ntb_write_8
argument_list|(
name|SOC_PBAR4XLAT_OFFSET
argument_list|,
name|SOC_PBAR4XLAT_DSD_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb_read_8
argument_list|(
name|SOC_MBAR23_OFFSET
argument_list|)
operator|==
literal|0xC
condition|)
name|ntb_write_8
argument_list|(
name|SOC_MBAR23_OFFSET
argument_list|,
name|SOC_MBAR23_DSD_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb_read_8
argument_list|(
name|SOC_MBAR45_OFFSET
argument_list|)
operator|==
literal|0xC
condition|)
name|ntb_write_8
argument_list|(
name|SOC_MBAR45_OFFSET
argument_list|,
name|SOC_MBAR45_DSD_ADDR
argument_list|)
expr_stmt|;
block|}
comment|/* Enable Bus Master and Memory Space on the secondary side */
name|ntb_write_2
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|spci_cmd
argument_list|,
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|ntb
operator|->
name|heartbeat_timer
argument_list|,
literal|0
argument_list|,
name|ntb_handle_heartbeat
argument_list|,
name|ntb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* SOC doesn't have link status interrupt, poll on that platform */
end_comment

begin_function
specifier|static
name|void
name|ntb_handle_heartbeat
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|arg
decl_stmt|;
name|uint32_t
name|status32
decl_stmt|;
name|int
name|rc
init|=
name|ntb_check_link_status
argument_list|(
name|ntb
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Error determining link status\n"
argument_list|)
expr_stmt|;
comment|/* Check to see if a link error is the cause of the link down */
if|if
condition|(
name|ntb
operator|->
name|link_status
operator|==
name|NTB_LINK_DOWN
condition|)
block|{
name|status32
operator|=
name|ntb_read_4
argument_list|(
name|SOC_LTSSMSTATEJMP_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status32
operator|&
name|SOC_LTSSMSTATEJMP_FORCEDETECT
operator|)
operator|!=
literal|0
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|ntb
operator|->
name|lr_timer
argument_list|,
literal|0
argument_list|,
name|recover_soc_link
argument_list|,
name|ntb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|callout_reset
argument_list|(
operator|&
name|ntb
operator|->
name|heartbeat_timer
argument_list|,
name|NTB_HB_TIMEOUT
operator|*
name|hz
argument_list|,
name|ntb_handle_heartbeat
argument_list|,
name|ntb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|soc_perform_link_restart
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
comment|/* Driver resets the NTB ModPhy lanes - magic! */
name|ntb_write_1
argument_list|(
name|SOC_MODPHY_PCSREG6
argument_list|,
literal|0xe0
argument_list|)
expr_stmt|;
name|ntb_write_1
argument_list|(
name|SOC_MODPHY_PCSREG4
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|ntb_write_1
argument_list|(
name|SOC_MODPHY_PCSREG4
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
name|ntb_write_1
argument_list|(
name|SOC_MODPHY_PCSREG6
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
comment|/* Driver waits 100ms to allow the NTB ModPhy to settle */
name|pause
argument_list|(
literal|"ModPhy"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
comment|/* Clear AER Errors, write to clear */
name|status
operator|=
name|ntb_read_4
argument_list|(
name|SOC_ERRCORSTS_OFFSET
argument_list|)
expr_stmt|;
name|status
operator|&=
name|PCIM_AER_COR_REPLAY_ROLLOVER
expr_stmt|;
name|ntb_write_4
argument_list|(
name|SOC_ERRCORSTS_OFFSET
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Clear unexpected electrical idle event in LTSSM, write to clear */
name|status
operator|=
name|ntb_read_4
argument_list|(
name|SOC_LTSSMERRSTS0_OFFSET
argument_list|)
expr_stmt|;
name|status
operator||=
name|SOC_LTSSMERRSTS0_UNEXPECTEDEI
expr_stmt|;
name|ntb_write_4
argument_list|(
name|SOC_LTSSMERRSTS0_OFFSET
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Clear DeSkew Buffer error, write to clear */
name|status
operator|=
name|ntb_read_4
argument_list|(
name|SOC_DESKEWSTS_OFFSET
argument_list|)
expr_stmt|;
name|status
operator||=
name|SOC_DESKEWSTS_DBERR
expr_stmt|;
name|ntb_write_4
argument_list|(
name|SOC_DESKEWSTS_OFFSET
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|status
operator|=
name|ntb_read_4
argument_list|(
name|SOC_IBSTERRRCRVSTS0_OFFSET
argument_list|)
expr_stmt|;
name|status
operator|&=
name|SOC_IBIST_ERR_OFLOW
expr_stmt|;
name|ntb_write_4
argument_list|(
name|SOC_IBSTERRRCRVSTS0_OFFSET
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Releases the NTB state machine to allow the link to retrain */
name|status
operator|=
name|ntb_read_4
argument_list|(
name|SOC_LTSSMSTATEJMP_OFFSET
argument_list|)
expr_stmt|;
name|status
operator|&=
operator|~
name|SOC_LTSSMSTATEJMP_FORCEDETECT
expr_stmt|;
name|ntb_write_4
argument_list|(
name|SOC_LTSSMSTATEJMP_OFFSET
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_handle_link_event
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|int
name|link_state
parameter_list|)
block|{
name|enum
name|ntb_hw_event
name|event
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
if|if
condition|(
name|ntb
operator|->
name|link_status
operator|==
name|link_state
condition|)
return|return;
if|if
condition|(
name|link_state
operator|==
name|NTB_LINK_UP
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Link Up\n"
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|link_status
operator|=
name|NTB_LINK_UP
expr_stmt|;
name|event
operator|=
name|NTB_EVENT_HW_LINK_UP
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_SOC
condition|)
name|status
operator|=
name|ntb_read_2
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|lnk_stat
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|XEON_LINK_STATUS_OFFSET
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|link_width
operator|=
operator|(
name|status
operator|&
name|NTB_LINK_WIDTH_MASK
operator|)
operator|>>
literal|4
expr_stmt|;
name|ntb
operator|->
name|link_speed
operator|=
operator|(
name|status
operator|&
name|NTB_LINK_SPEED_MASK
operator|)
expr_stmt|;
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Link Width %d, Link Speed %d\n"
argument_list|,
name|ntb
operator|->
name|link_width
argument_list|,
name|ntb
operator|->
name|link_speed
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|ntb
operator|->
name|heartbeat_timer
argument_list|,
name|NTB_HB_TIMEOUT
operator|*
name|hz
argument_list|,
name|ntb_handle_heartbeat
argument_list|,
name|ntb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Link Down\n"
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|link_status
operator|=
name|NTB_LINK_DOWN
expr_stmt|;
name|event
operator|=
name|NTB_EVENT_HW_LINK_DOWN
expr_stmt|;
comment|/* Don't modify link width/speed, we need it in link recovery */
block|}
comment|/* notify the upper layer if we have an event change */
if|if
condition|(
name|ntb
operator|->
name|event_cb
operator|!=
name|NULL
condition|)
name|ntb
operator|->
name|event_cb
argument_list|(
name|ntb
operator|->
name|ntb_transport
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|recover_soc_link
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|arg
decl_stmt|;
name|uint8_t
name|speed
decl_stmt|,
name|width
decl_stmt|;
name|uint32_t
name|status32
decl_stmt|;
name|uint16_t
name|status16
decl_stmt|;
name|soc_perform_link_restart
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|pause
argument_list|(
literal|"Link"
argument_list|,
name|SOC_LINK_RECOVERY_TIME
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|status32
operator|=
name|ntb_read_4
argument_list|(
name|SOC_LTSSMSTATEJMP_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status32
operator|&
name|SOC_LTSSMSTATEJMP_FORCEDETECT
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|retry
goto|;
name|status32
operator|=
name|ntb_read_4
argument_list|(
name|SOC_IBSTERRRCRVSTS0_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status32
operator|&
name|SOC_IBIST_ERR_OFLOW
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|retry
goto|;
name|status16
operator|=
name|ntb_read_2
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|lnk_stat
argument_list|)
expr_stmt|;
name|width
operator|=
operator|(
name|status16
operator|&
name|NTB_LINK_WIDTH_MASK
operator|)
operator|>>
literal|4
expr_stmt|;
name|speed
operator|=
operator|(
name|status16
operator|&
name|NTB_LINK_SPEED_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|link_width
operator|!=
name|width
operator|||
name|ntb
operator|->
name|link_speed
operator|!=
name|speed
condition|)
goto|goto
name|retry
goto|;
name|callout_reset
argument_list|(
operator|&
name|ntb
operator|->
name|heartbeat_timer
argument_list|,
name|NTB_HB_TIMEOUT
operator|*
name|hz
argument_list|,
name|ntb_handle_heartbeat
argument_list|,
name|ntb
argument_list|)
expr_stmt|;
return|return;
name|retry
label|:
name|callout_reset
argument_list|(
operator|&
name|ntb
operator|->
name|lr_timer
argument_list|,
name|NTB_HB_TIMEOUT
operator|*
name|hz
argument_list|,
name|recover_soc_link
argument_list|,
name|ntb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_check_link_status
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|int
name|link_state
decl_stmt|;
name|uint32_t
name|ntb_cntl
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_SOC
condition|)
block|{
name|ntb_cntl
operator|=
name|ntb_read_4
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|lnk_cntl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ntb_cntl
operator|&
name|SOC_CNTL_LINK_DOWN
operator|)
operator|!=
literal|0
condition|)
name|link_state
operator|=
name|NTB_LINK_DOWN
expr_stmt|;
else|else
name|link_state
operator|=
name|NTB_LINK_UP
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|XEON_LINK_STATUS_OFFSET
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|NTB_LINK_STATUS_ACTIVE
operator|)
operator|!=
literal|0
condition|)
name|link_state
operator|=
name|NTB_LINK_UP
expr_stmt|;
else|else
name|link_state
operator|=
name|NTB_LINK_DOWN
expr_stmt|;
block|}
name|ntb_handle_link_event
argument_list|(
name|ntb
argument_list|,
name|link_state
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_register_event_callback() - register event callback  * @ntb: pointer to ntb_softc instance  * @func: callback function to register  *  * This function registers a callback for any HW driver events such as link  * up/down, power management notices and etc.  *  * RETURNS: An appropriate -ERRNO error value on error, or zero for success.  */
end_comment

begin_function
name|int
name|ntb_register_event_callback
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|ntb_event_callback
name|func
parameter_list|)
block|{
if|if
condition|(
name|ntb
operator|->
name|event_cb
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ntb
operator|->
name|event_cb
operator|=
name|func
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_unregister_event_callback() - unregisters the event callback  * @ntb: pointer to ntb_softc instance  *  * This function unregisters the existing callback from transport  */
end_comment

begin_function
name|void
name|ntb_unregister_event_callback
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|ntb
operator|->
name|event_cb
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ntb_register_db_callback() - register a callback for doorbell interrupt  * @ntb: pointer to ntb_softc instance  * @idx: doorbell index to register callback, zero based  * @func: callback function to register  *  * This function registers a callback function for the doorbell interrupt  * on the primary side. The function will unmask the doorbell as well to  * allow interrupt.  *  * RETURNS: An appropriate -ERRNO error value on error, or zero for success.  */
end_comment

begin_function
name|int
name|ntb_register_db_callback
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|ntb_db_callback
name|func
parameter_list|)
block|{
name|uint16_t
name|mask
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
name|ntb
operator|->
name|allocated_interrupts
operator|||
name|ntb
operator|->
name|db_cb
index|[
name|idx
index|]
operator|.
name|callback
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Invalid Index.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ntb
operator|->
name|db_cb
index|[
name|idx
index|]
operator|.
name|callback
operator|=
name|func
expr_stmt|;
name|ntb
operator|->
name|db_cb
index|[
name|idx
index|]
operator|.
name|data
operator|=
name|data
expr_stmt|;
comment|/* unmask interrupt */
name|mask
operator|=
name|ntb_read_2
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|pdb_mask
argument_list|)
expr_stmt|;
name|mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|idx
operator|*
name|ntb
operator|->
name|bits_per_vector
operator|)
operator|)
expr_stmt|;
name|ntb_write_2
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|pdb_mask
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_unregister_db_callback() - unregister a callback for doorbell interrupt  * @ntb: pointer to ntb_softc instance  * @idx: doorbell index to register callback, zero based  *  * This function unregisters a callback function for the doorbell interrupt  * on the primary side. The function will also mask the said doorbell.  */
end_comment

begin_function
name|void
name|ntb_unregister_db_callback
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|)
block|{
name|unsigned
name|long
name|mask
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
name|ntb
operator|->
name|allocated_interrupts
operator|||
operator|!
name|ntb
operator|->
name|db_cb
index|[
name|idx
index|]
operator|.
name|callback
condition|)
return|return;
name|mask
operator|=
name|ntb_read_2
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|pdb_mask
argument_list|)
expr_stmt|;
name|mask
operator||=
literal|1
operator|<<
operator|(
name|idx
operator|*
name|ntb
operator|->
name|bits_per_vector
operator|)
expr_stmt|;
name|ntb_write_2
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|pdb_mask
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|db_cb
index|[
name|idx
index|]
operator|.
name|callback
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ntb_find_transport() - find the transport pointer  * @transport: pointer to pci device  *  * Given the pci device pointer, return the transport pointer passed in when  * the transport attached when it was inited.  *  * RETURNS: pointer to transport.  */
end_comment

begin_function
name|void
modifier|*
name|ntb_find_transport
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
return|return
operator|(
name|ntb
operator|->
name|ntb_transport
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_register_transport() - Register NTB transport with NTB HW driver  * @transport: transport identifier  *  * This function allows a transport to reserve the hardware driver for  * NTB usage.  *  * RETURNS: pointer to ntb_softc, NULL on error.  */
end_comment

begin_function
name|struct
name|ntb_softc
modifier|*
name|ntb_register_transport
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|void
modifier|*
name|transport
parameter_list|)
block|{
comment|/* 	 * TODO: when we have more than one transport, we will need to rewrite 	 * this to prevent race conditions 	 */
if|if
condition|(
name|ntb
operator|->
name|ntb_transport
operator|!=
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ntb
operator|->
name|ntb_transport
operator|=
name|transport
expr_stmt|;
return|return
operator|(
name|ntb
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_unregister_transport() - Unregister the transport with the NTB HW driver  * @ntb - ntb_softc of the transport to be freed  *  * This function unregisters the transport from the HW driver and performs any  * necessary cleanups.  */
end_comment

begin_function
name|void
name|ntb_unregister_transport
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ntb
operator|->
name|ntb_transport
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntb
operator|->
name|allocated_interrupts
condition|;
name|i
operator|++
control|)
name|ntb_unregister_db_callback
argument_list|(
name|ntb
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ntb_unregister_event_callback
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|ntb_transport
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ntb_get_max_spads() - get the total scratch regs usable  * @ntb: pointer to ntb_softc instance  *  * This function returns the max 32bit scratchpad registers usable by the  * upper layer.  *  * RETURNS: total number of scratch pad registers available  */
end_comment

begin_function
name|int
name|ntb_get_max_spads
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
return|return
operator|(
name|ntb
operator|->
name|limits
operator|.
name|max_spads
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_write_local_spad() - write to the secondary scratchpad register  * @ntb: pointer to ntb_softc instance  * @idx: index to the scratchpad register, 0 based  * @val: the data value to put into the register  *  * This function allows writing of a 32bit value to the indexed scratchpad  * register. The register resides on the secondary (external) side.  *  * RETURNS: An appropriate -ERRNO error value on error, or zero for success.  */
end_comment

begin_function
name|int
name|ntb_write_local_spad
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>=
name|ntb
operator|->
name|limits
operator|.
name|max_spads
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ntb_write_4
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|spad_local
operator|+
name|idx
operator|*
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_read_local_spad() - read from the primary scratchpad register  * @ntb: pointer to ntb_softc instance  * @idx: index to scratchpad register, 0 based  * @val: pointer to 32bit integer for storing the register value  *  * This function allows reading of the 32bit scratchpad register on  * the primary (internal) side.  *  * RETURNS: An appropriate -ERRNO error value on error, or zero for success.  */
end_comment

begin_function
name|int
name|ntb_read_local_spad
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>=
name|ntb
operator|->
name|limits
operator|.
name|max_spads
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|val
operator|=
name|ntb_read_4
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|spad_local
operator|+
name|idx
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_write_remote_spad() - write to the secondary scratchpad register  * @ntb: pointer to ntb_softc instance  * @idx: index to the scratchpad register, 0 based  * @val: the data value to put into the register  *  * This function allows writing of a 32bit value to the indexed scratchpad  * register. The register resides on the secondary (external) side.  *  * RETURNS: An appropriate -ERRNO error value on error, or zero for success.  */
end_comment

begin_function
name|int
name|ntb_write_remote_spad
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>=
name|ntb
operator|->
name|limits
operator|.
name|max_spads
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ntb_write_4
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|spad_remote
operator|+
name|idx
operator|*
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_read_remote_spad() - read from the primary scratchpad register  * @ntb: pointer to ntb_softc instance  * @idx: index to scratchpad register, 0 based  * @val: pointer to 32bit integer for storing the register value  *  * This function allows reading of the 32bit scratchpad register on  * the primary (internal) side.  *  * RETURNS: An appropriate -ERRNO error value on error, or zero for success.  */
end_comment

begin_function
name|int
name|ntb_read_remote_spad
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>=
name|ntb
operator|->
name|limits
operator|.
name|max_spads
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|val
operator|=
name|ntb_read_4
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|spad_remote
operator|+
name|idx
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_get_mw_vbase() - get virtual addr for the NTB memory window  * @ntb: pointer to ntb_softc instance  * @mw: memory window number  *  * This function provides the base virtual address of the memory window  * specified.  *  * RETURNS: pointer to virtual address, or NULL on error.  */
end_comment

begin_function
name|void
modifier|*
name|ntb_get_mw_vbase
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|mw
parameter_list|)
block|{
if|if
condition|(
name|mw
operator|>=
name|NTB_NUM_MW
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|ntb
operator|->
name|bar_info
index|[
name|NTB_MW_TO_BAR
argument_list|(
name|mw
argument_list|)
index|]
operator|.
name|vbase
operator|)
return|;
block|}
end_function

begin_function
name|vm_paddr_t
name|ntb_get_mw_pbase
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|mw
parameter_list|)
block|{
if|if
condition|(
name|mw
operator|>=
name|NTB_NUM_MW
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ntb
operator|->
name|bar_info
index|[
name|NTB_MW_TO_BAR
argument_list|(
name|mw
argument_list|)
index|]
operator|.
name|pbase
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_get_mw_size() - return size of NTB memory window  * @ntb: pointer to ntb_softc instance  * @mw: memory window number  *  * This function provides the physical size of the memory window specified  *  * RETURNS: the size of the memory window or zero on error  */
end_comment

begin_function
name|u_long
name|ntb_get_mw_size
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|mw
parameter_list|)
block|{
if|if
condition|(
name|mw
operator|>=
name|NTB_NUM_MW
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ntb
operator|->
name|bar_info
index|[
name|NTB_MW_TO_BAR
argument_list|(
name|mw
argument_list|)
index|]
operator|.
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_set_mw_addr - set the memory window address  * @ntb: pointer to ntb_softc instance  * @mw: memory window number  * @addr: base address for data  *  * This function sets the base physical address of the memory window.  This  * memory address is where data from the remote system will be transfered into  * or out of depending on how the transport is configured.  */
end_comment

begin_function
name|void
name|ntb_set_mw_addr
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|mw
parameter_list|,
name|uint64_t
name|addr
parameter_list|)
block|{
if|if
condition|(
name|mw
operator|>=
name|NTB_NUM_MW
condition|)
return|return;
switch|switch
condition|(
name|NTB_MW_TO_BAR
argument_list|(
name|mw
argument_list|)
condition|)
block|{
case|case
name|NTB_B2B_BAR_1
case|:
name|ntb_write_8
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|sbar2_xlat
argument_list|,
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|NTB_B2B_BAR_2
case|:
name|ntb_write_8
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|sbar4_xlat
argument_list|,
name|addr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * ntb_ring_sdb() - Set the doorbell on the secondary/external side  * @ntb: pointer to ntb_softc instance  * @db: doorbell to ring  *  * This function allows triggering of a doorbell on the secondary/external  * side that will initiate an interrupt on the remote host  *  * RETURNS: An appropriate -ERRNO error value on error, or zero for success.  */
end_comment

begin_function
name|void
name|ntb_ring_sdb
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|db
parameter_list|)
block|{
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_SOC
condition|)
name|ntb_write_8
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|sdb
argument_list|,
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
name|db
argument_list|)
expr_stmt|;
else|else
name|ntb_write_2
argument_list|(
name|ntb
operator|->
name|reg_ofs
operator|.
name|sdb
argument_list|,
operator|(
operator|(
literal|1
operator|<<
name|ntb
operator|->
name|bits_per_vector
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
name|db
operator|*
name|ntb
operator|->
name|bits_per_vector
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ntb_query_link_status() - return the hardware link status  * @ndev: pointer to ntb_device instance  *  * Returns true if the hardware is connected to the remote system  *  * RETURNS: true or false based on the hardware link state  */
end_comment

begin_function
name|bool
name|ntb_query_link_status
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
return|return
operator|(
name|ntb
operator|->
name|link_status
operator|==
name|NTB_LINK_UP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|is_bar_for_data_transfer
parameter_list|(
name|int
name|bar_num
parameter_list|)
block|{
if|if
condition|(
operator|(
name|bar_num
operator|>
name|NTB_CONFIG_BAR
operator|)
operator|&&
operator|(
name|bar_num
operator|<
name|NTB_MAX_BARS
operator|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
end_function

begin_function
name|device_t
name|ntb_get_device
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
return|return
operator|(
name|ntb
operator|->
name|device
operator|)
return|;
block|}
end_function

end_unit

