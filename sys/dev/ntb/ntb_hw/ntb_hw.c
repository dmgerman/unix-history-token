begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 2013 Intel Corporation  * Copyright (C) 2015 EMC Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|"ntb_regs.h"
end_include

begin_include
include|#
directive|include
file|"ntb_hw.h"
end_include

begin_comment
comment|/*  * The Non-Transparent Bridge (NTB) is a device on some Intel processors that  * allows you to connect two systems using a PCI-e link.  *  * This module contains the hardware abstraction layer for the NTB. It allows  * you to send and recieve interrupts, map the memory windows and send and  * receive messages in the scratch-pad registers.  *  * NOTE: Much of the code in this module is shared with Linux. Any patches may  * be picked up and redistributed in Linux with a dual GPL/BSD license.  */
end_comment

begin_define
define|#
directive|define
name|MAX_MSIX_INTERRUPTS
value|MAX(XEON_DB_COUNT, ATOM_DB_COUNT)
end_define

begin_define
define|#
directive|define
name|NTB_HB_TIMEOUT
value|1
end_define

begin_comment
comment|/* second */
end_comment

begin_define
define|#
directive|define
name|ATOM_LINK_RECOVERY_TIME
value|500
end_define

begin_comment
comment|/* ms */
end_comment

begin_define
define|#
directive|define
name|BAR_HIGH_MASK
value|(~((1ull<< 12) - 1))
end_define

begin_define
define|#
directive|define
name|DEVICE2SOFTC
parameter_list|(
name|dev
parameter_list|)
value|((struct ntb_softc *) device_get_softc(dev))
end_define

begin_define
define|#
directive|define
name|NTB_MSIX_VER_GUARD
value|0xaabbccdd
end_define

begin_define
define|#
directive|define
name|NTB_MSIX_RECEIVED
value|0xe0f0e0f0
end_define

begin_comment
comment|/*  * PCI constants could be somewhere more generic, but aren't defined/used in  * pci.c.  */
end_comment

begin_define
define|#
directive|define
name|PCI_MSIX_ENTRY_SIZE
value|16
end_define

begin_define
define|#
directive|define
name|PCI_MSIX_ENTRY_LOWER_ADDR
value|0
end_define

begin_define
define|#
directive|define
name|PCI_MSIX_ENTRY_UPPER_ADDR
value|4
end_define

begin_define
define|#
directive|define
name|PCI_MSIX_ENTRY_DATA
value|8
end_define

begin_enum
enum|enum
name|ntb_device_type
block|{
name|NTB_XEON
block|,
name|NTB_ATOM
block|}
enum|;
end_enum

begin_comment
comment|/* ntb_conn_type are hardware numbers, cannot change. */
end_comment

begin_enum
enum|enum
name|ntb_conn_type
block|{
name|NTB_CONN_TRANSPARENT
init|=
literal|0
block|,
name|NTB_CONN_B2B
init|=
literal|1
block|,
name|NTB_CONN_RP
init|=
literal|2
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|ntb_b2b_direction
block|{
name|NTB_DEV_USD
init|=
literal|0
block|,
name|NTB_DEV_DSD
init|=
literal|1
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|ntb_bar
block|{
name|NTB_CONFIG_BAR
init|=
literal|0
block|,
name|NTB_B2B_BAR_1
block|,
name|NTB_B2B_BAR_2
block|,
name|NTB_B2B_BAR_3
block|,
name|NTB_MAX_BARS
block|}
enum|;
end_enum

begin_enum
enum|enum
block|{
name|NTB_MSIX_GUARD
init|=
literal|0
block|,
name|NTB_MSIX_DATA0
block|,
name|NTB_MSIX_DATA1
block|,
name|NTB_MSIX_DATA2
block|,
name|NTB_MSIX_OFS0
block|,
name|NTB_MSIX_OFS1
block|,
name|NTB_MSIX_OFS2
block|,
name|NTB_MSIX_DONE
block|,
name|NTB_MAX_MSIX_SPAD
block|}
enum|;
end_enum

begin_comment
comment|/* Device features and workarounds */
end_comment

begin_define
define|#
directive|define
name|HAS_FEATURE
parameter_list|(
name|feature
parameter_list|)
define|\
value|((ntb->features& (feature)) != 0)
end_define

begin_struct
struct|struct
name|ntb_hw_info
block|{
name|uint32_t
name|device_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
name|enum
name|ntb_device_type
name|type
decl_stmt|;
name|uint32_t
name|features
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_pci_bar_info
block|{
name|bus_space_tag_t
name|pci_bus_tag
decl_stmt|;
name|bus_space_handle_t
name|pci_bus_handle
decl_stmt|;
name|int
name|pci_resource_id
decl_stmt|;
name|struct
name|resource
modifier|*
name|pci_resource
decl_stmt|;
name|vm_paddr_t
name|pbase
decl_stmt|;
name|caddr_t
name|vbase
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|vm_memattr_t
name|map_mode
decl_stmt|;
comment|/* Configuration register offsets */
name|uint32_t
name|psz_off
decl_stmt|;
name|uint32_t
name|ssz_off
decl_stmt|;
name|uint32_t
name|pbarxlat_off
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_int_info
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|void
modifier|*
name|tag
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_vec
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
decl_stmt|;
name|uint32_t
name|num
decl_stmt|;
name|unsigned
name|masked
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_reg
block|{
name|uint32_t
name|ntb_ctl
decl_stmt|;
name|uint32_t
name|lnk_sta
decl_stmt|;
name|uint8_t
name|db_size
decl_stmt|;
name|unsigned
name|mw_bar
index|[
name|NTB_MAX_BARS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_alt_reg
block|{
name|uint32_t
name|db_bell
decl_stmt|;
name|uint32_t
name|db_mask
decl_stmt|;
name|uint32_t
name|spad
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_xlat_reg
block|{
name|uint32_t
name|bar0_base
decl_stmt|;
name|uint32_t
name|bar2_base
decl_stmt|;
name|uint32_t
name|bar4_base
decl_stmt|;
name|uint32_t
name|bar5_base
decl_stmt|;
name|uint32_t
name|bar2_xlat
decl_stmt|;
name|uint32_t
name|bar4_xlat
decl_stmt|;
name|uint32_t
name|bar5_xlat
decl_stmt|;
name|uint32_t
name|bar2_limit
decl_stmt|;
name|uint32_t
name|bar4_limit
decl_stmt|;
name|uint32_t
name|bar5_limit
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_b2b_addr
block|{
name|uint64_t
name|bar0_addr
decl_stmt|;
name|uint64_t
name|bar2_addr64
decl_stmt|;
name|uint64_t
name|bar4_addr64
decl_stmt|;
name|uint64_t
name|bar4_addr32
decl_stmt|;
name|uint64_t
name|bar5_addr32
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_msix_data
block|{
name|uint32_t
name|nmd_ofs
decl_stmt|;
name|uint32_t
name|nmd_data
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_softc
block|{
name|device_t
name|device
decl_stmt|;
name|enum
name|ntb_device_type
name|type
decl_stmt|;
name|uint32_t
name|features
decl_stmt|;
name|struct
name|ntb_pci_bar_info
name|bar_info
index|[
name|NTB_MAX_BARS
index|]
decl_stmt|;
name|struct
name|ntb_int_info
name|int_info
index|[
name|MAX_MSIX_INTERRUPTS
index|]
decl_stmt|;
name|uint32_t
name|allocated_interrupts
decl_stmt|;
name|struct
name|ntb_msix_data
name|peer_msix_data
index|[
name|XEON_NONLINK_DB_MSIX_BITS
index|]
decl_stmt|;
name|struct
name|ntb_msix_data
name|msix_data
index|[
name|XEON_NONLINK_DB_MSIX_BITS
index|]
decl_stmt|;
name|bool
name|peer_msix_good
decl_stmt|;
name|bool
name|peer_msix_done
decl_stmt|;
name|struct
name|ntb_pci_bar_info
modifier|*
name|peer_lapic_bar
decl_stmt|;
name|struct
name|callout
name|peer_msix_work
decl_stmt|;
name|struct
name|callout
name|heartbeat_timer
decl_stmt|;
name|struct
name|callout
name|lr_timer
decl_stmt|;
name|void
modifier|*
name|ntb_ctx
decl_stmt|;
specifier|const
name|struct
name|ntb_ctx_ops
modifier|*
name|ctx_ops
decl_stmt|;
name|struct
name|ntb_vec
modifier|*
name|msix_vec
decl_stmt|;
define|#
directive|define
name|CTX_LOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_lock(&(sc)->ctx_lock)
define|#
directive|define
name|CTX_UNLOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_unlock(&(sc)->ctx_lock)
define|#
directive|define
name|CTX_ASSERT
parameter_list|(
name|sc
parameter_list|,
name|f
parameter_list|)
value|mtx_assert(&(sc)->ctx_lock, (f))
name|struct
name|mtx
name|ctx_lock
decl_stmt|;
name|uint32_t
name|ppd
decl_stmt|;
name|enum
name|ntb_conn_type
name|conn_type
decl_stmt|;
name|enum
name|ntb_b2b_direction
name|dev_type
decl_stmt|;
comment|/* Offset of peer bar0 in B2B BAR */
name|uint64_t
name|b2b_off
decl_stmt|;
comment|/* Memory window used to access peer bar0 */
define|#
directive|define
name|B2B_MW_DISABLED
value|UINT8_MAX
name|uint8_t
name|b2b_mw_idx
decl_stmt|;
name|uint32_t
name|msix_xlat
decl_stmt|;
name|uint8_t
name|msix_mw_idx
decl_stmt|;
name|uint8_t
name|mw_count
decl_stmt|;
name|uint8_t
name|spad_count
decl_stmt|;
name|uint8_t
name|db_count
decl_stmt|;
name|uint8_t
name|db_vec_count
decl_stmt|;
name|uint8_t
name|db_vec_shift
decl_stmt|;
comment|/* Protects local db_mask. */
define|#
directive|define
name|DB_MASK_LOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_lock_spin(&(sc)->db_mask_lock)
define|#
directive|define
name|DB_MASK_UNLOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_unlock_spin(&(sc)->db_mask_lock)
define|#
directive|define
name|DB_MASK_ASSERT
parameter_list|(
name|sc
parameter_list|,
name|f
parameter_list|)
value|mtx_assert(&(sc)->db_mask_lock, (f))
name|struct
name|mtx
name|db_mask_lock
decl_stmt|;
specifier|volatile
name|uint32_t
name|ntb_ctl
decl_stmt|;
specifier|volatile
name|uint32_t
name|lnk_sta
decl_stmt|;
name|uint64_t
name|db_valid_mask
decl_stmt|;
name|uint64_t
name|db_link_mask
decl_stmt|;
name|uint64_t
name|db_mask
decl_stmt|;
name|int
name|last_ts
decl_stmt|;
comment|/* ticks @ last irq */
specifier|const
name|struct
name|ntb_reg
modifier|*
name|reg
decl_stmt|;
specifier|const
name|struct
name|ntb_alt_reg
modifier|*
name|self_reg
decl_stmt|;
specifier|const
name|struct
name|ntb_alt_reg
modifier|*
name|peer_reg
decl_stmt|;
specifier|const
name|struct
name|ntb_xlat_reg
modifier|*
name|xlat_reg
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_function
specifier|static
name|__inline
name|uint64_t
name|bus_space_read_8
parameter_list|(
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
name|handle
parameter_list|,
name|bus_size_t
name|offset
parameter_list|)
block|{
return|return
operator|(
name|bus_space_read_4
argument_list|(
name|tag
argument_list|,
name|handle
argument_list|,
name|offset
argument_list|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|bus_space_read_4
argument_list|(
name|tag
argument_list|,
name|handle
argument_list|,
name|offset
operator|+
literal|4
argument_list|)
operator|)
operator|<<
literal|32
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|bus_space_write_8
parameter_list|(
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
name|handle
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|bus_space_write_4
argument_list|(
name|tag
argument_list|,
name|handle
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|tag
argument_list|,
name|handle
argument_list|,
name|offset
operator|+
literal|4
argument_list|,
name|val
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ntb_bar_read
parameter_list|(
name|SIZE
parameter_list|,
name|bar
parameter_list|,
name|offset
parameter_list|)
define|\
value|bus_space_read_ ## SIZE (ntb->bar_info[(bar)].pci_bus_tag, \ 	    ntb->bar_info[(bar)].pci_bus_handle, (offset))
end_define

begin_define
define|#
directive|define
name|ntb_bar_write
parameter_list|(
name|SIZE
parameter_list|,
name|bar
parameter_list|,
name|offset
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_space_write_ ## SIZE (ntb->bar_info[(bar)].pci_bus_tag, \ 	    ntb->bar_info[(bar)].pci_bus_handle, (offset), (val))
end_define

begin_define
define|#
directive|define
name|ntb_reg_read
parameter_list|(
name|SIZE
parameter_list|,
name|offset
parameter_list|)
value|ntb_bar_read(SIZE, NTB_CONFIG_BAR, offset)
end_define

begin_define
define|#
directive|define
name|ntb_reg_write
parameter_list|(
name|SIZE
parameter_list|,
name|offset
parameter_list|,
name|val
parameter_list|)
define|\
value|ntb_bar_write(SIZE, NTB_CONFIG_BAR, offset, val)
end_define

begin_define
define|#
directive|define
name|ntb_mw_read
parameter_list|(
name|SIZE
parameter_list|,
name|offset
parameter_list|)
define|\
value|ntb_bar_read(SIZE, ntb_mw_to_bar(ntb, ntb->b2b_mw_idx), offset)
end_define

begin_define
define|#
directive|define
name|ntb_mw_write
parameter_list|(
name|SIZE
parameter_list|,
name|offset
parameter_list|,
name|val
parameter_list|)
define|\
value|ntb_bar_write(SIZE, ntb_mw_to_bar(ntb, ntb->b2b_mw_idx), \ 		offset, val)
end_define

begin_function_decl
specifier|static
name|int
name|ntb_probe
parameter_list|(
name|device_t
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_attach
parameter_list|(
name|device_t
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_detach
parameter_list|(
name|device_t
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|ntb_user_mw_to_idx
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|unsigned
name|uidx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|enum
name|ntb_bar
name|ntb_mw_to_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|unsigned
name|mw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|bool
name|bar_is_64bit
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|enum
name|ntb_bar
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|bar_get_xlat_params
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|enum
name|ntb_bar
parameter_list|,
name|uint32_t
modifier|*
name|base
parameter_list|,
name|uint32_t
modifier|*
name|xlat
parameter_list|,
name|uint32_t
modifier|*
name|lmt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_map_pci_bars
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_mw_set_wc_internal
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|unsigned
name|idx
parameter_list|,
name|vm_memattr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_map_success
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|struct
name|ntb_pci_bar_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|map_mmr_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|map_memory_window_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_unmap_pci_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_remap_msix
parameter_list|(
name|device_t
parameter_list|,
name|uint32_t
name|desired
parameter_list|,
name|uint32_t
name|avail
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_init_isr
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_setup_legacy_interrupt
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_setup_msix
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint32_t
name|num_vectors
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_teardown_interrupts
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|uint64_t
name|ntb_vec_mask
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|uint64_t
name|db_vector
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_interrupt
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|uint32_t
name|vec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ndev_vec_isr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ndev_irq_isr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|uint64_t
name|db_ioread
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|uint64_t
name|regoff
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|db_iowrite
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|uint64_t
name|regoff
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|db_iowrite_raw
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|uint64_t
name|regoff
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_create_msix_vec
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint32_t
name|num_vectors
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_free_msix_vec
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_get_msix_info
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_exchange_msix
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ntb_hw_info
modifier|*
name|ntb_get_device_info
parameter_list|(
name|uint32_t
name|device_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_detect_max_mw
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_detect_xeon
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_detect_atom
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_xeon_init_dev
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_atom_init_dev
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_teardown_xeon
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|configure_atom_secondary_side_bars
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xeon_reset_sbar_size
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|enum
name|ntb_bar
name|idx
parameter_list|,
name|enum
name|ntb_bar
name|regbar
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xeon_set_sbar_base_and_limit
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|uint64_t
name|base_addr
parameter_list|,
name|enum
name|ntb_bar
name|idx
parameter_list|,
name|enum
name|ntb_bar
name|regbar
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xeon_set_pbar_xlat
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|uint64_t
name|base_addr
parameter_list|,
name|enum
name|ntb_bar
name|idx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xeon_setup_b2b_mw
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|ntb_b2b_addr
modifier|*
name|addr
parameter_list|,
specifier|const
name|struct
name|ntb_b2b_addr
modifier|*
name|peer_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xeon_setup_msix_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|bool
name|link_is_up
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|bool
name|_xeon_link_is_up
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|bool
name|atom_link_is_err
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|enum
name|ntb_speed
name|ntb_link_sta_speed
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|enum
name|ntb_width
name|ntb_link_sta_width
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atom_link_hb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_db_event
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint32_t
name|vec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|recover_atom_link
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ntb_poll_link
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_bar_parameters
parameter_list|(
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_sysctl_init
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_handle_features
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_handle_link_admin
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_handle_link_status_human
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_handle_link_status
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_handle_register
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|unsigned
name|g_ntb_hw_debug_level
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ntb.debug_level"
argument_list|,
operator|&
name|g_ntb_hw_debug_level
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_ntb
argument_list|,
name|OID_AUTO
argument_list|,
name|debug_level
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|g_ntb_hw_debug_level
argument_list|,
literal|0
argument_list|,
literal|"ntb_hw log level -- higher is more verbose"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|ntb_printf
parameter_list|(
name|lvl
parameter_list|,
modifier|...
parameter_list|)
value|do {				\ 	if ((lvl)<= g_ntb_hw_debug_level) {			\ 		device_printf(ntb->device, __VA_ARGS__);	\ 	}							\ } while (0)
end_define

begin_define
define|#
directive|define
name|_NTB_PAT_UC
value|0
end_define

begin_define
define|#
directive|define
name|_NTB_PAT_WC
value|1
end_define

begin_define
define|#
directive|define
name|_NTB_PAT_WT
value|4
end_define

begin_define
define|#
directive|define
name|_NTB_PAT_WP
value|5
end_define

begin_define
define|#
directive|define
name|_NTB_PAT_WB
value|6
end_define

begin_define
define|#
directive|define
name|_NTB_PAT_UCM
value|7
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|g_ntb_mw_pat
init|=
name|_NTB_PAT_UC
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ntb.default_mw_pat"
argument_list|,
operator|&
name|g_ntb_mw_pat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_ntb
argument_list|,
name|OID_AUTO
argument_list|,
name|default_mw_pat
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|g_ntb_mw_pat
argument_list|,
literal|0
argument_list|,
literal|"Configure the default memory window cache flags (PAT): "
literal|"UC: "
name|__XSTRING
argument_list|(
name|_NTB_PAT_UC
argument_list|)
literal|", "
literal|"WC: "
name|__XSTRING
argument_list|(
name|_NTB_PAT_WC
argument_list|)
literal|", "
literal|"WT: "
name|__XSTRING
argument_list|(
name|_NTB_PAT_WT
argument_list|)
literal|", "
literal|"WP: "
name|__XSTRING
argument_list|(
name|_NTB_PAT_WP
argument_list|)
literal|", "
literal|"WB: "
name|__XSTRING
argument_list|(
name|_NTB_PAT_WB
argument_list|)
literal|", "
literal|"UC-: "
name|__XSTRING
argument_list|(
name|_NTB_PAT_UCM
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
specifier|inline
name|vm_memattr_t
name|ntb_pat_flags
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|g_ntb_mw_pat
condition|)
block|{
case|case
name|_NTB_PAT_WC
case|:
return|return
operator|(
name|VM_MEMATTR_WRITE_COMBINING
operator|)
return|;
case|case
name|_NTB_PAT_WT
case|:
return|return
operator|(
name|VM_MEMATTR_WRITE_THROUGH
operator|)
return|;
case|case
name|_NTB_PAT_WP
case|:
return|return
operator|(
name|VM_MEMATTR_WRITE_PROTECTED
operator|)
return|;
case|case
name|_NTB_PAT_WB
case|:
return|return
operator|(
name|VM_MEMATTR_WRITE_BACK
operator|)
return|;
case|case
name|_NTB_PAT_UCM
case|:
return|return
operator|(
name|VM_MEMATTR_WEAK_UNCACHEABLE
operator|)
return|;
case|case
name|_NTB_PAT_UC
case|:
comment|/* FALLTHROUGH */
default|default:
return|return
operator|(
name|VM_MEMATTR_UNCACHEABLE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Well, this obviously doesn't belong here, but it doesn't seem to exist  * anywhere better yet.  */
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|ntb_vm_memattr_to_str
parameter_list|(
name|vm_memattr_t
name|pat
parameter_list|)
block|{
switch|switch
condition|(
name|pat
condition|)
block|{
case|case
name|VM_MEMATTR_WRITE_COMBINING
case|:
return|return
operator|(
literal|"WRITE_COMBINING"
operator|)
return|;
case|case
name|VM_MEMATTR_WRITE_THROUGH
case|:
return|return
operator|(
literal|"WRITE_THROUGH"
operator|)
return|;
case|case
name|VM_MEMATTR_WRITE_PROTECTED
case|:
return|return
operator|(
literal|"WRITE_PROTECTED"
operator|)
return|;
case|case
name|VM_MEMATTR_WRITE_BACK
case|:
return|return
operator|(
literal|"WRITE_BACK"
operator|)
return|;
case|case
name|VM_MEMATTR_WEAK_UNCACHEABLE
case|:
return|return
operator|(
literal|"UNCACHED"
operator|)
return|;
case|case
name|VM_MEMATTR_UNCACHEABLE
case|:
return|return
operator|(
literal|"UNCACHEABLE"
operator|)
return|;
default|default:
return|return
operator|(
literal|"UNKNOWN"
operator|)
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|g_ntb_msix_idx
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ntb
argument_list|,
name|OID_AUTO
argument_list|,
name|msix_mw_idx
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|g_ntb_msix_idx
argument_list|,
literal|0
argument_list|,
literal|"Use this memory window to access the peer MSIX message complex on "
literal|"certain Xeon-based NTB systems, as a workaround for a hardware errata.  "
literal|"Like b2b_mw_idx, negative values index from the last available memory "
literal|"window.  (Applies on Xeon platforms with SB01BASE_LOCKUP errata.)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|g_ntb_mw_idx
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ntb.b2b_mw_idx"
argument_list|,
operator|&
name|g_ntb_mw_idx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ntb
argument_list|,
name|OID_AUTO
argument_list|,
name|b2b_mw_idx
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|g_ntb_mw_idx
argument_list|,
literal|0
argument_list|,
literal|"Use this memory window to access the peer NTB registers.  A "
literal|"non-negative value starts from the first MW index; a negative value "
literal|"starts from the last MW index.  The default is -1, i.e., the last "
literal|"available memory window.  Both sides of the NTB MUST set the same "
literal|"value here!  (Applies on Xeon platforms with SDOORBELL_LOCKUP errata.)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|ntb_hw_info
name|pci_ids
index|[]
init|=
block|{
comment|/* XXX: PS/SS IDs left out until they are supported. */
block|{
literal|0x0C4E8086
block|,
literal|"BWD Atom Processor S1200 Non-Transparent Bridge B2B"
block|,
name|NTB_ATOM
block|,
literal|0
block|}
block|,
block|{
literal|0x37258086
block|,
literal|"JSF Xeon C35xx/C55xx Non-Transparent Bridge B2B"
block|,
name|NTB_XEON
block|,
name|NTB_SDOORBELL_LOCKUP
operator||
name|NTB_B2BDOORBELL_BIT14
block|}
block|,
block|{
literal|0x3C0D8086
block|,
literal|"SNB Xeon E5/Core i7 Non-Transparent Bridge B2B"
block|,
name|NTB_XEON
block|,
name|NTB_SDOORBELL_LOCKUP
operator||
name|NTB_B2BDOORBELL_BIT14
block|}
block|,
block|{
literal|0x0E0D8086
block|,
literal|"IVT Xeon E5 V2 Non-Transparent Bridge B2B"
block|,
name|NTB_XEON
block|,
name|NTB_SDOORBELL_LOCKUP
operator||
name|NTB_B2BDOORBELL_BIT14
operator||
name|NTB_SB01BASE_LOCKUP
operator||
name|NTB_BAR_SIZE_4K
block|}
block|,
block|{
literal|0x2F0D8086
block|,
literal|"HSX Xeon E5 V3 Non-Transparent Bridge B2B"
block|,
name|NTB_XEON
block|,
name|NTB_SDOORBELL_LOCKUP
operator||
name|NTB_B2BDOORBELL_BIT14
operator||
name|NTB_SB01BASE_LOCKUP
block|}
block|,
block|{
literal|0x6F0D8086
block|,
literal|"BDX Xeon E5 V4 Non-Transparent Bridge B2B"
block|,
name|NTB_XEON
block|,
name|NTB_SDOORBELL_LOCKUP
operator||
name|NTB_B2BDOORBELL_BIT14
operator||
name|NTB_SB01BASE_LOCKUP
block|}
block|,
block|{
literal|0x00000000
block|,
name|NULL
block|,
name|NTB_ATOM
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ntb_reg
name|atom_reg
init|=
block|{
operator|.
name|ntb_ctl
operator|=
name|ATOM_NTBCNTL_OFFSET
block|,
operator|.
name|lnk_sta
operator|=
name|ATOM_LINK_STATUS_OFFSET
block|,
operator|.
name|db_size
operator|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
block|,
operator|.
name|mw_bar
operator|=
block|{
name|NTB_B2B_BAR_1
block|,
name|NTB_B2B_BAR_2
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ntb_alt_reg
name|atom_pri_reg
init|=
block|{
operator|.
name|db_bell
operator|=
name|ATOM_PDOORBELL_OFFSET
block|,
operator|.
name|db_mask
operator|=
name|ATOM_PDBMSK_OFFSET
block|,
operator|.
name|spad
operator|=
name|ATOM_SPAD_OFFSET
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ntb_alt_reg
name|atom_b2b_reg
init|=
block|{
operator|.
name|db_bell
operator|=
name|ATOM_B2B_DOORBELL_OFFSET
block|,
operator|.
name|spad
operator|=
name|ATOM_B2B_SPAD_OFFSET
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ntb_xlat_reg
name|atom_sec_xlat
init|=
block|{
if|#
directive|if
literal|0
comment|/* "FIXME" says the Linux driver. */
block|.bar0_base = ATOM_SBAR0BASE_OFFSET, 	.bar2_base = ATOM_SBAR2BASE_OFFSET, 	.bar4_base = ATOM_SBAR4BASE_OFFSET,  	.bar2_limit = ATOM_SBAR2LMT_OFFSET, 	.bar4_limit = ATOM_SBAR4LMT_OFFSET,
endif|#
directive|endif
operator|.
name|bar2_xlat
operator|=
name|ATOM_SBAR2XLAT_OFFSET
block|,
operator|.
name|bar4_xlat
operator|=
name|ATOM_SBAR4XLAT_OFFSET
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ntb_reg
name|xeon_reg
init|=
block|{
operator|.
name|ntb_ctl
operator|=
name|XEON_NTBCNTL_OFFSET
block|,
operator|.
name|lnk_sta
operator|=
name|XEON_LINK_STATUS_OFFSET
block|,
operator|.
name|db_size
operator|=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
block|,
operator|.
name|mw_bar
operator|=
block|{
name|NTB_B2B_BAR_1
block|,
name|NTB_B2B_BAR_2
block|,
name|NTB_B2B_BAR_3
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ntb_alt_reg
name|xeon_pri_reg
init|=
block|{
operator|.
name|db_bell
operator|=
name|XEON_PDOORBELL_OFFSET
block|,
operator|.
name|db_mask
operator|=
name|XEON_PDBMSK_OFFSET
block|,
operator|.
name|spad
operator|=
name|XEON_SPAD_OFFSET
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ntb_alt_reg
name|xeon_b2b_reg
init|=
block|{
operator|.
name|db_bell
operator|=
name|XEON_B2B_DOORBELL_OFFSET
block|,
operator|.
name|spad
operator|=
name|XEON_B2B_SPAD_OFFSET
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ntb_xlat_reg
name|xeon_sec_xlat
init|=
block|{
operator|.
name|bar0_base
operator|=
name|XEON_SBAR0BASE_OFFSET
block|,
operator|.
name|bar2_base
operator|=
name|XEON_SBAR2BASE_OFFSET
block|,
operator|.
name|bar4_base
operator|=
name|XEON_SBAR4BASE_OFFSET
block|,
operator|.
name|bar5_base
operator|=
name|XEON_SBAR5BASE_OFFSET
block|,
operator|.
name|bar2_limit
operator|=
name|XEON_SBAR2LMT_OFFSET
block|,
operator|.
name|bar4_limit
operator|=
name|XEON_SBAR4LMT_OFFSET
block|,
operator|.
name|bar5_limit
operator|=
name|XEON_SBAR5LMT_OFFSET
block|,
operator|.
name|bar2_xlat
operator|=
name|XEON_SBAR2XLAT_OFFSET
block|,
operator|.
name|bar4_xlat
operator|=
name|XEON_SBAR4XLAT_OFFSET
block|,
operator|.
name|bar5_xlat
operator|=
name|XEON_SBAR5XLAT_OFFSET
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ntb_b2b_addr
name|xeon_b2b_usd_addr
init|=
block|{
operator|.
name|bar0_addr
operator|=
name|XEON_B2B_BAR0_ADDR
block|,
operator|.
name|bar2_addr64
operator|=
name|XEON_B2B_BAR2_ADDR64
block|,
operator|.
name|bar4_addr64
operator|=
name|XEON_B2B_BAR4_ADDR64
block|,
operator|.
name|bar4_addr32
operator|=
name|XEON_B2B_BAR4_ADDR32
block|,
operator|.
name|bar5_addr32
operator|=
name|XEON_B2B_BAR5_ADDR32
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ntb_b2b_addr
name|xeon_b2b_dsd_addr
init|=
block|{
operator|.
name|bar0_addr
operator|=
name|XEON_B2B_BAR0_ADDR
block|,
operator|.
name|bar2_addr64
operator|=
name|XEON_B2B_BAR2_ADDR64
block|,
operator|.
name|bar4_addr64
operator|=
name|XEON_B2B_BAR4_ADDR64
block|,
operator|.
name|bar4_addr32
operator|=
name|XEON_B2B_BAR4_ADDR32
block|,
operator|.
name|bar5_addr32
operator|=
name|XEON_B2B_BAR5_ADDR32
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_ntb
argument_list|,
name|OID_AUTO
argument_list|,
name|xeon_b2b
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"B2B MW segment overrides -- MUST be the same on both sides"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_QUAD
argument_list|(
literal|"hw.ntb.usd_bar2_addr64"
argument_list|,
operator|&
name|xeon_b2b_usd_addr
operator|.
name|bar2_addr64
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UQUAD
argument_list|(
name|_hw_ntb_xeon_b2b
argument_list|,
name|OID_AUTO
argument_list|,
name|usd_bar2_addr64
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|xeon_b2b_usd_addr
operator|.
name|bar2_addr64
argument_list|,
literal|0
argument_list|,
literal|"If using B2B topology on Xeon "
literal|"hardware, use this 64-bit address on the bus between the NTB devices for "
literal|"the window at BAR2, on the upstream side of the link.  MUST be the same "
literal|"address on both sides."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_QUAD
argument_list|(
literal|"hw.ntb.usd_bar4_addr64"
argument_list|,
operator|&
name|xeon_b2b_usd_addr
operator|.
name|bar4_addr64
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UQUAD
argument_list|(
name|_hw_ntb_xeon_b2b
argument_list|,
name|OID_AUTO
argument_list|,
name|usd_bar4_addr64
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|xeon_b2b_usd_addr
operator|.
name|bar4_addr64
argument_list|,
literal|0
argument_list|,
literal|"See usd_bar2_addr64, but BAR4."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_QUAD
argument_list|(
literal|"hw.ntb.usd_bar4_addr32"
argument_list|,
operator|&
name|xeon_b2b_usd_addr
operator|.
name|bar4_addr32
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UQUAD
argument_list|(
name|_hw_ntb_xeon_b2b
argument_list|,
name|OID_AUTO
argument_list|,
name|usd_bar4_addr32
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|xeon_b2b_usd_addr
operator|.
name|bar4_addr32
argument_list|,
literal|0
argument_list|,
literal|"See usd_bar2_addr64, but BAR4 "
literal|"(split-BAR mode)."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_QUAD
argument_list|(
literal|"hw.ntb.usd_bar5_addr32"
argument_list|,
operator|&
name|xeon_b2b_usd_addr
operator|.
name|bar5_addr32
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UQUAD
argument_list|(
name|_hw_ntb_xeon_b2b
argument_list|,
name|OID_AUTO
argument_list|,
name|usd_bar5_addr32
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|xeon_b2b_usd_addr
operator|.
name|bar5_addr32
argument_list|,
literal|0
argument_list|,
literal|"See usd_bar2_addr64, but BAR5 "
literal|"(split-BAR mode)."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_QUAD
argument_list|(
literal|"hw.ntb.dsd_bar2_addr64"
argument_list|,
operator|&
name|xeon_b2b_dsd_addr
operator|.
name|bar2_addr64
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UQUAD
argument_list|(
name|_hw_ntb_xeon_b2b
argument_list|,
name|OID_AUTO
argument_list|,
name|dsd_bar2_addr64
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|xeon_b2b_dsd_addr
operator|.
name|bar2_addr64
argument_list|,
literal|0
argument_list|,
literal|"If using B2B topology on Xeon "
literal|"hardware, use this 64-bit address on the bus between the NTB devices for "
literal|"the window at BAR2, on the downstream side of the link.  MUST be the same"
literal|" address on both sides."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_QUAD
argument_list|(
literal|"hw.ntb.dsd_bar4_addr64"
argument_list|,
operator|&
name|xeon_b2b_dsd_addr
operator|.
name|bar4_addr64
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UQUAD
argument_list|(
name|_hw_ntb_xeon_b2b
argument_list|,
name|OID_AUTO
argument_list|,
name|dsd_bar4_addr64
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|xeon_b2b_dsd_addr
operator|.
name|bar4_addr64
argument_list|,
literal|0
argument_list|,
literal|"See dsd_bar2_addr64, but BAR4."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_QUAD
argument_list|(
literal|"hw.ntb.dsd_bar4_addr32"
argument_list|,
operator|&
name|xeon_b2b_dsd_addr
operator|.
name|bar4_addr32
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UQUAD
argument_list|(
name|_hw_ntb_xeon_b2b
argument_list|,
name|OID_AUTO
argument_list|,
name|dsd_bar4_addr32
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|xeon_b2b_dsd_addr
operator|.
name|bar4_addr32
argument_list|,
literal|0
argument_list|,
literal|"See dsd_bar2_addr64, but BAR4 "
literal|"(split-BAR mode)."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_QUAD
argument_list|(
literal|"hw.ntb.dsd_bar5_addr32"
argument_list|,
operator|&
name|xeon_b2b_dsd_addr
operator|.
name|bar5_addr32
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UQUAD
argument_list|(
name|_hw_ntb_xeon_b2b
argument_list|,
name|OID_AUTO
argument_list|,
name|dsd_bar5_addr32
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|xeon_b2b_dsd_addr
operator|.
name|bar5_addr32
argument_list|,
literal|0
argument_list|,
literal|"See dsd_bar2_addr64, but BAR5 "
literal|"(split-BAR mode)."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * OS<-> Driver interface structures  */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NTB
argument_list|,
literal|"ntb_hw"
argument_list|,
literal|"ntb_hw driver memory allocations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|ntb_pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ntb_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ntb_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ntb_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ntb_pci_driver
init|=
block|{
literal|"ntb_hw"
block|,
name|ntb_pci_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ntb_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ntb_hw
argument_list|,
name|pci
argument_list|,
name|ntb_pci_driver
argument_list|,
name|ntb_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ntb_hw
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|ntb
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"NTB sysctls"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * OS<-> Driver linkage functions  */
end_comment

begin_function
specifier|static
name|int
name|ntb_probe
parameter_list|(
name|device_t
name|device
parameter_list|)
block|{
name|struct
name|ntb_hw_info
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ntb_get_device_info
argument_list|(
name|pci_get_devid
argument_list|(
name|device
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|device
argument_list|,
name|p
operator|->
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_attach
parameter_list|(
name|device_t
name|device
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
decl_stmt|;
name|struct
name|ntb_hw_info
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ntb
operator|=
name|DEVICE2SOFTC
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|p
operator|=
name|ntb_get_device_info
argument_list|(
name|pci_get_devid
argument_list|(
name|device
argument_list|)
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|device
operator|=
name|device
expr_stmt|;
name|ntb
operator|->
name|type
operator|=
name|p
operator|->
name|type
expr_stmt|;
name|ntb
operator|->
name|features
operator|=
name|p
operator|->
name|features
expr_stmt|;
name|ntb
operator|->
name|b2b_mw_idx
operator|=
name|B2B_MW_DISABLED
expr_stmt|;
name|ntb
operator|->
name|msix_mw_idx
operator|=
name|B2B_MW_DISABLED
expr_stmt|;
comment|/* Heartbeat timer for NTB_ATOM since there is no link interrupt */
name|callout_init
argument_list|(
operator|&
name|ntb
operator|->
name|heartbeat_timer
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|ntb
operator|->
name|lr_timer
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|ntb
operator|->
name|peer_msix_work
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ntb
operator|->
name|db_mask_lock
argument_list|,
literal|"ntb hw bits"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ntb
operator|->
name|ctx_lock
argument_list|,
literal|"ntb ctx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_ATOM
condition|)
name|error
operator|=
name|ntb_detect_atom
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ntb_detect_xeon
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|ntb_detect_max_mw
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|pci_enable_busmaster
argument_list|(
name|ntb
operator|->
name|device
argument_list|)
expr_stmt|;
name|error
operator|=
name|ntb_map_pci_bars
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_ATOM
condition|)
name|error
operator|=
name|ntb_atom_init_dev
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ntb_xeon_init_dev
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|ntb_spad_clear
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|ntb_poll_link
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|ntb_sysctl_init
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|ntb_detach
argument_list|(
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_detach
parameter_list|(
name|device_t
name|device
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
decl_stmt|;
name|ntb
operator|=
name|DEVICE2SOFTC
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|self_reg
operator|!=
name|NULL
condition|)
block|{
name|DB_MASK_LOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|db_iowrite
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|self_reg
operator|->
name|db_mask
argument_list|,
name|ntb
operator|->
name|db_valid_mask
argument_list|)
expr_stmt|;
name|DB_MASK_UNLOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
block|}
name|callout_drain
argument_list|(
operator|&
name|ntb
operator|->
name|heartbeat_timer
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|ntb
operator|->
name|lr_timer
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|ntb
operator|->
name|peer_msix_work
argument_list|)
expr_stmt|;
name|pci_disable_busmaster
argument_list|(
name|ntb
operator|->
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_XEON
condition|)
name|ntb_teardown_xeon
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|ntb_teardown_interrupts
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ntb
operator|->
name|db_mask_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ntb
operator|->
name|ctx_lock
argument_list|)
expr_stmt|;
name|ntb_unmap_pci_bar
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Driver internal routines  */
end_comment

begin_function
specifier|static
specifier|inline
name|enum
name|ntb_bar
name|ntb_mw_to_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|mw
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|mw
operator|<
name|ntb
operator|->
name|mw_count
argument_list|,
operator|(
literal|"%s: mw:%u> count:%u"
operator|,
name|__func__
operator|,
name|mw
operator|,
operator|(
name|unsigned
operator|)
name|ntb
operator|->
name|mw_count
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ntb
operator|->
name|reg
operator|->
name|mw_bar
index|[
name|mw
index|]
operator|!=
literal|0
argument_list|,
operator|(
literal|"invalid mw"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ntb
operator|->
name|reg
operator|->
name|mw_bar
index|[
name|mw
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|bar_is_64bit
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|enum
name|ntb_bar
name|bar
parameter_list|)
block|{
comment|/* XXX This assertion could be stronger. */
name|KASSERT
argument_list|(
name|bar
operator|<
name|NTB_MAX_BARS
argument_list|,
operator|(
literal|"bogus bar"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bar
operator|<
name|NTB_B2B_BAR_2
operator|||
operator|!
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|bar_get_xlat_params
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|enum
name|ntb_bar
name|bar
parameter_list|,
name|uint32_t
modifier|*
name|base
parameter_list|,
name|uint32_t
modifier|*
name|xlat
parameter_list|,
name|uint32_t
modifier|*
name|lmt
parameter_list|)
block|{
name|uint32_t
name|basev
decl_stmt|,
name|lmtv
decl_stmt|,
name|xlatv
decl_stmt|;
switch|switch
condition|(
name|bar
condition|)
block|{
case|case
name|NTB_B2B_BAR_1
case|:
name|basev
operator|=
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar2_base
expr_stmt|;
name|lmtv
operator|=
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar2_limit
expr_stmt|;
name|xlatv
operator|=
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar2_xlat
expr_stmt|;
break|break;
case|case
name|NTB_B2B_BAR_2
case|:
name|basev
operator|=
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar4_base
expr_stmt|;
name|lmtv
operator|=
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar4_limit
expr_stmt|;
name|xlatv
operator|=
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar4_xlat
expr_stmt|;
break|break;
case|case
name|NTB_B2B_BAR_3
case|:
name|basev
operator|=
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar5_base
expr_stmt|;
name|lmtv
operator|=
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar5_limit
expr_stmt|;
name|xlatv
operator|=
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar5_xlat
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
name|bar
operator|>=
name|NTB_B2B_BAR_1
operator|&&
name|bar
operator|<
name|NTB_MAX_BARS
argument_list|,
operator|(
literal|"bad bar"
operator|)
argument_list|)
expr_stmt|;
name|basev
operator|=
name|lmtv
operator|=
name|xlatv
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|base
operator|!=
name|NULL
condition|)
operator|*
name|base
operator|=
name|basev
expr_stmt|;
if|if
condition|(
name|xlat
operator|!=
name|NULL
condition|)
operator|*
name|xlat
operator|=
name|xlatv
expr_stmt|;
if|if
condition|(
name|lmt
operator|!=
name|NULL
condition|)
operator|*
name|lmt
operator|=
name|lmtv
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_map_pci_bars
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_CONFIG_BAR
index|]
operator|.
name|pci_resource_id
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|map_mmr_bar
argument_list|(
name|ntb
argument_list|,
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|NTB_CONFIG_BAR
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_1
index|]
operator|.
name|pci_resource_id
operator|=
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|rc
operator|=
name|map_memory_window_bar
argument_list|(
name|ntb
argument_list|,
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_1
index|]
operator|.
name|psz_off
operator|=
name|XEON_PBAR23SZ_OFFSET
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_1
index|]
operator|.
name|ssz_off
operator|=
name|XEON_SBAR23SZ_OFFSET
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_1
index|]
operator|.
name|pbarxlat_off
operator|=
name|XEON_PBAR2XLAT_OFFSET
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_2
index|]
operator|.
name|pci_resource_id
operator|=
name|PCIR_BAR
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|rc
operator|=
name|map_memory_window_bar
argument_list|(
name|ntb
argument_list|,
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_2
index|]
operator|.
name|psz_off
operator|=
name|XEON_PBAR4SZ_OFFSET
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_2
index|]
operator|.
name|ssz_off
operator|=
name|XEON_SBAR4SZ_OFFSET
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_2
index|]
operator|.
name|pbarxlat_off
operator|=
name|XEON_PBAR4XLAT_OFFSET
expr_stmt|;
if|if
condition|(
operator|!
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_3
index|]
operator|.
name|pci_resource_id
operator|=
name|PCIR_BAR
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|rc
operator|=
name|map_memory_window_bar
argument_list|(
name|ntb
argument_list|,
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_3
index|]
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_3
index|]
operator|.
name|psz_off
operator|=
name|XEON_PBAR5SZ_OFFSET
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_3
index|]
operator|.
name|ssz_off
operator|=
name|XEON_SBAR5SZ_OFFSET
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_3
index|]
operator|.
name|pbarxlat_off
operator|=
name|XEON_PBAR5XLAT_OFFSET
expr_stmt|;
name|out
label|:
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"unable to allocate pci resource\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_map_success
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
parameter_list|,
specifier|const
name|char
modifier|*
name|kind
parameter_list|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Mapped BAR%d v:[%p-%p] p:[%p-%p] (0x%jx bytes) (%s)\n"
argument_list|,
name|PCI_RID2BAR
argument_list|(
name|bar
operator|->
name|pci_resource_id
argument_list|)
argument_list|,
name|bar
operator|->
name|vbase
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bar
operator|->
name|vbase
operator|+
name|bar
operator|->
name|size
operator|-
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bar
operator|->
name|pbase
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|bar
operator|->
name|pbase
operator|+
name|bar
operator|->
name|size
operator|-
literal|1
operator|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|bar
operator|->
name|size
argument_list|,
name|kind
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|map_mmr_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
parameter_list|)
block|{
name|bar
operator|->
name|pci_resource
operator|=
name|bus_alloc_resource_any
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|bar
operator|->
name|pci_resource_id
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bar
operator|->
name|pci_resource
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|save_bar_parameters
argument_list|(
name|bar
argument_list|)
expr_stmt|;
name|bar
operator|->
name|map_mode
operator|=
name|VM_MEMATTR_UNCACHEABLE
expr_stmt|;
name|print_map_success
argument_list|(
name|ntb
argument_list|,
name|bar
argument_list|,
literal|"mmr"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|map_memory_window_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|vm_memattr_t
name|mapmode
decl_stmt|;
name|uint8_t
name|bar_size_bits
init|=
literal|0
decl_stmt|;
name|bar
operator|->
name|pci_resource
operator|=
name|bus_alloc_resource_any
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|bar
operator|->
name|pci_resource_id
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bar
operator|->
name|pci_resource
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|save_bar_parameters
argument_list|(
name|bar
argument_list|)
expr_stmt|;
comment|/* 	 * Ivytown NTB BAR sizes are misreported by the hardware due to a 	 * hardware issue. To work around this, query the size it should be 	 * configured to by the device and modify the resource to correspond to 	 * this new size. The BIOS on systems with this problem is required to 	 * provide enough address space to allow the driver to make this change 	 * safely. 	 * 	 * Ideally I could have just specified the size when I allocated the 	 * resource like: 	 *  bus_alloc_resource(ntb->device, 	 *	SYS_RES_MEMORY,&bar->pci_resource_id, 0ul, ~0ul, 	 *	1ul<< bar_size_bits, RF_ACTIVE); 	 * but the PCI driver does not honor the size in this call, so we have 	 * to modify it after the fact. 	 */
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_BAR_SIZE_4K
argument_list|)
condition|)
block|{
if|if
condition|(
name|bar
operator|->
name|pci_resource_id
operator|==
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
condition|)
name|bar_size_bits
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|XEON_PBAR23SZ_OFFSET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|bar_size_bits
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|XEON_PBAR45SZ_OFFSET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bus_adjust_resource
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|bar
operator|->
name|pci_resource
argument_list|,
name|bar
operator|->
name|pbase
argument_list|,
name|bar
operator|->
name|pbase
operator|+
operator|(
literal|1ul
operator|<<
name|bar_size_bits
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"unable to resize bar\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|save_bar_parameters
argument_list|(
name|bar
argument_list|)
expr_stmt|;
block|}
name|bar
operator|->
name|map_mode
operator|=
name|VM_MEMATTR_UNCACHEABLE
expr_stmt|;
name|print_map_success
argument_list|(
name|ntb
argument_list|,
name|bar
argument_list|,
literal|"mw"
argument_list|)
expr_stmt|;
comment|/* 	 * Optionally, mark MW BARs as anything other than UC to improve 	 * performance. 	 */
name|mapmode
operator|=
name|ntb_pat_flags
argument_list|()
expr_stmt|;
if|if
condition|(
name|mapmode
operator|==
name|bar
operator|->
name|map_mode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rc
operator|=
name|pmap_change_attr
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bar
operator|->
name|vbase
argument_list|,
name|bar
operator|->
name|size
argument_list|,
name|mapmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|bar
operator|->
name|map_mode
operator|=
name|mapmode
expr_stmt|;
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Marked BAR%d v:[%p-%p] p:[%p-%p] as "
literal|"%s.\n"
argument_list|,
name|PCI_RID2BAR
argument_list|(
name|bar
operator|->
name|pci_resource_id
argument_list|)
argument_list|,
name|bar
operator|->
name|vbase
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bar
operator|->
name|vbase
operator|+
name|bar
operator|->
name|size
operator|-
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bar
operator|->
name|pbase
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|bar
operator|->
name|pbase
operator|+
name|bar
operator|->
name|size
operator|-
literal|1
operator|)
argument_list|,
name|ntb_vm_memattr_to_str
argument_list|(
name|mapmode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Unable to mark BAR%d v:[%p-%p] p:[%p-%p] as "
literal|"%s: %d\n"
argument_list|,
name|PCI_RID2BAR
argument_list|(
name|bar
operator|->
name|pci_resource_id
argument_list|)
argument_list|,
name|bar
operator|->
name|vbase
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bar
operator|->
name|vbase
operator|+
name|bar
operator|->
name|size
operator|-
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bar
operator|->
name|pbase
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|bar
operator|->
name|pbase
operator|+
name|bar
operator|->
name|size
operator|-
literal|1
operator|)
argument_list|,
name|ntb_vm_memattr_to_str
argument_list|(
name|mapmode
argument_list|)
argument_list|,
name|rc
argument_list|)
expr_stmt|;
comment|/* Proceed anyway */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_unmap_pci_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|struct
name|ntb_pci_bar_info
modifier|*
name|current_bar
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTB_MAX_BARS
condition|;
name|i
operator|++
control|)
block|{
name|current_bar
operator|=
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|current_bar
operator|->
name|pci_resource
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|current_bar
operator|->
name|pci_resource_id
argument_list|,
name|current_bar
operator|->
name|pci_resource
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_setup_msix
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint32_t
name|num_vectors
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|int
name|rc
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_vectors
condition|;
name|i
operator|++
control|)
block|{
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|rid
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"bus_alloc_resource failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|tag
operator|=
name|NULL
expr_stmt|;
name|ntb
operator|->
name|allocated_interrupts
operator|++
expr_stmt|;
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_MISC
argument_list|,
name|NULL
argument_list|,
name|ndev_vec_isr
argument_list|,
operator|&
name|ntb
operator|->
name|msix_vec
index|[
name|i
index|]
argument_list|,
operator|&
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"bus_setup_intr failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The Linux NTB driver drops from MSI-X to legacy INTx if a unique vector  * cannot be allocated for each MSI-X message.  JHB seems to think remapping  * should be okay.  This tunable should enable us to test that hypothesis  * when someone gets their hands on some Xeon hardware.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ntb_force_remap_mode
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ntb.force_remap_mode"
argument_list|,
operator|&
name|ntb_force_remap_mode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ntb
argument_list|,
name|OID_AUTO
argument_list|,
name|force_remap_mode
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ntb_force_remap_mode
argument_list|,
literal|0
argument_list|,
literal|"If enabled, force MSI-X messages to be remapped"
literal|" to a smaller number of ithreads, even if the desired number are "
literal|"available"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * In case it is NOT ok, give consumers an abort button.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ntb_prefer_intx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ntb.prefer_intx_to_remap"
argument_list|,
operator|&
name|ntb_prefer_intx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ntb
argument_list|,
name|OID_AUTO
argument_list|,
name|prefer_intx_to_remap
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ntb_prefer_intx
argument_list|,
literal|0
argument_list|,
literal|"If enabled, prefer to use legacy INTx mode rather "
literal|"than remapping MSI-X messages over available slots (match Linux driver "
literal|"behavior)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Remap the desired number of MSI-X messages to available ithreads in a simple  * round-robin fashion.  */
end_comment

begin_function
specifier|static
name|int
name|ntb_remap_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint32_t
name|desired
parameter_list|,
name|uint32_t
name|avail
parameter_list|)
block|{
name|u_int
modifier|*
name|vectors
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|ntb_prefer_intx
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|vectors
operator|=
name|malloc
argument_list|(
name|desired
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|vectors
argument_list|)
argument_list|,
name|M_NTB
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|desired
condition|;
name|i
operator|++
control|)
name|vectors
index|[
name|i
index|]
operator|=
operator|(
name|i
operator|%
name|avail
operator|)
operator|+
literal|1
expr_stmt|;
name|rc
operator|=
name|pci_remap_msix
argument_list|(
name|dev
argument_list|,
name|desired
argument_list|,
name|vectors
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vectors
argument_list|,
name|M_NTB
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_init_isr
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|uint32_t
name|desired_vectors
decl_stmt|,
name|num_vectors
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|ntb
operator|->
name|allocated_interrupts
operator|=
literal|0
expr_stmt|;
name|ntb
operator|->
name|last_ts
operator|=
name|ticks
expr_stmt|;
comment|/* 	 * Mask all doorbell interrupts.  (Except link events!) 	 */
name|DB_MASK_LOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|db_mask
operator|=
name|ntb
operator|->
name|db_valid_mask
expr_stmt|;
name|db_iowrite
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|self_reg
operator|->
name|db_mask
argument_list|,
name|ntb
operator|->
name|db_mask
argument_list|)
expr_stmt|;
name|DB_MASK_UNLOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|num_vectors
operator|=
name|desired_vectors
operator|=
name|MIN
argument_list|(
name|pci_msix_count
argument_list|(
name|ntb
operator|->
name|device
argument_list|)
argument_list|,
name|ntb
operator|->
name|db_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|desired_vectors
operator|>=
literal|1
condition|)
block|{
name|rc
operator|=
name|pci_alloc_msix
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
operator|&
name|num_vectors
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb_force_remap_mode
operator|!=
literal|0
operator|&&
name|rc
operator|==
literal|0
operator|&&
name|num_vectors
operator|==
name|desired_vectors
condition|)
name|num_vectors
operator|--
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
operator|&&
name|num_vectors
operator|<
name|desired_vectors
condition|)
block|{
name|rc
operator|=
name|ntb_remap_msix
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|desired_vectors
argument_list|,
name|num_vectors
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|num_vectors
operator|=
name|desired_vectors
expr_stmt|;
else|else
name|pci_release_msi
argument_list|(
name|ntb
operator|->
name|device
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|num_vectors
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|num_vectors
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_XEON
operator|&&
name|num_vectors
operator|<
name|ntb
operator|->
name|db_vec_count
condition|)
block|{
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SB01BASE_LOCKUP
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Errata workaround does not support MSI or INTX\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ntb
operator|->
name|db_vec_count
operator|=
literal|1
expr_stmt|;
name|ntb
operator|->
name|db_vec_shift
operator|=
name|XEON_DB_TOTAL_SHIFT
expr_stmt|;
name|rc
operator|=
name|ntb_setup_legacy_interrupt
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|num_vectors
operator|-
literal|1
operator|!=
name|XEON_NONLINK_DB_MSIX_BITS
operator|&&
name|HAS_FEATURE
argument_list|(
name|NTB_SB01BASE_LOCKUP
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Errata workaround expects %d doorbell bits\n"
argument_list|,
name|XEON_NONLINK_DB_MSIX_BITS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ntb_create_msix_vec
argument_list|(
name|ntb
argument_list|,
name|num_vectors
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ntb_setup_msix
argument_list|(
name|ntb
argument_list|,
name|num_vectors
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
operator|&&
name|HAS_FEATURE
argument_list|(
name|NTB_SB01BASE_LOCKUP
argument_list|)
condition|)
name|ntb_get_msix_info
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Error allocating interrupts: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|ntb_free_msix_vec
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_setup_legacy_interrupt
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|rid
operator|=
literal|0
expr_stmt|;
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"bus_alloc_resource failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|tag
operator|=
name|NULL
expr_stmt|;
name|ntb
operator|->
name|allocated_interrupts
operator|=
literal|1
expr_stmt|;
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_MISC
argument_list|,
name|NULL
argument_list|,
name|ndev_irq_isr
argument_list|,
name|ntb
argument_list|,
operator|&
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"bus_setup_intr failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_teardown_interrupts
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|struct
name|ntb_int_info
modifier|*
name|current_int
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntb
operator|->
name|allocated_interrupts
condition|;
name|i
operator|++
control|)
block|{
name|current_int
operator|=
operator|&
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|current_int
operator|->
name|tag
operator|!=
name|NULL
condition|)
name|bus_teardown_intr
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|current_int
operator|->
name|res
argument_list|,
name|current_int
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_int
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rman_get_rid
argument_list|(
name|current_int
operator|->
name|res
argument_list|)
argument_list|,
name|current_int
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
name|ntb_free_msix_vec
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|pci_release_msi
argument_list|(
name|ntb
operator|->
name|device
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Doorbell register and mask are 64-bit on Atom, 16-bit on Xeon.  Abstract it  * out to make code clearer.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint64_t
name|db_ioread
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint64_t
name|regoff
parameter_list|)
block|{
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_ATOM
condition|)
return|return
operator|(
name|ntb_reg_read
argument_list|(
literal|8
argument_list|,
name|regoff
argument_list|)
operator|)
return|;
name|KASSERT
argument_list|(
name|ntb
operator|->
name|type
operator|==
name|NTB_XEON
argument_list|,
operator|(
literal|"bad ntb type"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ntb_reg_read
argument_list|(
literal|2
argument_list|,
name|regoff
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|db_iowrite
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint64_t
name|regoff
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|val
operator|&
operator|~
name|ntb
operator|->
name|db_valid_mask
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Invalid bits 0x%jx (valid: 0x%jx)"
operator|,
name|__func__
operator|,
call|(
name|uintmax_t
call|)
argument_list|(
name|val
operator|&
operator|~
name|ntb
operator|->
name|db_valid_mask
argument_list|)
operator|,
operator|(
name|uintmax_t
operator|)
name|ntb
operator|->
name|db_valid_mask
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regoff
operator|==
name|ntb
operator|->
name|self_reg
operator|->
name|db_mask
condition|)
name|DB_MASK_ASSERT
argument_list|(
name|ntb
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|db_iowrite_raw
argument_list|(
name|ntb
argument_list|,
name|regoff
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|db_iowrite_raw
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint64_t
name|regoff
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_ATOM
condition|)
block|{
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|regoff
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|ntb
operator|->
name|type
operator|==
name|NTB_XEON
argument_list|,
operator|(
literal|"bad ntb type"
operator|)
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|2
argument_list|,
name|regoff
argument_list|,
operator|(
name|uint16_t
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ntb_db_set_mask
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint64_t
name|bits
parameter_list|)
block|{
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SB01BASE_LOCKUP
argument_list|)
condition|)
return|return;
name|DB_MASK_LOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|db_mask
operator||=
name|bits
expr_stmt|;
name|db_iowrite
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|self_reg
operator|->
name|db_mask
argument_list|,
name|ntb
operator|->
name|db_mask
argument_list|)
expr_stmt|;
name|DB_MASK_UNLOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ntb_db_clear_mask
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint64_t
name|bits
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|bits
operator|&
operator|~
name|ntb
operator|->
name|db_valid_mask
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Invalid bits 0x%jx (valid: 0x%jx)"
operator|,
name|__func__
operator|,
call|(
name|uintmax_t
call|)
argument_list|(
name|bits
operator|&
operator|~
name|ntb
operator|->
name|db_valid_mask
argument_list|)
operator|,
operator|(
name|uintmax_t
operator|)
name|ntb
operator|->
name|db_valid_mask
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SB01BASE_LOCKUP
argument_list|)
condition|)
return|return;
name|DB_MASK_LOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|db_mask
operator|&=
operator|~
name|bits
expr_stmt|;
name|db_iowrite
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|self_reg
operator|->
name|db_mask
argument_list|,
name|ntb
operator|->
name|db_mask
argument_list|)
expr_stmt|;
name|DB_MASK_UNLOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|ntb_db_read
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SB01BASE_LOCKUP
argument_list|)
condition|)
block|{
name|uint64_t
name|res
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XEON_NONLINK_DB_MSIX_BITS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ntb
operator|->
name|msix_vec
index|[
name|i
index|]
operator|.
name|masked
operator|!=
literal|0
condition|)
name|res
operator||=
name|ntb_db_vector_mask
argument_list|(
name|ntb
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
return|return
operator|(
name|db_ioread
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|self_reg
operator|->
name|db_bell
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ntb_db_clear
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint64_t
name|bits
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|bits
operator|&
operator|~
name|ntb
operator|->
name|db_valid_mask
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Invalid bits 0x%jx (valid: 0x%jx)"
operator|,
name|__func__
operator|,
call|(
name|uintmax_t
call|)
argument_list|(
name|bits
operator|&
operator|~
name|ntb
operator|->
name|db_valid_mask
argument_list|)
operator|,
operator|(
name|uintmax_t
operator|)
name|ntb
operator|->
name|db_valid_mask
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SB01BASE_LOCKUP
argument_list|)
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XEON_NONLINK_DB_MSIX_BITS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bits
operator|&
name|ntb_db_vector_mask
argument_list|(
name|ntb
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DB_MASK_LOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|msix_vec
index|[
name|i
index|]
operator|.
name|masked
operator|!=
literal|0
condition|)
block|{
comment|/* XXX These need a public API. */
if|#
directive|if
literal|0
block|pci_unmask_msix(ntb->device, i);
endif|#
directive|endif
name|ntb
operator|->
name|msix_vec
index|[
name|i
index|]
operator|.
name|masked
operator|=
literal|0
expr_stmt|;
block|}
name|DB_MASK_UNLOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
name|db_iowrite
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|self_reg
operator|->
name|db_bell
argument_list|,
name|bits
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|ntb_vec_mask
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint64_t
name|db_vector
parameter_list|)
block|{
name|uint64_t
name|shift
decl_stmt|,
name|mask
decl_stmt|;
name|shift
operator|=
name|ntb
operator|->
name|db_vec_shift
expr_stmt|;
name|mask
operator|=
operator|(
literal|1ull
operator|<<
name|shift
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|mask
operator|<<
operator|(
name|shift
operator|*
name|db_vector
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_interrupt
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint32_t
name|vec
parameter_list|)
block|{
name|uint64_t
name|vec_mask
decl_stmt|;
name|ntb
operator|->
name|last_ts
operator|=
name|ticks
expr_stmt|;
name|vec_mask
operator|=
name|ntb_vec_mask
argument_list|(
name|ntb
argument_list|,
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vec_mask
operator|&
name|ntb
operator|->
name|db_link_mask
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ntb_poll_link
argument_list|(
name|ntb
argument_list|)
condition|)
name|ntb_link_event
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SB01BASE_LOCKUP
argument_list|)
operator|&&
operator|(
name|vec_mask
operator|&
name|ntb
operator|->
name|db_link_mask
operator|)
operator|==
literal|0
condition|)
block|{
name|DB_MASK_LOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|msix_vec
index|[
name|vec
index|]
operator|.
name|masked
operator|==
literal|0
condition|)
block|{
comment|/* XXX These need a public API. */
if|#
directive|if
literal|0
block|pci_mask_msix(ntb->device, vec);
endif|#
directive|endif
name|ntb
operator|->
name|msix_vec
index|[
name|vec
index|]
operator|.
name|masked
operator|=
literal|1
expr_stmt|;
block|}
name|DB_MASK_UNLOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vec_mask
operator|&
name|ntb
operator|->
name|db_valid_mask
operator|)
operator|!=
literal|0
condition|)
name|ntb_db_event
argument_list|(
name|ntb
argument_list|,
name|vec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ndev_vec_isr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_vec
modifier|*
name|nvec
init|=
name|arg
decl_stmt|;
name|ntb_interrupt
argument_list|(
name|nvec
operator|->
name|ntb
argument_list|,
name|nvec
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ndev_irq_isr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* If we couldn't set up MSI-X, we only have the one vector. */
name|ntb_interrupt
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_create_msix_vec
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint32_t
name|num_vectors
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|ntb
operator|->
name|msix_vec
operator|=
name|malloc
argument_list|(
name|num_vectors
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ntb
operator|->
name|msix_vec
argument_list|)
argument_list|,
name|M_NTB
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_vectors
condition|;
name|i
operator|++
control|)
block|{
name|ntb
operator|->
name|msix_vec
index|[
name|i
index|]
operator|.
name|num
operator|=
name|i
expr_stmt|;
name|ntb
operator|->
name|msix_vec
index|[
name|i
index|]
operator|.
name|ntb
operator|=
name|ntb
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_free_msix_vec
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
if|if
condition|(
name|ntb
operator|->
name|msix_vec
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
name|ntb
operator|->
name|msix_vec
argument_list|,
name|M_NTB
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|msix_vec
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_get_msix_info
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|pcicfg_msix
modifier|*
name|msix
decl_stmt|;
name|uint32_t
name|laddr
decl_stmt|,
name|data
decl_stmt|,
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|ntb
operator|->
name|device
argument_list|)
expr_stmt|;
name|msix
operator|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
expr_stmt|;
name|CTASSERT
argument_list|(
name|XEON_NONLINK_DB_MSIX_BITS
operator|==
name|nitems
argument_list|(
name|ntb
operator|->
name|msix_data
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XEON_NONLINK_DB_MSIX_BITS
condition|;
name|i
operator|++
control|)
block|{
name|offset
operator|=
name|msix
operator|->
name|msix_table_offset
operator|+
name|i
operator|*
name|PCI_MSIX_ENTRY_SIZE
expr_stmt|;
name|laddr
operator|=
name|bus_read_4
argument_list|(
name|msix
operator|->
name|msix_table_res
argument_list|,
name|offset
operator|+
name|PCI_MSIX_ENTRY_LOWER_ADDR
argument_list|)
expr_stmt|;
name|ntb_printf
argument_list|(
literal|2
argument_list|,
literal|"local MSIX addr(%u): 0x%x\n"
argument_list|,
name|i
argument_list|,
name|laddr
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|laddr
operator|&
name|MSI_INTEL_ADDR_BASE
operator|)
operator|==
name|MSI_INTEL_ADDR_BASE
argument_list|,
operator|(
literal|"local MSIX addr 0x%x not in MSI base 0x%x"
operator|,
name|laddr
operator|,
name|MSI_INTEL_ADDR_BASE
operator|)
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|msix_data
index|[
name|i
index|]
operator|.
name|nmd_ofs
operator|=
name|laddr
expr_stmt|;
name|data
operator|=
name|bus_read_4
argument_list|(
name|msix
operator|->
name|msix_table_res
argument_list|,
name|offset
operator|+
name|PCI_MSIX_ENTRY_DATA
argument_list|)
expr_stmt|;
name|ntb_printf
argument_list|(
literal|2
argument_list|,
literal|"local MSIX data(%u): 0x%x\n"
argument_list|,
name|i
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|msix_data
index|[
name|i
index|]
operator|.
name|nmd_data
operator|=
name|data
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|ntb_hw_info
modifier|*
name|ntb_get_device_info
parameter_list|(
name|uint32_t
name|device_id
parameter_list|)
block|{
name|struct
name|ntb_hw_info
modifier|*
name|ep
init|=
name|pci_ids
decl_stmt|;
while|while
condition|(
name|ep
operator|->
name|device_id
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|device_id
operator|==
name|device_id
condition|)
return|return
operator|(
name|ep
operator|)
return|;
operator|++
name|ep
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_teardown_xeon
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
if|if
condition|(
name|ntb
operator|->
name|reg
operator|!=
name|NULL
condition|)
name|ntb_link_disable
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_detect_max_mw
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_ATOM
condition|)
block|{
name|ntb
operator|->
name|mw_count
operator|=
name|ATOM_MW_COUNT
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
name|ntb
operator|->
name|mw_count
operator|=
name|XEON_HSX_SPLIT_MW_COUNT
expr_stmt|;
else|else
name|ntb
operator|->
name|mw_count
operator|=
name|XEON_SNB_MW_COUNT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_detect_xeon
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|uint8_t
name|ppd
decl_stmt|,
name|conn_type
decl_stmt|;
name|ppd
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|NTB_PPD_OFFSET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|ppd
operator|=
name|ppd
expr_stmt|;
if|if
condition|(
operator|(
name|ppd
operator|&
name|XEON_PPD_DEV_TYPE
operator|)
operator|!=
literal|0
condition|)
name|ntb
operator|->
name|dev_type
operator|=
name|NTB_DEV_DSD
expr_stmt|;
else|else
name|ntb
operator|->
name|dev_type
operator|=
name|NTB_DEV_USD
expr_stmt|;
if|if
condition|(
operator|(
name|ppd
operator|&
name|XEON_PPD_SPLIT_BAR
operator|)
operator|!=
literal|0
condition|)
name|ntb
operator|->
name|features
operator||=
name|NTB_SPLIT_BAR
expr_stmt|;
comment|/* 	 * SDOORBELL errata workaround gets in the way of SB01BASE_LOCKUP 	 * errata workaround; only do one at a time. 	 */
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SB01BASE_LOCKUP
argument_list|)
condition|)
name|ntb
operator|->
name|features
operator|&=
operator|~
name|NTB_SDOORBELL_LOCKUP
expr_stmt|;
name|conn_type
operator|=
name|ppd
operator|&
name|XEON_PPD_CONN_TYPE
expr_stmt|;
switch|switch
condition|(
name|conn_type
condition|)
block|{
case|case
name|NTB_CONN_B2B
case|:
name|ntb
operator|->
name|conn_type
operator|=
name|conn_type
expr_stmt|;
break|break;
case|case
name|NTB_CONN_RP
case|:
case|case
name|NTB_CONN_TRANSPARENT
case|:
default|default:
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Unsupported connection type: %u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|conn_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_detect_atom
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|uint32_t
name|ppd
decl_stmt|,
name|conn_type
decl_stmt|;
name|ppd
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|NTB_PPD_OFFSET
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|ppd
operator|=
name|ppd
expr_stmt|;
if|if
condition|(
operator|(
name|ppd
operator|&
name|ATOM_PPD_DEV_TYPE
operator|)
operator|!=
literal|0
condition|)
name|ntb
operator|->
name|dev_type
operator|=
name|NTB_DEV_DSD
expr_stmt|;
else|else
name|ntb
operator|->
name|dev_type
operator|=
name|NTB_DEV_USD
expr_stmt|;
name|conn_type
operator|=
operator|(
name|ppd
operator|&
name|ATOM_PPD_CONN_TYPE
operator|)
operator|>>
literal|8
expr_stmt|;
switch|switch
condition|(
name|conn_type
condition|)
block|{
case|case
name|NTB_CONN_B2B
case|:
name|ntb
operator|->
name|conn_type
operator|=
name|conn_type
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Unsupported NTB configuration\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_xeon_init_dev
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|ntb
operator|->
name|spad_count
operator|=
name|XEON_SPAD_COUNT
expr_stmt|;
name|ntb
operator|->
name|db_count
operator|=
name|XEON_DB_COUNT
expr_stmt|;
name|ntb
operator|->
name|db_link_mask
operator|=
name|XEON_DB_LINK_BIT
expr_stmt|;
name|ntb
operator|->
name|db_vec_count
operator|=
name|XEON_DB_MSIX_VECTOR_COUNT
expr_stmt|;
name|ntb
operator|->
name|db_vec_shift
operator|=
name|XEON_DB_MSIX_VECTOR_SHIFT
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|conn_type
operator|!=
name|NTB_CONN_B2B
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Connection type %d not supported\n"
argument_list|,
name|ntb
operator|->
name|conn_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ntb
operator|->
name|reg
operator|=
operator|&
name|xeon_reg
expr_stmt|;
name|ntb
operator|->
name|self_reg
operator|=
operator|&
name|xeon_pri_reg
expr_stmt|;
name|ntb
operator|->
name|peer_reg
operator|=
operator|&
name|xeon_b2b_reg
expr_stmt|;
name|ntb
operator|->
name|xlat_reg
operator|=
operator|&
name|xeon_sec_xlat
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SB01BASE_LOCKUP
argument_list|)
condition|)
block|{
name|ntb
operator|->
name|msix_mw_idx
operator|=
operator|(
name|ntb
operator|->
name|mw_count
operator|+
name|g_ntb_msix_idx
operator|)
operator|%
name|ntb
operator|->
name|mw_count
expr_stmt|;
name|ntb_printf
argument_list|(
literal|2
argument_list|,
literal|"Setting up MSIX mw idx %d means %u\n"
argument_list|,
name|g_ntb_msix_idx
argument_list|,
name|ntb
operator|->
name|msix_mw_idx
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ntb_mw_set_wc_internal
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|msix_mw_idx
argument_list|,
name|VM_MEMATTR_UNCACHEABLE
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rc
operator|==
literal|0
argument_list|,
operator|(
literal|"shouldn't fail"
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SDOORBELL_LOCKUP
argument_list|)
condition|)
block|{
comment|/* 		 * There is a Xeon hardware errata related to writes to SDOORBELL or 		 * B2BDOORBELL in conjunction with inbound access to NTB MMIO space, 		 * which may hang the system.  To workaround this, use a memory 		 * window to access the interrupt and scratch pad registers on the 		 * remote system. 		 */
name|ntb
operator|->
name|b2b_mw_idx
operator|=
operator|(
name|ntb
operator|->
name|mw_count
operator|+
name|g_ntb_mw_idx
operator|)
operator|%
name|ntb
operator|->
name|mw_count
expr_stmt|;
name|ntb_printf
argument_list|(
literal|2
argument_list|,
literal|"Setting up b2b mw idx %d means %u\n"
argument_list|,
name|g_ntb_mw_idx
argument_list|,
name|ntb
operator|->
name|b2b_mw_idx
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ntb_mw_set_wc_internal
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|b2b_mw_idx
argument_list|,
name|VM_MEMATTR_UNCACHEABLE
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rc
operator|==
literal|0
argument_list|,
operator|(
literal|"shouldn't fail"
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_B2BDOORBELL_BIT14
argument_list|)
condition|)
comment|/* 		 * HW Errata on bit 14 of b2bdoorbell register.  Writes will not be 		 * mirrored to the remote system.  Shrink the number of bits by one, 		 * since bit 14 is the last bit. 		 * 		 * On REGS_THRU_MW errata mode, we don't use the b2bdoorbell register 		 * anyway.  Nor for non-B2B connection types. 		 */
name|ntb
operator|->
name|db_count
operator|=
name|XEON_DB_COUNT
operator|-
literal|1
expr_stmt|;
name|ntb
operator|->
name|db_valid_mask
operator|=
operator|(
literal|1ull
operator|<<
name|ntb
operator|->
name|db_count
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|dev_type
operator|==
name|NTB_DEV_USD
condition|)
name|rc
operator|=
name|xeon_setup_b2b_mw
argument_list|(
name|ntb
argument_list|,
operator|&
name|xeon_b2b_dsd_addr
argument_list|,
operator|&
name|xeon_b2b_usd_addr
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|xeon_setup_b2b_mw
argument_list|(
name|ntb
argument_list|,
operator|&
name|xeon_b2b_usd_addr
argument_list|,
operator|&
name|xeon_b2b_dsd_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* Enable Bus Master and Memory Space on the secondary side */
name|ntb_reg_write
argument_list|(
literal|2
argument_list|,
name|XEON_SPCICMD_OFFSET
argument_list|,
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
argument_list|)
expr_stmt|;
comment|/* 	 * Mask all doorbell interrupts. 	 */
name|DB_MASK_LOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|db_mask
operator|=
name|ntb
operator|->
name|db_valid_mask
expr_stmt|;
name|db_iowrite
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|self_reg
operator|->
name|db_mask
argument_list|,
name|ntb
operator|->
name|db_mask
argument_list|)
expr_stmt|;
name|DB_MASK_UNLOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xeon_setup_msix_bar
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
name|ntb_init_isr
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_atom_init_dev
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|ntb
operator|->
name|conn_type
operator|==
name|NTB_CONN_B2B
argument_list|,
operator|(
literal|"Unsupported NTB configuration (%d)\n"
operator|,
name|ntb
operator|->
name|conn_type
operator|)
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|spad_count
operator|=
name|ATOM_SPAD_COUNT
expr_stmt|;
name|ntb
operator|->
name|db_count
operator|=
name|ATOM_DB_COUNT
expr_stmt|;
name|ntb
operator|->
name|db_vec_count
operator|=
name|ATOM_DB_MSIX_VECTOR_COUNT
expr_stmt|;
name|ntb
operator|->
name|db_vec_shift
operator|=
name|ATOM_DB_MSIX_VECTOR_SHIFT
expr_stmt|;
name|ntb
operator|->
name|db_valid_mask
operator|=
operator|(
literal|1ull
operator|<<
name|ntb
operator|->
name|db_count
operator|)
operator|-
literal|1
expr_stmt|;
name|ntb
operator|->
name|reg
operator|=
operator|&
name|atom_reg
expr_stmt|;
name|ntb
operator|->
name|self_reg
operator|=
operator|&
name|atom_pri_reg
expr_stmt|;
name|ntb
operator|->
name|peer_reg
operator|=
operator|&
name|atom_b2b_reg
expr_stmt|;
name|ntb
operator|->
name|xlat_reg
operator|=
operator|&
name|atom_sec_xlat
expr_stmt|;
comment|/* 	 * FIXME - MSI-X bug on early Atom HW, remove once internal issue is 	 * resolved.  Mask transaction layer internal parity errors. 	 */
name|pci_write_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|0xFC
argument_list|,
literal|0x4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|configure_atom_secondary_side_bars
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
comment|/* Enable Bus Master and Memory Space on the secondary side */
name|ntb_reg_write
argument_list|(
literal|2
argument_list|,
name|ATOM_SPCICMD_OFFSET
argument_list|,
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
argument_list|)
expr_stmt|;
name|error
operator|=
name|ntb_init_isr
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Initiate PCI-E link training */
name|ntb_link_enable
argument_list|(
name|ntb
argument_list|,
name|NTB_SPEED_AUTO
argument_list|,
name|NTB_WIDTH_AUTO
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|ntb
operator|->
name|heartbeat_timer
argument_list|,
literal|0
argument_list|,
name|atom_link_hb
argument_list|,
name|ntb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* XXX: Linux driver doesn't seem to do any of this for Atom. */
end_comment

begin_function
specifier|static
name|void
name|configure_atom_secondary_side_bars
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
if|if
condition|(
name|ntb
operator|->
name|dev_type
operator|==
name|NTB_DEV_USD
condition|)
block|{
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|ATOM_PBAR2XLAT_OFFSET
argument_list|,
name|XEON_B2B_BAR2_ADDR64
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|ATOM_PBAR4XLAT_OFFSET
argument_list|,
name|XEON_B2B_BAR4_ADDR64
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|ATOM_MBAR23_OFFSET
argument_list|,
name|XEON_B2B_BAR2_ADDR64
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|ATOM_MBAR45_OFFSET
argument_list|,
name|XEON_B2B_BAR4_ADDR64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|ATOM_PBAR2XLAT_OFFSET
argument_list|,
name|XEON_B2B_BAR2_ADDR64
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|ATOM_PBAR4XLAT_OFFSET
argument_list|,
name|XEON_B2B_BAR4_ADDR64
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|ATOM_MBAR23_OFFSET
argument_list|,
name|XEON_B2B_BAR2_ADDR64
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|ATOM_MBAR45_OFFSET
argument_list|,
name|XEON_B2B_BAR4_ADDR64
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * When working around Xeon SDOORBELL errata by remapping remote registers in a  * MW, limit the B2B MW to half a MW.  By sharing a MW, half the shared MW  * remains for use by a higher layer.  *  * Will only be used if working around SDOORBELL errata and the BIOS-configured  * MW size is sufficiently large.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|ntb_b2b_mw_share
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ntb.b2b_mw_share"
argument_list|,
operator|&
name|ntb_b2b_mw_share
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_ntb
argument_list|,
name|OID_AUTO
argument_list|,
name|b2b_mw_share
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ntb_b2b_mw_share
argument_list|,
literal|0
argument_list|,
literal|"If enabled (non-zero), prefer to share half of the B2B peer register "
literal|"MW with higher level consumers.  Both sides of the NTB MUST set the same "
literal|"value here."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|xeon_reset_sbar_size
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|enum
name|ntb_bar
name|idx
parameter_list|,
name|enum
name|ntb_bar
name|regbar
parameter_list|)
block|{
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
decl_stmt|;
name|uint8_t
name|bar_sz
decl_stmt|;
if|if
condition|(
operator|!
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
operator|&&
name|idx
operator|>=
name|NTB_B2B_BAR_3
condition|)
return|return;
name|bar
operator|=
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|idx
index|]
expr_stmt|;
name|bar_sz
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|bar
operator|->
name|psz_off
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|regbar
condition|)
block|{
if|if
condition|(
name|ntb
operator|->
name|b2b_off
operator|!=
literal|0
condition|)
name|bar_sz
operator|--
expr_stmt|;
else|else
name|bar_sz
operator|=
literal|0
expr_stmt|;
block|}
name|pci_write_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|bar
operator|->
name|ssz_off
argument_list|,
name|bar_sz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bar_sz
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|bar
operator|->
name|ssz_off
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bar_sz
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xeon_set_sbar_base_and_limit
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint64_t
name|bar_addr
parameter_list|,
name|enum
name|ntb_bar
name|idx
parameter_list|,
name|enum
name|ntb_bar
name|regbar
parameter_list|)
block|{
name|uint64_t
name|reg_val
decl_stmt|;
name|uint32_t
name|base_reg
decl_stmt|,
name|lmt_reg
decl_stmt|;
name|bar_get_xlat_params
argument_list|(
name|ntb
argument_list|,
name|idx
argument_list|,
operator|&
name|base_reg
argument_list|,
name|NULL
argument_list|,
operator|&
name|lmt_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|regbar
condition|)
block|{
if|if
condition|(
name|ntb
operator|->
name|b2b_off
condition|)
name|bar_addr
operator|+=
name|ntb
operator|->
name|b2b_off
expr_stmt|;
else|else
name|bar_addr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Set limit registers first to avoid an errata where setting the base 	 * registers locks the limit registers. 	 */
if|if
condition|(
operator|!
name|bar_is_64bit
argument_list|(
name|ntb
argument_list|,
name|idx
argument_list|)
condition|)
block|{
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|lmt_reg
argument_list|,
name|bar_addr
argument_list|)
expr_stmt|;
name|reg_val
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|lmt_reg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|reg_val
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|base_reg
argument_list|,
name|bar_addr
argument_list|)
expr_stmt|;
name|reg_val
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|base_reg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|reg_val
expr_stmt|;
block|}
else|else
block|{
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|lmt_reg
argument_list|,
name|bar_addr
argument_list|)
expr_stmt|;
name|reg_val
operator|=
name|ntb_reg_read
argument_list|(
literal|8
argument_list|,
name|lmt_reg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|reg_val
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|base_reg
argument_list|,
name|bar_addr
argument_list|)
expr_stmt|;
name|reg_val
operator|=
name|ntb_reg_read
argument_list|(
literal|8
argument_list|,
name|base_reg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|reg_val
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xeon_set_pbar_xlat
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint64_t
name|base_addr
parameter_list|,
name|enum
name|ntb_bar
name|idx
parameter_list|)
block|{
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
decl_stmt|;
name|bar
operator|=
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
operator|&&
name|idx
operator|>=
name|NTB_B2B_BAR_2
condition|)
block|{
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|bar
operator|->
name|pbarxlat_off
argument_list|,
name|base_addr
argument_list|)
expr_stmt|;
name|base_addr
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|bar
operator|->
name|pbarxlat_off
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|bar
operator|->
name|pbarxlat_off
argument_list|,
name|base_addr
argument_list|)
expr_stmt|;
name|base_addr
operator|=
name|ntb_reg_read
argument_list|(
literal|8
argument_list|,
name|bar
operator|->
name|pbarxlat_off
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|base_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xeon_setup_msix_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|enum
name|ntb_bar
name|bar_num
decl_stmt|;
if|if
condition|(
operator|!
name|HAS_FEATURE
argument_list|(
name|NTB_SB01BASE_LOCKUP
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bar_num
operator|=
name|ntb_mw_to_bar
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|msix_mw_idx
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|peer_lapic_bar
operator|=
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|bar_num
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xeon_setup_b2b_mw
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
specifier|const
name|struct
name|ntb_b2b_addr
modifier|*
name|addr
parameter_list|,
specifier|const
name|struct
name|ntb_b2b_addr
modifier|*
name|peer_addr
parameter_list|)
block|{
name|struct
name|ntb_pci_bar_info
modifier|*
name|b2b_bar
decl_stmt|;
name|vm_size_t
name|bar_size
decl_stmt|;
name|uint64_t
name|bar_addr
decl_stmt|;
name|enum
name|ntb_bar
name|b2b_bar_num
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|ntb
operator|->
name|b2b_mw_idx
operator|==
name|B2B_MW_DISABLED
condition|)
block|{
name|b2b_bar
operator|=
name|NULL
expr_stmt|;
name|b2b_bar_num
operator|=
name|NTB_CONFIG_BAR
expr_stmt|;
name|ntb
operator|->
name|b2b_off
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|b2b_bar_num
operator|=
name|ntb_mw_to_bar
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|b2b_mw_idx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|b2b_bar_num
operator|>
literal|0
operator|&&
name|b2b_bar_num
operator|<
name|NTB_MAX_BARS
argument_list|,
operator|(
literal|"invalid b2b mw bar"
operator|)
argument_list|)
expr_stmt|;
name|b2b_bar
operator|=
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|b2b_bar_num
index|]
expr_stmt|;
name|bar_size
operator|=
name|b2b_bar
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|ntb_b2b_mw_share
operator|!=
literal|0
operator|&&
operator|(
name|bar_size
operator|>>
literal|1
operator|)
operator|>=
name|XEON_B2B_MIN_SIZE
condition|)
name|ntb
operator|->
name|b2b_off
operator|=
name|bar_size
operator|>>
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|bar_size
operator|>=
name|XEON_B2B_MIN_SIZE
condition|)
block|{
name|ntb
operator|->
name|b2b_off
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"B2B bar size is too small!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
comment|/* 	 * Reset the secondary bar sizes to match the primary bar sizes. 	 * (Except, disable or halve the size of the B2B secondary bar.) 	 */
for|for
control|(
name|i
operator|=
name|NTB_B2B_BAR_1
init|;
name|i
operator|<
name|NTB_MAX_BARS
condition|;
name|i
operator|++
control|)
name|xeon_reset_sbar_size
argument_list|(
name|ntb
argument_list|,
name|i
argument_list|,
name|b2b_bar_num
argument_list|)
expr_stmt|;
name|bar_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b2b_bar_num
operator|==
name|NTB_CONFIG_BAR
condition|)
name|bar_addr
operator|=
name|addr
operator|->
name|bar0_addr
expr_stmt|;
elseif|else
if|if
condition|(
name|b2b_bar_num
operator|==
name|NTB_B2B_BAR_1
condition|)
name|bar_addr
operator|=
name|addr
operator|->
name|bar2_addr64
expr_stmt|;
elseif|else
if|if
condition|(
name|b2b_bar_num
operator|==
name|NTB_B2B_BAR_2
operator|&&
operator|!
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
name|bar_addr
operator|=
name|addr
operator|->
name|bar4_addr64
expr_stmt|;
elseif|else
if|if
condition|(
name|b2b_bar_num
operator|==
name|NTB_B2B_BAR_2
condition|)
name|bar_addr
operator|=
name|addr
operator|->
name|bar4_addr32
expr_stmt|;
elseif|else
if|if
condition|(
name|b2b_bar_num
operator|==
name|NTB_B2B_BAR_3
condition|)
name|bar_addr
operator|=
name|addr
operator|->
name|bar5_addr32
expr_stmt|;
else|else
name|KASSERT
argument_list|(
name|false
argument_list|,
operator|(
literal|"invalid bar"
operator|)
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|XEON_SBAR0BASE_OFFSET
argument_list|,
name|bar_addr
argument_list|)
expr_stmt|;
comment|/* 	 * Other SBARs are normally hit by the PBAR xlat, except for the b2b 	 * register BAR.  The B2B BAR is either disabled above or configured 	 * half-size.  It starts at PBAR xlat + offset. 	 * 	 * Also set up incoming BAR limits == base (zero length window). 	 */
name|xeon_set_sbar_base_and_limit
argument_list|(
name|ntb
argument_list|,
name|addr
operator|->
name|bar2_addr64
argument_list|,
name|NTB_B2B_BAR_1
argument_list|,
name|b2b_bar_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
block|{
name|xeon_set_sbar_base_and_limit
argument_list|(
name|ntb
argument_list|,
name|addr
operator|->
name|bar4_addr32
argument_list|,
name|NTB_B2B_BAR_2
argument_list|,
name|b2b_bar_num
argument_list|)
expr_stmt|;
name|xeon_set_sbar_base_and_limit
argument_list|(
name|ntb
argument_list|,
name|addr
operator|->
name|bar5_addr32
argument_list|,
name|NTB_B2B_BAR_3
argument_list|,
name|b2b_bar_num
argument_list|)
expr_stmt|;
block|}
else|else
name|xeon_set_sbar_base_and_limit
argument_list|(
name|ntb
argument_list|,
name|addr
operator|->
name|bar4_addr64
argument_list|,
name|NTB_B2B_BAR_2
argument_list|,
name|b2b_bar_num
argument_list|)
expr_stmt|;
comment|/* Zero incoming translation addrs */
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|XEON_SBAR2XLAT_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|XEON_SBAR4XLAT_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SB01BASE_LOCKUP
argument_list|)
condition|)
block|{
name|size_t
name|size
decl_stmt|,
name|xlatoffset
decl_stmt|;
switch|switch
condition|(
name|ntb_mw_to_bar
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|msix_mw_idx
argument_list|)
condition|)
block|{
case|case
name|NTB_B2B_BAR_1
case|:
name|size
operator|=
literal|8
expr_stmt|;
name|xlatoffset
operator|=
name|XEON_SBAR2XLAT_OFFSET
expr_stmt|;
break|break;
case|case
name|NTB_B2B_BAR_2
case|:
name|xlatoffset
operator|=
name|XEON_SBAR4XLAT_OFFSET
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
name|size
operator|=
literal|4
expr_stmt|;
else|else
name|size
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|NTB_B2B_BAR_3
case|:
name|xlatoffset
operator|=
name|XEON_SBAR5XLAT_OFFSET
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
name|false
argument_list|,
operator|(
literal|"Bogus msix mw idx: %u"
operator|,
name|ntb
operator|->
name|msix_mw_idx
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 		 * We point the chosen MSIX MW BAR xlat to remote LAPIC for 		 * workaround 		 */
if|if
condition|(
name|size
operator|==
literal|4
condition|)
block|{
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|xlatoffset
argument_list|,
name|MSI_INTEL_ADDR_BASE
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|msix_xlat
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|xlatoffset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|xlatoffset
argument_list|,
name|MSI_INTEL_ADDR_BASE
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|msix_xlat
operator|=
name|ntb_reg_read
argument_list|(
literal|8
argument_list|,
name|xlatoffset
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|ntb_reg_read
argument_list|(
literal|8
argument_list|,
name|XEON_SBAR2XLAT_OFFSET
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ntb_reg_read
argument_list|(
literal|8
argument_list|,
name|XEON_SBAR4XLAT_OFFSET
argument_list|)
expr_stmt|;
comment|/* Zero outgoing translation limits (whole bar size windows) */
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|XEON_PBAR2LMT_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|XEON_PBAR4LMT_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set outgoing translation offsets */
name|xeon_set_pbar_xlat
argument_list|(
name|ntb
argument_list|,
name|peer_addr
operator|->
name|bar2_addr64
argument_list|,
name|NTB_B2B_BAR_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
block|{
name|xeon_set_pbar_xlat
argument_list|(
name|ntb
argument_list|,
name|peer_addr
operator|->
name|bar4_addr32
argument_list|,
name|NTB_B2B_BAR_2
argument_list|)
expr_stmt|;
name|xeon_set_pbar_xlat
argument_list|(
name|ntb
argument_list|,
name|peer_addr
operator|->
name|bar5_addr32
argument_list|,
name|NTB_B2B_BAR_3
argument_list|)
expr_stmt|;
block|}
else|else
name|xeon_set_pbar_xlat
argument_list|(
name|ntb
argument_list|,
name|peer_addr
operator|->
name|bar4_addr64
argument_list|,
name|NTB_B2B_BAR_2
argument_list|)
expr_stmt|;
comment|/* Set the translation offset for B2B registers */
name|bar_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b2b_bar_num
operator|==
name|NTB_CONFIG_BAR
condition|)
name|bar_addr
operator|=
name|peer_addr
operator|->
name|bar0_addr
expr_stmt|;
elseif|else
if|if
condition|(
name|b2b_bar_num
operator|==
name|NTB_B2B_BAR_1
condition|)
name|bar_addr
operator|=
name|peer_addr
operator|->
name|bar2_addr64
expr_stmt|;
elseif|else
if|if
condition|(
name|b2b_bar_num
operator|==
name|NTB_B2B_BAR_2
operator|&&
operator|!
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
name|bar_addr
operator|=
name|peer_addr
operator|->
name|bar4_addr64
expr_stmt|;
elseif|else
if|if
condition|(
name|b2b_bar_num
operator|==
name|NTB_B2B_BAR_2
condition|)
name|bar_addr
operator|=
name|peer_addr
operator|->
name|bar4_addr32
expr_stmt|;
elseif|else
if|if
condition|(
name|b2b_bar_num
operator|==
name|NTB_B2B_BAR_3
condition|)
name|bar_addr
operator|=
name|peer_addr
operator|->
name|bar5_addr32
expr_stmt|;
else|else
name|KASSERT
argument_list|(
name|false
argument_list|,
operator|(
literal|"invalid bar"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * B2B_XLAT_OFFSET is a 64-bit register but can only be written 32 bits 	 * at a time. 	 */
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|XEON_B2B_XLAT_OFFSETL
argument_list|,
name|bar_addr
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|XEON_B2B_XLAT_OFFSETU
argument_list|,
name|bar_addr
operator|>>
literal|32
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|_xeon_link_is_up
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
if|if
condition|(
name|ntb
operator|->
name|conn_type
operator|==
name|NTB_CONN_TRANSPARENT
condition|)
return|return
operator|(
name|true
operator|)
return|;
return|return
operator|(
operator|(
name|ntb
operator|->
name|lnk_sta
operator|&
name|NTB_LINK_STATUS_ACTIVE
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|link_is_up
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_XEON
condition|)
return|return
operator|(
name|_xeon_link_is_up
argument_list|(
name|ntb
argument_list|)
operator|&&
operator|(
name|ntb
operator|->
name|peer_msix_good
operator|||
operator|!
name|HAS_FEATURE
argument_list|(
name|NTB_SB01BASE_LOCKUP
argument_list|)
operator|)
operator|)
return|;
name|KASSERT
argument_list|(
name|ntb
operator|->
name|type
operator|==
name|NTB_ATOM
argument_list|,
operator|(
literal|"ntb type"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|ntb
operator|->
name|ntb_ctl
operator|&
name|ATOM_CNTL_LINK_DOWN
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|atom_link_is_err
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|KASSERT
argument_list|(
name|ntb
operator|->
name|type
operator|==
name|NTB_ATOM
argument_list|,
operator|(
literal|"ntb type"
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ATOM_LTSSMSTATEJMP_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|ATOM_LTSSMSTATEJMP_FORCEDETECT
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|status
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ATOM_IBSTERRRCRVSTS0_OFFSET
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|status
operator|&
name|ATOM_IBIST_ERR_OFLOW
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Atom does not have link status interrupt, poll on that platform */
end_comment

begin_function
specifier|static
name|void
name|atom_link_hb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|arg
decl_stmt|;
name|sbintime_t
name|timo
decl_stmt|,
name|poll_ts
decl_stmt|;
name|timo
operator|=
name|NTB_HB_TIMEOUT
operator|*
name|hz
expr_stmt|;
name|poll_ts
operator|=
name|ntb
operator|->
name|last_ts
operator|+
name|timo
expr_stmt|;
comment|/* 	 * Delay polling the link status if an interrupt was received, unless 	 * the cached link status says the link is down. 	 */
if|if
condition|(
operator|(
name|sbintime_t
operator|)
name|ticks
operator|-
name|poll_ts
operator|<
literal|0
operator|&&
name|link_is_up
argument_list|(
name|ntb
argument_list|)
condition|)
block|{
name|timo
operator|=
name|poll_ts
operator|-
name|ticks
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|ntb_poll_link
argument_list|(
name|ntb
argument_list|)
condition|)
name|ntb_link_event
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|link_is_up
argument_list|(
name|ntb
argument_list|)
operator|&&
name|atom_link_is_err
argument_list|(
name|ntb
argument_list|)
condition|)
block|{
comment|/* Link is down with error, proceed with recovery */
name|callout_reset
argument_list|(
operator|&
name|ntb
operator|->
name|lr_timer
argument_list|,
literal|0
argument_list|,
name|recover_atom_link
argument_list|,
name|ntb
argument_list|)
expr_stmt|;
return|return;
block|}
name|out
label|:
name|callout_reset
argument_list|(
operator|&
name|ntb
operator|->
name|heartbeat_timer
argument_list|,
name|timo
argument_list|,
name|atom_link_hb
argument_list|,
name|ntb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atom_perform_link_restart
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
comment|/* Driver resets the NTB ModPhy lanes - magic! */
name|ntb_reg_write
argument_list|(
literal|1
argument_list|,
name|ATOM_MODPHY_PCSREG6
argument_list|,
literal|0xe0
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|1
argument_list|,
name|ATOM_MODPHY_PCSREG4
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|1
argument_list|,
name|ATOM_MODPHY_PCSREG4
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|1
argument_list|,
name|ATOM_MODPHY_PCSREG6
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
comment|/* Driver waits 100ms to allow the NTB ModPhy to settle */
name|pause
argument_list|(
literal|"ModPhy"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
comment|/* Clear AER Errors, write to clear */
name|status
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ATOM_ERRCORSTS_OFFSET
argument_list|)
expr_stmt|;
name|status
operator|&=
name|PCIM_AER_COR_REPLAY_ROLLOVER
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|ATOM_ERRCORSTS_OFFSET
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Clear unexpected electrical idle event in LTSSM, write to clear */
name|status
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ATOM_LTSSMERRSTS0_OFFSET
argument_list|)
expr_stmt|;
name|status
operator||=
name|ATOM_LTSSMERRSTS0_UNEXPECTEDEI
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|ATOM_LTSSMERRSTS0_OFFSET
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Clear DeSkew Buffer error, write to clear */
name|status
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ATOM_DESKEWSTS_OFFSET
argument_list|)
expr_stmt|;
name|status
operator||=
name|ATOM_DESKEWSTS_DBERR
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|ATOM_DESKEWSTS_OFFSET
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|status
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ATOM_IBSTERRRCRVSTS0_OFFSET
argument_list|)
expr_stmt|;
name|status
operator|&=
name|ATOM_IBIST_ERR_OFLOW
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|ATOM_IBSTERRRCRVSTS0_OFFSET
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Releases the NTB state machine to allow the link to retrain */
name|status
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ATOM_LTSSMSTATEJMP_OFFSET
argument_list|)
expr_stmt|;
name|status
operator|&=
operator|~
name|ATOM_LTSSMSTATEJMP_FORCEDETECT
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|ATOM_LTSSMSTATEJMP_OFFSET
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ntb_set_ctx() - associate a driver context with an ntb device  * @ntb:        NTB device context  * @ctx:        Driver context  * @ctx_ops:    Driver context operations  *  * Associate a driver context and operations with a ntb device.  The context is  * provided by the client driver, and the driver may associate a different  * context with each ntb device.  *  * Return: Zero if the context is associated, otherwise an error number.  */
end_comment

begin_function
name|int
name|ntb_set_ctx
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|struct
name|ntb_ctx_ops
modifier|*
name|ops
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|==
name|NULL
operator|||
name|ops
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ntb
operator|->
name|ctx_ops
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|CTX_LOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|ctx_ops
operator|!=
name|NULL
condition|)
block|{
name|CTX_UNLOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ntb
operator|->
name|ntb_ctx
operator|=
name|ctx
expr_stmt|;
name|ntb
operator|->
name|ctx_ops
operator|=
name|ops
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * It is expected that this will only be used from contexts where the ctx_lock  * is not needed to protect ntb_ctx lifetime.  */
end_comment

begin_function
name|void
modifier|*
name|ntb_get_ctx
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
specifier|const
name|struct
name|ntb_ctx_ops
modifier|*
modifier|*
name|ops
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|ntb
operator|->
name|ntb_ctx
operator|!=
name|NULL
operator|&&
name|ntb
operator|->
name|ctx_ops
operator|!=
name|NULL
argument_list|,
operator|(
literal|"bogus"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ops
operator|!=
name|NULL
condition|)
operator|*
name|ops
operator|=
name|ntb
operator|->
name|ctx_ops
expr_stmt|;
return|return
operator|(
name|ntb
operator|->
name|ntb_ctx
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ntb_clear_ctx() - disassociate any driver context from an ntb device  * @ntb:        NTB device context  *  * Clear any association that may exist between a driver context and the ntb  * device.  */
end_comment

begin_function
name|void
name|ntb_clear_ctx
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|CTX_LOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|ntb_ctx
operator|=
name|NULL
expr_stmt|;
name|ntb
operator|->
name|ctx_ops
operator|=
name|NULL
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ntb_link_event() - notify driver context of a change in link status  * @ntb:        NTB device context  *  * Notify the driver context that the link status may have changed.  The driver  * should call ntb_link_is_up() to get the current status.  */
end_comment

begin_function
name|void
name|ntb_link_event
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|CTX_LOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|ctx_ops
operator|!=
name|NULL
operator|&&
name|ntb
operator|->
name|ctx_ops
operator|->
name|link_event
operator|!=
name|NULL
condition|)
name|ntb
operator|->
name|ctx_ops
operator|->
name|link_event
argument_list|(
name|ntb
operator|->
name|ntb_ctx
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ntb_db_event() - notify driver context of a doorbell event  * @ntb:        NTB device context  * @vector:     Interrupt vector number  *  * Notify the driver context of a doorbell event.  If hardware supports  * multiple interrupt vectors for doorbells, the vector number indicates which  * vector received the interrupt.  The vector number is relative to the first  * vector used for doorbells, starting at zero, and must be less than  * ntb_db_vector_count().  The driver may call ntb_db_read() to check which  * doorbell bits need service, and ntb_db_vector_mask() to determine which of  * those bits are associated with the vector number.  */
end_comment

begin_function
specifier|static
name|void
name|ntb_db_event
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint32_t
name|vec
parameter_list|)
block|{
name|CTX_LOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|ctx_ops
operator|!=
name|NULL
operator|&&
name|ntb
operator|->
name|ctx_ops
operator|->
name|db_event
operator|!=
name|NULL
condition|)
name|ntb
operator|->
name|ctx_ops
operator|->
name|db_event
argument_list|(
name|ntb
operator|->
name|ntb_ctx
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ntb_link_enable() - enable the link on the secondary side of the ntb  * @ntb:        NTB device context  * @max_speed:  The maximum link speed expressed as PCIe generation number[0]  * @max_width:  The maximum link width expressed as the number of PCIe lanes[0]  *  * Enable the link on the secondary side of the ntb.  This can only be done  * from the primary side of the ntb in primary or b2b topology.  The ntb device  * should train the link to its maximum speed and width, or the requested speed  * and width, whichever is smaller, if supported.  *  * Return: Zero on success, otherwise an error number.  *  * [0]: Only NTB_SPEED_AUTO and NTB_WIDTH_AUTO are valid inputs; other speed  *      and width input will be ignored.  */
end_comment

begin_function
name|int
name|ntb_link_enable
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|enum
name|ntb_speed
name|s
name|__unused
parameter_list|,
name|enum
name|ntb_width
name|w
name|__unused
parameter_list|)
block|{
name|uint32_t
name|cntl
decl_stmt|;
name|ntb_printf
argument_list|(
literal|2
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_ATOM
condition|)
block|{
name|pci_write_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|NTB_PPD_OFFSET
argument_list|,
name|ntb
operator|->
name|ppd
operator||
name|ATOM_PPD_INIT_LINK
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ntb
operator|->
name|conn_type
operator|==
name|NTB_CONN_TRANSPARENT
condition|)
block|{
name|ntb_link_event
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cntl
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|ntb_ctl
argument_list|)
expr_stmt|;
name|cntl
operator|&=
operator|~
operator|(
name|NTB_CNTL_LINK_DISABLE
operator||
name|NTB_CNTL_CFG_LOCK
operator|)
expr_stmt|;
name|cntl
operator||=
name|NTB_CNTL_P2S_BAR23_SNOOP
operator||
name|NTB_CNTL_S2P_BAR23_SNOOP
expr_stmt|;
name|cntl
operator||=
name|NTB_CNTL_P2S_BAR4_SNOOP
operator||
name|NTB_CNTL_S2P_BAR4_SNOOP
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
name|cntl
operator||=
name|NTB_CNTL_P2S_BAR5_SNOOP
operator||
name|NTB_CNTL_S2P_BAR5_SNOOP
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|ntb_ctl
argument_list|,
name|cntl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ntb_link_disable() - disable the link on the secondary side of the ntb  * @ntb:        NTB device context  *  * Disable the link on the secondary side of the ntb.  This can only be done  * from the primary side of the ntb in primary or b2b topology.  The ntb device  * should disable the link.  Returning from this call must indicate that a  * barrier has passed, though with no more writes may pass in either direction  * across the link, except if this call returns an error number.  *  * Return: Zero on success, otherwise an error number.  */
end_comment

begin_function
name|int
name|ntb_link_disable
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|uint32_t
name|cntl
decl_stmt|;
name|ntb_printf
argument_list|(
literal|2
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|conn_type
operator|==
name|NTB_CONN_TRANSPARENT
condition|)
block|{
name|ntb_link_event
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cntl
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|ntb_ctl
argument_list|)
expr_stmt|;
name|cntl
operator|&=
operator|~
operator|(
name|NTB_CNTL_P2S_BAR23_SNOOP
operator||
name|NTB_CNTL_S2P_BAR23_SNOOP
operator|)
expr_stmt|;
name|cntl
operator|&=
operator|~
operator|(
name|NTB_CNTL_P2S_BAR4_SNOOP
operator||
name|NTB_CNTL_S2P_BAR4_SNOOP
operator|)
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
name|cntl
operator|&=
operator|~
operator|(
name|NTB_CNTL_P2S_BAR5_SNOOP
operator||
name|NTB_CNTL_S2P_BAR5_SNOOP
operator|)
expr_stmt|;
name|cntl
operator||=
name|NTB_CNTL_LINK_DISABLE
operator||
name|NTB_CNTL_CFG_LOCK
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|ntb_ctl
argument_list|,
name|cntl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|ntb_link_enabled
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|uint32_t
name|cntl
decl_stmt|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_ATOM
condition|)
block|{
name|cntl
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|NTB_PPD_OFFSET
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|cntl
operator|&
name|ATOM_PPD_INIT_LINK
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ntb
operator|->
name|conn_type
operator|==
name|NTB_CONN_TRANSPARENT
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|cntl
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|ntb_ctl
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|cntl
operator|&
name|NTB_CNTL_LINK_DISABLE
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|recover_atom_link
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|arg
decl_stmt|;
name|unsigned
name|speed
decl_stmt|,
name|width
decl_stmt|,
name|oldspeed
decl_stmt|,
name|oldwidth
decl_stmt|;
name|uint32_t
name|status32
decl_stmt|;
name|atom_perform_link_restart
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
comment|/* 	 * There is a potential race between the 2 NTB devices recovering at 	 * the same time.  If the times are the same, the link will not recover 	 * and the driver will be stuck in this loop forever.  Add a random 	 * interval to the recovery time to prevent this race. 	 */
name|status32
operator|=
name|arc4random
argument_list|()
operator|%
name|ATOM_LINK_RECOVERY_TIME
expr_stmt|;
name|pause
argument_list|(
literal|"Link"
argument_list|,
operator|(
name|ATOM_LINK_RECOVERY_TIME
operator|+
name|status32
operator|)
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom_link_is_err
argument_list|(
name|ntb
argument_list|)
condition|)
goto|goto
name|retry
goto|;
name|status32
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|ntb_ctl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status32
operator|&
name|ATOM_CNTL_LINK_DOWN
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|status32
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|lnk_sta
argument_list|)
expr_stmt|;
name|width
operator|=
name|NTB_LNK_STA_WIDTH
argument_list|(
name|status32
argument_list|)
expr_stmt|;
name|speed
operator|=
name|status32
operator|&
name|NTB_LINK_SPEED_MASK
expr_stmt|;
name|oldwidth
operator|=
name|NTB_LNK_STA_WIDTH
argument_list|(
name|ntb
operator|->
name|lnk_sta
argument_list|)
expr_stmt|;
name|oldspeed
operator|=
name|ntb
operator|->
name|lnk_sta
operator|&
name|NTB_LINK_SPEED_MASK
expr_stmt|;
if|if
condition|(
name|oldwidth
operator|!=
name|width
operator|||
name|oldspeed
operator|!=
name|speed
condition|)
goto|goto
name|retry
goto|;
name|out
label|:
name|callout_reset
argument_list|(
operator|&
name|ntb
operator|->
name|heartbeat_timer
argument_list|,
name|NTB_HB_TIMEOUT
operator|*
name|hz
argument_list|,
name|atom_link_hb
argument_list|,
name|ntb
argument_list|)
expr_stmt|;
return|return;
name|retry
label|:
name|callout_reset
argument_list|(
operator|&
name|ntb
operator|->
name|lr_timer
argument_list|,
name|NTB_HB_TIMEOUT
operator|*
name|hz
argument_list|,
name|recover_atom_link
argument_list|,
name|ntb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Polls the HW link status register(s); returns true if something has changed.  */
end_comment

begin_function
specifier|static
name|bool
name|ntb_poll_link
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|uint32_t
name|ntb_cntl
decl_stmt|;
name|uint16_t
name|reg_val
decl_stmt|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_ATOM
condition|)
block|{
name|ntb_cntl
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|ntb_ctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb_cntl
operator|==
name|ntb
operator|->
name|ntb_ctl
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|ntb
operator|->
name|ntb_ctl
operator|=
name|ntb_cntl
expr_stmt|;
name|ntb
operator|->
name|lnk_sta
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|lnk_sta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|db_iowrite_raw
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|self_reg
operator|->
name|db_bell
argument_list|,
name|ntb
operator|->
name|db_link_mask
argument_list|)
expr_stmt|;
name|reg_val
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|lnk_sta
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_val
operator|==
name|ntb
operator|->
name|lnk_sta
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|ntb
operator|->
name|lnk_sta
operator|=
name|reg_val
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SB01BASE_LOCKUP
argument_list|)
condition|)
block|{
if|if
condition|(
name|_xeon_link_is_up
argument_list|(
name|ntb
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ntb
operator|->
name|peer_msix_good
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|ntb
operator|->
name|peer_msix_work
argument_list|,
literal|0
argument_list|,
name|ntb_exchange_msix
argument_list|,
name|ntb
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
block|}
else|else
block|{
name|ntb
operator|->
name|peer_msix_good
operator|=
name|false
expr_stmt|;
name|ntb
operator|->
name|peer_msix_done
operator|=
name|false
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|enum
name|ntb_speed
name|ntb_link_sta_speed
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|link_is_up
argument_list|(
name|ntb
argument_list|)
condition|)
return|return
operator|(
name|NTB_SPEED_NONE
operator|)
return|;
return|return
operator|(
name|ntb
operator|->
name|lnk_sta
operator|&
name|NTB_LINK_SPEED_MASK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|enum
name|ntb_width
name|ntb_link_sta_width
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|link_is_up
argument_list|(
name|ntb
argument_list|)
condition|)
return|return
operator|(
name|NTB_WIDTH_NONE
operator|)
return|;
return|return
operator|(
name|NTB_LNK_STA_WIDTH
argument_list|(
name|ntb
operator|->
name|lnk_sta
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_ntb
argument_list|,
name|OID_AUTO
argument_list|,
name|debug_info
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Driver state, statistics, and HW registers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NTB_REGSZ_MASK
value|(3ul<< 30)
end_define

begin_define
define|#
directive|define
name|NTB_REG_64
value|(1ul<< 30)
end_define

begin_define
define|#
directive|define
name|NTB_REG_32
value|(2ul<< 30)
end_define

begin_define
define|#
directive|define
name|NTB_REG_16
value|(3ul<< 30)
end_define

begin_define
define|#
directive|define
name|NTB_REG_8
value|(0ul<< 30)
end_define

begin_define
define|#
directive|define
name|NTB_DB_READ
value|(1ul<< 29)
end_define

begin_define
define|#
directive|define
name|NTB_PCI_REG
value|(1ul<< 28)
end_define

begin_define
define|#
directive|define
name|NTB_REGFLAGS_MASK
value|(NTB_REGSZ_MASK | NTB_DB_READ | NTB_PCI_REG)
end_define

begin_function
specifier|static
name|void
name|ntb_sysctl_init
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|struct
name|sysctl_oid_list
modifier|*
name|globals
decl_stmt|,
modifier|*
name|tree_par
decl_stmt|,
modifier|*
name|regpar
decl_stmt|,
modifier|*
name|statpar
decl_stmt|,
modifier|*
name|errpar
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
decl_stmt|,
modifier|*
name|tmptree
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|ntb
operator|->
name|device
argument_list|)
expr_stmt|;
name|globals
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|ntb
operator|->
name|device
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|globals
argument_list|,
name|OID_AUTO
argument_list|,
literal|"link_status"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_STRING
argument_list|,
name|ntb
argument_list|,
literal|0
argument_list|,
name|sysctl_handle_link_status_human
argument_list|,
literal|"A"
argument_list|,
literal|"Link status (human readable)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|globals
argument_list|,
name|OID_AUTO
argument_list|,
literal|"active"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_UINT
argument_list|,
name|ntb
argument_list|,
literal|0
argument_list|,
name|sysctl_handle_link_status
argument_list|,
literal|"IU"
argument_list|,
literal|"Link status (1=active, 0=inactive)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|globals
argument_list|,
name|OID_AUTO
argument_list|,
literal|"admin_up"
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLTYPE_UINT
argument_list|,
name|ntb
argument_list|,
literal|0
argument_list|,
name|sysctl_handle_link_admin
argument_list|,
literal|"IU"
argument_list|,
literal|"Set/get interface status (1=UP, 0=DOWN)"
argument_list|)
expr_stmt|;
name|tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|globals
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug_info"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Driver state, statistics, and HW registers"
argument_list|)
expr_stmt|;
name|tree_par
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|tree_par
argument_list|,
name|OID_AUTO
argument_list|,
literal|"conn_type"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ntb
operator|->
name|conn_type
argument_list|,
literal|0
argument_list|,
literal|"0 - Transparent; 1 - B2B; 2 - Root Port"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|tree_par
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dev_type"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ntb
operator|->
name|dev_type
argument_list|,
literal|0
argument_list|,
literal|"0 - USD; 1 - DSD"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|tree_par
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ppd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ntb
operator|->
name|ppd
argument_list|,
literal|0
argument_list|,
literal|"Raw PPD register (cached)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|b2b_mw_idx
operator|!=
name|B2B_MW_DISABLED
condition|)
block|{
ifdef|#
directive|ifdef
name|notyet
name|SYSCTL_ADD_U8
argument_list|(
name|ctx
argument_list|,
name|tree_par
argument_list|,
name|OID_AUTO
argument_list|,
literal|"b2b_idx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ntb
operator|->
name|b2b_mw_idx
argument_list|,
literal|0
argument_list|,
literal|"Index of the MW used for B2B remote register access"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|tree_par
argument_list|,
name|OID_AUTO
argument_list|,
literal|"b2b_off"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ntb
operator|->
name|b2b_off
argument_list|,
literal|"If non-zero, offset of B2B register region in shared MW"
argument_list|)
expr_stmt|;
block|}
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|tree_par
argument_list|,
name|OID_AUTO
argument_list|,
literal|"features"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_STRING
argument_list|,
name|ntb
argument_list|,
literal|0
argument_list|,
name|sysctl_handle_features
argument_list|,
literal|"A"
argument_list|,
literal|"Features/errata of this NTB device"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|tree_par
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ntb_ctl"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|ntb
operator|->
name|ntb_ctl
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"NTB CTL register (cached)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|tree_par
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lnk_sta"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|ntb
operator|->
name|lnk_sta
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"LNK STA register (cached)"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|SYSCTL_ADD_U8
argument_list|(
name|ctx
argument_list|,
name|tree_par
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mw_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ntb
operator|->
name|mw_count
argument_list|,
literal|0
argument_list|,
literal|"MW count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U8
argument_list|(
name|ctx
argument_list|,
name|tree_par
argument_list|,
name|OID_AUTO
argument_list|,
literal|"spad_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ntb
operator|->
name|spad_count
argument_list|,
literal|0
argument_list|,
literal|"Scratchpad count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U8
argument_list|(
name|ctx
argument_list|,
name|tree_par
argument_list|,
name|OID_AUTO
argument_list|,
literal|"db_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ntb
operator|->
name|db_count
argument_list|,
literal|0
argument_list|,
literal|"Doorbell count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U8
argument_list|(
name|ctx
argument_list|,
name|tree_par
argument_list|,
name|OID_AUTO
argument_list|,
literal|"db_vec_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ntb
operator|->
name|db_vec_count
argument_list|,
literal|0
argument_list|,
literal|"Doorbell vector count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U8
argument_list|(
name|ctx
argument_list|,
name|tree_par
argument_list|,
name|OID_AUTO
argument_list|,
literal|"db_vec_shift"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ntb
operator|->
name|db_vec_shift
argument_list|,
literal|0
argument_list|,
literal|"Doorbell vector shift"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|tree_par
argument_list|,
name|OID_AUTO
argument_list|,
literal|"db_valid_mask"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ntb
operator|->
name|db_valid_mask
argument_list|,
literal|"Doorbell valid mask"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|tree_par
argument_list|,
name|OID_AUTO
argument_list|,
literal|"db_link_mask"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ntb
operator|->
name|db_link_mask
argument_list|,
literal|"Doorbell link mask"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|tree_par
argument_list|,
name|OID_AUTO
argument_list|,
literal|"db_mask"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ntb
operator|->
name|db_mask
argument_list|,
literal|"Doorbell mask (cached)"
argument_list|)
expr_stmt|;
name|tmptree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|tree_par
argument_list|,
name|OID_AUTO
argument_list|,
literal|"registers"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Raw HW registers (big-endian)"
argument_list|)
expr_stmt|;
name|regpar
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tmptree
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ntbcntl"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_32
operator||
name|ntb
operator|->
name|reg
operator|->
name|ntb_ctl
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"IU"
argument_list|,
literal|"NTB Control register"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lnkcap"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_32
operator||
literal|0x19c
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"IU"
argument_list|,
literal|"NTB Link Capabilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lnkcon"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_32
operator||
literal|0x1a0
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"IU"
argument_list|,
literal|"NTB Link Control register"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"db_mask"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_64
operator||
name|NTB_DB_READ
operator||
name|ntb
operator|->
name|self_reg
operator|->
name|db_mask
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"QU"
argument_list|,
literal|"Doorbell mask register"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"db_bell"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_64
operator||
name|NTB_DB_READ
operator||
name|ntb
operator|->
name|self_reg
operator|->
name|db_bell
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"QU"
argument_list|,
literal|"Doorbell register"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"incoming_xlat23"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_64
operator||
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar2_xlat
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"QU"
argument_list|,
literal|"Incoming XLAT23 register"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"incoming_xlat4"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_32
operator||
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar4_xlat
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"IU"
argument_list|,
literal|"Incoming XLAT4 register"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"incoming_xlat5"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_32
operator||
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar5_xlat
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"IU"
argument_list|,
literal|"Incoming XLAT5 register"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"incoming_xlat45"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_64
operator||
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar4_xlat
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"QU"
argument_list|,
literal|"Incoming XLAT45 register"
argument_list|)
expr_stmt|;
block|}
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"incoming_lmt23"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_64
operator||
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar2_limit
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"QU"
argument_list|,
literal|"Incoming LMT23 register"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"incoming_lmt4"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_32
operator||
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar4_limit
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"IU"
argument_list|,
literal|"Incoming LMT4 register"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"incoming_lmt5"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_32
operator||
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar5_limit
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"IU"
argument_list|,
literal|"Incoming LMT5 register"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"incoming_lmt45"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_64
operator||
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar4_limit
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"QU"
argument_list|,
literal|"Incoming LMT45 register"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_ATOM
condition|)
return|return;
name|tmptree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xeon_stats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Xeon HW statistics"
argument_list|)
expr_stmt|;
name|statpar
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tmptree
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|statpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"upstream_mem_miss"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_16
operator||
name|XEON_USMEMMISS_OFFSET
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"SU"
argument_list|,
literal|"Upstream Memory Miss"
argument_list|)
expr_stmt|;
name|tmptree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xeon_hw_err"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Xeon HW errors"
argument_list|)
expr_stmt|;
name|errpar
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tmptree
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ppd"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_8
operator||
name|NTB_PCI_REG
operator||
name|NTB_PPD_OFFSET
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"CU"
argument_list|,
literal|"PPD"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pbar23_sz"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_8
operator||
name|NTB_PCI_REG
operator||
name|XEON_PBAR23SZ_OFFSET
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"CU"
argument_list|,
literal|"PBAR23 SZ (log2)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pbar4_sz"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_8
operator||
name|NTB_PCI_REG
operator||
name|XEON_PBAR4SZ_OFFSET
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"CU"
argument_list|,
literal|"PBAR4 SZ (log2)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pbar5_sz"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_8
operator||
name|NTB_PCI_REG
operator||
name|XEON_PBAR5SZ_OFFSET
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"CU"
argument_list|,
literal|"PBAR5 SZ (log2)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sbar23_sz"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_8
operator||
name|NTB_PCI_REG
operator||
name|XEON_SBAR23SZ_OFFSET
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"CU"
argument_list|,
literal|"SBAR23 SZ (log2)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sbar4_sz"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_8
operator||
name|NTB_PCI_REG
operator||
name|XEON_SBAR4SZ_OFFSET
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"CU"
argument_list|,
literal|"SBAR4 SZ (log2)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sbar5_sz"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_8
operator||
name|NTB_PCI_REG
operator||
name|XEON_SBAR5SZ_OFFSET
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"CU"
argument_list|,
literal|"SBAR5 SZ (log2)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"devsts"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_16
operator||
name|NTB_PCI_REG
operator||
name|XEON_DEVSTS_OFFSET
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"SU"
argument_list|,
literal|"DEVSTS"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lnksts"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_16
operator||
name|NTB_PCI_REG
operator||
name|XEON_LINK_STATUS_OFFSET
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"SU"
argument_list|,
literal|"LNKSTS"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"slnksts"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_16
operator||
name|NTB_PCI_REG
operator||
name|XEON_SLINK_STATUS_OFFSET
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"SU"
argument_list|,
literal|"SLNKSTS"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|errpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"uncerrsts"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_32
operator||
name|NTB_PCI_REG
operator||
name|XEON_UNCERRSTS_OFFSET
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"IU"
argument_list|,
literal|"UNCERRSTS"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|errpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"corerrsts"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_32
operator||
name|NTB_PCI_REG
operator||
name|XEON_CORERRSTS_OFFSET
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"IU"
argument_list|,
literal|"CORERRSTS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|conn_type
operator|!=
name|NTB_CONN_B2B
condition|)
return|return;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"outgoing_xlat23"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_64
operator||
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_1
index|]
operator|.
name|pbarxlat_off
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"QU"
argument_list|,
literal|"Outgoing XLAT23 register"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"outgoing_xlat4"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_32
operator||
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_2
index|]
operator|.
name|pbarxlat_off
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"IU"
argument_list|,
literal|"Outgoing XLAT4 register"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"outgoing_xlat5"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_32
operator||
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_3
index|]
operator|.
name|pbarxlat_off
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"IU"
argument_list|,
literal|"Outgoing XLAT5 register"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"outgoing_xlat45"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_64
operator||
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_2
index|]
operator|.
name|pbarxlat_off
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"QU"
argument_list|,
literal|"Outgoing XLAT45 register"
argument_list|)
expr_stmt|;
block|}
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"outgoing_lmt23"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_64
operator||
name|XEON_PBAR2LMT_OFFSET
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"QU"
argument_list|,
literal|"Outgoing LMT23 register"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"outgoing_lmt4"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_32
operator||
name|XEON_PBAR4LMT_OFFSET
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"IU"
argument_list|,
literal|"Outgoing LMT4 register"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"outgoing_lmt5"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_32
operator||
name|XEON_PBAR5LMT_OFFSET
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"IU"
argument_list|,
literal|"Outgoing LMT5 register"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"outgoing_lmt45"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_64
operator||
name|XEON_PBAR4LMT_OFFSET
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"QU"
argument_list|,
literal|"Outgoing LMT45 register"
argument_list|)
expr_stmt|;
block|}
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sbar01_base"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_64
operator||
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar0_base
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"QU"
argument_list|,
literal|"Secondary BAR01 base register"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sbar23_base"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_64
operator||
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar2_base
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"QU"
argument_list|,
literal|"Secondary BAR23 base register"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sbar4_base"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_32
operator||
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar4_base
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"IU"
argument_list|,
literal|"Secondary BAR4 base register"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sbar5_base"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_32
operator||
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar5_base
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"IU"
argument_list|,
literal|"Secondary BAR5 base register"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|regpar
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sbar45_base"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|ntb
argument_list|,
name|NTB_REG_64
operator||
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar4_base
argument_list|,
name|sysctl_handle_register
argument_list|,
literal|"QU"
argument_list|,
literal|"Secondary BAR45 base register"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_handle_features
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sbuf_new_for_sysctl
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%b"
argument_list|,
name|ntb
operator|->
name|features
argument_list|,
name|NTB_FEATURES_STR
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_handle_link_admin
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|arg1
decl_stmt|;
name|unsigned
name|old
decl_stmt|,
name|new
decl_stmt|;
name|int
name|error
decl_stmt|;
name|old
operator|=
name|ntb_link_enabled
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|old
argument_list|,
sizeof|sizeof
argument_list|(
name|old
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
operator|&
name|new
argument_list|,
sizeof|sizeof
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ntb_printf
argument_list|(
literal|0
argument_list|,
literal|"Admin set interface state to '%sabled'\n"
argument_list|,
operator|(
name|new
operator|!=
literal|0
operator|)
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
literal|0
condition|)
name|error
operator|=
name|ntb_link_enable
argument_list|(
name|ntb
argument_list|,
name|NTB_SPEED_AUTO
argument_list|,
name|NTB_WIDTH_AUTO
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ntb_link_disable
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_handle_link_status_human
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|arg1
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|enum
name|ntb_speed
name|speed
decl_stmt|;
name|enum
name|ntb_width
name|width
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sbuf_new_for_sysctl
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
literal|32
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb_link_is_up
argument_list|(
name|ntb
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|width
argument_list|)
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"up / PCIe Gen %u / Width x%u"
argument_list|,
operator|(
name|unsigned
operator|)
name|speed
argument_list|,
operator|(
name|unsigned
operator|)
name|width
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"down"
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_handle_link_status
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|arg1
decl_stmt|;
name|unsigned
name|res
decl_stmt|;
name|int
name|error
decl_stmt|;
name|res
operator|=
name|ntb_link_is_up
argument_list|(
name|ntb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|res
argument_list|,
sizeof|sizeof
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_handle_register
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
decl_stmt|;
specifier|const
name|void
modifier|*
name|outp
decl_stmt|;
name|uintptr_t
name|sz
decl_stmt|;
name|uint64_t
name|umv
decl_stmt|;
name|char
name|be
index|[
sizeof|sizeof
argument_list|(
name|umv
argument_list|)
index|]
decl_stmt|;
name|size_t
name|outsz
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|bool
name|db
decl_stmt|,
name|pci
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ntb
operator|=
name|arg1
expr_stmt|;
name|reg
operator|=
name|arg2
operator|&
operator|~
name|NTB_REGFLAGS_MASK
expr_stmt|;
name|sz
operator|=
name|arg2
operator|&
name|NTB_REGSZ_MASK
expr_stmt|;
name|db
operator|=
operator|(
name|arg2
operator|&
name|NTB_DB_READ
operator|)
operator|!=
literal|0
expr_stmt|;
name|pci
operator|=
operator|(
name|arg2
operator|&
name|NTB_PCI_REG
operator|)
operator|!=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|db
operator|&&
name|pci
operator|)
argument_list|,
operator|(
literal|"bogus"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
condition|)
block|{
name|KASSERT
argument_list|(
name|sz
operator|==
name|NTB_REG_64
argument_list|,
operator|(
literal|"bogus"
operator|)
argument_list|)
expr_stmt|;
name|umv
operator|=
name|db_ioread
argument_list|(
name|ntb
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|outsz
operator|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|sz
condition|)
block|{
case|case
name|NTB_REG_64
case|:
if|if
condition|(
name|pci
condition|)
name|umv
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|reg
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
name|umv
operator|=
name|ntb_reg_read
argument_list|(
literal|8
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|outsz
operator|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|NTB_REG_32
case|:
if|if
condition|(
name|pci
condition|)
name|umv
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|umv
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|outsz
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|NTB_REG_16
case|:
if|if
condition|(
name|pci
condition|)
name|umv
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|reg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
name|umv
operator|=
name|ntb_reg_read
argument_list|(
literal|2
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|outsz
operator|=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|NTB_REG_8
case|:
if|if
condition|(
name|pci
condition|)
name|umv
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|umv
operator|=
name|ntb_reg_read
argument_list|(
literal|1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|outsz
operator|=
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"bogus"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Encode bigendian so that sysctl -x is legible. */
name|be64enc
argument_list|(
name|be
argument_list|,
name|umv
argument_list|)
expr_stmt|;
name|outp
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|be
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|umv
argument_list|)
operator|-
name|outsz
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|outp
argument_list|,
name|outsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|ntb_user_mw_to_idx
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|uidx
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ntb
operator|->
name|b2b_mw_idx
operator|!=
name|B2B_MW_DISABLED
operator|&&
name|ntb
operator|->
name|b2b_off
operator|==
literal|0
operator|&&
name|uidx
operator|>=
name|ntb
operator|->
name|b2b_mw_idx
operator|)
operator|||
operator|(
name|ntb
operator|->
name|msix_mw_idx
operator|!=
name|B2B_MW_DISABLED
operator|&&
name|uidx
operator|>=
name|ntb
operator|->
name|msix_mw_idx
operator|)
condition|)
name|uidx
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ntb
operator|->
name|b2b_mw_idx
operator|!=
name|B2B_MW_DISABLED
operator|&&
name|ntb
operator|->
name|b2b_off
operator|==
literal|0
operator|&&
name|uidx
operator|>=
name|ntb
operator|->
name|b2b_mw_idx
operator|)
operator|&&
operator|(
name|ntb
operator|->
name|msix_mw_idx
operator|!=
name|B2B_MW_DISABLED
operator|&&
name|uidx
operator|>=
name|ntb
operator|->
name|msix_mw_idx
operator|)
condition|)
name|uidx
operator|++
expr_stmt|;
return|return
operator|(
name|uidx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_exchange_msix
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|ntb
operator|=
name|ctx
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|peer_msix_good
condition|)
goto|goto
name|msix_good
goto|;
if|if
condition|(
name|ntb
operator|->
name|peer_msix_done
condition|)
goto|goto
name|msix_done
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XEON_NONLINK_DB_MSIX_BITS
condition|;
name|i
operator|++
control|)
block|{
name|ntb_peer_spad_write
argument_list|(
name|ntb
argument_list|,
name|NTB_MSIX_DATA0
operator|+
name|i
argument_list|,
name|ntb
operator|->
name|msix_data
index|[
name|i
index|]
operator|.
name|nmd_data
argument_list|)
expr_stmt|;
name|ntb_peer_spad_write
argument_list|(
name|ntb
argument_list|,
name|NTB_MSIX_OFS0
operator|+
name|i
argument_list|,
name|ntb
operator|->
name|msix_data
index|[
name|i
index|]
operator|.
name|nmd_ofs
operator|-
name|ntb
operator|->
name|msix_xlat
argument_list|)
expr_stmt|;
block|}
name|ntb_peer_spad_write
argument_list|(
name|ntb
argument_list|,
name|NTB_MSIX_GUARD
argument_list|,
name|NTB_MSIX_VER_GUARD
argument_list|)
expr_stmt|;
name|ntb_spad_read
argument_list|(
name|ntb
argument_list|,
name|NTB_MSIX_GUARD
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|NTB_MSIX_VER_GUARD
condition|)
goto|goto
name|reschedule
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XEON_NONLINK_DB_MSIX_BITS
condition|;
name|i
operator|++
control|)
block|{
name|ntb_spad_read
argument_list|(
name|ntb
argument_list|,
name|NTB_MSIX_DATA0
operator|+
name|i
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|ntb_printf
argument_list|(
literal|2
argument_list|,
literal|"remote MSIX data(%u): 0x%x\n"
argument_list|,
name|i
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|peer_msix_data
index|[
name|i
index|]
operator|.
name|nmd_data
operator|=
name|val
expr_stmt|;
name|ntb_spad_read
argument_list|(
name|ntb
argument_list|,
name|NTB_MSIX_OFS0
operator|+
name|i
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|ntb_printf
argument_list|(
literal|2
argument_list|,
literal|"remote MSIX addr(%u): 0x%x\n"
argument_list|,
name|i
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|peer_msix_data
index|[
name|i
index|]
operator|.
name|nmd_ofs
operator|=
name|val
expr_stmt|;
block|}
name|ntb
operator|->
name|peer_msix_done
operator|=
name|true
expr_stmt|;
name|msix_done
label|:
name|ntb_peer_spad_write
argument_list|(
name|ntb
argument_list|,
name|NTB_MSIX_DONE
argument_list|,
name|NTB_MSIX_RECEIVED
argument_list|)
expr_stmt|;
name|ntb_spad_read
argument_list|(
name|ntb
argument_list|,
name|NTB_MSIX_DONE
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|NTB_MSIX_RECEIVED
condition|)
goto|goto
name|reschedule
goto|;
name|ntb
operator|->
name|peer_msix_good
operator|=
name|true
expr_stmt|;
comment|/* Give peer time to see our NTB_MSIX_RECEIVED. */
goto|goto
name|reschedule
goto|;
name|msix_good
label|:
name|ntb_poll_link
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|ntb_link_event
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
return|return;
name|reschedule
label|:
name|ntb
operator|->
name|lnk_sta
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|lnk_sta
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|_xeon_link_is_up
argument_list|(
name|ntb
argument_list|)
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|ntb
operator|->
name|peer_msix_work
argument_list|,
name|hz
operator|*
operator|(
name|ntb
operator|->
name|peer_msix_good
condition|?
literal|2
else|:
literal|1
operator|)
operator|/
literal|100
argument_list|,
name|ntb_exchange_msix
argument_list|,
name|ntb
argument_list|)
expr_stmt|;
block|}
else|else
name|ntb_spad_clear
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Public API to the rest of the OS  */
end_comment

begin_comment
comment|/**  * ntb_get_max_spads() - get the total scratch regs usable  * @ntb: pointer to ntb_softc instance  *  * This function returns the max 32bit scratchpad registers usable by the  * upper layer.  *  * RETURNS: total number of scratch pad registers available  */
end_comment

begin_function
name|uint8_t
name|ntb_get_max_spads
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
return|return
operator|(
name|ntb
operator|->
name|spad_count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ntb_mw_count() - Get the number of memory windows available for KPI  * consumers.  *  * (Excludes any MW wholly reserved for register access.)  */
end_comment

begin_function
name|uint8_t
name|ntb_mw_count
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|uint8_t
name|res
decl_stmt|;
name|res
operator|=
name|ntb
operator|->
name|mw_count
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|b2b_mw_idx
operator|!=
name|B2B_MW_DISABLED
operator|&&
name|ntb
operator|->
name|b2b_off
operator|==
literal|0
condition|)
name|res
operator|--
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|msix_mw_idx
operator|!=
name|B2B_MW_DISABLED
condition|)
name|res
operator|--
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_spad_write() - write to the secondary scratchpad register  * @ntb: pointer to ntb_softc instance  * @idx: index to the scratchpad register, 0 based  * @val: the data value to put into the register  *  * This function allows writing of a 32bit value to the indexed scratchpad  * register. The register resides on the secondary (external) side.  *  * RETURNS: An appropriate ERRNO error value on error, or zero for success.  */
end_comment

begin_function
name|int
name|ntb_spad_write
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>=
name|ntb
operator|->
name|spad_count
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|self_reg
operator|->
name|spad
operator|+
name|idx
operator|*
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Zeros the local scratchpad.  */
end_comment

begin_function
name|void
name|ntb_spad_clear
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntb
operator|->
name|spad_count
condition|;
name|i
operator|++
control|)
name|ntb_spad_write
argument_list|(
name|ntb
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ntb_spad_read() - read from the primary scratchpad register  * @ntb: pointer to ntb_softc instance  * @idx: index to scratchpad register, 0 based  * @val: pointer to 32bit integer for storing the register value  *  * This function allows reading of the 32bit scratchpad register on  * the primary (internal) side.  *  * RETURNS: An appropriate ERRNO error value on error, or zero for success.  */
end_comment

begin_function
name|int
name|ntb_spad_read
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>=
name|ntb
operator|->
name|spad_count
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|val
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|self_reg
operator|->
name|spad
operator|+
name|idx
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_peer_spad_write() - write to the secondary scratchpad register  * @ntb: pointer to ntb_softc instance  * @idx: index to the scratchpad register, 0 based  * @val: the data value to put into the register  *  * This function allows writing of a 32bit value to the indexed scratchpad  * register. The register resides on the secondary (external) side.  *  * RETURNS: An appropriate ERRNO error value on error, or zero for success.  */
end_comment

begin_function
name|int
name|ntb_peer_spad_write
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>=
name|ntb
operator|->
name|spad_count
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SDOORBELL_LOCKUP
argument_list|)
condition|)
name|ntb_mw_write
argument_list|(
literal|4
argument_list|,
name|XEON_SPAD_OFFSET
operator|+
name|idx
operator|*
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|peer_reg
operator|->
name|spad
operator|+
name|idx
operator|*
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_peer_spad_read() - read from the primary scratchpad register  * @ntb: pointer to ntb_softc instance  * @idx: index to scratchpad register, 0 based  * @val: pointer to 32bit integer for storing the register value  *  * This function allows reading of the 32bit scratchpad register on  * the primary (internal) side.  *  * RETURNS: An appropriate ERRNO error value on error, or zero for success.  */
end_comment

begin_function
name|int
name|ntb_peer_spad_read
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>=
name|ntb
operator|->
name|spad_count
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SDOORBELL_LOCKUP
argument_list|)
condition|)
operator|*
name|val
operator|=
name|ntb_mw_read
argument_list|(
literal|4
argument_list|,
name|XEON_SPAD_OFFSET
operator|+
name|idx
operator|*
literal|4
argument_list|)
expr_stmt|;
else|else
operator|*
name|val
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|peer_reg
operator|->
name|spad
operator|+
name|idx
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ntb_mw_get_range() - get the range of a memory window  * @ntb:        NTB device context  * @idx:        Memory window number  * @base:       OUT - the base address for mapping the memory window  * @size:       OUT - the size for mapping the memory window  * @align:      OUT - the base alignment for translating the memory window  * @align_size: OUT - the size alignment for translating the memory window  *  * Get the range of a memory window.  NULL may be given for any output  * parameter if the value is not needed.  The base and size may be used for  * mapping the memory window, to access the peer memory.  The alignment and  * size may be used for translating the memory window, for the peer to access  * memory on the local system.  *  * Return: Zero on success, otherwise an error number.  */
end_comment

begin_function
name|int
name|ntb_mw_get_range
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|mw_idx
parameter_list|,
name|vm_paddr_t
modifier|*
name|base
parameter_list|,
name|caddr_t
modifier|*
name|vbase
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|size_t
modifier|*
name|align
parameter_list|,
name|size_t
modifier|*
name|align_size
parameter_list|,
name|bus_addr_t
modifier|*
name|plimit
parameter_list|)
block|{
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
decl_stmt|;
name|bus_addr_t
name|limit
decl_stmt|;
name|size_t
name|bar_b2b_off
decl_stmt|;
name|enum
name|ntb_bar
name|bar_num
decl_stmt|;
if|if
condition|(
name|mw_idx
operator|>=
name|ntb_mw_count
argument_list|(
name|ntb
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mw_idx
operator|=
name|ntb_user_mw_to_idx
argument_list|(
name|ntb
argument_list|,
name|mw_idx
argument_list|)
expr_stmt|;
name|bar_num
operator|=
name|ntb_mw_to_bar
argument_list|(
name|ntb
argument_list|,
name|mw_idx
argument_list|)
expr_stmt|;
name|bar
operator|=
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|bar_num
index|]
expr_stmt|;
name|bar_b2b_off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mw_idx
operator|==
name|ntb
operator|->
name|b2b_mw_idx
condition|)
block|{
name|KASSERT
argument_list|(
name|ntb
operator|->
name|b2b_off
operator|!=
literal|0
argument_list|,
operator|(
literal|"user shouldn't get non-shared b2b mw"
operator|)
argument_list|)
expr_stmt|;
name|bar_b2b_off
operator|=
name|ntb
operator|->
name|b2b_off
expr_stmt|;
block|}
if|if
condition|(
name|bar_is_64bit
argument_list|(
name|ntb
argument_list|,
name|bar_num
argument_list|)
condition|)
name|limit
operator|=
name|BUS_SPACE_MAXADDR
expr_stmt|;
else|else
name|limit
operator|=
name|BUS_SPACE_MAXADDR_32BIT
expr_stmt|;
if|if
condition|(
name|base
operator|!=
name|NULL
condition|)
operator|*
name|base
operator|=
name|bar
operator|->
name|pbase
operator|+
name|bar_b2b_off
expr_stmt|;
if|if
condition|(
name|vbase
operator|!=
name|NULL
condition|)
operator|*
name|vbase
operator|=
name|bar
operator|->
name|vbase
operator|+
name|bar_b2b_off
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|NULL
condition|)
operator|*
name|size
operator|=
name|bar
operator|->
name|size
operator|-
name|bar_b2b_off
expr_stmt|;
if|if
condition|(
name|align
operator|!=
name|NULL
condition|)
operator|*
name|align
operator|=
name|bar
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|align_size
operator|!=
name|NULL
condition|)
operator|*
name|align_size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|plimit
operator|!=
name|NULL
condition|)
operator|*
name|plimit
operator|=
name|limit
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ntb_mw_set_trans() - set the translation of a memory window  * @ntb:        NTB device context  * @idx:        Memory window number  * @addr:       The dma address local memory to expose to the peer  * @size:       The size of the local memory to expose to the peer  *  * Set the translation of a memory window.  The peer may access local memory  * through the window starting at the address, up to the size.  The address  * must be aligned to the alignment specified by ntb_mw_get_range().  The size  * must be aligned to the size alignment specified by ntb_mw_get_range().  The  * address must be below the plimit specified by ntb_mw_get_range() (i.e. for  * 32-bit BARs).  *  * Return: Zero on success, otherwise an error number.  */
end_comment

begin_function
name|int
name|ntb_mw_set_trans
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|idx
parameter_list|,
name|bus_addr_t
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
decl_stmt|;
name|uint64_t
name|base
decl_stmt|,
name|limit
decl_stmt|,
name|reg_val
decl_stmt|;
name|size_t
name|bar_size
decl_stmt|,
name|mw_size
decl_stmt|;
name|uint32_t
name|base_reg
decl_stmt|,
name|xlat_reg
decl_stmt|,
name|limit_reg
decl_stmt|;
name|enum
name|ntb_bar
name|bar_num
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
name|ntb_mw_count
argument_list|(
name|ntb
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|idx
operator|=
name|ntb_user_mw_to_idx
argument_list|(
name|ntb
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|bar_num
operator|=
name|ntb_mw_to_bar
argument_list|(
name|ntb
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|bar
operator|=
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|bar_num
index|]
expr_stmt|;
name|bar_size
operator|=
name|bar
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|ntb
operator|->
name|b2b_mw_idx
condition|)
name|mw_size
operator|=
name|bar_size
operator|-
name|ntb
operator|->
name|b2b_off
expr_stmt|;
else|else
name|mw_size
operator|=
name|bar_size
expr_stmt|;
comment|/* Hardware requires that addr is aligned to bar size */
if|if
condition|(
operator|(
name|addr
operator|&
operator|(
name|bar_size
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|size
operator|>
name|mw_size
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bar_get_xlat_params
argument_list|(
name|ntb
argument_list|,
name|bar_num
argument_list|,
operator|&
name|base_reg
argument_list|,
operator|&
name|xlat_reg
argument_list|,
operator|&
name|limit_reg
argument_list|)
expr_stmt|;
name|limit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bar_is_64bit
argument_list|(
name|ntb
argument_list|,
name|bar_num
argument_list|)
condition|)
block|{
name|base
operator|=
name|ntb_reg_read
argument_list|(
literal|8
argument_list|,
name|base_reg
argument_list|)
operator|&
name|BAR_HIGH_MASK
expr_stmt|;
if|if
condition|(
name|limit_reg
operator|!=
literal|0
operator|&&
name|size
operator|!=
name|mw_size
condition|)
name|limit
operator|=
name|base
operator|+
name|size
expr_stmt|;
comment|/* Set and verify translation address */
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|xlat_reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|reg_val
operator|=
name|ntb_reg_read
argument_list|(
literal|8
argument_list|,
name|xlat_reg
argument_list|)
operator|&
name|BAR_HIGH_MASK
expr_stmt|;
if|if
condition|(
name|reg_val
operator|!=
name|addr
condition|)
block|{
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|xlat_reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Set and verify the limit */
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|limit_reg
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|reg_val
operator|=
name|ntb_reg_read
argument_list|(
literal|8
argument_list|,
name|limit_reg
argument_list|)
operator|&
name|BAR_HIGH_MASK
expr_stmt|;
if|if
condition|(
name|reg_val
operator|!=
name|limit
condition|)
block|{
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|limit_reg
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|xlat_reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Configure 32-bit (split) BAR MW */
if|if
condition|(
operator|(
name|addr
operator|&
name|UINT32_MAX
operator|)
operator|!=
name|addr
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|addr
operator|+
name|size
operator|)
operator|&
name|UINT32_MAX
operator|)
operator|!=
operator|(
name|addr
operator|+
name|size
operator|)
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
name|base
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|base_reg
argument_list|)
operator|&
name|BAR_HIGH_MASK
expr_stmt|;
if|if
condition|(
name|limit_reg
operator|!=
literal|0
operator|&&
name|size
operator|!=
name|mw_size
condition|)
name|limit
operator|=
name|base
operator|+
name|size
expr_stmt|;
comment|/* Set and verify translation address */
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|xlat_reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|reg_val
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|xlat_reg
argument_list|)
operator|&
name|BAR_HIGH_MASK
expr_stmt|;
if|if
condition|(
name|reg_val
operator|!=
name|addr
condition|)
block|{
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|xlat_reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Set and verify the limit */
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|limit_reg
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|reg_val
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|limit_reg
argument_list|)
operator|&
name|BAR_HIGH_MASK
expr_stmt|;
if|if
condition|(
name|reg_val
operator|!=
name|limit
condition|)
block|{
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|limit_reg
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|xlat_reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ntb_mw_clear_trans() - clear the translation of a memory window  * @ntb:	NTB device context  * @idx:	Memory window number  *  * Clear the translation of a memory window.  The peer may no longer access  * local memory through the window.  *  * Return: Zero on success, otherwise an error number.  */
end_comment

begin_function
name|int
name|ntb_mw_clear_trans
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|mw_idx
parameter_list|)
block|{
return|return
operator|(
name|ntb_mw_set_trans
argument_list|(
name|ntb
argument_list|,
name|mw_idx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ntb_mw_get_wc - Get the write-combine status of a memory window  *  * Returns:  Zero on success, setting *wc; otherwise an error number (e.g. if  * idx is an invalid memory window).  *  * Mode is a VM_MEMATTR_* type.  */
end_comment

begin_function
name|int
name|ntb_mw_get_wc
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|idx
parameter_list|,
name|vm_memattr_t
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
name|ntb_mw_count
argument_list|(
name|ntb
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|idx
operator|=
name|ntb_user_mw_to_idx
argument_list|(
name|ntb
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|bar
operator|=
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|ntb_mw_to_bar
argument_list|(
name|ntb
argument_list|,
name|idx
argument_list|)
index|]
expr_stmt|;
operator|*
name|mode
operator|=
name|bar
operator|->
name|map_mode
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ntb_mw_set_wc - Set the write-combine status of a memory window  *  * If 'mode' matches the current status, this does nothing and succeeds.  Mode  * is a VM_MEMATTR_* type.  *  * Returns:  Zero on success, setting the caching attribute on the virtual  * mapping of the BAR; otherwise an error number (e.g. if idx is an invalid  * memory window, or if changing the caching attribute fails).  */
end_comment

begin_function
name|int
name|ntb_mw_set_wc
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|idx
parameter_list|,
name|vm_memattr_t
name|mode
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>=
name|ntb_mw_count
argument_list|(
name|ntb
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|idx
operator|=
name|ntb_user_mw_to_idx
argument_list|(
name|ntb
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ntb_mw_set_wc_internal
argument_list|(
name|ntb
argument_list|,
name|idx
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_mw_set_wc_internal
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|idx
parameter_list|,
name|vm_memattr_t
name|mode
parameter_list|)
block|{
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|bar
operator|=
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|ntb_mw_to_bar
argument_list|(
name|ntb
argument_list|,
name|idx
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|bar
operator|->
name|map_mode
operator|==
name|mode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rc
operator|=
name|pmap_change_attr
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bar
operator|->
name|vbase
argument_list|,
name|bar
operator|->
name|size
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|bar
operator|->
name|map_mode
operator|=
name|mode
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_peer_db_set() - Set the doorbell on the secondary/external side  * @ntb: pointer to ntb_softc instance  * @bit: doorbell bits to ring  *  * This function allows triggering of a doorbell on the secondary/external  * side that will initiate an interrupt on the remote host  */
end_comment

begin_function
name|void
name|ntb_peer_db_set
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint64_t
name|bit
parameter_list|)
block|{
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SB01BASE_LOCKUP
argument_list|)
condition|)
block|{
name|struct
name|ntb_pci_bar_info
modifier|*
name|lapic
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|lapic
operator|=
name|ntb
operator|->
name|peer_lapic_bar
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XEON_NONLINK_DB_MSIX_BITS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bit
operator|&
name|ntb_db_vector_mask
argument_list|(
name|ntb
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|bus_space_write_4
argument_list|(
name|lapic
operator|->
name|pci_bus_tag
argument_list|,
name|lapic
operator|->
name|pci_bus_handle
argument_list|,
name|ntb
operator|->
name|peer_msix_data
index|[
name|i
index|]
operator|.
name|nmd_ofs
argument_list|,
name|ntb
operator|->
name|peer_msix_data
index|[
name|i
index|]
operator|.
name|nmd_data
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SDOORBELL_LOCKUP
argument_list|)
condition|)
block|{
name|ntb_mw_write
argument_list|(
literal|2
argument_list|,
name|XEON_PDOORBELL_OFFSET
argument_list|,
name|bit
argument_list|)
expr_stmt|;
return|return;
block|}
name|db_iowrite
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|peer_reg
operator|->
name|db_bell
argument_list|,
name|bit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ntb_get_peer_db_addr() - Return the address of the remote doorbell register,  * as well as the size of the register (via *sz_out).  *  * This function allows a caller using I/OAT DMA to chain the remote doorbell  * ring to its memory window write.  *  * Note that writing the peer doorbell via a memory window will *not* generate  * an interrupt on the remote host; that must be done seperately.  */
end_comment

begin_function
name|bus_addr_t
name|ntb_get_peer_db_addr
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|vm_size_t
modifier|*
name|sz_out
parameter_list|)
block|{
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
decl_stmt|;
name|uint64_t
name|regoff
decl_stmt|;
name|KASSERT
argument_list|(
name|sz_out
operator|!=
name|NULL
argument_list|,
operator|(
literal|"must be non-NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HAS_FEATURE
argument_list|(
name|NTB_SDOORBELL_LOCKUP
argument_list|)
condition|)
block|{
name|bar
operator|=
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|NTB_CONFIG_BAR
index|]
expr_stmt|;
name|regoff
operator|=
name|ntb
operator|->
name|peer_reg
operator|->
name|db_bell
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|ntb
operator|->
name|b2b_mw_idx
operator|!=
name|B2B_MW_DISABLED
argument_list|,
operator|(
literal|"invalid b2b idx"
operator|)
argument_list|)
expr_stmt|;
name|bar
operator|=
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|ntb_mw_to_bar
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|b2b_mw_idx
argument_list|)
index|]
expr_stmt|;
name|regoff
operator|=
name|XEON_PDOORBELL_OFFSET
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|bar
operator|->
name|pci_bus_tag
operator|!=
name|X86_BUS_SPACE_IO
argument_list|,
operator|(
literal|"uh oh"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|sz_out
operator|=
name|ntb
operator|->
name|reg
operator|->
name|db_size
expr_stmt|;
comment|/* HACK: Specific to current x86 bus implementation. */
return|return
operator|(
operator|(
name|uint64_t
operator|)
name|bar
operator|->
name|pci_bus_handle
operator|+
name|regoff
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ntb_db_valid_mask() - get a mask of doorbell bits supported by the ntb  * @ntb:	NTB device context  *  * Hardware may support different number or arrangement of doorbell bits.  *  * Return: A mask of doorbell bits supported by the ntb.  */
end_comment

begin_function
name|uint64_t
name|ntb_db_valid_mask
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
return|return
operator|(
name|ntb
operator|->
name|db_valid_mask
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ntb_db_vector_mask() - get a mask of doorbell bits serviced by a vector  * @ntb:	NTB device context  * @vector:	Doorbell vector number  *  * Each interrupt vector may have a different number or arrangement of bits.  *  * Return: A mask of doorbell bits serviced by a vector.  */
end_comment

begin_function
name|uint64_t
name|ntb_db_vector_mask
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint32_t
name|vector
parameter_list|)
block|{
if|if
condition|(
name|vector
operator|>
name|ntb
operator|->
name|db_vec_count
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ntb
operator|->
name|db_valid_mask
operator|&
name|ntb_vec_mask
argument_list|(
name|ntb
argument_list|,
name|vector
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_link_is_up() - get the current ntb link state  * @ntb:        NTB device context  * @speed:      OUT - The link speed expressed as PCIe generation number  * @width:      OUT - The link width expressed as the number of PCIe lanes  *  * RETURNS: true or false based on the hardware link state  */
end_comment

begin_function
name|bool
name|ntb_link_is_up
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|enum
name|ntb_speed
modifier|*
name|speed
parameter_list|,
name|enum
name|ntb_width
modifier|*
name|width
parameter_list|)
block|{
if|if
condition|(
name|speed
operator|!=
name|NULL
condition|)
operator|*
name|speed
operator|=
name|ntb_link_sta_speed
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|!=
name|NULL
condition|)
operator|*
name|width
operator|=
name|ntb_link_sta_width
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
return|return
operator|(
name|link_is_up
argument_list|(
name|ntb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_bar_parameters
parameter_list|(
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
parameter_list|)
block|{
name|bar
operator|->
name|pci_bus_tag
operator|=
name|rman_get_bustag
argument_list|(
name|bar
operator|->
name|pci_resource
argument_list|)
expr_stmt|;
name|bar
operator|->
name|pci_bus_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|bar
operator|->
name|pci_resource
argument_list|)
expr_stmt|;
name|bar
operator|->
name|pbase
operator|=
name|rman_get_start
argument_list|(
name|bar
operator|->
name|pci_resource
argument_list|)
expr_stmt|;
name|bar
operator|->
name|size
operator|=
name|rman_get_size
argument_list|(
name|bar
operator|->
name|pci_resource
argument_list|)
expr_stmt|;
name|bar
operator|->
name|vbase
operator|=
name|rman_get_virtual
argument_list|(
name|bar
operator|->
name|pci_resource
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|device_t
name|ntb_get_device
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
return|return
operator|(
name|ntb
operator|->
name|device
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Export HW-specific errata information. */
end_comment

begin_function
name|bool
name|ntb_has_feature
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint32_t
name|feature
parameter_list|)
block|{
return|return
operator|(
name|HAS_FEATURE
argument_list|(
name|feature
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

