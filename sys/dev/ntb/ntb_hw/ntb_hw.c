begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 2013 Intel Corporation  * Copyright (C) 2015 EMC Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|"ntb_regs.h"
end_include

begin_include
include|#
directive|include
file|"ntb_hw.h"
end_include

begin_comment
comment|/*  * The Non-Transparent Bridge (NTB) is a device on some Intel processors that  * allows you to connect two systems using a PCI-e link.  *  * This module contains the hardware abstraction layer for the NTB. It allows  * you to send and recieve interrupts, map the memory windows and send and  * receive messages in the scratch-pad registers.  *  * NOTE: Much of the code in this module is shared with Linux. Any patches may  * be picked up and redistributed in Linux with a dual GPL/BSD license.  */
end_comment

begin_define
define|#
directive|define
name|MAX_MSIX_INTERRUPTS
value|MAX(XEON_DB_COUNT, SOC_DB_COUNT)
end_define

begin_define
define|#
directive|define
name|NTB_HB_TIMEOUT
value|1
end_define

begin_comment
comment|/* second */
end_comment

begin_define
define|#
directive|define
name|SOC_LINK_RECOVERY_TIME
value|500
end_define

begin_comment
comment|/* ms */
end_comment

begin_define
define|#
directive|define
name|DEVICE2SOFTC
parameter_list|(
name|dev
parameter_list|)
value|((struct ntb_softc *) device_get_softc(dev))
end_define

begin_enum
enum|enum
name|ntb_device_type
block|{
name|NTB_XEON
block|,
name|NTB_SOC
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ntb_bar
block|{
name|NTB_CONFIG_BAR
init|=
literal|0
block|,
name|NTB_B2B_BAR_1
block|,
name|NTB_B2B_BAR_2
block|,
name|NTB_B2B_BAR_3
block|,
name|NTB_MAX_BARS
block|}
enum|;
end_enum

begin_comment
comment|/* Device features and workarounds */
end_comment

begin_define
define|#
directive|define
name|HAS_FEATURE
parameter_list|(
name|feature
parameter_list|)
define|\
value|((ntb->features& (feature)) != 0)
end_define

begin_struct
struct|struct
name|ntb_hw_info
block|{
name|uint32_t
name|device_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
name|enum
name|ntb_device_type
name|type
decl_stmt|;
name|uint32_t
name|features
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_pci_bar_info
block|{
name|bus_space_tag_t
name|pci_bus_tag
decl_stmt|;
name|bus_space_handle_t
name|pci_bus_handle
decl_stmt|;
name|int
name|pci_resource_id
decl_stmt|;
name|struct
name|resource
modifier|*
name|pci_resource
decl_stmt|;
name|vm_paddr_t
name|pbase
decl_stmt|;
name|void
modifier|*
name|vbase
decl_stmt|;
name|u_long
name|size
decl_stmt|;
comment|/* Configuration register offsets */
name|uint32_t
name|psz_off
decl_stmt|;
name|uint32_t
name|ssz_off
decl_stmt|;
name|uint32_t
name|sbarbase_off
decl_stmt|;
name|uint32_t
name|sbarlmt_off
decl_stmt|;
name|uint32_t
name|pbarxlat_off
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_int_info
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|void
modifier|*
name|tag
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_db_cb
block|{
name|ntb_db_callback
name|callback
decl_stmt|;
name|unsigned
name|int
name|db_num
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|struct
name|ntb_softc
modifier|*
name|ntb
decl_stmt|;
name|struct
name|callout
name|irq_work
decl_stmt|;
name|bool
name|reserved
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_reg
block|{
name|uint32_t
name|ntb_ctl
decl_stmt|;
name|uint32_t
name|lnk_sta
decl_stmt|;
name|uint8_t
name|db_size
decl_stmt|;
name|unsigned
name|mw_bar
index|[
name|NTB_MAX_BARS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_alt_reg
block|{
name|uint32_t
name|db_bell
decl_stmt|;
name|uint32_t
name|db_mask
decl_stmt|;
name|uint32_t
name|spad
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_xlat_reg
block|{
name|uint64_t
name|bar0_base
decl_stmt|;
name|uint64_t
name|bar2_xlat
decl_stmt|;
name|uint64_t
name|bar2_limit
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_b2b_addr
block|{
name|uint64_t
name|bar0_addr
decl_stmt|;
name|uint64_t
name|bar2_addr64
decl_stmt|;
name|uint64_t
name|bar4_addr64
decl_stmt|;
name|uint64_t
name|bar4_addr32
decl_stmt|;
name|uint64_t
name|bar5_addr32
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_softc
block|{
name|device_t
name|device
decl_stmt|;
name|enum
name|ntb_device_type
name|type
decl_stmt|;
name|uint64_t
name|features
decl_stmt|;
name|struct
name|ntb_pci_bar_info
name|bar_info
index|[
name|NTB_MAX_BARS
index|]
decl_stmt|;
name|struct
name|ntb_int_info
name|int_info
index|[
name|MAX_MSIX_INTERRUPTS
index|]
decl_stmt|;
name|uint32_t
name|allocated_interrupts
decl_stmt|;
name|struct
name|callout
name|heartbeat_timer
decl_stmt|;
name|struct
name|callout
name|lr_timer
decl_stmt|;
name|void
modifier|*
name|ntb_transport
decl_stmt|;
name|ntb_event_callback
name|event_cb
decl_stmt|;
name|struct
name|ntb_db_cb
modifier|*
name|db_cb
decl_stmt|;
name|uint8_t
name|max_cbs
decl_stmt|;
struct|struct
block|{
name|uint32_t
name|ldb
decl_stmt|;
name|uint32_t
name|ldb_mask
decl_stmt|;
name|uint32_t
name|bar4_xlat
decl_stmt|;
name|uint32_t
name|bar5_xlat
decl_stmt|;
name|uint32_t
name|spad_local
decl_stmt|;
name|uint32_t
name|spci_cmd
decl_stmt|;
block|}
name|reg_ofs
struct|;
name|uint32_t
name|ppd
decl_stmt|;
name|uint8_t
name|conn_type
decl_stmt|;
name|uint8_t
name|dev_type
decl_stmt|;
name|uint8_t
name|link_status
decl_stmt|;
name|uint8_t
name|link_width
decl_stmt|;
name|uint8_t
name|link_speed
decl_stmt|;
comment|/* Offset of peer bar0 in B2B BAR */
name|uint64_t
name|b2b_off
decl_stmt|;
comment|/* Memory window used to access peer bar0 */
define|#
directive|define
name|B2B_MW_DISABLED
value|UINT8_MAX
name|uint8_t
name|b2b_mw_idx
decl_stmt|;
name|uint8_t
name|mw_count
decl_stmt|;
name|uint8_t
name|spad_count
decl_stmt|;
name|uint8_t
name|db_count
decl_stmt|;
name|uint8_t
name|db_vec_count
decl_stmt|;
name|uint8_t
name|db_vec_shift
decl_stmt|;
comment|/* Protects local DB mask and (h). */
define|#
directive|define
name|HW_LOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_lock_spin(&(sc)->db_mask_lock)
define|#
directive|define
name|HW_UNLOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_unlock_spin(&(sc)->db_mask_lock)
define|#
directive|define
name|HW_ASSERT
parameter_list|(
name|sc
parameter_list|,
name|f
parameter_list|)
value|mtx_assert(&(sc)->db_mask_lock, (f))
name|struct
name|mtx
name|db_mask_lock
decl_stmt|;
name|uint32_t
name|ntb_ctl
decl_stmt|;
comment|/* (h) - SOC only */
name|uint32_t
name|lnk_sta
decl_stmt|;
comment|/* (h) - SOC only */
name|uint64_t
name|db_valid_mask
decl_stmt|;
name|uint64_t
name|db_link_mask
decl_stmt|;
name|uint64_t
name|db_mask
decl_stmt|;
comment|/* (h) */
name|int
name|last_ts
decl_stmt|;
comment|/* ticks @ last irq */
specifier|const
name|struct
name|ntb_reg
modifier|*
name|reg
decl_stmt|;
specifier|const
name|struct
name|ntb_alt_reg
modifier|*
name|self_reg
decl_stmt|;
specifier|const
name|struct
name|ntb_alt_reg
modifier|*
name|peer_reg
decl_stmt|;
specifier|const
name|struct
name|ntb_xlat_reg
modifier|*
name|xlat_reg
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_function
specifier|static
name|__inline
name|uint64_t
name|bus_space_read_8
parameter_list|(
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
name|handle
parameter_list|,
name|bus_size_t
name|offset
parameter_list|)
block|{
return|return
operator|(
name|bus_space_read_4
argument_list|(
name|tag
argument_list|,
name|handle
argument_list|,
name|offset
argument_list|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|bus_space_read_4
argument_list|(
name|tag
argument_list|,
name|handle
argument_list|,
name|offset
operator|+
literal|4
argument_list|)
operator|)
operator|<<
literal|32
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|bus_space_write_8
parameter_list|(
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
name|handle
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|bus_space_write_4
argument_list|(
name|tag
argument_list|,
name|handle
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|tag
argument_list|,
name|handle
argument_list|,
name|offset
operator|+
literal|4
argument_list|,
name|val
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ntb_bar_read
parameter_list|(
name|SIZE
parameter_list|,
name|bar
parameter_list|,
name|offset
parameter_list|)
define|\
value|bus_space_read_ ## SIZE (ntb->bar_info[(bar)].pci_bus_tag, \ 	    ntb->bar_info[(bar)].pci_bus_handle, (offset))
end_define

begin_define
define|#
directive|define
name|ntb_bar_write
parameter_list|(
name|SIZE
parameter_list|,
name|bar
parameter_list|,
name|offset
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_space_write_ ## SIZE (ntb->bar_info[(bar)].pci_bus_tag, \ 	    ntb->bar_info[(bar)].pci_bus_handle, (offset), (val))
end_define

begin_define
define|#
directive|define
name|ntb_reg_read
parameter_list|(
name|SIZE
parameter_list|,
name|offset
parameter_list|)
value|ntb_bar_read(SIZE, NTB_CONFIG_BAR, offset)
end_define

begin_define
define|#
directive|define
name|ntb_reg_write
parameter_list|(
name|SIZE
parameter_list|,
name|offset
parameter_list|,
name|val
parameter_list|)
define|\
value|ntb_bar_write(SIZE, NTB_CONFIG_BAR, offset, val)
end_define

begin_define
define|#
directive|define
name|ntb_mw_read
parameter_list|(
name|SIZE
parameter_list|,
name|offset
parameter_list|)
define|\
value|ntb_bar_read(SIZE, ntb_mw_to_bar(ntb, ntb->b2b_mw_idx), offset)
end_define

begin_define
define|#
directive|define
name|ntb_mw_write
parameter_list|(
name|SIZE
parameter_list|,
name|offset
parameter_list|,
name|val
parameter_list|)
define|\
value|ntb_bar_write(SIZE, ntb_mw_to_bar(ntb, ntb->b2b_mw_idx), \ 		offset, val)
end_define

begin_function_decl
specifier|static
name|int
name|ntb_probe
parameter_list|(
name|device_t
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_attach
parameter_list|(
name|device_t
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_detach
parameter_list|(
name|device_t
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|enum
name|ntb_bar
name|ntb_mw_to_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|unsigned
name|mw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_map_pci_bars
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_map_success
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|struct
name|ntb_pci_bar_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|map_mmr_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|map_memory_window_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_unmap_pci_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_remap_msix
parameter_list|(
name|device_t
parameter_list|,
name|uint32_t
name|desired
parameter_list|,
name|uint32_t
name|avail
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_init_isr
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_setup_legacy_interrupt
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_setup_msix
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint32_t
name|num_vectors
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_teardown_interrupts
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|uint64_t
name|ntb_vec_mask
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|uint64_t
name|db_vector
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_irq
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_handle_legacy_interrupt
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_irq_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|uint64_t
name|ntb_db_read
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|uint64_t
name|regoff
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ntb_db_write
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|uint64_t
name|regoff
parameter_list|,
name|uint64_t
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|mask_ldb_interrupt
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|unmask_ldb_interrupt
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ntb_db_set_mask
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|uint64_t
name|bits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ntb_db_clear_mask
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|uint64_t
name|bits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_create_callbacks
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint32_t
name|num_vectors
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_free_callbacks
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ntb_hw_info
modifier|*
name|ntb_get_device_info
parameter_list|(
name|uint32_t
name|device_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_detect_max_mw
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_detect_xeon
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_detect_soc
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_xeon_init_dev
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_soc_init_dev
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_teardown_xeon
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|configure_soc_secondary_side_bars
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xeon_reset_sbar_size
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|enum
name|ntb_bar
name|idx
parameter_list|,
name|enum
name|ntb_bar
name|regbar
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xeon_set_sbar_base_and_limit
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|uint64_t
name|base_addr
parameter_list|,
name|enum
name|ntb_bar
name|idx
parameter_list|,
name|enum
name|ntb_bar
name|regbar
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xeon_set_pbar_xlat
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
name|uint64_t
name|base_addr
parameter_list|,
name|enum
name|ntb_bar
name|idx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xeon_setup_b2b_mw
parameter_list|(
name|struct
name|ntb_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|ntb_b2b_addr
modifier|*
name|addr
parameter_list|,
specifier|const
name|struct
name|ntb_b2b_addr
modifier|*
name|peer_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|soc_link_hb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_handle_link_event
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|int
name|link_state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_link_disable
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_link_enable
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|recover_soc_link
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_poll_link
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_bar_parameters
parameter_list|(
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|ntb_hw_info
name|pci_ids
index|[]
init|=
block|{
block|{
literal|0x0C4E8086
block|,
literal|"Atom Processor S1200 NTB Primary B2B"
block|,
name|NTB_SOC
block|,
literal|0
block|}
block|,
comment|/* XXX: PS/SS IDs left out until they are supported. */
block|{
literal|0x37258086
block|,
literal|"JSF Xeon C35xx/C55xx Non-Transparent Bridge B2B"
block|,
name|NTB_XEON
block|,
name|NTB_SDOORBELL_LOCKUP
operator||
name|NTB_B2BDOORBELL_BIT14
block|}
block|,
block|{
literal|0x3C0D8086
block|,
literal|"SNB Xeon E5/Core i7 Non-Transparent Bridge B2B"
block|,
name|NTB_XEON
block|,
name|NTB_SDOORBELL_LOCKUP
operator||
name|NTB_B2BDOORBELL_BIT14
block|}
block|,
block|{
literal|0x0E0D8086
block|,
literal|"IVT Xeon E5 V2 Non-Transparent Bridge B2B"
block|,
name|NTB_XEON
block|,
name|NTB_SDOORBELL_LOCKUP
operator||
name|NTB_B2BDOORBELL_BIT14
operator||
name|NTB_SB01BASE_LOCKUP
operator||
name|NTB_BAR_SIZE_4K
block|}
block|,
block|{
literal|0x2F0D8086
block|,
literal|"HSX Xeon E5 V3 Non-Transparent Bridge B2B"
block|,
name|NTB_XEON
block|,
name|NTB_SDOORBELL_LOCKUP
operator||
name|NTB_B2BDOORBELL_BIT14
operator||
name|NTB_SB01BASE_LOCKUP
block|}
block|,
block|{
literal|0x6F0D8086
block|,
literal|"BDX Xeon E5 V4 Non-Transparent Bridge B2B"
block|,
name|NTB_XEON
block|,
name|NTB_SDOORBELL_LOCKUP
operator||
name|NTB_B2BDOORBELL_BIT14
operator||
name|NTB_SB01BASE_LOCKUP
block|}
block|,
block|{
literal|0x00000000
block|,
name|NULL
block|,
name|NTB_SOC
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ntb_reg
name|soc_reg
init|=
block|{
operator|.
name|ntb_ctl
operator|=
name|SOC_NTBCNTL_OFFSET
block|,
operator|.
name|lnk_sta
operator|=
name|SOC_LINK_STATUS_OFFSET
block|,
operator|.
name|db_size
operator|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
block|,
operator|.
name|mw_bar
operator|=
block|{
name|NTB_B2B_BAR_1
block|,
name|NTB_B2B_BAR_2
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ntb_alt_reg
name|soc_b2b_reg
init|=
block|{
operator|.
name|db_bell
operator|=
name|SOC_B2B_DOORBELL_OFFSET
block|,
operator|.
name|spad
operator|=
name|SOC_B2B_SPAD_OFFSET
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ntb_xlat_reg
name|soc_sec_xlat
init|=
block|{
if|#
directive|if
literal|0
comment|/* "FIXME" says the Linux driver. */
block|.bar0_base = SOC_SBAR0BASE_OFFSET, 	.bar2_limit = SOC_SBAR2LMT_OFFSET,
endif|#
directive|endif
operator|.
name|bar2_xlat
operator|=
name|SOC_SBAR2XLAT_OFFSET
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ntb_reg
name|xeon_reg
init|=
block|{
operator|.
name|ntb_ctl
operator|=
name|XEON_NTBCNTL_OFFSET
block|,
operator|.
name|lnk_sta
operator|=
name|XEON_LINK_STATUS_OFFSET
block|,
operator|.
name|db_size
operator|=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
block|,
operator|.
name|mw_bar
operator|=
block|{
name|NTB_B2B_BAR_1
block|,
name|NTB_B2B_BAR_2
block|,
name|NTB_B2B_BAR_3
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ntb_alt_reg
name|xeon_b2b_reg
init|=
block|{
operator|.
name|db_bell
operator|=
name|XEON_B2B_DOORBELL_OFFSET
block|,
operator|.
name|spad
operator|=
name|XEON_B2B_SPAD_OFFSET
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ntb_xlat_reg
name|xeon_sec_xlat
init|=
block|{
operator|.
name|bar0_base
operator|=
name|XEON_SBAR0BASE_OFFSET
block|,
operator|.
name|bar2_limit
operator|=
name|XEON_SBAR2LMT_OFFSET
block|,
operator|.
name|bar2_xlat
operator|=
name|XEON_SBAR2XLAT_OFFSET
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ntb_b2b_addr
name|xeon_b2b_usd_addr
init|=
block|{
operator|.
name|bar0_addr
operator|=
name|XEON_B2B_BAR0_USD_ADDR
block|,
operator|.
name|bar2_addr64
operator|=
name|XEON_B2B_BAR2_USD_ADDR64
block|,
operator|.
name|bar4_addr64
operator|=
name|XEON_B2B_BAR4_USD_ADDR64
block|,
operator|.
name|bar4_addr32
operator|=
name|XEON_B2B_BAR4_USD_ADDR32
block|,
operator|.
name|bar5_addr32
operator|=
name|XEON_B2B_BAR5_USD_ADDR32
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ntb_b2b_addr
name|xeon_b2b_dsd_addr
init|=
block|{
operator|.
name|bar0_addr
operator|=
name|XEON_B2B_BAR0_DSD_ADDR
block|,
operator|.
name|bar2_addr64
operator|=
name|XEON_B2B_BAR2_DSD_ADDR64
block|,
operator|.
name|bar4_addr64
operator|=
name|XEON_B2B_BAR4_DSD_ADDR64
block|,
operator|.
name|bar4_addr32
operator|=
name|XEON_B2B_BAR4_DSD_ADDR32
block|,
operator|.
name|bar5_addr32
operator|=
name|XEON_B2B_BAR5_DSD_ADDR32
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * OS<-> Driver interface structures  */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NTB
argument_list|,
literal|"ntb_hw"
argument_list|,
literal|"ntb_hw driver memory allocations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|ntb_pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ntb_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ntb_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ntb_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ntb_pci_driver
init|=
block|{
literal|"ntb_hw"
block|,
name|ntb_pci_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ntb_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ntb_hw
argument_list|,
name|pci
argument_list|,
name|ntb_pci_driver
argument_list|,
name|ntb_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ntb_hw
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|ntb
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"NTB sysctls"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * OS<-> Driver linkage functions  */
end_comment

begin_function
specifier|static
name|int
name|ntb_probe
parameter_list|(
name|device_t
name|device
parameter_list|)
block|{
name|struct
name|ntb_hw_info
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ntb_get_device_info
argument_list|(
name|pci_get_devid
argument_list|(
name|device
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|device
argument_list|,
name|p
operator|->
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_attach
parameter_list|(
name|device_t
name|device
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
decl_stmt|;
name|struct
name|ntb_hw_info
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ntb
operator|=
name|DEVICE2SOFTC
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|p
operator|=
name|ntb_get_device_info
argument_list|(
name|pci_get_devid
argument_list|(
name|device
argument_list|)
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|device
operator|=
name|device
expr_stmt|;
name|ntb
operator|->
name|type
operator|=
name|p
operator|->
name|type
expr_stmt|;
name|ntb
operator|->
name|features
operator|=
name|p
operator|->
name|features
expr_stmt|;
name|ntb
operator|->
name|b2b_mw_idx
operator|=
name|B2B_MW_DISABLED
expr_stmt|;
comment|/* Heartbeat timer for NTB_SOC since there is no link interrupt */
name|callout_init
argument_list|(
operator|&
name|ntb
operator|->
name|heartbeat_timer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|ntb
operator|->
name|lr_timer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ntb
operator|->
name|db_mask_lock
argument_list|,
literal|"ntb hw bits"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_SOC
condition|)
name|error
operator|=
name|ntb_detect_soc
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ntb_detect_xeon
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|ntb_detect_max_mw
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|error
operator|=
name|ntb_map_pci_bars
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_SOC
condition|)
name|error
operator|=
name|ntb_soc_init_dev
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ntb_xeon_init_dev
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|ntb_init_isr
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|pci_enable_busmaster
argument_list|(
name|ntb
operator|->
name|device
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|ntb_detach
argument_list|(
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_detach
parameter_list|(
name|device_t
name|device
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
decl_stmt|;
name|ntb
operator|=
name|DEVICE2SOFTC
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|ntb_db_set_mask
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|db_valid_mask
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|ntb
operator|->
name|heartbeat_timer
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|ntb
operator|->
name|lr_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_XEON
condition|)
name|ntb_teardown_xeon
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|ntb_teardown_interrupts
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ntb
operator|->
name|db_mask_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Redetect total MWs so we unmap properly -- in case we lowered the 	 * maximum to work around Xeon errata. 	 */
name|ntb_detect_max_mw
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|ntb_unmap_pci_bar
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Driver internal routines  */
end_comment

begin_function
specifier|static
specifier|inline
name|enum
name|ntb_bar
name|ntb_mw_to_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|mw
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|mw
operator|<
name|ntb
operator|->
name|mw_count
operator|||
operator|(
name|mw
operator|!=
name|B2B_MW_DISABLED
operator|&&
name|mw
operator|==
name|ntb
operator|->
name|b2b_mw_idx
operator|)
argument_list|,
operator|(
literal|"%s: mw:%u> count:%u"
operator|,
name|__func__
operator|,
name|mw
operator|,
operator|(
name|unsigned
operator|)
name|ntb
operator|->
name|mw_count
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ntb
operator|->
name|reg
operator|->
name|mw_bar
index|[
name|mw
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_map_pci_bars
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_CONFIG_BAR
index|]
operator|.
name|pci_resource_id
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|map_mmr_bar
argument_list|(
name|ntb
argument_list|,
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|NTB_CONFIG_BAR
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_1
index|]
operator|.
name|pci_resource_id
operator|=
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|rc
operator|=
name|map_memory_window_bar
argument_list|(
name|ntb
argument_list|,
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_1
index|]
operator|.
name|psz_off
operator|=
name|XEON_PBAR23SZ_OFFSET
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_1
index|]
operator|.
name|ssz_off
operator|=
name|XEON_SBAR23SZ_OFFSET
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_1
index|]
operator|.
name|sbarbase_off
operator|=
name|XEON_SBAR2BASE_OFFSET
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_1
index|]
operator|.
name|sbarlmt_off
operator|=
name|XEON_SBAR2LMT_OFFSET
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_1
index|]
operator|.
name|pbarxlat_off
operator|=
name|XEON_PBAR2XLAT_OFFSET
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_2
index|]
operator|.
name|pci_resource_id
operator|=
name|PCIR_BAR
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* XXX Are shared MW B2Bs write-combining? */
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SDOORBELL_LOCKUP
argument_list|)
operator|&&
operator|!
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
name|rc
operator|=
name|map_mmr_bar
argument_list|(
name|ntb
argument_list|,
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_2
index|]
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|map_memory_window_bar
argument_list|(
name|ntb
argument_list|,
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_2
index|]
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_2
index|]
operator|.
name|psz_off
operator|=
name|XEON_PBAR4SZ_OFFSET
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_2
index|]
operator|.
name|ssz_off
operator|=
name|XEON_SBAR4SZ_OFFSET
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_2
index|]
operator|.
name|sbarbase_off
operator|=
name|XEON_SBAR4BASE_OFFSET
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_2
index|]
operator|.
name|sbarlmt_off
operator|=
name|XEON_SBAR4LMT_OFFSET
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_2
index|]
operator|.
name|pbarxlat_off
operator|=
name|XEON_PBAR4XLAT_OFFSET
expr_stmt|;
if|if
condition|(
operator|!
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_3
index|]
operator|.
name|pci_resource_id
operator|=
name|PCIR_BAR
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SDOORBELL_LOCKUP
argument_list|)
condition|)
name|rc
operator|=
name|map_mmr_bar
argument_list|(
name|ntb
argument_list|,
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_3
index|]
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|map_memory_window_bar
argument_list|(
name|ntb
argument_list|,
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_3
index|]
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_3
index|]
operator|.
name|psz_off
operator|=
name|XEON_PBAR5SZ_OFFSET
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_3
index|]
operator|.
name|ssz_off
operator|=
name|XEON_SBAR5SZ_OFFSET
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_3
index|]
operator|.
name|sbarbase_off
operator|=
name|XEON_SBAR5BASE_OFFSET
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_3
index|]
operator|.
name|sbarlmt_off
operator|=
name|XEON_SBAR5LMT_OFFSET
expr_stmt|;
name|ntb
operator|->
name|bar_info
index|[
name|NTB_B2B_BAR_3
index|]
operator|.
name|pbarxlat_off
operator|=
name|XEON_PBAR5XLAT_OFFSET
expr_stmt|;
name|out
label|:
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"unable to allocate pci resource\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_map_success
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
parameter_list|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Bar size = %lx, v %p, p %p\n"
argument_list|,
name|bar
operator|->
name|size
argument_list|,
name|bar
operator|->
name|vbase
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|bar
operator|->
name|pbase
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|map_mmr_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
parameter_list|)
block|{
name|bar
operator|->
name|pci_resource
operator|=
name|bus_alloc_resource_any
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|bar
operator|->
name|pci_resource_id
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bar
operator|->
name|pci_resource
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|save_bar_parameters
argument_list|(
name|bar
argument_list|)
expr_stmt|;
name|print_map_success
argument_list|(
name|ntb
argument_list|,
name|bar
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|map_memory_window_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|uint8_t
name|bar_size_bits
init|=
literal|0
decl_stmt|;
name|bar
operator|->
name|pci_resource
operator|=
name|bus_alloc_resource_any
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|bar
operator|->
name|pci_resource_id
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bar
operator|->
name|pci_resource
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|save_bar_parameters
argument_list|(
name|bar
argument_list|)
expr_stmt|;
comment|/* 	 * Ivytown NTB BAR sizes are misreported by the hardware due to a 	 * hardware issue. To work around this, query the size it should be 	 * configured to by the device and modify the resource to correspond to 	 * this new size. The BIOS on systems with this problem is required to 	 * provide enough address space to allow the driver to make this change 	 * safely. 	 * 	 * Ideally I could have just specified the size when I allocated the 	 * resource like: 	 *  bus_alloc_resource(ntb->device, 	 *	SYS_RES_MEMORY,&bar->pci_resource_id, 0ul, ~0ul, 	 *	1ul<< bar_size_bits, RF_ACTIVE); 	 * but the PCI driver does not honor the size in this call, so we have 	 * to modify it after the fact. 	 */
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_BAR_SIZE_4K
argument_list|)
condition|)
block|{
if|if
condition|(
name|bar
operator|->
name|pci_resource_id
operator|==
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
condition|)
name|bar_size_bits
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|XEON_PBAR23SZ_OFFSET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|bar_size_bits
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|XEON_PBAR45SZ_OFFSET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bus_adjust_resource
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|bar
operator|->
name|pci_resource
argument_list|,
name|bar
operator|->
name|pbase
argument_list|,
name|bar
operator|->
name|pbase
operator|+
operator|(
literal|1ul
operator|<<
name|bar_size_bits
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"unable to resize bar\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|save_bar_parameters
argument_list|(
name|bar
argument_list|)
expr_stmt|;
block|}
comment|/* Mark bar region as write combining to improve performance. */
name|rc
operator|=
name|pmap_change_attr
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bar
operator|->
name|vbase
argument_list|,
name|bar
operator|->
name|size
argument_list|,
name|VM_MEMATTR_WRITE_COMBINING
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"unable to mark bar as WRITE_COMBINING\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|print_map_success
argument_list|(
name|ntb
argument_list|,
name|bar
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_unmap_pci_bar
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|struct
name|ntb_pci_bar_info
modifier|*
name|current_bar
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTB_MAX_BARS
condition|;
name|i
operator|++
control|)
block|{
name|current_bar
operator|=
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|current_bar
operator|->
name|pci_resource
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|current_bar
operator|->
name|pci_resource_id
argument_list|,
name|current_bar
operator|->
name|pci_resource
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_setup_msix
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint32_t
name|num_vectors
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|int
name|rc
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_vectors
condition|;
name|i
operator|++
control|)
block|{
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|rid
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"bus_alloc_resource failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|tag
operator|=
name|NULL
expr_stmt|;
name|ntb
operator|->
name|allocated_interrupts
operator|++
expr_stmt|;
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_MISC
argument_list|,
name|NULL
argument_list|,
name|handle_irq
argument_list|,
operator|&
name|ntb
operator|->
name|db_cb
index|[
name|i
index|]
argument_list|,
operator|&
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
operator|.
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"bus_setup_intr failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The Linux NTB driver drops from MSI-X to legacy INTx if a unique vector  * cannot be allocated for each MSI-X message.  JHB seems to think remapping  * should be okay.  This tunable should enable us to test that hypothesis  * when someone gets their hands on some Xeon hardware.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ntb_force_remap_mode
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ntb
argument_list|,
name|OID_AUTO
argument_list|,
name|force_remap_mode
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ntb_force_remap_mode
argument_list|,
literal|0
argument_list|,
literal|"If enabled, force MSI-X messages to be remapped"
literal|" to a smaller number of ithreads, even if the desired number are "
literal|"available"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * In case it is NOT ok, give consumers an abort button.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ntb_prefer_intx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ntb
argument_list|,
name|OID_AUTO
argument_list|,
name|prefer_intx_to_remap
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ntb_prefer_intx
argument_list|,
literal|0
argument_list|,
literal|"If enabled, prefer to use legacy INTx mode rather "
literal|"than remapping MSI-X messages over available slots (match Linux driver "
literal|"behavior)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Remap the desired number of MSI-X messages to available ithreads in a simple  * round-robin fashion.  */
end_comment

begin_function
specifier|static
name|int
name|ntb_remap_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint32_t
name|desired
parameter_list|,
name|uint32_t
name|avail
parameter_list|)
block|{
name|u_int
modifier|*
name|vectors
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|ntb_prefer_intx
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|vectors
operator|=
name|malloc
argument_list|(
name|desired
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|vectors
argument_list|)
argument_list|,
name|M_NTB
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|desired
condition|;
name|i
operator|++
control|)
name|vectors
index|[
name|i
index|]
operator|=
operator|(
name|i
operator|%
name|avail
operator|)
operator|+
literal|1
expr_stmt|;
name|rc
operator|=
name|pci_remap_msix
argument_list|(
name|dev
argument_list|,
name|desired
argument_list|,
name|vectors
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vectors
argument_list|,
name|M_NTB
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_init_isr
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|uint32_t
name|desired_vectors
decl_stmt|,
name|num_vectors
decl_stmt|;
name|uint64_t
name|mask
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|ntb
operator|->
name|allocated_interrupts
operator|=
literal|0
expr_stmt|;
name|ntb
operator|->
name|last_ts
operator|=
name|ticks
expr_stmt|;
comment|/* 	 * On SOC, disable all interrupts.  On XEON, disable all but Link 	 * Interrupt.  The rest will be unmasked as callbacks are registered. 	 */
name|mask
operator|=
name|ntb
operator|->
name|db_valid_mask
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_XEON
condition|)
name|mask
operator|&=
operator|~
name|ntb
operator|->
name|db_link_mask
expr_stmt|;
name|ntb_db_set_mask
argument_list|(
name|ntb
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|num_vectors
operator|=
name|desired_vectors
operator|=
name|MIN
argument_list|(
name|pci_msix_count
argument_list|(
name|ntb
operator|->
name|device
argument_list|)
argument_list|,
name|ntb
operator|->
name|db_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|desired_vectors
operator|>=
literal|1
condition|)
block|{
name|rc
operator|=
name|pci_alloc_msix
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
operator|&
name|num_vectors
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb_force_remap_mode
operator|!=
literal|0
operator|&&
name|rc
operator|==
literal|0
operator|&&
name|num_vectors
operator|==
name|desired_vectors
condition|)
name|num_vectors
operator|--
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
operator|&&
name|num_vectors
operator|<
name|desired_vectors
condition|)
block|{
name|rc
operator|=
name|ntb_remap_msix
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|desired_vectors
argument_list|,
name|num_vectors
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|num_vectors
operator|=
name|desired_vectors
expr_stmt|;
else|else
name|pci_release_msi
argument_list|(
name|ntb
operator|->
name|device
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|num_vectors
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|num_vectors
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_XEON
operator|&&
name|num_vectors
operator|<
name|ntb
operator|->
name|db_vec_count
condition|)
block|{
comment|/* 		 * If allocating MSI-X interrupts failed and we're forced to 		 * use legacy INTx anyway, the only limit on individual 		 * callbacks is the number of doorbell bits. 		 */
name|ntb
operator|->
name|db_vec_count
operator|=
literal|1
expr_stmt|;
name|ntb
operator|->
name|db_vec_shift
operator|=
name|ntb
operator|->
name|db_count
expr_stmt|;
name|ntb_create_callbacks
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|db_count
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ntb_setup_legacy_interrupt
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ntb_create_callbacks
argument_list|(
name|ntb
argument_list|,
name|num_vectors
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ntb_setup_msix
argument_list|(
name|ntb
argument_list|,
name|num_vectors
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
operator|&&
name|ntb
operator|->
name|type
operator|==
name|NTB_XEON
condition|)
block|{
comment|/* 			 * Prevent consumers from registering callbacks on the link event irq 			 * slot, from which they will never be called back. 			 */
name|ntb
operator|->
name|db_cb
index|[
name|num_vectors
operator|-
literal|1
index|]
operator|.
name|reserved
operator|=
name|true
expr_stmt|;
name|ntb
operator|->
name|max_cbs
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Error allocating interrupts: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|ntb_free_callbacks
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_setup_legacy_interrupt
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|rid
operator|=
literal|0
expr_stmt|;
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"bus_alloc_resource failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|tag
operator|=
name|NULL
expr_stmt|;
name|ntb
operator|->
name|allocated_interrupts
operator|=
literal|1
expr_stmt|;
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_MISC
argument_list|,
name|NULL
argument_list|,
name|ntb_handle_legacy_interrupt
argument_list|,
name|ntb
argument_list|,
operator|&
name|ntb
operator|->
name|int_info
index|[
literal|0
index|]
operator|.
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"bus_setup_intr failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_teardown_interrupts
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|struct
name|ntb_int_info
modifier|*
name|current_int
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntb
operator|->
name|allocated_interrupts
condition|;
name|i
operator|++
control|)
block|{
name|current_int
operator|=
operator|&
name|ntb
operator|->
name|int_info
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|current_int
operator|->
name|tag
operator|!=
name|NULL
condition|)
name|bus_teardown_intr
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|current_int
operator|->
name|res
argument_list|,
name|current_int
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_int
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rman_get_rid
argument_list|(
name|current_int
operator|->
name|res
argument_list|)
argument_list|,
name|current_int
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
name|ntb_free_callbacks
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|pci_release_msi
argument_list|(
name|ntb
operator|->
name|device
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Doorbell register and mask are 64-bit on SoC, 16-bit on Xeon.  Abstract it  * out to make code clearer.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint64_t
name|ntb_db_read
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint64_t
name|regoff
parameter_list|)
block|{
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_SOC
condition|)
return|return
operator|(
name|ntb_reg_read
argument_list|(
literal|8
argument_list|,
name|regoff
argument_list|)
operator|)
return|;
name|KASSERT
argument_list|(
name|ntb
operator|->
name|type
operator|==
name|NTB_XEON
argument_list|,
operator|(
literal|"bad ntb type"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ntb_reg_read
argument_list|(
literal|2
argument_list|,
name|regoff
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ntb_db_write
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint64_t
name|regoff
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|val
operator|&
operator|~
name|ntb
operator|->
name|db_valid_mask
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Invalid bits 0x%jx (valid: 0x%jx)"
operator|,
name|__func__
operator|,
call|(
name|uintmax_t
call|)
argument_list|(
name|val
operator|&
operator|~
name|ntb
operator|->
name|db_valid_mask
argument_list|)
operator|,
operator|(
name|uintmax_t
operator|)
name|ntb
operator|->
name|db_valid_mask
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regoff
operator|==
name|ntb
operator|->
name|reg_ofs
operator|.
name|ldb_mask
condition|)
name|HW_ASSERT
argument_list|(
name|ntb
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_SOC
condition|)
block|{
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|regoff
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|ntb
operator|->
name|type
operator|==
name|NTB_XEON
argument_list|,
operator|(
literal|"bad ntb type"
operator|)
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|2
argument_list|,
name|regoff
argument_list|,
operator|(
name|uint16_t
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ntb_db_set_mask
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint64_t
name|bits
parameter_list|)
block|{
name|HW_LOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|db_mask
operator||=
name|bits
expr_stmt|;
name|ntb_db_write
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|reg_ofs
operator|.
name|ldb_mask
argument_list|,
name|ntb
operator|->
name|db_mask
argument_list|)
expr_stmt|;
name|HW_UNLOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ntb_db_clear_mask
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint64_t
name|bits
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|bits
operator|&
operator|~
name|ntb
operator|->
name|db_valid_mask
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Invalid bits 0x%jx (valid: 0x%jx)"
operator|,
name|__func__
operator|,
call|(
name|uintmax_t
call|)
argument_list|(
name|bits
operator|&
operator|~
name|ntb
operator|->
name|db_valid_mask
argument_list|)
operator|,
operator|(
name|uintmax_t
operator|)
name|ntb
operator|->
name|db_valid_mask
operator|)
argument_list|)
expr_stmt|;
name|HW_LOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|db_mask
operator|&=
operator|~
name|bits
expr_stmt|;
name|ntb_db_write
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|reg_ofs
operator|.
name|ldb_mask
argument_list|,
name|ntb
operator|->
name|db_mask
argument_list|)
expr_stmt|;
name|HW_UNLOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mask_ldb_interrupt
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|)
block|{
name|uint64_t
name|mask
decl_stmt|;
name|mask
operator|=
literal|1ull
operator|<<
operator|(
name|idx
operator|*
name|ntb
operator|->
name|db_vec_shift
operator|)
expr_stmt|;
name|ntb_db_set_mask
argument_list|(
name|ntb
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|unmask_ldb_interrupt
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|)
block|{
name|uint64_t
name|mask
decl_stmt|;
name|mask
operator|=
literal|1ull
operator|<<
operator|(
name|idx
operator|*
name|ntb
operator|->
name|db_vec_shift
operator|)
expr_stmt|;
name|ntb_db_clear_mask
argument_list|(
name|ntb
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|ntb_vec_mask
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint64_t
name|db_vector
parameter_list|)
block|{
name|uint64_t
name|shift
decl_stmt|,
name|mask
decl_stmt|;
name|shift
operator|=
name|ntb
operator|->
name|db_vec_shift
expr_stmt|;
name|mask
operator|=
operator|(
literal|1ull
operator|<<
name|shift
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|mask
operator|<<
operator|(
name|shift
operator|*
name|db_vector
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_irq
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_db_cb
modifier|*
name|db_cb
init|=
name|arg
decl_stmt|;
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|db_cb
operator|->
name|ntb
decl_stmt|;
name|uint64_t
name|vec_mask
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|ntb
operator|->
name|last_ts
operator|=
name|ticks
expr_stmt|;
name|vec_mask
operator|=
name|ntb_vec_mask
argument_list|(
name|ntb
argument_list|,
name|db_cb
operator|->
name|db_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vec_mask
operator|&
name|ntb
operator|->
name|db_link_mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|ntb_poll_link
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Error determining link status\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|db_cb
operator|->
name|callback
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
name|db_cb
operator|->
name|reserved
argument_list|,
operator|(
literal|"user callback on link event cb"
operator|)
argument_list|)
expr_stmt|;
name|mask_ldb_interrupt
argument_list|(
name|ntb
argument_list|,
name|db_cb
operator|->
name|db_num
argument_list|)
expr_stmt|;
block|}
name|ntb_db_write
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|reg_ofs
operator|.
name|ldb
argument_list|,
name|vec_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_cb
operator|->
name|callback
operator|!=
name|NULL
condition|)
name|callout_reset
argument_list|(
operator|&
name|db_cb
operator|->
name|irq_work
argument_list|,
literal|0
argument_list|,
name|ntb_irq_work
argument_list|,
name|db_cb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_handle_legacy_interrupt
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|arg
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|uint64_t
name|ldb
decl_stmt|;
name|ldb
operator|=
name|ntb_db_read
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|reg_ofs
operator|.
name|ldb
argument_list|)
expr_stmt|;
while|while
condition|(
name|ldb
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|ffs
argument_list|(
name|ldb
argument_list|)
expr_stmt|;
name|ldb
operator|&=
name|ldb
operator|-
literal|1
expr_stmt|;
name|handle_irq
argument_list|(
operator|&
name|ntb
operator|->
name|db_cb
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_create_callbacks
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint32_t
name|num_vectors
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|ntb
operator|->
name|max_cbs
operator|=
name|num_vectors
expr_stmt|;
name|ntb
operator|->
name|db_cb
operator|=
name|malloc
argument_list|(
name|num_vectors
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ntb
operator|->
name|db_cb
argument_list|)
argument_list|,
name|M_NTB
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_vectors
condition|;
name|i
operator|++
control|)
block|{
name|ntb
operator|->
name|db_cb
index|[
name|i
index|]
operator|.
name|db_num
operator|=
name|i
expr_stmt|;
name|ntb
operator|->
name|db_cb
index|[
name|i
index|]
operator|.
name|ntb
operator|=
name|ntb
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_free_callbacks
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|uint8_t
name|i
decl_stmt|;
if|if
condition|(
name|ntb
operator|->
name|db_cb
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntb
operator|->
name|max_cbs
condition|;
name|i
operator|++
control|)
name|ntb_unregister_db_callback
argument_list|(
name|ntb
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ntb
operator|->
name|db_cb
argument_list|,
name|M_NTB
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|db_cb
operator|=
name|NULL
expr_stmt|;
name|ntb
operator|->
name|max_cbs
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ntb_hw_info
modifier|*
name|ntb_get_device_info
parameter_list|(
name|uint32_t
name|device_id
parameter_list|)
block|{
name|struct
name|ntb_hw_info
modifier|*
name|ep
init|=
name|pci_ids
decl_stmt|;
while|while
condition|(
name|ep
operator|->
name|device_id
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|device_id
operator|==
name|device_id
condition|)
return|return
operator|(
name|ep
operator|)
return|;
operator|++
name|ep
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_teardown_xeon
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|ntb_link_disable
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_detect_max_mw
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_SOC
condition|)
block|{
name|ntb
operator|->
name|mw_count
operator|=
name|SOC_MW_COUNT
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
name|ntb
operator|->
name|mw_count
operator|=
name|XEON_HSX_SPLIT_MW_COUNT
expr_stmt|;
else|else
name|ntb
operator|->
name|mw_count
operator|=
name|XEON_SNB_MW_COUNT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_detect_xeon
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|uint8_t
name|ppd
decl_stmt|,
name|conn_type
decl_stmt|;
name|ppd
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|NTB_PPD_OFFSET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|ppd
operator|=
name|ppd
expr_stmt|;
if|if
condition|(
operator|(
name|ppd
operator|&
name|XEON_PPD_DEV_TYPE
operator|)
operator|!=
literal|0
condition|)
name|ntb
operator|->
name|dev_type
operator|=
name|NTB_DEV_USD
expr_stmt|;
else|else
name|ntb
operator|->
name|dev_type
operator|=
name|NTB_DEV_DSD
expr_stmt|;
if|if
condition|(
operator|(
name|ppd
operator|&
name|XEON_PPD_SPLIT_BAR
operator|)
operator|!=
literal|0
condition|)
name|ntb
operator|->
name|features
operator||=
name|NTB_SPLIT_BAR
expr_stmt|;
comment|/* SB01BASE_LOCKUP errata is a superset of SDOORBELL errata */
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SB01BASE_LOCKUP
argument_list|)
condition|)
name|ntb
operator|->
name|features
operator||=
name|NTB_SDOORBELL_LOCKUP
expr_stmt|;
name|conn_type
operator|=
name|ppd
operator|&
name|XEON_PPD_CONN_TYPE
expr_stmt|;
switch|switch
condition|(
name|conn_type
condition|)
block|{
case|case
name|NTB_CONN_B2B
case|:
name|ntb
operator|->
name|conn_type
operator|=
name|conn_type
expr_stmt|;
break|break;
case|case
name|NTB_CONN_RP
case|:
case|case
name|NTB_CONN_TRANSPARENT
case|:
default|default:
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Unsupported connection type: %u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|conn_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_detect_soc
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|uint32_t
name|ppd
decl_stmt|,
name|conn_type
decl_stmt|;
name|ppd
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|NTB_PPD_OFFSET
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|ppd
operator|=
name|ppd
expr_stmt|;
if|if
condition|(
operator|(
name|ppd
operator|&
name|SOC_PPD_DEV_TYPE
operator|)
operator|!=
literal|0
condition|)
name|ntb
operator|->
name|dev_type
operator|=
name|NTB_DEV_DSD
expr_stmt|;
else|else
name|ntb
operator|->
name|dev_type
operator|=
name|NTB_DEV_USD
expr_stmt|;
name|conn_type
operator|=
operator|(
name|ppd
operator|&
name|SOC_PPD_CONN_TYPE
operator|)
operator|>>
literal|8
expr_stmt|;
switch|switch
condition|(
name|conn_type
condition|)
block|{
case|case
name|NTB_CONN_B2B
case|:
name|ntb
operator|->
name|conn_type
operator|=
name|conn_type
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Unsupported NTB configuration\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_xeon_init_dev
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|ldb
operator|=
name|XEON_PDOORBELL_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|ldb_mask
operator|=
name|XEON_PDBMSK_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|spad_local
operator|=
name|XEON_SPAD_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|bar4_xlat
operator|=
name|XEON_SBAR4XLAT_OFFSET
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
name|ntb
operator|->
name|reg_ofs
operator|.
name|bar5_xlat
operator|=
name|XEON_SBAR5XLAT_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|spci_cmd
operator|=
name|XEON_PCICMD_OFFSET
expr_stmt|;
name|ntb
operator|->
name|spad_count
operator|=
name|XEON_SPAD_COUNT
expr_stmt|;
name|ntb
operator|->
name|db_count
operator|=
name|XEON_DB_COUNT
expr_stmt|;
name|ntb
operator|->
name|db_link_mask
operator|=
name|XEON_DB_LINK_BIT
expr_stmt|;
name|ntb
operator|->
name|db_vec_count
operator|=
name|XEON_DB_MSIX_VECTOR_COUNT
expr_stmt|;
name|ntb
operator|->
name|db_vec_shift
operator|=
name|XEON_DB_MSIX_VECTOR_SHIFT
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|conn_type
operator|!=
name|NTB_CONN_B2B
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Connection type %d not supported\n"
argument_list|,
name|ntb
operator|->
name|conn_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ntb
operator|->
name|reg
operator|=
operator|&
name|xeon_reg
expr_stmt|;
name|ntb
operator|->
name|peer_reg
operator|=
operator|&
name|xeon_b2b_reg
expr_stmt|;
name|ntb
operator|->
name|xlat_reg
operator|=
operator|&
name|xeon_sec_xlat
expr_stmt|;
comment|/* 	 * There is a Xeon hardware errata related to writes to SDOORBELL or 	 * B2BDOORBELL in conjunction with inbound access to NTB MMIO space, 	 * which may hang the system.  To workaround this use the second memory 	 * window to access the interrupt and scratch pad registers on the 	 * remote system. 	 */
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SDOORBELL_LOCKUP
argument_list|)
condition|)
comment|/* Use the last MW for mapping remote spad */
name|ntb
operator|->
name|b2b_mw_idx
operator|=
name|ntb
operator|->
name|mw_count
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_B2BDOORBELL_BIT14
argument_list|)
condition|)
comment|/* 		 * HW Errata on bit 14 of b2bdoorbell register.  Writes will not be 		 * mirrored to the remote system.  Shrink the number of bits by one, 		 * since bit 14 is the last bit. 		 * 		 * On REGS_THRU_MW errata mode, we don't use the b2bdoorbell register 		 * anyway.  Nor for non-B2B connection types. 		 */
name|ntb
operator|->
name|db_count
operator|=
name|XEON_DB_COUNT
operator|-
literal|1
expr_stmt|;
name|ntb
operator|->
name|db_valid_mask
operator|=
operator|(
literal|1ull
operator|<<
name|ntb
operator|->
name|db_count
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|dev_type
operator|==
name|NTB_DEV_USD
condition|)
name|rc
operator|=
name|xeon_setup_b2b_mw
argument_list|(
name|ntb
argument_list|,
operator|&
name|xeon_b2b_dsd_addr
argument_list|,
operator|&
name|xeon_b2b_usd_addr
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|xeon_setup_b2b_mw
argument_list|(
name|ntb
argument_list|,
operator|&
name|xeon_b2b_usd_addr
argument_list|,
operator|&
name|xeon_b2b_dsd_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* Enable Bus Master and Memory Space on the secondary side */
name|ntb_reg_write
argument_list|(
literal|2
argument_list|,
name|ntb
operator|->
name|reg_ofs
operator|.
name|spci_cmd
argument_list|,
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
argument_list|)
expr_stmt|;
comment|/* Enable link training */
name|ntb_link_enable
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_soc_init_dev
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|ntb
operator|->
name|conn_type
operator|==
name|NTB_CONN_B2B
argument_list|,
operator|(
literal|"Unsupported NTB configuration (%d)\n"
operator|,
name|ntb
operator|->
name|conn_type
operator|)
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|ldb
operator|=
name|SOC_PDOORBELL_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|ldb_mask
operator|=
name|SOC_PDBMSK_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|bar4_xlat
operator|=
name|SOC_SBAR4XLAT_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|spad_local
operator|=
name|SOC_SPAD_OFFSET
expr_stmt|;
name|ntb
operator|->
name|reg_ofs
operator|.
name|spci_cmd
operator|=
name|SOC_PCICMD_OFFSET
expr_stmt|;
name|ntb
operator|->
name|spad_count
operator|=
name|SOC_SPAD_COUNT
expr_stmt|;
name|ntb
operator|->
name|db_count
operator|=
name|SOC_DB_COUNT
expr_stmt|;
name|ntb
operator|->
name|db_vec_count
operator|=
name|SOC_DB_MSIX_VECTOR_COUNT
expr_stmt|;
name|ntb
operator|->
name|db_vec_shift
operator|=
name|SOC_DB_MSIX_VECTOR_SHIFT
expr_stmt|;
name|ntb
operator|->
name|db_valid_mask
operator|=
operator|(
literal|1ull
operator|<<
name|ntb
operator|->
name|db_count
operator|)
operator|-
literal|1
expr_stmt|;
name|ntb
operator|->
name|reg
operator|=
operator|&
name|soc_reg
expr_stmt|;
name|ntb
operator|->
name|peer_reg
operator|=
operator|&
name|soc_b2b_reg
expr_stmt|;
name|ntb
operator|->
name|xlat_reg
operator|=
operator|&
name|soc_sec_xlat
expr_stmt|;
comment|/* 	 * FIXME - MSI-X bug on early SOC HW, remove once internal issue is 	 * resolved.  Mask transaction layer internal parity errors. 	 */
name|pci_write_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|0xFC
argument_list|,
literal|0x4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|configure_soc_secondary_side_bars
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
comment|/* Enable Bus Master and Memory Space on the secondary side */
name|ntb_reg_write
argument_list|(
literal|2
argument_list|,
name|ntb
operator|->
name|reg_ofs
operator|.
name|spci_cmd
argument_list|,
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
argument_list|)
expr_stmt|;
comment|/* Initiate PCI-E link training */
name|ntb_link_enable
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|ntb
operator|->
name|heartbeat_timer
argument_list|,
literal|0
argument_list|,
name|soc_link_hb
argument_list|,
name|ntb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* XXX: Linux driver doesn't seem to do any of this for SoC. */
end_comment

begin_function
specifier|static
name|void
name|configure_soc_secondary_side_bars
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
if|if
condition|(
name|ntb
operator|->
name|dev_type
operator|==
name|NTB_DEV_USD
condition|)
block|{
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|SOC_PBAR2XLAT_OFFSET
argument_list|,
name|XEON_B2B_BAR2_DSD_ADDR64
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|SOC_PBAR4XLAT_OFFSET
argument_list|,
name|XEON_B2B_BAR4_DSD_ADDR64
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|SOC_MBAR23_OFFSET
argument_list|,
name|XEON_B2B_BAR2_USD_ADDR64
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|SOC_MBAR45_OFFSET
argument_list|,
name|XEON_B2B_BAR4_USD_ADDR64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|SOC_PBAR2XLAT_OFFSET
argument_list|,
name|XEON_B2B_BAR2_USD_ADDR64
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|SOC_PBAR4XLAT_OFFSET
argument_list|,
name|XEON_B2B_BAR4_USD_ADDR64
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|SOC_MBAR23_OFFSET
argument_list|,
name|XEON_B2B_BAR2_DSD_ADDR64
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|SOC_MBAR45_OFFSET
argument_list|,
name|XEON_B2B_BAR4_DSD_ADDR64
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * When working around Xeon SDOORBELL errata by remapping remote registers in a  * MW, limit the B2B MW to half a MW.  By sharing a MW, half the shared MW  * remains for use by a higher layer.  *  * Will only be used if working around SDOORBELL errata and the BIOS-configured  * MW size is sufficiently large.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|ntb_b2b_mw_share
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_ntb
argument_list|,
name|OID_AUTO
argument_list|,
name|b2b_mw_share
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ntb_b2b_mw_share
argument_list|,
literal|0
argument_list|,
literal|"If enabled (non-zero), prefer to share half of the B2B peer register "
literal|"MW with higher level consumers.  Both sides of the NTB MUST set the same "
literal|"value here."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|xeon_reset_sbar_size
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|enum
name|ntb_bar
name|idx
parameter_list|,
name|enum
name|ntb_bar
name|regbar
parameter_list|)
block|{
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
decl_stmt|;
name|uint8_t
name|bar_sz
decl_stmt|;
if|if
condition|(
operator|!
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
operator|&&
name|idx
operator|>=
name|NTB_B2B_BAR_3
condition|)
return|return;
name|bar
operator|=
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|idx
index|]
expr_stmt|;
name|bar_sz
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|bar
operator|->
name|psz_off
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|regbar
condition|)
block|{
if|if
condition|(
name|ntb
operator|->
name|b2b_off
operator|!=
literal|0
condition|)
name|bar_sz
operator|--
expr_stmt|;
else|else
name|bar_sz
operator|=
literal|0
expr_stmt|;
block|}
name|pci_write_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|bar
operator|->
name|ssz_off
argument_list|,
name|bar_sz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bar_sz
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|bar
operator|->
name|ssz_off
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bar_sz
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xeon_set_sbar_base_and_limit
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint64_t
name|base_addr
parameter_list|,
name|enum
name|ntb_bar
name|idx
parameter_list|,
name|enum
name|ntb_bar
name|regbar
parameter_list|)
block|{
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
decl_stmt|;
name|vm_paddr_t
name|bar_addr
decl_stmt|;
name|bar
operator|=
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|idx
index|]
expr_stmt|;
name|bar_addr
operator|=
name|base_addr
operator|+
operator|(
operator|(
name|idx
operator|==
name|regbar
operator|)
condition|?
name|ntb
operator|->
name|b2b_off
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
operator|&&
name|idx
operator|>=
name|NTB_B2B_BAR_2
condition|)
block|{
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|bar
operator|->
name|sbarbase_off
argument_list|,
name|bar_addr
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|bar
operator|->
name|sbarlmt_off
argument_list|,
name|bar_addr
argument_list|)
expr_stmt|;
name|bar_addr
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|bar
operator|->
name|sbarbase_off
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bar_addr
expr_stmt|;
name|bar_addr
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|bar
operator|->
name|sbarlmt_off
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|bar
operator|->
name|sbarbase_off
argument_list|,
name|bar_addr
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|bar
operator|->
name|sbarlmt_off
argument_list|,
name|bar_addr
argument_list|)
expr_stmt|;
name|bar_addr
operator|=
name|ntb_reg_read
argument_list|(
literal|8
argument_list|,
name|bar
operator|->
name|sbarbase_off
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bar_addr
expr_stmt|;
name|bar_addr
operator|=
name|ntb_reg_read
argument_list|(
literal|8
argument_list|,
name|bar
operator|->
name|sbarlmt_off
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|bar_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xeon_set_pbar_xlat
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint64_t
name|base_addr
parameter_list|,
name|enum
name|ntb_bar
name|idx
parameter_list|)
block|{
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
decl_stmt|;
name|bar
operator|=
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
operator|&&
name|idx
operator|>=
name|NTB_B2B_BAR_2
condition|)
block|{
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|bar
operator|->
name|pbarxlat_off
argument_list|,
name|base_addr
argument_list|)
expr_stmt|;
name|base_addr
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|bar
operator|->
name|pbarxlat_off
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|bar
operator|->
name|pbarxlat_off
argument_list|,
name|base_addr
argument_list|)
expr_stmt|;
name|base_addr
operator|=
name|ntb_reg_read
argument_list|(
literal|8
argument_list|,
name|bar
operator|->
name|pbarxlat_off
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|base_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xeon_setup_b2b_mw
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
specifier|const
name|struct
name|ntb_b2b_addr
modifier|*
name|addr
parameter_list|,
specifier|const
name|struct
name|ntb_b2b_addr
modifier|*
name|peer_addr
parameter_list|)
block|{
name|struct
name|ntb_pci_bar_info
modifier|*
name|b2b_bar
decl_stmt|;
name|vm_size_t
name|bar_size
decl_stmt|;
name|uint64_t
name|bar_addr
decl_stmt|;
name|enum
name|ntb_bar
name|b2b_bar_num
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|ntb
operator|->
name|b2b_mw_idx
operator|==
name|B2B_MW_DISABLED
condition|)
block|{
name|b2b_bar
operator|=
name|NULL
expr_stmt|;
name|b2b_bar_num
operator|=
name|NTB_CONFIG_BAR
expr_stmt|;
name|ntb
operator|->
name|b2b_off
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|b2b_bar_num
operator|=
name|ntb_mw_to_bar
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|b2b_mw_idx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|b2b_bar_num
operator|>
literal|0
operator|&&
name|b2b_bar_num
operator|<
name|NTB_MAX_BARS
argument_list|,
operator|(
literal|"invalid b2b mw bar"
operator|)
argument_list|)
expr_stmt|;
name|b2b_bar
operator|=
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|b2b_bar_num
index|]
expr_stmt|;
name|bar_size
operator|=
name|b2b_bar
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|ntb_b2b_mw_share
operator|!=
literal|0
operator|&&
operator|(
name|bar_size
operator|>>
literal|1
operator|)
operator|>=
name|XEON_B2B_MIN_SIZE
condition|)
name|ntb
operator|->
name|b2b_off
operator|=
name|bar_size
operator|>>
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|bar_size
operator|>=
name|XEON_B2B_MIN_SIZE
condition|)
block|{
name|ntb
operator|->
name|b2b_off
operator|=
literal|0
expr_stmt|;
name|ntb
operator|->
name|mw_count
operator|--
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"B2B bar size is too small!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
comment|/* 	 * Reset the secondary bar sizes to match the primary bar sizes. 	 * (Except, disable or halve the size of the B2B secondary bar.) 	 */
for|for
control|(
name|i
operator|=
name|NTB_B2B_BAR_1
init|;
name|i
operator|<
name|NTB_MAX_BARS
condition|;
name|i
operator|++
control|)
name|xeon_reset_sbar_size
argument_list|(
name|ntb
argument_list|,
name|i
argument_list|,
name|b2b_bar_num
argument_list|)
expr_stmt|;
name|bar_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b2b_bar_num
operator|==
name|NTB_CONFIG_BAR
condition|)
name|bar_addr
operator|=
name|addr
operator|->
name|bar0_addr
expr_stmt|;
elseif|else
if|if
condition|(
name|b2b_bar_num
operator|==
name|NTB_B2B_BAR_1
condition|)
name|bar_addr
operator|=
name|addr
operator|->
name|bar2_addr64
expr_stmt|;
elseif|else
if|if
condition|(
name|b2b_bar_num
operator|==
name|NTB_B2B_BAR_2
operator|&&
operator|!
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
name|bar_addr
operator|=
name|addr
operator|->
name|bar4_addr64
expr_stmt|;
elseif|else
if|if
condition|(
name|b2b_bar_num
operator|==
name|NTB_B2B_BAR_2
condition|)
name|bar_addr
operator|=
name|addr
operator|->
name|bar4_addr32
expr_stmt|;
elseif|else
if|if
condition|(
name|b2b_bar_num
operator|==
name|NTB_B2B_BAR_3
condition|)
name|bar_addr
operator|=
name|addr
operator|->
name|bar5_addr32
expr_stmt|;
else|else
name|KASSERT
argument_list|(
name|false
argument_list|,
operator|(
literal|"invalid bar"
operator|)
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|XEON_SBAR0BASE_OFFSET
argument_list|,
name|bar_addr
argument_list|)
expr_stmt|;
comment|/* 	 * Other SBARs are normally hit by the PBAR xlat, except for the b2b 	 * register BAR.  The B2B BAR is either disabled above or configured 	 * half-size.  It starts at PBAR xlat + offset. 	 * 	 * Also set up incoming BAR limits == base (zero length window). 	 */
name|xeon_set_sbar_base_and_limit
argument_list|(
name|ntb
argument_list|,
name|addr
operator|->
name|bar2_addr64
argument_list|,
name|NTB_B2B_BAR_1
argument_list|,
name|b2b_bar_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
block|{
name|xeon_set_sbar_base_and_limit
argument_list|(
name|ntb
argument_list|,
name|addr
operator|->
name|bar4_addr32
argument_list|,
name|NTB_B2B_BAR_2
argument_list|,
name|b2b_bar_num
argument_list|)
expr_stmt|;
name|xeon_set_sbar_base_and_limit
argument_list|(
name|ntb
argument_list|,
name|addr
operator|->
name|bar5_addr32
argument_list|,
name|NTB_B2B_BAR_3
argument_list|,
name|b2b_bar_num
argument_list|)
expr_stmt|;
block|}
else|else
name|xeon_set_sbar_base_and_limit
argument_list|(
name|ntb
argument_list|,
name|addr
operator|->
name|bar4_addr64
argument_list|,
name|NTB_B2B_BAR_2
argument_list|,
name|b2b_bar_num
argument_list|)
expr_stmt|;
comment|/* Zero incoming translation addrs */
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|XEON_SBAR2XLAT_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|XEON_SBAR4XLAT_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Zero outgoing translation limits (whole bar size windows) */
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|XEON_PBAR2LMT_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|XEON_PBAR4LMT_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set outgoing translation offsets */
name|xeon_set_pbar_xlat
argument_list|(
name|ntb
argument_list|,
name|peer_addr
operator|->
name|bar2_addr64
argument_list|,
name|NTB_B2B_BAR_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
block|{
name|xeon_set_pbar_xlat
argument_list|(
name|ntb
argument_list|,
name|peer_addr
operator|->
name|bar4_addr32
argument_list|,
name|NTB_B2B_BAR_2
argument_list|)
expr_stmt|;
name|xeon_set_pbar_xlat
argument_list|(
name|ntb
argument_list|,
name|peer_addr
operator|->
name|bar5_addr32
argument_list|,
name|NTB_B2B_BAR_3
argument_list|)
expr_stmt|;
block|}
else|else
name|xeon_set_pbar_xlat
argument_list|(
name|ntb
argument_list|,
name|peer_addr
operator|->
name|bar4_addr64
argument_list|,
name|NTB_B2B_BAR_2
argument_list|)
expr_stmt|;
comment|/* Set the translation offset for B2B registers */
name|bar_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b2b_bar_num
operator|==
name|NTB_CONFIG_BAR
condition|)
name|bar_addr
operator|=
name|peer_addr
operator|->
name|bar0_addr
expr_stmt|;
elseif|else
if|if
condition|(
name|b2b_bar_num
operator|==
name|NTB_B2B_BAR_1
condition|)
name|bar_addr
operator|=
name|peer_addr
operator|->
name|bar2_addr64
expr_stmt|;
elseif|else
if|if
condition|(
name|b2b_bar_num
operator|==
name|NTB_B2B_BAR_2
operator|&&
operator|!
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
name|bar_addr
operator|=
name|peer_addr
operator|->
name|bar4_addr64
expr_stmt|;
elseif|else
if|if
condition|(
name|b2b_bar_num
operator|==
name|NTB_B2B_BAR_2
condition|)
name|bar_addr
operator|=
name|peer_addr
operator|->
name|bar4_addr32
expr_stmt|;
elseif|else
if|if
condition|(
name|b2b_bar_num
operator|==
name|NTB_B2B_BAR_3
condition|)
name|bar_addr
operator|=
name|peer_addr
operator|->
name|bar5_addr32
expr_stmt|;
else|else
name|KASSERT
argument_list|(
name|false
argument_list|,
operator|(
literal|"invalid bar"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * B2B_XLAT_OFFSET is a 64-bit register but can only be written 32 bits 	 * at a time. 	 */
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|XEON_B2B_XLAT_OFFSETL
argument_list|,
name|bar_addr
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|XEON_B2B_XLAT_OFFSETU
argument_list|,
name|bar_addr
operator|>>
literal|32
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* SOC does not have link status interrupt, poll on that platform */
end_comment

begin_function
specifier|static
name|void
name|soc_link_hb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|arg
decl_stmt|;
name|uint32_t
name|status32
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* 	 * Delay polling the link status if an interrupt was received, unless 	 * the cached link status says the link is down. 	 */
if|if
condition|(
operator|(
name|long
operator|)
name|ticks
operator|-
operator|(
operator|(
name|long
operator|)
name|ntb
operator|->
name|last_ts
operator|+
name|NTB_HB_TIMEOUT
operator|*
name|hz
operator|)
operator|<
literal|0
operator|&&
operator|(
name|ntb
operator|->
name|ntb_ctl
operator|&
name|SOC_CNTL_LINK_DOWN
operator|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|rc
operator|=
name|ntb_poll_link
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Error determining link status\n"
argument_list|)
expr_stmt|;
comment|/* Check to see if a link error is the cause of the link down */
if|if
condition|(
name|ntb
operator|->
name|link_status
operator|==
name|NTB_LINK_DOWN
condition|)
block|{
name|status32
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|SOC_LTSSMSTATEJMP_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status32
operator|&
name|SOC_LTSSMSTATEJMP_FORCEDETECT
operator|)
operator|!=
literal|0
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|ntb
operator|->
name|lr_timer
argument_list|,
literal|0
argument_list|,
name|recover_soc_link
argument_list|,
name|ntb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|out
label|:
name|callout_reset
argument_list|(
operator|&
name|ntb
operator|->
name|heartbeat_timer
argument_list|,
name|NTB_HB_TIMEOUT
operator|*
name|hz
argument_list|,
name|soc_link_hb
argument_list|,
name|ntb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|soc_perform_link_restart
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
comment|/* Driver resets the NTB ModPhy lanes - magic! */
name|ntb_reg_write
argument_list|(
literal|1
argument_list|,
name|SOC_MODPHY_PCSREG6
argument_list|,
literal|0xe0
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|1
argument_list|,
name|SOC_MODPHY_PCSREG4
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|1
argument_list|,
name|SOC_MODPHY_PCSREG4
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|1
argument_list|,
name|SOC_MODPHY_PCSREG6
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
comment|/* Driver waits 100ms to allow the NTB ModPhy to settle */
name|pause
argument_list|(
literal|"ModPhy"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
comment|/* Clear AER Errors, write to clear */
name|status
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|SOC_ERRCORSTS_OFFSET
argument_list|)
expr_stmt|;
name|status
operator|&=
name|PCIM_AER_COR_REPLAY_ROLLOVER
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|SOC_ERRCORSTS_OFFSET
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Clear unexpected electrical idle event in LTSSM, write to clear */
name|status
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|SOC_LTSSMERRSTS0_OFFSET
argument_list|)
expr_stmt|;
name|status
operator||=
name|SOC_LTSSMERRSTS0_UNEXPECTEDEI
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|SOC_LTSSMERRSTS0_OFFSET
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Clear DeSkew Buffer error, write to clear */
name|status
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|SOC_DESKEWSTS_OFFSET
argument_list|)
expr_stmt|;
name|status
operator||=
name|SOC_DESKEWSTS_DBERR
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|SOC_DESKEWSTS_OFFSET
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|status
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|SOC_IBSTERRRCRVSTS0_OFFSET
argument_list|)
expr_stmt|;
name|status
operator|&=
name|SOC_IBIST_ERR_OFLOW
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|SOC_IBSTERRRCRVSTS0_OFFSET
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Releases the NTB state machine to allow the link to retrain */
name|status
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|SOC_LTSSMSTATEJMP_OFFSET
argument_list|)
expr_stmt|;
name|status
operator|&=
operator|~
name|SOC_LTSSMSTATEJMP_FORCEDETECT
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|SOC_LTSSMSTATEJMP_OFFSET
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_handle_link_event
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|int
name|link_state
parameter_list|)
block|{
name|enum
name|ntb_hw_event
name|event
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
if|if
condition|(
name|ntb
operator|->
name|link_status
operator|==
name|link_state
condition|)
return|return;
if|if
condition|(
name|link_state
operator|==
name|NTB_LINK_UP
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Link Up\n"
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|link_status
operator|=
name|NTB_LINK_UP
expr_stmt|;
name|event
operator|=
name|NTB_EVENT_HW_LINK_UP
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_SOC
operator|||
name|ntb
operator|->
name|conn_type
operator|==
name|NTB_CONN_TRANSPARENT
condition|)
name|status
operator|=
name|ntb_reg_read
argument_list|(
literal|2
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|lnk_sta
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|XEON_LINK_STATUS_OFFSET
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|link_width
operator|=
operator|(
name|status
operator|&
name|NTB_LINK_WIDTH_MASK
operator|)
operator|>>
literal|4
expr_stmt|;
name|ntb
operator|->
name|link_speed
operator|=
operator|(
name|status
operator|&
name|NTB_LINK_SPEED_MASK
operator|)
expr_stmt|;
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Link Width %d, Link Speed %d\n"
argument_list|,
name|ntb
operator|->
name|link_width
argument_list|,
name|ntb
operator|->
name|link_speed
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|ntb
operator|->
name|heartbeat_timer
argument_list|,
name|NTB_HB_TIMEOUT
operator|*
name|hz
argument_list|,
name|soc_link_hb
argument_list|,
name|ntb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Link Down\n"
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|link_status
operator|=
name|NTB_LINK_DOWN
expr_stmt|;
name|event
operator|=
name|NTB_EVENT_HW_LINK_DOWN
expr_stmt|;
comment|/* Do not modify link width/speed, we need it in link recovery */
block|}
comment|/* notify the upper layer if we have an event change */
if|if
condition|(
name|ntb
operator|->
name|event_cb
operator|!=
name|NULL
condition|)
name|ntb
operator|->
name|event_cb
argument_list|(
name|ntb
operator|->
name|ntb_transport
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_link_enable
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|uint32_t
name|cntl
decl_stmt|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_SOC
condition|)
block|{
name|pci_write_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|NTB_PPD_OFFSET
argument_list|,
name|ntb
operator|->
name|ppd
operator||
name|SOC_PPD_INIT_LINK
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ntb
operator|->
name|conn_type
operator|==
name|NTB_CONN_TRANSPARENT
condition|)
block|{
name|ntb_handle_link_event
argument_list|(
name|ntb
argument_list|,
name|NTB_LINK_UP
argument_list|)
expr_stmt|;
return|return;
block|}
name|cntl
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|ntb_ctl
argument_list|)
expr_stmt|;
name|cntl
operator|&=
operator|~
operator|(
name|NTB_CNTL_LINK_DISABLE
operator||
name|NTB_CNTL_CFG_LOCK
operator|)
expr_stmt|;
name|cntl
operator||=
name|NTB_CNTL_P2S_BAR23_SNOOP
operator||
name|NTB_CNTL_S2P_BAR23_SNOOP
expr_stmt|;
name|cntl
operator||=
name|NTB_CNTL_P2S_BAR4_SNOOP
operator||
name|NTB_CNTL_S2P_BAR4_SNOOP
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
name|cntl
operator||=
name|NTB_CNTL_P2S_BAR5_SNOOP
operator||
name|NTB_CNTL_S2P_BAR5_SNOOP
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|ntb_ctl
argument_list|,
name|cntl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_link_disable
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|uint32_t
name|cntl
decl_stmt|;
if|if
condition|(
name|ntb
operator|->
name|conn_type
operator|==
name|NTB_CONN_TRANSPARENT
condition|)
block|{
name|ntb_handle_link_event
argument_list|(
name|ntb
argument_list|,
name|NTB_LINK_DOWN
argument_list|)
expr_stmt|;
return|return;
block|}
name|cntl
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|ntb_ctl
argument_list|)
expr_stmt|;
name|cntl
operator|&=
operator|~
operator|(
name|NTB_CNTL_P2S_BAR23_SNOOP
operator||
name|NTB_CNTL_S2P_BAR23_SNOOP
operator|)
expr_stmt|;
name|cntl
operator|&=
operator|~
operator|(
name|NTB_CNTL_P2S_BAR4_SNOOP
operator||
name|NTB_CNTL_S2P_BAR4_SNOOP
operator|)
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
name|cntl
operator|&=
operator|~
operator|(
name|NTB_CNTL_P2S_BAR5_SNOOP
operator||
name|NTB_CNTL_S2P_BAR5_SNOOP
operator|)
expr_stmt|;
name|cntl
operator||=
name|NTB_CNTL_LINK_DISABLE
operator||
name|NTB_CNTL_CFG_LOCK
expr_stmt|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|ntb_ctl
argument_list|,
name|cntl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|recover_soc_link
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|arg
decl_stmt|;
name|uint8_t
name|speed
decl_stmt|,
name|width
decl_stmt|;
name|uint32_t
name|status32
decl_stmt|;
name|soc_perform_link_restart
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
comment|/* 	 * There is a potential race between the 2 NTB devices recovering at 	 * the same time.  If the times are the same, the link will not recover 	 * and the driver will be stuck in this loop forever.  Add a random 	 * interval to the recovery time to prevent this race. 	 */
name|status32
operator|=
name|arc4random
argument_list|()
operator|%
name|SOC_LINK_RECOVERY_TIME
expr_stmt|;
name|pause
argument_list|(
literal|"Link"
argument_list|,
operator|(
name|SOC_LINK_RECOVERY_TIME
operator|+
name|status32
operator|)
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|status32
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|SOC_LTSSMSTATEJMP_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status32
operator|&
name|SOC_LTSSMSTATEJMP_FORCEDETECT
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|retry
goto|;
name|status32
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|SOC_IBSTERRRCRVSTS0_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status32
operator|&
name|SOC_IBIST_ERR_OFLOW
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|retry
goto|;
name|status32
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|ntb_ctl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status32
operator|&
name|SOC_CNTL_LINK_DOWN
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|status32
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|lnk_sta
argument_list|)
expr_stmt|;
name|width
operator|=
operator|(
name|status32
operator|&
name|NTB_LINK_WIDTH_MASK
operator|)
operator|>>
literal|4
expr_stmt|;
name|speed
operator|=
operator|(
name|status32
operator|&
name|NTB_LINK_SPEED_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|ntb
operator|->
name|link_width
operator|!=
name|width
operator|||
name|ntb
operator|->
name|link_speed
operator|!=
name|speed
condition|)
goto|goto
name|retry
goto|;
name|out
label|:
name|callout_reset
argument_list|(
operator|&
name|ntb
operator|->
name|heartbeat_timer
argument_list|,
name|NTB_HB_TIMEOUT
operator|*
name|hz
argument_list|,
name|soc_link_hb
argument_list|,
name|ntb
argument_list|)
expr_stmt|;
return|return;
name|retry
label|:
name|callout_reset
argument_list|(
operator|&
name|ntb
operator|->
name|lr_timer
argument_list|,
name|NTB_HB_TIMEOUT
operator|*
name|hz
argument_list|,
name|recover_soc_link
argument_list|,
name|ntb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_poll_link
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|int
name|link_state
decl_stmt|;
name|uint32_t
name|ntb_cntl
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_SOC
condition|)
block|{
name|HW_LOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|ntb_cntl
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|ntb_ctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntb_cntl
operator|==
name|ntb
operator|->
name|ntb_ctl
condition|)
block|{
name|HW_UNLOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ntb
operator|->
name|ntb_ctl
operator|=
name|ntb_cntl
expr_stmt|;
name|ntb
operator|->
name|lnk_sta
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|lnk_sta
argument_list|)
expr_stmt|;
name|HW_UNLOCK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ntb_cntl
operator|&
name|SOC_CNTL_LINK_DOWN
operator|)
operator|!=
literal|0
condition|)
name|link_state
operator|=
name|NTB_LINK_DOWN
expr_stmt|;
else|else
name|link_state
operator|=
name|NTB_LINK_UP
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|pci_read_config
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
name|ntb
operator|->
name|reg
operator|->
name|lnk_sta
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|ntb
operator|->
name|lnk_sta
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ntb
operator|->
name|lnk_sta
operator|=
name|status
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|NTB_LINK_STATUS_ACTIVE
operator|)
operator|!=
literal|0
condition|)
name|link_state
operator|=
name|NTB_LINK_UP
expr_stmt|;
else|else
name|link_state
operator|=
name|NTB_LINK_DOWN
expr_stmt|;
block|}
name|ntb_handle_link_event
argument_list|(
name|ntb
argument_list|,
name|link_state
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_irq_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_db_cb
modifier|*
name|db_cb
init|=
name|arg
decl_stmt|;
name|struct
name|ntb_softc
modifier|*
name|ntb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|db_cb
operator|->
name|callback
argument_list|(
name|db_cb
operator|->
name|data
argument_list|,
name|db_cb
operator|->
name|db_num
argument_list|)
expr_stmt|;
comment|/* Poll if forward progress was made. */
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|db_cb
operator|->
name|irq_work
argument_list|,
literal|0
argument_list|,
name|ntb_irq_work
argument_list|,
name|db_cb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Unmask interrupt if no progress was made. */
name|ntb
operator|=
name|db_cb
operator|->
name|ntb
expr_stmt|;
name|unmask_ldb_interrupt
argument_list|(
name|ntb
argument_list|,
name|db_cb
operator|->
name|db_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Public API to the rest of the OS  */
end_comment

begin_comment
comment|/**  * ntb_register_event_callback() - register event callback  * @ntb: pointer to ntb_softc instance  * @func: callback function to register  *  * This function registers a callback for any HW driver events such as link  * up/down, power management notices and etc.  *  * RETURNS: An appropriate ERRNO error value on error, or zero for success.  */
end_comment

begin_function
name|int
name|ntb_register_event_callback
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|ntb_event_callback
name|func
parameter_list|)
block|{
if|if
condition|(
name|ntb
operator|->
name|event_cb
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ntb
operator|->
name|event_cb
operator|=
name|func
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_unregister_event_callback() - unregisters the event callback  * @ntb: pointer to ntb_softc instance  *  * This function unregisters the existing callback from transport  */
end_comment

begin_function
name|void
name|ntb_unregister_event_callback
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|ntb
operator|->
name|event_cb
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ntb_register_db_callback() - register a callback for doorbell interrupt  * @ntb: pointer to ntb_softc instance  * @idx: doorbell index to register callback, zero based  * @data: pointer to be returned to caller with every callback  * @func: callback function to register  *  * This function registers a callback function for the doorbell interrupt  * on the primary side. The function will unmask the doorbell as well to  * allow interrupt.  *  * RETURNS: An appropriate ERRNO error value on error, or zero for success.  */
end_comment

begin_function
name|int
name|ntb_register_db_callback
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|ntb_db_callback
name|func
parameter_list|)
block|{
name|struct
name|ntb_db_cb
modifier|*
name|db_cb
init|=
operator|&
name|ntb
operator|->
name|db_cb
index|[
name|idx
index|]
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
name|ntb
operator|->
name|max_cbs
operator|||
name|db_cb
operator|->
name|callback
operator|!=
name|NULL
operator|||
name|db_cb
operator|->
name|reserved
condition|)
block|{
name|device_printf
argument_list|(
name|ntb
operator|->
name|device
argument_list|,
literal|"Invalid Index.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|db_cb
operator|->
name|callback
operator|=
name|func
expr_stmt|;
name|db_cb
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|db_cb
operator|->
name|irq_work
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|unmask_ldb_interrupt
argument_list|(
name|ntb
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_unregister_db_callback() - unregister a callback for doorbell interrupt  * @ntb: pointer to ntb_softc instance  * @idx: doorbell index to register callback, zero based  *  * This function unregisters a callback function for the doorbell interrupt  * on the primary side. The function will also mask the said doorbell.  */
end_comment

begin_function
name|void
name|ntb_unregister_db_callback
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>=
name|ntb
operator|->
name|max_cbs
operator|||
name|ntb
operator|->
name|db_cb
index|[
name|idx
index|]
operator|.
name|callback
operator|==
name|NULL
condition|)
return|return;
name|mask_ldb_interrupt
argument_list|(
name|ntb
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|ntb
operator|->
name|db_cb
index|[
name|idx
index|]
operator|.
name|irq_work
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|db_cb
index|[
name|idx
index|]
operator|.
name|callback
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ntb_find_transport() - find the transport pointer  * @transport: pointer to pci device  *  * Given the pci device pointer, return the transport pointer passed in when  * the transport attached when it was inited.  *  * RETURNS: pointer to transport.  */
end_comment

begin_function
name|void
modifier|*
name|ntb_find_transport
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
return|return
operator|(
name|ntb
operator|->
name|ntb_transport
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_register_transport() - Register NTB transport with NTB HW driver  * @transport: transport identifier  *  * This function allows a transport to reserve the hardware driver for  * NTB usage.  *  * RETURNS: pointer to ntb_softc, NULL on error.  */
end_comment

begin_function
name|struct
name|ntb_softc
modifier|*
name|ntb_register_transport
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|void
modifier|*
name|transport
parameter_list|)
block|{
comment|/* 	 * TODO: when we have more than one transport, we will need to rewrite 	 * this to prevent race conditions 	 */
if|if
condition|(
name|ntb
operator|->
name|ntb_transport
operator|!=
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ntb
operator|->
name|ntb_transport
operator|=
name|transport
expr_stmt|;
return|return
operator|(
name|ntb
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_unregister_transport() - Unregister the transport with the NTB HW driver  * @ntb - ntb_softc of the transport to be freed  *  * This function unregisters the transport from the HW driver and performs any  * necessary cleanups.  */
end_comment

begin_function
name|void
name|ntb_unregister_transport
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|uint8_t
name|i
decl_stmt|;
if|if
condition|(
name|ntb
operator|->
name|ntb_transport
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntb
operator|->
name|max_cbs
condition|;
name|i
operator|++
control|)
name|ntb_unregister_db_callback
argument_list|(
name|ntb
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ntb_unregister_event_callback
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|ntb
operator|->
name|ntb_transport
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ntb_get_max_spads() - get the total scratch regs usable  * @ntb: pointer to ntb_softc instance  *  * This function returns the max 32bit scratchpad registers usable by the  * upper layer.  *  * RETURNS: total number of scratch pad registers available  */
end_comment

begin_function
name|uint8_t
name|ntb_get_max_spads
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
return|return
operator|(
name|ntb
operator|->
name|spad_count
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|ntb_get_max_cbs
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
return|return
operator|(
name|ntb
operator|->
name|max_cbs
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|ntb_mw_count
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
return|return
operator|(
name|ntb
operator|->
name|mw_count
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_write_local_spad() - write to the secondary scratchpad register  * @ntb: pointer to ntb_softc instance  * @idx: index to the scratchpad register, 0 based  * @val: the data value to put into the register  *  * This function allows writing of a 32bit value to the indexed scratchpad  * register. The register resides on the secondary (external) side.  *  * RETURNS: An appropriate ERRNO error value on error, or zero for success.  */
end_comment

begin_function
name|int
name|ntb_write_local_spad
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>=
name|ntb
operator|->
name|spad_count
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg_ofs
operator|.
name|spad_local
operator|+
name|idx
operator|*
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_read_local_spad() - read from the primary scratchpad register  * @ntb: pointer to ntb_softc instance  * @idx: index to scratchpad register, 0 based  * @val: pointer to 32bit integer for storing the register value  *  * This function allows reading of the 32bit scratchpad register on  * the primary (internal) side.  *  * RETURNS: An appropriate ERRNO error value on error, or zero for success.  */
end_comment

begin_function
name|int
name|ntb_read_local_spad
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>=
name|ntb
operator|->
name|spad_count
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|val
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg_ofs
operator|.
name|spad_local
operator|+
name|idx
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_write_remote_spad() - write to the secondary scratchpad register  * @ntb: pointer to ntb_softc instance  * @idx: index to the scratchpad register, 0 based  * @val: the data value to put into the register  *  * This function allows writing of a 32bit value to the indexed scratchpad  * register. The register resides on the secondary (external) side.  *  * RETURNS: An appropriate ERRNO error value on error, or zero for success.  */
end_comment

begin_function
name|int
name|ntb_write_remote_spad
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>=
name|ntb
operator|->
name|spad_count
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SDOORBELL_LOCKUP
argument_list|)
condition|)
name|ntb_mw_write
argument_list|(
literal|4
argument_list|,
name|XEON_SHADOW_SPAD_OFFSET
operator|+
name|idx
operator|*
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|peer_reg
operator|->
name|spad
operator|+
name|idx
operator|*
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_read_remote_spad() - read from the primary scratchpad register  * @ntb: pointer to ntb_softc instance  * @idx: index to scratchpad register, 0 based  * @val: pointer to 32bit integer for storing the register value  *  * This function allows reading of the 32bit scratchpad register on  * the primary (internal) side.  *  * RETURNS: An appropriate ERRNO error value on error, or zero for success.  */
end_comment

begin_function
name|int
name|ntb_read_remote_spad
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>=
name|ntb
operator|->
name|spad_count
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SDOORBELL_LOCKUP
argument_list|)
condition|)
operator|*
name|val
operator|=
name|ntb_mw_read
argument_list|(
literal|4
argument_list|,
name|XEON_SHADOW_SPAD_OFFSET
operator|+
name|idx
operator|*
literal|4
argument_list|)
expr_stmt|;
else|else
operator|*
name|val
operator|=
name|ntb_reg_read
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|peer_reg
operator|->
name|spad
operator|+
name|idx
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_get_mw_vbase() - get virtual addr for the NTB memory window  * @ntb: pointer to ntb_softc instance  * @mw: memory window number  *  * This function provides the base virtual address of the memory window  * specified.  *  * RETURNS: pointer to virtual address, or NULL on error.  */
end_comment

begin_function
name|void
modifier|*
name|ntb_get_mw_vbase
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|mw
parameter_list|)
block|{
if|if
condition|(
name|mw
operator|>=
name|ntb_mw_count
argument_list|(
name|ntb
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|ntb
operator|->
name|bar_info
index|[
name|ntb_mw_to_bar
argument_list|(
name|ntb
argument_list|,
name|mw
argument_list|)
index|]
operator|.
name|vbase
operator|)
return|;
block|}
end_function

begin_function
name|bus_addr_t
name|ntb_get_mw_pbase
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|mw
parameter_list|)
block|{
if|if
condition|(
name|mw
operator|>=
name|ntb_mw_count
argument_list|(
name|ntb
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ntb
operator|->
name|bar_info
index|[
name|ntb_mw_to_bar
argument_list|(
name|ntb
argument_list|,
name|mw
argument_list|)
index|]
operator|.
name|pbase
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_get_mw_size() - return size of NTB memory window  * @ntb: pointer to ntb_softc instance  * @mw: memory window number  *  * This function provides the physical size of the memory window specified  *  * RETURNS: the size of the memory window or zero on error  */
end_comment

begin_function
name|u_long
name|ntb_get_mw_size
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|mw
parameter_list|)
block|{
if|if
condition|(
name|mw
operator|>=
name|ntb_mw_count
argument_list|(
name|ntb
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ntb
operator|->
name|bar_info
index|[
name|ntb_mw_to_bar
argument_list|(
name|ntb
argument_list|,
name|mw
argument_list|)
index|]
operator|.
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_set_mw_addr - set the memory window address  * @ntb: pointer to ntb_softc instance  * @mw: memory window number  * @addr: base address for data  *  * This function sets the base physical address of the memory window.  This  * memory address is where data from the remote system will be transfered into  * or out of depending on how the transport is configured.  */
end_comment

begin_function
name|void
name|ntb_set_mw_addr
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|mw
parameter_list|,
name|uint64_t
name|addr
parameter_list|)
block|{
if|if
condition|(
name|mw
operator|>=
name|ntb_mw_count
argument_list|(
name|ntb
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|ntb_mw_to_bar
argument_list|(
name|ntb
argument_list|,
name|mw
argument_list|)
condition|)
block|{
case|case
name|NTB_B2B_BAR_1
case|:
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|ntb
operator|->
name|xlat_reg
operator|->
name|bar2_xlat
argument_list|,
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|NTB_B2B_BAR_2
case|:
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
condition|)
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg_ofs
operator|.
name|bar4_xlat
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|ntb_reg_write
argument_list|(
literal|8
argument_list|,
name|ntb
operator|->
name|reg_ofs
operator|.
name|bar4_xlat
argument_list|,
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|NTB_B2B_BAR_3
case|:
name|ntb_reg_write
argument_list|(
literal|4
argument_list|,
name|ntb
operator|->
name|reg_ofs
operator|.
name|bar5_xlat
argument_list|,
name|addr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
name|false
argument_list|,
operator|(
literal|"invalid BAR"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * ntb_ring_doorbell() - Set the doorbell on the secondary/external side  * @ntb: pointer to ntb_softc instance  * @db: doorbell to ring  *  * This function allows triggering of a doorbell on the secondary/external  * side that will initiate an interrupt on the remote host  */
end_comment

begin_function
name|void
name|ntb_ring_doorbell
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|unsigned
name|int
name|db
parameter_list|)
block|{
name|uint64_t
name|bit
decl_stmt|;
if|if
condition|(
name|ntb
operator|->
name|type
operator|==
name|NTB_SOC
condition|)
name|bit
operator|=
literal|1
operator|<<
name|db
expr_stmt|;
else|else
name|bit
operator|=
operator|(
operator|(
literal|1
operator|<<
name|ntb
operator|->
name|db_vec_shift
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
name|db
operator|*
name|ntb
operator|->
name|db_vec_shift
operator|)
expr_stmt|;
if|if
condition|(
name|HAS_FEATURE
argument_list|(
name|NTB_SDOORBELL_LOCKUP
argument_list|)
condition|)
block|{
name|ntb_mw_write
argument_list|(
literal|2
argument_list|,
name|XEON_SHADOW_PDOORBELL_OFFSET
argument_list|,
name|bit
argument_list|)
expr_stmt|;
return|return;
block|}
name|ntb_db_write
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|peer_reg
operator|->
name|db_bell
argument_list|,
name|bit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ntb_get_peer_db_addr() - Return the address of the remote doorbell register,  * as well as the size of the register (via *sz_out).  *  * This function allows a caller using I/OAT DMA to chain the remote doorbell  * ring to its memory window write.  *  * Note that writing the peer doorbell via a memory window will *not* generate  * an interrupt on the remote host; that must be done seperately.  */
end_comment

begin_function
name|bus_addr_t
name|ntb_get_peer_db_addr
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|vm_size_t
modifier|*
name|sz_out
parameter_list|)
block|{
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
decl_stmt|;
name|uint64_t
name|regoff
decl_stmt|;
name|KASSERT
argument_list|(
name|sz_out
operator|!=
name|NULL
argument_list|,
operator|(
literal|"must be non-NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HAS_FEATURE
argument_list|(
name|NTB_SDOORBELL_LOCKUP
argument_list|)
condition|)
block|{
name|bar
operator|=
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|NTB_CONFIG_BAR
index|]
expr_stmt|;
name|regoff
operator|=
name|ntb
operator|->
name|peer_reg
operator|->
name|db_bell
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
operator|(
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
operator|&&
name|ntb
operator|->
name|mw_count
operator|==
literal|2
operator|)
operator|||
operator|(
operator|!
name|HAS_FEATURE
argument_list|(
name|NTB_SPLIT_BAR
argument_list|)
operator|&&
name|ntb
operator|->
name|mw_count
operator|==
literal|1
operator|)
argument_list|,
operator|(
literal|"mw_count invalid after setup"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ntb
operator|->
name|b2b_mw_idx
operator|!=
name|B2B_MW_DISABLED
argument_list|,
operator|(
literal|"invalid b2b idx"
operator|)
argument_list|)
expr_stmt|;
name|bar
operator|=
operator|&
name|ntb
operator|->
name|bar_info
index|[
name|ntb_mw_to_bar
argument_list|(
name|ntb
argument_list|,
name|ntb
operator|->
name|b2b_mw_idx
argument_list|)
index|]
expr_stmt|;
name|regoff
operator|=
name|XEON_SHADOW_PDOORBELL_OFFSET
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|bar
operator|->
name|pci_bus_tag
operator|!=
name|X86_BUS_SPACE_IO
argument_list|,
operator|(
literal|"uh oh"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|sz_out
operator|=
name|ntb
operator|->
name|reg
operator|->
name|db_size
expr_stmt|;
comment|/* HACK: Specific to current x86 bus implementation. */
return|return
operator|(
operator|(
name|uint64_t
operator|)
name|bar
operator|->
name|pci_bus_handle
operator|+
name|regoff
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_query_link_status() - return the hardware link status  * @ndev: pointer to ntb_device instance  *  * Returns true if the hardware is connected to the remote system  *  * RETURNS: true or false based on the hardware link state  */
end_comment

begin_function
name|bool
name|ntb_query_link_status
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
return|return
operator|(
name|ntb
operator|->
name|link_status
operator|==
name|NTB_LINK_UP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_bar_parameters
parameter_list|(
name|struct
name|ntb_pci_bar_info
modifier|*
name|bar
parameter_list|)
block|{
name|bar
operator|->
name|pci_bus_tag
operator|=
name|rman_get_bustag
argument_list|(
name|bar
operator|->
name|pci_resource
argument_list|)
expr_stmt|;
name|bar
operator|->
name|pci_bus_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|bar
operator|->
name|pci_resource
argument_list|)
expr_stmt|;
name|bar
operator|->
name|pbase
operator|=
name|rman_get_start
argument_list|(
name|bar
operator|->
name|pci_resource
argument_list|)
expr_stmt|;
name|bar
operator|->
name|size
operator|=
name|rman_get_size
argument_list|(
name|bar
operator|->
name|pci_resource
argument_list|)
expr_stmt|;
name|bar
operator|->
name|vbase
operator|=
name|rman_get_virtual
argument_list|(
name|bar
operator|->
name|pci_resource
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|device_t
name|ntb_get_device
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
return|return
operator|(
name|ntb
operator|->
name|device
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Export HW-specific errata information. */
end_comment

begin_function
name|bool
name|ntb_has_feature
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
name|uint64_t
name|feature
parameter_list|)
block|{
return|return
operator|(
name|HAS_FEATURE
argument_list|(
name|feature
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

