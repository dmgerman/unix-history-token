begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2017 Alexander Motin<mav@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * The Non-Transparent Bridge (NTB) is a device that allows you to connect  * two or more systems using a PCI-e links, providing remote memory access.  *  * This module contains a driver for NTBs in PLX/Avago/Broadcom PCIe bridges.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|"../ntb.h"
end_include

begin_define
define|#
directive|define
name|PLX_MAX_BARS
value|4
end_define

begin_comment
comment|/* There are at most 4 data BARs. */
end_comment

begin_define
define|#
directive|define
name|PLX_NUM_SPAD
value|8
end_define

begin_comment
comment|/* There are 8 scratchpads. */
end_comment

begin_define
define|#
directive|define
name|PLX_NUM_SPAD_PATT
value|4
end_define

begin_comment
comment|/* Use test pattern as 4 more. */
end_comment

begin_define
define|#
directive|define
name|PLX_NUM_DB
value|16
end_define

begin_comment
comment|/* There are 16 doorbells. */
end_comment

begin_struct
struct|struct
name|ntb_plx_mw_info
block|{
name|int
name|mw_bar
decl_stmt|;
name|int
name|mw_64bit
decl_stmt|;
name|int
name|mw_rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|mw_res
decl_stmt|;
name|vm_paddr_t
name|mw_pbase
decl_stmt|;
name|caddr_t
name|mw_vbase
decl_stmt|;
name|vm_size_t
name|mw_size
decl_stmt|;
name|vm_memattr_t
name|mw_map_mode
decl_stmt|;
name|bus_addr_t
name|mw_xlat_addr
decl_stmt|;
name|size_t
name|mw_xlat_size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_plx_softc
block|{
comment|/* ntb.c context. Do not move! Must go first! */
name|void
modifier|*
name|ntb_store
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|struct
name|resource
modifier|*
name|conf_res
decl_stmt|;
name|int
name|conf_rid
decl_stmt|;
name|u_int
name|ntx
decl_stmt|;
comment|/* NTx number within chip. */
name|u_int
name|link
decl_stmt|;
comment|/* Link v/s Virtual side. */
name|u_int
name|port
decl_stmt|;
comment|/* Port number within chip. */
name|int
name|int_rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|int_res
decl_stmt|;
name|void
modifier|*
name|int_tag
decl_stmt|;
name|struct
name|ntb_plx_mw_info
name|mw_info
index|[
name|PLX_MAX_BARS
index|]
decl_stmt|;
name|int
name|mw_count
decl_stmt|;
comment|/* Number of memory windows. */
name|int
name|spad_count1
decl_stmt|;
comment|/* Number of standard spads. */
name|int
name|spad_count2
decl_stmt|;
comment|/* Number of extra spads. */
name|uint32_t
name|spad_off1
decl_stmt|;
comment|/* Offset of our spads. */
name|uint32_t
name|spad_off2
decl_stmt|;
comment|/* Offset of our extra spads. */
name|uint32_t
name|spad_offp1
decl_stmt|;
comment|/* Offset of peer spads. */
name|uint32_t
name|spad_offp2
decl_stmt|;
comment|/* Offset of peer extra spads. */
comment|/* Parameters of window shared with peer config access in B2B mode. */
name|int
name|b2b_mw
decl_stmt|;
comment|/* Shared window number. */
name|uint64_t
name|b2b_off
decl_stmt|;
comment|/* Offset in shared window. */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PLX_NT0_BASE
value|0x3E000
end_define

begin_define
define|#
directive|define
name|PLX_NT1_BASE
value|0x3C000
end_define

begin_define
define|#
directive|define
name|PLX_NTX_BASE
parameter_list|(
name|sc
parameter_list|)
value|((sc)->ntx ? PLX_NT1_BASE : PLX_NT0_BASE)
end_define

begin_define
define|#
directive|define
name|PLX_NTX_LINK_OFFSET
value|0x01000
end_define

begin_comment
comment|/* Bases of NTx our/peer interface registers */
end_comment

begin_define
define|#
directive|define
name|PLX_NTX_OUR
parameter_list|(
name|sc
parameter_list|)
define|\
value|(PLX_NTX_BASE(sc) + ((sc)->link ? PLX_NTX_LINK_OFFSET : 0))
end_define

begin_define
define|#
directive|define
name|PLX_NTX_PEER
parameter_list|(
name|sc
parameter_list|)
define|\
value|(PLX_NTX_BASE(sc) + ((sc)->link ? 0 : PLX_NTX_LINK_OFFSET))
end_define

begin_comment
comment|/* Read/write NTx our interface registers */
end_comment

begin_define
define|#
directive|define
name|NTX_READ
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
define|\
value|bus_read_4((sc)->conf_res, PLX_NTX_OUR(sc) + (reg))
end_define

begin_define
define|#
directive|define
name|NTX_WRITE
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_write_4((sc)->conf_res, PLX_NTX_OUR(sc) + (reg), (val))
end_define

begin_comment
comment|/* Read/write NTx peer interface registers */
end_comment

begin_define
define|#
directive|define
name|PNTX_READ
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
define|\
value|bus_read_4((sc)->conf_res, PLX_NTX_PEER(sc) + (reg))
end_define

begin_define
define|#
directive|define
name|PNTX_WRITE
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_write_4((sc)->conf_res, PLX_NTX_PEER(sc) + (reg), (val))
end_define

begin_comment
comment|/* Read/write B2B NTx registers */
end_comment

begin_define
define|#
directive|define
name|BNTX_READ
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
define|\
value|bus_read_4((sc)->mw_info[(sc)->b2b_mw].mw_res,	\     PLX_NTX_BASE(sc) + (reg))
end_define

begin_define
define|#
directive|define
name|BNTX_WRITE
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_write_4((sc)->mw_info[(sc)->b2b_mw].mw_res,	\     PLX_NTX_BASE(sc) + (reg), (val))
end_define

begin_function_decl
specifier|static
name|int
name|ntb_plx_init
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_plx_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_plx_mw_set_trans_internal
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|unsigned
name|mw_idx
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|ntb_plx_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
switch|switch
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
literal|0x87a010b5
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PLX Non-Transparent Bridge NT0 Link"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
case|case
literal|0x87a110b5
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PLX Non-Transparent Bridge NT1 Link"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
case|case
literal|0x87b010b5
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PLX Non-Transparent Bridge NT0 Virtual"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
case|case
literal|0x87b110b5
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PLX Non-Transparent Bridge NT1 Virtual"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_plx_init
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ntb_plx_mw_info
modifier|*
name|mw
decl_stmt|;
name|uint64_t
name|val64
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|b2b_mw
operator|>=
literal|0
condition|)
block|{
comment|/* Set peer BAR0/1 size and address for B2B NTx access. */
name|mw
operator|=
operator|&
name|sc
operator|->
name|mw_info
index|[
name|sc
operator|->
name|b2b_mw
index|]
expr_stmt|;
if|if
condition|(
name|mw
operator|->
name|mw_64bit
condition|)
block|{
name|PNTX_WRITE
argument_list|(
name|sc
argument_list|,
literal|0xe4
argument_list|,
literal|0x3
argument_list|)
expr_stmt|;
comment|/* 64-bit */
name|val64
operator|=
literal|0x2000000000000000
operator|*
name|mw
operator|->
name|mw_bar
operator||
literal|0x4
expr_stmt|;
name|PNTX_WRITE
argument_list|(
name|sc
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|val64
argument_list|)
expr_stmt|;
name|PNTX_WRITE
argument_list|(
name|sc
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
operator|+
literal|4
argument_list|,
name|val64
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PNTX_WRITE
argument_list|(
name|sc
argument_list|,
literal|0xe4
argument_list|,
literal|0x2
argument_list|)
expr_stmt|;
comment|/* 32-bit */
name|val
operator|=
literal|0x20000000
operator|*
name|mw
operator|->
name|mw_bar
expr_stmt|;
name|PNTX_WRITE
argument_list|(
name|sc
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* Set Virtual to Link address translation for B2B. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mw_count
condition|;
name|i
operator|++
control|)
block|{
name|mw
operator|=
operator|&
name|sc
operator|->
name|mw_info
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mw
operator|->
name|mw_64bit
condition|)
block|{
name|val64
operator|=
literal|0x2000000000000000
operator|*
name|mw
operator|->
name|mw_bar
expr_stmt|;
name|NTX_WRITE
argument_list|(
name|sc
argument_list|,
literal|0xc3c
operator|+
operator|(
name|mw
operator|->
name|mw_bar
operator|-
literal|2
operator|)
operator|*
literal|4
argument_list|,
name|val64
argument_list|)
expr_stmt|;
name|NTX_WRITE
argument_list|(
name|sc
argument_list|,
literal|0xc3c
operator|+
operator|(
name|mw
operator|->
name|mw_bar
operator|-
literal|2
operator|)
operator|*
literal|4
operator|+
literal|4
argument_list|,
name|val64
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
literal|0x20000000
operator|*
name|mw
operator|->
name|mw_bar
expr_stmt|;
name|NTX_WRITE
argument_list|(
name|sc
argument_list|,
literal|0xc3c
operator|+
operator|(
name|mw
operator|->
name|mw_bar
operator|-
literal|2
operator|)
operator|*
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Enable Link Interface LUT entry 0 for 0:0.0. */
name|PNTX_WRITE
argument_list|(
name|sc
argument_list|,
literal|0xdb4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Enable Virtual Interface LUT entry 0 for 0:0.0 and 	 * entry 1 for our Requester ID reported by chip. 	 */
name|val
operator|=
operator|(
name|NTX_READ
argument_list|(
name|sc
argument_list|,
literal|0xc90
argument_list|)
operator|<<
literal|16
operator|)
operator||
literal|0x00010001
expr_stmt|;
name|NTX_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|link
condition|?
literal|0xdb4
else|:
literal|0xd94
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Set Link to Virtual address translation. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mw_count
condition|;
name|i
operator|++
control|)
block|{
name|mw
operator|=
operator|&
name|sc
operator|->
name|mw_info
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mw
operator|->
name|mw_xlat_size
operator|!=
literal|0
condition|)
name|ntb_plx_mw_set_trans_internal
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|b2b_mw
operator|>=
literal|0
condition|)
name|PNTX_WRITE
argument_list|(
name|sc
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_plx_isr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|arg
decl_stmt|;
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|ntb_db_event
argument_list|(
operator|(
name|device_t
operator|)
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|NTX_READ
argument_list|(
name|sc
argument_list|,
literal|0xfe0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
return|return;
name|NTX_WRITE
argument_list|(
name|sc
argument_list|,
literal|0xfe0
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|1
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Correctable Error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|2
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Uncorrectable Error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|4
condition|)
block|{
comment|/* DL_Down resets link side registers, have to reinit. */
name|ntb_plx_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ntb_link_event
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
literal|8
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Uncorrectable Error Message Drop\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_plx_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * XXX: This hardware supports MSI, but I found it unusable. 	 * It generates new MSI only when doorbell register goes from 	 * zero, but does not generate it when another bit is set or on 	 * partial clear.  It makes operation very racy and unreliable. 	 * The data book mentions some mask juggling magic to workaround 	 * that, but I failed to make it work. 	 */
name|sc
operator|->
name|int_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|int_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|int_rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|int_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_alloc_resource failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|int_res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_MISC
argument_list|,
name|NULL
argument_list|,
name|ntb_plx_isr
argument_list|,
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|int_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_setup_intr failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|NTX_WRITE
argument_list|(
name|sc
argument_list|,
literal|0xfe0
argument_list|,
literal|0xf
argument_list|)
expr_stmt|;
comment|/* Clear link interrupts. */
name|NTX_WRITE
argument_list|(
name|sc
argument_list|,
literal|0xfe4
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Unmask link interrupts. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_plx_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|NTX_WRITE
argument_list|(
name|sc
argument_list|,
literal|0xfe4
argument_list|,
literal|0xf
argument_list|)
expr_stmt|;
comment|/* Mask link interrupts. */
if|if
condition|(
name|sc
operator|->
name|int_res
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|int_res
argument_list|,
name|sc
operator|->
name|int_tag
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|int_rid
argument_list|,
name|sc
operator|->
name|int_res
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_plx_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ntb_plx_mw_info
modifier|*
name|mw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
comment|/* Identify what we are (what side of what NTx). */
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0xc8c
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ntx
operator|=
operator|(
name|val
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
name|sc
operator|->
name|link
operator|=
operator|(
name|val
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* Get access to whole 256KB of chip configuration space via BAR0/1. */
name|sc
operator|->
name|conf_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|conf_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|conf_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|conf_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't allocate configuration BAR.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|pmap_change_attr
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|rman_get_start
argument_list|(
name|sc
operator|->
name|conf_res
argument_list|)
argument_list|,
name|rman_get_size
argument_list|(
name|sc
operator|->
name|conf_res
argument_list|)
argument_list|,
name|VM_MEMATTR_UNCACHEABLE
argument_list|)
expr_stmt|;
comment|/* Identify chip port we are connected to. */
name|val
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|conf_res
argument_list|,
literal|0x360
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
operator|=
operator|(
name|val
operator|>>
operator|(
operator|(
name|sc
operator|->
name|ntx
operator|==
literal|0
operator|)
condition|?
literal|8
else|:
literal|16
operator|)
operator|)
operator|&
literal|0x1f
expr_stmt|;
comment|/* Find configured memory windows at BAR2-5. */
name|sc
operator|->
name|mw_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<=
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|mw
operator|=
operator|&
name|sc
operator|->
name|mw_info
index|[
name|sc
operator|->
name|mw_count
index|]
expr_stmt|;
name|mw
operator|->
name|mw_bar
operator|=
name|i
expr_stmt|;
name|mw
operator|->
name|mw_rid
operator|=
name|PCIR_BAR
argument_list|(
name|mw
operator|->
name|mw_bar
argument_list|)
expr_stmt|;
name|mw
operator|->
name|mw_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|mw
operator|->
name|mw_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mw
operator|->
name|mw_res
operator|==
name|NULL
condition|)
continue|continue;
name|mw
operator|->
name|mw_pbase
operator|=
name|rman_get_start
argument_list|(
name|mw
operator|->
name|mw_res
argument_list|)
expr_stmt|;
name|mw
operator|->
name|mw_size
operator|=
name|rman_get_size
argument_list|(
name|mw
operator|->
name|mw_res
argument_list|)
expr_stmt|;
name|mw
operator|->
name|mw_vbase
operator|=
name|rman_get_virtual
argument_list|(
name|mw
operator|->
name|mw_res
argument_list|)
expr_stmt|;
name|mw
operator|->
name|mw_map_mode
operator|=
name|VM_MEMATTR_UNCACHEABLE
expr_stmt|;
name|pmap_change_attr
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|mw
operator|->
name|mw_vbase
argument_list|,
name|mw
operator|->
name|mw_size
argument_list|,
name|mw
operator|->
name|mw_map_mode
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mw_count
operator|++
expr_stmt|;
comment|/* Skip over adjacent BAR for 64-bit BARs. */
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
name|mw
operator|->
name|mw_bar
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PCIM_BAR_MEM_TYPE
operator|)
operator|==
name|PCIM_BAR_MEM_64
condition|)
block|{
name|mw
operator|->
name|mw_64bit
operator|=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|/* Try to identify B2B mode. */
name|i
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"hint.%s.%d.b2b"
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|buf
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"NTB-to-Root Port mode (Link Interface)\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|b2b_mw
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"NTB-to-Root Port mode (Virtual Interface)\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|b2b_mw
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"NTB-to-NTB (back-to-back) mode\n"
argument_list|)
expr_stmt|;
comment|/* We need at least one memory window for B2B peer access. */
if|if
condition|(
name|sc
operator|->
name|mw_count
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No memory window BARs enabled.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sc
operator|->
name|b2b_mw
operator|=
name|sc
operator|->
name|mw_count
operator|-
literal|1
expr_stmt|;
comment|/* Use half of the window for B2B, but no less then 1MB. */
name|mw
operator|=
operator|&
name|sc
operator|->
name|mw_info
index|[
name|sc
operator|->
name|b2b_mw
index|]
expr_stmt|;
if|if
condition|(
name|mw
operator|->
name|mw_size
operator|>=
literal|2
operator|*
literal|1024
operator|*
literal|1024
condition|)
name|sc
operator|->
name|b2b_off
operator|=
name|mw
operator|->
name|mw_size
operator|/
literal|2
expr_stmt|;
else|else
name|sc
operator|->
name|b2b_off
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Use Physical Layer User Test Pattern as additional scratchpad. 	 * Make sure they are present and enabled by writing to them. 	 * XXX: Its a hack, but standard 8 registers are not enough. 	 */
if|if
condition|(
name|sc
operator|->
name|b2b_mw
operator|>=
literal|0
condition|)
block|{
name|sc
operator|->
name|spad_count1
operator|=
name|PLX_NUM_SPAD
expr_stmt|;
name|sc
operator|->
name|spad_off1
operator|=
name|PLX_NTX_OUR
argument_list|(
name|sc
argument_list|)
operator|+
literal|0xc6c
expr_stmt|;
name|sc
operator|->
name|spad_off2
operator|=
operator|(
name|sc
operator|->
name|ntx
operator|==
literal|0
operator|)
condition|?
literal|0x0020c
else|:
literal|0x0820c
expr_stmt|;
name|sc
operator|->
name|spad_offp1
operator|=
name|sc
operator|->
name|spad_off1
expr_stmt|;
name|sc
operator|->
name|spad_offp2
operator|=
name|sc
operator|->
name|spad_off2
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|conf_res
argument_list|,
name|sc
operator|->
name|spad_off2
argument_list|,
literal|0x12345678
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_read_4
argument_list|(
name|sc
operator|->
name|conf_res
argument_list|,
name|sc
operator|->
name|spad_off2
argument_list|)
operator|==
literal|0x12345678
condition|)
name|sc
operator|->
name|spad_count2
operator|=
name|PLX_NUM_SPAD_PATT
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|spad_count1
operator|=
name|PLX_NUM_SPAD
operator|/
literal|2
expr_stmt|;
name|sc
operator|->
name|spad_off1
operator|=
name|PLX_NTX_OUR
argument_list|(
name|sc
argument_list|)
operator|+
literal|0xc6c
expr_stmt|;
name|sc
operator|->
name|spad_off2
operator|=
operator|(
name|sc
operator|->
name|ntx
operator|==
literal|0
operator|)
condition|?
literal|0x0020c
else|:
literal|0x0820c
expr_stmt|;
name|sc
operator|->
name|spad_offp1
operator|=
name|sc
operator|->
name|spad_off1
expr_stmt|;
name|sc
operator|->
name|spad_offp2
operator|=
name|sc
operator|->
name|spad_off2
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link
condition|)
block|{
name|sc
operator|->
name|spad_off1
operator|+=
name|PLX_NUM_SPAD
operator|/
literal|2
operator|*
literal|4
expr_stmt|;
name|sc
operator|->
name|spad_off2
operator|+=
name|PLX_NUM_SPAD_PATT
operator|/
literal|2
operator|*
literal|4
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|spad_offp1
operator|+=
name|PLX_NUM_SPAD
operator|/
literal|2
operator|*
literal|4
expr_stmt|;
name|sc
operator|->
name|spad_offp2
operator|+=
name|PLX_NUM_SPAD_PATT
operator|/
literal|2
operator|*
literal|4
expr_stmt|;
block|}
name|bus_write_4
argument_list|(
name|sc
operator|->
name|conf_res
argument_list|,
name|sc
operator|->
name|spad_off2
argument_list|,
literal|0x12345678
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_read_4
argument_list|(
name|sc
operator|->
name|conf_res
argument_list|,
name|sc
operator|->
name|spad_off2
argument_list|)
operator|==
literal|0x12345678
condition|)
name|sc
operator|->
name|spad_count2
operator|=
name|PLX_NUM_SPAD_PATT
operator|/
literal|2
expr_stmt|;
block|}
comment|/* Apply static part of NTB configuration. */
name|ntb_plx_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Allocate and setup interrupts. */
name|error
operator|=
name|ntb_plx_setup_intr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* Attach children to this controller */
name|error
operator|=
name|ntb_register_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|ntb_plx_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_plx_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ntb_plx_mw_info
modifier|*
name|mw
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Detach& delete all children */
name|ntb_unregister_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Disable and free interrupts. */
name|ntb_plx_teardown_intr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Free memory resources. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mw_count
condition|;
name|i
operator|++
control|)
block|{
name|mw
operator|=
operator|&
name|sc
operator|->
name|mw_info
index|[
name|i
index|]
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|mw
operator|->
name|mw_rid
argument_list|,
name|mw
operator|->
name|mw_res
argument_list|)
expr_stmt|;
block|}
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|conf_rid
argument_list|,
name|sc
operator|->
name|conf_res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ntb_plx_link_is_up
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|enum
name|ntb_speed
modifier|*
name|speed
parameter_list|,
name|enum
name|ntb_width
modifier|*
name|width
parameter_list|)
block|{
name|uint16_t
name|link
decl_stmt|;
name|link
operator|=
name|pcie_read_config
argument_list|(
name|dev
argument_list|,
name|PCIER_LINK_STA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|speed
operator|!=
name|NULL
condition|)
operator|*
name|speed
operator|=
operator|(
name|link
operator|&
name|PCIEM_LINK_STA_SPEED
operator|)
expr_stmt|;
if|if
condition|(
name|width
operator|!=
name|NULL
condition|)
operator|*
name|width
operator|=
operator|(
name|link
operator|&
name|PCIEM_LINK_STA_WIDTH
operator|)
operator|>>
literal|4
expr_stmt|;
return|return
operator|(
operator|(
name|link
operator|&
name|PCIEM_LINK_STA_WIDTH
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_plx_link_enable
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|enum
name|ntb_speed
name|speed
name|__unused
parameter_list|,
name|enum
name|ntb_width
name|width
name|__unused
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|,
name|val
decl_stmt|;
comment|/* The fact that we see the Link Interface means link is enabled. */
if|if
condition|(
name|sc
operator|->
name|link
condition|)
block|{
name|ntb_link_event
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|reg
operator|=
operator|(
name|sc
operator|->
name|port
operator|<
literal|8
operator|)
condition|?
literal|0x00208
else|:
literal|0x08208
expr_stmt|;
name|val
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|conf_res
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|(
literal|1
operator|<<
operator|(
name|sc
operator|->
name|port
operator|&
literal|7
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* If already enabled, generate fake link event and exit. */
name|ntb_link_event
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|val
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|sc
operator|->
name|port
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|conf_res
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_plx_link_disable
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|,
name|val
decl_stmt|;
comment|/* Link disable for Link Interface would be suicidal. */
if|if
condition|(
name|sc
operator|->
name|link
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|reg
operator|=
operator|(
name|sc
operator|->
name|port
operator|<
literal|8
operator|)
condition|?
literal|0x00208
else|:
literal|0x08208
expr_stmt|;
name|val
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|conf_res
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
literal|1
operator|<<
operator|(
name|sc
operator|->
name|port
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|conf_res
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ntb_plx_link_enabled
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|,
name|val
decl_stmt|;
comment|/* The fact that we see the Link Interface means link is enabled. */
if|if
condition|(
name|sc
operator|->
name|link
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|reg
operator|=
operator|(
name|sc
operator|->
name|port
operator|<
literal|8
operator|)
condition|?
literal|0x00208
else|:
literal|0x08208
expr_stmt|;
name|val
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|conf_res
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|val
operator|&
operator|(
literal|1
operator|<<
operator|(
name|sc
operator|->
name|port
operator|&
literal|7
operator|)
operator|)
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|ntb_plx_mw_count
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|b2b_mw
operator|>=
literal|0
operator|&&
name|sc
operator|->
name|b2b_off
operator|==
literal|0
condition|)
return|return
operator|(
name|sc
operator|->
name|mw_count
operator|-
literal|1
operator|)
return|;
comment|/* B2B consumed whole window. */
return|return
operator|(
name|sc
operator|->
name|mw_count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_plx_mw_get_range
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|unsigned
name|mw_idx
parameter_list|,
name|vm_paddr_t
modifier|*
name|base
parameter_list|,
name|caddr_t
modifier|*
name|vbase
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|size_t
modifier|*
name|align
parameter_list|,
name|size_t
modifier|*
name|align_size
parameter_list|,
name|bus_addr_t
modifier|*
name|plimit
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ntb_plx_mw_info
modifier|*
name|mw
decl_stmt|;
name|size_t
name|off
decl_stmt|;
if|if
condition|(
name|mw_idx
operator|>=
name|sc
operator|->
name|mw_count
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mw_idx
operator|==
name|sc
operator|->
name|b2b_mw
condition|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|->
name|b2b_off
operator|!=
literal|0
argument_list|,
operator|(
literal|"user shouldn't get non-shared b2b mw"
operator|)
argument_list|)
expr_stmt|;
name|off
operator|=
name|sc
operator|->
name|b2b_off
expr_stmt|;
block|}
name|mw
operator|=
operator|&
name|sc
operator|->
name|mw_info
index|[
name|mw_idx
index|]
expr_stmt|;
comment|/* Local to remote memory window parameters. */
if|if
condition|(
name|base
operator|!=
name|NULL
condition|)
operator|*
name|base
operator|=
name|mw
operator|->
name|mw_pbase
operator|+
name|off
expr_stmt|;
if|if
condition|(
name|vbase
operator|!=
name|NULL
condition|)
operator|*
name|vbase
operator|=
name|mw
operator|->
name|mw_vbase
operator|+
name|off
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|NULL
condition|)
operator|*
name|size
operator|=
name|mw
operator|->
name|mw_size
operator|-
name|off
expr_stmt|;
comment|/* 	 * Remote to local memory window translation address alignment. 	 * XXX: In B2B mode we can change window size (and so alignmet) 	 * live, but there is no way to report it, so report safe value. 	 */
if|if
condition|(
name|align
operator|!=
name|NULL
condition|)
operator|*
name|align
operator|=
name|mw
operator|->
name|mw_size
operator|-
name|off
expr_stmt|;
comment|/* 	 * Remote to local memory window size alignment. 	 * XXX: The chip has no limit registers.  In B2B case size must be 	 * power of 2 (since we can reprogram BAR size), but there is no way 	 * to report it, so report 1MB -- minimal BAR size.  In non-B2B case 	 * there is no control at all, so report the precofigured BAR size. 	 */
if|if
condition|(
name|align_size
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|b2b_mw
operator|>=
literal|0
condition|)
operator|*
name|align_size
operator|=
literal|1024
operator|*
literal|1024
expr_stmt|;
else|else
operator|*
name|align_size
operator|=
name|mw
operator|->
name|mw_size
operator|-
name|off
expr_stmt|;
block|}
comment|/* Remote to local memory window translation address upper limit. */
if|if
condition|(
name|plimit
operator|!=
name|NULL
condition|)
operator|*
name|plimit
operator|=
name|mw
operator|->
name|mw_64bit
condition|?
name|BUS_SPACE_MAXADDR
else|:
name|BUS_SPACE_MAXADDR_32BIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_plx_mw_set_trans_internal
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|unsigned
name|mw_idx
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ntb_plx_mw_info
modifier|*
name|mw
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|,
name|off
decl_stmt|,
name|size
decl_stmt|,
name|val64
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|mw
operator|=
operator|&
name|sc
operator|->
name|mw_info
index|[
name|mw_idx
index|]
expr_stmt|;
name|addr
operator|=
name|mw
operator|->
name|mw_xlat_addr
expr_stmt|;
name|size
operator|=
name|mw
operator|->
name|mw_xlat_size
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mw_idx
operator|==
name|sc
operator|->
name|b2b_mw
condition|)
block|{
name|off
operator|=
name|sc
operator|->
name|b2b_off
expr_stmt|;
name|KASSERT
argument_list|(
name|off
operator|!=
literal|0
argument_list|,
operator|(
literal|"user shouldn't get non-shared b2b mw"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * While generally we can set any BAR size on link side, 		 * for B2B shared window we can't go above preconfigured 		 * size due to BAR address alignment requirements. 		 */
if|if
condition|(
name|size
operator|>
name|mw
operator|->
name|mw_size
operator|-
name|off
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
comment|/* Round BAR size to next power of 2 or at least 1MB. */
if|if
condition|(
operator|!
name|powerof2
argument_list|(
name|size
argument_list|)
condition|)
name|size
operator|=
literal|1LL
operator|<<
name|flsll
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1024
operator|*
literal|1024
condition|)
name|size
operator|=
literal|1024
operator|*
literal|1024
expr_stmt|;
comment|/* Hardware requires addr aligned to BAR size. */
if|if
condition|(
operator|(
name|addr
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|mw
operator|->
name|mw_64bit
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|b2b_mw
operator|>=
literal|0
condition|)
block|{
comment|/* Set Link Interface BAR size and enable/disable it. */
name|val64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|val64
operator|=
operator|(
operator|~
operator|(
name|size
operator|-
literal|1
operator|)
operator|&
operator|~
literal|0xfffff
operator|)
expr_stmt|;
name|val64
operator||=
literal|0x4
expr_stmt|;
name|PNTX_WRITE
argument_list|(
name|sc
argument_list|,
literal|0xe8
operator|+
operator|(
name|mw
operator|->
name|mw_bar
operator|-
literal|2
operator|)
operator|*
literal|4
argument_list|,
name|val64
argument_list|)
expr_stmt|;
name|PNTX_WRITE
argument_list|(
name|sc
argument_list|,
literal|0xe8
operator|+
operator|(
name|mw
operator|->
name|mw_bar
operator|-
literal|2
operator|)
operator|*
literal|4
operator|+
literal|4
argument_list|,
name|val64
operator|>>
literal|32
argument_list|)
expr_stmt|;
comment|/* Set Link Interface BAR address. */
name|val64
operator|=
literal|0x2000000000000000
operator|*
name|mw
operator|->
name|mw_bar
operator|+
name|off
expr_stmt|;
name|val64
operator||=
literal|0x4
expr_stmt|;
name|PNTX_WRITE
argument_list|(
name|sc
argument_list|,
name|PCIR_BAR
argument_list|(
name|mw
operator|->
name|mw_bar
argument_list|)
argument_list|,
name|val64
argument_list|)
expr_stmt|;
name|PNTX_WRITE
argument_list|(
name|sc
argument_list|,
name|PCIR_BAR
argument_list|(
name|mw
operator|->
name|mw_bar
argument_list|)
operator|+
literal|4
argument_list|,
name|val64
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
comment|/* Set Virtual Interface BARs address translation */
name|PNTX_WRITE
argument_list|(
name|sc
argument_list|,
literal|0xc3c
operator|+
operator|(
name|mw
operator|->
name|mw_bar
operator|-
literal|2
operator|)
operator|*
literal|4
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|PNTX_WRITE
argument_list|(
name|sc
argument_list|,
literal|0xc3c
operator|+
operator|(
name|mw
operator|->
name|mw_bar
operator|-
literal|2
operator|)
operator|*
literal|4
operator|+
literal|4
argument_list|,
name|addr
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make sure we fit into 32-bit address space. */
if|if
condition|(
operator|(
name|addr
operator|&
name|UINT32_MAX
operator|)
operator|!=
name|addr
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|addr
operator|+
name|size
operator|)
operator|&
name|UINT32_MAX
operator|)
operator|!=
operator|(
name|addr
operator|+
name|size
operator|)
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|b2b_mw
operator|>=
literal|0
condition|)
block|{
comment|/* Set Link Interface BAR size and enable/disable it. */
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|val
operator|=
operator|(
operator|~
operator|(
name|size
operator|-
literal|1
operator|)
operator|&
operator|~
literal|0xfffff
operator|)
expr_stmt|;
name|PNTX_WRITE
argument_list|(
name|sc
argument_list|,
literal|0xe8
operator|+
operator|(
name|mw
operator|->
name|mw_bar
operator|-
literal|2
operator|)
operator|*
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Set Link Interface BAR address. */
name|val64
operator|=
literal|0x20000000
operator|*
name|mw
operator|->
name|mw_bar
operator|+
name|off
expr_stmt|;
name|PNTX_WRITE
argument_list|(
name|sc
argument_list|,
name|PCIR_BAR
argument_list|(
name|mw
operator|->
name|mw_bar
argument_list|)
argument_list|,
name|val64
argument_list|)
expr_stmt|;
block|}
comment|/* Set Virtual Interface BARs address translation */
name|PNTX_WRITE
argument_list|(
name|sc
argument_list|,
literal|0xc3c
operator|+
operator|(
name|mw
operator|->
name|mw_bar
operator|-
literal|2
operator|)
operator|*
literal|4
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_plx_mw_set_trans
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|unsigned
name|mw_idx
parameter_list|,
name|bus_addr_t
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ntb_plx_mw_info
modifier|*
name|mw
decl_stmt|;
if|if
condition|(
name|mw_idx
operator|>=
name|sc
operator|->
name|mw_count
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mw
operator|=
operator|&
name|sc
operator|->
name|mw_info
index|[
name|mw_idx
index|]
expr_stmt|;
name|mw
operator|->
name|mw_xlat_addr
operator|=
name|addr
expr_stmt|;
name|mw
operator|->
name|mw_xlat_size
operator|=
name|size
expr_stmt|;
return|return
operator|(
name|ntb_plx_mw_set_trans_internal
argument_list|(
name|dev
argument_list|,
name|mw_idx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_plx_mw_clear_trans
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|unsigned
name|mw_idx
parameter_list|)
block|{
return|return
operator|(
name|ntb_plx_mw_set_trans
argument_list|(
name|dev
argument_list|,
name|mw_idx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_plx_mw_get_wc
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|unsigned
name|idx
parameter_list|,
name|vm_memattr_t
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ntb_plx_mw_info
modifier|*
name|mw
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
name|sc
operator|->
name|mw_count
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mw
operator|=
operator|&
name|sc
operator|->
name|mw_info
index|[
name|idx
index|]
expr_stmt|;
operator|*
name|mode
operator|=
name|mw
operator|->
name|mw_map_mode
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_plx_mw_set_wc
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|unsigned
name|idx
parameter_list|,
name|vm_memattr_t
name|mode
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ntb_plx_mw_info
modifier|*
name|mw
decl_stmt|;
name|uint64_t
name|off
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
name|sc
operator|->
name|mw_count
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mw
operator|=
operator|&
name|sc
operator|->
name|mw_info
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|mw
operator|->
name|mw_map_mode
operator|==
name|mode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|sc
operator|->
name|b2b_mw
condition|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|->
name|b2b_off
operator|!=
literal|0
argument_list|,
operator|(
literal|"user shouldn't get non-shared b2b mw"
operator|)
argument_list|)
expr_stmt|;
name|off
operator|=
name|sc
operator|->
name|b2b_off
expr_stmt|;
block|}
name|rc
operator|=
name|pmap_change_attr
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|mw
operator|->
name|mw_vbase
operator|+
name|off
argument_list|,
name|mw
operator|->
name|mw_size
operator|-
name|off
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|mw
operator|->
name|mw_map_mode
operator|=
name|mode
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|ntb_plx_spad_count
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|sc
operator|->
name|spad_count1
operator|+
name|sc
operator|->
name|spad_count2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_plx_spad_write
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int
name|off
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
name|sc
operator|->
name|spad_count1
operator|+
name|sc
operator|->
name|spad_count2
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|idx
operator|<
name|sc
operator|->
name|spad_count1
condition|)
name|off
operator|=
name|sc
operator|->
name|spad_off1
operator|+
name|idx
operator|*
literal|4
expr_stmt|;
else|else
name|off
operator|=
name|sc
operator|->
name|spad_off2
operator|+
operator|(
name|idx
operator|-
name|sc
operator|->
name|spad_count1
operator|)
operator|*
literal|4
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|conf_res
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_plx_spad_clear
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|spad_count1
operator|+
name|sc
operator|->
name|spad_count2
condition|;
name|i
operator|++
control|)
name|ntb_plx_spad_write
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_plx_spad_read
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int
name|off
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
name|sc
operator|->
name|spad_count1
operator|+
name|sc
operator|->
name|spad_count2
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|idx
operator|<
name|sc
operator|->
name|spad_count1
condition|)
name|off
operator|=
name|sc
operator|->
name|spad_off1
operator|+
name|idx
operator|*
literal|4
expr_stmt|;
else|else
name|off
operator|=
name|sc
operator|->
name|spad_off2
operator|+
operator|(
name|idx
operator|-
name|sc
operator|->
name|spad_count1
operator|)
operator|*
literal|4
expr_stmt|;
operator|*
name|val
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|conf_res
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_plx_peer_spad_write
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int
name|off
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
name|sc
operator|->
name|spad_count1
operator|+
name|sc
operator|->
name|spad_count2
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|idx
operator|<
name|sc
operator|->
name|spad_count1
condition|)
name|off
operator|=
name|sc
operator|->
name|spad_offp1
operator|+
name|idx
operator|*
literal|4
expr_stmt|;
else|else
name|off
operator|=
name|sc
operator|->
name|spad_offp2
operator|+
operator|(
name|idx
operator|-
name|sc
operator|->
name|spad_count1
operator|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|b2b_mw
operator|>=
literal|0
condition|)
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mw_info
index|[
name|sc
operator|->
name|b2b_mw
index|]
operator|.
name|mw_res
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|bus_write_4
argument_list|(
name|sc
operator|->
name|conf_res
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_plx_peer_spad_read
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int
name|off
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
name|sc
operator|->
name|spad_count1
operator|+
name|sc
operator|->
name|spad_count2
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|idx
operator|<
name|sc
operator|->
name|spad_count1
condition|)
name|off
operator|=
name|sc
operator|->
name|spad_offp1
operator|+
name|idx
operator|*
literal|4
expr_stmt|;
else|else
name|off
operator|=
name|sc
operator|->
name|spad_offp2
operator|+
operator|(
name|idx
operator|-
name|sc
operator|->
name|spad_count1
operator|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|b2b_mw
operator|>=
literal|0
condition|)
operator|*
name|val
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mw_info
index|[
name|sc
operator|->
name|b2b_mw
index|]
operator|.
name|mw_res
argument_list|,
name|off
argument_list|)
expr_stmt|;
else|else
operator|*
name|val
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|conf_res
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|ntb_plx_db_valid_mask
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
operator|(
literal|1LL
operator|<<
name|PLX_NUM_DB
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_plx_db_vector_count
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|ntb_plx_db_vector_mask
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint32_t
name|vector
parameter_list|)
block|{
if|if
condition|(
name|vector
operator|>
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|(
literal|1LL
operator|<<
name|PLX_NUM_DB
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_plx_db_clear
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint64_t
name|bits
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|NTX_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|link
condition|?
literal|0xc60
else|:
literal|0xc50
argument_list|,
name|bits
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_plx_db_clear_mask
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint64_t
name|bits
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|NTX_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|link
condition|?
literal|0xc68
else|:
literal|0xc58
argument_list|,
name|bits
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|ntb_plx_db_read
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|NTX_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|link
condition|?
literal|0xc5c
else|:
literal|0xc4c
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_plx_db_set_mask
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint64_t
name|bits
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|NTX_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|link
condition|?
literal|0xc64
else|:
literal|0xc54
argument_list|,
name|bits
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_plx_peer_db_addr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|bus_addr_t
modifier|*
name|db_addr
parameter_list|,
name|vm_size_t
modifier|*
name|db_size
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ntb_plx_mw_info
modifier|*
name|mw
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|db_addr
operator|!=
name|NULL
operator|&&
name|db_size
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"must be non-NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|b2b_mw
operator|>=
literal|0
condition|)
block|{
name|mw
operator|=
operator|&
name|sc
operator|->
name|mw_info
index|[
name|sc
operator|->
name|b2b_mw
index|]
expr_stmt|;
operator|*
name|db_addr
operator|=
operator|(
name|uint64_t
operator|)
name|mw
operator|->
name|mw_pbase
operator|+
name|PLX_NTX_BASE
argument_list|(
name|sc
argument_list|)
operator|+
literal|0xc4c
expr_stmt|;
block|}
else|else
block|{
operator|*
name|db_addr
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|conf_res
argument_list|)
operator|+
name|PLX_NTX_BASE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|*
name|db_addr
operator|+=
name|sc
operator|->
name|link
condition|?
literal|0xc4c
else|:
literal|0xc5c
expr_stmt|;
block|}
operator|*
name|db_size
operator|=
literal|4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_plx_peer_db_set
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint64_t
name|bit
parameter_list|)
block|{
name|struct
name|ntb_plx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|b2b_mw
operator|>=
literal|0
condition|)
name|BNTX_WRITE
argument_list|(
name|sc
argument_list|,
literal|0xc4c
argument_list|,
name|bit
argument_list|)
expr_stmt|;
else|else
name|NTX_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|link
condition|?
literal|0xc4c
else|:
literal|0xc5c
argument_list|,
name|bit
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ntb_plx_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ntb_plx_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ntb_plx_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ntb_plx_detach
argument_list|)
block|,
comment|/* NTB interface */
name|DEVMETHOD
argument_list|(
name|ntb_link_is_up
argument_list|,
name|ntb_plx_link_is_up
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_link_enable
argument_list|,
name|ntb_plx_link_enable
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_link_disable
argument_list|,
name|ntb_plx_link_disable
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_link_enabled
argument_list|,
name|ntb_plx_link_enabled
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_mw_count
argument_list|,
name|ntb_plx_mw_count
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_mw_get_range
argument_list|,
name|ntb_plx_mw_get_range
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_mw_set_trans
argument_list|,
name|ntb_plx_mw_set_trans
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_mw_clear_trans
argument_list|,
name|ntb_plx_mw_clear_trans
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_mw_get_wc
argument_list|,
name|ntb_plx_mw_get_wc
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_mw_set_wc
argument_list|,
name|ntb_plx_mw_set_wc
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_spad_count
argument_list|,
name|ntb_plx_spad_count
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_spad_clear
argument_list|,
name|ntb_plx_spad_clear
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_spad_write
argument_list|,
name|ntb_plx_spad_write
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_spad_read
argument_list|,
name|ntb_plx_spad_read
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_peer_spad_write
argument_list|,
name|ntb_plx_peer_spad_write
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_peer_spad_read
argument_list|,
name|ntb_plx_peer_spad_read
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_db_valid_mask
argument_list|,
name|ntb_plx_db_valid_mask
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_db_vector_count
argument_list|,
name|ntb_plx_db_vector_count
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_db_vector_mask
argument_list|,
name|ntb_plx_db_vector_mask
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_db_clear
argument_list|,
name|ntb_plx_db_clear
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_db_clear_mask
argument_list|,
name|ntb_plx_db_clear_mask
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_db_read
argument_list|,
name|ntb_plx_db_read
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_db_set_mask
argument_list|,
name|ntb_plx_db_set_mask
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_peer_db_addr
argument_list|,
name|ntb_plx_peer_db_addr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ntb_peer_db_set
argument_list|,
name|ntb_plx_peer_db_set
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|DEFINE_CLASS_0
argument_list|(
name|ntb_hw
argument_list|,
name|ntb_plx_driver
argument_list|,
name|ntb_plx_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_plx_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ntb_hw_plx
argument_list|,
name|pci
argument_list|,
name|ntb_plx_driver
argument_list|,
name|ntb_hw_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ntb_hw_plx
argument_list|,
name|ntb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ntb_hw_plx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

