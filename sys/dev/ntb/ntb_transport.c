begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Alexander Motin<mav@FreeBSD.org>  * Copyright (C) 2013 Intel Corporation  * Copyright (C) 2015 EMC Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * The Non-Transparent Bridge (NTB) is a device that allows you to connect  * two or more systems using a PCI-e links, providing remote memory access.  *  * This module contains a transport for sending and receiving messages by  * writing to remote memory window(s) provided by underlying NTB device.  *  * NOTE: Much of the code in this module is shared with Linux. Any patches may  * be picked up and redistributed in Linux with a dual GPL/BSD license.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bitset.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|"ntb.h"
end_include

begin_include
include|#
directive|include
file|"ntb_transport.h"
end_include

begin_define
define|#
directive|define
name|QP_SETSIZE
value|64
end_define

begin_expr_stmt
name|BITSET_DEFINE
argument_list|(
name|_qpset
argument_list|,
name|QP_SETSIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|test_bit
parameter_list|(
name|pos
parameter_list|,
name|addr
parameter_list|)
value|BIT_ISSET(QP_SETSIZE, (pos), (addr))
end_define

begin_define
define|#
directive|define
name|set_bit
parameter_list|(
name|pos
parameter_list|,
name|addr
parameter_list|)
value|BIT_SET(QP_SETSIZE, (pos), (addr))
end_define

begin_define
define|#
directive|define
name|clear_bit
parameter_list|(
name|pos
parameter_list|,
name|addr
parameter_list|)
value|BIT_CLR(QP_SETSIZE, (pos), (addr))
end_define

begin_define
define|#
directive|define
name|ffs_bit
parameter_list|(
name|addr
parameter_list|)
value|BIT_FFS(QP_SETSIZE, (addr))
end_define

begin_define
define|#
directive|define
name|KTR_NTB
value|KTR_SPARE3
end_define

begin_define
define|#
directive|define
name|NTB_TRANSPORT_VERSION
value|4
end_define

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|ntb_transport
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"ntb_transport"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|g_ntb_transport_debug_level
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ntb_transport.debug_level"
argument_list|,
operator|&
name|g_ntb_transport_debug_level
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_ntb_transport
argument_list|,
name|OID_AUTO
argument_list|,
name|debug_level
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|g_ntb_transport_debug_level
argument_list|,
literal|0
argument_list|,
literal|"ntb_transport log level -- higher is more verbose"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|ntb_printf
parameter_list|(
name|lvl
parameter_list|,
modifier|...
parameter_list|)
value|do {			\ 	if ((lvl)<= g_ntb_transport_debug_level) {	\ 		printf(__VA_ARGS__);			\ 	}						\ } while (0)
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|transport_mtu
init|=
literal|0x10000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|max_mw_size
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_QUAD
argument_list|(
literal|"hw.ntb_transport.max_mw_size"
argument_list|,
operator|&
name|max_mw_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UQUAD
argument_list|(
name|_hw_ntb_transport
argument_list|,
name|OID_AUTO
argument_list|,
name|max_mw_size
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|max_mw_size
argument_list|,
literal|0
argument_list|,
literal|"If enabled (non-zero), limit the size of large memory windows. "
literal|"Both sides of the NTB MUST set the same value here."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|max_num_clients
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ntb_transport.max_num_clients"
argument_list|,
operator|&
name|max_num_clients
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_ntb_transport
argument_list|,
name|OID_AUTO
argument_list|,
name|max_num_clients
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|max_num_clients
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of NTB transport clients.  "
literal|"0 (default) - use all available NTB memory windows; "
literal|"positive integer N - Limit to N memory windows."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|enable_xeon_watchdog
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ntb_transport.enable_xeon_watchdog"
argument_list|,
operator|&
name|enable_xeon_watchdog
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_ntb_transport
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_xeon_watchdog
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|enable_xeon_watchdog
argument_list|,
literal|0
argument_list|,
literal|"If non-zero, write a register every second to "
literal|"keep a watchdog from tearing down the NTB link"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STAILQ_HEAD
argument_list|(
name|ntb_queue_list
argument_list|,
name|ntb_queue_entry
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|uint32_t
name|ntb_q_idx_t
typedef|;
end_typedef

begin_struct
struct|struct
name|ntb_queue_entry
block|{
comment|/* ntb_queue list reference */
name|STAILQ_ENTRY
argument_list|(
argument|ntb_queue_entry
argument_list|)
name|entry
expr_stmt|;
comment|/* info on data to be transferred */
name|void
modifier|*
name|cb_data
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|struct
name|ntb_transport_qp
modifier|*
name|qp
decl_stmt|;
name|struct
name|ntb_payload_header
modifier|*
name|x_hdr
decl_stmt|;
name|ntb_q_idx_t
name|index
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_rx_info
block|{
name|ntb_q_idx_t
name|entry
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_transport_qp
block|{
name|struct
name|ntb_transport_ctx
modifier|*
name|transport
decl_stmt|;
name|device_t
name|ntb
decl_stmt|;
name|void
modifier|*
name|cb_data
decl_stmt|;
name|bool
name|client_ready
decl_stmt|;
specifier|volatile
name|bool
name|link_is_up
decl_stmt|;
name|uint8_t
name|qp_num
decl_stmt|;
comment|/* Only 64 QPs are allowed.  0-63 */
name|struct
name|ntb_rx_info
modifier|*
name|rx_info
decl_stmt|;
name|struct
name|ntb_rx_info
modifier|*
name|remote_rx_info
decl_stmt|;
name|void
function_decl|(
modifier|*
name|tx_handler
function_decl|)
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|qp_data
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
name|struct
name|ntb_queue_list
name|tx_free_q
decl_stmt|;
name|struct
name|mtx
name|ntb_tx_free_q_lock
decl_stmt|;
name|caddr_t
name|tx_mw
decl_stmt|;
name|bus_addr_t
name|tx_mw_phys
decl_stmt|;
name|ntb_q_idx_t
name|tx_index
decl_stmt|;
name|ntb_q_idx_t
name|tx_max_entry
decl_stmt|;
name|uint64_t
name|tx_max_frame
decl_stmt|;
name|void
function_decl|(
modifier|*
name|rx_handler
function_decl|)
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|qp_data
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
name|struct
name|ntb_queue_list
name|rx_post_q
decl_stmt|;
name|struct
name|ntb_queue_list
name|rx_pend_q
decl_stmt|;
comment|/* ntb_rx_q_lock: synchronize access to rx_XXXX_q */
name|struct
name|mtx
name|ntb_rx_q_lock
decl_stmt|;
name|struct
name|task
name|rxc_db_work
decl_stmt|;
name|struct
name|taskqueue
modifier|*
name|rxc_tq
decl_stmt|;
name|caddr_t
name|rx_buff
decl_stmt|;
name|ntb_q_idx_t
name|rx_index
decl_stmt|;
name|ntb_q_idx_t
name|rx_max_entry
decl_stmt|;
name|uint64_t
name|rx_max_frame
decl_stmt|;
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|enum
name|ntb_link_event
name|status
parameter_list|)
function_decl|;
name|struct
name|callout
name|link_work
decl_stmt|;
name|struct
name|callout
name|rx_full
decl_stmt|;
name|uint64_t
name|last_rx_no_buf
decl_stmt|;
comment|/* Stats */
name|uint64_t
name|rx_bytes
decl_stmt|;
name|uint64_t
name|rx_pkts
decl_stmt|;
name|uint64_t
name|rx_ring_empty
decl_stmt|;
name|uint64_t
name|rx_err_no_buf
decl_stmt|;
name|uint64_t
name|rx_err_oflow
decl_stmt|;
name|uint64_t
name|rx_err_ver
decl_stmt|;
name|uint64_t
name|tx_bytes
decl_stmt|;
name|uint64_t
name|tx_pkts
decl_stmt|;
name|uint64_t
name|tx_ring_full
decl_stmt|;
name|uint64_t
name|tx_err_no_buf
decl_stmt|;
name|struct
name|mtx
name|tx_lock
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_transport_mw
block|{
name|vm_paddr_t
name|phys_addr
decl_stmt|;
name|size_t
name|phys_size
decl_stmt|;
name|size_t
name|xlat_align
decl_stmt|;
name|size_t
name|xlat_align_size
decl_stmt|;
name|bus_addr_t
name|addr_limit
decl_stmt|;
comment|/* Tx buff is off vbase / phys_addr */
name|caddr_t
name|vbase
decl_stmt|;
name|size_t
name|xlat_size
decl_stmt|;
name|size_t
name|buff_size
decl_stmt|;
comment|/* Rx buff is off virt_addr / dma_addr */
name|caddr_t
name|virt_addr
decl_stmt|;
name|bus_addr_t
name|dma_addr
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_transport_ctx
block|{
name|device_t
name|dev
decl_stmt|;
name|device_t
name|ntb
decl_stmt|;
name|struct
name|ntb_transport_mw
modifier|*
name|mw_vec
decl_stmt|;
name|struct
name|ntb_transport_qp
modifier|*
name|qp_vec
decl_stmt|;
name|struct
name|_qpset
name|qp_bitmap
decl_stmt|;
name|struct
name|_qpset
name|qp_bitmap_free
decl_stmt|;
name|unsigned
name|mw_count
decl_stmt|;
name|unsigned
name|qp_count
decl_stmt|;
specifier|volatile
name|bool
name|link_is_up
decl_stmt|;
name|struct
name|callout
name|link_work
decl_stmt|;
name|struct
name|callout
name|link_watchdog
decl_stmt|;
name|struct
name|task
name|link_cleanup
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
name|NTBT_DESC_DONE_FLAG
init|=
literal|1
operator|<<
literal|0
block|,
name|NTBT_LINK_DOWN_FLAG
init|=
literal|1
operator|<<
literal|1
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|ntb_payload_header
block|{
name|ntb_q_idx_t
name|ver
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
comment|/* 	 * The order of this enum is part of the remote protocol.  Do not 	 * reorder without bumping protocol version (and it's probably best 	 * to keep the protocol in lock-step with the Linux NTB driver. 	 */
name|NTBT_VERSION
init|=
literal|0
block|,
name|NTBT_QP_LINKS
block|,
name|NTBT_NUM_QPS
block|,
name|NTBT_NUM_MWS
block|,
comment|/* 	 * N.B.: transport_link_work assumes MW1 enums = MW0 + 2. 	 */
name|NTBT_MW0_SZ_HIGH
block|,
name|NTBT_MW0_SZ_LOW
block|,
name|NTBT_MW1_SZ_HIGH
block|,
name|NTBT_MW1_SZ_LOW
block|,
name|NTBT_MAX_SPAD
block|,
comment|/* 	 * Some NTB-using hardware have a watchdog to work around NTB hangs; if 	 * a register or doorbell isn't written every few seconds, the link is 	 * torn down.  Write an otherwise unused register every few seconds to 	 * work around this watchdog. 	 */
name|NTBT_WATCHDOG_SPAD
init|=
literal|15
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|QP_TO_MW
parameter_list|(
name|nt
parameter_list|,
name|qp
parameter_list|)
value|((qp) % nt->mw_count)
end_define

begin_define
define|#
directive|define
name|NTB_QP_DEF_NUM_ENTRIES
value|100
end_define

begin_define
define|#
directive|define
name|NTB_LINK_DOWN_TIMEOUT
value|10
end_define

begin_function_decl
specifier|static
name|int
name|ntb_transport_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_transport_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_transport_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_init_queue
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
parameter_list|,
name|unsigned
name|int
name|qp_num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_process_tx
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_rxc_db
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_process_rxc
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_memcpy_rx
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ntb_rx_copy_callback
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_complete_rxc
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_doorbell_callback
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|vector
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_event_callback
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_link_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_set_mw
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
parameter_list|,
name|int
name|num_mw
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_free_mw
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
parameter_list|,
name|int
name|num_mw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_transport_setup_qp_mw
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
parameter_list|,
name|unsigned
name|int
name|qp_num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_qp_link_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_link_cleanup
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_link_cleanup_work
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_qp_link_down
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_qp_link_down_reset
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_qp_link_cleanup
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_send_link_down
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_list_add
parameter_list|(
name|struct
name|mtx
modifier|*
name|lock
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|ntb_queue_list
modifier|*
name|list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ntb_queue_entry
modifier|*
name|ntb_list_rm
parameter_list|(
name|struct
name|mtx
modifier|*
name|lock
parameter_list|,
name|struct
name|ntb_queue_list
modifier|*
name|list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ntb_queue_entry
modifier|*
name|ntb_list_mv
parameter_list|(
name|struct
name|mtx
modifier|*
name|lock
parameter_list|,
name|struct
name|ntb_queue_list
modifier|*
name|from
parameter_list|,
name|struct
name|ntb_queue_list
modifier|*
name|to
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xeon_link_watchdog_hb
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ntb_ctx_ops
name|ntb_transport_ops
init|=
block|{
operator|.
name|link_event
operator|=
name|ntb_transport_event_callback
block|,
operator|.
name|db_event
operator|=
name|ntb_transport_doorbell_callback
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NTB_T
argument_list|,
literal|"ntb_transport"
argument_list|,
literal|"ntb transport driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
specifier|inline
name|void
name|iowrite32
parameter_list|(
name|uint32_t
name|val
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|bus_space_write_4
argument_list|(
name|X86_BUS_SPACE_MEM
argument_list|,
literal|0
comment|/* HACK */
argument_list|,
operator|(
name|uintptr_t
operator|)
name|addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Transport Init and teardown */
end_comment

begin_function
specifier|static
name|void
name|xeon_link_watchdog_hb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
decl_stmt|;
name|nt
operator|=
name|arg
expr_stmt|;
name|NTB_SPAD_WRITE
argument_list|(
name|nt
operator|->
name|ntb
argument_list|,
name|NTBT_WATCHDOG_SPAD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|nt
operator|->
name|link_watchdog
argument_list|,
literal|1
operator|*
name|hz
argument_list|,
name|xeon_link_watchdog_hb
argument_list|,
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_transport_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"NTB Transport"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_transport_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|device_t
name|ntb
init|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ntb_transport_mw
modifier|*
name|mw
decl_stmt|;
name|uint64_t
name|qp_bitmap
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|nt
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|nt
operator|->
name|ntb
operator|=
name|ntb
expr_stmt|;
name|nt
operator|->
name|mw_count
operator|=
name|NTB_MW_COUNT
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|nt
operator|->
name|mw_vec
operator|=
name|malloc
argument_list|(
name|nt
operator|->
name|mw_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|nt
operator|->
name|mw_vec
argument_list|)
argument_list|,
name|M_NTB_T
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|mw_count
condition|;
name|i
operator|++
control|)
block|{
name|mw
operator|=
operator|&
name|nt
operator|->
name|mw_vec
index|[
name|i
index|]
expr_stmt|;
name|rc
operator|=
name|NTB_MW_GET_RANGE
argument_list|(
name|ntb
argument_list|,
name|i
argument_list|,
operator|&
name|mw
operator|->
name|phys_addr
argument_list|,
operator|&
name|mw
operator|->
name|vbase
argument_list|,
operator|&
name|mw
operator|->
name|phys_size
argument_list|,
operator|&
name|mw
operator|->
name|xlat_align
argument_list|,
operator|&
name|mw
operator|->
name|xlat_align_size
argument_list|,
operator|&
name|mw
operator|->
name|addr_limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|mw
operator|->
name|buff_size
operator|=
literal|0
expr_stmt|;
name|mw
operator|->
name|xlat_size
operator|=
literal|0
expr_stmt|;
name|mw
operator|->
name|virt_addr
operator|=
name|NULL
expr_stmt|;
name|mw
operator|->
name|dma_addr
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|NTB_MW_SET_WC
argument_list|(
name|nt
operator|->
name|ntb
argument_list|,
name|i
argument_list|,
name|VM_MEMATTR_WRITE_COMBINING
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
name|ntb_printf
argument_list|(
literal|0
argument_list|,
literal|"Unable to set mw%d caching\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|qp_bitmap
operator|=
name|NTB_DB_VALID_MASK
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|nt
operator|->
name|qp_count
operator|=
name|flsll
argument_list|(
name|qp_bitmap
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nt
operator|->
name|qp_count
operator|!=
literal|0
argument_list|,
operator|(
literal|"bogus db bitmap"
operator|)
argument_list|)
expr_stmt|;
name|nt
operator|->
name|qp_count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|max_num_clients
operator|!=
literal|0
operator|&&
name|max_num_clients
operator|<
name|nt
operator|->
name|qp_count
condition|)
name|nt
operator|->
name|qp_count
operator|=
name|max_num_clients
expr_stmt|;
elseif|else
if|if
condition|(
name|nt
operator|->
name|mw_count
operator|<
name|nt
operator|->
name|qp_count
condition|)
name|nt
operator|->
name|qp_count
operator|=
name|nt
operator|->
name|mw_count
expr_stmt|;
name|KASSERT
argument_list|(
name|nt
operator|->
name|qp_count
operator|<=
name|QP_SETSIZE
argument_list|,
operator|(
literal|"invalid qp_count"
operator|)
argument_list|)
expr_stmt|;
name|nt
operator|->
name|qp_vec
operator|=
name|malloc
argument_list|(
name|nt
operator|->
name|qp_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|nt
operator|->
name|qp_vec
argument_list|)
argument_list|,
name|M_NTB_T
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|qp_count
condition|;
name|i
operator|++
control|)
block|{
name|set_bit
argument_list|(
name|i
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|i
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap_free
argument_list|)
expr_stmt|;
name|ntb_transport_init_queue
argument_list|(
name|nt
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|callout_init
argument_list|(
operator|&
name|nt
operator|->
name|link_work
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|nt
operator|->
name|link_watchdog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|nt
operator|->
name|link_cleanup
argument_list|,
literal|0
argument_list|,
name|ntb_transport_link_cleanup_work
argument_list|,
name|nt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|NTB_SET_CTX
argument_list|(
name|ntb
argument_list|,
name|nt
argument_list|,
operator|&
name|ntb_transport_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|nt
operator|->
name|link_is_up
operator|=
name|false
expr_stmt|;
name|NTB_LINK_ENABLE
argument_list|(
name|ntb
argument_list|,
name|NTB_SPEED_AUTO
argument_list|,
name|NTB_WIDTH_AUTO
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|nt
operator|->
name|link_work
argument_list|,
literal|0
argument_list|,
name|ntb_transport_link_work
argument_list|,
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable_xeon_watchdog
operator|!=
literal|0
condition|)
name|callout_reset
argument_list|(
operator|&
name|nt
operator|->
name|link_watchdog
argument_list|,
literal|0
argument_list|,
name|xeon_link_watchdog_hb
argument_list|,
name|nt
argument_list|)
expr_stmt|;
comment|/* Attach children to this transport */
name|device_add_child
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
name|free
argument_list|(
name|nt
operator|->
name|qp_vec
argument_list|,
name|M_NTB_T
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nt
operator|->
name|mw_vec
argument_list|,
name|M_NTB_T
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_transport_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|device_t
name|ntb
init|=
name|nt
operator|->
name|ntb
decl_stmt|;
name|struct
name|_qpset
name|qp_bitmap_alloc
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
comment|/* Detach& delete all children */
name|device_delete_children
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ntb_transport_link_cleanup
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|nt
operator|->
name|link_cleanup
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|nt
operator|->
name|link_work
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|nt
operator|->
name|link_watchdog
argument_list|)
expr_stmt|;
name|BIT_COPY
argument_list|(
name|QP_SETSIZE
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap
argument_list|,
operator|&
name|qp_bitmap_alloc
argument_list|)
expr_stmt|;
name|BIT_NAND
argument_list|(
name|QP_SETSIZE
argument_list|,
operator|&
name|qp_bitmap_alloc
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap_free
argument_list|)
expr_stmt|;
comment|/* Verify that all the QPs are freed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|qp_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|test_bit
argument_list|(
name|i
argument_list|,
operator|&
name|qp_bitmap_alloc
argument_list|)
condition|)
name|ntb_transport_free_queue
argument_list|(
operator|&
name|nt
operator|->
name|qp_vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|NTB_LINK_DISABLE
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|NTB_CLEAR_CTX
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|mw_count
condition|;
name|i
operator|++
control|)
name|ntb_free_mw
argument_list|(
name|nt
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nt
operator|->
name|qp_vec
argument_list|,
name|M_NTB_T
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nt
operator|->
name|mw_vec
argument_list|,
name|M_NTB_T
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_transport_init_queue
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
parameter_list|,
name|unsigned
name|int
name|qp_num
parameter_list|)
block|{
name|struct
name|ntb_transport_mw
modifier|*
name|mw
decl_stmt|;
name|struct
name|ntb_transport_qp
modifier|*
name|qp
decl_stmt|;
name|vm_paddr_t
name|mw_base
decl_stmt|;
name|uint64_t
name|mw_size
decl_stmt|,
name|qp_offset
decl_stmt|;
name|size_t
name|tx_size
decl_stmt|;
name|unsigned
name|num_qps_mw
decl_stmt|,
name|mw_num
decl_stmt|,
name|mw_count
decl_stmt|;
name|mw_count
operator|=
name|nt
operator|->
name|mw_count
expr_stmt|;
name|mw_num
operator|=
name|QP_TO_MW
argument_list|(
name|nt
argument_list|,
name|qp_num
argument_list|)
expr_stmt|;
name|mw
operator|=
operator|&
name|nt
operator|->
name|mw_vec
index|[
name|mw_num
index|]
expr_stmt|;
name|qp
operator|=
operator|&
name|nt
operator|->
name|qp_vec
index|[
name|qp_num
index|]
expr_stmt|;
name|qp
operator|->
name|qp_num
operator|=
name|qp_num
expr_stmt|;
name|qp
operator|->
name|transport
operator|=
name|nt
expr_stmt|;
name|qp
operator|->
name|ntb
operator|=
name|nt
operator|->
name|ntb
expr_stmt|;
name|qp
operator|->
name|client_ready
operator|=
name|false
expr_stmt|;
name|qp
operator|->
name|event_handler
operator|=
name|NULL
expr_stmt|;
name|ntb_qp_link_down_reset
argument_list|(
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mw_num
operator|<
name|nt
operator|->
name|qp_count
operator|%
name|mw_count
condition|)
name|num_qps_mw
operator|=
name|nt
operator|->
name|qp_count
operator|/
name|mw_count
operator|+
literal|1
expr_stmt|;
else|else
name|num_qps_mw
operator|=
name|nt
operator|->
name|qp_count
operator|/
name|mw_count
expr_stmt|;
name|mw_base
operator|=
name|mw
operator|->
name|phys_addr
expr_stmt|;
name|mw_size
operator|=
name|mw
operator|->
name|phys_size
expr_stmt|;
name|tx_size
operator|=
name|mw_size
operator|/
name|num_qps_mw
expr_stmt|;
name|qp_offset
operator|=
name|tx_size
operator|*
operator|(
name|qp_num
operator|/
name|mw_count
operator|)
expr_stmt|;
name|qp
operator|->
name|tx_mw
operator|=
name|mw
operator|->
name|vbase
operator|+
name|qp_offset
expr_stmt|;
name|KASSERT
argument_list|(
name|qp
operator|->
name|tx_mw
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uh oh?"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX Assumes that a vm_paddr_t is equivalent to bus_addr_t */
name|qp
operator|->
name|tx_mw_phys
operator|=
name|mw_base
operator|+
name|qp_offset
expr_stmt|;
name|KASSERT
argument_list|(
name|qp
operator|->
name|tx_mw_phys
operator|!=
literal|0
argument_list|,
operator|(
literal|"uh oh?"
operator|)
argument_list|)
expr_stmt|;
name|tx_size
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_rx_info
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rx_info
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|qp
operator|->
name|tx_mw
operator|+
name|tx_size
operator|)
expr_stmt|;
comment|/* Due to house-keeping, there must be at least 2 buffs */
name|qp
operator|->
name|tx_max_frame
operator|=
name|qmin
argument_list|(
name|tx_size
operator|/
literal|2
argument_list|,
name|transport_mtu
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
argument_list|)
expr_stmt|;
name|qp
operator|->
name|tx_max_entry
operator|=
name|tx_size
operator|/
name|qp
operator|->
name|tx_max_frame
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|qp
operator|->
name|rx_full
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_q_lock
argument_list|,
literal|"ntb rx q"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
literal|"ntb tx free q"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|qp
operator|->
name|tx_lock
argument_list|,
literal|"ntb transport tx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|qp
operator|->
name|rxc_db_work
argument_list|,
literal|0
argument_list|,
name|ntb_transport_rxc_db
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rxc_tq
operator|=
name|taskqueue_create
argument_list|(
literal|"ntbt_rx"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|qp
operator|->
name|rxc_tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|qp
operator|->
name|rxc_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s rx%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|nt
operator|->
name|dev
argument_list|)
argument_list|,
name|qp_num
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|qp
operator|->
name|rx_post_q
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|qp
operator|->
name|rx_pend_q
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|,
literal|0
argument_list|,
name|ntb_qp_link_work
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ntb_transport_free_queue
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
return|return;
name|callout_drain
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|)
expr_stmt|;
name|NTB_DB_SET_MASK
argument_list|(
name|qp
operator|->
name|ntb
argument_list|,
literal|1ull
operator|<<
name|qp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
name|taskqueue_drain_all
argument_list|(
name|qp
operator|->
name|rxc_tq
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|qp
operator|->
name|rxc_tq
argument_list|)
expr_stmt|;
name|qp
operator|->
name|cb_data
operator|=
name|NULL
expr_stmt|;
name|qp
operator|->
name|rx_handler
operator|=
name|NULL
expr_stmt|;
name|qp
operator|->
name|tx_handler
operator|=
name|NULL
expr_stmt|;
name|qp
operator|->
name|event_handler
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|ntb_list_rm
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|rx_pend_q
argument_list|)
operator|)
condition|)
name|free
argument_list|(
name|entry
argument_list|,
name|M_NTB_T
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|ntb_list_rm
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|rx_post_q
argument_list|)
operator|)
condition|)
name|free
argument_list|(
name|entry
argument_list|,
name|M_NTB_T
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|ntb_list_rm
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
operator|)
condition|)
name|free
argument_list|(
name|entry
argument_list|,
name|M_NTB_T
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|qp
operator|->
name|qp_num
argument_list|,
operator|&
name|qp
operator|->
name|transport
operator|->
name|qp_bitmap_free
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ntb_transport_create_queue - Create a new NTB transport layer queue  * @rx_handler: receive callback function  * @tx_handler: transmit callback function  * @event_handler: event callback function  *  * Create a new NTB transport layer queue and provide the queue with a callback  * routine for both transmit and receive.  The receive callback routine will be  * used to pass up data when the transport has received it on the queue.   The  * transmit callback routine will be called when the transport has completed the  * transmission of the data on the queue and the data is ready to be freed.  *  * RETURNS: pointer to newly created ntb_queue, NULL on error.  */
end_comment

begin_function
name|struct
name|ntb_transport_qp
modifier|*
name|ntb_transport_create_queue
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|ntb_queue_handlers
modifier|*
name|handlers
parameter_list|)
block|{
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|device_t
name|ntb
init|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|ntb_transport_qp
modifier|*
name|qp
decl_stmt|;
name|unsigned
name|int
name|free_queue
decl_stmt|;
name|int
name|i
decl_stmt|;
name|free_queue
operator|=
name|ffs_bit
argument_list|(
operator|&
name|nt
operator|->
name|qp_bitmap_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_queue
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* decrement free_queue to make it zero based */
name|free_queue
operator|--
expr_stmt|;
name|qp
operator|=
operator|&
name|nt
operator|->
name|qp_vec
index|[
name|free_queue
index|]
expr_stmt|;
name|clear_bit
argument_list|(
name|qp
operator|->
name|qp_num
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap_free
argument_list|)
expr_stmt|;
name|qp
operator|->
name|cb_data
operator|=
name|data
expr_stmt|;
name|qp
operator|->
name|rx_handler
operator|=
name|handlers
operator|->
name|rx_handler
expr_stmt|;
name|qp
operator|->
name|tx_handler
operator|=
name|handlers
operator|->
name|tx_handler
expr_stmt|;
name|qp
operator|->
name|event_handler
operator|=
name|handlers
operator|->
name|event_handler
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTB_QP_DEF_NUM_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|,
name|M_NTB_T
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|entry
operator|->
name|cb_data
operator|=
name|data
expr_stmt|;
name|entry
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|len
operator|=
name|transport_mtu
expr_stmt|;
name|entry
operator|->
name|qp
operator|=
name|qp
expr_stmt|;
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|rx_pend_q
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTB_QP_DEF_NUM_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|,
name|M_NTB_T
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|entry
operator|->
name|qp
operator|=
name|qp
expr_stmt|;
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
block|}
name|NTB_DB_CLEAR
argument_list|(
name|ntb
argument_list|,
literal|1ull
operator|<<
name|qp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
name|NTB_DB_CLEAR_MASK
argument_list|(
name|ntb
argument_list|,
literal|1ull
operator|<<
name|qp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
return|return
operator|(
name|qp
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_transport_link_up - Notify NTB transport of client readiness to use queue  * @qp: NTB transport layer queue to be enabled  *  * Notify NTB transport layer of client readiness to use queue  */
end_comment

begin_function
name|void
name|ntb_transport_link_up
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
init|=
name|qp
operator|->
name|transport
decl_stmt|;
name|qp
operator|->
name|client_ready
operator|=
name|true
expr_stmt|;
name|ntb_printf
argument_list|(
literal|2
argument_list|,
literal|"qp %d client ready\n"
argument_list|,
name|qp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|link_is_up
condition|)
name|callout_reset
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|,
literal|0
argument_list|,
name|ntb_qp_link_work
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Transport Tx */
end_comment

begin_comment
comment|/**  * ntb_transport_tx_enqueue - Enqueue a new NTB queue entry  * @qp: NTB transport layer queue the entry is to be enqueued on  * @cb: per buffer pointer for callback function to use  * @data: pointer to data buffer that will be sent  * @len: length of the data buffer  *  * Enqueue a new transmit buffer onto the transport queue from which a NTB  * payload will be transmitted.  This assumes that a lock is being held to  * serialize access to the qp.  *  * RETURNS: An appropriate ERRNO error value on error, or zero for success.  */
end_comment

begin_function
name|int
name|ntb_transport_tx_enqueue
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|qp
operator|==
name|NULL
operator|||
operator|!
name|qp
operator|->
name|link_is_up
operator|||
name|len
operator|==
literal|0
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: link not up"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|entry
operator|=
name|ntb_list_rm
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: could not get entry from tx_free_q"
argument_list|)
expr_stmt|;
name|qp
operator|->
name|tx_err_no_buf
operator|++
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: got entry %p from tx_free_q"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|cb_data
operator|=
name|cb
expr_stmt|;
name|entry
operator|->
name|buf
operator|=
name|data
expr_stmt|;
name|entry
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|entry
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|qp
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ntb_process_tx
argument_list|(
name|qp
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|qp
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: process_tx failed. Returning entry %p to tx_free_q"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_tx_copy_callback
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ntb_queue_entry
modifier|*
name|entry
init|=
name|data
decl_stmt|;
name|struct
name|ntb_transport_qp
modifier|*
name|qp
init|=
name|entry
operator|->
name|qp
decl_stmt|;
name|struct
name|ntb_payload_header
modifier|*
name|hdr
init|=
name|entry
operator|->
name|x_hdr
decl_stmt|;
name|iowrite32
argument_list|(
name|entry
operator|->
name|flags
operator||
name|NTBT_DESC_DONE_FLAG
argument_list|,
operator|&
name|hdr
operator|->
name|flags
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: hdr %p set DESC_DONE"
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|NTB_PEER_DB_SET
argument_list|(
name|qp
operator|->
name|ntb
argument_list|,
literal|1ull
operator|<<
name|qp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
comment|/* 	 * The entry length can only be zero if the packet is intended to be a 	 * "link down" or similar.  Since no payload is being sent in these 	 * cases, there is nothing to add to the completion queue. 	 */
if|if
condition|(
name|entry
operator|->
name|len
operator|>
literal|0
condition|)
block|{
name|qp
operator|->
name|tx_bytes
operator|+=
name|entry
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|tx_handler
condition|)
name|qp
operator|->
name|tx_handler
argument_list|(
name|qp
argument_list|,
name|qp
operator|->
name|cb_data
argument_list|,
name|entry
operator|->
name|buf
argument_list|,
name|entry
operator|->
name|len
argument_list|)
expr_stmt|;
else|else
name|m_freem
argument_list|(
name|entry
operator|->
name|buf
argument_list|)
expr_stmt|;
name|entry
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
name|CTR3
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: entry %p sent. hdr->ver = %u, hdr->flags = 0x%x, Returning "
literal|"to tx_free_q"
argument_list|,
name|entry
argument_list|,
name|hdr
operator|->
name|ver
argument_list|,
name|hdr
operator|->
name|flags
argument_list|)
expr_stmt|;
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_memcpy_tx
parameter_list|(
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|offset
parameter_list|)
block|{
name|CTR2
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: copying %d bytes to offset %p"
argument_list|,
name|entry
operator|->
name|len
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|m_copydata
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|entry
operator|->
name|buf
argument_list|,
literal|0
argument_list|,
name|entry
operator|->
name|len
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* 		 * Ensure that the data is fully copied before setting the 		 * flags 		 */
name|wmb
argument_list|()
expr_stmt|;
block|}
name|ntb_tx_copy_callback
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_async_tx
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|ntb_payload_header
modifier|*
name|hdr
decl_stmt|;
name|void
modifier|*
name|offset
decl_stmt|;
name|offset
operator|=
name|qp
operator|->
name|tx_mw
operator|+
name|qp
operator|->
name|tx_max_frame
operator|*
name|qp
operator|->
name|tx_index
expr_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|ntb_payload_header
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|offset
operator|+
name|qp
operator|->
name|tx_max_frame
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
operator|)
expr_stmt|;
name|entry
operator|->
name|x_hdr
operator|=
name|hdr
expr_stmt|;
name|iowrite32
argument_list|(
name|entry
operator|->
name|len
argument_list|,
operator|&
name|hdr
operator|->
name|len
argument_list|)
expr_stmt|;
name|iowrite32
argument_list|(
name|qp
operator|->
name|tx_pkts
argument_list|,
operator|&
name|hdr
operator|->
name|ver
argument_list|)
expr_stmt|;
name|ntb_memcpy_tx
argument_list|(
name|entry
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_process_tx
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|)
block|{
name|CTR3
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: process_tx: tx_pkts=%lu, tx_index=%u, remote entry=%u"
argument_list|,
name|qp
operator|->
name|tx_pkts
argument_list|,
name|qp
operator|->
name|tx_index
argument_list|,
name|qp
operator|->
name|remote_rx_info
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|tx_index
operator|==
name|qp
operator|->
name|remote_rx_info
operator|->
name|entry
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: ring full"
argument_list|)
expr_stmt|;
name|qp
operator|->
name|tx_ring_full
operator|++
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
if|if
condition|(
name|entry
operator|->
name|len
operator|>
name|qp
operator|->
name|tx_max_frame
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|tx_handler
operator|!=
name|NULL
condition|)
name|qp
operator|->
name|tx_handler
argument_list|(
name|qp
argument_list|,
name|qp
operator|->
name|cb_data
argument_list|,
name|entry
operator|->
name|buf
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
else|else
name|m_freem
argument_list|(
name|entry
operator|->
name|buf
argument_list|)
expr_stmt|;
name|entry
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: frame too big. returning entry %p to tx_free_q"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|CTR2
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: copying entry %p to index %u"
argument_list|,
name|entry
argument_list|,
name|qp
operator|->
name|tx_index
argument_list|)
expr_stmt|;
name|ntb_async_tx
argument_list|(
name|qp
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|qp
operator|->
name|tx_index
operator|++
expr_stmt|;
name|qp
operator|->
name|tx_index
operator|%=
name|qp
operator|->
name|tx_max_entry
expr_stmt|;
name|qp
operator|->
name|tx_pkts
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Transport Rx */
end_comment

begin_function
specifier|static
name|void
name|ntb_transport_rxc_db
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|ntb_transport_qp
modifier|*
name|qp
init|=
name|arg
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: transport_rx"
argument_list|)
expr_stmt|;
name|again
label|:
while|while
condition|(
operator|(
name|rc
operator|=
name|ntb_process_rxc
argument_list|(
name|qp
argument_list|)
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: process_rxc returned %d"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|NTB_DB_READ
argument_list|(
name|qp
operator|->
name|ntb
argument_list|)
operator|&
operator|(
literal|1ull
operator|<<
name|qp
operator|->
name|qp_num
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* If db is set, clear it and check queue once more. */
name|NTB_DB_CLEAR
argument_list|(
name|qp
operator|->
name|ntb
argument_list|,
literal|1ull
operator|<<
name|qp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_process_rxc
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|ntb_payload_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|caddr_t
name|offset
decl_stmt|;
name|offset
operator|=
name|qp
operator|->
name|rx_buff
operator|+
name|qp
operator|->
name|rx_max_frame
operator|*
name|qp
operator|->
name|rx_index
expr_stmt|;
name|hdr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|offset
operator|+
name|qp
operator|->
name|rx_max_frame
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
operator|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: process_rxc rx_index = %u"
argument_list|,
name|qp
operator|->
name|rx_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|flags
operator|&
name|NTBT_DESC_DONE_FLAG
operator|)
operator|==
literal|0
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: hdr not done"
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rx_ring_empty
operator|++
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|hdr
operator|->
name|flags
operator|&
name|NTBT_LINK_DOWN_FLAG
operator|)
operator|!=
literal|0
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: link down"
argument_list|)
expr_stmt|;
name|ntb_qp_link_down
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
if|if
condition|(
name|hdr
operator|->
name|ver
operator|!=
operator|(
name|uint32_t
operator|)
name|qp
operator|->
name|rx_pkts
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: ver != rx_pkts (%x != %lx). "
literal|"Returning entry to rx_pend_q"
argument_list|,
name|hdr
operator|->
name|ver
argument_list|,
name|qp
operator|->
name|rx_pkts
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rx_err_ver
operator|++
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|entry
operator|=
name|ntb_list_mv
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|rx_pend_q
argument_list|,
operator|&
name|qp
operator|->
name|rx_post_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|qp
operator|->
name|rx_err_no_buf
operator|++
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: No entries in rx_pend_q"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|callout_stop
argument_list|(
operator|&
name|qp
operator|->
name|rx_full
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: rx entry %p from rx_pend_q"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|x_hdr
operator|=
name|hdr
expr_stmt|;
name|entry
operator|->
name|index
operator|=
name|qp
operator|->
name|rx_index
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|len
operator|>
name|entry
operator|->
name|len
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: len too long. Wanted %ju got %ju"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|hdr
operator|->
name|len
argument_list|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|len
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rx_err_oflow
operator|++
expr_stmt|;
name|entry
operator|->
name|len
operator|=
operator|-
name|EIO
expr_stmt|;
name|entry
operator|->
name|flags
operator||=
name|NTBT_DESC_DONE_FLAG
expr_stmt|;
name|ntb_complete_rxc
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qp
operator|->
name|rx_bytes
operator|+=
name|hdr
operator|->
name|len
expr_stmt|;
name|qp
operator|->
name|rx_pkts
operator|++
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: received %ld rx_pkts"
argument_list|,
name|qp
operator|->
name|rx_pkts
argument_list|)
expr_stmt|;
name|entry
operator|->
name|len
operator|=
name|hdr
operator|->
name|len
expr_stmt|;
name|ntb_memcpy_rx
argument_list|(
name|qp
argument_list|,
name|entry
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|qp
operator|->
name|rx_index
operator|++
expr_stmt|;
name|qp
operator|->
name|rx_index
operator|%=
name|qp
operator|->
name|rx_max_entry
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_memcpy_rx
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|entry
operator|->
name|cb_data
decl_stmt|;
name|unsigned
name|int
name|len
init|=
name|entry
operator|->
name|len
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: copying %d bytes from offset %p"
argument_list|,
name|len
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|entry
operator|->
name|buf
operator|=
operator|(
name|void
operator|*
operator|)
name|m_devget
argument_list|(
name|offset
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Ensure that the data is globally visible before clearing the flag */
name|wmb
argument_list|()
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: copied entry %p to mbuf %p."
argument_list|,
name|entry
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ntb_rx_copy_callback
argument_list|(
name|qp
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ntb_rx_copy_callback
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|data
expr_stmt|;
name|entry
operator|->
name|flags
operator||=
name|NTBT_DESC_DONE_FLAG
expr_stmt|;
name|ntb_complete_rxc
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_complete_rxc
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: rx_completion_task"
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_q_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|qp
operator|->
name|rx_post_q
argument_list|)
condition|)
block|{
name|entry
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|qp
operator|->
name|rx_post_q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|NTBT_DESC_DONE_FLAG
operator|)
operator|==
literal|0
condition|)
break|break;
name|entry
operator|->
name|x_hdr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|iowrite32
argument_list|(
name|entry
operator|->
name|index
argument_list|,
operator|&
name|qp
operator|->
name|rx_info
operator|->
name|entry
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|qp
operator|->
name|rx_post_q
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|len
operator|=
name|entry
operator|->
name|len
expr_stmt|;
name|m
operator|=
name|entry
operator|->
name|buf
expr_stmt|;
comment|/* 		 * Re-initialize queue_entry for reuse; rx_handler takes 		 * ownership of the mbuf. 		 */
name|entry
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|len
operator|=
name|transport_mtu
expr_stmt|;
name|entry
operator|->
name|cb_data
operator|=
name|qp
operator|->
name|cb_data
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|qp
operator|->
name|rx_pend_q
argument_list|,
name|entry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_q_lock
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: completing entry %p, mbuf %p"
argument_list|,
name|entry
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|rx_handler
operator|!=
name|NULL
operator|&&
name|qp
operator|->
name|client_ready
condition|)
name|qp
operator|->
name|rx_handler
argument_list|(
name|qp
argument_list|,
name|qp
operator|->
name|cb_data
argument_list|,
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_q_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_q_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_transport_doorbell_callback
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|vector
parameter_list|)
block|{
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
init|=
name|data
decl_stmt|;
name|struct
name|ntb_transport_qp
modifier|*
name|qp
decl_stmt|;
name|struct
name|_qpset
name|db_bits
decl_stmt|;
name|uint64_t
name|vec_mask
decl_stmt|;
name|unsigned
name|qp_num
decl_stmt|;
name|BIT_COPY
argument_list|(
name|QP_SETSIZE
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap
argument_list|,
operator|&
name|db_bits
argument_list|)
expr_stmt|;
name|BIT_NAND
argument_list|(
name|QP_SETSIZE
argument_list|,
operator|&
name|db_bits
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap_free
argument_list|)
expr_stmt|;
name|vec_mask
operator|=
name|NTB_DB_VECTOR_MASK
argument_list|(
name|nt
operator|->
name|ntb
argument_list|,
name|vector
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vec_mask
operator|&
operator|(
name|vec_mask
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|vec_mask
operator|&=
name|NTB_DB_READ
argument_list|(
name|nt
operator|->
name|ntb
argument_list|)
expr_stmt|;
while|while
condition|(
name|vec_mask
operator|!=
literal|0
condition|)
block|{
name|qp_num
operator|=
name|ffsll
argument_list|(
name|vec_mask
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|test_bit
argument_list|(
name|qp_num
argument_list|,
operator|&
name|db_bits
argument_list|)
condition|)
block|{
name|qp
operator|=
operator|&
name|nt
operator|->
name|qp_vec
index|[
name|qp_num
index|]
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|qp
operator|->
name|rxc_tq
argument_list|,
operator|&
name|qp
operator|->
name|rxc_db_work
argument_list|)
expr_stmt|;
block|}
name|vec_mask
operator|&=
operator|~
operator|(
literal|1ull
operator|<<
name|qp_num
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Link Event handler */
end_comment

begin_function
specifier|static
name|void
name|ntb_transport_event_callback
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
init|=
name|data
decl_stmt|;
if|if
condition|(
name|NTB_LINK_IS_UP
argument_list|(
name|nt
operator|->
name|ntb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|ntb_printf
argument_list|(
literal|1
argument_list|,
literal|"HW link up\n"
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|nt
operator|->
name|link_work
argument_list|,
literal|0
argument_list|,
name|ntb_transport_link_work
argument_list|,
name|nt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ntb_printf
argument_list|(
literal|1
argument_list|,
literal|"HW link down\n"
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|nt
operator|->
name|link_cleanup
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Link bring up */
end_comment

begin_function
specifier|static
name|void
name|ntb_transport_link_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
init|=
name|arg
decl_stmt|;
name|device_t
name|ntb
init|=
name|nt
operator|->
name|ntb
decl_stmt|;
name|struct
name|ntb_transport_qp
modifier|*
name|qp
decl_stmt|;
name|uint64_t
name|val64
decl_stmt|,
name|size
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* send the local info, in the opposite order of the way we read it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|mw_count
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|nt
operator|->
name|mw_vec
index|[
name|i
index|]
operator|.
name|phys_size
expr_stmt|;
if|if
condition|(
name|max_mw_size
operator|!=
literal|0
operator|&&
name|size
operator|>
name|max_mw_size
condition|)
name|size
operator|=
name|max_mw_size
expr_stmt|;
name|NTB_PEER_SPAD_WRITE
argument_list|(
name|ntb
argument_list|,
name|NTBT_MW0_SZ_HIGH
operator|+
operator|(
name|i
operator|*
literal|2
operator|)
argument_list|,
name|size
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|NTB_PEER_SPAD_WRITE
argument_list|(
name|ntb
argument_list|,
name|NTBT_MW0_SZ_LOW
operator|+
operator|(
name|i
operator|*
literal|2
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|NTB_PEER_SPAD_WRITE
argument_list|(
name|ntb
argument_list|,
name|NTBT_NUM_MWS
argument_list|,
name|nt
operator|->
name|mw_count
argument_list|)
expr_stmt|;
name|NTB_PEER_SPAD_WRITE
argument_list|(
name|ntb
argument_list|,
name|NTBT_NUM_QPS
argument_list|,
name|nt
operator|->
name|qp_count
argument_list|)
expr_stmt|;
name|NTB_PEER_SPAD_WRITE
argument_list|(
name|ntb
argument_list|,
name|NTBT_VERSION
argument_list|,
name|NTB_TRANSPORT_VERSION
argument_list|)
expr_stmt|;
comment|/* Query the remote side for its info */
name|val
operator|=
literal|0
expr_stmt|;
name|NTB_SPAD_READ
argument_list|(
name|ntb
argument_list|,
name|NTBT_VERSION
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|NTB_TRANSPORT_VERSION
condition|)
goto|goto
name|out
goto|;
name|NTB_SPAD_READ
argument_list|(
name|ntb
argument_list|,
name|NTBT_NUM_QPS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|nt
operator|->
name|qp_count
condition|)
goto|goto
name|out
goto|;
name|NTB_SPAD_READ
argument_list|(
name|ntb
argument_list|,
name|NTBT_NUM_MWS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|nt
operator|->
name|mw_count
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|mw_count
condition|;
name|i
operator|++
control|)
block|{
name|NTB_SPAD_READ
argument_list|(
name|ntb
argument_list|,
name|NTBT_MW0_SZ_HIGH
operator|+
operator|(
name|i
operator|*
literal|2
operator|)
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val64
operator|=
operator|(
name|uint64_t
operator|)
name|val
operator|<<
literal|32
expr_stmt|;
name|NTB_SPAD_READ
argument_list|(
name|ntb
argument_list|,
name|NTBT_MW0_SZ_LOW
operator|+
operator|(
name|i
operator|*
literal|2
operator|)
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val64
operator||=
name|val
expr_stmt|;
name|rc
operator|=
name|ntb_set_mw
argument_list|(
name|nt
argument_list|,
name|i
argument_list|,
name|val64
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|free_mws
goto|;
block|}
name|nt
operator|->
name|link_is_up
operator|=
name|true
expr_stmt|;
name|ntb_printf
argument_list|(
literal|1
argument_list|,
literal|"transport link up\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|qp_count
condition|;
name|i
operator|++
control|)
block|{
name|qp
operator|=
operator|&
name|nt
operator|->
name|qp_vec
index|[
name|i
index|]
expr_stmt|;
name|ntb_transport_setup_qp_mw
argument_list|(
name|nt
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|client_ready
condition|)
name|callout_reset
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|,
literal|0
argument_list|,
name|ntb_qp_link_work
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
return|return;
name|free_mws
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|mw_count
condition|;
name|i
operator|++
control|)
name|ntb_free_mw
argument_list|(
name|nt
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|NTB_LINK_IS_UP
argument_list|(
name|ntb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
name|callout_reset
argument_list|(
operator|&
name|nt
operator|->
name|link_work
argument_list|,
name|NTB_LINK_DOWN_TIMEOUT
operator|*
name|hz
operator|/
literal|1000
argument_list|,
name|ntb_transport_link_work
argument_list|,
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_set_mw
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
parameter_list|,
name|int
name|num_mw
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|ntb_transport_mw
modifier|*
name|mw
init|=
operator|&
name|nt
operator|->
name|mw_vec
index|[
name|num_mw
index|]
decl_stmt|;
name|size_t
name|xlat_size
decl_stmt|,
name|buff_size
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|xlat_size
operator|=
name|roundup
argument_list|(
name|size
argument_list|,
name|mw
operator|->
name|xlat_align_size
argument_list|)
expr_stmt|;
name|buff_size
operator|=
name|xlat_size
expr_stmt|;
comment|/* No need to re-setup */
if|if
condition|(
name|mw
operator|->
name|xlat_size
operator|==
name|xlat_size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|mw
operator|->
name|buff_size
operator|!=
literal|0
condition|)
name|ntb_free_mw
argument_list|(
name|nt
argument_list|,
name|num_mw
argument_list|)
expr_stmt|;
comment|/* Alloc memory for receiving data.  Must be aligned */
name|mw
operator|->
name|xlat_size
operator|=
name|xlat_size
expr_stmt|;
name|mw
operator|->
name|buff_size
operator|=
name|buff_size
expr_stmt|;
name|mw
operator|->
name|virt_addr
operator|=
name|contigmalloc
argument_list|(
name|mw
operator|->
name|buff_size
argument_list|,
name|M_NTB_T
argument_list|,
name|M_ZERO
argument_list|,
literal|0
argument_list|,
name|mw
operator|->
name|addr_limit
argument_list|,
name|mw
operator|->
name|xlat_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mw
operator|->
name|virt_addr
operator|==
name|NULL
condition|)
block|{
name|ntb_printf
argument_list|(
literal|0
argument_list|,
literal|"Unable to allocate MW buffer of size %zu/%zu\n"
argument_list|,
name|mw
operator|->
name|buff_size
argument_list|,
name|mw
operator|->
name|xlat_size
argument_list|)
expr_stmt|;
name|mw
operator|->
name|xlat_size
operator|=
literal|0
expr_stmt|;
name|mw
operator|->
name|buff_size
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* TODO: replace with bus_space_* functions */
name|mw
operator|->
name|dma_addr
operator|=
name|vtophys
argument_list|(
name|mw
operator|->
name|virt_addr
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that the allocation from contigmalloc is aligned as 	 * requested.  XXX: This may not be needed -- brought in for parity 	 * with the Linux driver. 	 */
if|if
condition|(
name|mw
operator|->
name|dma_addr
operator|%
name|mw
operator|->
name|xlat_align
operator|!=
literal|0
condition|)
block|{
name|ntb_printf
argument_list|(
literal|0
argument_list|,
literal|"DMA memory 0x%jx not aligned to BAR size 0x%zx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|mw
operator|->
name|dma_addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ntb_free_mw
argument_list|(
name|nt
argument_list|,
name|num_mw
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Notify HW the memory location of the receive buffer */
name|rc
operator|=
name|NTB_MW_SET_TRANS
argument_list|(
name|nt
operator|->
name|ntb
argument_list|,
name|num_mw
argument_list|,
name|mw
operator|->
name|dma_addr
argument_list|,
name|mw
operator|->
name|xlat_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|ntb_printf
argument_list|(
literal|0
argument_list|,
literal|"Unable to set mw%d translation\n"
argument_list|,
name|num_mw
argument_list|)
expr_stmt|;
name|ntb_free_mw
argument_list|(
name|nt
argument_list|,
name|num_mw
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_free_mw
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
parameter_list|,
name|int
name|num_mw
parameter_list|)
block|{
name|struct
name|ntb_transport_mw
modifier|*
name|mw
init|=
operator|&
name|nt
operator|->
name|mw_vec
index|[
name|num_mw
index|]
decl_stmt|;
if|if
condition|(
name|mw
operator|->
name|virt_addr
operator|==
name|NULL
condition|)
return|return;
name|NTB_MW_CLEAR_TRANS
argument_list|(
name|nt
operator|->
name|ntb
argument_list|,
name|num_mw
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|mw
operator|->
name|virt_addr
argument_list|,
name|mw
operator|->
name|xlat_size
argument_list|,
name|M_NTB_T
argument_list|)
expr_stmt|;
name|mw
operator|->
name|xlat_size
operator|=
literal|0
expr_stmt|;
name|mw
operator|->
name|buff_size
operator|=
literal|0
expr_stmt|;
name|mw
operator|->
name|virt_addr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_transport_setup_qp_mw
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
parameter_list|,
name|unsigned
name|int
name|qp_num
parameter_list|)
block|{
name|struct
name|ntb_transport_qp
modifier|*
name|qp
init|=
operator|&
name|nt
operator|->
name|qp_vec
index|[
name|qp_num
index|]
decl_stmt|;
name|struct
name|ntb_transport_mw
modifier|*
name|mw
decl_stmt|;
name|void
modifier|*
name|offset
decl_stmt|;
name|ntb_q_idx_t
name|i
decl_stmt|;
name|size_t
name|rx_size
decl_stmt|;
name|unsigned
name|num_qps_mw
decl_stmt|,
name|mw_num
decl_stmt|,
name|mw_count
decl_stmt|;
name|mw_count
operator|=
name|nt
operator|->
name|mw_count
expr_stmt|;
name|mw_num
operator|=
name|QP_TO_MW
argument_list|(
name|nt
argument_list|,
name|qp_num
argument_list|)
expr_stmt|;
name|mw
operator|=
operator|&
name|nt
operator|->
name|mw_vec
index|[
name|mw_num
index|]
expr_stmt|;
if|if
condition|(
name|mw
operator|->
name|virt_addr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|mw_num
operator|<
name|nt
operator|->
name|qp_count
operator|%
name|mw_count
condition|)
name|num_qps_mw
operator|=
name|nt
operator|->
name|qp_count
operator|/
name|mw_count
operator|+
literal|1
expr_stmt|;
else|else
name|num_qps_mw
operator|=
name|nt
operator|->
name|qp_count
operator|/
name|mw_count
expr_stmt|;
name|rx_size
operator|=
name|mw
operator|->
name|xlat_size
operator|/
name|num_qps_mw
expr_stmt|;
name|qp
operator|->
name|rx_buff
operator|=
name|mw
operator|->
name|virt_addr
operator|+
name|rx_size
operator|*
operator|(
name|qp_num
operator|/
name|mw_count
operator|)
expr_stmt|;
name|rx_size
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_rx_info
argument_list|)
expr_stmt|;
name|qp
operator|->
name|remote_rx_info
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|qp
operator|->
name|rx_buff
operator|+
name|rx_size
operator|)
expr_stmt|;
comment|/* Due to house-keeping, there must be at least 2 buffs */
name|qp
operator|->
name|rx_max_frame
operator|=
name|qmin
argument_list|(
name|rx_size
operator|/
literal|2
argument_list|,
name|transport_mtu
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rx_max_entry
operator|=
name|rx_size
operator|/
name|qp
operator|->
name|rx_max_frame
expr_stmt|;
name|qp
operator|->
name|rx_index
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|remote_rx_info
operator|->
name|entry
operator|=
name|qp
operator|->
name|rx_max_entry
operator|-
literal|1
expr_stmt|;
comment|/* Set up the hdr offsets with 0s */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp
operator|->
name|rx_max_entry
condition|;
name|i
operator|++
control|)
block|{
name|offset
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|qp
operator|->
name|rx_buff
operator|+
name|qp
operator|->
name|rx_max_frame
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|qp
operator|->
name|rx_pkts
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|tx_pkts
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|tx_index
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_qp_link_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_transport_qp
modifier|*
name|qp
init|=
name|arg
decl_stmt|;
name|device_t
name|ntb
init|=
name|qp
operator|->
name|ntb
decl_stmt|;
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
init|=
name|qp
operator|->
name|transport
decl_stmt|;
name|uint32_t
name|val
decl_stmt|,
name|dummy
decl_stmt|;
name|NTB_SPAD_READ
argument_list|(
name|ntb
argument_list|,
name|NTBT_QP_LINKS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|NTB_PEER_SPAD_WRITE
argument_list|(
name|ntb
argument_list|,
name|NTBT_QP_LINKS
argument_list|,
name|val
operator||
operator|(
literal|1ull
operator|<<
name|qp
operator|->
name|qp_num
operator|)
argument_list|)
expr_stmt|;
comment|/* query remote spad for qp ready bits */
name|NTB_PEER_SPAD_READ
argument_list|(
name|ntb
argument_list|,
name|NTBT_QP_LINKS
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
comment|/* See if the remote side is up */
if|if
condition|(
operator|(
name|val
operator|&
operator|(
literal|1ull
operator|<<
name|qp
operator|->
name|qp_num
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ntb_printf
argument_list|(
literal|2
argument_list|,
literal|"qp %d link up\n"
argument_list|,
name|qp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
name|qp
operator|->
name|link_is_up
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|event_handler
operator|!=
name|NULL
condition|)
name|qp
operator|->
name|event_handler
argument_list|(
name|qp
operator|->
name|cb_data
argument_list|,
name|NTB_LINK_UP
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|qp
operator|->
name|rxc_tq
argument_list|,
operator|&
name|qp
operator|->
name|rxc_db_work
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nt
operator|->
name|link_is_up
condition|)
name|callout_reset
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|,
name|NTB_LINK_DOWN_TIMEOUT
operator|*
name|hz
operator|/
literal|1000
argument_list|,
name|ntb_qp_link_work
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Link down event*/
end_comment

begin_function
specifier|static
name|void
name|ntb_transport_link_cleanup
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
parameter_list|)
block|{
name|struct
name|ntb_transport_qp
modifier|*
name|qp
decl_stmt|;
name|struct
name|_qpset
name|qp_bitmap_alloc
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|BIT_COPY
argument_list|(
name|QP_SETSIZE
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap
argument_list|,
operator|&
name|qp_bitmap_alloc
argument_list|)
expr_stmt|;
name|BIT_NAND
argument_list|(
name|QP_SETSIZE
argument_list|,
operator|&
name|qp_bitmap_alloc
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap_free
argument_list|)
expr_stmt|;
comment|/* Pass along the info to any clients */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|qp_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|test_bit
argument_list|(
name|i
argument_list|,
operator|&
name|qp_bitmap_alloc
argument_list|)
condition|)
block|{
name|qp
operator|=
operator|&
name|nt
operator|->
name|qp_vec
index|[
name|i
index|]
expr_stmt|;
name|ntb_qp_link_cleanup
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nt
operator|->
name|link_is_up
condition|)
name|callout_drain
argument_list|(
operator|&
name|nt
operator|->
name|link_work
argument_list|)
expr_stmt|;
comment|/* 	 * The scratchpad registers keep the values if the remote side 	 * goes down, blast them now to give them a sane value the next 	 * time they are accessed 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTBT_MAX_SPAD
condition|;
name|i
operator|++
control|)
name|NTB_SPAD_WRITE
argument_list|(
name|nt
operator|->
name|ntb
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_transport_link_cleanup_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|ntb_transport_link_cleanup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_qp_link_down
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|ntb_qp_link_cleanup
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_qp_link_down_reset
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|qp
operator|->
name|link_is_up
operator|=
name|false
expr_stmt|;
name|qp
operator|->
name|tx_index
operator|=
name|qp
operator|->
name|rx_index
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|tx_bytes
operator|=
name|qp
operator|->
name|rx_bytes
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|tx_pkts
operator|=
name|qp
operator|->
name|rx_pkts
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|rx_ring_empty
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|tx_ring_full
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|rx_err_no_buf
operator|=
name|qp
operator|->
name|tx_err_no_buf
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|rx_err_oflow
operator|=
name|qp
operator|->
name|rx_err_ver
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_qp_link_cleanup
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
init|=
name|qp
operator|->
name|transport
decl_stmt|;
name|callout_drain
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|)
expr_stmt|;
name|ntb_qp_link_down_reset
argument_list|(
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|event_handler
operator|!=
name|NULL
condition|)
name|qp
operator|->
name|event_handler
argument_list|(
name|qp
operator|->
name|cb_data
argument_list|,
name|NTB_LINK_DOWN
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|link_is_up
condition|)
name|callout_reset
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|,
name|NTB_LINK_DOWN_TIMEOUT
operator|*
name|hz
operator|/
literal|1000
argument_list|,
name|ntb_qp_link_work
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Link commanded down */
end_comment

begin_comment
comment|/**  * ntb_transport_link_down - Notify NTB transport to no longer enqueue data  * @qp: NTB transport layer queue to be disabled  *  * Notify NTB transport layer of client's desire to no longer receive data on  * transport queue specified.  It is the client's responsibility to ensure all  * entries on queue are purged or otherwise handled appropriately.  */
end_comment

begin_function
name|void
name|ntb_transport_link_down
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
return|return;
name|qp
operator|->
name|client_ready
operator|=
name|false
expr_stmt|;
name|NTB_SPAD_READ
argument_list|(
name|qp
operator|->
name|ntb
argument_list|,
name|NTBT_QP_LINKS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|NTB_PEER_SPAD_WRITE
argument_list|(
name|qp
operator|->
name|ntb
argument_list|,
name|NTBT_QP_LINKS
argument_list|,
name|val
operator|&
operator|~
operator|(
literal|1
operator|<<
name|qp
operator|->
name|qp_num
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|link_is_up
condition|)
name|ntb_send_link_down
argument_list|(
name|qp
argument_list|)
expr_stmt|;
else|else
name|callout_drain
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ntb_transport_link_query - Query transport link state  * @qp: NTB transport layer queue to be queried  *  * Query connectivity to the remote system of the NTB transport queue  *  * RETURNS: true for link up or false for link down  */
end_comment

begin_function
name|bool
name|ntb_transport_link_query
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|qp
operator|->
name|link_is_up
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_send_link_down
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|qp
operator|->
name|link_is_up
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTB_LINK_DOWN_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
name|ntb_list_rm
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
break|break;
name|pause
argument_list|(
literal|"NTB Wait for link down"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return;
name|entry
operator|->
name|cb_data
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|flags
operator|=
name|NTBT_LINK_DOWN_FLAG
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|qp
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ntb_process_tx
argument_list|(
name|qp
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|qp
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"ntb: Failed to send link down\n"
argument_list|)
expr_stmt|;
name|ntb_qp_link_down_reset
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* List Management */
end_comment

begin_function
specifier|static
name|void
name|ntb_list_add
parameter_list|(
name|struct
name|mtx
modifier|*
name|lock
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|ntb_queue_list
modifier|*
name|list
parameter_list|)
block|{
name|mtx_lock_spin
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|list
argument_list|,
name|entry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ntb_queue_entry
modifier|*
name|ntb_list_rm
parameter_list|(
name|struct
name|mtx
modifier|*
name|lock
parameter_list|,
name|struct
name|ntb_queue_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|mtx_lock_spin
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|entry
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|entry
operator|=
name|STAILQ_FIRST
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
name|list
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|out
label|:
name|mtx_unlock_spin
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ntb_queue_entry
modifier|*
name|ntb_list_mv
parameter_list|(
name|struct
name|mtx
modifier|*
name|lock
parameter_list|,
name|struct
name|ntb_queue_list
modifier|*
name|from
parameter_list|,
name|struct
name|ntb_queue_list
modifier|*
name|to
parameter_list|)
block|{
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|mtx_lock_spin
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
name|from
argument_list|)
condition|)
block|{
name|entry
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|entry
operator|=
name|STAILQ_FIRST
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
name|from
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|to
argument_list|,
name|entry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|out
label|:
name|mtx_unlock_spin
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_transport_qp_num - Query the qp number  * @qp: NTB transport layer queue to be queried  *  * Query qp number of the NTB transport queue  *  * RETURNS: a zero based number specifying the qp number  */
end_comment

begin_function
name|unsigned
name|char
name|ntb_transport_qp_num
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|qp
operator|->
name|qp_num
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_transport_max_size - Query the max payload size of a qp  * @qp: NTB transport layer queue to be queried  *  * Query the maximum payload size permissible on the given qp  *  * RETURNS: the max payload size of a qp  */
end_comment

begin_function
name|unsigned
name|int
name|ntb_transport_max_size
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|qp
operator|->
name|tx_max_frame
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|ntb_transport_tx_free_entry
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|unsigned
name|int
name|head
init|=
name|qp
operator|->
name|tx_index
decl_stmt|;
name|unsigned
name|int
name|tail
init|=
name|qp
operator|->
name|remote_rx_info
operator|->
name|entry
decl_stmt|;
return|return
operator|(
name|tail
operator|>=
name|head
condition|?
name|tail
operator|-
name|head
else|:
name|qp
operator|->
name|tx_max_entry
operator|+
name|tail
operator|-
name|head
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ntb_transport_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ntb_transport_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ntb_transport_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ntb_transport_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|ntb_transport_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|DEFINE_CLASS_0
argument_list|(
name|ntb_transport
argument_list|,
name|ntb_transport_driver
argument_list|,
name|ntb_transport_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_transport_ctx
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ntb_transport
argument_list|,
name|ntb_hw
argument_list|,
name|ntb_transport_driver
argument_list|,
name|ntb_transport_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ntb_transport
argument_list|,
name|ntb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ntb_transport
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

