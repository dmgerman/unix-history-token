begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 2013 Intel Corporation  * Copyright (C) 2015 EMC Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bitset.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|"../ntb_hw/ntb_hw.h"
end_include

begin_comment
comment|/*  * The Non-Transparent Bridge (NTB) is a device on some Intel processors that  * allows you to connect two systems using a PCI-e link.  *  * This module contains a protocol for sending and receiving messages, and  * exposes that protocol through a simulated ethernet device called ntb.  *  * NOTE: Much of the code in this module is shared with Linux. Any patches may  * be picked up and redistributed in Linux with a dual GPL/BSD license.  */
end_comment

begin_define
define|#
directive|define
name|QP_SETSIZE
value|64
end_define

begin_expr_stmt
name|BITSET_DEFINE
argument_list|(
name|_qpset
argument_list|,
name|QP_SETSIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|test_bit
parameter_list|(
name|pos
parameter_list|,
name|addr
parameter_list|)
value|BIT_ISSET(QP_SETSIZE, (pos), (addr))
end_define

begin_define
define|#
directive|define
name|set_bit
parameter_list|(
name|pos
parameter_list|,
name|addr
parameter_list|)
value|BIT_SET(QP_SETSIZE, (pos), (addr))
end_define

begin_define
define|#
directive|define
name|clear_bit
parameter_list|(
name|pos
parameter_list|,
name|addr
parameter_list|)
value|BIT_CLR(QP_SETSIZE, (pos), (addr))
end_define

begin_define
define|#
directive|define
name|ffs_bit
parameter_list|(
name|addr
parameter_list|)
value|BIT_FFS(QP_SETSIZE, (addr))
end_define

begin_define
define|#
directive|define
name|KTR_NTB
value|KTR_SPARE3
end_define

begin_define
define|#
directive|define
name|NTB_TRANSPORT_VERSION
value|4
end_define

begin_define
define|#
directive|define
name|NTB_RX_MAX_PKTS
value|64
end_define

begin_define
define|#
directive|define
name|NTB_RXQ_SIZE
value|300
end_define

begin_enum
enum|enum
name|ntb_link_event
block|{
name|NTB_LINK_DOWN
init|=
literal|0
block|,
name|NTB_LINK_UP
block|, }
enum|;
end_enum

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|if_ntb
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"if_ntb"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|g_if_ntb_debug_level
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_if_ntb
argument_list|,
name|OID_AUTO
argument_list|,
name|debug_level
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|g_if_ntb_debug_level
argument_list|,
literal|0
argument_list|,
literal|"if_ntb log level -- higher is more verbose"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|ntb_printf
parameter_list|(
name|lvl
parameter_list|,
modifier|...
parameter_list|)
value|do {			\ 	if ((lvl)<= g_if_ntb_debug_level) {		\ 		if_printf(nt->ifp, __VA_ARGS__);	\ 	}						\ } while (0)
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|transport_mtu
init|=
literal|0x10000
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|max_mw_size
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UQUAD
argument_list|(
name|_hw_if_ntb
argument_list|,
name|OID_AUTO
argument_list|,
name|max_mw_size
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|max_mw_size
argument_list|,
literal|0
argument_list|,
literal|"If enabled (non-zero), limit the size of large memory windows. "
literal|"Both sides of the NTB MUST set the same value here."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|max_num_clients
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_if_ntb
argument_list|,
name|OID_AUTO
argument_list|,
name|max_num_clients
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|max_num_clients
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of NTB transport clients.  "
literal|"0 (default) - use all available NTB memory windows; "
literal|"positive integer N - Limit to N memory windows."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STAILQ_HEAD
argument_list|(
name|ntb_queue_list
argument_list|,
name|ntb_queue_entry
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|uint32_t
name|ntb_q_idx_t
typedef|;
end_typedef

begin_struct
struct|struct
name|ntb_queue_entry
block|{
comment|/* ntb_queue list reference */
name|STAILQ_ENTRY
argument_list|(
argument|ntb_queue_entry
argument_list|)
name|entry
expr_stmt|;
comment|/* info on data to be transferred */
name|void
modifier|*
name|cb_data
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|struct
name|ntb_transport_qp
modifier|*
name|qp
decl_stmt|;
name|struct
name|ntb_payload_header
modifier|*
name|x_hdr
decl_stmt|;
name|ntb_q_idx_t
name|index
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_rx_info
block|{
name|ntb_q_idx_t
name|entry
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_transport_qp
block|{
name|struct
name|ntb_transport_ctx
modifier|*
name|transport
decl_stmt|;
name|struct
name|ntb_softc
modifier|*
name|ntb
decl_stmt|;
name|void
modifier|*
name|cb_data
decl_stmt|;
name|bool
name|client_ready
decl_stmt|;
specifier|volatile
name|bool
name|link_is_up
decl_stmt|;
name|uint8_t
name|qp_num
decl_stmt|;
comment|/* Only 64 QPs are allowed.  0-63 */
name|struct
name|ntb_rx_info
modifier|*
name|rx_info
decl_stmt|;
name|struct
name|ntb_rx_info
modifier|*
name|remote_rx_info
decl_stmt|;
name|void
function_decl|(
modifier|*
name|tx_handler
function_decl|)
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|qp_data
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
name|struct
name|ntb_queue_list
name|tx_free_q
decl_stmt|;
name|struct
name|mtx
name|ntb_tx_free_q_lock
decl_stmt|;
name|caddr_t
name|tx_mw
decl_stmt|;
name|bus_addr_t
name|tx_mw_phys
decl_stmt|;
name|ntb_q_idx_t
name|tx_index
decl_stmt|;
name|ntb_q_idx_t
name|tx_max_entry
decl_stmt|;
name|uint64_t
name|tx_max_frame
decl_stmt|;
name|void
function_decl|(
modifier|*
name|rx_handler
function_decl|)
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|qp_data
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
name|struct
name|ntb_queue_list
name|rx_post_q
decl_stmt|;
name|struct
name|ntb_queue_list
name|rx_pend_q
decl_stmt|;
name|struct
name|ntb_queue_list
name|rx_free_q
decl_stmt|;
comment|/* ntb_rx_q_lock: synchronize access to rx_XXXX_q */
name|struct
name|mtx
name|ntb_rx_q_lock
decl_stmt|;
name|struct
name|task
name|rx_completion_task
decl_stmt|;
name|struct
name|task
name|rxc_db_work
decl_stmt|;
name|caddr_t
name|rx_buff
decl_stmt|;
name|ntb_q_idx_t
name|rx_index
decl_stmt|;
name|ntb_q_idx_t
name|rx_max_entry
decl_stmt|;
name|uint64_t
name|rx_max_frame
decl_stmt|;
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|enum
name|ntb_link_event
name|status
parameter_list|)
function_decl|;
name|struct
name|callout
name|link_work
decl_stmt|;
name|struct
name|callout
name|queue_full
decl_stmt|;
name|struct
name|callout
name|rx_full
decl_stmt|;
name|uint64_t
name|last_rx_no_buf
decl_stmt|;
comment|/* Stats */
name|uint64_t
name|rx_bytes
decl_stmt|;
name|uint64_t
name|rx_pkts
decl_stmt|;
name|uint64_t
name|rx_ring_empty
decl_stmt|;
name|uint64_t
name|rx_err_no_buf
decl_stmt|;
name|uint64_t
name|rx_err_oflow
decl_stmt|;
name|uint64_t
name|rx_err_ver
decl_stmt|;
name|uint64_t
name|tx_bytes
decl_stmt|;
name|uint64_t
name|tx_pkts
decl_stmt|;
name|uint64_t
name|tx_ring_full
decl_stmt|;
name|uint64_t
name|tx_err_no_buf
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_queue_handlers
block|{
name|void
function_decl|(
modifier|*
name|rx_handler
function_decl|)
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|qp_data
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|tx_handler
function_decl|)
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|qp_data
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|enum
name|ntb_link_event
name|status
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_transport_mw
block|{
name|vm_paddr_t
name|phys_addr
decl_stmt|;
name|size_t
name|phys_size
decl_stmt|;
name|size_t
name|xlat_align
decl_stmt|;
name|size_t
name|xlat_align_size
decl_stmt|;
name|bus_addr_t
name|addr_limit
decl_stmt|;
comment|/* Tx buff is off vbase / phys_addr */
name|caddr_t
name|vbase
decl_stmt|;
name|size_t
name|xlat_size
decl_stmt|;
name|size_t
name|buff_size
decl_stmt|;
comment|/* Rx buff is off virt_addr / dma_addr */
name|caddr_t
name|virt_addr
decl_stmt|;
name|bus_addr_t
name|dma_addr
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_transport_ctx
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ntb_transport_mw
name|mw_vec
index|[
name|NTB_MAX_NUM_MW
index|]
decl_stmt|;
name|struct
name|ntb_transport_qp
modifier|*
name|qp_vec
decl_stmt|;
name|struct
name|_qpset
name|qp_bitmap
decl_stmt|;
name|struct
name|_qpset
name|qp_bitmap_free
decl_stmt|;
name|unsigned
name|mw_count
decl_stmt|;
name|unsigned
name|qp_count
decl_stmt|;
specifier|volatile
name|bool
name|link_is_up
decl_stmt|;
name|struct
name|callout
name|link_work
decl_stmt|;
name|struct
name|task
name|link_cleanup
decl_stmt|;
name|uint64_t
name|bufsize
decl_stmt|;
name|u_char
name|eaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|struct
name|mtx
name|tx_lock
decl_stmt|;
name|struct
name|mtx
name|rx_lock
decl_stmt|;
comment|/* The hardcoded single queuepair in ntb_setup_interface() */
name|struct
name|ntb_transport_qp
modifier|*
name|qp
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ntb_transport_ctx
name|net_softc
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
block|{
name|IF_NTB_DESC_DONE_FLAG
init|=
literal|1
operator|<<
literal|0
block|,
name|IF_NTB_LINK_DOWN_FLAG
init|=
literal|1
operator|<<
literal|1
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|ntb_payload_header
block|{
name|ntb_q_idx_t
name|ver
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
comment|/* 	 * The order of this enum is part of the if_ntb remote protocol.  Do 	 * not reorder without bumping protocol version (and it's probably best 	 * to keep the protocol in lock-step with the Linux NTB driver. 	 */
name|IF_NTB_VERSION
init|=
literal|0
block|,
name|IF_NTB_QP_LINKS
block|,
name|IF_NTB_NUM_QPS
block|,
name|IF_NTB_NUM_MWS
block|,
comment|/* 	 * N.B.: transport_link_work assumes MW1 enums = MW0 + 2. 	 */
name|IF_NTB_MW0_SZ_HIGH
block|,
name|IF_NTB_MW0_SZ_LOW
block|,
name|IF_NTB_MW1_SZ_HIGH
block|,
name|IF_NTB_MW1_SZ_LOW
block|,
name|IF_NTB_MAX_SPAD
block|, }
enum|;
end_enum

begin_define
define|#
directive|define
name|QP_TO_MW
parameter_list|(
name|nt
parameter_list|,
name|qp
parameter_list|)
value|((qp) % nt->mw_count)
end_define

begin_define
define|#
directive|define
name|NTB_QP_DEF_NUM_ENTRIES
value|100
end_define

begin_define
define|#
directive|define
name|NTB_LINK_DOWN_TIMEOUT
value|10
end_define

begin_function_decl
specifier|static
name|int
name|ntb_handle_module_events
parameter_list|(
name|struct
name|module
modifier|*
name|m
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_setup_interface
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_teardown_interface
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_net_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_net_tx_handler
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|qp_data
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_net_rx_handler
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|qp_data
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_net_event_handler
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|enum
name|ntb_link_event
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_transport_probe
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_free
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_init_queue
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
parameter_list|,
name|unsigned
name|int
name|qp_num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_free_queue
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ntb_transport_qp
modifier|*
name|ntb_transport_create_queue
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|ntb_softc
modifier|*
name|pdev
parameter_list|,
specifier|const
name|struct
name|ntb_queue_handlers
modifier|*
name|handlers
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_link_up
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_transport_tx_enqueue
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_process_tx
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_memcpy_tx
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_qp_full
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_rxc_db
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_process_rxc
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_memcpy_rx
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ntb_rx_copy_callback
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_complete_rxc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_doorbell_callback
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|vector
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_event_callback
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_link_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_set_mw
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
parameter_list|,
name|int
name|num_mw
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_free_mw
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
parameter_list|,
name|int
name|num_mw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_transport_setup_qp_mw
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
parameter_list|,
name|unsigned
name|int
name|qp_num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_qp_link_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_link_cleanup
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_link_cleanup_work
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_qp_link_down
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_qp_link_down_reset
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_qp_link_cleanup
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_link_down
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_send_link_down
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_list_add
parameter_list|(
name|struct
name|mtx
modifier|*
name|lock
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|ntb_queue_list
modifier|*
name|list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ntb_queue_entry
modifier|*
name|ntb_list_rm
parameter_list|(
name|struct
name|mtx
modifier|*
name|lock
parameter_list|,
name|struct
name|ntb_queue_list
modifier|*
name|list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ntb_queue_entry
modifier|*
name|ntb_list_mv
parameter_list|(
name|struct
name|mtx
modifier|*
name|lock
parameter_list|,
name|struct
name|ntb_queue_list
modifier|*
name|from
parameter_list|,
name|struct
name|ntb_queue_list
modifier|*
name|to
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_random_local_eui48
parameter_list|(
name|u_char
modifier|*
name|eaddr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|ntb_transport_max_size
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ntb_ctx_ops
name|ntb_transport_ops
init|=
block|{
operator|.
name|link_event
operator|=
name|ntb_transport_event_callback
block|,
operator|.
name|db_event
operator|=
name|ntb_transport_doorbell_callback
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NTB_IF
argument_list|,
literal|"if_ntb"
argument_list|,
literal|"ntb network driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
specifier|inline
name|void
name|iowrite32
parameter_list|(
name|uint32_t
name|val
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|bus_space_write_4
argument_list|(
name|X86_BUS_SPACE_MEM
argument_list|,
literal|0
comment|/* HACK */
argument_list|,
operator|(
name|uintptr_t
operator|)
name|addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Module setup and teardown */
end_comment

begin_function
specifier|static
name|int
name|ntb_handle_module_events
parameter_list|(
name|struct
name|module
modifier|*
name|m
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|err
operator|=
name|ntb_setup_interface
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|err
operator|=
name|ntb_teardown_interface
argument_list|()
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|if_ntb_mod
init|=
block|{
literal|"if_ntb"
block|,
name|ntb_handle_module_events
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|if_ntb
argument_list|,
name|if_ntb_mod
argument_list|,
name|SI_SUB_KLD
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|if_ntb
argument_list|,
name|ntb_hw
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|ntb_setup_interface
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ntb_queue_handlers
name|handlers
init|=
block|{
name|ntb_net_rx_handler
block|,
name|ntb_net_tx_handler
block|,
name|ntb_net_event_handler
block|}
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|net_softc
operator|.
name|ntb
operator|=
name|devclass_get_softc
argument_list|(
name|devclass_find
argument_list|(
literal|"ntb_hw"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|net_softc
operator|.
name|ntb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ntb: Cannot find devclass\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ifp
operator|=
name|net_softc
operator|.
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|ntb_transport_free
argument_list|(
operator|&
name|net_softc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ntb: Cannot allocate ifnet structure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
literal|"ntb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ntb_transport_probe
argument_list|(
name|net_softc
operator|.
name|ntb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ntb: Cannot init transport: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|net_softc
operator|.
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|net_softc
operator|.
name|qp
operator|=
name|ntb_transport_create_queue
argument_list|(
name|ifp
argument_list|,
name|net_softc
operator|.
name|ntb
argument_list|,
operator|&
name|handlers
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ntb_net_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
operator|&
name|net_softc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ntb_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ntb_start
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|IFQ_MAXLEN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|create_random_local_eui48
argument_list|(
name|net_softc
operator|.
name|eaddr
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|net_softc
operator|.
name|eaddr
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_HWCSUM
operator||
name|IFCAP_JUMBO_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
name|ntb_transport_link_up
argument_list|(
name|net_softc
operator|.
name|qp
argument_list|)
expr_stmt|;
name|net_softc
operator|.
name|bufsize
operator|=
name|ntb_transport_max_size
argument_list|(
name|net_softc
operator|.
name|qp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_teardown_interface
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|net_softc
operator|.
name|qp
operator|!=
name|NULL
condition|)
block|{
name|ntb_transport_link_down
argument_list|(
name|net_softc
operator|.
name|qp
argument_list|)
expr_stmt|;
name|ntb_transport_free_queue
argument_list|(
name|net_softc
operator|.
name|qp
argument_list|)
expr_stmt|;
name|ntb_transport_free
argument_list|(
operator|&
name|net_softc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|net_softc
operator|.
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|ether_ifdetach
argument_list|(
name|net_softc
operator|.
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|net_softc
operator|.
name|ifp
argument_list|)
expr_stmt|;
name|net_softc
operator|.
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Network device interface */
end_comment

begin_function
specifier|static
name|void
name|ntb_net_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_transport_ctx
modifier|*
name|ntb_softc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ntb_softc
operator|->
name|ifp
decl_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
block|{
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ntb_transport_max_size
argument_list|(
name|nt
operator|->
name|qp
argument_list|)
operator|-
name|ETHER_HDR_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nt
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: ntb_start"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: start mbuf %p"
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ntb_transport_tx_enqueue
argument_list|(
name|nt
operator|->
name|qp
argument_list|,
name|m_head
argument_list|,
name|m_head
argument_list|,
name|m_length
argument_list|(
name|m_head
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: could not tx mbuf %p. Returning to snd q"
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|EAGAIN
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|nt
operator|->
name|qp
operator|->
name|queue_full
argument_list|,
name|hz
operator|/
literal|1000
argument_list|,
name|ntb_qp_full
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nt
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Network Device Callbacks */
end_comment

begin_function
specifier|static
name|void
name|ntb_net_tx_handler
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|qp_data
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|m_freem
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: tx_handler freeing mbuf %p"
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_net_rx_handler
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|qp_data
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|data
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|qp_data
decl_stmt|;
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: rx handler"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_net_event_handler
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|enum
name|ntb_link_event
name|status
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|data
expr_stmt|;
operator|(
name|void
operator|)
name|ifp
expr_stmt|;
comment|/* XXX The Linux driver munges with the carrier status here. */
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|NTB_LINK_DOWN
case|:
break|break;
case|case
name|NTB_LINK_UP
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"Bogus ntb_link_event %u\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Transport Init and teardown */
end_comment

begin_function
specifier|static
name|int
name|ntb_transport_probe
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
init|=
operator|&
name|net_softc
decl_stmt|;
name|struct
name|ntb_transport_mw
modifier|*
name|mw
decl_stmt|;
name|uint64_t
name|qp_bitmap
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|nt
operator|->
name|mw_count
operator|=
name|ntb_mw_count
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|mw_count
condition|;
name|i
operator|++
control|)
block|{
name|mw
operator|=
operator|&
name|nt
operator|->
name|mw_vec
index|[
name|i
index|]
expr_stmt|;
name|rc
operator|=
name|ntb_mw_get_range
argument_list|(
name|ntb
argument_list|,
name|i
argument_list|,
operator|&
name|mw
operator|->
name|phys_addr
argument_list|,
operator|&
name|mw
operator|->
name|vbase
argument_list|,
operator|&
name|mw
operator|->
name|phys_size
argument_list|,
operator|&
name|mw
operator|->
name|xlat_align
argument_list|,
operator|&
name|mw
operator|->
name|xlat_align_size
argument_list|,
operator|&
name|mw
operator|->
name|addr_limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|mw
operator|->
name|buff_size
operator|=
literal|0
expr_stmt|;
name|mw
operator|->
name|xlat_size
operator|=
literal|0
expr_stmt|;
name|mw
operator|->
name|virt_addr
operator|=
name|NULL
expr_stmt|;
name|mw
operator|->
name|dma_addr
operator|=
literal|0
expr_stmt|;
block|}
name|qp_bitmap
operator|=
name|ntb_db_valid_mask
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|nt
operator|->
name|qp_count
operator|=
name|flsll
argument_list|(
name|qp_bitmap
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nt
operator|->
name|qp_count
operator|!=
literal|0
argument_list|,
operator|(
literal|"bogus db bitmap"
operator|)
argument_list|)
expr_stmt|;
name|nt
operator|->
name|qp_count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|max_num_clients
operator|!=
literal|0
operator|&&
name|max_num_clients
operator|<
name|nt
operator|->
name|qp_count
condition|)
name|nt
operator|->
name|qp_count
operator|=
name|max_num_clients
expr_stmt|;
elseif|else
if|if
condition|(
name|nt
operator|->
name|mw_count
operator|<
name|nt
operator|->
name|qp_count
condition|)
name|nt
operator|->
name|qp_count
operator|=
name|nt
operator|->
name|mw_count
expr_stmt|;
name|KASSERT
argument_list|(
name|nt
operator|->
name|qp_count
operator|<=
name|QP_SETSIZE
argument_list|,
operator|(
literal|"invalid qp_count"
operator|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nt
operator|->
name|tx_lock
argument_list|,
literal|"ntb transport tx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nt
operator|->
name|rx_lock
argument_list|,
literal|"ntb transport rx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|nt
operator|->
name|qp_vec
operator|=
name|malloc
argument_list|(
name|nt
operator|->
name|qp_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|nt
operator|->
name|qp_vec
argument_list|)
argument_list|,
name|M_NTB_IF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|qp_count
condition|;
name|i
operator|++
control|)
block|{
name|set_bit
argument_list|(
name|i
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|i
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap_free
argument_list|)
expr_stmt|;
name|ntb_transport_init_queue
argument_list|(
name|nt
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|callout_init
argument_list|(
operator|&
name|nt
operator|->
name|link_work
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|nt
operator|->
name|link_cleanup
argument_list|,
literal|0
argument_list|,
name|ntb_transport_link_cleanup_work
argument_list|,
name|nt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ntb_set_ctx
argument_list|(
name|ntb
argument_list|,
name|nt
argument_list|,
operator|&
name|ntb_transport_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|nt
operator|->
name|link_is_up
operator|=
name|false
expr_stmt|;
name|ntb_link_enable
argument_list|(
name|ntb
argument_list|,
name|NTB_SPEED_AUTO
argument_list|,
name|NTB_WIDTH_AUTO
argument_list|)
expr_stmt|;
name|ntb_link_event
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|nt
operator|->
name|link_work
argument_list|,
literal|0
argument_list|,
name|ntb_transport_link_work
argument_list|,
name|nt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
name|free
argument_list|(
name|nt
operator|->
name|qp_vec
argument_list|,
name|M_NTB_IF
argument_list|)
expr_stmt|;
name|nt
operator|->
name|qp_vec
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_transport_free
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
parameter_list|)
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|nt
operator|->
name|ntb
decl_stmt|;
name|struct
name|_qpset
name|qp_bitmap_alloc
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|ntb_transport_link_cleanup
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|nt
operator|->
name|link_cleanup
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|nt
operator|->
name|link_work
argument_list|)
expr_stmt|;
name|BIT_COPY
argument_list|(
name|QP_SETSIZE
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap
argument_list|,
operator|&
name|qp_bitmap_alloc
argument_list|)
expr_stmt|;
name|BIT_NAND
argument_list|(
name|QP_SETSIZE
argument_list|,
operator|&
name|qp_bitmap_alloc
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap_free
argument_list|)
expr_stmt|;
comment|/* Verify that all the QPs are freed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|qp_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|test_bit
argument_list|(
name|i
argument_list|,
operator|&
name|qp_bitmap_alloc
argument_list|)
condition|)
name|ntb_transport_free_queue
argument_list|(
operator|&
name|nt
operator|->
name|qp_vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ntb_link_disable
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
name|ntb_clear_ctx
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|mw_count
condition|;
name|i
operator|++
control|)
name|ntb_free_mw
argument_list|(
name|nt
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nt
operator|->
name|qp_vec
argument_list|,
name|M_NTB_IF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_transport_init_queue
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
parameter_list|,
name|unsigned
name|int
name|qp_num
parameter_list|)
block|{
name|struct
name|ntb_transport_mw
modifier|*
name|mw
decl_stmt|;
name|struct
name|ntb_transport_qp
modifier|*
name|qp
decl_stmt|;
name|vm_paddr_t
name|mw_base
decl_stmt|;
name|uint64_t
name|mw_size
decl_stmt|,
name|qp_offset
decl_stmt|;
name|size_t
name|tx_size
decl_stmt|;
name|unsigned
name|num_qps_mw
decl_stmt|,
name|mw_num
decl_stmt|,
name|mw_count
decl_stmt|;
name|mw_count
operator|=
name|nt
operator|->
name|mw_count
expr_stmt|;
name|mw_num
operator|=
name|QP_TO_MW
argument_list|(
name|nt
argument_list|,
name|qp_num
argument_list|)
expr_stmt|;
name|mw
operator|=
operator|&
name|nt
operator|->
name|mw_vec
index|[
name|mw_num
index|]
expr_stmt|;
name|qp
operator|=
operator|&
name|nt
operator|->
name|qp_vec
index|[
name|qp_num
index|]
expr_stmt|;
name|qp
operator|->
name|qp_num
operator|=
name|qp_num
expr_stmt|;
name|qp
operator|->
name|transport
operator|=
name|nt
expr_stmt|;
name|qp
operator|->
name|ntb
operator|=
name|nt
operator|->
name|ntb
expr_stmt|;
name|qp
operator|->
name|client_ready
operator|=
name|false
expr_stmt|;
name|qp
operator|->
name|event_handler
operator|=
name|NULL
expr_stmt|;
name|ntb_qp_link_down_reset
argument_list|(
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|qp_count
operator|%
name|mw_count
operator|&&
name|mw_num
operator|+
literal|1
operator|<
name|nt
operator|->
name|qp_count
operator|/
name|mw_count
condition|)
name|num_qps_mw
operator|=
name|nt
operator|->
name|qp_count
operator|/
name|mw_count
operator|+
literal|1
expr_stmt|;
else|else
name|num_qps_mw
operator|=
name|nt
operator|->
name|qp_count
operator|/
name|mw_count
expr_stmt|;
name|mw_base
operator|=
name|mw
operator|->
name|phys_addr
expr_stmt|;
name|mw_size
operator|=
name|mw
operator|->
name|phys_size
expr_stmt|;
name|tx_size
operator|=
name|mw_size
operator|/
name|num_qps_mw
expr_stmt|;
name|qp_offset
operator|=
name|tx_size
operator|*
operator|(
name|qp_num
operator|/
name|mw_count
operator|)
expr_stmt|;
name|qp
operator|->
name|tx_mw
operator|=
name|mw
operator|->
name|vbase
operator|+
name|qp_offset
expr_stmt|;
name|KASSERT
argument_list|(
name|qp
operator|->
name|tx_mw
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uh oh?"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX Assumes that a vm_paddr_t is equivalent to bus_addr_t */
name|qp
operator|->
name|tx_mw_phys
operator|=
name|mw_base
operator|+
name|qp_offset
expr_stmt|;
name|KASSERT
argument_list|(
name|qp
operator|->
name|tx_mw_phys
operator|!=
literal|0
argument_list|,
operator|(
literal|"uh oh?"
operator|)
argument_list|)
expr_stmt|;
name|tx_size
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_rx_info
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rx_info
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|qp
operator|->
name|tx_mw
operator|+
name|tx_size
operator|)
expr_stmt|;
comment|/* Due to house-keeping, there must be at least 2 buffs */
name|qp
operator|->
name|tx_max_frame
operator|=
name|qmin
argument_list|(
name|tx_size
operator|/
literal|2
argument_list|,
name|transport_mtu
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
argument_list|)
expr_stmt|;
name|qp
operator|->
name|tx_max_entry
operator|=
name|tx_size
operator|/
name|qp
operator|->
name|tx_max_frame
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|qp
operator|->
name|queue_full
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|qp
operator|->
name|rx_full
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_q_lock
argument_list|,
literal|"ntb rx q"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
literal|"ntb tx free q"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|qp
operator|->
name|rx_completion_task
argument_list|,
literal|0
argument_list|,
name|ntb_complete_rxc
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|qp
operator|->
name|rxc_db_work
argument_list|,
literal|0
argument_list|,
name|ntb_transport_rxc_db
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|qp
operator|->
name|rx_post_q
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|qp
operator|->
name|rx_pend_q
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|qp
operator|->
name|rx_free_q
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|,
literal|0
argument_list|,
name|ntb_qp_link_work
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_transport_free_queue
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
return|return;
name|callout_drain
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|)
expr_stmt|;
name|ntb_db_set_mask
argument_list|(
name|qp
operator|->
name|ntb
argument_list|,
literal|1ull
operator|<<
name|qp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|qp
operator|->
name|rxc_db_work
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|qp
operator|->
name|rx_completion_task
argument_list|)
expr_stmt|;
name|qp
operator|->
name|cb_data
operator|=
name|NULL
expr_stmt|;
name|qp
operator|->
name|rx_handler
operator|=
name|NULL
expr_stmt|;
name|qp
operator|->
name|tx_handler
operator|=
name|NULL
expr_stmt|;
name|qp
operator|->
name|event_handler
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|ntb_list_rm
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|rx_free_q
argument_list|)
operator|)
condition|)
name|free
argument_list|(
name|entry
argument_list|,
name|M_NTB_IF
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|ntb_list_rm
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|rx_pend_q
argument_list|)
operator|)
condition|)
name|free
argument_list|(
name|entry
argument_list|,
name|M_NTB_IF
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|ntb_list_rm
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|rx_post_q
argument_list|)
operator|)
condition|)
name|free
argument_list|(
name|entry
argument_list|,
name|M_NTB_IF
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|ntb_list_rm
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
operator|)
condition|)
name|free
argument_list|(
name|entry
argument_list|,
name|M_NTB_IF
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|qp
operator|->
name|qp_num
argument_list|,
operator|&
name|qp
operator|->
name|transport
operator|->
name|qp_bitmap_free
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ntb_transport_create_queue - Create a new NTB transport layer queue  * @rx_handler: receive callback function  * @tx_handler: transmit callback function  * @event_handler: event callback function  *  * Create a new NTB transport layer queue and provide the queue with a callback  * routine for both transmit and receive.  The receive callback routine will be  * used to pass up data when the transport has received it on the queue.   The  * transmit callback routine will be called when the transport has completed the  * transmission of the data on the queue and the data is ready to be freed.  *  * RETURNS: pointer to newly created ntb_queue, NULL on error.  */
end_comment

begin_function
specifier|static
name|struct
name|ntb_transport_qp
modifier|*
name|ntb_transport_create_queue
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|,
specifier|const
name|struct
name|ntb_queue_handlers
modifier|*
name|handlers
parameter_list|)
block|{
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|ntb_transport_qp
modifier|*
name|qp
decl_stmt|;
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
decl_stmt|;
name|unsigned
name|int
name|free_queue
decl_stmt|;
name|int
name|i
decl_stmt|;
name|nt
operator|=
name|ntb_get_ctx
argument_list|(
name|ntb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"bogus"
operator|)
argument_list|)
expr_stmt|;
name|free_queue
operator|=
name|ffs_bit
argument_list|(
operator|&
name|nt
operator|->
name|qp_bitmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_queue
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* decrement free_queue to make it zero based */
name|free_queue
operator|--
expr_stmt|;
name|qp
operator|=
operator|&
name|nt
operator|->
name|qp_vec
index|[
name|free_queue
index|]
expr_stmt|;
name|clear_bit
argument_list|(
name|qp
operator|->
name|qp_num
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap_free
argument_list|)
expr_stmt|;
name|qp
operator|->
name|cb_data
operator|=
name|data
expr_stmt|;
name|qp
operator|->
name|rx_handler
operator|=
name|handlers
operator|->
name|rx_handler
expr_stmt|;
name|qp
operator|->
name|tx_handler
operator|=
name|handlers
operator|->
name|tx_handler
expr_stmt|;
name|qp
operator|->
name|event_handler
operator|=
name|handlers
operator|->
name|event_handler
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTB_QP_DEF_NUM_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|,
name|M_NTB_IF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|entry
operator|->
name|cb_data
operator|=
name|nt
operator|->
name|ifp
expr_stmt|;
name|entry
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|len
operator|=
name|transport_mtu
expr_stmt|;
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|rx_pend_q
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTB_QP_DEF_NUM_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|,
name|M_NTB_IF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
block|}
name|ntb_db_clear
argument_list|(
name|ntb
argument_list|,
literal|1ull
operator|<<
name|qp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
name|ntb_db_clear_mask
argument_list|(
name|ntb
argument_list|,
literal|1ull
operator|<<
name|qp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
return|return
operator|(
name|qp
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_transport_link_up - Notify NTB transport of client readiness to use queue  * @qp: NTB transport layer queue to be enabled  *  * Notify NTB transport layer of client readiness to use queue  */
end_comment

begin_function
specifier|static
name|void
name|ntb_transport_link_up
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
decl_stmt|;
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
return|return;
name|qp
operator|->
name|client_ready
operator|=
name|true
expr_stmt|;
name|nt
operator|=
name|qp
operator|->
name|transport
expr_stmt|;
name|ntb_printf
argument_list|(
literal|2
argument_list|,
literal|"qp client ready\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|transport
operator|->
name|link_is_up
condition|)
name|callout_reset
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|,
literal|0
argument_list|,
name|ntb_qp_link_work
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Transport Tx */
end_comment

begin_comment
comment|/**  * ntb_transport_tx_enqueue - Enqueue a new NTB queue entry  * @qp: NTB transport layer queue the entry is to be enqueued on  * @cb: per buffer pointer for callback function to use  * @data: pointer to data buffer that will be sent  * @len: length of the data buffer  *  * Enqueue a new transmit buffer onto the transport queue from which a NTB  * payload will be transmitted.  This assumes that a lock is being held to  * serialize access to the qp.  *  * RETURNS: An appropriate ERRNO error value on error, or zero for success.  */
end_comment

begin_function
specifier|static
name|int
name|ntb_transport_tx_enqueue
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|qp
operator|==
name|NULL
operator|||
operator|!
name|qp
operator|->
name|link_is_up
operator|||
name|len
operator|==
literal|0
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: link not up"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|entry
operator|=
name|ntb_list_rm
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: could not get entry from tx_free_q"
argument_list|)
expr_stmt|;
name|qp
operator|->
name|tx_err_no_buf
operator|++
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: got entry %p from tx_free_q"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|cb_data
operator|=
name|cb
expr_stmt|;
name|entry
operator|->
name|buf
operator|=
name|data
expr_stmt|;
name|entry
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|entry
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|ntb_process_tx
argument_list|(
name|qp
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: process_tx failed. Returning entry %p to tx_free_q"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_process_tx
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|)
block|{
name|void
modifier|*
name|offset
decl_stmt|;
name|offset
operator|=
name|qp
operator|->
name|tx_mw
operator|+
name|qp
operator|->
name|tx_max_frame
operator|*
name|qp
operator|->
name|tx_index
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: process_tx: tx_pkts=%lu, tx_index=%u, remote entry=%u"
argument_list|,
name|qp
operator|->
name|tx_pkts
argument_list|,
name|qp
operator|->
name|tx_index
argument_list|,
name|qp
operator|->
name|remote_rx_info
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|tx_index
operator|==
name|qp
operator|->
name|remote_rx_info
operator|->
name|entry
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: ring full"
argument_list|)
expr_stmt|;
name|qp
operator|->
name|tx_ring_full
operator|++
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
if|if
condition|(
name|entry
operator|->
name|len
operator|>
name|qp
operator|->
name|tx_max_frame
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|tx_handler
operator|!=
name|NULL
condition|)
name|qp
operator|->
name|tx_handler
argument_list|(
name|qp
argument_list|,
name|qp
operator|->
name|cb_data
argument_list|,
name|entry
operator|->
name|buf
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: frame too big. returning entry %p to tx_free_q"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|CTR2
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: copying entry %p to offset %p"
argument_list|,
name|entry
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ntb_memcpy_tx
argument_list|(
name|qp
argument_list|,
name|entry
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|qp
operator|->
name|tx_index
operator|++
expr_stmt|;
name|qp
operator|->
name|tx_index
operator|%=
name|qp
operator|->
name|tx_max_entry
expr_stmt|;
name|qp
operator|->
name|tx_pkts
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_memcpy_tx
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|ntb_payload_header
modifier|*
name|hdr
decl_stmt|;
comment|/* This piece is from Linux' ntb_async_tx() */
name|hdr
operator|=
operator|(
expr|struct
name|ntb_payload_header
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|offset
operator|+
name|qp
operator|->
name|tx_max_frame
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
operator|)
expr_stmt|;
name|entry
operator|->
name|x_hdr
operator|=
name|hdr
expr_stmt|;
name|iowrite32
argument_list|(
name|entry
operator|->
name|len
argument_list|,
operator|&
name|hdr
operator|->
name|len
argument_list|)
expr_stmt|;
name|iowrite32
argument_list|(
name|qp
operator|->
name|tx_pkts
argument_list|,
operator|&
name|hdr
operator|->
name|ver
argument_list|)
expr_stmt|;
comment|/* This piece is ntb_memcpy_tx() */
name|CTR2
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: copying %d bytes to offset %p"
argument_list|,
name|entry
operator|->
name|len
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|m_copydata
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|entry
operator|->
name|buf
argument_list|,
literal|0
argument_list|,
name|entry
operator|->
name|len
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* 		 * Ensure that the data is fully copied before setting the 		 * flags 		 */
name|wmb
argument_list|()
expr_stmt|;
block|}
comment|/* The rest is ntb_tx_copy_callback() */
name|iowrite32
argument_list|(
name|entry
operator|->
name|flags
operator||
name|IF_NTB_DESC_DONE_FLAG
argument_list|,
operator|&
name|hdr
operator|->
name|flags
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: hdr %p set DESC_DONE"
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|ntb_peer_db_set
argument_list|(
name|qp
operator|->
name|ntb
argument_list|,
literal|1ull
operator|<<
name|qp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
comment|/* 	 * The entry length can only be zero if the packet is intended to be a 	 * "link down" or similar.  Since no payload is being sent in these 	 * cases, there is nothing to add to the completion queue. 	 */
if|if
condition|(
name|entry
operator|->
name|len
operator|>
literal|0
condition|)
block|{
name|qp
operator|->
name|tx_bytes
operator|+=
name|entry
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|tx_handler
condition|)
name|qp
operator|->
name|tx_handler
argument_list|(
name|qp
argument_list|,
name|qp
operator|->
name|cb_data
argument_list|,
name|entry
operator|->
name|cb_data
argument_list|,
name|entry
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
name|CTR3
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: entry %p sent. hdr->ver = %u, hdr->flags = 0x%x, Returning "
literal|"to tx_free_q"
argument_list|,
name|entry
argument_list|,
name|hdr
operator|->
name|ver
argument_list|,
name|hdr
operator|->
name|flags
argument_list|)
expr_stmt|;
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_qp_full
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: qp_full callout"
argument_list|)
expr_stmt|;
name|ntb_start
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Transport Rx */
end_comment

begin_function
specifier|static
name|void
name|ntb_transport_rxc_db
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|ntb_transport_qp
modifier|*
name|qp
init|=
name|arg
decl_stmt|;
name|ntb_q_idx_t
name|i
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* 	 * Limit the number of packets processed in a single interrupt to 	 * provide fairness to others 	 */
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: transport_rx"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|qp
operator|->
name|transport
operator|->
name|rx_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp
operator|->
name|rx_max_entry
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|ntb_process_rxc
argument_list|(
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: process_rxc failed"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|qp
operator|->
name|transport
operator|->
name|rx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|qp
operator|->
name|rx_max_entry
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|qp
operator|->
name|rxc_db_work
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ntb_db_read
argument_list|(
name|qp
operator|->
name|ntb
argument_list|)
operator|&
operator|(
literal|1ull
operator|<<
name|qp
operator|->
name|qp_num
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* If db is set, clear it and read it back to commit clear. */
name|ntb_db_clear
argument_list|(
name|qp
operator|->
name|ntb
argument_list|,
literal|1ull
operator|<<
name|qp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ntb_db_read
argument_list|(
name|qp
operator|->
name|ntb
argument_list|)
expr_stmt|;
comment|/* 		 * An interrupt may have arrived between finishing 		 * ntb_process_rxc and clearing the doorbell bit: there might 		 * be some more work to do. 		 */
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|qp
operator|->
name|rxc_db_work
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_process_rxc
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|ntb_payload_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|caddr_t
name|offset
decl_stmt|;
name|offset
operator|=
name|qp
operator|->
name|rx_buff
operator|+
name|qp
operator|->
name|rx_max_frame
operator|*
name|qp
operator|->
name|rx_index
expr_stmt|;
name|hdr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|offset
operator|+
name|qp
operator|->
name|rx_max_frame
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
operator|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: process_rxc rx_index = %u"
argument_list|,
name|qp
operator|->
name|rx_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|flags
operator|&
name|IF_NTB_DESC_DONE_FLAG
operator|)
operator|==
literal|0
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: hdr not done"
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rx_ring_empty
operator|++
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|hdr
operator|->
name|flags
operator|&
name|IF_NTB_LINK_DOWN_FLAG
operator|)
operator|!=
literal|0
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: link down"
argument_list|)
expr_stmt|;
name|ntb_qp_link_down
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
if|if
condition|(
name|hdr
operator|->
name|ver
operator|!=
operator|(
name|uint32_t
operator|)
name|qp
operator|->
name|rx_pkts
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: ver != rx_pkts (%x != %lx). "
literal|"Returning entry to rx_pend_q"
argument_list|,
name|hdr
operator|->
name|ver
argument_list|,
name|qp
operator|->
name|rx_pkts
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rx_err_ver
operator|++
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|entry
operator|=
name|ntb_list_mv
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|rx_pend_q
argument_list|,
operator|&
name|qp
operator|->
name|rx_post_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|qp
operator|->
name|rx_err_no_buf
operator|++
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: No entries in rx_pend_q"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|callout_stop
argument_list|(
operator|&
name|qp
operator|->
name|rx_full
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: rx entry %p from rx_pend_q"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|x_hdr
operator|=
name|hdr
expr_stmt|;
name|entry
operator|->
name|index
operator|=
name|qp
operator|->
name|rx_index
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|len
operator|>
name|entry
operator|->
name|len
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: len too long. Wanted %ju got %ju"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|hdr
operator|->
name|len
argument_list|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|len
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rx_err_oflow
operator|++
expr_stmt|;
name|entry
operator|->
name|len
operator|=
operator|-
name|EIO
expr_stmt|;
name|entry
operator|->
name|flags
operator||=
name|IF_NTB_DESC_DONE_FLAG
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|qp
operator|->
name|rx_completion_task
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qp
operator|->
name|rx_bytes
operator|+=
name|hdr
operator|->
name|len
expr_stmt|;
name|qp
operator|->
name|rx_pkts
operator|++
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: received %ld rx_pkts"
argument_list|,
name|qp
operator|->
name|rx_pkts
argument_list|)
expr_stmt|;
name|entry
operator|->
name|len
operator|=
name|hdr
operator|->
name|len
expr_stmt|;
name|ntb_memcpy_rx
argument_list|(
name|qp
argument_list|,
name|entry
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|qp
operator|->
name|rx_index
operator|++
expr_stmt|;
name|qp
operator|->
name|rx_index
operator|%=
name|qp
operator|->
name|rx_max_entry
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_memcpy_rx
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|entry
operator|->
name|cb_data
decl_stmt|;
name|unsigned
name|int
name|len
init|=
name|entry
operator|->
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: copying %d bytes from offset %p"
argument_list|,
name|len
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_devget
argument_list|(
name|offset
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
expr_stmt|;
name|entry
operator|->
name|buf
operator|=
operator|(
name|void
operator|*
operator|)
name|m
expr_stmt|;
comment|/* Ensure that the data is globally visible before clearing the flag */
name|wmb
argument_list|()
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: copied entry %p to mbuf %p."
argument_list|,
name|entry
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ntb_rx_copy_callback
argument_list|(
name|qp
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ntb_rx_copy_callback
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|data
expr_stmt|;
name|entry
operator|->
name|flags
operator||=
name|IF_NTB_DESC_DONE_FLAG
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|qp
operator|->
name|rx_completion_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_complete_rxc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ntb_transport_qp
modifier|*
name|qp
init|=
name|arg
decl_stmt|;
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: rx_completion_task"
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_q_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|qp
operator|->
name|rx_post_q
argument_list|)
condition|)
block|{
name|entry
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|qp
operator|->
name|rx_post_q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|IF_NTB_DESC_DONE_FLAG
operator|)
operator|==
literal|0
condition|)
break|break;
name|entry
operator|->
name|x_hdr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|iowrite32
argument_list|(
name|entry
operator|->
name|index
argument_list|,
operator|&
name|qp
operator|->
name|rx_info
operator|->
name|entry
argument_list|)
expr_stmt|;
name|len
operator|=
name|entry
operator|->
name|len
expr_stmt|;
name|m
operator|=
name|entry
operator|->
name|buf
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|qp
operator|->
name|rx_post_q
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|qp
operator|->
name|rx_free_q
argument_list|,
name|entry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_q_lock
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: completing entry %p, mbuf %p"
argument_list|,
name|entry
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|rx_handler
operator|!=
name|NULL
operator|&&
name|qp
operator|->
name|client_ready
condition|)
name|qp
operator|->
name|rx_handler
argument_list|(
name|qp
argument_list|,
name|qp
operator|->
name|cb_data
argument_list|,
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_q_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_q_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_transport_doorbell_callback
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|vector
parameter_list|)
block|{
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
init|=
name|data
decl_stmt|;
name|struct
name|ntb_transport_qp
modifier|*
name|qp
decl_stmt|;
name|struct
name|_qpset
name|db_bits
decl_stmt|;
name|uint64_t
name|vec_mask
decl_stmt|;
name|unsigned
name|qp_num
decl_stmt|;
name|BIT_COPY
argument_list|(
name|QP_SETSIZE
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap
argument_list|,
operator|&
name|db_bits
argument_list|)
expr_stmt|;
name|BIT_NAND
argument_list|(
name|QP_SETSIZE
argument_list|,
operator|&
name|db_bits
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap_free
argument_list|)
expr_stmt|;
name|vec_mask
operator|=
name|ntb_db_vector_mask
argument_list|(
name|nt
operator|->
name|ntb
argument_list|,
name|vector
argument_list|)
expr_stmt|;
while|while
condition|(
name|vec_mask
operator|!=
literal|0
condition|)
block|{
name|qp_num
operator|=
name|ffsll
argument_list|(
name|vec_mask
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|test_bit
argument_list|(
name|qp_num
argument_list|,
operator|&
name|db_bits
argument_list|)
condition|)
block|{
name|qp
operator|=
operator|&
name|nt
operator|->
name|qp_vec
index|[
name|qp_num
index|]
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|qp
operator|->
name|rxc_db_work
argument_list|)
expr_stmt|;
block|}
name|vec_mask
operator|&=
operator|~
operator|(
literal|1ull
operator|<<
name|qp_num
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Link Event handler */
end_comment

begin_function
specifier|static
name|void
name|ntb_transport_event_callback
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
init|=
name|data
decl_stmt|;
if|if
condition|(
name|ntb_link_is_up
argument_list|(
name|nt
operator|->
name|ntb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|ntb_printf
argument_list|(
literal|1
argument_list|,
literal|"HW link up\n"
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|nt
operator|->
name|link_work
argument_list|,
literal|0
argument_list|,
name|ntb_transport_link_work
argument_list|,
name|nt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ntb_printf
argument_list|(
literal|1
argument_list|,
literal|"HW link down\n"
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|nt
operator|->
name|link_cleanup
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Link bring up */
end_comment

begin_function
specifier|static
name|void
name|ntb_transport_link_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
init|=
name|arg
decl_stmt|;
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|nt
operator|->
name|ntb
decl_stmt|;
name|struct
name|ntb_transport_qp
modifier|*
name|qp
decl_stmt|;
name|uint64_t
name|val64
decl_stmt|,
name|size
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* send the local info, in the opposite order of the way we read it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|mw_count
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|nt
operator|->
name|mw_vec
index|[
name|i
index|]
operator|.
name|phys_size
expr_stmt|;
if|if
condition|(
name|max_mw_size
operator|!=
literal|0
operator|&&
name|size
operator|>
name|max_mw_size
condition|)
name|size
operator|=
name|max_mw_size
expr_stmt|;
name|ntb_peer_spad_write
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_MW0_SZ_HIGH
operator|+
operator|(
name|i
operator|*
literal|2
operator|)
argument_list|,
name|size
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|ntb_peer_spad_write
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_MW0_SZ_LOW
operator|+
operator|(
name|i
operator|*
literal|2
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|ntb_peer_spad_write
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_NUM_MWS
argument_list|,
name|nt
operator|->
name|mw_count
argument_list|)
expr_stmt|;
name|ntb_peer_spad_write
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_NUM_QPS
argument_list|,
name|nt
operator|->
name|qp_count
argument_list|)
expr_stmt|;
name|ntb_peer_spad_write
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_VERSION
argument_list|,
name|NTB_TRANSPORT_VERSION
argument_list|)
expr_stmt|;
comment|/* Query the remote side for its info */
name|val
operator|=
literal|0
expr_stmt|;
name|ntb_spad_read
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_VERSION
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|NTB_TRANSPORT_VERSION
condition|)
goto|goto
name|out
goto|;
name|ntb_spad_read
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_NUM_QPS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|nt
operator|->
name|qp_count
condition|)
goto|goto
name|out
goto|;
name|ntb_spad_read
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_NUM_MWS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|nt
operator|->
name|mw_count
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|mw_count
condition|;
name|i
operator|++
control|)
block|{
name|ntb_spad_read
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_MW0_SZ_HIGH
operator|+
operator|(
name|i
operator|*
literal|2
operator|)
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val64
operator|=
operator|(
name|uint64_t
operator|)
name|val
operator|<<
literal|32
expr_stmt|;
name|ntb_spad_read
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_MW0_SZ_LOW
operator|+
operator|(
name|i
operator|*
literal|2
operator|)
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val64
operator||=
name|val
expr_stmt|;
name|rc
operator|=
name|ntb_set_mw
argument_list|(
name|nt
argument_list|,
name|i
argument_list|,
name|val64
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|free_mws
goto|;
block|}
name|nt
operator|->
name|link_is_up
operator|=
name|true
expr_stmt|;
name|ntb_printf
argument_list|(
literal|1
argument_list|,
literal|"transport link up\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|qp_count
condition|;
name|i
operator|++
control|)
block|{
name|qp
operator|=
operator|&
name|nt
operator|->
name|qp_vec
index|[
name|i
index|]
expr_stmt|;
name|ntb_transport_setup_qp_mw
argument_list|(
name|nt
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|client_ready
condition|)
name|callout_reset
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|,
literal|0
argument_list|,
name|ntb_qp_link_work
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
return|return;
name|free_mws
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|mw_count
condition|;
name|i
operator|++
control|)
name|ntb_free_mw
argument_list|(
name|nt
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ntb_link_is_up
argument_list|(
name|ntb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
name|callout_reset
argument_list|(
operator|&
name|nt
operator|->
name|link_work
argument_list|,
name|NTB_LINK_DOWN_TIMEOUT
operator|*
name|hz
operator|/
literal|1000
argument_list|,
name|ntb_transport_link_work
argument_list|,
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_set_mw
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
parameter_list|,
name|int
name|num_mw
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|ntb_transport_mw
modifier|*
name|mw
init|=
operator|&
name|nt
operator|->
name|mw_vec
index|[
name|num_mw
index|]
decl_stmt|;
name|size_t
name|xlat_size
decl_stmt|,
name|buff_size
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|xlat_size
operator|=
name|roundup
argument_list|(
name|size
argument_list|,
name|mw
operator|->
name|xlat_align_size
argument_list|)
expr_stmt|;
name|buff_size
operator|=
name|roundup
argument_list|(
name|size
argument_list|,
name|mw
operator|->
name|xlat_align
argument_list|)
expr_stmt|;
comment|/* No need to re-setup */
if|if
condition|(
name|mw
operator|->
name|xlat_size
operator|==
name|xlat_size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|mw
operator|->
name|buff_size
operator|!=
literal|0
condition|)
name|ntb_free_mw
argument_list|(
name|nt
argument_list|,
name|num_mw
argument_list|)
expr_stmt|;
comment|/* Alloc memory for receiving data.  Must be aligned */
name|mw
operator|->
name|xlat_size
operator|=
name|xlat_size
expr_stmt|;
name|mw
operator|->
name|buff_size
operator|=
name|buff_size
expr_stmt|;
name|mw
operator|->
name|virt_addr
operator|=
name|contigmalloc
argument_list|(
name|mw
operator|->
name|buff_size
argument_list|,
name|M_NTB_IF
argument_list|,
name|M_ZERO
argument_list|,
literal|0
argument_list|,
name|mw
operator|->
name|addr_limit
argument_list|,
name|mw
operator|->
name|xlat_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mw
operator|->
name|virt_addr
operator|==
name|NULL
condition|)
block|{
name|mw
operator|->
name|xlat_size
operator|=
literal|0
expr_stmt|;
name|mw
operator|->
name|buff_size
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"ntb: Unable to allocate MW buffer of size %zu\n"
argument_list|,
name|mw
operator|->
name|xlat_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* TODO: replace with bus_space_* functions */
name|mw
operator|->
name|dma_addr
operator|=
name|vtophys
argument_list|(
name|mw
operator|->
name|virt_addr
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that the allocation from contigmalloc is aligned as 	 * requested.  XXX: This may not be needed -- brought in for parity 	 * with the Linux driver. 	 */
if|if
condition|(
name|mw
operator|->
name|dma_addr
operator|%
name|mw
operator|->
name|xlat_align
operator|!=
literal|0
condition|)
block|{
name|ntb_printf
argument_list|(
literal|0
argument_list|,
literal|"DMA memory 0x%jx not aligned to BAR size 0x%zx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|mw
operator|->
name|dma_addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ntb_free_mw
argument_list|(
name|nt
argument_list|,
name|num_mw
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Notify HW the memory location of the receive buffer */
name|rc
operator|=
name|ntb_mw_set_trans
argument_list|(
name|nt
operator|->
name|ntb
argument_list|,
name|num_mw
argument_list|,
name|mw
operator|->
name|dma_addr
argument_list|,
name|mw
operator|->
name|xlat_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|ntb_printf
argument_list|(
literal|0
argument_list|,
literal|"Unable to set mw%d translation\n"
argument_list|,
name|num_mw
argument_list|)
expr_stmt|;
name|ntb_free_mw
argument_list|(
name|nt
argument_list|,
name|num_mw
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_free_mw
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
parameter_list|,
name|int
name|num_mw
parameter_list|)
block|{
name|struct
name|ntb_transport_mw
modifier|*
name|mw
init|=
operator|&
name|nt
operator|->
name|mw_vec
index|[
name|num_mw
index|]
decl_stmt|;
if|if
condition|(
name|mw
operator|->
name|virt_addr
operator|==
name|NULL
condition|)
return|return;
name|ntb_mw_clear_trans
argument_list|(
name|nt
operator|->
name|ntb
argument_list|,
name|num_mw
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|mw
operator|->
name|virt_addr
argument_list|,
name|mw
operator|->
name|xlat_size
argument_list|,
name|M_NTB_IF
argument_list|)
expr_stmt|;
name|mw
operator|->
name|xlat_size
operator|=
literal|0
expr_stmt|;
name|mw
operator|->
name|buff_size
operator|=
literal|0
expr_stmt|;
name|mw
operator|->
name|virt_addr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_transport_setup_qp_mw
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
parameter_list|,
name|unsigned
name|int
name|qp_num
parameter_list|)
block|{
name|struct
name|ntb_transport_qp
modifier|*
name|qp
init|=
operator|&
name|nt
operator|->
name|qp_vec
index|[
name|qp_num
index|]
decl_stmt|;
name|struct
name|ntb_transport_mw
modifier|*
name|mw
decl_stmt|;
name|void
modifier|*
name|offset
decl_stmt|;
name|ntb_q_idx_t
name|i
decl_stmt|;
name|size_t
name|rx_size
decl_stmt|;
name|unsigned
name|num_qps_mw
decl_stmt|,
name|mw_num
decl_stmt|,
name|mw_count
decl_stmt|;
name|mw_count
operator|=
name|nt
operator|->
name|mw_count
expr_stmt|;
name|mw_num
operator|=
name|QP_TO_MW
argument_list|(
name|nt
argument_list|,
name|qp_num
argument_list|)
expr_stmt|;
name|mw
operator|=
operator|&
name|nt
operator|->
name|mw_vec
index|[
name|mw_num
index|]
expr_stmt|;
if|if
condition|(
name|mw
operator|->
name|virt_addr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|nt
operator|->
name|qp_count
operator|%
name|mw_count
operator|&&
name|mw_num
operator|+
literal|1
operator|<
name|nt
operator|->
name|qp_count
operator|/
name|mw_count
condition|)
name|num_qps_mw
operator|=
name|nt
operator|->
name|qp_count
operator|/
name|mw_count
operator|+
literal|1
expr_stmt|;
else|else
name|num_qps_mw
operator|=
name|nt
operator|->
name|qp_count
operator|/
name|mw_count
expr_stmt|;
name|rx_size
operator|=
name|mw
operator|->
name|xlat_size
operator|/
name|num_qps_mw
expr_stmt|;
name|qp
operator|->
name|rx_buff
operator|=
name|mw
operator|->
name|virt_addr
operator|+
name|rx_size
operator|*
operator|(
name|qp_num
operator|/
name|mw_count
operator|)
expr_stmt|;
name|rx_size
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_rx_info
argument_list|)
expr_stmt|;
name|qp
operator|->
name|remote_rx_info
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|qp
operator|->
name|rx_buff
operator|+
name|rx_size
operator|)
expr_stmt|;
comment|/* Due to house-keeping, there must be at least 2 buffs */
name|qp
operator|->
name|rx_max_frame
operator|=
name|qmin
argument_list|(
name|rx_size
operator|/
literal|2
argument_list|,
name|transport_mtu
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rx_max_entry
operator|=
name|rx_size
operator|/
name|qp
operator|->
name|rx_max_frame
expr_stmt|;
name|qp
operator|->
name|rx_index
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|remote_rx_info
operator|->
name|entry
operator|=
name|qp
operator|->
name|rx_max_entry
operator|-
literal|1
expr_stmt|;
comment|/* Set up the hdr offsets with 0s */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp
operator|->
name|rx_max_entry
condition|;
name|i
operator|++
control|)
block|{
name|offset
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|qp
operator|->
name|rx_buff
operator|+
name|qp
operator|->
name|rx_max_frame
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|qp
operator|->
name|rx_pkts
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|tx_pkts
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|tx_index
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_qp_link_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_transport_qp
modifier|*
name|qp
init|=
name|arg
decl_stmt|;
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|qp
operator|->
name|ntb
decl_stmt|;
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
init|=
name|qp
operator|->
name|transport
decl_stmt|;
name|uint32_t
name|val
decl_stmt|,
name|dummy
decl_stmt|;
name|ntb_spad_read
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_QP_LINKS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|ntb_peer_spad_write
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_QP_LINKS
argument_list|,
name|val
operator||
operator|(
literal|1ull
operator|<<
name|qp
operator|->
name|qp_num
operator|)
argument_list|)
expr_stmt|;
comment|/* query remote spad for qp ready bits */
name|ntb_peer_spad_read
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_QP_LINKS
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
comment|/* See if the remote side is up */
if|if
condition|(
operator|(
name|val
operator|&
operator|(
literal|1ull
operator|<<
name|qp
operator|->
name|qp_num
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ntb_printf
argument_list|(
literal|2
argument_list|,
literal|"qp link up\n"
argument_list|)
expr_stmt|;
name|qp
operator|->
name|link_is_up
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|event_handler
operator|!=
name|NULL
condition|)
name|qp
operator|->
name|event_handler
argument_list|(
name|qp
operator|->
name|cb_data
argument_list|,
name|NTB_LINK_UP
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|qp
operator|->
name|rxc_db_work
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nt
operator|->
name|link_is_up
condition|)
name|callout_reset
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|,
name|NTB_LINK_DOWN_TIMEOUT
operator|*
name|hz
operator|/
literal|1000
argument_list|,
name|ntb_qp_link_work
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Link down event*/
end_comment

begin_function
specifier|static
name|void
name|ntb_transport_link_cleanup
parameter_list|(
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
parameter_list|)
block|{
name|struct
name|ntb_transport_qp
modifier|*
name|qp
decl_stmt|;
name|struct
name|_qpset
name|qp_bitmap_alloc
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|BIT_COPY
argument_list|(
name|QP_SETSIZE
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap
argument_list|,
operator|&
name|qp_bitmap_alloc
argument_list|)
expr_stmt|;
name|BIT_NAND
argument_list|(
name|QP_SETSIZE
argument_list|,
operator|&
name|qp_bitmap_alloc
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap_free
argument_list|)
expr_stmt|;
comment|/* Pass along the info to any clients */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|qp_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|test_bit
argument_list|(
name|i
argument_list|,
operator|&
name|qp_bitmap_alloc
argument_list|)
condition|)
block|{
name|qp
operator|=
operator|&
name|nt
operator|->
name|qp_vec
index|[
name|i
index|]
expr_stmt|;
name|ntb_qp_link_cleanup
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nt
operator|->
name|link_is_up
condition|)
name|callout_drain
argument_list|(
operator|&
name|nt
operator|->
name|link_work
argument_list|)
expr_stmt|;
comment|/* 	 * The scratchpad registers keep the values if the remote side 	 * goes down, blast them now to give them a sane value the next 	 * time they are accessed 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IF_NTB_MAX_SPAD
condition|;
name|i
operator|++
control|)
name|ntb_spad_write
argument_list|(
name|nt
operator|->
name|ntb
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_transport_link_cleanup_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|ntb_transport_link_cleanup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_qp_link_down
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|ntb_qp_link_cleanup
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_qp_link_down_reset
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|qp
operator|->
name|link_is_up
operator|=
name|false
expr_stmt|;
name|qp
operator|->
name|tx_index
operator|=
name|qp
operator|->
name|rx_index
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|tx_bytes
operator|=
name|qp
operator|->
name|rx_bytes
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|tx_pkts
operator|=
name|qp
operator|->
name|rx_pkts
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|rx_ring_empty
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|tx_ring_full
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|rx_err_no_buf
operator|=
name|qp
operator|->
name|tx_err_no_buf
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|rx_err_oflow
operator|=
name|qp
operator|->
name|rx_err_ver
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_qp_link_cleanup
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|ntb_transport_ctx
modifier|*
name|nt
init|=
name|qp
operator|->
name|transport
decl_stmt|;
name|callout_drain
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|)
expr_stmt|;
name|ntb_qp_link_down_reset
argument_list|(
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|event_handler
operator|!=
name|NULL
condition|)
name|qp
operator|->
name|event_handler
argument_list|(
name|qp
operator|->
name|cb_data
argument_list|,
name|NTB_LINK_DOWN
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|link_is_up
condition|)
name|callout_reset
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|,
name|NTB_LINK_DOWN_TIMEOUT
operator|*
name|hz
operator|/
literal|1000
argument_list|,
name|ntb_qp_link_work
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Link commanded down */
end_comment

begin_comment
comment|/**  * ntb_transport_link_down - Notify NTB transport to no longer enqueue data  * @qp: NTB transport layer queue to be disabled  *  * Notify NTB transport layer of client's desire to no longer receive data on  * transport queue specified.  It is the client's responsibility to ensure all  * entries on queue are purged or otherwise handled appropriately.  */
end_comment

begin_function
specifier|static
name|void
name|ntb_transport_link_down
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
return|return;
name|qp
operator|->
name|client_ready
operator|=
name|false
expr_stmt|;
name|ntb_spad_read
argument_list|(
name|qp
operator|->
name|ntb
argument_list|,
name|IF_NTB_QP_LINKS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|ntb_peer_spad_write
argument_list|(
name|qp
operator|->
name|ntb
argument_list|,
name|IF_NTB_QP_LINKS
argument_list|,
name|val
operator|&
operator|~
operator|(
literal|1
operator|<<
name|qp
operator|->
name|qp_num
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|link_is_up
condition|)
name|ntb_send_link_down
argument_list|(
name|qp
argument_list|)
expr_stmt|;
else|else
name|callout_drain
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_send_link_down
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|qp
operator|->
name|link_is_up
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTB_LINK_DOWN_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
name|ntb_list_rm
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
break|break;
name|pause
argument_list|(
literal|"NTB Wait for link down"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return;
name|entry
operator|->
name|cb_data
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|flags
operator|=
name|IF_NTB_LINK_DOWN_FLAG
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|qp
operator|->
name|transport
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ntb_process_tx
argument_list|(
name|qp
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"ntb: Failed to send link down\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|qp
operator|->
name|transport
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
name|ntb_qp_link_down_reset
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* List Management */
end_comment

begin_function
specifier|static
name|void
name|ntb_list_add
parameter_list|(
name|struct
name|mtx
modifier|*
name|lock
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|ntb_queue_list
modifier|*
name|list
parameter_list|)
block|{
name|mtx_lock_spin
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|list
argument_list|,
name|entry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ntb_queue_entry
modifier|*
name|ntb_list_rm
parameter_list|(
name|struct
name|mtx
modifier|*
name|lock
parameter_list|,
name|struct
name|ntb_queue_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|mtx_lock_spin
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|entry
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|entry
operator|=
name|STAILQ_FIRST
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
name|list
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|out
label|:
name|mtx_unlock_spin
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ntb_queue_entry
modifier|*
name|ntb_list_mv
parameter_list|(
name|struct
name|mtx
modifier|*
name|lock
parameter_list|,
name|struct
name|ntb_queue_list
modifier|*
name|from
parameter_list|,
name|struct
name|ntb_queue_list
modifier|*
name|to
parameter_list|)
block|{
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|mtx_lock_spin
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
name|from
argument_list|)
condition|)
block|{
name|entry
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|entry
operator|=
name|STAILQ_FIRST
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
name|from
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|to
argument_list|,
name|entry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|out
label|:
name|mtx_unlock_spin
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Helper functions */
end_comment

begin_comment
comment|/* TODO: This too should really be part of the kernel */
end_comment

begin_define
define|#
directive|define
name|EUI48_MULTICAST
value|1<< 0
end_define

begin_define
define|#
directive|define
name|EUI48_LOCALLY_ADMINISTERED
value|1<< 1
end_define

begin_function
specifier|static
name|void
name|create_random_local_eui48
parameter_list|(
name|u_char
modifier|*
name|eaddr
parameter_list|)
block|{
specifier|static
name|uint8_t
name|counter
init|=
literal|0
decl_stmt|;
name|uint32_t
name|seed
init|=
name|ticks
decl_stmt|;
name|eaddr
index|[
literal|0
index|]
operator|=
name|EUI48_LOCALLY_ADMINISTERED
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|eaddr
index|[
literal|1
index|]
argument_list|,
operator|&
name|seed
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|eaddr
index|[
literal|5
index|]
operator|=
name|counter
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ntb_transport_max_size - Query the max payload size of a qp  * @qp: NTB transport layer queue to be queried  *  * Query the maximum payload size permissible on the given qp  *  * RETURNS: the max payload size of a qp  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|ntb_transport_max_size
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|qp
operator|->
name|tx_max_frame
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

