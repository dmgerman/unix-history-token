begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 2013 Intel Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|"../ntb_hw/ntb_hw.h"
end_include

begin_comment
comment|/*  * The Non-Transparent Bridge (NTB) is a device on some Intel processors that  * allows you to connect two systems using a PCI-e link.  *  * This module contains a protocol for sending and receiving messages, and  * exposes that protocol through a simulated ethernet device called ntb.  *  * NOTE: Much of the code in this module is shared with Linux. Any patches may  * be picked up and redistributed in Linux with a dual GPL/BSD license.  */
end_comment

begin_comment
comment|/* TODO: These functions should really be part of the kernel */
end_comment

begin_define
define|#
directive|define
name|test_bit
parameter_list|(
name|pos
parameter_list|,
name|bitmap_addr
parameter_list|)
value|(*(bitmap_addr)& 1UL<< (pos))
end_define

begin_define
define|#
directive|define
name|set_bit
parameter_list|(
name|pos
parameter_list|,
name|bitmap_addr
parameter_list|)
value|*(bitmap_addr) |= 1UL<< (pos)
end_define

begin_define
define|#
directive|define
name|clear_bit
parameter_list|(
name|pos
parameter_list|,
name|bitmap_addr
parameter_list|)
value|*(bitmap_addr)&= ~(1UL<< (pos))
end_define

begin_define
define|#
directive|define
name|KTR_NTB
value|KTR_SPARE3
end_define

begin_define
define|#
directive|define
name|NTB_TRANSPORT_VERSION
value|3
end_define

begin_define
define|#
directive|define
name|NTB_RX_MAX_PKTS
value|64
end_define

begin_define
define|#
directive|define
name|NTB_RXQ_SIZE
value|300
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|transport_mtu
init|=
literal|0x4000
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is an oversimplification to work around Xeon Errata.  The second client  * may be usable for unidirectional traffic.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|max_num_clients
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|STAILQ_HEAD
argument_list|(
name|ntb_queue_list
argument_list|,
name|ntb_queue_entry
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|ntb_queue_entry
block|{
comment|/* ntb_queue list reference */
name|STAILQ_ENTRY
argument_list|(
argument|ntb_queue_entry
argument_list|)
name|entry
expr_stmt|;
comment|/* info on data to be transfered */
name|void
modifier|*
name|cb_data
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|uint64_t
name|len
decl_stmt|;
name|uint64_t
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_rx_info
block|{
name|unsigned
name|int
name|entry
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_transport_qp
block|{
name|struct
name|ntb_netdev
modifier|*
name|transport
decl_stmt|;
name|struct
name|ntb_softc
modifier|*
name|ntb
decl_stmt|;
name|void
modifier|*
name|cb_data
decl_stmt|;
name|bool
name|client_ready
decl_stmt|;
name|bool
name|qp_link
decl_stmt|;
name|uint8_t
name|qp_num
decl_stmt|;
comment|/* Only 64 QPs are allowed.  0-63 */
name|struct
name|ntb_rx_info
modifier|*
name|rx_info
decl_stmt|;
name|struct
name|ntb_rx_info
modifier|*
name|remote_rx_info
decl_stmt|;
name|void
function_decl|(
modifier|*
name|tx_handler
function_decl|)
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|qp_data
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
name|struct
name|ntb_queue_list
name|tx_free_q
decl_stmt|;
name|struct
name|mtx
name|ntb_tx_free_q_lock
decl_stmt|;
name|void
modifier|*
name|tx_mw
decl_stmt|;
name|uint64_t
name|tx_index
decl_stmt|;
name|uint64_t
name|tx_max_entry
decl_stmt|;
name|uint64_t
name|tx_max_frame
decl_stmt|;
name|void
function_decl|(
modifier|*
name|rx_handler
function_decl|)
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|qp_data
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
name|struct
name|ntb_queue_list
name|rx_pend_q
decl_stmt|;
name|struct
name|ntb_queue_list
name|rx_free_q
decl_stmt|;
name|struct
name|mtx
name|ntb_rx_pend_q_lock
decl_stmt|;
name|struct
name|mtx
name|ntb_rx_free_q_lock
decl_stmt|;
name|struct
name|task
name|rx_completion_task
decl_stmt|;
name|void
modifier|*
name|rx_buff
decl_stmt|;
name|uint64_t
name|rx_index
decl_stmt|;
name|uint64_t
name|rx_max_entry
decl_stmt|;
name|uint64_t
name|rx_max_frame
decl_stmt|;
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|status
parameter_list|)
function_decl|;
name|struct
name|callout
name|link_work
decl_stmt|;
name|struct
name|callout
name|queue_full
decl_stmt|;
name|struct
name|callout
name|rx_full
decl_stmt|;
name|uint64_t
name|last_rx_no_buf
decl_stmt|;
comment|/* Stats */
name|uint64_t
name|rx_bytes
decl_stmt|;
name|uint64_t
name|rx_pkts
decl_stmt|;
name|uint64_t
name|rx_ring_empty
decl_stmt|;
name|uint64_t
name|rx_err_no_buf
decl_stmt|;
name|uint64_t
name|rx_err_oflow
decl_stmt|;
name|uint64_t
name|rx_err_ver
decl_stmt|;
name|uint64_t
name|tx_bytes
decl_stmt|;
name|uint64_t
name|tx_pkts
decl_stmt|;
name|uint64_t
name|tx_ring_full
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_queue_handlers
block|{
name|void
function_decl|(
modifier|*
name|rx_handler
function_decl|)
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|qp_data
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|tx_handler
function_decl|)
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|qp_data
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|status
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_transport_mw
block|{
name|size_t
name|size
decl_stmt|;
name|void
modifier|*
name|virt_addr
decl_stmt|;
name|vm_paddr_t
name|dma_addr
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntb_netdev
block|{
name|struct
name|ntb_softc
modifier|*
name|ntb
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ntb_transport_mw
name|mw
index|[
name|NTB_NUM_MW
index|]
decl_stmt|;
name|struct
name|ntb_transport_qp
modifier|*
name|qps
decl_stmt|;
name|uint64_t
name|max_qps
decl_stmt|;
name|uint64_t
name|qp_bitmap
decl_stmt|;
name|bool
name|transport_link
decl_stmt|;
name|struct
name|callout
name|link_work
decl_stmt|;
name|struct
name|ntb_transport_qp
modifier|*
name|qp
decl_stmt|;
name|uint64_t
name|bufsize
decl_stmt|;
name|u_char
name|eaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|struct
name|mtx
name|tx_lock
decl_stmt|;
name|struct
name|mtx
name|rx_lock
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ntb_netdev
name|net_softc
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
block|{
name|IF_NTB_DESC_DONE_FLAG
init|=
literal|1
operator|<<
literal|0
block|,
name|IF_NTB_LINK_DOWN_FLAG
init|=
literal|1
operator|<<
literal|1
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|ntb_payload_header
block|{
name|uint64_t
name|ver
decl_stmt|;
name|uint64_t
name|len
decl_stmt|;
name|uint64_t
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
comment|/* 	 * The order of this enum is part of the if_ntb remote protocol.  Do 	 * not reorder without bumping protocol version (and it's probably best 	 * to keep the protocol in lock-step with the Linux NTB driver. 	 */
name|IF_NTB_VERSION
init|=
literal|0
block|,
name|IF_NTB_QP_LINKS
block|,
name|IF_NTB_NUM_QPS
block|,
name|IF_NTB_NUM_MWS
block|,
comment|/* 	 * N.B.: transport_link_work assumes MW1 enums = MW0 + 2. 	 */
name|IF_NTB_MW0_SZ_HIGH
block|,
name|IF_NTB_MW0_SZ_LOW
block|,
name|IF_NTB_MW1_SZ_HIGH
block|,
name|IF_NTB_MW1_SZ_LOW
block|,
name|IF_NTB_MAX_SPAD
block|, }
enum|;
end_enum

begin_define
define|#
directive|define
name|QP_TO_MW
parameter_list|(
name|qp
parameter_list|)
value|((qp) % NTB_NUM_MW)
end_define

begin_define
define|#
directive|define
name|NTB_QP_DEF_NUM_ENTRIES
value|100
end_define

begin_define
define|#
directive|define
name|NTB_LINK_DOWN_TIMEOUT
value|10
end_define

begin_function_decl
specifier|static
name|int
name|ntb_handle_module_events
parameter_list|(
name|struct
name|module
modifier|*
name|m
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_setup_interface
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_teardown_interface
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_net_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_net_tx_handler
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|qp_data
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_net_rx_handler
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|qp_data
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_net_event_handler
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_transport_init
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_free
parameter_list|(
name|void
modifier|*
name|transport
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_init_queue
parameter_list|(
name|struct
name|ntb_netdev
modifier|*
name|nt
parameter_list|,
name|unsigned
name|int
name|qp_num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_free_queue
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ntb_transport_qp
modifier|*
name|ntb_transport_create_queue
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|ntb_softc
modifier|*
name|pdev
parameter_list|,
specifier|const
name|struct
name|ntb_queue_handlers
modifier|*
name|handlers
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_link_up
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_transport_tx_enqueue
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_process_tx
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_tx_copy_task
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_qp_full
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_rxc_db
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|db_num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_rx_pendq_full
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_rx
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_process_rxc
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_rx_copy_task
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_rx_completion_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_event_callback
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|enum
name|ntb_hw_event
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_link_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntb_set_mw
parameter_list|(
name|struct
name|ntb_netdev
modifier|*
name|nt
parameter_list|,
name|int
name|num_mw
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_free_mw
parameter_list|(
name|struct
name|ntb_netdev
modifier|*
name|nt
parameter_list|,
name|int
name|num_mw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_setup_qp_mw
parameter_list|(
name|struct
name|ntb_netdev
modifier|*
name|nt
parameter_list|,
name|unsigned
name|int
name|qp_num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_qp_link_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_link_cleanup
parameter_list|(
name|struct
name|ntb_netdev
modifier|*
name|nt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_qp_link_down
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_qp_link_cleanup
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_transport_link_down
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_send_link_down
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntb_list_add
parameter_list|(
name|struct
name|mtx
modifier|*
name|lock
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|ntb_queue_list
modifier|*
name|list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ntb_queue_entry
modifier|*
name|ntb_list_rm
parameter_list|(
name|struct
name|mtx
modifier|*
name|lock
parameter_list|,
name|struct
name|ntb_queue_list
modifier|*
name|list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_random_local_eui48
parameter_list|(
name|u_char
modifier|*
name|eaddr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|ntb_transport_max_size
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NTB_IF
argument_list|,
literal|"if_ntb"
argument_list|,
literal|"ntb network driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Module setup and teardown */
end_comment

begin_function
specifier|static
name|int
name|ntb_handle_module_events
parameter_list|(
name|struct
name|module
modifier|*
name|m
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|err
operator|=
name|ntb_setup_interface
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|err
operator|=
name|ntb_teardown_interface
argument_list|()
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|if_ntb_mod
init|=
block|{
literal|"if_ntb"
block|,
name|ntb_handle_module_events
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|if_ntb
argument_list|,
name|if_ntb_mod
argument_list|,
name|SI_SUB_KLD
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|if_ntb
argument_list|,
name|ntb_hw
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|ntb_setup_interface
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ntb_queue_handlers
name|handlers
init|=
block|{
name|ntb_net_rx_handler
block|,
name|ntb_net_tx_handler
block|,
name|ntb_net_event_handler
block|}
decl_stmt|;
name|net_softc
operator|.
name|ntb
operator|=
name|devclass_get_softc
argument_list|(
name|devclass_find
argument_list|(
literal|"ntb_hw"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|net_softc
operator|.
name|ntb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ntb: Cannot find devclass\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ntb_transport_init
argument_list|(
name|net_softc
operator|.
name|ntb
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|net_softc
operator|.
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ntb: cannot allocate ifnet structure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|net_softc
operator|.
name|qp
operator|=
name|ntb_transport_create_queue
argument_list|(
name|ifp
argument_list|,
name|net_softc
operator|.
name|ntb
argument_list|,
operator|&
name|handlers
argument_list|)
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
literal|"ntb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ntb_net_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
operator|&
name|net_softc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ntb_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ntb_start
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|IFQ_MAXLEN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|create_random_local_eui48
argument_list|(
name|net_softc
operator|.
name|eaddr
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|net_softc
operator|.
name|eaddr
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_HWCSUM
operator||
name|IFCAP_JUMBO_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
name|ntb_transport_link_up
argument_list|(
name|net_softc
operator|.
name|qp
argument_list|)
expr_stmt|;
name|net_softc
operator|.
name|bufsize
operator|=
name|ntb_transport_max_size
argument_list|(
name|net_softc
operator|.
name|qp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_teardown_interface
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|net_softc
operator|.
name|qp
operator|!=
name|NULL
condition|)
name|ntb_transport_link_down
argument_list|(
name|net_softc
operator|.
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|net_softc
operator|.
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|ether_ifdetach
argument_list|(
name|net_softc
operator|.
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|net_softc
operator|.
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|net_softc
operator|.
name|qp
operator|!=
name|NULL
condition|)
block|{
name|ntb_transport_free_queue
argument_list|(
name|net_softc
operator|.
name|qp
argument_list|)
expr_stmt|;
name|ntb_transport_free
argument_list|(
operator|&
name|net_softc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Network device interface */
end_comment

begin_function
specifier|static
name|void
name|ntb_net_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_netdev
modifier|*
name|ntb_softc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ntb_softc
operator|->
name|ifp
decl_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ntb_netdev
modifier|*
name|nt
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
block|{
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ntb_transport_max_size
argument_list|(
name|nt
operator|->
name|qp
argument_list|)
operator|-
name|ETHER_HDR_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|struct
name|ntb_netdev
modifier|*
name|nt
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nt
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: ntb_start"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: start mbuf %p"
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ntb_transport_tx_enqueue
argument_list|(
name|nt
operator|->
name|qp
argument_list|,
name|m_head
argument_list|,
name|m_head
argument_list|,
name|m_length
argument_list|(
name|m_head
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: could not tx mbuf %p. Returning to snd q"
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|EAGAIN
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|nt
operator|->
name|qp
operator|->
name|queue_full
argument_list|,
name|hz
operator|/
literal|1000
argument_list|,
name|ntb_qp_full
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nt
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Network Device Callbacks */
end_comment

begin_function
specifier|static
name|void
name|ntb_net_tx_handler
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|qp_data
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|m_freem
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: tx_handler freeing mbuf %p"
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_net_rx_handler
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|qp_data
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|data
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|qp_data
decl_stmt|;
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: rx handler"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_net_event_handler
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|status
parameter_list|)
block|{  }
end_function

begin_comment
comment|/* Transport Init and teardown */
end_comment

begin_function
specifier|static
name|int
name|ntb_transport_init
parameter_list|(
name|struct
name|ntb_softc
modifier|*
name|ntb
parameter_list|)
block|{
name|struct
name|ntb_netdev
modifier|*
name|nt
init|=
operator|&
name|net_softc
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|nt
operator|->
name|max_qps
operator|=
name|max_num_clients
expr_stmt|;
name|ntb_register_transport
argument_list|(
name|ntb
argument_list|,
name|nt
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nt
operator|->
name|tx_lock
argument_list|,
literal|"ntb transport tx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nt
operator|->
name|rx_lock
argument_list|,
literal|"ntb transport rx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|nt
operator|->
name|qps
operator|=
name|malloc
argument_list|(
name|nt
operator|->
name|max_qps
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_transport_qp
argument_list|)
argument_list|,
name|M_NTB_IF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|nt
operator|->
name|qp_bitmap
operator|=
operator|(
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
name|nt
operator|->
name|max_qps
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|max_qps
condition|;
name|i
operator|++
control|)
name|ntb_transport_init_queue
argument_list|(
name|nt
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|nt
operator|->
name|link_work
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ntb_register_event_callback
argument_list|(
name|ntb
argument_list|,
name|ntb_transport_event_callback
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|ntb_query_link_status
argument_list|(
name|ntb
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|ntb_get_device
argument_list|(
name|ntb
argument_list|)
argument_list|,
literal|"link up\n"
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|nt
operator|->
name|link_work
argument_list|,
literal|0
argument_list|,
name|ntb_transport_link_work
argument_list|,
name|nt
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
name|free
argument_list|(
name|nt
operator|->
name|qps
argument_list|,
name|M_NTB_IF
argument_list|)
expr_stmt|;
name|ntb_unregister_transport
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_transport_free
parameter_list|(
name|void
modifier|*
name|transport
parameter_list|)
block|{
name|struct
name|ntb_netdev
modifier|*
name|nt
init|=
name|transport
decl_stmt|;
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|nt
operator|->
name|ntb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|nt
operator|->
name|transport_link
operator|=
name|NTB_LINK_DOWN
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|nt
operator|->
name|link_work
argument_list|)
expr_stmt|;
comment|/* verify that all the qps are freed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|max_qps
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|test_bit
argument_list|(
name|i
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap
argument_list|)
condition|)
name|ntb_transport_free_queue
argument_list|(
operator|&
name|nt
operator|->
name|qps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ntb_unregister_event_callback
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTB_NUM_MW
condition|;
name|i
operator|++
control|)
name|ntb_free_mw
argument_list|(
name|nt
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nt
operator|->
name|qps
argument_list|,
name|M_NTB_IF
argument_list|)
expr_stmt|;
name|ntb_unregister_transport
argument_list|(
name|ntb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_transport_init_queue
parameter_list|(
name|struct
name|ntb_netdev
modifier|*
name|nt
parameter_list|,
name|unsigned
name|int
name|qp_num
parameter_list|)
block|{
name|struct
name|ntb_transport_qp
modifier|*
name|qp
decl_stmt|;
name|unsigned
name|int
name|num_qps_mw
decl_stmt|,
name|tx_size
decl_stmt|;
name|uint8_t
name|mw_num
init|=
name|QP_TO_MW
argument_list|(
name|qp_num
argument_list|)
decl_stmt|;
name|qp
operator|=
operator|&
name|nt
operator|->
name|qps
index|[
name|qp_num
index|]
expr_stmt|;
name|qp
operator|->
name|qp_num
operator|=
name|qp_num
expr_stmt|;
name|qp
operator|->
name|transport
operator|=
name|nt
expr_stmt|;
name|qp
operator|->
name|ntb
operator|=
name|nt
operator|->
name|ntb
expr_stmt|;
name|qp
operator|->
name|qp_link
operator|=
name|NTB_LINK_DOWN
expr_stmt|;
name|qp
operator|->
name|client_ready
operator|=
name|NTB_LINK_DOWN
expr_stmt|;
name|qp
operator|->
name|event_handler
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|max_qps
operator|%
name|NTB_NUM_MW
operator|&&
name|mw_num
operator|<
name|nt
operator|->
name|max_qps
operator|%
name|NTB_NUM_MW
condition|)
name|num_qps_mw
operator|=
name|nt
operator|->
name|max_qps
operator|/
name|NTB_NUM_MW
operator|+
literal|1
expr_stmt|;
else|else
name|num_qps_mw
operator|=
name|nt
operator|->
name|max_qps
operator|/
name|NTB_NUM_MW
expr_stmt|;
name|tx_size
operator|=
operator|(
name|unsigned
name|int
operator|)
name|ntb_get_mw_size
argument_list|(
name|qp
operator|->
name|ntb
argument_list|,
name|mw_num
argument_list|)
operator|/
name|num_qps_mw
expr_stmt|;
name|qp
operator|->
name|rx_info
operator|=
operator|(
expr|struct
name|ntb_rx_info
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ntb_get_mw_vbase
argument_list|(
name|qp
operator|->
name|ntb
argument_list|,
name|mw_num
argument_list|)
operator|+
operator|(
name|qp_num
operator|/
name|NTB_NUM_MW
operator|*
name|tx_size
operator|)
operator|)
expr_stmt|;
name|tx_size
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_rx_info
argument_list|)
expr_stmt|;
name|qp
operator|->
name|tx_mw
operator|=
name|qp
operator|->
name|rx_info
operator|+
literal|1
expr_stmt|;
comment|/* Due to house-keeping, there must be at least 2 buffs */
name|qp
operator|->
name|tx_max_frame
operator|=
name|min
argument_list|(
name|transport_mtu
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
argument_list|,
name|tx_size
operator|/
literal|2
argument_list|)
expr_stmt|;
name|qp
operator|->
name|tx_max_entry
operator|=
name|tx_size
operator|/
name|qp
operator|->
name|tx_max_frame
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|qp
operator|->
name|queue_full
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|qp
operator|->
name|rx_full
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_pend_q_lock
argument_list|,
literal|"ntb rx pend q"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_free_q_lock
argument_list|,
literal|"ntb rx free q"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
literal|"ntb tx free q"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|qp
operator|->
name|rx_completion_task
argument_list|,
literal|0
argument_list|,
name|ntb_rx_completion_task
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|qp
operator|->
name|rx_pend_q
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|qp
operator|->
name|rx_free_q
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_transport_free_queue
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
return|return;
name|callout_drain
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|)
expr_stmt|;
name|ntb_unregister_db_callback
argument_list|(
name|qp
operator|->
name|ntb
argument_list|,
name|qp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|ntb_list_rm
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_free_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|rx_free_q
argument_list|)
operator|)
condition|)
name|free
argument_list|(
name|entry
argument_list|,
name|M_NTB_IF
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|ntb_list_rm
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_pend_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|rx_pend_q
argument_list|)
operator|)
condition|)
name|free
argument_list|(
name|entry
argument_list|,
name|M_NTB_IF
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|ntb_list_rm
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
operator|)
condition|)
name|free
argument_list|(
name|entry
argument_list|,
name|M_NTB_IF
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|qp
operator|->
name|qp_num
argument_list|,
operator|&
name|qp
operator|->
name|transport
operator|->
name|qp_bitmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ntb_transport_create_queue - Create a new NTB transport layer queue  * @rx_handler: receive callback function  * @tx_handler: transmit callback function  * @event_handler: event callback function  *  * Create a new NTB transport layer queue and provide the queue with a callback  * routine for both transmit and receive.  The receive callback routine will be  * used to pass up data when the transport has received it on the queue.   The  * transmit callback routine will be called when the transport has completed the  * transmission of the data on the queue and the data is ready to be freed.  *  * RETURNS: pointer to newly created ntb_queue, NULL on error.  */
end_comment

begin_function
specifier|static
name|struct
name|ntb_transport_qp
modifier|*
name|ntb_transport_create_queue
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|ntb_softc
modifier|*
name|pdev
parameter_list|,
specifier|const
name|struct
name|ntb_queue_handlers
modifier|*
name|handlers
parameter_list|)
block|{
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|ntb_transport_qp
modifier|*
name|qp
decl_stmt|;
name|struct
name|ntb_netdev
modifier|*
name|nt
decl_stmt|;
name|unsigned
name|int
name|free_queue
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|nt
operator|=
name|ntb_find_transport
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|free_queue
operator|=
name|ffs
argument_list|(
name|nt
operator|->
name|qp_bitmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_queue
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
comment|/* decrement free_queue to make it zero based */
name|free_queue
operator|--
expr_stmt|;
name|clear_bit
argument_list|(
name|free_queue
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap
argument_list|)
expr_stmt|;
name|qp
operator|=
operator|&
name|nt
operator|->
name|qps
index|[
name|free_queue
index|]
expr_stmt|;
name|qp
operator|->
name|cb_data
operator|=
name|data
expr_stmt|;
name|qp
operator|->
name|rx_handler
operator|=
name|handlers
operator|->
name|rx_handler
expr_stmt|;
name|qp
operator|->
name|tx_handler
operator|=
name|handlers
operator|->
name|tx_handler
expr_stmt|;
name|qp
operator|->
name|event_handler
operator|=
name|handlers
operator|->
name|event_handler
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTB_QP_DEF_NUM_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_queue_entry
argument_list|)
argument_list|,
name|M_NTB_IF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|entry
operator|->
name|cb_data
operator|=
name|nt
operator|->
name|ifp
expr_stmt|;
name|entry
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|len
operator|=
name|transport_mtu
expr_stmt|;
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_pend_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|rx_pend_q
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTB_QP_DEF_NUM_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_queue_entry
argument_list|)
argument_list|,
name|M_NTB_IF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|ntb_register_db_callback
argument_list|(
name|qp
operator|->
name|ntb
argument_list|,
name|free_queue
argument_list|,
name|qp
argument_list|,
name|ntb_transport_rxc_db
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|err1
goto|;
return|return
operator|(
name|qp
operator|)
return|;
name|err1
label|:
while|while
condition|(
operator|(
name|entry
operator|=
name|ntb_list_rm
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
operator|)
condition|)
name|free
argument_list|(
name|entry
argument_list|,
name|M_NTB_IF
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|ntb_list_rm
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_free_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|rx_free_q
argument_list|)
operator|)
condition|)
name|free
argument_list|(
name|entry
argument_list|,
name|M_NTB_IF
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|free_queue
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap
argument_list|)
expr_stmt|;
name|err
label|:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ntb_transport_link_up - Notify NTB transport of client readiness to use queue  * @qp: NTB transport layer queue to be enabled  *  * Notify NTB transport layer of client readiness to use queue  */
end_comment

begin_function
specifier|static
name|void
name|ntb_transport_link_up
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
return|return;
name|qp
operator|->
name|client_ready
operator|=
name|NTB_LINK_UP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|ntb_get_device
argument_list|(
name|qp
operator|->
name|ntb
argument_list|)
argument_list|,
literal|"qp client ready\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|transport
operator|->
name|transport_link
operator|==
name|NTB_LINK_UP
condition|)
name|callout_reset
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|,
literal|0
argument_list|,
name|ntb_qp_link_work
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Transport Tx */
end_comment

begin_comment
comment|/**  * ntb_transport_tx_enqueue - Enqueue a new NTB queue entry  * @qp: NTB transport layer queue the entry is to be enqueued on  * @cb: per buffer pointer for callback function to use  * @data: pointer to data buffer that will be sent  * @len: length of the data buffer  *  * Enqueue a new transmit buffer onto the transport queue from which a NTB  * payload will be transmitted.  This assumes that a lock is being held to  * serialize access to the qp.  *  * RETURNS: An appropriate ERRNO error value on error, or zero for success.  */
end_comment

begin_function
specifier|static
name|int
name|ntb_transport_tx_enqueue
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|qp
operator|==
name|NULL
operator|||
name|qp
operator|->
name|qp_link
operator|!=
name|NTB_LINK_UP
operator|||
name|len
operator|==
literal|0
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: link not up"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|entry
operator|=
name|ntb_list_rm
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: could not get entry from tx_free_q"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: got entry %p from tx_free_q"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|cb_data
operator|=
name|cb
expr_stmt|;
name|entry
operator|->
name|buf
operator|=
name|data
expr_stmt|;
name|entry
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|entry
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|ntb_process_tx
argument_list|(
name|qp
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: process_tx failed. Returning entry %p to tx_free_q"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_process_tx
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|)
block|{
name|void
modifier|*
name|offset
decl_stmt|;
name|offset
operator|=
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|tx_mw
operator|+
name|qp
operator|->
name|tx_max_frame
operator|*
name|qp
operator|->
name|tx_index
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: process_tx: tx_pkts=%u, tx_index=%u, remote entry=%u"
argument_list|,
name|qp
operator|->
name|tx_pkts
argument_list|,
name|qp
operator|->
name|tx_index
argument_list|,
name|qp
operator|->
name|remote_rx_info
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|tx_index
operator|==
name|qp
operator|->
name|remote_rx_info
operator|->
name|entry
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: ring full"
argument_list|)
expr_stmt|;
name|qp
operator|->
name|tx_ring_full
operator|++
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
if|if
condition|(
name|entry
operator|->
name|len
operator|>
name|qp
operator|->
name|tx_max_frame
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|tx_handler
operator|!=
name|NULL
condition|)
name|qp
operator|->
name|tx_handler
argument_list|(
name|qp
argument_list|,
name|qp
operator|->
name|cb_data
argument_list|,
name|entry
operator|->
name|buf
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: frame too big. returning entry %p to tx_free_q"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|CTR2
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: copying entry %p to offset %p"
argument_list|,
name|entry
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ntb_tx_copy_task
argument_list|(
name|qp
argument_list|,
name|entry
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|qp
operator|->
name|tx_index
operator|++
expr_stmt|;
name|qp
operator|->
name|tx_index
operator|%=
name|qp
operator|->
name|tx_max_entry
expr_stmt|;
name|qp
operator|->
name|tx_pkts
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_tx_copy_task
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|ntb_payload_header
modifier|*
name|hdr
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: copying %d bytes to offset %p"
argument_list|,
name|entry
operator|->
name|len
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|buf
operator|!=
name|NULL
condition|)
name|m_copydata
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|entry
operator|->
name|buf
argument_list|,
literal|0
argument_list|,
name|entry
operator|->
name|len
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|ntb_payload_header
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|offset
operator|+
name|qp
operator|->
name|tx_max_frame
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
operator|)
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|entry
operator|->
name|len
expr_stmt|;
comment|/* TODO: replace with bus_space_write */
name|hdr
operator|->
name|ver
operator|=
name|qp
operator|->
name|tx_pkts
expr_stmt|;
comment|/* TODO: replace with bus_space_write */
name|wmb
argument_list|()
expr_stmt|;
comment|/* TODO: replace with bus_space_write */
name|hdr
operator|->
name|flags
operator|=
name|entry
operator|->
name|flags
operator||
name|IF_NTB_DESC_DONE_FLAG
expr_stmt|;
name|ntb_ring_doorbell
argument_list|(
name|qp
operator|->
name|ntb
argument_list|,
name|qp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
comment|/*  	 * The entry length can only be zero if the packet is intended to be a 	 * "link down" or similar.  Since no payload is being sent in these 	 * cases, there is nothing to add to the completion queue. 	 */
if|if
condition|(
name|entry
operator|->
name|len
operator|>
literal|0
condition|)
block|{
name|qp
operator|->
name|tx_bytes
operator|+=
name|entry
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|tx_handler
condition|)
name|qp
operator|->
name|tx_handler
argument_list|(
name|qp
argument_list|,
name|qp
operator|->
name|cb_data
argument_list|,
name|entry
operator|->
name|cb_data
argument_list|,
name|entry
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
name|CTR2
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: entry %p sent. hdr->ver = %d, Returning to tx_free_q"
argument_list|,
name|entry
argument_list|,
name|hdr
operator|->
name|ver
argument_list|)
expr_stmt|;
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_qp_full
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"TX: qp_full callout"
argument_list|)
expr_stmt|;
name|ntb_start
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Transport Rx */
end_comment

begin_function
specifier|static
name|void
name|ntb_transport_rxc_db
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|db_num
parameter_list|)
block|{
name|struct
name|ntb_transport_qp
modifier|*
name|qp
init|=
name|data
decl_stmt|;
name|ntb_transport_rx
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_rx_pendq_full
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: ntb_rx_pendq_full callout"
argument_list|)
expr_stmt|;
name|ntb_transport_rx
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_transport_rx
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|uint64_t
name|i
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/*  	 * Limit the number of packets processed in a single interrupt to 	 * provide fairness to others 	 */
name|mtx_lock
argument_list|(
operator|&
name|qp
operator|->
name|transport
operator|->
name|rx_lock
argument_list|)
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: transport_rx"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp
operator|->
name|rx_max_entry
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|ntb_process_rxc
argument_list|(
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: process_rxc failed"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|qp
operator|->
name|transport
operator|->
name|rx_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_process_rxc
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|ntb_payload_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|void
modifier|*
name|offset
decl_stmt|;
name|offset
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|rx_buff
operator|+
name|qp
operator|->
name|rx_max_frame
operator|*
name|qp
operator|->
name|rx_index
operator|)
expr_stmt|;
name|hdr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|offset
operator|+
name|qp
operator|->
name|rx_max_frame
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
operator|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: process_rxc rx_index = %u"
argument_list|,
name|qp
operator|->
name|rx_index
argument_list|)
expr_stmt|;
name|entry
operator|=
name|ntb_list_rm
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_pend_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|rx_pend_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|qp
operator|->
name|rx_err_no_buf
operator|++
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: No entries in rx_pend_q"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|callout_stop
argument_list|(
operator|&
name|qp
operator|->
name|rx_full
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: rx entry %p from rx_pend_q"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|flags
operator|&
name|IF_NTB_DESC_DONE_FLAG
operator|)
operator|==
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: hdr not done. Returning entry %p to rx_pend_q"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_pend_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|rx_pend_q
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rx_ring_empty
operator|++
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
if|if
condition|(
name|hdr
operator|->
name|ver
operator|!=
operator|(
name|uint32_t
operator|)
name|qp
operator|->
name|rx_pkts
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: ver != rx_pkts (%x != %lx). "
literal|"Returning entry %p to rx_pend_q"
argument_list|,
name|hdr
operator|->
name|ver
argument_list|,
name|qp
operator|->
name|rx_pkts
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_pend_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|rx_pend_q
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rx_err_ver
operator|++
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|hdr
operator|->
name|flags
operator|&
name|IF_NTB_LINK_DOWN_FLAG
operator|)
operator|!=
literal|0
condition|)
block|{
name|ntb_qp_link_down
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: link down. adding entry %p back to rx_pend_q"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_pend_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|rx_pend_q
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hdr
operator|->
name|len
operator|<=
name|entry
operator|->
name|len
condition|)
block|{
name|entry
operator|->
name|len
operator|=
name|hdr
operator|->
name|len
expr_stmt|;
name|ntb_rx_copy_task
argument_list|(
name|qp
argument_list|,
name|entry
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: len too long. Returning entry %p to rx_pend_q"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_pend_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|rx_pend_q
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rx_err_oflow
operator|++
expr_stmt|;
block|}
name|qp
operator|->
name|rx_bytes
operator|+=
name|hdr
operator|->
name|len
expr_stmt|;
name|qp
operator|->
name|rx_pkts
operator|++
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: received %ld rx_pkts"
argument_list|,
name|qp
operator|->
name|rx_pkts
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* Ensure that the data is globally visible before clearing the flag */
name|wmb
argument_list|()
expr_stmt|;
name|hdr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* TODO: replace with bus_space_write */
name|qp
operator|->
name|rx_info
operator|->
name|entry
operator|=
name|qp
operator|->
name|rx_index
expr_stmt|;
name|qp
operator|->
name|rx_index
operator|++
expr_stmt|;
name|qp
operator|->
name|rx_index
operator|%=
name|qp
operator|->
name|rx_max_entry
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_rx_copy_task
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|entry
operator|->
name|cb_data
decl_stmt|;
name|unsigned
name|int
name|len
init|=
name|entry
operator|->
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: copying %d bytes from offset %p"
argument_list|,
name|len
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_devget
argument_list|(
name|offset
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
expr_stmt|;
name|entry
operator|->
name|buf
operator|=
operator|(
name|void
operator|*
operator|)
name|m
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: copied entry %p to mbuf %p. Adding entry to rx_free_q"
argument_list|,
name|entry
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_free_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|rx_free_q
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|qp
operator|->
name|rx_completion_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_rx_completion_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ntb_transport_qp
modifier|*
name|qp
init|=
name|arg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: rx_completion_task"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|ntb_list_rm
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_free_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|rx_free_q
argument_list|)
operator|)
condition|)
block|{
name|m
operator|=
name|entry
operator|->
name|buf
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: completing entry %p, mbuf %p"
argument_list|,
name|entry
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|rx_handler
operator|&&
name|qp
operator|->
name|client_ready
operator|==
name|NTB_LINK_UP
condition|)
name|qp
operator|->
name|rx_handler
argument_list|(
name|qp
argument_list|,
name|qp
operator|->
name|cb_data
argument_list|,
name|m
argument_list|,
name|entry
operator|->
name|len
argument_list|)
expr_stmt|;
name|entry
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|len
operator|=
name|qp
operator|->
name|transport
operator|->
name|bufsize
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: entry %p removed from rx_free_q "
literal|"and added to rx_pend_q"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|ntb_list_add
argument_list|(
operator|&
name|qp
operator|->
name|ntb_rx_pend_q_lock
argument_list|,
name|entry
argument_list|,
operator|&
name|qp
operator|->
name|rx_pend_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|rx_err_no_buf
operator|>
name|qp
operator|->
name|last_rx_no_buf
condition|)
block|{
name|qp
operator|->
name|last_rx_no_buf
operator|=
name|qp
operator|->
name|rx_err_no_buf
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_NTB
argument_list|,
literal|"RX: could spawn rx task"
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|qp
operator|->
name|rx_full
argument_list|,
name|hz
operator|/
literal|1000
argument_list|,
name|ntb_rx_pendq_full
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Link Event handler */
end_comment

begin_function
specifier|static
name|void
name|ntb_transport_event_callback
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|enum
name|ntb_hw_event
name|event
parameter_list|)
block|{
name|struct
name|ntb_netdev
modifier|*
name|nt
init|=
name|data
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|NTB_EVENT_HW_LINK_UP
case|:
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|ntb_get_device
argument_list|(
name|nt
operator|->
name|ntb
argument_list|)
argument_list|,
literal|"HW link up\n"
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|nt
operator|->
name|link_work
argument_list|,
literal|0
argument_list|,
name|ntb_transport_link_work
argument_list|,
name|nt
argument_list|)
expr_stmt|;
break|break;
case|case
name|NTB_EVENT_HW_LINK_DOWN
case|:
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|ntb_get_device
argument_list|(
name|nt
operator|->
name|ntb
argument_list|)
argument_list|,
literal|"HW link down\n"
argument_list|)
expr_stmt|;
name|ntb_transport_link_cleanup
argument_list|(
name|nt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"ntb: Unknown NTB event"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Link bring up */
end_comment

begin_function
specifier|static
name|void
name|ntb_transport_link_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_netdev
modifier|*
name|nt
init|=
name|arg
decl_stmt|;
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|nt
operator|->
name|ntb
decl_stmt|;
name|struct
name|ntb_transport_qp
modifier|*
name|qp
decl_stmt|;
name|uint64_t
name|val64
decl_stmt|;
name|uint32_t
name|val
decl_stmt|,
name|i
decl_stmt|,
name|num_mw
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|ntb_has_feature
argument_list|(
name|ntb
argument_list|,
name|NTB_REGS_THRU_MW
argument_list|)
condition|)
name|num_mw
operator|=
name|NTB_NUM_MW
operator|-
literal|1
expr_stmt|;
else|else
name|num_mw
operator|=
name|NTB_NUM_MW
expr_stmt|;
comment|/* send the local info, in the opposite order of the way we read it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_mw
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|ntb_write_remote_spad
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_MW0_SZ_HIGH
operator|+
operator|(
name|i
operator|*
literal|2
operator|)
argument_list|,
operator|(
name|uint64_t
operator|)
name|ntb_get_mw_size
argument_list|(
name|ntb
argument_list|,
name|i
argument_list|)
operator|>>
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|rc
operator|=
name|ntb_write_remote_spad
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_MW0_SZ_LOW
operator|+
operator|(
name|i
operator|*
literal|2
operator|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|ntb_get_mw_size
argument_list|(
name|ntb
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|rc
operator|=
name|ntb_write_remote_spad
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_NUM_MWS
argument_list|,
name|num_mw
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|rc
operator|=
name|ntb_write_remote_spad
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_NUM_QPS
argument_list|,
name|nt
operator|->
name|max_qps
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|rc
operator|=
name|ntb_write_remote_spad
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_VERSION
argument_list|,
name|NTB_TRANSPORT_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Query the remote side for its info */
name|rc
operator|=
name|ntb_read_local_spad
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_VERSION
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|val
operator|!=
name|NTB_TRANSPORT_VERSION
condition|)
goto|goto
name|out
goto|;
name|rc
operator|=
name|ntb_read_local_spad
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_NUM_QPS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|val
operator|!=
name|nt
operator|->
name|max_qps
condition|)
goto|goto
name|out
goto|;
name|rc
operator|=
name|ntb_read_local_spad
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_NUM_MWS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|val
operator|!=
name|num_mw
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_mw
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|ntb_read_local_spad
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_MW0_SZ_HIGH
operator|+
operator|(
name|i
operator|*
literal|2
operator|)
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|free_mws
goto|;
name|val64
operator|=
operator|(
name|uint64_t
operator|)
name|val
operator|<<
literal|32
expr_stmt|;
name|rc
operator|=
name|ntb_read_local_spad
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_MW0_SZ_LOW
operator|+
operator|(
name|i
operator|*
literal|2
operator|)
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|free_mws
goto|;
name|val64
operator||=
name|val
expr_stmt|;
name|rc
operator|=
name|ntb_set_mw
argument_list|(
name|nt
argument_list|,
name|i
argument_list|,
name|val64
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|free_mws
goto|;
block|}
name|nt
operator|->
name|transport_link
operator|=
name|NTB_LINK_UP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|ntb_get_device
argument_list|(
name|ntb
argument_list|)
argument_list|,
literal|"transport link up\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|max_qps
condition|;
name|i
operator|++
control|)
block|{
name|qp
operator|=
operator|&
name|nt
operator|->
name|qps
index|[
name|i
index|]
expr_stmt|;
name|ntb_transport_setup_qp_mw
argument_list|(
name|nt
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|client_ready
operator|==
name|NTB_LINK_UP
condition|)
name|callout_reset
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|,
literal|0
argument_list|,
name|ntb_qp_link_work
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
return|return;
name|free_mws
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTB_NUM_MW
condition|;
name|i
operator|++
control|)
name|ntb_free_mw
argument_list|(
name|nt
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ntb_query_link_status
argument_list|(
name|ntb
argument_list|)
condition|)
name|callout_reset
argument_list|(
operator|&
name|nt
operator|->
name|link_work
argument_list|,
name|NTB_LINK_DOWN_TIMEOUT
operator|*
name|hz
operator|/
literal|1000
argument_list|,
name|ntb_transport_link_work
argument_list|,
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntb_set_mw
parameter_list|(
name|struct
name|ntb_netdev
modifier|*
name|nt
parameter_list|,
name|int
name|num_mw
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|struct
name|ntb_transport_mw
modifier|*
name|mw
init|=
operator|&
name|nt
operator|->
name|mw
index|[
name|num_mw
index|]
decl_stmt|;
comment|/* No need to re-setup */
if|if
condition|(
name|mw
operator|->
name|size
operator|==
name|size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|mw
operator|->
name|size
operator|!=
literal|0
condition|)
name|ntb_free_mw
argument_list|(
name|nt
argument_list|,
name|num_mw
argument_list|)
expr_stmt|;
comment|/* Alloc memory for receiving data.  Must be 4k aligned */
name|mw
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|mw
operator|->
name|virt_addr
operator|=
name|contigmalloc
argument_list|(
name|mw
operator|->
name|size
argument_list|,
name|M_NTB_IF
argument_list|,
name|M_ZERO
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|mw
operator|->
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mw
operator|->
name|virt_addr
operator|==
name|NULL
condition|)
block|{
name|mw
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"ntb: Unable to allocate MW buffer of size %d\n"
argument_list|,
operator|(
name|int
operator|)
name|mw
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* TODO: replace with bus_space_* functions */
name|mw
operator|->
name|dma_addr
operator|=
name|vtophys
argument_list|(
name|mw
operator|->
name|virt_addr
argument_list|)
expr_stmt|;
comment|/* Notify HW the memory location of the receive buffer */
name|ntb_set_mw_addr
argument_list|(
name|nt
operator|->
name|ntb
argument_list|,
name|num_mw
argument_list|,
name|mw
operator|->
name|dma_addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_free_mw
parameter_list|(
name|struct
name|ntb_netdev
modifier|*
name|nt
parameter_list|,
name|int
name|num_mw
parameter_list|)
block|{
name|struct
name|ntb_transport_mw
modifier|*
name|mw
init|=
operator|&
name|nt
operator|->
name|mw
index|[
name|num_mw
index|]
decl_stmt|;
if|if
condition|(
name|mw
operator|->
name|virt_addr
operator|==
name|NULL
condition|)
return|return;
name|contigfree
argument_list|(
name|mw
operator|->
name|virt_addr
argument_list|,
name|mw
operator|->
name|size
argument_list|,
name|M_NTB_IF
argument_list|)
expr_stmt|;
name|mw
operator|->
name|virt_addr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_transport_setup_qp_mw
parameter_list|(
name|struct
name|ntb_netdev
modifier|*
name|nt
parameter_list|,
name|unsigned
name|int
name|qp_num
parameter_list|)
block|{
name|struct
name|ntb_transport_qp
modifier|*
name|qp
init|=
operator|&
name|nt
operator|->
name|qps
index|[
name|qp_num
index|]
decl_stmt|;
name|void
modifier|*
name|offset
decl_stmt|;
name|unsigned
name|int
name|rx_size
decl_stmt|,
name|num_qps_mw
decl_stmt|;
name|uint8_t
name|mw_num
init|=
name|QP_TO_MW
argument_list|(
name|qp_num
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nt
operator|->
name|max_qps
operator|%
name|NTB_NUM_MW
operator|&&
name|mw_num
operator|<
name|nt
operator|->
name|max_qps
operator|%
name|NTB_NUM_MW
condition|)
name|num_qps_mw
operator|=
name|nt
operator|->
name|max_qps
operator|/
name|NTB_NUM_MW
operator|+
literal|1
expr_stmt|;
else|else
name|num_qps_mw
operator|=
name|nt
operator|->
name|max_qps
operator|/
name|NTB_NUM_MW
expr_stmt|;
name|rx_size
operator|=
operator|(
name|unsigned
name|int
operator|)
name|nt
operator|->
name|mw
index|[
name|mw_num
index|]
operator|.
name|size
operator|/
name|num_qps_mw
expr_stmt|;
name|qp
operator|->
name|remote_rx_info
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|nt
operator|->
name|mw
index|[
name|mw_num
index|]
operator|.
name|virt_addr
operator|+
operator|(
name|qp_num
operator|/
name|NTB_NUM_MW
operator|*
name|rx_size
operator|)
operator|)
expr_stmt|;
name|rx_size
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_rx_info
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rx_buff
operator|=
name|qp
operator|->
name|remote_rx_info
operator|+
literal|1
expr_stmt|;
comment|/* Due to house-keeping, there must be at least 2 buffs */
name|qp
operator|->
name|rx_max_frame
operator|=
name|min
argument_list|(
name|transport_mtu
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
argument_list|,
name|rx_size
operator|/
literal|2
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rx_max_entry
operator|=
name|rx_size
operator|/
name|qp
operator|->
name|rx_max_frame
expr_stmt|;
name|qp
operator|->
name|rx_index
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|remote_rx_info
operator|->
name|entry
operator|=
name|qp
operator|->
name|rx_max_entry
operator|-
literal|1
expr_stmt|;
comment|/* setup the hdr offsets with 0's */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp
operator|->
name|rx_max_entry
condition|;
name|i
operator|++
control|)
block|{
name|offset
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|qp
operator|->
name|rx_buff
operator|+
name|qp
operator|->
name|rx_max_frame
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|qp
operator|->
name|rx_pkts
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|tx_pkts
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|tx_index
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_qp_link_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ntb_transport_qp
modifier|*
name|qp
init|=
name|arg
decl_stmt|;
name|struct
name|ntb_softc
modifier|*
name|ntb
init|=
name|qp
operator|->
name|ntb
decl_stmt|;
name|struct
name|ntb_netdev
modifier|*
name|nt
init|=
name|qp
operator|->
name|transport
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|val
decl_stmt|;
name|rc
operator|=
name|ntb_read_remote_spad
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_QP_LINKS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return;
name|rc
operator|=
name|ntb_write_remote_spad
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_QP_LINKS
argument_list|,
name|val
operator||
literal|1
operator|<<
name|qp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
comment|/* query remote spad for qp ready bits */
name|rc
operator|=
name|ntb_read_local_spad
argument_list|(
name|ntb
argument_list|,
name|IF_NTB_QP_LINKS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* See if the remote side is up */
if|if
condition|(
operator|(
literal|1
operator|<<
name|qp
operator|->
name|qp_num
operator|&
name|val
operator|)
operator|!=
literal|0
condition|)
block|{
name|qp
operator|->
name|qp_link
operator|=
name|NTB_LINK_UP
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|event_handler
operator|!=
name|NULL
condition|)
name|qp
operator|->
name|event_handler
argument_list|(
name|qp
operator|->
name|cb_data
argument_list|,
name|NTB_LINK_UP
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|ntb_get_device
argument_list|(
name|ntb
argument_list|)
argument_list|,
literal|"qp link up\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nt
operator|->
name|transport_link
operator|==
name|NTB_LINK_UP
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|,
name|NTB_LINK_DOWN_TIMEOUT
operator|*
name|hz
operator|/
literal|1000
argument_list|,
name|ntb_qp_link_work
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Link down event*/
end_comment

begin_function
specifier|static
name|void
name|ntb_transport_link_cleanup
parameter_list|(
name|struct
name|ntb_netdev
modifier|*
name|nt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nt
operator|->
name|transport_link
operator|==
name|NTB_LINK_DOWN
condition|)
name|callout_drain
argument_list|(
operator|&
name|nt
operator|->
name|link_work
argument_list|)
expr_stmt|;
else|else
name|nt
operator|->
name|transport_link
operator|=
name|NTB_LINK_DOWN
expr_stmt|;
comment|/* Pass along the info to any clients */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|max_qps
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|test_bit
argument_list|(
name|i
argument_list|,
operator|&
name|nt
operator|->
name|qp_bitmap
argument_list|)
condition|)
name|ntb_qp_link_down
argument_list|(
operator|&
name|nt
operator|->
name|qps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/*  	 * The scratchpad registers keep the values if the remote side 	 * goes down, blast them now to give them a sane value the next 	 * time they are accessed 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IF_NTB_MAX_SPAD
condition|;
name|i
operator|++
control|)
name|ntb_write_local_spad
argument_list|(
name|nt
operator|->
name|ntb
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_qp_link_down
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|ntb_qp_link_cleanup
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_qp_link_cleanup
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|ntb_netdev
modifier|*
name|nt
init|=
name|qp
operator|->
name|transport
decl_stmt|;
if|if
condition|(
name|qp
operator|->
name|qp_link
operator|==
name|NTB_LINK_DOWN
condition|)
block|{
name|callout_drain
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|qp
operator|->
name|event_handler
operator|!=
name|NULL
condition|)
name|qp
operator|->
name|event_handler
argument_list|(
name|qp
operator|->
name|cb_data
argument_list|,
name|NTB_LINK_DOWN
argument_list|)
expr_stmt|;
name|qp
operator|->
name|qp_link
operator|=
name|NTB_LINK_DOWN
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|transport_link
operator|==
name|NTB_LINK_UP
condition|)
name|callout_reset
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|,
name|NTB_LINK_DOWN_TIMEOUT
operator|*
name|hz
operator|/
literal|1000
argument_list|,
name|ntb_qp_link_work
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Link commanded down */
end_comment

begin_comment
comment|/**  * ntb_transport_link_down - Notify NTB transport to no longer enqueue data  * @qp: NTB transport layer queue to be disabled  *  * Notify NTB transport layer of client's desire to no longer receive data on  * transport queue specified.  It is the client's responsibility to ensure all  * entries on queue are purged or otherwise handled appropriately.  */
end_comment

begin_function
specifier|static
name|void
name|ntb_transport_link_down
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|val
decl_stmt|;
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
return|return;
name|qp
operator|->
name|client_ready
operator|=
name|NTB_LINK_DOWN
expr_stmt|;
name|rc
operator|=
name|ntb_read_remote_spad
argument_list|(
name|qp
operator|->
name|ntb
argument_list|,
name|IF_NTB_QP_LINKS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return;
name|rc
operator|=
name|ntb_write_remote_spad
argument_list|(
name|qp
operator|->
name|ntb
argument_list|,
name|IF_NTB_QP_LINKS
argument_list|,
name|val
operator|&
operator|~
operator|(
literal|1
operator|<<
name|qp
operator|->
name|qp_num
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|qp_link
operator|==
name|NTB_LINK_UP
condition|)
name|ntb_send_link_down
argument_list|(
name|qp
argument_list|)
expr_stmt|;
else|else
name|callout_drain
argument_list|(
operator|&
name|qp
operator|->
name|link_work
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntb_send_link_down
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
if|if
condition|(
name|qp
operator|->
name|qp_link
operator|==
name|NTB_LINK_DOWN
condition|)
return|return;
name|qp
operator|->
name|qp_link
operator|=
name|NTB_LINK_DOWN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTB_LINK_DOWN_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
name|ntb_list_rm
argument_list|(
operator|&
name|qp
operator|->
name|ntb_tx_free_q_lock
argument_list|,
operator|&
name|qp
operator|->
name|tx_free_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
break|break;
name|pause
argument_list|(
literal|"NTB Wait for link down"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return;
name|entry
operator|->
name|cb_data
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|flags
operator|=
name|IF_NTB_LINK_DOWN_FLAG
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|qp
operator|->
name|transport
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ntb_process_tx
argument_list|(
name|qp
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"ntb: Failed to send link down\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|qp
operator|->
name|transport
operator|->
name|tx_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* List Management */
end_comment

begin_function
specifier|static
name|void
name|ntb_list_add
parameter_list|(
name|struct
name|mtx
modifier|*
name|lock
parameter_list|,
name|struct
name|ntb_queue_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|ntb_queue_list
modifier|*
name|list
parameter_list|)
block|{
name|mtx_lock_spin
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|list
argument_list|,
name|entry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ntb_queue_entry
modifier|*
name|ntb_list_rm
parameter_list|(
name|struct
name|mtx
modifier|*
name|lock
parameter_list|,
name|struct
name|ntb_queue_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|ntb_queue_entry
modifier|*
name|entry
decl_stmt|;
name|mtx_lock_spin
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|entry
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|entry
operator|=
name|STAILQ_FIRST
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
name|list
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|out
label|:
name|mtx_unlock_spin
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Helper functions */
end_comment

begin_comment
comment|/* TODO: This too should really be part of the kernel */
end_comment

begin_define
define|#
directive|define
name|EUI48_MULTICAST
value|1<< 0
end_define

begin_define
define|#
directive|define
name|EUI48_LOCALLY_ADMINISTERED
value|1<< 1
end_define

begin_function
specifier|static
name|void
name|create_random_local_eui48
parameter_list|(
name|u_char
modifier|*
name|eaddr
parameter_list|)
block|{
specifier|static
name|uint8_t
name|counter
init|=
literal|0
decl_stmt|;
name|uint32_t
name|seed
init|=
name|ticks
decl_stmt|;
name|eaddr
index|[
literal|0
index|]
operator|=
name|EUI48_LOCALLY_ADMINISTERED
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|eaddr
index|[
literal|1
index|]
argument_list|,
operator|&
name|seed
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|eaddr
index|[
literal|5
index|]
operator|=
name|counter
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ntb_transport_max_size - Query the max payload size of a qp  * @qp: NTB transport layer queue to be queried  *  * Query the maximum payload size permissible on the given qp  *  * RETURNS: the max payload size of a qp  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|ntb_transport_max_size
parameter_list|(
name|struct
name|ntb_transport_qp
modifier|*
name|qp
parameter_list|)
block|{
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|qp
operator|->
name|tx_max_frame
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ntb_payload_header
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

