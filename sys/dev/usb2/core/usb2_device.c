begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2008 Hans Petter Selasky. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<dev/usb2/include/usb2_defs.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/include/usb2_mfunc.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/include/usb2_error.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/include/usb2_standard.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/include/usb2_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/include/usb2_devid.h>
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|usb2_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_transfer.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_parse.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_dynamic.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_hub.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_mbuf.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_dev.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_msctest.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/quirk/usb2_quirk.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/controller/usb2_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/controller/usb2_bus.h>
end_include

begin_comment
comment|/* function prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|usb2_fill_pipe_data
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|struct
name|usb2_endpoint_descriptor
modifier|*
name|edesc
parameter_list|,
name|struct
name|usb2_pipe
modifier|*
name|pipe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb2_free_pipe_data
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|uint8_t
name|iface_mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb2_free_iface_data
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb2_detach_device_sub
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|device_t
modifier|*
name|ppdev
parameter_list|,
name|uint8_t
name|free_subdev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|usb2_probe_and_attach_sub
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb2_attach_arg
modifier|*
name|uaa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb2_init_attach_arg
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb2_attach_arg
modifier|*
name|uaa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb2_suspend_resume_sub
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|uint8_t
name|do_suspend
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb2_clear_stall_proc
parameter_list|(
name|struct
name|usb2_proc_msg
modifier|*
name|_pm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb2_check_strings
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb2_error_t
name|usb2_fill_iface_data
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|uint8_t
name|alt_index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb2_notify_addq
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb2_fifo_free_wrap
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|uint8_t
name|free_all
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* static structures */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|usb2_hub_speed_combs
index|[
name|USB_SPEED_MAX
index|]
index|[
name|USB_SPEED_MAX
index|]
init|=
block|{
comment|/* HUB */
comment|/* subdevice */
index|[
name|USB_SPEED_HIGH
index|]
index|[
name|USB_SPEED_HIGH
index|]
operator|=
literal|1
block|,
index|[
name|USB_SPEED_HIGH
index|]
index|[
name|USB_SPEED_FULL
index|]
operator|=
literal|1
block|,
index|[
name|USB_SPEED_HIGH
index|]
index|[
name|USB_SPEED_LOW
index|]
operator|=
literal|1
block|,
index|[
name|USB_SPEED_FULL
index|]
index|[
name|USB_SPEED_FULL
index|]
operator|=
literal|1
block|,
index|[
name|USB_SPEED_FULL
index|]
index|[
name|USB_SPEED_LOW
index|]
operator|=
literal|1
block|,
index|[
name|USB_SPEED_LOW
index|]
index|[
name|USB_SPEED_LOW
index|]
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This variable is global to allow easy access to it: */
end_comment

begin_decl_stmt
name|int
name|usb2_template
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb2
argument_list|,
name|OID_AUTO
argument_list|,
name|template
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|usb2_template
argument_list|,
literal|0
argument_list|,
literal|"Selected USB device side template"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_get_pipe_by_addr  *  * This function searches for an USB pipe by endpoint address and  * direction.  *  * Returns:  * NULL: Failure  * Else: Success  *------------------------------------------------------------------------*/
end_comment

begin_function
name|struct
name|usb2_pipe
modifier|*
name|usb2_get_pipe_by_addr
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|ea_val
parameter_list|)
block|{
name|struct
name|usb2_pipe
modifier|*
name|pipe
init|=
name|udev
operator|->
name|pipes
decl_stmt|;
name|struct
name|usb2_pipe
modifier|*
name|pipe_end
init|=
name|udev
operator|->
name|pipes
operator|+
name|USB_EP_MAX
decl_stmt|;
enum|enum
block|{
name|EA_MASK
init|=
operator|(
name|UE_DIR_IN
operator||
name|UE_DIR_OUT
operator||
name|UE_ADDR
operator|)
block|, 	}
enum|;
comment|/* 	 * According to the USB specification not all bits are used 	 * for the endpoint address. Keep defined bits only: 	 */
name|ea_val
operator|&=
name|EA_MASK
expr_stmt|;
comment|/* 	 * Iterate accross all the USB pipes searching for a match 	 * based on the endpoint address: 	 */
for|for
control|(
init|;
name|pipe
operator|!=
name|pipe_end
condition|;
name|pipe
operator|++
control|)
block|{
if|if
condition|(
name|pipe
operator|->
name|edesc
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
comment|/* do the mask and check the value */
if|if
condition|(
operator|(
name|pipe
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|&
name|EA_MASK
operator|)
operator|==
name|ea_val
condition|)
block|{
goto|goto
name|found
goto|;
block|}
block|}
comment|/* 	 * The default pipe is always present and is checked separately: 	 */
if|if
condition|(
operator|(
name|udev
operator|->
name|default_pipe
operator|.
name|edesc
operator|)
operator|&&
operator|(
operator|(
name|udev
operator|->
name|default_pipe
operator|.
name|edesc
operator|->
name|bEndpointAddress
operator|&
name|EA_MASK
operator|)
operator|==
name|ea_val
operator|)
condition|)
block|{
name|pipe
operator|=
operator|&
name|udev
operator|->
name|default_pipe
expr_stmt|;
goto|goto
name|found
goto|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
name|found
label|:
return|return
operator|(
name|pipe
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_get_pipe  *  * This function searches for an USB pipe based on the information  * given by the passed "struct usb2_config" pointer.  *  * Return values:  * NULL: No match.  * Else: Pointer to "struct usb2_pipe".  *------------------------------------------------------------------------*/
end_comment

begin_function
name|struct
name|usb2_pipe
modifier|*
name|usb2_get_pipe
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
specifier|const
name|struct
name|usb2_config
modifier|*
name|setup
parameter_list|)
block|{
name|struct
name|usb2_pipe
modifier|*
name|pipe
init|=
name|udev
operator|->
name|pipes
decl_stmt|;
name|struct
name|usb2_pipe
modifier|*
name|pipe_end
init|=
name|udev
operator|->
name|pipes
operator|+
name|USB_EP_MAX
decl_stmt|;
name|uint8_t
name|index
init|=
name|setup
operator|->
name|ep_index
decl_stmt|;
name|uint8_t
name|ea_mask
decl_stmt|;
name|uint8_t
name|ea_val
decl_stmt|;
name|uint8_t
name|type_mask
decl_stmt|;
name|uint8_t
name|type_val
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
literal|"udev=%p iface_index=%d address=0x%x "
literal|"type=0x%x dir=0x%x index=%d\n"
argument_list|,
name|udev
argument_list|,
name|iface_index
argument_list|,
name|setup
operator|->
name|endpoint
argument_list|,
name|setup
operator|->
name|type
argument_list|,
name|setup
operator|->
name|direction
argument_list|,
name|setup
operator|->
name|ep_index
argument_list|)
expr_stmt|;
comment|/* setup expected endpoint direction mask and value */
if|if
condition|(
name|setup
operator|->
name|direction
operator|==
name|UE_DIR_ANY
condition|)
block|{
comment|/* match any endpoint direction */
name|ea_mask
operator|=
literal|0
expr_stmt|;
name|ea_val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* match the given endpoint direction */
name|ea_mask
operator|=
operator|(
name|UE_DIR_IN
operator||
name|UE_DIR_OUT
operator|)
expr_stmt|;
name|ea_val
operator|=
operator|(
name|setup
operator|->
name|direction
operator|&
operator|(
name|UE_DIR_IN
operator||
name|UE_DIR_OUT
operator|)
operator|)
expr_stmt|;
block|}
comment|/* setup expected endpoint address */
if|if
condition|(
name|setup
operator|->
name|endpoint
operator|==
name|UE_ADDR_ANY
condition|)
block|{
comment|/* match any endpoint address */
block|}
else|else
block|{
comment|/* match the given endpoint address */
name|ea_mask
operator||=
name|UE_ADDR
expr_stmt|;
name|ea_val
operator||=
operator|(
name|setup
operator|->
name|endpoint
operator|&
name|UE_ADDR
operator|)
expr_stmt|;
block|}
comment|/* setup expected endpoint type */
if|if
condition|(
name|setup
operator|->
name|type
operator|==
name|UE_BULK_INTR
condition|)
block|{
comment|/* this will match BULK and INTERRUPT endpoints */
name|type_mask
operator|=
literal|2
expr_stmt|;
name|type_val
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|setup
operator|->
name|type
operator|==
name|UE_TYPE_ANY
condition|)
block|{
comment|/* match any endpoint type */
name|type_mask
operator|=
literal|0
expr_stmt|;
name|type_val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* match the given endpoint type */
name|type_mask
operator|=
name|UE_XFERTYPE
expr_stmt|;
name|type_val
operator|=
operator|(
name|setup
operator|->
name|type
operator|&
name|UE_XFERTYPE
operator|)
expr_stmt|;
block|}
comment|/* 	 * Iterate accross all the USB pipes searching for a match 	 * based on the endpoint address. Note that we are searching 	 * the pipes from the beginning of the "udev->pipes" array. 	 */
for|for
control|(
init|;
name|pipe
operator|!=
name|pipe_end
condition|;
name|pipe
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pipe
operator|->
name|edesc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pipe
operator|->
name|iface_index
operator|!=
name|iface_index
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* do the masks and check the values */
if|if
condition|(
operator|(
operator|(
name|pipe
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|&
name|ea_mask
operator|)
operator|==
name|ea_val
operator|)
operator|&&
operator|(
operator|(
name|pipe
operator|->
name|edesc
operator|->
name|bmAttributes
operator|&
name|type_mask
operator|)
operator|==
name|type_val
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|index
operator|--
condition|)
block|{
goto|goto
name|found
goto|;
block|}
block|}
block|}
comment|/* 	 * Match against default pipe last, so that "any pipe", "any 	 * address" and "any direction" returns the first pipe of the 	 * interface. "iface_index" and "direction" is ignored: 	 */
if|if
condition|(
operator|(
name|udev
operator|->
name|default_pipe
operator|.
name|edesc
operator|)
operator|&&
operator|(
operator|(
name|udev
operator|->
name|default_pipe
operator|.
name|edesc
operator|->
name|bEndpointAddress
operator|&
name|ea_mask
operator|)
operator|==
name|ea_val
operator|)
operator|&&
operator|(
operator|(
name|udev
operator|->
name|default_pipe
operator|.
name|edesc
operator|->
name|bmAttributes
operator|&
name|type_mask
operator|)
operator|==
name|type_val
operator|)
operator|&&
operator|(
operator|!
name|index
operator|)
condition|)
block|{
name|pipe
operator|=
operator|&
name|udev
operator|->
name|default_pipe
expr_stmt|;
goto|goto
name|found
goto|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
name|found
label|:
return|return
operator|(
name|pipe
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_interface_count  *  * This function stores the number of USB interfaces excluding  * alternate settings, which the USB config descriptor reports into  * the unsigned 8-bit integer pointed to by "count".  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
name|usb2_error_t
name|usb2_interface_count
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
modifier|*
name|count
parameter_list|)
block|{
if|if
condition|(
name|udev
operator|->
name|cdesc
operator|==
name|NULL
condition|)
block|{
operator|*
name|count
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|USB_ERR_NOT_CONFIGURED
operator|)
return|;
block|}
operator|*
name|count
operator|=
name|udev
operator|->
name|cdesc
operator|->
name|bNumInterface
expr_stmt|;
return|return
operator|(
name|USB_ERR_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_fill_pipe_data  *  * This function will initialise the USB pipe structure pointed to by  * the "pipe" argument.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb2_fill_pipe_data
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|struct
name|usb2_endpoint_descriptor
modifier|*
name|edesc
parameter_list|,
name|struct
name|usb2_pipe
modifier|*
name|pipe
parameter_list|)
block|{
name|bzero
argument_list|(
name|pipe
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|->
name|pipe_init
call|)
argument_list|(
name|udev
argument_list|,
name|edesc
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
operator|->
name|methods
operator|==
name|NULL
condition|)
block|{
comment|/* the pipe is invalid: just return */
return|return;
block|}
comment|/* initialise USB pipe structure */
name|pipe
operator|->
name|edesc
operator|=
name|edesc
expr_stmt|;
name|pipe
operator|->
name|iface_index
operator|=
name|iface_index
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pipe
operator|->
name|pipe_q
operator|.
name|head
argument_list|)
expr_stmt|;
name|pipe
operator|->
name|pipe_q
operator|.
name|command
operator|=
operator|&
name|usb2_pipe_start
expr_stmt|;
comment|/* clear stall, if any */
if|if
condition|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|->
name|clear_stall
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|udev
operator|->
name|bus
operator|->
name|mtx
argument_list|)
expr_stmt|;
call|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|->
name|clear_stall
call|)
argument_list|(
name|udev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|udev
operator|->
name|bus
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_free_pipe_data  *  * This function will free USB pipe data for the given interface  * index. Hence we do not have any dynamic allocations we simply clear  * "pipe->edesc" to indicate that the USB pipe structure can be  * reused. The pipes belonging to the given interface should not be in  * use when this function is called and no check is performed to  * prevent this.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb2_free_pipe_data
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|uint8_t
name|iface_mask
parameter_list|)
block|{
name|struct
name|usb2_pipe
modifier|*
name|pipe
init|=
name|udev
operator|->
name|pipes
decl_stmt|;
name|struct
name|usb2_pipe
modifier|*
name|pipe_end
init|=
name|udev
operator|->
name|pipes
operator|+
name|USB_EP_MAX
decl_stmt|;
while|while
condition|(
name|pipe
operator|!=
name|pipe_end
condition|)
block|{
if|if
condition|(
operator|(
name|pipe
operator|->
name|iface_index
operator|&
name|iface_mask
operator|)
operator|==
name|iface_index
condition|)
block|{
comment|/* free pipe */
name|pipe
operator|->
name|edesc
operator|=
name|NULL
expr_stmt|;
block|}
name|pipe
operator|++
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_fill_iface_data  *  * This function will fill in interface data and allocate USB pipes  * for all the endpoints that belong to the given interface. This  * function is typically called when setting the configuration or when  * setting an alternate interface.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|usb2_error_t
name|usb2_fill_iface_data
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|uint8_t
name|alt_index
parameter_list|)
block|{
name|struct
name|usb2_interface
modifier|*
name|iface
init|=
name|usb2_get_iface
argument_list|(
name|udev
argument_list|,
name|iface_index
argument_list|)
decl_stmt|;
name|struct
name|usb2_pipe
modifier|*
name|pipe
decl_stmt|;
name|struct
name|usb2_pipe
modifier|*
name|pipe_end
decl_stmt|;
name|struct
name|usb2_interface_descriptor
modifier|*
name|id
decl_stmt|;
name|struct
name|usb2_endpoint_descriptor
modifier|*
name|ed
init|=
name|NULL
decl_stmt|;
name|struct
name|usb2_descriptor
modifier|*
name|desc
decl_stmt|;
name|uint8_t
name|nendpt
decl_stmt|;
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"iface_index=%d alt_index=%d\n"
argument_list|,
name|iface_index
argument_list|,
name|alt_index
argument_list|)
expr_stmt|;
name|sx_assert
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|,
name|SA_LOCKED
argument_list|)
expr_stmt|;
name|pipe
operator|=
name|udev
operator|->
name|pipes
expr_stmt|;
name|pipe_end
operator|=
name|udev
operator|->
name|pipes
operator|+
name|USB_EP_MAX
expr_stmt|;
comment|/* 	 * Check if any USB pipes on the given USB interface are in 	 * use: 	 */
while|while
condition|(
name|pipe
operator|!=
name|pipe_end
condition|)
block|{
if|if
condition|(
operator|(
name|pipe
operator|->
name|edesc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|pipe
operator|->
name|iface_index
operator|==
name|iface_index
operator|)
operator|&&
operator|(
name|pipe
operator|->
name|refcount
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|USB_ERR_IN_USE
operator|)
return|;
block|}
name|pipe
operator|++
expr_stmt|;
block|}
name|pipe
operator|=
operator|&
name|udev
operator|->
name|pipes
index|[
literal|0
index|]
expr_stmt|;
name|id
operator|=
name|usb2_find_idesc
argument_list|(
name|udev
operator|->
name|cdesc
argument_list|,
name|iface_index
argument_list|,
name|alt_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
comment|/* 	 * Free old pipes after we know that an interface descriptor exists, 	 * if any. 	 */
name|usb2_free_pipe_data
argument_list|(
name|udev
argument_list|,
name|iface_index
argument_list|,
literal|0
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Setup USB interface structure */
name|iface
operator|->
name|idesc
operator|=
name|id
expr_stmt|;
name|iface
operator|->
name|alt_index
operator|=
name|alt_index
expr_stmt|;
name|iface
operator|->
name|parent_iface_index
operator|=
name|USB_IFACE_INDEX_ANY
expr_stmt|;
name|nendpt
operator|=
name|id
operator|->
name|bNumEndpoints
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"found idesc nendpt=%d\n"
argument_list|,
name|nendpt
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|(
name|void
operator|*
operator|)
name|id
expr_stmt|;
while|while
condition|(
name|nendpt
operator|--
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"endpt=%d\n"
argument_list|,
name|nendpt
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|desc
operator|=
name|usb2_desc_foreach
argument_list|(
name|udev
operator|->
name|cdesc
argument_list|,
name|desc
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|desc
operator|->
name|bDescriptorType
operator|==
name|UDESC_ENDPOINT
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bLength
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|ed
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|found
goto|;
block|}
if|if
condition|(
name|desc
operator|->
name|bDescriptorType
operator|==
name|UDESC_INTERFACE
condition|)
block|{
break|break;
block|}
block|}
goto|goto
name|error
goto|;
name|found
label|:
name|ed
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
comment|/* find a free pipe */
while|while
condition|(
name|pipe
operator|!=
name|pipe_end
condition|)
block|{
if|if
condition|(
name|pipe
operator|->
name|edesc
operator|==
name|NULL
condition|)
block|{
comment|/* pipe is free */
name|usb2_fill_pipe_data
argument_list|(
name|udev
argument_list|,
name|iface_index
argument_list|,
name|ed
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
break|break;
block|}
name|pipe
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|USB_ERR_NORMAL_COMPLETION
operator|)
return|;
name|error
label|:
comment|/* passed end, or bad desc */
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"%s: bad descriptor(s), addr=%d!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|udev
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* free old pipes if any */
name|usb2_free_pipe_data
argument_list|(
name|udev
argument_list|,
name|iface_index
argument_list|,
literal|0
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_free_iface_data  *  * This function will free all USB interfaces and USB pipes belonging  * to an USB device.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb2_free_iface_data
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|usb2_interface
modifier|*
name|iface
init|=
name|udev
operator|->
name|ifaces
decl_stmt|;
name|struct
name|usb2_interface
modifier|*
name|iface_end
init|=
name|udev
operator|->
name|ifaces
operator|+
name|USB_IFACE_MAX
decl_stmt|;
comment|/* mtx_assert() */
comment|/* free Linux compat device, if any */
if|if
condition|(
name|udev
operator|->
name|linux_dev
condition|)
block|{
name|usb_linux_free_device
argument_list|(
name|udev
operator|->
name|linux_dev
argument_list|)
expr_stmt|;
name|udev
operator|->
name|linux_dev
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* free all pipes, if any */
name|usb2_free_pipe_data
argument_list|(
name|udev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* free all interfaces, if any */
while|while
condition|(
name|iface
operator|!=
name|iface_end
condition|)
block|{
name|iface
operator|->
name|idesc
operator|=
name|NULL
expr_stmt|;
name|iface
operator|->
name|alt_index
operator|=
literal|0
expr_stmt|;
name|iface
operator|->
name|parent_iface_index
operator|=
name|USB_IFACE_INDEX_ANY
expr_stmt|;
name|iface
operator|->
name|perm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
comment|/* disable permissions */
name|iface
operator|++
expr_stmt|;
block|}
comment|/* free "cdesc" after "ifaces", if any */
if|if
condition|(
name|udev
operator|->
name|cdesc
condition|)
block|{
name|free
argument_list|(
name|udev
operator|->
name|cdesc
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|udev
operator|->
name|cdesc
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* set unconfigured state */
name|udev
operator|->
name|curr_config_no
operator|=
name|USB_UNCONFIG_NO
expr_stmt|;
name|udev
operator|->
name|curr_config_index
operator|=
name|USB_UNCONFIG_INDEX
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_set_config_index  *  * This function selects configuration by index, independent of the  * actual configuration number. This function should not be used by  * USB drivers.  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
name|usb2_error_t
name|usb2_set_config_index
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|index
parameter_list|)
block|{
name|struct
name|usb2_status
name|ds
decl_stmt|;
name|struct
name|usb2_hub_descriptor
name|hd
decl_stmt|;
name|struct
name|usb2_config_descriptor
modifier|*
name|cdp
decl_stmt|;
name|uint16_t
name|power
decl_stmt|;
name|uint16_t
name|max_power
decl_stmt|;
name|uint8_t
name|nifc
decl_stmt|;
name|uint8_t
name|selfpowered
decl_stmt|;
name|uint8_t
name|do_unlock
decl_stmt|;
name|usb2_error_t
name|err
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"udev=%p index=%d\n"
argument_list|,
name|udev
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* automatic locking */
if|if
condition|(
name|sx_xlocked
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
condition|)
block|{
name|do_unlock
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|do_unlock
operator|=
literal|1
expr_stmt|;
name|sx_xlock
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* detach all interface drivers */
name|usb2_detach_device
argument_list|(
name|udev
argument_list|,
name|USB_IFACE_INDEX_ANY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* free all FIFOs except control endpoint FIFOs */
name|usb2_fifo_free_wrap
argument_list|(
name|udev
argument_list|,
name|USB_IFACE_INDEX_ANY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* free all configuration data structures */
name|usb2_free_iface_data
argument_list|(
name|udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|USB_UNCONFIG_INDEX
condition|)
block|{
comment|/* 		 * Leave unallocated when unconfiguring the 		 * device. "usb2_free_iface_data()" will also reset 		 * the current config number and index. 		 */
name|err
operator|=
name|usb2_req_set_config
argument_list|(
name|udev
argument_list|,
operator|&
name|Giant
argument_list|,
name|USB_UNCONFIG_NO
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* get the full config descriptor */
name|err
operator|=
name|usb2_req_get_config_desc_full
argument_list|(
name|udev
argument_list|,
operator|&
name|Giant
argument_list|,
operator|&
name|cdp
argument_list|,
name|M_USB
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/* set the new config descriptor */
name|udev
operator|->
name|cdesc
operator|=
name|cdp
expr_stmt|;
if|if
condition|(
name|cdp
operator|->
name|bNumInterface
operator|>
name|USB_IFACE_MAX
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"too many interfaces: %d\n"
argument_list|,
name|cdp
operator|->
name|bNumInterface
argument_list|)
expr_stmt|;
name|cdp
operator|->
name|bNumInterface
operator|=
name|USB_IFACE_MAX
expr_stmt|;
block|}
comment|/* Figure out if the device is self or bus powered. */
name|selfpowered
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|udev
operator|->
name|flags
operator|.
name|uq_bus_powered
operator|)
operator|&&
operator|(
name|cdp
operator|->
name|bmAttributes
operator|&
name|UC_SELF_POWERED
operator|)
operator|&&
operator|(
name|udev
operator|->
name|flags
operator|.
name|usb2_mode
operator|==
name|USB_MODE_HOST
operator|)
condition|)
block|{
comment|/* May be self powered. */
if|if
condition|(
name|cdp
operator|->
name|bmAttributes
operator|&
name|UC_BUS_POWERED
condition|)
block|{
comment|/* Must ask device. */
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|uq_power_claim
condition|)
block|{
comment|/* 				 * HUB claims to be self powered, but isn't. 				 * It seems that the power status can be 				 * determined by the HUB characteristics. 				 */
name|err
operator|=
name|usb2_req_get_hub_descriptor
argument_list|(
name|udev
argument_list|,
operator|&
name|Giant
argument_list|,
operator|&
name|hd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"could not read "
literal|"HUB descriptor: %s\n"
argument_list|,
name|usb2_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UGETW
argument_list|(
name|hd
operator|.
name|wHubCharacteristics
argument_list|)
operator|&
name|UHD_PWR_INDIVIDUAL
condition|)
block|{
name|selfpowered
operator|=
literal|1
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"characteristics=0x%04x\n"
argument_list|,
name|UGETW
argument_list|(
name|hd
operator|.
name|wHubCharacteristics
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|usb2_req_get_device_status
argument_list|(
name|udev
argument_list|,
operator|&
name|Giant
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"could not read "
literal|"device status: %s\n"
argument_list|,
name|usb2_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UGETW
argument_list|(
name|ds
operator|.
name|wStatus
argument_list|)
operator|&
name|UDS_SELF_POWERED
condition|)
block|{
name|selfpowered
operator|=
literal|1
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"status=0x%04x \n"
argument_list|,
name|UGETW
argument_list|(
name|ds
operator|.
name|wStatus
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|selfpowered
operator|=
literal|1
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"udev=%p cdesc=%p (addr %d) cno=%d attr=0x%02x, "
literal|"selfpowered=%d, power=%d\n"
argument_list|,
name|udev
argument_list|,
name|cdp
argument_list|,
name|cdp
operator|->
name|bConfigurationValue
argument_list|,
name|udev
operator|->
name|address
argument_list|,
name|cdp
operator|->
name|bmAttributes
argument_list|,
name|selfpowered
argument_list|,
name|cdp
operator|->
name|bMaxPower
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* Check if we have enough power. */
name|power
operator|=
name|cdp
operator|->
name|bMaxPower
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|parent_hub
condition|)
block|{
name|max_power
operator|=
name|udev
operator|->
name|parent_hub
operator|->
name|hub
operator|->
name|portpower
expr_stmt|;
block|}
else|else
block|{
name|max_power
operator|=
name|USB_MAX_POWER
expr_stmt|;
block|}
if|if
condition|(
name|power
operator|>
name|max_power
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"power exceeded %d> %d\n"
argument_list|,
name|power
argument_list|,
name|max_power
argument_list|)
expr_stmt|;
name|err
operator|=
name|USB_ERR_NO_POWER
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Only update "self_powered" in USB Host Mode */
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb2_mode
operator|==
name|USB_MODE_HOST
condition|)
block|{
name|udev
operator|->
name|flags
operator|.
name|self_powered
operator|=
name|selfpowered
expr_stmt|;
block|}
name|udev
operator|->
name|power
operator|=
name|power
expr_stmt|;
name|udev
operator|->
name|curr_config_no
operator|=
name|cdp
operator|->
name|bConfigurationValue
expr_stmt|;
name|udev
operator|->
name|curr_config_index
operator|=
name|index
expr_stmt|;
comment|/* Set the actual configuration value. */
name|err
operator|=
name|usb2_req_set_config
argument_list|(
name|udev
argument_list|,
operator|&
name|Giant
argument_list|,
name|cdp
operator|->
name|bConfigurationValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/* Allocate and fill interface data. */
name|nifc
operator|=
name|cdp
operator|->
name|bNumInterface
expr_stmt|;
while|while
condition|(
name|nifc
operator|--
condition|)
block|{
name|err
operator|=
name|usb2_fill_iface_data
argument_list|(
name|udev
argument_list|,
name|nifc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|DPRINTF
argument_list|(
literal|"error=%s\n"
argument_list|,
name|usb2_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|usb2_free_iface_data
argument_list|(
name|udev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_unlock
condition|)
block|{
name|sx_unlock
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_set_alt_interface_index  *  * This function will select an alternate interface index for the  * given interface index. The interface should not be in use when this  * function is called. That means there should be no open USB  * transfers. Else an error is returned.  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
name|usb2_error_t
name|usb2_set_alt_interface_index
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|uint8_t
name|alt_index
parameter_list|)
block|{
name|struct
name|usb2_interface
modifier|*
name|iface
init|=
name|usb2_get_iface
argument_list|(
name|udev
argument_list|,
name|iface_index
argument_list|)
decl_stmt|;
name|usb2_error_t
name|err
decl_stmt|;
name|uint8_t
name|do_unlock
decl_stmt|;
comment|/* automatic locking */
if|if
condition|(
name|sx_xlocked
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
condition|)
block|{
name|do_unlock
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|do_unlock
operator|=
literal|1
expr_stmt|;
name|sx_xlock
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb2_mode
operator|==
name|USB_MODE_DEVICE
condition|)
block|{
name|usb2_detach_device
argument_list|(
name|udev
argument_list|,
name|iface_index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* free all FIFOs for this interface */
name|usb2_fifo_free_wrap
argument_list|(
name|udev
argument_list|,
name|iface_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb2_fill_iface_data
argument_list|(
name|udev
argument_list|,
name|iface_index
argument_list|,
name|alt_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|err
operator|=
name|usb2_req_set_alt_interface_no
argument_list|(
name|udev
argument_list|,
operator|&
name|Giant
argument_list|,
name|iface_index
argument_list|,
name|iface
operator|->
name|idesc
operator|->
name|bAlternateSetting
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|do_unlock
condition|)
block|{
name|sx_unlock
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_set_endpoint_stall  *  * This function is used to make a BULK or INTERRUPT endpoint  * send STALL tokens.  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
name|usb2_error_t
name|usb2_set_endpoint_stall
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb2_pipe
modifier|*
name|pipe
parameter_list|,
name|uint8_t
name|do_stall
parameter_list|)
block|{
name|struct
name|usb2_xfer
modifier|*
name|xfer
decl_stmt|;
name|uint8_t
name|et
decl_stmt|;
name|uint8_t
name|was_stalled
decl_stmt|;
if|if
condition|(
name|pipe
operator|==
name|NULL
condition|)
block|{
comment|/* nothing to do */
name|DPRINTF
argument_list|(
literal|"Cannot find endpoint\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Pretend that the clear or set stall request is 		 * successful else some USB host stacks can do 		 * strange things, especially when a control endpoint 		 * stalls. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|et
operator|=
operator|(
name|pipe
operator|->
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|et
operator|!=
name|UE_BULK
operator|)
operator|&&
operator|(
name|et
operator|!=
name|UE_INTERRUPT
operator|)
condition|)
block|{
comment|/* 	         * Should not stall control 	         * nor isochronous endpoints. 	         */
name|DPRINTF
argument_list|(
literal|"Invalid endpoint\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|udev
operator|->
name|bus
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* store current stall state */
name|was_stalled
operator|=
name|pipe
operator|->
name|is_stalled
expr_stmt|;
comment|/* check for no change */
if|if
condition|(
name|was_stalled
operator|&&
name|do_stall
condition|)
block|{
comment|/* if the pipe is already stalled do nothing */
name|mtx_unlock
argument_list|(
operator|&
name|udev
operator|->
name|bus
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"No change\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* set stalled state */
name|pipe
operator|->
name|is_stalled
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|do_stall
operator|||
operator|(
operator|!
name|was_stalled
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|was_stalled
condition|)
block|{
comment|/* lookup the current USB transfer, if any */
name|xfer
operator|=
name|pipe
operator|->
name|pipe_q
operator|.
name|curr
expr_stmt|;
block|}
else|else
block|{
name|xfer
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * If "xfer" is non-NULL the "set_stall" method will 		 * complete the USB transfer like in case of a timeout 		 * setting the error code "USB_ERR_STALLED". 		 */
call|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|->
name|set_stall
call|)
argument_list|(
name|udev
argument_list|,
name|xfer
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|do_stall
condition|)
block|{
name|pipe
operator|->
name|toggle_next
operator|=
literal|0
expr_stmt|;
comment|/* reset data toggle */
name|pipe
operator|->
name|is_stalled
operator|=
literal|0
expr_stmt|;
comment|/* clear stalled state */
call|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|->
name|clear_stall
call|)
argument_list|(
name|udev
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
comment|/* start up the current or next transfer, if any */
name|usb2_command_wrapper
argument_list|(
operator|&
name|pipe
operator|->
name|pipe_q
argument_list|,
name|pipe
operator|->
name|pipe_q
operator|.
name|curr
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|udev
operator|->
name|bus
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_reset_iface_endpoints - used in USB device side mode  *------------------------------------------------------------------------*/
end_comment

begin_function
name|usb2_error_t
name|usb2_reset_iface_endpoints
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|)
block|{
name|struct
name|usb2_pipe
modifier|*
name|pipe
decl_stmt|;
name|struct
name|usb2_pipe
modifier|*
name|pipe_end
decl_stmt|;
name|usb2_error_t
name|err
decl_stmt|;
name|pipe
operator|=
name|udev
operator|->
name|pipes
expr_stmt|;
name|pipe_end
operator|=
name|udev
operator|->
name|pipes
operator|+
name|USB_EP_MAX
expr_stmt|;
for|for
control|(
init|;
name|pipe
operator|!=
name|pipe_end
condition|;
name|pipe
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pipe
operator|->
name|edesc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pipe
operator|->
name|iface_index
operator|!=
name|iface_index
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* simulate a clear stall from the peer */
name|err
operator|=
name|usb2_set_endpoint_stall
argument_list|(
name|udev
argument_list|,
name|pipe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* just ignore */
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_detach_device_sub  *  * This function will try to detach an USB device. If it fails a panic  * will result.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb2_detach_device_sub
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|device_t
modifier|*
name|ppdev
parameter_list|,
name|uint8_t
name|free_subdev
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|free_subdev
condition|)
block|{
operator|*
name|ppdev
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ppdev
condition|)
block|{
comment|/* 		 * NOTE: It is important to clear "*ppdev" before deleting 		 * the child due to some device methods being called late 		 * during the delete process ! 		 */
name|dev
operator|=
operator|*
name|ppdev
expr_stmt|;
operator|*
name|ppdev
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"at %s, port %d, addr %d "
literal|"(disconnected)\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|udev
operator|->
name|parent_dev
argument_list|)
argument_list|,
name|udev
operator|->
name|port_no
argument_list|,
name|udev
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|suspended
condition|)
block|{
name|err
operator|=
name|DEVICE_RESUME
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Resume failed!\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|device_detach
argument_list|(
name|dev
argument_list|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
block|}
if|if
condition|(
name|device_delete_child
argument_list|(
name|udev
operator|->
name|parent_dev
argument_list|,
name|dev
argument_list|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
block|}
return|return;
name|error
label|:
comment|/* Detach is not allowed to fail in the USB world */
name|panic
argument_list|(
literal|"An USB driver would not detach!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_detach_device  *  * The following function will detach the matching interfaces.  * This function is NULL safe.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb2_detach_device
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|uint8_t
name|free_subdev
parameter_list|)
block|{
name|struct
name|usb2_interface
modifier|*
name|iface
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|uint8_t
name|do_unlock
decl_stmt|;
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
block|{
comment|/* nothing to do */
return|return;
block|}
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"udev=%p\n"
argument_list|,
name|udev
argument_list|)
expr_stmt|;
comment|/* automatic locking */
if|if
condition|(
name|sx_xlocked
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
condition|)
block|{
name|do_unlock
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|do_unlock
operator|=
literal|1
expr_stmt|;
name|sx_xlock
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * First detach the child to give the child's detach routine a 	 * chance to detach the sub-devices in the correct order. 	 * Then delete the child using "device_delete_child()" which 	 * will detach all sub-devices from the bottom and upwards! 	 */
if|if
condition|(
name|iface_index
operator|!=
name|USB_IFACE_INDEX_ANY
condition|)
block|{
name|i
operator|=
name|iface_index
expr_stmt|;
name|iface_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|iface_index
operator|=
name|USB_IFACE_MAX
expr_stmt|;
block|}
comment|/* do the detach */
for|for
control|(
init|;
name|i
operator|!=
name|iface_index
condition|;
name|i
operator|++
control|)
block|{
name|iface
operator|=
name|usb2_get_iface
argument_list|(
name|udev
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
block|{
comment|/* looks like the end of the USB interfaces */
break|break;
block|}
name|usb2_detach_device_sub
argument_list|(
name|udev
argument_list|,
operator|&
name|iface
operator|->
name|subdev
argument_list|,
name|free_subdev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_unlock
condition|)
block|{
name|sx_unlock
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_probe_and_attach_sub  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|usb2_probe_and_attach_sub
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb2_attach_arg
modifier|*
name|uaa
parameter_list|)
block|{
name|struct
name|usb2_interface
modifier|*
name|iface
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|int
name|err
decl_stmt|;
name|iface
operator|=
name|uaa
operator|->
name|iface
expr_stmt|;
if|if
condition|(
name|iface
operator|->
name|parent_iface_index
operator|!=
name|USB_IFACE_INDEX_ANY
condition|)
block|{
comment|/* leave interface alone */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dev
operator|=
name|iface
operator|->
name|subdev
expr_stmt|;
if|if
condition|(
name|dev
condition|)
block|{
comment|/* clean up after module unload */
if|if
condition|(
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* already a device there */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* clear "iface->subdev" as early as possible */
name|iface
operator|->
name|subdev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|device_delete_child
argument_list|(
name|udev
operator|->
name|parent_dev
argument_list|,
name|dev
argument_list|)
condition|)
block|{
comment|/* 			 * Panic here, else one can get a double call 			 * to device_detach().  USB devices should 			 * never fail on detach! 			 */
name|panic
argument_list|(
literal|"device_delete_child() failed!\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|uaa
operator|->
name|temp_dev
operator|==
name|NULL
condition|)
block|{
comment|/* create a new child */
name|uaa
operator|->
name|temp_dev
operator|=
name|device_add_child
argument_list|(
name|udev
operator|->
name|parent_dev
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|uaa
operator|->
name|temp_dev
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|udev
operator|->
name|parent_dev
argument_list|,
literal|"Device creation failed!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* failure */
block|}
name|device_set_ivars
argument_list|(
name|uaa
operator|->
name|temp_dev
argument_list|,
name|uaa
argument_list|)
expr_stmt|;
name|device_quiet
argument_list|(
name|uaa
operator|->
name|temp_dev
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set "subdev" before probe and attach so that "devd" gets 	 * the information it needs. 	 */
name|iface
operator|->
name|subdev
operator|=
name|uaa
operator|->
name|temp_dev
expr_stmt|;
if|if
condition|(
name|device_probe_and_attach
argument_list|(
name|iface
operator|->
name|subdev
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * The USB attach arguments are only available during probe 		 * and attach ! 		 */
name|uaa
operator|->
name|temp_dev
operator|=
name|NULL
expr_stmt|;
name|device_set_ivars
argument_list|(
name|iface
operator|->
name|subdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|suspended
condition|)
block|{
name|err
operator|=
name|DEVICE_SUSPEND
argument_list|(
name|iface
operator|->
name|subdev
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|iface
operator|->
name|subdev
argument_list|,
literal|"Suspend failed\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
else|else
block|{
comment|/* No USB driver found */
name|iface
operator|->
name|subdev
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* failure */
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_set_parent_iface  *  * Using this function will lock the alternate interface setting on an  * interface. It is typically used for multi interface drivers. In USB  * device side mode it is assumed that the alternate interfaces all  * have the same endpoint descriptors. The default parent index value  * is "USB_IFACE_INDEX_ANY". Then the alternate setting value is not  * locked.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb2_set_parent_iface
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|uint8_t
name|parent_index
parameter_list|)
block|{
name|struct
name|usb2_interface
modifier|*
name|iface
decl_stmt|;
name|iface
operator|=
name|usb2_get_iface
argument_list|(
name|udev
argument_list|,
name|iface_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
condition|)
block|{
name|iface
operator|->
name|parent_iface_index
operator|=
name|parent_index
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|usb2_init_attach_arg
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb2_attach_arg
modifier|*
name|uaa
parameter_list|)
block|{
name|bzero
argument_list|(
name|uaa
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|uaa
argument_list|)
argument_list|)
expr_stmt|;
name|uaa
operator|->
name|device
operator|=
name|udev
expr_stmt|;
name|uaa
operator|->
name|usb2_mode
operator|=
name|udev
operator|->
name|flags
operator|.
name|usb2_mode
expr_stmt|;
name|uaa
operator|->
name|port
operator|=
name|udev
operator|->
name|port_no
expr_stmt|;
name|uaa
operator|->
name|info
operator|.
name|idVendor
operator|=
name|UGETW
argument_list|(
name|udev
operator|->
name|ddesc
operator|.
name|idVendor
argument_list|)
expr_stmt|;
name|uaa
operator|->
name|info
operator|.
name|idProduct
operator|=
name|UGETW
argument_list|(
name|udev
operator|->
name|ddesc
operator|.
name|idProduct
argument_list|)
expr_stmt|;
name|uaa
operator|->
name|info
operator|.
name|bcdDevice
operator|=
name|UGETW
argument_list|(
name|udev
operator|->
name|ddesc
operator|.
name|bcdDevice
argument_list|)
expr_stmt|;
name|uaa
operator|->
name|info
operator|.
name|bDeviceClass
operator|=
name|udev
operator|->
name|ddesc
operator|.
name|bDeviceClass
expr_stmt|;
name|uaa
operator|->
name|info
operator|.
name|bDeviceSubClass
operator|=
name|udev
operator|->
name|ddesc
operator|.
name|bDeviceSubClass
expr_stmt|;
name|uaa
operator|->
name|info
operator|.
name|bDeviceProtocol
operator|=
name|udev
operator|->
name|ddesc
operator|.
name|bDeviceProtocol
expr_stmt|;
name|uaa
operator|->
name|info
operator|.
name|bConfigIndex
operator|=
name|udev
operator|->
name|curr_config_index
expr_stmt|;
name|uaa
operator|->
name|info
operator|.
name|bConfigNum
operator|=
name|udev
operator|->
name|curr_config_no
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_probe_and_attach  *  * This function is called from "uhub_explore_sub()",  * "usb2_handle_set_config()" and "usb2_handle_request()".  *  * Returns:  *    0: Success  * Else: A control transfer failed  *------------------------------------------------------------------------*/
end_comment

begin_function
name|usb2_error_t
name|usb2_probe_and_attach
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|)
block|{
name|struct
name|usb2_attach_arg
name|uaa
decl_stmt|;
name|struct
name|usb2_interface
modifier|*
name|iface
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|uint8_t
name|j
decl_stmt|;
name|uint8_t
name|do_unlock
decl_stmt|;
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"udev == NULL\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
comment|/* automatic locking */
if|if
condition|(
name|sx_xlocked
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
condition|)
block|{
name|do_unlock
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|do_unlock
operator|=
literal|1
expr_stmt|;
name|sx_xlock
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|udev
operator|->
name|curr_config_index
operator|==
name|USB_UNCONFIG_INDEX
condition|)
block|{
comment|/* do nothing - no configuration has been set */
goto|goto
name|done
goto|;
block|}
comment|/* setup USB attach arguments */
name|usb2_init_attach_arg
argument_list|(
name|udev
argument_list|,
operator|&
name|uaa
argument_list|)
expr_stmt|;
comment|/* Check if only one interface should be probed: */
if|if
condition|(
name|iface_index
operator|!=
name|USB_IFACE_INDEX_ANY
condition|)
block|{
name|i
operator|=
name|iface_index
expr_stmt|;
name|j
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|USB_IFACE_MAX
expr_stmt|;
block|}
comment|/* Do the probe and attach */
for|for
control|(
init|;
name|i
operator|!=
name|j
condition|;
name|i
operator|++
control|)
block|{
name|iface
operator|=
name|usb2_get_iface
argument_list|(
name|udev
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Looks like the end of the USB 			 * interfaces ! 			 */
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"end of interfaces "
literal|"at %u\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|iface
operator|->
name|idesc
operator|==
name|NULL
condition|)
block|{
comment|/* no interface descriptor */
continue|continue;
block|}
name|uaa
operator|.
name|iface
operator|=
name|iface
expr_stmt|;
name|uaa
operator|.
name|info
operator|.
name|bInterfaceClass
operator|=
name|iface
operator|->
name|idesc
operator|->
name|bInterfaceClass
expr_stmt|;
name|uaa
operator|.
name|info
operator|.
name|bInterfaceSubClass
operator|=
name|iface
operator|->
name|idesc
operator|->
name|bInterfaceSubClass
expr_stmt|;
name|uaa
operator|.
name|info
operator|.
name|bInterfaceProtocol
operator|=
name|iface
operator|->
name|idesc
operator|->
name|bInterfaceProtocol
expr_stmt|;
name|uaa
operator|.
name|info
operator|.
name|bIfaceIndex
operator|=
name|i
expr_stmt|;
name|uaa
operator|.
name|info
operator|.
name|bIfaceNum
operator|=
name|iface
operator|->
name|idesc
operator|->
name|bInterfaceNumber
expr_stmt|;
name|uaa
operator|.
name|use_generic
operator|=
literal|0
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"iclass=%u/%u/%u iindex=%u/%u\n"
argument_list|,
name|uaa
operator|.
name|info
operator|.
name|bInterfaceClass
argument_list|,
name|uaa
operator|.
name|info
operator|.
name|bInterfaceSubClass
argument_list|,
name|uaa
operator|.
name|info
operator|.
name|bInterfaceProtocol
argument_list|,
name|uaa
operator|.
name|info
operator|.
name|bIfaceIndex
argument_list|,
name|uaa
operator|.
name|info
operator|.
name|bIfaceNum
argument_list|)
expr_stmt|;
comment|/* try specific interface drivers first */
if|if
condition|(
name|usb2_probe_and_attach_sub
argument_list|(
name|udev
argument_list|,
operator|&
name|uaa
argument_list|)
condition|)
block|{
comment|/* ignore */
block|}
comment|/* try generic interface drivers last */
name|uaa
operator|.
name|use_generic
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|usb2_probe_and_attach_sub
argument_list|(
name|udev
argument_list|,
operator|&
name|uaa
argument_list|)
condition|)
block|{
comment|/* ignore */
block|}
block|}
if|if
condition|(
name|uaa
operator|.
name|temp_dev
condition|)
block|{
comment|/* remove the last created child; it is unused */
if|if
condition|(
name|device_delete_child
argument_list|(
name|udev
operator|->
name|parent_dev
argument_list|,
name|uaa
operator|.
name|temp_dev
argument_list|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"device delete child failed!\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|done
label|:
if|if
condition|(
name|do_unlock
condition|)
block|{
name|sx_unlock
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_suspend_resume_sub  *  * This function is called when the suspend or resume methods should  * be executed on an USB device.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb2_suspend_resume_sub
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|uint8_t
name|do_suspend
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|do_suspend
condition|)
block|{
name|err
operator|=
name|DEVICE_SUSPEND
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|DEVICE_RESUME
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s failed!\n"
argument_list|,
name|do_suspend
condition|?
literal|"Suspend"
else|:
literal|"Resume"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_suspend_resume_device  *  * The following function will suspend or resume the USB device.  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
name|usb2_error_t
name|usb2_suspend_resume
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|do_suspend
parameter_list|)
block|{
name|struct
name|usb2_interface
modifier|*
name|iface
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
block|{
comment|/* nothing to do */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"udev=%p do_suspend=%d\n"
argument_list|,
name|udev
argument_list|,
name|do_suspend
argument_list|)
expr_stmt|;
name|sx_assert
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|,
name|SA_LOCKED
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|udev
operator|->
name|bus
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* filter the suspend events */
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|suspended
operator|==
name|do_suspend
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|udev
operator|->
name|bus
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* nothing to do */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|udev
operator|->
name|flags
operator|.
name|suspended
operator|=
name|do_suspend
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|udev
operator|->
name|bus
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* do the suspend or resume */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|USB_IFACE_MAX
condition|;
name|i
operator|++
control|)
block|{
name|iface
operator|=
name|usb2_get_iface
argument_list|(
name|udev
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
block|{
comment|/* looks like the end of the USB interfaces */
break|break;
block|}
name|usb2_suspend_resume_sub
argument_list|(
name|udev
argument_list|,
name|iface
operator|->
name|subdev
argument_list|,
name|do_suspend
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *      usb2_clear_stall_proc  *  * This function performs generic USB clear stall operations.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb2_clear_stall_proc
parameter_list|(
name|struct
name|usb2_proc_msg
modifier|*
name|_pm
parameter_list|)
block|{
name|struct
name|usb2_clear_stall_msg
modifier|*
name|pm
init|=
operator|(
name|void
operator|*
operator|)
name|_pm
decl_stmt|;
name|struct
name|usb2_device
modifier|*
name|udev
init|=
name|pm
operator|->
name|udev
decl_stmt|;
comment|/* Change lock */
name|mtx_unlock
argument_list|(
operator|&
name|udev
operator|->
name|bus
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|udev
operator|->
name|default_mtx
argument_list|)
expr_stmt|;
comment|/* Start clear stall callback */
name|usb2_transfer_start
argument_list|(
name|udev
operator|->
name|default_xfer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Change lock */
name|mtx_unlock
argument_list|(
name|udev
operator|->
name|default_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|udev
operator|->
name|bus
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_alloc_device  *  * This function allocates a new USB device. This function is called  * when a new device has been put in the powered state, but not yet in  * the addressed state. Get initial descriptor, set the address, get  * full descriptor and get strings.  *  * Return values:  *    0: Failure  * Else: Success  *------------------------------------------------------------------------*/
end_comment

begin_function
name|struct
name|usb2_device
modifier|*
name|usb2_alloc_device
parameter_list|(
name|device_t
name|parent_dev
parameter_list|,
name|struct
name|usb2_bus
modifier|*
name|bus
parameter_list|,
name|struct
name|usb2_device
modifier|*
name|parent_hub
parameter_list|,
name|uint8_t
name|depth
parameter_list|,
name|uint8_t
name|port_index
parameter_list|,
name|uint8_t
name|port_no
parameter_list|,
name|uint8_t
name|speed
parameter_list|,
name|uint8_t
name|usb2_mode
parameter_list|)
block|{
name|struct
name|usb2_attach_arg
name|uaa
decl_stmt|;
name|struct
name|usb2_device
modifier|*
name|udev
decl_stmt|;
name|struct
name|usb2_device
modifier|*
name|adev
decl_stmt|;
name|struct
name|usb2_device
modifier|*
name|hub
decl_stmt|;
name|uint8_t
modifier|*
name|scratch_ptr
decl_stmt|;
name|uint32_t
name|scratch_size
decl_stmt|;
name|usb2_error_t
name|err
decl_stmt|;
name|uint8_t
name|device_index
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"parent_dev=%p, bus=%p, parent_hub=%p, depth=%u, "
literal|"port_index=%u, port_no=%u, speed=%u, usb2_mode=%u\n"
argument_list|,
name|parent_dev
argument_list|,
name|bus
argument_list|,
name|parent_hub
argument_list|,
name|depth
argument_list|,
name|port_index
argument_list|,
name|port_no
argument_list|,
name|speed
argument_list|,
name|usb2_mode
argument_list|)
expr_stmt|;
comment|/* 	 * Find an unused device index. In USB Host mode this is the 	 * same as the device address. 	 * 	 * NOTE: Index 1 is reserved for the Root HUB. 	 */
for|for
control|(
name|device_index
operator|=
name|USB_ROOT_HUB_ADDR
init|;
name|device_index
operator|!=
name|USB_MAX_DEVICES
condition|;
name|device_index
operator|++
control|)
block|{
if|if
condition|(
name|bus
operator|->
name|devices
index|[
name|device_index
index|]
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|device_index
operator|==
name|USB_MAX_DEVICES
condition|)
block|{
name|device_printf
argument_list|(
name|bus
operator|->
name|bdev
argument_list|,
literal|"No free USB device index for new device!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|depth
operator|>
literal|0x10
condition|)
block|{
name|device_printf
argument_list|(
name|bus
operator|->
name|bdev
argument_list|,
literal|"Invalid device depth!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|udev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|udev
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* initialise our SX-lock */
name|sx_init
argument_list|(
name|udev
operator|->
name|default_sx
argument_list|,
literal|"0123456789ABCDEF - USB device SX lock"
operator|+
name|depth
argument_list|)
expr_stmt|;
comment|/* initialise our SX-lock */
name|sx_init
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|,
literal|"0123456789ABCDEF - USB config SX lock"
operator|+
name|depth
argument_list|)
expr_stmt|;
name|usb2_cv_init
argument_list|(
name|udev
operator|->
name|default_cv
argument_list|,
literal|"WCTRL"
argument_list|)
expr_stmt|;
name|usb2_cv_init
argument_list|(
name|udev
operator|->
name|default_cv
operator|+
literal|1
argument_list|,
literal|"UGONE"
argument_list|)
expr_stmt|;
comment|/* initialise our mutex */
name|mtx_init
argument_list|(
name|udev
operator|->
name|default_mtx
argument_list|,
literal|"USB device mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* initialise generic clear stall */
name|udev
operator|->
name|cs_msg
index|[
literal|0
index|]
operator|.
name|hdr
operator|.
name|pm_callback
operator|=
operator|&
name|usb2_clear_stall_proc
expr_stmt|;
name|udev
operator|->
name|cs_msg
index|[
literal|0
index|]
operator|.
name|udev
operator|=
name|udev
expr_stmt|;
name|udev
operator|->
name|cs_msg
index|[
literal|1
index|]
operator|.
name|hdr
operator|.
name|pm_callback
operator|=
operator|&
name|usb2_clear_stall_proc
expr_stmt|;
name|udev
operator|->
name|cs_msg
index|[
literal|1
index|]
operator|.
name|udev
operator|=
name|udev
expr_stmt|;
comment|/* initialise some USB device fields */
name|udev
operator|->
name|parent_hub
operator|=
name|parent_hub
expr_stmt|;
name|udev
operator|->
name|parent_dev
operator|=
name|parent_dev
expr_stmt|;
name|udev
operator|->
name|port_index
operator|=
name|port_index
expr_stmt|;
name|udev
operator|->
name|port_no
operator|=
name|port_no
expr_stmt|;
name|udev
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|udev
operator|->
name|bus
operator|=
name|bus
expr_stmt|;
name|udev
operator|->
name|address
operator|=
name|USB_START_ADDR
expr_stmt|;
comment|/* default value */
name|udev
operator|->
name|plugtime
operator|=
operator|(
name|uint32_t
operator|)
name|ticks
expr_stmt|;
name|udev
operator|->
name|power_mode
operator|=
name|USB_POWER_MODE_ON
expr_stmt|;
comment|/* we are not ready yet */
name|udev
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
comment|/* set up default endpoint descriptor */
name|udev
operator|->
name|default_ep_desc
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
name|udev
operator|->
name|default_ep_desc
argument_list|)
expr_stmt|;
name|udev
operator|->
name|default_ep_desc
operator|.
name|bDescriptorType
operator|=
name|UDESC_ENDPOINT
expr_stmt|;
name|udev
operator|->
name|default_ep_desc
operator|.
name|bEndpointAddress
operator|=
name|USB_CONTROL_ENDPOINT
expr_stmt|;
name|udev
operator|->
name|default_ep_desc
operator|.
name|bmAttributes
operator|=
name|UE_CONTROL
expr_stmt|;
name|udev
operator|->
name|default_ep_desc
operator|.
name|wMaxPacketSize
index|[
literal|0
index|]
operator|=
name|USB_MAX_IPACKET
expr_stmt|;
name|udev
operator|->
name|default_ep_desc
operator|.
name|wMaxPacketSize
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|udev
operator|->
name|default_ep_desc
operator|.
name|bInterval
operator|=
literal|0
expr_stmt|;
name|udev
operator|->
name|ddesc
operator|.
name|bMaxPacketSize
operator|=
name|USB_MAX_IPACKET
expr_stmt|;
name|udev
operator|->
name|speed
operator|=
name|speed
expr_stmt|;
name|udev
operator|->
name|flags
operator|.
name|usb2_mode
operator|=
name|usb2_mode
expr_stmt|;
comment|/* check speed combination */
name|hub
operator|=
name|udev
operator|->
name|parent_hub
expr_stmt|;
if|if
condition|(
name|hub
condition|)
block|{
if|if
condition|(
name|usb2_hub_speed_combs
index|[
name|hub
operator|->
name|speed
index|]
index|[
name|speed
index|]
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|USB_DEBUG
name|printf
argument_list|(
literal|"%s: the selected subdevice and HUB speed "
literal|"combination is not supported %d/%d.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|speed
argument_list|,
name|hub
operator|->
name|speed
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* reject this combination */
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* search for our High Speed USB HUB, if any */
name|adev
operator|=
name|udev
expr_stmt|;
name|hub
operator|=
name|udev
operator|->
name|parent_hub
expr_stmt|;
while|while
condition|(
name|hub
condition|)
block|{
if|if
condition|(
name|hub
operator|->
name|speed
operator|==
name|USB_SPEED_HIGH
condition|)
block|{
name|udev
operator|->
name|hs_hub_addr
operator|=
name|hub
operator|->
name|address
expr_stmt|;
name|udev
operator|->
name|hs_port_no
operator|=
name|adev
operator|->
name|port_no
expr_stmt|;
break|break;
block|}
name|adev
operator|=
name|hub
expr_stmt|;
name|hub
operator|=
name|hub
operator|->
name|parent_hub
expr_stmt|;
block|}
comment|/* init the default pipe */
name|usb2_fill_pipe_data
argument_list|(
name|udev
argument_list|,
literal|0
argument_list|,
operator|&
name|udev
operator|->
name|default_ep_desc
argument_list|,
operator|&
name|udev
operator|->
name|default_pipe
argument_list|)
expr_stmt|;
comment|/* set device index */
name|udev
operator|->
name|device_index
operator|=
name|device_index
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb2_mode
operator|==
name|USB_MODE_HOST
condition|)
block|{
name|err
operator|=
name|usb2_req_set_address
argument_list|(
name|udev
argument_list|,
operator|&
name|Giant
argument_list|,
name|device_index
argument_list|)
expr_stmt|;
comment|/* This is the new USB device address from now on */
name|udev
operator|->
name|address
operator|=
name|device_index
expr_stmt|;
comment|/* 		 * We ignore any set-address errors, hence there are 		 * buggy USB devices out there that actually receive 		 * the SETUP PID, but manage to set the address before 		 * the STATUS stage is ACK'ed. If the device responds 		 * to the subsequent get-descriptor at the new 		 * address, then we know that the set-address command 		 * was successful. 		 */
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"set address %d failed "
literal|"(ignored)\n"
argument_list|,
name|udev
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
comment|/* allow device time to set new address */
name|usb2_pause_mtx
argument_list|(
operator|&
name|Giant
argument_list|,
name|USB_SET_ADDRESS_SETTLE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We are not self powered */
name|udev
operator|->
name|flags
operator|.
name|self_powered
operator|=
literal|0
expr_stmt|;
comment|/* Set unconfigured state */
name|udev
operator|->
name|curr_config_no
operator|=
name|USB_UNCONFIG_NO
expr_stmt|;
name|udev
operator|->
name|curr_config_index
operator|=
name|USB_UNCONFIG_INDEX
expr_stmt|;
comment|/* Setup USB descriptors */
name|err
operator|=
call|(
name|usb2_temp_setup_by_index_p
call|)
argument_list|(
name|udev
argument_list|,
name|usb2_template
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"setting up USB template failed maybe the USB "
literal|"template module has not been loaded\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* 	 * Get the first 8 bytes of the device descriptor ! 	 * 	 * NOTE: "usb2_do_request" will check the device descriptor 	 * next time we do a request to see if the maximum packet size 	 * changed! The 8 first bytes of the device descriptor 	 * contains the maximum packet size to use on control endpoint 	 * 0. If this value is different from "USB_MAX_IPACKET" a new 	 * USB control request will be setup! 	 */
name|err
operator|=
name|usb2_req_get_desc
argument_list|(
name|udev
argument_list|,
operator|&
name|Giant
argument_list|,
operator|&
name|udev
operator|->
name|ddesc
argument_list|,
name|USB_MAX_IPACKET
argument_list|,
name|USB_MAX_IPACKET
argument_list|,
literal|0
argument_list|,
name|UDESC_DEVICE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"getting device descriptor "
literal|"at addr %d failed!\n"
argument_list|,
name|udev
operator|->
name|address
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|DPRINTF
argument_list|(
literal|"adding unit addr=%d, rev=%02x, class=%d, "
literal|"subclass=%d, protocol=%d, maxpacket=%d, len=%d, speed=%d\n"
argument_list|,
name|udev
operator|->
name|address
argument_list|,
name|UGETW
argument_list|(
name|udev
operator|->
name|ddesc
operator|.
name|bcdUSB
argument_list|)
argument_list|,
name|udev
operator|->
name|ddesc
operator|.
name|bDeviceClass
argument_list|,
name|udev
operator|->
name|ddesc
operator|.
name|bDeviceSubClass
argument_list|,
name|udev
operator|->
name|ddesc
operator|.
name|bDeviceProtocol
argument_list|,
name|udev
operator|->
name|ddesc
operator|.
name|bMaxPacketSize
argument_list|,
name|udev
operator|->
name|ddesc
operator|.
name|bLength
argument_list|,
name|udev
operator|->
name|speed
argument_list|)
expr_stmt|;
comment|/* get the full device descriptor */
name|err
operator|=
name|usb2_req_get_device_desc
argument_list|(
name|udev
argument_list|,
operator|&
name|Giant
argument_list|,
operator|&
name|udev
operator|->
name|ddesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"addr=%d, getting full desc failed\n"
argument_list|,
name|udev
operator|->
name|address
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Setup temporary USB attach args so that we can figure out some 	 * basic quirks for this device. 	 */
name|usb2_init_attach_arg
argument_list|(
name|udev
argument_list|,
operator|&
name|uaa
argument_list|)
expr_stmt|;
if|if
condition|(
name|usb2_test_quirk
argument_list|(
operator|&
name|uaa
argument_list|,
name|UQ_BUS_POWERED
argument_list|)
condition|)
block|{
name|udev
operator|->
name|flags
operator|.
name|uq_bus_powered
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|usb2_test_quirk
argument_list|(
operator|&
name|uaa
argument_list|,
name|UQ_POWER_CLAIM
argument_list|)
condition|)
block|{
name|udev
operator|->
name|flags
operator|.
name|uq_power_claim
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|usb2_test_quirk
argument_list|(
operator|&
name|uaa
argument_list|,
name|UQ_NO_STRINGS
argument_list|)
condition|)
block|{
name|udev
operator|->
name|flags
operator|.
name|no_strings
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Workaround for buggy USB devices. 	 * 	 * It appears that some string-less USB chips will crash and 	 * disappear if any attempts are made to read any string 	 * descriptors. 	 * 	 * Try to detect such chips by checking the strings in the USB 	 * device descriptor. If no strings are present there we 	 * simply disable all USB strings. 	 */
name|scratch_ptr
operator|=
name|udev
operator|->
name|bus
operator|->
name|scratch
index|[
literal|0
index|]
operator|.
name|data
expr_stmt|;
name|scratch_size
operator|=
sizeof|sizeof
argument_list|(
name|udev
operator|->
name|bus
operator|->
name|scratch
index|[
literal|0
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|ddesc
operator|.
name|iManufacturer
operator|||
name|udev
operator|->
name|ddesc
operator|.
name|iProduct
operator|||
name|udev
operator|->
name|ddesc
operator|.
name|iSerialNumber
condition|)
block|{
comment|/* read out the language ID string */
name|err
operator|=
name|usb2_req_get_string_desc
argument_list|(
name|udev
argument_list|,
operator|&
name|Giant
argument_list|,
operator|(
name|char
operator|*
operator|)
name|scratch_ptr
argument_list|,
literal|4
argument_list|,
name|scratch_size
argument_list|,
name|USB_LANGUAGE_TABLE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|||
operator|(
name|scratch_ptr
index|[
literal|0
index|]
operator|<
literal|4
operator|)
condition|)
block|{
name|udev
operator|->
name|flags
operator|.
name|no_strings
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* pick the first language as the default */
name|udev
operator|->
name|langid
operator|=
name|UGETW
argument_list|(
name|scratch_ptr
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* assume 100mA bus powered for now. Changed when configured. */
name|udev
operator|->
name|power
operator|=
name|USB_MIN_POWER
expr_stmt|;
comment|/* get serial number string */
name|err
operator|=
name|usb2_req_get_string_any
argument_list|(
name|udev
argument_list|,
operator|&
name|Giant
argument_list|,
operator|(
name|char
operator|*
operator|)
name|scratch_ptr
argument_list|,
name|scratch_size
argument_list|,
name|udev
operator|->
name|ddesc
operator|.
name|iSerialNumber
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|udev
operator|->
name|serial
argument_list|,
operator|(
name|char
operator|*
operator|)
name|scratch_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|udev
operator|->
name|serial
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get manufacturer string */
name|err
operator|=
name|usb2_req_get_string_any
argument_list|(
name|udev
argument_list|,
operator|&
name|Giant
argument_list|,
operator|(
name|char
operator|*
operator|)
name|scratch_ptr
argument_list|,
name|scratch_size
argument_list|,
name|udev
operator|->
name|ddesc
operator|.
name|iManufacturer
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|udev
operator|->
name|manufacturer
argument_list|,
operator|(
name|char
operator|*
operator|)
name|scratch_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|udev
operator|->
name|manufacturer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get product string */
name|err
operator|=
name|usb2_req_get_string_any
argument_list|(
name|udev
argument_list|,
operator|&
name|Giant
argument_list|,
operator|(
name|char
operator|*
operator|)
name|scratch_ptr
argument_list|,
name|scratch_size
argument_list|,
name|udev
operator|->
name|ddesc
operator|.
name|iProduct
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|udev
operator|->
name|product
argument_list|,
operator|(
name|char
operator|*
operator|)
name|scratch_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|udev
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
comment|/* finish up all the strings */
name|usb2_check_strings
argument_list|(
name|udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb2_mode
operator|==
name|USB_MODE_HOST
condition|)
block|{
name|uint8_t
name|config_index
decl_stmt|;
name|uint8_t
name|config_quirk
decl_stmt|;
comment|/* 		 * Most USB devices should attach to config index 0 by 		 * default 		 */
if|if
condition|(
name|usb2_test_quirk
argument_list|(
operator|&
name|uaa
argument_list|,
name|UQ_CFG_INDEX_0
argument_list|)
condition|)
block|{
name|config_index
operator|=
literal|0
expr_stmt|;
name|config_quirk
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usb2_test_quirk
argument_list|(
operator|&
name|uaa
argument_list|,
name|UQ_CFG_INDEX_1
argument_list|)
condition|)
block|{
name|config_index
operator|=
literal|1
expr_stmt|;
name|config_quirk
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usb2_test_quirk
argument_list|(
operator|&
name|uaa
argument_list|,
name|UQ_CFG_INDEX_2
argument_list|)
condition|)
block|{
name|config_index
operator|=
literal|2
expr_stmt|;
name|config_quirk
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usb2_test_quirk
argument_list|(
operator|&
name|uaa
argument_list|,
name|UQ_CFG_INDEX_3
argument_list|)
condition|)
block|{
name|config_index
operator|=
literal|3
expr_stmt|;
name|config_quirk
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usb2_test_quirk
argument_list|(
operator|&
name|uaa
argument_list|,
name|UQ_CFG_INDEX_4
argument_list|)
condition|)
block|{
name|config_index
operator|=
literal|4
expr_stmt|;
name|config_quirk
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|config_index
operator|=
literal|0
expr_stmt|;
name|config_quirk
operator|=
literal|0
expr_stmt|;
block|}
name|repeat_set_config
label|:
name|DPRINTF
argument_list|(
literal|"setting config %u\n"
argument_list|,
name|config_index
argument_list|)
expr_stmt|;
comment|/* get the USB device configured */
name|sx_xlock
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb2_set_config_index
argument_list|(
name|udev
argument_list|,
name|config_index
argument_list|)
expr_stmt|;
name|sx_unlock
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Failure selecting "
literal|"configuration index %u: %s, port %u, addr %u\n"
argument_list|,
name|config_index
argument_list|,
name|usb2_errstr
argument_list|(
name|err
argument_list|)
argument_list|,
name|udev
operator|->
name|port_no
argument_list|,
name|udev
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|config_quirk
condition|)
block|{
comment|/* user quirk selects configuration index */
block|}
elseif|else
if|if
condition|(
operator|(
name|config_index
operator|+
literal|1
operator|)
operator|<
name|udev
operator|->
name|ddesc
operator|.
name|bNumConfigurations
condition|)
block|{
if|if
condition|(
operator|(
name|udev
operator|->
name|cdesc
operator|->
name|bNumInterface
operator|<
literal|2
operator|)
operator|&&
operator|(
name|usb2_get_no_endpoints
argument_list|(
name|udev
operator|->
name|cdesc
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Found no endpoints "
literal|"(trying next config)!\n"
argument_list|)
expr_stmt|;
name|config_index
operator|++
expr_stmt|;
goto|goto
name|repeat_set_config
goto|;
block|}
if|if
condition|(
name|config_index
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Try to figure out if we have an 				 * auto-install disk there: 				 */
if|if
condition|(
name|usb2_test_autoinstall
argument_list|(
name|udev
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Found possible auto-install "
literal|"disk (trying next config)\n"
argument_list|)
expr_stmt|;
name|config_index
operator|++
expr_stmt|;
goto|goto
name|repeat_set_config
goto|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|UGETW
argument_list|(
name|udev
operator|->
name|ddesc
operator|.
name|idVendor
argument_list|)
operator|==
name|USB_VENDOR_HUAWEI
condition|)
block|{
if|if
condition|(
name|usb2_test_huawei
argument_list|(
name|udev
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Found Huawei auto-install disk!\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|USB_ERR_STALLED
expr_stmt|;
comment|/* fake an error */
block|}
block|}
block|}
else|else
block|{
name|err
operator|=
literal|0
expr_stmt|;
comment|/* set success */
block|}
name|DPRINTF
argument_list|(
literal|"new dev (addr %d), udev=%p, parent_hub=%p\n"
argument_list|,
name|udev
operator|->
name|address
argument_list|,
name|udev
argument_list|,
name|udev
operator|->
name|parent_hub
argument_list|)
expr_stmt|;
comment|/* register our device - we are ready */
name|usb2_bus_port_set_device
argument_list|(
name|bus
argument_list|,
name|parent_hub
condition|?
name|parent_hub
operator|->
name|hub
operator|->
name|ports
operator|+
name|port_index
else|:
name|NULL
argument_list|,
name|udev
argument_list|,
name|device_index
argument_list|)
expr_stmt|;
comment|/* make a symlink for UGEN */
if|if
condition|(
name|snprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|scratch_ptr
argument_list|,
name|scratch_size
argument_list|,
name|USB_DEVICE_NAME
literal|"%u.%u.0.0"
argument_list|,
name|device_get_unit
argument_list|(
name|udev
operator|->
name|bus
operator|->
name|bdev
argument_list|)
argument_list|,
name|udev
operator|->
name|device_index
argument_list|)
condition|)
block|{
comment|/* ignore */
block|}
name|udev
operator|->
name|ugen_symlink
operator|=
name|usb2_alloc_symlink
argument_list|(
operator|(
name|char
operator|*
operator|)
name|scratch_ptr
argument_list|,
literal|"ugen%u.%u"
argument_list|,
name|device_get_unit
argument_list|(
name|udev
operator|->
name|bus
operator|->
name|bdev
argument_list|)
argument_list|,
name|udev
operator|->
name|device_index
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ugen%u.%u:<%s> at %s\n"
argument_list|,
name|device_get_unit
argument_list|(
name|udev
operator|->
name|bus
operator|->
name|bdev
argument_list|)
argument_list|,
name|udev
operator|->
name|device_index
argument_list|,
name|udev
operator|->
name|manufacturer
argument_list|,
name|device_get_nameunit
argument_list|(
name|udev
operator|->
name|bus
operator|->
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|usb2_notify_addq
argument_list|(
literal|"+"
argument_list|,
name|udev
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|err
condition|)
block|{
comment|/* free device  */
name|usb2_free_device
argument_list|(
name|udev
argument_list|)
expr_stmt|;
name|udev
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|udev
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_free_device  *  * This function is NULL safe and will free an USB device.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb2_free_device
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|usb2_bus
modifier|*
name|bus
decl_stmt|;
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
block|{
comment|/* already freed */
return|return;
block|}
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"udev=%p port=%d\n"
argument_list|,
name|udev
argument_list|,
name|udev
operator|->
name|port_no
argument_list|)
expr_stmt|;
name|usb2_notify_addq
argument_list|(
literal|"-"
argument_list|,
name|udev
argument_list|)
expr_stmt|;
name|bus
operator|=
name|udev
operator|->
name|bus
expr_stmt|;
comment|/* 	 * Destroy UGEN symlink, if any 	 */
if|if
condition|(
name|udev
operator|->
name|ugen_symlink
condition|)
block|{
name|usb2_free_symlink
argument_list|(
name|udev
operator|->
name|ugen_symlink
argument_list|)
expr_stmt|;
name|udev
operator|->
name|ugen_symlink
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Unregister our device first which will prevent any further 	 * references: 	 */
name|usb2_bus_port_set_device
argument_list|(
name|bus
argument_list|,
name|udev
operator|->
name|parent_hub
condition|?
name|udev
operator|->
name|parent_hub
operator|->
name|hub
operator|->
name|ports
operator|+
name|udev
operator|->
name|port_index
else|:
name|NULL
argument_list|,
name|NULL
argument_list|,
name|USB_ROOT_HUB_ADDR
argument_list|)
expr_stmt|;
comment|/* wait for all pending references to go away: */
name|mtx_lock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
name|udev
operator|->
name|refcount
operator|--
expr_stmt|;
while|while
condition|(
name|udev
operator|->
name|refcount
operator|!=
literal|0
condition|)
block|{
name|usb2_cv_wait
argument_list|(
name|udev
operator|->
name|default_cv
operator|+
literal|1
argument_list|,
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|usb2_ref_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb2_mode
operator|==
name|USB_MODE_DEVICE
condition|)
block|{
comment|/* stop receiving any control transfers (Device Side Mode) */
name|usb2_transfer_unsetup
argument_list|(
name|udev
operator|->
name|default_xfer
argument_list|,
name|USB_DEFAULT_XFER_MAX
argument_list|)
expr_stmt|;
block|}
comment|/* free all FIFOs */
name|usb2_fifo_free_wrap
argument_list|(
name|udev
argument_list|,
name|USB_IFACE_INDEX_ANY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Free all interface related data and FIFOs, if any. 	 */
name|usb2_free_iface_data
argument_list|(
name|udev
argument_list|)
expr_stmt|;
comment|/* unsetup any leftover default USB transfers */
name|usb2_transfer_unsetup
argument_list|(
name|udev
operator|->
name|default_xfer
argument_list|,
name|USB_DEFAULT_XFER_MAX
argument_list|)
expr_stmt|;
call|(
name|usb2_temp_unsetup_p
call|)
argument_list|(
name|udev
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
name|udev
operator|->
name|default_sx
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
name|udev
operator|->
name|default_sx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|usb2_cv_destroy
argument_list|(
name|udev
operator|->
name|default_cv
argument_list|)
expr_stmt|;
name|usb2_cv_destroy
argument_list|(
name|udev
operator|->
name|default_cv
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
name|udev
operator|->
name|default_mtx
argument_list|)
expr_stmt|;
comment|/* free device */
name|free
argument_list|(
name|udev
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_get_iface  *  * This function is the safe way to get the USB interface structure  * pointer by interface index.  *  * Return values:  *   NULL: Interface not present.  *   Else: Pointer to USB interface structure.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|struct
name|usb2_interface
modifier|*
name|usb2_get_iface
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|)
block|{
name|struct
name|usb2_interface
modifier|*
name|iface
init|=
name|udev
operator|->
name|ifaces
operator|+
name|iface_index
decl_stmt|;
if|if
condition|(
operator|(
name|iface
operator|<
name|udev
operator|->
name|ifaces
operator|)
operator|||
operator|(
name|iface_index
operator|>=
name|USB_IFACE_MAX
operator|)
operator|||
operator|(
name|udev
operator|->
name|cdesc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|iface_index
operator|>=
name|udev
operator|->
name|cdesc
operator|->
name|bNumInterface
operator|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|iface
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_find_descriptor  *  * This function will lookup the first descriptor that matches the  * criteria given by the arguments "type" and "subtype". Descriptors  * will only be searched within the interface having the index  * "iface_index".  If the "id" argument points to an USB descriptor,  * it will be skipped before the search is started. This allows  * searching for multiple descriptors using the same criteria. Else  * the search is started after the interface descriptor.  *  * Return values:  *   NULL: End of descriptors  *   Else: A descriptor matching the criteria  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
modifier|*
name|usb2_find_descriptor
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|void
modifier|*
name|id
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|uint8_t
name|type
parameter_list|,
name|uint8_t
name|type_mask
parameter_list|,
name|uint8_t
name|subtype
parameter_list|,
name|uint8_t
name|subtype_mask
parameter_list|)
block|{
name|struct
name|usb2_descriptor
modifier|*
name|desc
decl_stmt|;
name|struct
name|usb2_config_descriptor
modifier|*
name|cd
decl_stmt|;
name|struct
name|usb2_interface
modifier|*
name|iface
decl_stmt|;
name|cd
operator|=
name|usb2_get_config_descriptor
argument_list|(
name|udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
block|{
name|iface
operator|=
name|usb2_get_iface
argument_list|(
name|udev
argument_list|,
name|iface_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|id
operator|=
name|usb2_get_interface_descriptor
argument_list|(
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|desc
operator|=
operator|(
name|void
operator|*
operator|)
name|id
expr_stmt|;
while|while
condition|(
operator|(
name|desc
operator|=
name|usb2_desc_foreach
argument_list|(
name|cd
argument_list|,
name|desc
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|desc
operator|->
name|bDescriptorType
operator|==
name|UDESC_INTERFACE
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|desc
operator|->
name|bDescriptorType
operator|&
name|type_mask
operator|)
operator|==
name|type
operator|)
operator|&&
operator|(
operator|(
name|desc
operator|->
name|bDescriptorSubtype
operator|&
name|subtype_mask
operator|)
operator|==
name|subtype
operator|)
condition|)
block|{
return|return
operator|(
name|desc
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_devinfo  *  * This function will dump information from the device descriptor  * belonging to the USB device pointed to by "udev", to the string  * pointed to by "dst_ptr" having a maximum length of "dst_len" bytes  * including the terminating zero.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb2_devinfo
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|char
modifier|*
name|dst_ptr
parameter_list|,
name|uint16_t
name|dst_len
parameter_list|)
block|{
name|struct
name|usb2_device_descriptor
modifier|*
name|udd
init|=
operator|&
name|udev
operator|->
name|ddesc
decl_stmt|;
name|uint16_t
name|bcdDevice
decl_stmt|;
name|uint16_t
name|bcdUSB
decl_stmt|;
name|bcdUSB
operator|=
name|UGETW
argument_list|(
name|udd
operator|->
name|bcdUSB
argument_list|)
expr_stmt|;
name|bcdDevice
operator|=
name|UGETW
argument_list|(
name|udd
operator|->
name|bcdDevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|udd
operator|->
name|bDeviceClass
operator|!=
literal|0xFF
condition|)
block|{
name|snprintf
argument_list|(
name|dst_ptr
argument_list|,
name|dst_len
argument_list|,
literal|"%s %s, class %d/%d, rev %x.%02x/"
literal|"%x.%02x, addr %d"
argument_list|,
name|udev
operator|->
name|manufacturer
argument_list|,
name|udev
operator|->
name|product
argument_list|,
name|udd
operator|->
name|bDeviceClass
argument_list|,
name|udd
operator|->
name|bDeviceSubClass
argument_list|,
operator|(
name|bcdUSB
operator|>>
literal|8
operator|)
argument_list|,
name|bcdUSB
operator|&
literal|0xFF
argument_list|,
operator|(
name|bcdDevice
operator|>>
literal|8
operator|)
argument_list|,
name|bcdDevice
operator|&
literal|0xFF
argument_list|,
name|udev
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|dst_ptr
argument_list|,
name|dst_len
argument_list|,
literal|"%s %s, rev %x.%02x/"
literal|"%x.%02x, addr %d"
argument_list|,
name|udev
operator|->
name|manufacturer
argument_list|,
name|udev
operator|->
name|product
argument_list|,
operator|(
name|bcdUSB
operator|>>
literal|8
operator|)
argument_list|,
name|bcdUSB
operator|&
literal|0xFF
argument_list|,
operator|(
name|bcdDevice
operator|>>
literal|8
operator|)
argument_list|,
name|bcdDevice
operator|&
literal|0xFF
argument_list|,
name|udev
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|USB_VERBOSE
end_if

begin_comment
comment|/*  * Descriptions of of known vendors and devices ("products").  */
end_comment

begin_struct
struct|struct
name|usb_knowndev
block|{
name|uint16_t
name|vendor
decl_stmt|;
name|uint16_t
name|product
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|vendorname
decl_stmt|;
specifier|const
name|char
modifier|*
name|productname
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|USB_KNOWNDEV_NOPROD
value|0x01
end_define

begin_comment
comment|/* match on vendor only */
end_comment

begin_include
include|#
directive|include
file|<dev/usb2/include/usb2_devid.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/include/usb2_devtable.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USB_VERBOSE */
end_comment

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_check_strings  *  * This function checks the manufacturer and product strings and will  * fill in defaults for missing strings.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb2_check_strings
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|usb2_device_descriptor
modifier|*
name|udd
init|=
operator|&
name|udev
operator|->
name|ddesc
decl_stmt|;
specifier|const
name|char
modifier|*
name|vendor
decl_stmt|;
specifier|const
name|char
modifier|*
name|product
decl_stmt|;
if|#
directive|if
name|USB_VERBOSE
specifier|const
name|struct
name|usb_knowndev
modifier|*
name|kdp
decl_stmt|;
endif|#
directive|endif
name|uint16_t
name|vendor_id
decl_stmt|;
name|uint16_t
name|product_id
decl_stmt|;
name|usb2_trim_spaces
argument_list|(
name|udev
operator|->
name|manufacturer
argument_list|)
expr_stmt|;
name|usb2_trim_spaces
argument_list|(
name|udev
operator|->
name|product
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|manufacturer
index|[
literal|0
index|]
condition|)
block|{
name|vendor
operator|=
name|udev
operator|->
name|manufacturer
expr_stmt|;
block|}
else|else
block|{
name|vendor
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|udev
operator|->
name|product
index|[
literal|0
index|]
condition|)
block|{
name|product
operator|=
name|udev
operator|->
name|product
expr_stmt|;
block|}
else|else
block|{
name|product
operator|=
name|NULL
expr_stmt|;
block|}
name|vendor_id
operator|=
name|UGETW
argument_list|(
name|udd
operator|->
name|idVendor
argument_list|)
expr_stmt|;
name|product_id
operator|=
name|UGETW
argument_list|(
name|udd
operator|->
name|idProduct
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_VERBOSE
if|if
condition|(
name|vendor
operator|==
name|NULL
operator|||
name|product
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|kdp
operator|=
name|usb_knowndevs
init|;
name|kdp
operator|->
name|vendorname
operator|!=
name|NULL
condition|;
name|kdp
operator|++
control|)
block|{
if|if
condition|(
name|kdp
operator|->
name|vendor
operator|==
name|vendor_id
operator|&&
operator|(
name|kdp
operator|->
name|product
operator|==
name|product_id
operator|||
operator|(
name|kdp
operator|->
name|flags
operator|&
name|USB_KNOWNDEV_NOPROD
operator|)
operator|!=
literal|0
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|kdp
operator|->
name|vendorname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|vendor
operator|==
name|NULL
condition|)
name|vendor
operator|=
name|kdp
operator|->
name|vendorname
expr_stmt|;
if|if
condition|(
name|product
operator|==
name|NULL
condition|)
name|product
operator|=
operator|(
name|kdp
operator|->
name|flags
operator|&
name|USB_KNOWNDEV_NOPROD
operator|)
operator|==
literal|0
condition|?
name|kdp
operator|->
name|productname
else|:
name|NULL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|vendor
operator|&&
operator|*
name|vendor
condition|)
block|{
if|if
condition|(
name|udev
operator|->
name|manufacturer
operator|!=
name|vendor
condition|)
block|{
name|strlcpy
argument_list|(
name|udev
operator|->
name|manufacturer
argument_list|,
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|udev
operator|->
name|manufacturer
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|snprintf
argument_list|(
name|udev
operator|->
name|manufacturer
argument_list|,
sizeof|sizeof
argument_list|(
name|udev
operator|->
name|manufacturer
argument_list|)
argument_list|,
literal|"vendor 0x%04x"
argument_list|,
name|vendor_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|product
operator|&&
operator|*
name|product
condition|)
block|{
if|if
condition|(
name|udev
operator|->
name|product
operator|!=
name|product
condition|)
block|{
name|strlcpy
argument_list|(
name|udev
operator|->
name|product
argument_list|,
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|udev
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|snprintf
argument_list|(
name|udev
operator|->
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|udev
operator|->
name|product
argument_list|)
argument_list|,
literal|"product 0x%04x"
argument_list|,
name|product_id
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|uint8_t
name|usb2_get_speed
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|)
block|{
return|return
operator|(
name|udev
operator|->
name|speed
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|usb2_device_descriptor
modifier|*
name|usb2_get_device_descriptor
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|)
block|{
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* be NULL safe */
return|return
operator|(
operator|&
name|udev
operator|->
name|ddesc
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|usb2_config_descriptor
modifier|*
name|usb2_get_config_descriptor
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|)
block|{
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* be NULL safe */
return|return
operator|(
name|udev
operator|->
name|cdesc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_test_quirk - test a device for a given quirk  *  * Return values:  * 0: The USB device does not have the given quirk.  * Else: The USB device has the given quirk.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|uint8_t
name|usb2_test_quirk
parameter_list|(
specifier|const
name|struct
name|usb2_attach_arg
modifier|*
name|uaa
parameter_list|,
name|uint16_t
name|quirk
parameter_list|)
block|{
name|uint8_t
name|found
decl_stmt|;
name|found
operator|=
call|(
name|usb2_test_quirk_p
call|)
argument_list|(
operator|&
name|uaa
operator|->
name|info
argument_list|,
name|quirk
argument_list|)
expr_stmt|;
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|usb2_interface_descriptor
modifier|*
name|usb2_get_interface_descriptor
parameter_list|(
name|struct
name|usb2_interface
modifier|*
name|iface
parameter_list|)
block|{
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* be NULL safe */
return|return
operator|(
name|iface
operator|->
name|idesc
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|usb2_get_interface_altindex
parameter_list|(
name|struct
name|usb2_interface
modifier|*
name|iface
parameter_list|)
block|{
return|return
operator|(
name|iface
operator|->
name|alt_index
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|usb2_get_bus_index
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|)
block|{
return|return
operator|(
operator|(
name|uint8_t
operator|)
name|device_get_unit
argument_list|(
name|udev
operator|->
name|bus
operator|->
name|bdev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|usb2_get_device_index
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|)
block|{
return|return
operator|(
name|udev
operator|->
name|device_index
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_notify_addq  *  * This function will generate events for dev.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb2_notify_addq
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|)
block|{
name|char
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|struct
name|malloc_type
modifier|*
name|mt
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|malloc_mtx
argument_list|)
expr_stmt|;
name|mt
operator|=
name|malloc_desc2type
argument_list|(
literal|"bus"
argument_list|)
expr_stmt|;
comment|/* XXX M_BUS */
name|mtx_unlock
argument_list|(
operator|&
name|malloc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mt
operator|==
name|NULL
condition|)
return|return;
name|data
operator|=
name|malloc
argument_list|(
literal|512
argument_list|,
name|mt
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return;
comment|/* String it all together. */
if|if
condition|(
name|udev
operator|->
name|parent_hub
condition|)
block|{
name|snprintf
argument_list|(
name|data
argument_list|,
literal|1024
argument_list|,
literal|"%s"
literal|"ugen%u.%u "
literal|"vendor=0x%04x "
literal|"product=0x%04x "
literal|"devclass=0x%02x "
literal|"devsubclass=0x%02x "
literal|"sernum=\"%s\" "
literal|"at "
literal|"port=%u "
literal|"on "
literal|"ugen%u.%u\n"
argument_list|,
name|type
argument_list|,
name|device_get_unit
argument_list|(
name|udev
operator|->
name|bus
operator|->
name|bdev
argument_list|)
argument_list|,
name|udev
operator|->
name|device_index
argument_list|,
name|UGETW
argument_list|(
name|udev
operator|->
name|ddesc
operator|.
name|idVendor
argument_list|)
argument_list|,
name|UGETW
argument_list|(
name|udev
operator|->
name|ddesc
operator|.
name|idProduct
argument_list|)
argument_list|,
name|udev
operator|->
name|ddesc
operator|.
name|bDeviceClass
argument_list|,
name|udev
operator|->
name|ddesc
operator|.
name|bDeviceSubClass
argument_list|,
name|udev
operator|->
name|serial
argument_list|,
name|udev
operator|->
name|port_no
argument_list|,
name|device_get_unit
argument_list|(
name|udev
operator|->
name|bus
operator|->
name|bdev
argument_list|)
argument_list|,
name|udev
operator|->
name|parent_hub
operator|->
name|device_index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|data
argument_list|,
literal|1024
argument_list|,
literal|"%s"
literal|"ugen%u.%u "
literal|"vendor=0x%04x "
literal|"product=0x%04x "
literal|"devclass=0x%02x "
literal|"devsubclass=0x%02x "
literal|"sernum=\"%s\" "
literal|"at port=%u "
literal|"on "
literal|"%s\n"
argument_list|,
name|type
argument_list|,
name|device_get_unit
argument_list|(
name|udev
operator|->
name|bus
operator|->
name|bdev
argument_list|)
argument_list|,
name|udev
operator|->
name|device_index
argument_list|,
name|UGETW
argument_list|(
name|udev
operator|->
name|ddesc
operator|.
name|idVendor
argument_list|)
argument_list|,
name|UGETW
argument_list|(
name|udev
operator|->
name|ddesc
operator|.
name|idProduct
argument_list|)
argument_list|,
name|udev
operator|->
name|ddesc
operator|.
name|bDeviceClass
argument_list|,
name|udev
operator|->
name|ddesc
operator|.
name|bDeviceSubClass
argument_list|,
name|udev
operator|->
name|serial
argument_list|,
name|udev
operator|->
name|port_no
argument_list|,
name|device_get_nameunit
argument_list|(
name|device_get_parent
argument_list|(
name|udev
operator|->
name|bus
operator|->
name|bdev
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|devctl_queue_data
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb2_fifo_free_wrap  *  * The function will free the FIFOs.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb2_fifo_free_wrap
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_index
parameter_list|,
name|uint8_t
name|free_all
parameter_list|)
block|{
name|struct
name|usb2_fifo
modifier|*
name|f
decl_stmt|;
name|struct
name|usb2_pipe
modifier|*
name|pipe
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
comment|/* 	 * Free any USB FIFOs on the given interface: 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|USB_FIFO_MAX
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
name|udev
operator|->
name|fifo
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
name|pipe
operator|=
name|f
operator|->
name|priv_sc0
expr_stmt|;
if|if
condition|(
operator|(
name|pipe
operator|==
operator|&
name|udev
operator|->
name|default_pipe
operator|)
operator|&&
operator|(
name|free_all
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* don't free UGEN control endpoint yet */
continue|continue;
block|}
comment|/* Check if the interface index matches */
if|if
condition|(
operator|(
name|iface_index
operator|==
name|f
operator|->
name|iface_index
operator|)
operator|||
operator|(
name|iface_index
operator|==
name|USB_IFACE_INDEX_ANY
operator|)
condition|)
block|{
name|usb2_fifo_free
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

end_unit

