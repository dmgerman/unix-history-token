begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: uaudio.c,v 1.91 2004/11/05 17:46:14 kent Exp $	*/
end_comment

begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1999 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Lennart Augustsson (lennart@augustsson.net) at  * Carlstedt Research& Technology.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * USB audio specs: http://www.usb.org/developers/devclass_docs/audio10.pdf  *                  http://www.usb.org/developers/devclass_docs/frmts10.pdf  *                  http://www.usb.org/developers/devclass_docs/termt10.pdf  */
end_comment

begin_comment
comment|/*  * Also merged:  *  $NetBSD: uaudio.c,v 1.94 2005/01/15 15:19:53 kent Exp $  *  $NetBSD: uaudio.c,v 1.95 2005/01/16 06:02:19 dsainty Exp $  *  $NetBSD: uaudio.c,v 1.96 2005/01/16 12:46:00 kent Exp $  *  $NetBSD: uaudio.c,v 1.97 2005/02/24 08:19:38 martin Exp $  */
end_comment

begin_include
include|#
directive|include
file|<dev/usb2/include/usb2_devid.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/include/usb2_standard.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/include/usb2_mfunc.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/include/usb2_error.h>
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|uaudio_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_lookup.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_parse.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_mbuf.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_dev.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/core/usb2_dynamic.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/quirk/usb2_quirk.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/sound/uaudio2_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb2/sound/uaudio2.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_comment
comment|/* for bootverbose */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/chip.h>
end_include

begin_include
include|#
directive|include
file|"feeder_if.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|uaudio_default_rate
init|=
literal|96000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|uaudio_default_bits
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|uaudio_default_channels
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|USB_DEBUG
end_if

begin_decl_stmt
specifier|static
name|int
name|uaudio_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb2
argument_list|,
name|OID_AUTO
argument_list|,
name|uaudio
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB uaudio"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb2_uaudio
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|uaudio_debug
argument_list|,
literal|0
argument_list|,
literal|"uaudio debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb2_uaudio
argument_list|,
name|OID_AUTO
argument_list|,
name|default_rate
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|uaudio_default_rate
argument_list|,
literal|0
argument_list|,
literal|"uaudio default sample rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb2_uaudio
argument_list|,
name|OID_AUTO
argument_list|,
name|default_bits
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|uaudio_default_bits
argument_list|,
literal|0
argument_list|,
literal|"uaudio default sample bits"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb2_uaudio
argument_list|,
name|OID_AUTO
argument_list|,
name|default_channels
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|uaudio_default_channels
argument_list|,
literal|0
argument_list|,
literal|"uaudio default sample channels"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UAUDIO_MINFRAMES
value|16
end_define

begin_comment
comment|/* must be factor of 8 due HS-USB */
end_comment

begin_define
define|#
directive|define
name|UAUDIO_NCHANBUFS
value|2
end_define

begin_comment
comment|/* number of outstanding request */
end_comment

begin_define
define|#
directive|define
name|UAUDIO_RECURSE_LIMIT
value|24
end_define

begin_comment
comment|/* rounds */
end_comment

begin_define
define|#
directive|define
name|MAKE_WORD
parameter_list|(
name|h
parameter_list|,
name|l
parameter_list|)
value|(((h)<< 8) | (l))
end_define

begin_define
define|#
directive|define
name|BIT_TEST
parameter_list|(
name|bm
parameter_list|,
name|bno
parameter_list|)
value|(((bm)[(bno) / 8]>> (7 - ((bno) % 8)))& 1)
end_define

begin_struct
struct|struct
name|uaudio_mixer_node
block|{
name|int32_t
name|minval
decl_stmt|;
name|int32_t
name|maxval
decl_stmt|;
define|#
directive|define
name|MIX_MAX_CHAN
value|8
name|int32_t
name|wValue
index|[
name|MIX_MAX_CHAN
index|]
decl_stmt|;
comment|/* using nchan */
name|uint32_t
name|delta
decl_stmt|;
name|uint32_t
name|mul
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|uint16_t
name|wData
index|[
name|MIX_MAX_CHAN
index|]
decl_stmt|;
comment|/* using nchan */
name|uint16_t
name|wIndex
decl_stmt|;
name|uint8_t
name|update
index|[
operator|(
name|MIX_MAX_CHAN
operator|+
literal|7
operator|)
operator|/
literal|8
index|]
decl_stmt|;
name|uint8_t
name|nchan
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
define|#
directive|define
name|MIX_ON_OFF
value|1
define|#
directive|define
name|MIX_SIGNED_16
value|2
define|#
directive|define
name|MIX_UNSIGNED_16
value|3
define|#
directive|define
name|MIX_SIGNED_8
value|4
define|#
directive|define
name|MIX_SELECTOR
value|5
define|#
directive|define
name|MIX_UNKNOWN
value|6
define|#
directive|define
name|MIX_SIZE
parameter_list|(
name|n
parameter_list|)
value|((((n) == MIX_SIGNED_16) || \ 		      ((n) == MIX_UNSIGNED_16)) ? 2 : 1)
define|#
directive|define
name|MIX_UNSIGNED
parameter_list|(
name|n
parameter_list|)
value|((n) == MIX_UNSIGNED_16)
define|#
directive|define
name|MAX_SELECTOR_INPUT_PIN
value|256
name|uint8_t
name|slctrtype
index|[
name|MAX_SELECTOR_INPUT_PIN
index|]
decl_stmt|;
name|uint8_t
name|class
decl_stmt|;
name|struct
name|uaudio_mixer_node
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uaudio_chan
block|{
name|struct
name|pcmchan_caps
name|pcm_cap
decl_stmt|;
comment|/* capabilities */
name|struct
name|snd_dbuf
modifier|*
name|pcm_buf
decl_stmt|;
specifier|const
name|struct
name|usb2_config
modifier|*
name|usb2_cfg
decl_stmt|;
name|struct
name|mtx
modifier|*
name|pcm_mtx
decl_stmt|;
comment|/* lock protecting this structure */
name|struct
name|uaudio_softc
modifier|*
name|priv_sc
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|pcm_ch
decl_stmt|;
name|struct
name|usb2_xfer
modifier|*
name|xfer
index|[
name|UAUDIO_NCHANBUFS
index|]
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_streaming_interface_descriptor
modifier|*
name|p_asid
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_streaming_type1_descriptor
modifier|*
name|p_asf1d
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_streaming_endpoint_descriptor
modifier|*
name|p_sed
decl_stmt|;
specifier|const
name|usb2_endpoint_descriptor_audio_t
modifier|*
name|p_ed1
decl_stmt|;
specifier|const
name|usb2_endpoint_descriptor_audio_t
modifier|*
name|p_ed2
decl_stmt|;
specifier|const
name|struct
name|uaudio_format
modifier|*
name|p_fmt
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
comment|/* pointer to buffer */
name|uint8_t
modifier|*
name|start
decl_stmt|;
comment|/* upper layer buffer start */
name|uint8_t
modifier|*
name|end
decl_stmt|;
comment|/* upper layer buffer end */
name|uint8_t
modifier|*
name|cur
decl_stmt|;
comment|/* current position in upper layer 					 * buffer */
name|uint32_t
name|intr_size
decl_stmt|;
comment|/* in bytes */
name|uint32_t
name|block_size
decl_stmt|;
name|uint32_t
name|sample_rate
decl_stmt|;
name|uint32_t
name|format
decl_stmt|;
name|uint32_t
name|pcm_format
index|[
literal|2
index|]
decl_stmt|;
name|uint16_t
name|bytes_per_frame
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
name|uint8_t
name|iface_index
decl_stmt|;
name|uint8_t
name|iface_alt_index
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|UMIDI_N_TRANSFER
value|4
end_define

begin_comment
comment|/* units */
end_comment

begin_define
define|#
directive|define
name|UMIDI_CABLES_MAX
value|16
end_define

begin_comment
comment|/* units */
end_comment

begin_define
define|#
directive|define
name|UMIDI_BULK_SIZE
value|1024
end_define

begin_comment
comment|/* bytes */
end_comment

begin_struct
struct|struct
name|umidi_sub_chan
block|{
name|struct
name|usb2_fifo_sc
name|fifo
decl_stmt|;
name|uint8_t
modifier|*
name|temp_cmd
decl_stmt|;
name|uint8_t
name|temp_0
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|temp_1
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|state
decl_stmt|;
define|#
directive|define
name|UMIDI_ST_UNKNOWN
value|0
comment|/* scan for command */
define|#
directive|define
name|UMIDI_ST_1PARAM
value|1
define|#
directive|define
name|UMIDI_ST_2PARAM_1
value|2
define|#
directive|define
name|UMIDI_ST_2PARAM_2
value|3
define|#
directive|define
name|UMIDI_ST_SYSEX_0
value|4
define|#
directive|define
name|UMIDI_ST_SYSEX_1
value|5
define|#
directive|define
name|UMIDI_ST_SYSEX_2
value|6
name|uint8_t
name|read_open
range|:
literal|1
decl_stmt|;
name|uint8_t
name|write_open
range|:
literal|1
decl_stmt|;
name|uint8_t
name|unused
range|:
literal|6
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|umidi_chan
block|{
name|struct
name|umidi_sub_chan
name|sub
index|[
name|UMIDI_CABLES_MAX
index|]
decl_stmt|;
name|struct
name|mtx
name|mtx
decl_stmt|;
name|struct
name|usb2_xfer
modifier|*
name|xfer
index|[
name|UMIDI_N_TRANSFER
index|]
decl_stmt|;
name|uint8_t
name|iface_index
decl_stmt|;
name|uint8_t
name|iface_alt_index
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|;
define|#
directive|define
name|UMIDI_FLAG_READ_STALL
value|0x01
define|#
directive|define
name|UMIDI_FLAG_WRITE_STALL
value|0x02
name|uint8_t
name|read_open_refcount
decl_stmt|;
name|uint8_t
name|write_open_refcount
decl_stmt|;
name|uint8_t
name|curr_cable
decl_stmt|;
name|uint8_t
name|max_cable
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uaudio_softc
block|{
name|struct
name|sbuf
name|sc_sndstat
decl_stmt|;
name|struct
name|sndcard_func
name|sc_sndcard_func
decl_stmt|;
name|struct
name|uaudio_chan
name|sc_rec_chan
decl_stmt|;
name|struct
name|uaudio_chan
name|sc_play_chan
decl_stmt|;
name|struct
name|umidi_chan
name|sc_midi_chan
decl_stmt|;
name|struct
name|usb2_device
modifier|*
name|sc_udev
decl_stmt|;
name|struct
name|usb2_xfer
modifier|*
name|sc_mixer_xfer
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|uaudio_mixer_node
modifier|*
name|sc_mixer_root
decl_stmt|;
name|struct
name|uaudio_mixer_node
modifier|*
name|sc_mixer_curr
decl_stmt|;
name|uint32_t
name|sc_mix_info
decl_stmt|;
name|uint32_t
name|sc_recsrc_info
decl_stmt|;
name|uint16_t
name|sc_audio_rev
decl_stmt|;
name|uint16_t
name|sc_mixer_count
decl_stmt|;
name|uint8_t
name|sc_sndstat_valid
decl_stmt|;
name|uint8_t
name|sc_mixer_iface_index
decl_stmt|;
name|uint8_t
name|sc_mixer_iface_no
decl_stmt|;
name|uint8_t
name|sc_mixer_chan
decl_stmt|;
name|uint8_t
name|sc_pcm_registered
range|:
literal|1
decl_stmt|;
name|uint8_t
name|sc_mixer_init
range|:
literal|1
decl_stmt|;
name|uint8_t
name|sc_uq_audio_swap_lr
range|:
literal|1
decl_stmt|;
name|uint8_t
name|sc_uq_au_inp_async
range|:
literal|1
decl_stmt|;
name|uint8_t
name|sc_uq_au_no_xu
range|:
literal|1
decl_stmt|;
name|uint8_t
name|sc_uq_bad_adc
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uaudio_search_result
block|{
name|uint8_t
name|bit_input
index|[
operator|(
literal|256
operator|+
literal|7
operator|)
operator|/
literal|8
index|]
decl_stmt|;
name|uint8_t
name|bit_output
index|[
operator|(
literal|256
operator|+
literal|7
operator|)
operator|/
literal|8
index|]
decl_stmt|;
name|uint8_t
name|bit_visited
index|[
operator|(
literal|256
operator|+
literal|7
operator|)
operator|/
literal|8
index|]
decl_stmt|;
name|uint8_t
name|recurse_level
decl_stmt|;
name|uint8_t
name|id_max
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uaudio_terminal_node
block|{
union|union
block|{
specifier|const
name|struct
name|usb2_descriptor
modifier|*
name|desc
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_input_terminal
modifier|*
name|it
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_output_terminal
modifier|*
name|ot
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_mixer_unit_0
modifier|*
name|mu
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_selector_unit
modifier|*
name|su
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_feature_unit
modifier|*
name|fu
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_processing_unit_0
modifier|*
name|pu
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_extension_unit_0
modifier|*
name|eu
decl_stmt|;
block|}
name|u
union|;
name|struct
name|uaudio_search_result
name|usr
decl_stmt|;
name|struct
name|uaudio_terminal_node
modifier|*
name|root
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uaudio_format
block|{
name|uint16_t
name|wFormat
decl_stmt|;
name|uint8_t
name|bPrecision
decl_stmt|;
name|uint32_t
name|freebsd_fmt
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|uaudio_format
name|uaudio_formats
index|[]
init|=
block|{
block|{
name|UA_FMT_PCM8
block|,
literal|8
block|,
name|AFMT_U8
block|,
literal|"8-bit U-LE PCM"
block|}
block|,
block|{
name|UA_FMT_PCM8
block|,
literal|16
block|,
name|AFMT_U16_LE
block|,
literal|"16-bit U-LE PCM"
block|}
block|,
block|{
name|UA_FMT_PCM8
block|,
literal|24
block|,
name|AFMT_U24_LE
block|,
literal|"24-bit U-LE PCM"
block|}
block|,
block|{
name|UA_FMT_PCM8
block|,
literal|32
block|,
name|AFMT_U32_LE
block|,
literal|"32-bit U-LE PCM"
block|}
block|,
block|{
name|UA_FMT_PCM
block|,
literal|8
block|,
name|AFMT_S8
block|,
literal|"8-bit S-LE PCM"
block|}
block|,
block|{
name|UA_FMT_PCM
block|,
literal|16
block|,
name|AFMT_S16_LE
block|,
literal|"16-bit S-LE PCM"
block|}
block|,
block|{
name|UA_FMT_PCM
block|,
literal|24
block|,
name|AFMT_S24_LE
block|,
literal|"24-bit S-LE PCM"
block|}
block|,
block|{
name|UA_FMT_PCM
block|,
literal|32
block|,
name|AFMT_S32_LE
block|,
literal|"32-bit S-LE PCM"
block|}
block|,
block|{
name|UA_FMT_ALAW
block|,
literal|8
block|,
name|AFMT_A_LAW
block|,
literal|"8-bit A-Law"
block|}
block|,
block|{
name|UA_FMT_MULAW
block|,
literal|8
block|,
name|AFMT_MU_LAW
block|,
literal|"8-bit mu-Law"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UAC_OUTPUT
value|0
end_define

begin_define
define|#
directive|define
name|UAC_INPUT
value|1
end_define

begin_define
define|#
directive|define
name|UAC_EQUAL
value|2
end_define

begin_define
define|#
directive|define
name|UAC_RECORD
value|3
end_define

begin_define
define|#
directive|define
name|UAC_NCLASSES
value|4
end_define

begin_if
if|#
directive|if
name|USB_DEBUG
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|uac_names
index|[]
init|=
block|{
literal|"outputs"
block|,
literal|"inputs"
block|,
literal|"equalization"
block|,
literal|"record"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* prototypes */
end_comment

begin_decl_stmt
specifier|static
name|device_probe_t
name|uaudio_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|uaudio_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_detach_t
name|uaudio_detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb2_callback_t
name|uaudio_chan_play_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb2_callback_t
name|uaudio_chan_record_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb2_callback_t
name|uaudio_mixer_write_cfg_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb2_callback_t
name|umidi_read_clear_stall_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb2_callback_t
name|umidi_bulk_read_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb2_callback_t
name|umidi_write_clear_stall_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb2_callback_t
name|umidi_bulk_write_callback
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|uaudio_chan_fill_info_sub
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|struct
name|usb2_device
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint16_t
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_chan_fill_info
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|struct
name|usb2_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_add_ctl_sub
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_add_ctl
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_add_input
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_add_output
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_add_mixer
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_add_selector
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|uaudio_mixer_feature_get_bmaControls
parameter_list|(
specifier|const
name|struct
name|usb2_audio_feature_unit
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_add_feature
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_add_processing_updown
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_add_processing
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_add_extension
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|usb2_audio_cluster
name|uaudio_mixer_get_cluster
parameter_list|(
name|uint8_t
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|uaudio_mixer_determine_class
parameter_list|(
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|uaudio_mixer_feature_name
parameter_list|(
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|uaudio_mixer_get_input
parameter_list|(
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|uaudio_mixer_get_output
parameter_list|(
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_find_inputs_sub
parameter_list|(
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|struct
name|uaudio_search_result
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_find_outputs_sub
parameter_list|(
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|struct
name|uaudio_search_result
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_fill_info
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|struct
name|usb2_device
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|uaudio_mixer_get
parameter_list|(
name|struct
name|usb2_device
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_ctl_set
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|int32_t
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb2_error_t
name|uaudio_set_speed
parameter_list|(
name|struct
name|usb2_device
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_mixer_signext
parameter_list|(
name|uint8_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_mixer_bsd2value
parameter_list|(
name|struct
name|uaudio_mixer_node
modifier|*
parameter_list|,
name|int32_t
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|void
modifier|*
name|uaudio_mixer_verify_desc
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_init
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|umidi_convert_to_usb
parameter_list|(
name|struct
name|umidi_sub_chan
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|umidi_sub_chan
modifier|*
name|umidi_sub_by_fifo
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umidi_start_read
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umidi_stop_read
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umidi_start_write
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umidi_stop_write
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|umidi_open
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|umidi_ioctl
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umidi_close
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umidi_init
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|umidi_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|umidi_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|USB_DEBUG
end_if

begin_function_decl
specifier|static
name|void
name|uaudio_chan_dump_ep_desc
parameter_list|(
specifier|const
name|usb2_endpoint_descriptor_audio_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_dump_cluster
parameter_list|(
name|uint8_t
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|uaudio_mixer_get_terminal_name
parameter_list|(
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb2_config
name|uaudio_cfg_record
index|[
name|UAUDIO_NCHANBUFS
index|]
init|=
block|{
index|[
literal|0
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_ISOCHRONOUS
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|mh
operator|.
name|bufsize
operator|=
literal|0
block|,
comment|/* use "wMaxPacketSize * frames" */
operator|.
name|mh
operator|.
name|frames
operator|=
name|UAUDIO_MINFRAMES
block|,
operator|.
name|mh
operator|.
name|flags
operator|=
block|{
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|mh
operator|.
name|callback
operator|=
operator|&
name|uaudio_chan_record_callback
block|, 	}
block|,
index|[
literal|1
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_ISOCHRONOUS
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|mh
operator|.
name|bufsize
operator|=
literal|0
block|,
comment|/* use "wMaxPacketSize * frames" */
operator|.
name|mh
operator|.
name|frames
operator|=
name|UAUDIO_MINFRAMES
block|,
operator|.
name|mh
operator|.
name|flags
operator|=
block|{
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|mh
operator|.
name|callback
operator|=
operator|&
name|uaudio_chan_record_callback
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb2_config
name|uaudio_cfg_play
index|[
name|UAUDIO_NCHANBUFS
index|]
init|=
block|{
index|[
literal|0
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_ISOCHRONOUS
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_OUT
block|,
operator|.
name|mh
operator|.
name|bufsize
operator|=
literal|0
block|,
comment|/* use "wMaxPacketSize * frames" */
operator|.
name|mh
operator|.
name|frames
operator|=
name|UAUDIO_MINFRAMES
block|,
operator|.
name|mh
operator|.
name|flags
operator|=
block|{
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|mh
operator|.
name|callback
operator|=
operator|&
name|uaudio_chan_play_callback
block|, 	}
block|,
index|[
literal|1
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_ISOCHRONOUS
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_OUT
block|,
operator|.
name|mh
operator|.
name|bufsize
operator|=
literal|0
block|,
comment|/* use "wMaxPacketSize * frames" */
operator|.
name|mh
operator|.
name|frames
operator|=
name|UAUDIO_MINFRAMES
block|,
operator|.
name|mh
operator|.
name|flags
operator|=
block|{
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|mh
operator|.
name|callback
operator|=
operator|&
name|uaudio_chan_play_callback
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb2_config
name|uaudio_mixer_config
index|[
literal|1
index|]
init|=
block|{
index|[
literal|0
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0x00
block|,
comment|/* Control pipe */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|mh
operator|.
name|bufsize
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|usb2_device_request
argument_list|)
operator|+
literal|4
operator|)
block|,
operator|.
name|mh
operator|.
name|callback
operator|=
operator|&
name|uaudio_mixer_write_cfg_callback
block|,
operator|.
name|mh
operator|.
name|timeout
operator|=
literal|1000
block|,
comment|/* 1 second */
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|umidi_cmd_to_len
index|[
literal|16
index|]
init|=
block|{
index|[
literal|0x0
index|]
operator|=
literal|0
block|,
comment|/* reserved */
index|[
literal|0x1
index|]
operator|=
literal|0
block|,
comment|/* reserved */
index|[
literal|0x2
index|]
operator|=
literal|2
block|,
comment|/* bytes */
index|[
literal|0x3
index|]
operator|=
literal|3
block|,
comment|/* bytes */
index|[
literal|0x4
index|]
operator|=
literal|3
block|,
comment|/* bytes */
index|[
literal|0x5
index|]
operator|=
literal|1
block|,
comment|/* bytes */
index|[
literal|0x6
index|]
operator|=
literal|2
block|,
comment|/* bytes */
index|[
literal|0x7
index|]
operator|=
literal|3
block|,
comment|/* bytes */
index|[
literal|0x8
index|]
operator|=
literal|3
block|,
comment|/* bytes */
index|[
literal|0x9
index|]
operator|=
literal|3
block|,
comment|/* bytes */
index|[
literal|0xA
index|]
operator|=
literal|3
block|,
comment|/* bytes */
index|[
literal|0xB
index|]
operator|=
literal|3
block|,
comment|/* bytes */
index|[
literal|0xC
index|]
operator|=
literal|2
block|,
comment|/* bytes */
index|[
literal|0xD
index|]
operator|=
literal|2
block|,
comment|/* bytes */
index|[
literal|0xE
index|]
operator|=
literal|3
block|,
comment|/* bytes */
index|[
literal|0xF
index|]
operator|=
literal|1
block|,
comment|/* bytes */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb2_config
name|umidi_config
index|[
name|UMIDI_N_TRANSFER
index|]
init|=
block|{
index|[
literal|0
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_OUT
block|,
operator|.
name|mh
operator|.
name|bufsize
operator|=
name|UMIDI_BULK_SIZE
block|,
operator|.
name|mh
operator|.
name|flags
operator|=
block|{
operator|.
name|pipe_bof
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|mh
operator|.
name|callback
operator|=
operator|&
name|umidi_bulk_write_callback
block|, 	}
block|,
index|[
literal|1
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|mh
operator|.
name|bufsize
operator|=
name|UMIDI_BULK_SIZE
block|,
operator|.
name|mh
operator|.
name|flags
operator|=
block|{
operator|.
name|pipe_bof
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|mh
operator|.
name|callback
operator|=
operator|&
name|umidi_bulk_read_callback
block|, 	}
block|,
index|[
literal|2
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0x00
block|,
comment|/* Control pipe */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|mh
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb2_device_request
argument_list|)
block|,
operator|.
name|mh
operator|.
name|flags
operator|=
block|{}
block|,
operator|.
name|mh
operator|.
name|callback
operator|=
operator|&
name|umidi_write_clear_stall_callback
block|,
operator|.
name|mh
operator|.
name|timeout
operator|=
literal|1000
block|,
comment|/* 1 second */
operator|.
name|mh
operator|.
name|interval
operator|=
literal|50
block|,
comment|/* 50ms */
block|}
block|,
index|[
literal|3
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0x00
block|,
comment|/* Control pipe */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|mh
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb2_device_request
argument_list|)
block|,
operator|.
name|mh
operator|.
name|flags
operator|=
block|{}
block|,
operator|.
name|mh
operator|.
name|callback
operator|=
operator|&
name|umidi_read_clear_stall_callback
block|,
operator|.
name|mh
operator|.
name|timeout
operator|=
literal|1000
block|,
comment|/* 1 second */
operator|.
name|mh
operator|.
name|interval
operator|=
literal|50
block|,
comment|/* 50ms */
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|uaudio_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|uaudio_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|uaudio_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|uaudio_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|uaudio_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|uaudio_driver
init|=
block|{
operator|.
name|name
operator|=
literal|"uaudio"
block|,
operator|.
name|methods
operator|=
name|uaudio_methods
block|,
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uaudio_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|uaudio_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb2_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|uaa
operator|->
name|usb2_mode
operator|!=
name|USB_MODE_HOST
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|uaa
operator|->
name|use_generic
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* trigger on the control interface */
if|if
condition|(
operator|(
name|uaa
operator|->
name|info
operator|.
name|bInterfaceClass
operator|==
name|UICLASS_AUDIO
operator|)
operator|&&
operator|(
name|uaa
operator|->
name|info
operator|.
name|bInterfaceSubClass
operator|==
name|UISUBCLASS_AUDIOCONTROL
operator|)
condition|)
block|{
if|if
condition|(
name|usb2_test_quirk
argument_list|(
name|uaa
argument_list|,
name|UQ_BAD_AUDIO
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb2_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb2_interface_descriptor
modifier|*
name|id
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|sc
operator|->
name|sc_play_chan
operator|.
name|priv_sc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_rec_chan
operator|.
name|priv_sc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_udev
operator|=
name|uaa
operator|->
name|device
expr_stmt|;
if|if
condition|(
name|usb2_test_quirk
argument_list|(
name|uaa
argument_list|,
name|UQ_AUDIO_SWAP_LR
argument_list|)
condition|)
name|sc
operator|->
name|sc_uq_audio_swap_lr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|usb2_test_quirk
argument_list|(
name|uaa
argument_list|,
name|UQ_AU_INP_ASYNC
argument_list|)
condition|)
name|sc
operator|->
name|sc_uq_au_inp_async
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|usb2_test_quirk
argument_list|(
name|uaa
argument_list|,
name|UQ_AU_NO_XU
argument_list|)
condition|)
name|sc
operator|->
name|sc_uq_au_no_xu
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|usb2_test_quirk
argument_list|(
name|uaa
argument_list|,
name|UQ_BAD_ADC
argument_list|)
condition|)
name|sc
operator|->
name|sc_uq_bad_adc
operator|=
literal|1
expr_stmt|;
name|umidi_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|device_set_usb2_desc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|id
operator|=
name|usb2_get_interface_descriptor
argument_list|(
name|uaa
operator|->
name|iface
argument_list|)
expr_stmt|;
name|uaudio_chan_fill_info
argument_list|(
name|sc
argument_list|,
name|uaa
operator|->
name|device
argument_list|)
expr_stmt|;
name|uaudio_mixer_fill_info
argument_list|(
name|sc
argument_list|,
name|uaa
operator|->
name|device
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mixer_iface_index
operator|=
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
expr_stmt|;
name|sc
operator|->
name|sc_mixer_iface_no
operator|=
name|uaa
operator|->
name|info
operator|.
name|bIfaceNum
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"audio rev %d.%02x\n"
argument_list|,
name|sc
operator|->
name|sc_audio_rev
operator|>>
literal|8
argument_list|,
name|sc
operator|->
name|sc_audio_rev
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%d mixer controls\n"
argument_list|,
name|sc
operator|->
name|sc_mixer_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_play_chan
operator|.
name|valid
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Play: %d Hz, %d ch, %s format\n"
argument_list|,
name|sc
operator|->
name|sc_play_chan
operator|.
name|sample_rate
argument_list|,
name|sc
operator|->
name|sc_play_chan
operator|.
name|p_asf1d
operator|->
name|bNrChannels
argument_list|,
name|sc
operator|->
name|sc_play_chan
operator|.
name|p_fmt
operator|->
name|description
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No playback!\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_rec_chan
operator|.
name|valid
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Record: %d Hz, %d ch, %s format\n"
argument_list|,
name|sc
operator|->
name|sc_rec_chan
operator|.
name|sample_rate
argument_list|,
name|sc
operator|->
name|sc_rec_chan
operator|.
name|p_asf1d
operator|->
name|bNrChannels
argument_list|,
name|sc
operator|->
name|sc_rec_chan
operator|.
name|p_fmt
operator|->
name|description
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No recording!\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_midi_chan
operator|.
name|valid
condition|)
block|{
if|if
condition|(
name|umidi_probe
argument_list|(
name|dev
argument_list|)
condition|)
block|{
goto|goto
name|detach
goto|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MIDI sequencer\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No midi sequencer\n"
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"doing child attach\n"
argument_list|)
expr_stmt|;
comment|/* attach the children */
name|sc
operator|->
name|sc_sndcard_func
operator|.
name|func
operator|=
name|SCF_PCM
expr_stmt|;
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pcm"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
name|device_set_ivars
argument_list|(
name|child
argument_list|,
operator|&
name|sc
operator|->
name|sc_sndcard_func
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"child attach failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
name|detach
label|:
name|uaudio_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_pcm_setflags
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|pcm_setflags
argument_list|(
name|dev
argument_list|,
name|pcm_getflags
argument_list|(
name|dev
argument_list|)
operator||
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|uaudio_attach_sub
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|kobj_class_t
name|mixer_class
parameter_list|,
name|kobj_class_t
name|chan_class
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
name|uaudio_mixer_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_uq_audio_swap_lr
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"hardware has swapped left and right\n"
argument_list|)
expr_stmt|;
name|uaudio_pcm_setflags
argument_list|(
name|dev
argument_list|,
name|SD_F_PSWAPLR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_mix_info
operator|&
name|SOUND_MASK_PCM
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"emulating master volume\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Emulate missing pcm mixer controller 		 * through FEEDER_VOLUME 		 */
name|uaudio_pcm_setflags
argument_list|(
name|dev
argument_list|,
name|SD_F_SOFTPCMVOL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mixer_init
argument_list|(
name|dev
argument_list|,
name|mixer_class
argument_list|,
name|sc
argument_list|)
condition|)
block|{
goto|goto
name|detach
goto|;
block|}
name|sc
operator|->
name|sc_mixer_init
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|,
literal|"at ? %s"
argument_list|,
name|PCM_KLDSTRING
argument_list|(
name|snd_uaudio
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sc_play_chan
operator|.
name|valid
condition|?
literal|1
else|:
literal|0
argument_list|,
name|sc
operator|->
name|sc_rec_chan
operator|.
name|valid
condition|?
literal|1
else|:
literal|0
argument_list|)
condition|)
block|{
goto|goto
name|detach
goto|;
block|}
name|sc
operator|->
name|sc_pcm_registered
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_play_chan
operator|.
name|valid
condition|)
block|{
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
name|chan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_rec_chan
operator|.
name|valid
condition|)
block|{
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
name|chan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
name|pcm_setstatus
argument_list|(
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
name|detach
label|:
name|uaudio_detach_sub
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_detach_sub
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|repeat
label|:
if|if
condition|(
name|sc
operator|->
name|sc_pcm_registered
condition|)
block|{
name|error
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_mixer_init
condition|)
block|{
name|error
operator|=
name|mixer_uninit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Waiting for sound application to exit!\n"
argument_list|)
expr_stmt|;
name|usb2_pause_mtx
argument_list|(
name|NULL
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
comment|/* try again */
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"detach failed!\n"
argument_list|)
expr_stmt|;
block|}
name|sbuf_delete
argument_list|(
operator|&
name|sc
operator|->
name|sc_sndstat
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sndstat_valid
operator|=
literal|0
expr_stmt|;
name|umidi_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*========================================================================*  * AS - Audio Stream - routines  *========================================================================*/
end_comment

begin_if
if|#
directive|if
name|USB_DEBUG
end_if

begin_function
specifier|static
name|void
name|uaudio_chan_dump_ep_desc
parameter_list|(
specifier|const
name|usb2_endpoint_descriptor_audio_t
modifier|*
name|ed
parameter_list|)
block|{
if|if
condition|(
name|ed
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"endpoint=%p bLength=%d bDescriptorType=%d \n"
literal|"bEndpointAddress=%d bmAttributes=0x%x \n"
literal|"wMaxPacketSize=%d bInterval=%d \n"
literal|"bRefresh=%d bSynchAddress=%d\n"
argument_list|,
name|ed
argument_list|,
name|ed
operator|->
name|bLength
argument_list|,
name|ed
operator|->
name|bDescriptorType
argument_list|,
name|ed
operator|->
name|bEndpointAddress
argument_list|,
name|ed
operator|->
name|bmAttributes
argument_list|,
name|UGETW
argument_list|(
name|ed
operator|->
name|wMaxPacketSize
argument_list|)
argument_list|,
name|ed
operator|->
name|bInterval
argument_list|,
name|ed
operator|->
name|bRefresh
argument_list|,
name|ed
operator|->
name|bSynchAddress
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|uaudio_chan_fill_info_sub
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint32_t
name|rate
parameter_list|,
name|uint16_t
name|fps
parameter_list|,
name|uint8_t
name|channels
parameter_list|,
name|uint8_t
name|bit_resolution
parameter_list|)
block|{
name|struct
name|usb2_descriptor
modifier|*
name|desc
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_streaming_interface_descriptor
modifier|*
name|asid
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_streaming_type1_descriptor
modifier|*
name|asf1d
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_streaming_endpoint_descriptor
modifier|*
name|sed
init|=
name|NULL
decl_stmt|;
specifier|const
name|usb2_endpoint_descriptor_audio_t
modifier|*
name|ed1
init|=
name|NULL
decl_stmt|;
specifier|const
name|usb2_endpoint_descriptor_audio_t
modifier|*
name|ed2
init|=
name|NULL
decl_stmt|;
name|struct
name|usb2_config_descriptor
modifier|*
name|cd
init|=
name|usb2_get_config_descriptor
argument_list|(
name|udev
argument_list|)
decl_stmt|;
name|struct
name|usb2_interface_descriptor
modifier|*
name|id
decl_stmt|;
specifier|const
name|struct
name|uaudio_format
modifier|*
name|p_fmt
decl_stmt|;
name|struct
name|uaudio_chan
modifier|*
name|chan
decl_stmt|;
name|uint16_t
name|curidx
init|=
literal|0xFFFF
decl_stmt|;
name|uint16_t
name|lastidx
init|=
literal|0xFFFF
decl_stmt|;
name|uint16_t
name|alt_index
init|=
literal|0
decl_stmt|;
name|uint16_t
name|wFormat
decl_stmt|;
name|uint8_t
name|ep_dir
decl_stmt|;
name|uint8_t
name|ep_type
decl_stmt|;
name|uint8_t
name|ep_sync
decl_stmt|;
name|uint8_t
name|bChannels
decl_stmt|;
name|uint8_t
name|bBitResolution
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
name|uint8_t
name|audio_if
init|=
literal|0
decl_stmt|;
name|uint8_t
name|sample_size
decl_stmt|;
while|while
condition|(
operator|(
name|desc
operator|=
name|usb2_desc_foreach
argument_list|(
name|cd
argument_list|,
name|desc
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|desc
operator|->
name|bDescriptorType
operator|==
name|UDESC_INTERFACE
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bLength
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
operator|)
condition|)
block|{
name|id
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|bInterfaceNumber
operator|!=
name|lastidx
condition|)
block|{
name|lastidx
operator|=
name|id
operator|->
name|bInterfaceNumber
expr_stmt|;
name|curidx
operator|++
expr_stmt|;
name|alt_index
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|alt_index
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|id
operator|->
name|bInterfaceClass
operator|==
name|UICLASS_AUDIO
operator|)
operator|&&
operator|(
name|id
operator|->
name|bInterfaceSubClass
operator|==
name|UISUBCLASS_AUDIOSTREAM
operator|)
condition|)
block|{
name|audio_if
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|audio_if
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|id
operator|->
name|bInterfaceClass
operator|==
name|UICLASS_AUDIO
operator|)
operator|&&
operator|(
name|id
operator|->
name|bInterfaceSubClass
operator|==
name|UISUBCLASS_MIDISTREAM
operator|)
condition|)
block|{
comment|/* 				 * XXX could allow multiple MIDI interfaces 				 * XXX 				 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_midi_chan
operator|.
name|valid
operator|==
literal|0
operator|)
operator|&&
name|usb2_get_iface
argument_list|(
name|udev
argument_list|,
name|curidx
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_midi_chan
operator|.
name|iface_index
operator|=
name|curidx
expr_stmt|;
name|sc
operator|->
name|sc_midi_chan
operator|.
name|iface_alt_index
operator|=
name|alt_index
expr_stmt|;
name|sc
operator|->
name|sc_midi_chan
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|asid
operator|=
name|NULL
expr_stmt|;
name|asf1d
operator|=
name|NULL
expr_stmt|;
name|ed1
operator|=
name|NULL
expr_stmt|;
name|ed2
operator|=
name|NULL
expr_stmt|;
name|sed
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|desc
operator|->
name|bDescriptorType
operator|==
name|UDESC_CS_INTERFACE
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bDescriptorSubtype
operator|==
name|AS_GENERAL
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bLength
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|asid
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|asid
operator|==
name|NULL
condition|)
block|{
name|asid
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|desc
operator|->
name|bDescriptorType
operator|==
name|UDESC_CS_INTERFACE
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bDescriptorSubtype
operator|==
name|FORMAT_TYPE
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bLength
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|asf1d
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|asf1d
operator|==
name|NULL
condition|)
block|{
name|asf1d
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
if|if
condition|(
name|asf1d
operator|->
name|bFormatType
operator|!=
name|FORMAT_TYPE_I
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"ignored bFormatType = %d\n"
argument_list|,
name|asf1d
operator|->
name|bFormatType
argument_list|)
expr_stmt|;
name|asf1d
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|asf1d
operator|->
name|bLength
operator|<
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|asf1d
argument_list|)
operator|+
operator|(
name|asf1d
operator|->
name|bSamFreqType
operator|==
literal|0
operator|)
condition|?
literal|6
else|:
operator|(
name|asf1d
operator|->
name|bSamFreqType
operator|*
literal|3
operator|)
operator|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"'asf1d' descriptor is too short\n"
argument_list|)
expr_stmt|;
name|asf1d
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|desc
operator|->
name|bDescriptorType
operator|==
name|UDESC_ENDPOINT
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bLength
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|ed1
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ed1
operator|==
name|NULL
condition|)
block|{
name|ed1
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
if|if
condition|(
name|UE_GET_XFERTYPE
argument_list|(
name|ed1
operator|->
name|bmAttributes
argument_list|)
operator|!=
name|UE_ISOCHRONOUS
condition|)
block|{
name|ed1
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ed2
operator|==
name|NULL
condition|)
block|{
name|ed2
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
if|if
condition|(
name|UE_GET_XFERTYPE
argument_list|(
name|ed2
operator|->
name|bmAttributes
argument_list|)
operator|!=
name|UE_ISOCHRONOUS
condition|)
block|{
name|ed2
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ed2
operator|->
name|bSynchAddress
operator|!=
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"invalid endpoint: bSynchAddress != 0\n"
argument_list|)
expr_stmt|;
name|ed2
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ed2
operator|->
name|bEndpointAddress
operator|!=
name|ed1
operator|->
name|bSynchAddress
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"invalid endpoint addresses: "
literal|"ep[0]->bSynchAddress=0x%x "
literal|"ep[1]->bEndpointAddress=0x%x\n"
argument_list|,
name|ed1
operator|->
name|bSynchAddress
argument_list|,
name|ed2
operator|->
name|bEndpointAddress
argument_list|)
expr_stmt|;
name|ed2
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|desc
operator|->
name|bDescriptorType
operator|==
name|UDESC_CS_ENDPOINT
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bDescriptorSubtype
operator|==
name|AS_GENERAL
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bLength
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|sed
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|sed
operator|==
name|NULL
condition|)
block|{
name|sed
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
block|}
block|}
if|if
condition|(
name|audio_if
operator|&&
name|asid
operator|&&
name|asf1d
operator|&&
name|ed1
operator|&&
name|sed
condition|)
block|{
name|ep_dir
operator|=
name|UE_GET_DIR
argument_list|(
name|ed1
operator|->
name|bEndpointAddress
argument_list|)
expr_stmt|;
name|ep_type
operator|=
name|UE_GET_ISO_TYPE
argument_list|(
name|ed1
operator|->
name|bmAttributes
argument_list|)
expr_stmt|;
name|ep_sync
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_uq_au_inp_async
operator|)
operator|&&
operator|(
name|ep_dir
operator|==
name|UE_DIR_IN
operator|)
operator|&&
operator|(
name|ep_type
operator|==
name|UE_ISO_ADAPT
operator|)
condition|)
block|{
name|ep_type
operator|=
name|UE_ISO_ASYNC
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ep_dir
operator|==
name|UE_DIR_IN
operator|)
operator|&&
operator|(
name|ep_type
operator|==
name|UE_ISO_ADAPT
operator|)
condition|)
block|{
name|ep_sync
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ep_dir
operator|!=
name|UE_DIR_IN
operator|)
operator|&&
operator|(
name|ep_type
operator|==
name|UE_ISO_ASYNC
operator|)
condition|)
block|{
name|ep_sync
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Ignore sync endpoint information until further. */
if|#
directive|if
literal|0
block|if (ep_sync&& (!ed2)) { 				continue; 			}
comment|/* 			 * we can't handle endpoints that need a sync pipe 			 * yet 			 */
block|if (ep_sync) { 				DPRINTF("skipped sync interface\n"); 				audio_if = 0; 				continue; 			}
endif|#
directive|endif
name|wFormat
operator|=
name|UGETW
argument_list|(
name|asid
operator|->
name|wFormatTag
argument_list|)
expr_stmt|;
name|bChannels
operator|=
name|asf1d
operator|->
name|bNrChannels
expr_stmt|;
name|bBitResolution
operator|=
name|asf1d
operator|->
name|bBitResolution
expr_stmt|;
if|if
condition|(
name|asf1d
operator|->
name|bSamFreqType
operator|==
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|16
argument_list|,
literal|"Sample rate: %d-%dHz\n"
argument_list|,
name|UA_SAMP_LO
argument_list|(
name|asf1d
argument_list|)
argument_list|,
name|UA_SAMP_HI
argument_list|(
name|asf1d
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rate
operator|>=
name|UA_SAMP_LO
argument_list|(
name|asf1d
argument_list|)
operator|)
operator|&&
operator|(
name|rate
operator|<=
name|UA_SAMP_HI
argument_list|(
name|asf1d
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|found_rate
goto|;
block|}
block|}
else|else
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|asf1d
operator|->
name|bSamFreqType
condition|;
name|x
operator|++
control|)
block|{
name|DPRINTFN
argument_list|(
literal|16
argument_list|,
literal|"Sample rate = %dHz\n"
argument_list|,
name|UA_GETSAMP
argument_list|(
name|asf1d
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rate
operator|==
name|UA_GETSAMP
argument_list|(
name|asf1d
argument_list|,
name|x
argument_list|)
condition|)
block|{
goto|goto
name|found_rate
goto|;
block|}
block|}
block|}
name|audio_if
operator|=
literal|0
expr_stmt|;
continue|continue;
name|found_rate
label|:
for|for
control|(
name|p_fmt
operator|=
name|uaudio_formats
init|;
name|p_fmt
operator|->
name|wFormat
condition|;
name|p_fmt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p_fmt
operator|->
name|wFormat
operator|==
name|wFormat
operator|)
operator|&&
operator|(
name|p_fmt
operator|->
name|bPrecision
operator|==
name|bBitResolution
operator|)
condition|)
block|{
goto|goto
name|found_format
goto|;
block|}
block|}
name|audio_if
operator|=
literal|0
expr_stmt|;
continue|continue;
name|found_format
label|:
if|if
condition|(
operator|(
name|bChannels
operator|==
name|channels
operator|)
operator|&&
operator|(
name|bBitResolution
operator|==
name|bit_resolution
operator|)
condition|)
block|{
name|chan
operator|=
operator|(
name|ep_dir
operator|==
name|UE_DIR_IN
operator|)
condition|?
operator|&
name|sc
operator|->
name|sc_rec_chan
else|:
operator|&
name|sc
operator|->
name|sc_play_chan
expr_stmt|;
if|if
condition|(
operator|(
name|chan
operator|->
name|valid
operator|==
literal|0
operator|)
operator|&&
name|usb2_get_iface
argument_list|(
name|udev
argument_list|,
name|curidx
argument_list|)
condition|)
block|{
name|chan
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
name|uaudio_chan_dump_ep_desc
argument_list|(
name|ed1
argument_list|)
expr_stmt|;
name|uaudio_chan_dump_ep_desc
argument_list|(
name|ed2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sed
operator|->
name|bmAttributes
operator|&
name|UA_SED_FREQ_CONTROL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"FREQ_CONTROL\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sed
operator|->
name|bmAttributes
operator|&
name|UA_SED_PITCH_CONTROL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"PITCH_CONTROL\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|DPRINTF
argument_list|(
literal|"Sample rate = %dHz, channels = %d, "
literal|"bits = %d, format = %s\n"
argument_list|,
name|rate
argument_list|,
name|channels
argument_list|,
name|bit_resolution
argument_list|,
name|p_fmt
operator|->
name|description
argument_list|)
expr_stmt|;
name|chan
operator|->
name|sample_rate
operator|=
name|rate
expr_stmt|;
name|chan
operator|->
name|p_asid
operator|=
name|asid
expr_stmt|;
name|chan
operator|->
name|p_asf1d
operator|=
name|asf1d
expr_stmt|;
name|chan
operator|->
name|p_ed1
operator|=
name|ed1
expr_stmt|;
name|chan
operator|->
name|p_ed2
operator|=
name|ed2
expr_stmt|;
name|chan
operator|->
name|p_fmt
operator|=
name|p_fmt
expr_stmt|;
name|chan
operator|->
name|p_sed
operator|=
name|sed
expr_stmt|;
name|chan
operator|->
name|iface_index
operator|=
name|curidx
expr_stmt|;
name|chan
operator|->
name|iface_alt_index
operator|=
name|alt_index
expr_stmt|;
if|if
condition|(
name|ep_dir
operator|==
name|UE_DIR_IN
condition|)
name|chan
operator|->
name|usb2_cfg
operator|=
name|uaudio_cfg_record
expr_stmt|;
else|else
name|chan
operator|->
name|usb2_cfg
operator|=
name|uaudio_cfg_play
expr_stmt|;
name|sample_size
operator|=
operator|(
operator|(
name|chan
operator|->
name|p_asf1d
operator|->
name|bNrChannels
operator|*
name|chan
operator|->
name|p_asf1d
operator|->
name|bBitResolution
operator|)
operator|/
literal|8
operator|)
expr_stmt|;
comment|/* 					 * NOTE: "chan->bytes_per_frame" 					 * should not be zero! 					 */
name|chan
operator|->
name|bytes_per_frame
operator|=
operator|(
operator|(
name|rate
operator|/
name|fps
operator|)
operator|*
name|sample_size
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_sndstat_valid
condition|)
block|{
name|sbuf_printf
argument_list|(
operator|&
name|sc
operator|->
name|sc_sndstat
argument_list|,
literal|"\n\t"
literal|"mode %d.%d:(%s) %dch, %d/%dbit, %s, %dHz"
argument_list|,
name|curidx
argument_list|,
name|alt_index
argument_list|,
operator|(
name|ep_dir
operator|==
name|UE_DIR_IN
operator|)
condition|?
literal|"input"
else|:
literal|"output"
argument_list|,
name|asf1d
operator|->
name|bNrChannels
argument_list|,
name|asf1d
operator|->
name|bBitResolution
argument_list|,
name|asf1d
operator|->
name|bSubFrameSize
operator|*
literal|8
argument_list|,
name|p_fmt
operator|->
name|description
argument_list|,
name|rate
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|audio_if
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_chan_fill_info
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|)
block|{
name|uint32_t
name|rate
init|=
name|uaudio_default_rate
decl_stmt|;
name|uint32_t
name|z
decl_stmt|;
name|uint16_t
name|fps
init|=
name|usb2_get_isoc_fps
argument_list|(
name|udev
argument_list|)
decl_stmt|;
name|uint8_t
name|bits
init|=
name|uaudio_default_bits
decl_stmt|;
name|uint8_t
name|y
decl_stmt|;
name|uint8_t
name|channels
init|=
name|uaudio_default_channels
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
name|bits
operator|-=
operator|(
name|bits
operator|%
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bits
operator|==
literal|0
operator|)
operator|||
operator|(
name|bits
operator|>
literal|32
operator|)
condition|)
block|{
comment|/* set a valid value */
name|bits
operator|=
literal|32
expr_stmt|;
block|}
name|rate
operator|-=
operator|(
name|rate
operator|%
name|fps
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|rate
operator|==
literal|0
operator|)
operator|||
operator|(
name|rate
operator|>
literal|192000
operator|)
condition|)
block|{
comment|/* set a valid value */
name|rate
operator|=
literal|192000
operator|-
operator|(
literal|192000
operator|%
name|fps
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|channels
operator|==
literal|0
operator|)
operator|||
operator|(
name|channels
operator|>
literal|2
operator|)
condition|)
block|{
comment|/* set a valid value */
name|channels
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|sbuf_new
argument_list|(
operator|&
name|sc
operator|->
name|sc_sndstat
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|SBUF_AUTOEXTEND
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_sndstat_valid
operator|=
literal|1
expr_stmt|;
block|}
comment|/* try to search for a valid config */
for|for
control|(
name|x
operator|=
name|channels
init|;
name|x
condition|;
name|x
operator|--
control|)
block|{
for|for
control|(
name|y
operator|=
name|bits
init|;
name|y
condition|;
name|y
operator|-=
literal|8
control|)
block|{
for|for
control|(
name|z
operator|=
name|rate
init|;
name|z
condition|;
name|z
operator|-=
name|fps
control|)
block|{
name|uaudio_chan_fill_info_sub
argument_list|(
name|sc
argument_list|,
name|udev
argument_list|,
name|z
argument_list|,
name|fps
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rec_chan
operator|.
name|valid
operator|&&
name|sc
operator|->
name|sc_play_chan
operator|.
name|valid
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
block|}
block|}
name|done
label|:
if|if
condition|(
name|sc
operator|->
name|sc_sndstat_valid
condition|)
block|{
name|sbuf_finish
argument_list|(
operator|&
name|sc
operator|->
name|sc_sndstat
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_chan_play_callback
parameter_list|(
name|struct
name|usb2_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|uaudio_chan
modifier|*
name|ch
init|=
name|xfer
operator|->
name|priv_sc
decl_stmt|;
name|uint32_t
modifier|*
name|p_len
init|=
name|xfer
operator|->
name|frlengths
decl_stmt|;
name|uint32_t
name|total
decl_stmt|;
name|uint32_t
name|blockcount
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
comment|/* allow dynamic sizing of play buffer */
name|total
operator|=
name|ch
operator|->
name|intr_size
expr_stmt|;
comment|/* allow dynamic sizing of play buffer */
name|blockcount
operator|=
name|total
operator|/
name|ch
operator|->
name|bytes_per_frame
expr_stmt|;
comment|/* align units */
name|blockcount
operator|-=
operator|(
name|blockcount
operator|%
name|UAUDIO_MINFRAMES
operator|)
expr_stmt|;
comment|/* range check - min */
if|if
condition|(
name|blockcount
operator|==
literal|0
condition|)
block|{
name|blockcount
operator|=
name|UAUDIO_MINFRAMES
expr_stmt|;
block|}
comment|/* range check - max */
if|if
condition|(
name|blockcount
operator|>
name|xfer
operator|->
name|max_frame_count
condition|)
block|{
name|blockcount
operator|=
name|xfer
operator|->
name|max_frame_count
expr_stmt|;
block|}
comment|/* compute the total length */
name|total
operator|=
name|blockcount
operator|*
name|ch
operator|->
name|bytes_per_frame
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|tr_transferred
label|:
if|if
condition|(
name|xfer
operator|->
name|actlen
operator|<
name|xfer
operator|->
name|sumlen
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"short transfer, "
literal|"%d of %d bytes\n"
argument_list|,
name|xfer
operator|->
name|actlen
argument_list|,
name|total
argument_list|)
expr_stmt|;
block|}
name|chn_intr
argument_list|(
name|ch
operator|->
name|pcm_ch
argument_list|)
expr_stmt|;
case|case
name|USB_ST_SETUP
case|:
if|if
condition|(
name|ch
operator|->
name|bytes_per_frame
operator|>
name|xfer
operator|->
name|max_frame_size
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"bytes per transfer, %d, "
literal|"exceeds maximum, %d!\n"
argument_list|,
name|ch
operator|->
name|bytes_per_frame
argument_list|,
name|xfer
operator|->
name|max_frame_size
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* setup frame length */
name|xfer
operator|->
name|nframes
operator|=
name|blockcount
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|blockcount
condition|;
name|n
operator|++
control|)
block|{
name|p_len
index|[
name|n
index|]
operator|=
name|ch
operator|->
name|bytes_per_frame
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|end
operator|==
name|ch
operator|->
name|start
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"no buffer!\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"transfer %d bytes\n"
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|total
operator|>
literal|0
condition|)
block|{
name|n
operator|=
operator|(
name|ch
operator|->
name|end
operator|-
name|ch
operator|->
name|cur
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|total
condition|)
block|{
name|n
operator|=
name|total
expr_stmt|;
block|}
name|usb2_copy_in
argument_list|(
name|xfer
operator|->
name|frbuffers
argument_list|,
name|offset
argument_list|,
name|ch
operator|->
name|cur
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|total
operator|-=
name|n
expr_stmt|;
name|ch
operator|->
name|cur
operator|+=
name|n
expr_stmt|;
name|offset
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|cur
operator|>=
name|ch
operator|->
name|end
condition|)
block|{
name|ch
operator|->
name|cur
operator|=
name|ch
operator|->
name|start
expr_stmt|;
block|}
block|}
name|usb2_start_hardware
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Error */
if|if
condition|(
name|xfer
operator|->
name|error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
break|break;
block|}
goto|goto
name|tr_transferred
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_chan_record_callback
parameter_list|(
name|struct
name|usb2_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|uaudio_chan
modifier|*
name|ch
init|=
name|xfer
operator|->
name|priv_sc
decl_stmt|;
name|uint32_t
modifier|*
name|p_len
init|=
name|xfer
operator|->
name|frlengths
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
name|uint32_t
name|m
decl_stmt|;
name|uint32_t
name|total
decl_stmt|;
name|uint32_t
name|blockcount
decl_stmt|;
name|uint32_t
name|offset0
decl_stmt|;
name|uint32_t
name|offset1
decl_stmt|;
comment|/* allow dynamic sizing of play buffer */
name|total
operator|=
name|ch
operator|->
name|intr_size
expr_stmt|;
comment|/* allow dynamic sizing of play buffer */
name|blockcount
operator|=
name|total
operator|/
name|ch
operator|->
name|bytes_per_frame
expr_stmt|;
comment|/* align units */
name|blockcount
operator|-=
operator|(
name|blockcount
operator|%
name|UAUDIO_MINFRAMES
operator|)
expr_stmt|;
comment|/* range check - min */
if|if
condition|(
name|blockcount
operator|==
literal|0
condition|)
block|{
name|blockcount
operator|=
name|UAUDIO_MINFRAMES
expr_stmt|;
block|}
comment|/* range check - max */
if|if
condition|(
name|blockcount
operator|>
name|xfer
operator|->
name|max_frame_count
condition|)
block|{
name|blockcount
operator|=
name|xfer
operator|->
name|max_frame_count
expr_stmt|;
block|}
comment|/* compute the total length */
name|total
operator|=
name|blockcount
operator|*
name|ch
operator|->
name|bytes_per_frame
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|tr_transferred
label|:
if|if
condition|(
name|xfer
operator|->
name|actlen
operator|<
name|total
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"short transfer, "
literal|"%d of %d bytes\n"
argument_list|,
name|xfer
operator|->
name|actlen
argument_list|,
name|total
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"transferred %d bytes\n"
argument_list|,
name|xfer
operator|->
name|actlen
argument_list|)
expr_stmt|;
block|}
name|offset0
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|xfer
operator|->
name|nframes
condition|;
name|n
operator|++
control|)
block|{
name|offset1
operator|=
name|offset0
expr_stmt|;
while|while
condition|(
name|p_len
index|[
name|n
index|]
operator|>
literal|0
condition|)
block|{
name|m
operator|=
operator|(
name|ch
operator|->
name|end
operator|-
name|ch
operator|->
name|cur
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|>
name|p_len
index|[
name|n
index|]
condition|)
block|{
name|m
operator|=
name|p_len
index|[
name|n
index|]
expr_stmt|;
block|}
name|usb2_copy_out
argument_list|(
name|xfer
operator|->
name|frbuffers
argument_list|,
name|offset1
argument_list|,
name|ch
operator|->
name|cur
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|p_len
index|[
name|n
index|]
operator|-=
name|m
expr_stmt|;
name|offset1
operator|+=
name|m
expr_stmt|;
name|ch
operator|->
name|cur
operator|+=
name|m
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|cur
operator|>=
name|ch
operator|->
name|end
condition|)
block|{
name|ch
operator|->
name|cur
operator|=
name|ch
operator|->
name|start
expr_stmt|;
block|}
block|}
name|offset0
operator|+=
name|ch
operator|->
name|bytes_per_frame
expr_stmt|;
block|}
name|chn_intr
argument_list|(
name|ch
operator|->
name|pcm_ch
argument_list|)
expr_stmt|;
case|case
name|USB_ST_SETUP
case|:
if|if
condition|(
name|ch
operator|->
name|bytes_per_frame
operator|>
name|xfer
operator|->
name|max_frame_size
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"bytes per transfer, %d, "
literal|"exceeds maximum, %d!\n"
argument_list|,
name|ch
operator|->
name|bytes_per_frame
argument_list|,
name|xfer
operator|->
name|max_frame_size
argument_list|)
expr_stmt|;
return|return;
block|}
name|xfer
operator|->
name|nframes
operator|=
name|blockcount
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|xfer
operator|->
name|nframes
condition|;
name|n
operator|++
control|)
block|{
name|p_len
index|[
name|n
index|]
operator|=
name|ch
operator|->
name|bytes_per_frame
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|end
operator|==
name|ch
operator|->
name|start
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"no buffer!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|usb2_start_hardware
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* Error */
if|if
condition|(
name|xfer
operator|->
name|error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
return|return;
block|}
goto|goto
name|tr_transferred
goto|;
block|}
block|}
end_function

begin_function
name|void
modifier|*
name|uaudio_chan_init
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|uaudio_chan
modifier|*
name|ch
init|=
operator|(
operator|(
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
operator|&
name|sc
operator|->
name|sc_play_chan
else|:
operator|&
name|sc
operator|->
name|sc_rec_chan
operator|)
decl_stmt|;
name|uint32_t
name|buf_size
decl_stmt|;
name|uint8_t
name|endpoint
decl_stmt|;
name|uint8_t
name|iface_index
decl_stmt|;
name|uint8_t
name|alt_index
decl_stmt|;
name|usb2_error_t
name|err
decl_stmt|;
comment|/* compute required buffer size */
name|buf_size
operator|=
operator|(
name|ch
operator|->
name|bytes_per_frame
operator|*
name|UAUDIO_MINFRAMES
operator|)
expr_stmt|;
comment|/* setup interrupt interval */
name|ch
operator|->
name|intr_size
operator|=
name|buf_size
expr_stmt|;
comment|/* double buffering */
name|buf_size
operator|*=
literal|2
expr_stmt|;
name|ch
operator|->
name|buf
operator|=
name|malloc
argument_list|(
name|buf_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|sndbuf_setup
argument_list|(
name|b
argument_list|,
name|ch
operator|->
name|buf
argument_list|,
name|buf_size
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|ch
operator|->
name|start
operator|=
name|ch
operator|->
name|buf
expr_stmt|;
name|ch
operator|->
name|end
operator|=
name|ch
operator|->
name|buf
operator|+
name|buf_size
expr_stmt|;
name|ch
operator|->
name|cur
operator|=
name|ch
operator|->
name|buf
expr_stmt|;
name|ch
operator|->
name|pcm_ch
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|pcm_mtx
operator|=
name|c
operator|->
name|lock
expr_stmt|;
name|ch
operator|->
name|pcm_buf
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|pcm_mtx
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"ERROR: PCM channels does not have a mutex!\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* setup play/record format */
name|ch
operator|->
name|pcm_cap
operator|.
name|fmtlist
operator|=
name|ch
operator|->
name|pcm_format
expr_stmt|;
name|ch
operator|->
name|pcm_format
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|pcm_format
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|pcm_cap
operator|.
name|minspeed
operator|=
name|ch
operator|->
name|sample_rate
expr_stmt|;
name|ch
operator|->
name|pcm_cap
operator|.
name|maxspeed
operator|=
name|ch
operator|->
name|sample_rate
expr_stmt|;
name|ch
operator|->
name|pcm_cap
operator|.
name|fmtlist
index|[
literal|0
index|]
operator|=
name|ch
operator|->
name|p_fmt
operator|->
name|freebsd_fmt
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|p_asf1d
operator|->
name|bNrChannels
operator|==
literal|2
condition|)
block|{
name|ch
operator|->
name|pcm_cap
operator|.
name|fmtlist
index|[
literal|0
index|]
operator||=
name|AFMT_STEREO
expr_stmt|;
block|}
name|ch
operator|->
name|pcm_cap
operator|.
name|fmtlist
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* set alternate interface corresponding to the mode */
name|endpoint
operator|=
name|ch
operator|->
name|p_ed1
operator|->
name|bEndpointAddress
expr_stmt|;
name|iface_index
operator|=
name|ch
operator|->
name|iface_index
expr_stmt|;
name|alt_index
operator|=
name|ch
operator|->
name|iface_alt_index
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"endpoint=0x%02x, speed=%d, iface=%d alt=%d\n"
argument_list|,
name|endpoint
argument_list|,
name|ch
operator|->
name|sample_rate
argument_list|,
name|iface_index
argument_list|,
name|alt_index
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb2_set_alt_interface_index
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|iface_index
argument_list|,
name|alt_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"setting of alternate index failed: %s!\n"
argument_list|,
name|usb2_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|usb2_set_parent_iface
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|iface_index
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_index
argument_list|)
expr_stmt|;
comment|/* 	 * If just one sampling rate is supported, 	 * no need to call "uaudio_set_speed()". 	 * Roland SD-90 freezes by a SAMPLING_FREQ_CONTROL request. 	 */
if|if
condition|(
name|ch
operator|->
name|p_asf1d
operator|->
name|bSamFreqType
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|uaudio_set_speed
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|endpoint
argument_list|,
name|ch
operator|->
name|sample_rate
argument_list|)
condition|)
block|{
comment|/* 			 * If the endpoint is adaptive setting the speed may 			 * fail. 			 */
name|DPRINTF
argument_list|(
literal|"setting of sample rate failed! (continuing anyway)\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|usb2_transfer_setup
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|iface_index
argument_list|,
name|ch
operator|->
name|xfer
argument_list|,
name|ch
operator|->
name|usb2_cfg
argument_list|,
name|UAUDIO_NCHANBUFS
argument_list|,
name|ch
argument_list|,
name|ch
operator|->
name|pcm_mtx
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"could not allocate USB transfers!\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
return|return
operator|(
name|ch
operator|)
return|;
name|error
label|:
name|uaudio_chan_free
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_chan_free
parameter_list|(
name|struct
name|uaudio_chan
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ch
operator|->
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ch
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
name|usb2_transfer_unsetup
argument_list|(
name|ch
operator|->
name|xfer
argument_list|,
name|UAUDIO_NCHANBUFS
argument_list|)
expr_stmt|;
name|ch
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_chan_set_param_blocksize
parameter_list|(
name|struct
name|uaudio_chan
modifier|*
name|ch
parameter_list|,
name|uint32_t
name|blocksize
parameter_list|)
block|{
name|uaudio_chan_set_param_fragments
argument_list|(
name|ch
argument_list|,
name|blocksize
argument_list|,
literal|0
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ch
operator|->
name|block_size
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_chan_set_param_fragments
parameter_list|(
name|struct
name|uaudio_chan
modifier|*
name|ch
parameter_list|,
name|uint32_t
name|blocksize
parameter_list|,
name|uint32_t
name|blockcount
parameter_list|)
block|{
comment|/* we only support one size */
name|blocksize
operator|=
name|ch
operator|->
name|intr_size
expr_stmt|;
name|blockcount
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|sndbuf_getblksz
argument_list|(
name|ch
operator|->
name|pcm_buf
argument_list|)
operator|!=
name|blocksize
operator|)
operator|||
operator|(
name|sndbuf_getblkcnt
argument_list|(
name|ch
operator|->
name|pcm_buf
argument_list|)
operator|!=
name|blockcount
operator|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
literal|"resizing to %u x "
literal|"%u bytes\n"
argument_list|,
name|blockcount
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sndbuf_resize
argument_list|(
name|ch
operator|->
name|pcm_buf
argument_list|,
name|blockcount
argument_list|,
name|blocksize
argument_list|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"failed to resize sound buffer, count=%u, "
literal|"size=%u\n"
argument_list|,
name|blockcount
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
block|}
block|}
name|ch
operator|->
name|block_size
operator|=
name|sndbuf_getblksz
argument_list|(
name|ch
operator|->
name|pcm_buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_chan_set_param_speed
parameter_list|(
name|struct
name|uaudio_chan
modifier|*
name|ch
parameter_list|,
name|uint32_t
name|speed
parameter_list|)
block|{
if|if
condition|(
name|speed
operator|!=
name|ch
operator|->
name|sample_rate
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"rate conversion required\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ch
operator|->
name|sample_rate
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_chan_getptr
parameter_list|(
name|struct
name|uaudio_chan
modifier|*
name|ch
parameter_list|)
block|{
return|return
operator|(
name|ch
operator|->
name|cur
operator|-
name|ch
operator|->
name|start
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|pcmchan_caps
modifier|*
name|uaudio_chan_getcaps
parameter_list|(
name|struct
name|uaudio_chan
modifier|*
name|ch
parameter_list|)
block|{
return|return
operator|(
operator|&
name|ch
operator|->
name|pcm_cap
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_chan_set_param_format
parameter_list|(
name|struct
name|uaudio_chan
modifier|*
name|ch
parameter_list|,
name|uint32_t
name|format
parameter_list|)
block|{
name|ch
operator|->
name|format
operator|=
name|format
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_chan_start
parameter_list|(
name|struct
name|uaudio_chan
modifier|*
name|ch
parameter_list|)
block|{
name|ch
operator|->
name|cur
operator|=
name|ch
operator|->
name|start
expr_stmt|;
if|#
directive|if
operator|(
name|UAUDIO_NCHANBUFS
operator|!=
literal|2
operator|)
error|#
directive|error
literal|"please update code"
endif|#
directive|endif
if|if
condition|(
name|ch
operator|->
name|xfer
index|[
literal|0
index|]
condition|)
block|{
name|usb2_transfer_start
argument_list|(
name|ch
operator|->
name|xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|xfer
index|[
literal|1
index|]
condition|)
block|{
name|usb2_transfer_start
argument_list|(
name|ch
operator|->
name|xfer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_chan_stop
parameter_list|(
name|struct
name|uaudio_chan
modifier|*
name|ch
parameter_list|)
block|{
if|#
directive|if
operator|(
name|UAUDIO_NCHANBUFS
operator|!=
literal|2
operator|)
error|#
directive|error
literal|"please update code"
endif|#
directive|endif
name|usb2_transfer_stop
argument_list|(
name|ch
operator|->
name|xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|usb2_transfer_stop
argument_list|(
name|ch
operator|->
name|xfer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*========================================================================*  * AC - Audio Controller - routines  *========================================================================*/
end_comment

begin_function
specifier|static
name|void
name|uaudio_mixer_add_ctl_sub
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
name|mc
parameter_list|)
block|{
name|struct
name|uaudio_mixer_node
modifier|*
name|p_mc_new
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_mc_new
argument_list|)
argument_list|,
name|M_USBDEV
argument_list|,
name|M_WAITOK
argument_list|)
decl_stmt|;
if|if
condition|(
name|p_mc_new
condition|)
block|{
name|bcopy
argument_list|(
name|mc
argument_list|,
name|p_mc_new
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_mc_new
argument_list|)
argument_list|)
expr_stmt|;
name|p_mc_new
operator|->
name|next
operator|=
name|sc
operator|->
name|sc_mixer_root
expr_stmt|;
name|sc
operator|->
name|sc_mixer_root
operator|=
name|p_mc_new
expr_stmt|;
name|sc
operator|->
name|sc_mixer_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_add_ctl
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
name|mc
parameter_list|)
block|{
name|int32_t
name|res
decl_stmt|;
if|if
condition|(
name|mc
operator|->
name|class
operator|<
name|UAC_NCLASSES
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"adding %s.%d\n"
argument_list|,
name|uac_names
index|[
name|mc
operator|->
name|class
index|]
argument_list|,
name|mc
operator|->
name|ctl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|"adding %d\n"
argument_list|,
name|mc
operator|->
name|ctl
argument_list|)
expr_stmt|;
block|}
name|mc
operator|->
name|delta
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_ON_OFF
condition|)
block|{
name|mc
operator|->
name|minval
operator|=
literal|0
expr_stmt|;
name|mc
operator|->
name|maxval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_SELECTOR
condition|)
block|{  	}
else|else
block|{
comment|/* determine min and max values */
name|mc
operator|->
name|minval
operator|=
name|uaudio_mixer_get
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|GET_MIN
argument_list|,
name|mc
argument_list|)
expr_stmt|;
name|mc
operator|->
name|minval
operator|=
name|uaudio_mixer_signext
argument_list|(
name|mc
operator|->
name|type
argument_list|,
name|mc
operator|->
name|minval
argument_list|)
expr_stmt|;
name|mc
operator|->
name|maxval
operator|=
name|uaudio_mixer_get
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|GET_MAX
argument_list|,
name|mc
argument_list|)
expr_stmt|;
name|mc
operator|->
name|maxval
operator|=
literal|1
operator|+
name|uaudio_mixer_signext
argument_list|(
name|mc
operator|->
name|type
argument_list|,
name|mc
operator|->
name|maxval
argument_list|)
expr_stmt|;
name|mc
operator|->
name|mul
operator|=
name|mc
operator|->
name|maxval
operator|-
name|mc
operator|->
name|minval
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|mul
operator|==
literal|0
condition|)
block|{
name|mc
operator|->
name|mul
operator|=
literal|1
expr_stmt|;
block|}
name|res
operator|=
name|uaudio_mixer_get
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|GET_RES
argument_list|,
name|mc
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
block|{
name|mc
operator|->
name|delta
operator|=
operator|(
operator|(
name|res
operator|*
literal|255
operator|)
operator|+
operator|(
name|mc
operator|->
name|mul
operator|/
literal|2
operator|)
operator|)
operator|/
name|mc
operator|->
name|mul
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mc
operator|->
name|maxval
operator|<
name|mc
operator|->
name|minval
condition|)
block|{
name|mc
operator|->
name|maxval
operator|=
name|mc
operator|->
name|minval
expr_stmt|;
block|}
name|uaudio_mixer_add_ctl_sub
argument_list|(
name|sc
argument_list|,
name|mc
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|uaudio_debug
operator|>
literal|2
condition|)
block|{
name|uint8_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
block|{
name|DPRINTF
argument_list|(
literal|"[mix] wValue=%04x\n"
argument_list|,
name|mc
operator|->
name|wValue
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"[mix] wIndex=%04x type=%d ctl='%d' "
literal|"min=%d max=%d\n"
argument_list|,
name|mc
operator|->
name|wIndex
argument_list|,
name|mc
operator|->
name|type
argument_list|,
name|mc
operator|->
name|ctl
argument_list|,
name|mc
operator|->
name|minval
argument_list|,
name|mc
operator|->
name|maxval
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_add_input
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
if|#
directive|if
name|USB_DEBUG
specifier|const
name|struct
name|usb2_audio_input_terminal
modifier|*
name|d
init|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|it
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"bTerminalId=%d wTerminalType=0x%04x "
literal|"bAssocTerminal=%d bNrChannels=%d wChannelConfig=%d "
literal|"iChannelNames=%d\n"
argument_list|,
name|d
operator|->
name|bTerminalId
argument_list|,
name|UGETW
argument_list|(
name|d
operator|->
name|wTerminalType
argument_list|)
argument_list|,
name|d
operator|->
name|bAssocTerminal
argument_list|,
name|d
operator|->
name|bNrChannels
argument_list|,
name|UGETW
argument_list|(
name|d
operator|->
name|wChannelConfig
argument_list|)
argument_list|,
name|d
operator|->
name|iChannelNames
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_add_output
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
if|#
directive|if
name|USB_DEBUG
specifier|const
name|struct
name|usb2_audio_output_terminal
modifier|*
name|d
init|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|ot
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"bTerminalId=%d wTerminalType=0x%04x "
literal|"bAssocTerminal=%d bSourceId=%d iTerminal=%d\n"
argument_list|,
name|d
operator|->
name|bTerminalId
argument_list|,
name|UGETW
argument_list|(
name|d
operator|->
name|wTerminalType
argument_list|)
argument_list|,
name|d
operator|->
name|bAssocTerminal
argument_list|,
name|d
operator|->
name|bSourceId
argument_list|,
name|d
operator|->
name|iTerminal
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_add_mixer
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|uaudio_mixer_node
name|mix
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_mixer_unit_0
modifier|*
name|d0
init|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|mu
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_mixer_unit_1
modifier|*
name|d1
decl_stmt|;
name|uint32_t
name|bno
decl_stmt|;
comment|/* bit number */
name|uint32_t
name|p
decl_stmt|;
comment|/* bit number accumulator */
name|uint32_t
name|mo
decl_stmt|;
comment|/* matching outputs */
name|uint32_t
name|mc
decl_stmt|;
comment|/* matching channels */
name|uint32_t
name|ichs
decl_stmt|;
comment|/* input channels */
name|uint32_t
name|ochs
decl_stmt|;
comment|/* output channels */
name|uint32_t
name|c
decl_stmt|;
name|uint32_t
name|chs
decl_stmt|;
comment|/* channels */
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|o
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"bUnitId=%d bNrInPins=%d\n"
argument_list|,
name|d0
operator|->
name|bUnitId
argument_list|,
name|d0
operator|->
name|bNrInPins
argument_list|)
expr_stmt|;
comment|/* compute the number of input channels */
name|ichs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d0
operator|->
name|bNrInPins
condition|;
name|i
operator|++
control|)
block|{
name|ichs
operator|+=
operator|(
name|uaudio_mixer_get_cluster
argument_list|(
name|d0
operator|->
name|baSourceId
index|[
name|i
index|]
argument_list|,
name|iot
argument_list|)
operator|.
name|bNrChannels
operator|)
expr_stmt|;
block|}
name|d1
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|d0
operator|->
name|baSourceId
operator|+
name|d0
operator|->
name|bNrInPins
operator|)
expr_stmt|;
comment|/* and the number of output channels */
name|ochs
operator|=
name|d1
operator|->
name|bNrChannels
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"ichs=%d ochs=%d\n"
argument_list|,
name|ichs
argument_list|,
name|ochs
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|mix
argument_list|,
sizeof|sizeof
argument_list|(
name|mix
argument_list|)
argument_list|)
expr_stmt|;
name|mix
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
name|d0
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
name|uaudio_mixer_determine_class
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
name|mix
operator|.
name|type
operator|=
name|MIX_SIGNED_16
expr_stmt|;
if|if
condition|(
name|uaudio_mixer_verify_desc
argument_list|(
name|d0
argument_list|,
operator|(
operator|(
name|ichs
operator|*
name|ochs
operator|)
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
for|for
control|(
name|p
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d0
operator|->
name|bNrInPins
condition|;
name|i
operator|++
control|)
block|{
name|chs
operator|=
name|uaudio_mixer_get_cluster
argument_list|(
name|d0
operator|->
name|baSourceId
index|[
name|i
index|]
argument_list|,
name|iot
argument_list|)
operator|.
name|bNrChannels
expr_stmt|;
name|mc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|chs
condition|;
name|c
operator|++
control|)
block|{
name|mo
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|o
operator|=
literal|0
init|;
name|o
operator|<
name|ochs
condition|;
name|o
operator|++
control|)
block|{
name|bno
operator|=
operator|(
operator|(
name|p
operator|+
name|c
operator|)
operator|*
name|ochs
operator|)
operator|+
name|o
expr_stmt|;
if|if
condition|(
name|BIT_TEST
argument_list|(
name|d1
operator|->
name|bmControls
argument_list|,
name|bno
argument_list|)
condition|)
block|{
name|mo
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mo
operator|==
literal|1
condition|)
block|{
name|mc
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|mc
operator|==
name|chs
operator|)
operator|&&
operator|(
name|chs
operator|<=
name|MIX_MAX_CHAN
operator|)
condition|)
block|{
comment|/* repeat bit-scan */
name|mc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|chs
condition|;
name|c
operator|++
control|)
block|{
for|for
control|(
name|o
operator|=
literal|0
init|;
name|o
operator|<
name|ochs
condition|;
name|o
operator|++
control|)
block|{
name|bno
operator|=
operator|(
operator|(
name|p
operator|+
name|c
operator|)
operator|*
name|ochs
operator|)
operator|+
name|o
expr_stmt|;
if|if
condition|(
name|BIT_TEST
argument_list|(
name|d1
operator|->
name|bmControls
argument_list|,
name|bno
argument_list|)
condition|)
block|{
name|mix
operator|.
name|wValue
index|[
name|mc
operator|++
index|]
operator|=
name|MAKE_WORD
argument_list|(
name|p
operator|+
name|c
operator|+
literal|1
argument_list|,
name|o
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mix
operator|.
name|nchan
operator|=
name|chs
expr_stmt|;
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX */
block|}
name|p
operator|+=
name|chs
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_add_selector
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|const
name|struct
name|usb2_audio_selector_unit
modifier|*
name|d
init|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|su
decl_stmt|;
name|struct
name|uaudio_mixer_node
name|mix
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"bUnitId=%d bNrInPins=%d\n"
argument_list|,
name|d
operator|->
name|bUnitId
argument_list|,
name|d
operator|->
name|bNrInPins
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bNrInPins
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|bzero
argument_list|(
operator|&
name|mix
argument_list|,
sizeof|sizeof
argument_list|(
name|mix
argument_list|)
argument_list|)
expr_stmt|;
name|mix
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
name|d
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
name|mix
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uaudio_mixer_determine_class
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
name|mix
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|mix
operator|.
name|type
operator|=
name|MIX_SELECTOR
expr_stmt|;
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
name|mix
operator|.
name|minval
operator|=
literal|1
expr_stmt|;
name|mix
operator|.
name|maxval
operator|=
name|d
operator|->
name|bNrInPins
expr_stmt|;
if|if
condition|(
name|mix
operator|.
name|maxval
operator|>
name|MAX_SELECTOR_INPUT_PIN
condition|)
block|{
name|mix
operator|.
name|maxval
operator|=
name|MAX_SELECTOR_INPUT_PIN
expr_stmt|;
block|}
name|mix
operator|.
name|mul
operator|=
operator|(
name|mix
operator|.
name|maxval
operator|-
name|mix
operator|.
name|minval
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_SELECTOR_INPUT_PIN
condition|;
name|i
operator|++
control|)
block|{
name|mix
operator|.
name|slctrtype
index|[
name|i
index|]
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mix
operator|.
name|maxval
condition|;
name|i
operator|++
control|)
block|{
name|mix
operator|.
name|slctrtype
index|[
name|i
index|]
operator|=
name|uaudio_mixer_feature_name
argument_list|(
operator|&
name|iot
index|[
name|d
operator|->
name|baSourceId
index|[
name|i
index|]
index|]
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
block|}
name|mix
operator|.
name|class
operator|=
literal|0
expr_stmt|;
comment|/* not used */
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|uaudio_mixer_feature_get_bmaControls
parameter_list|(
specifier|const
name|struct
name|usb2_audio_feature_unit
modifier|*
name|d
parameter_list|,
name|uint8_t
name|index
parameter_list|)
block|{
name|uint32_t
name|temp
init|=
literal|0
decl_stmt|;
name|uint32_t
name|offset
init|=
operator|(
name|index
operator|*
name|d
operator|->
name|bControlSize
operator|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|bControlSize
operator|>
literal|0
condition|)
block|{
name|temp
operator||=
name|d
operator|->
name|bmaControls
index|[
name|offset
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bControlSize
operator|>
literal|1
condition|)
block|{
name|temp
operator||=
name|d
operator|->
name|bmaControls
index|[
name|offset
operator|+
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bControlSize
operator|>
literal|2
condition|)
block|{
name|temp
operator||=
name|d
operator|->
name|bmaControls
index|[
name|offset
operator|+
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bControlSize
operator|>
literal|3
condition|)
block|{
name|temp
operator||=
name|d
operator|->
name|bmaControls
index|[
name|offset
operator|+
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_add_feature
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|const
name|struct
name|usb2_audio_feature_unit
modifier|*
name|d
init|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|fu
decl_stmt|;
name|struct
name|uaudio_mixer_node
name|mix
decl_stmt|;
name|uint32_t
name|fumask
decl_stmt|;
name|uint32_t
name|mmask
decl_stmt|;
name|uint32_t
name|cmask
decl_stmt|;
name|uint16_t
name|mixernumber
decl_stmt|;
name|uint8_t
name|nchan
decl_stmt|;
name|uint8_t
name|chan
decl_stmt|;
name|uint8_t
name|ctl
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|bControlSize
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|bzero
argument_list|(
operator|&
name|mix
argument_list|,
sizeof|sizeof
argument_list|(
name|mix
argument_list|)
argument_list|)
expr_stmt|;
name|nchan
operator|=
operator|(
name|d
operator|->
name|bLength
operator|-
literal|7
operator|)
operator|/
name|d
operator|->
name|bControlSize
expr_stmt|;
name|mmask
operator|=
name|uaudio_mixer_feature_get_bmaControls
argument_list|(
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cmask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nchan
operator|==
literal|0
condition|)
block|{
return|return;
block|}
comment|/* figure out what we can control */
for|for
control|(
name|chan
operator|=
literal|1
init|;
name|chan
operator|<
name|nchan
condition|;
name|chan
operator|++
control|)
block|{
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
literal|"chan=%d mask=%x\n"
argument_list|,
name|chan
argument_list|,
name|uaudio_mixer_feature_get_bmaControls
argument_list|(
name|d
argument_list|,
name|chan
argument_list|)
argument_list|)
expr_stmt|;
name|cmask
operator||=
name|uaudio_mixer_feature_get_bmaControls
argument_list|(
name|d
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nchan
operator|>
name|MIX_MAX_CHAN
condition|)
block|{
name|nchan
operator|=
name|MIX_MAX_CHAN
expr_stmt|;
block|}
name|mix
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
name|d
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
for|for
control|(
name|ctl
operator|=
literal|1
init|;
name|ctl
operator|<=
name|LOUDNESS_CONTROL
condition|;
name|ctl
operator|++
control|)
block|{
name|fumask
operator|=
name|FU_MASK
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"ctl=%d fumask=0x%04x\n"
argument_list|,
name|ctl
argument_list|,
name|fumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mmask
operator|&
name|fumask
condition|)
block|{
name|mix
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|mix
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
name|ctl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmask
operator|&
name|fumask
condition|)
block|{
name|mix
operator|.
name|nchan
operator|=
name|nchan
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nchan
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|uaudio_mixer_feature_get_bmaControls
argument_list|(
name|d
argument_list|,
name|i
argument_list|)
operator|&
name|fumask
condition|)
name|mix
operator|.
name|wValue
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|MAKE_WORD
argument_list|(
name|ctl
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|mix
operator|.
name|wValue
index|[
name|i
operator|-
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
continue|continue;
block|}
name|mixernumber
operator|=
name|uaudio_mixer_feature_name
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ctl
condition|)
block|{
case|case
name|MUTE_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
break|break;
case|case
name|VOLUME_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_SIGNED_16
expr_stmt|;
name|mix
operator|.
name|ctl
operator|=
name|mixernumber
expr_stmt|;
break|break;
case|case
name|BASS_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_SIGNED_8
expr_stmt|;
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_BASS
expr_stmt|;
break|break;
case|case
name|MID_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_SIGNED_8
expr_stmt|;
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
break|break;
case|case
name|TREBLE_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_SIGNED_8
expr_stmt|;
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_TREBLE
expr_stmt|;
break|break;
case|case
name|GRAPHIC_EQUALIZER_CONTROL
case|:
continue|continue;
comment|/* XXX don't add anything */
break|break;
case|case
name|AGC_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
break|break;
case|case
name|DELAY_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_UNSIGNED_16
expr_stmt|;
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
break|break;
case|case
name|BASS_BOOST_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
break|break;
case|case
name|LOUDNESS_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_LOUD
expr_stmt|;
comment|/* Is this correct ? */
break|break;
default|default:
name|mix
operator|.
name|type
operator|=
name|MIX_UNKNOWN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mix
operator|.
name|type
operator|!=
name|MIX_UNKNOWN
condition|)
block|{
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_add_processing_updown
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|const
name|struct
name|usb2_audio_processing_unit_0
modifier|*
name|d0
init|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|pu
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_processing_unit_1
modifier|*
name|d1
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|d0
operator|->
name|baSourceId
operator|+
name|d0
operator|->
name|bNrInPins
operator|)
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_processing_unit_updown
modifier|*
name|ud
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|d1
operator|->
name|bmControls
operator|+
name|d1
operator|->
name|bControlSize
operator|)
decl_stmt|;
name|struct
name|uaudio_mixer_node
name|mix
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
if|if
condition|(
name|uaudio_mixer_verify_desc
argument_list|(
name|d0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ud
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|uaudio_mixer_verify_desc
argument_list|(
name|d0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ud
argument_list|)
operator|+
operator|(
literal|2
operator|*
name|ud
operator|->
name|bNrModes
operator|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"bUnitId=%d bNrModes=%d\n"
argument_list|,
name|d0
operator|->
name|bUnitId
argument_list|,
name|ud
operator|->
name|bNrModes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|d1
operator|->
name|bmControls
index|[
literal|0
index|]
operator|&
name|UA_PROC_MASK
argument_list|(
name|UD_MODE_SELECT_CONTROL
argument_list|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"no mode select\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
operator|&
name|mix
argument_list|,
sizeof|sizeof
argument_list|(
name|mix
argument_list|)
argument_list|)
expr_stmt|;
name|mix
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
name|d0
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
name|mix
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|mix
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
name|UD_MODE_SELECT_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uaudio_mixer_determine_class
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
comment|/* XXX */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ud
operator|->
name|bNrModes
condition|;
name|i
operator|++
control|)
block|{
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"i=%d bm=0x%x\n"
argument_list|,
name|i
argument_list|,
name|UGETW
argument_list|(
name|ud
operator|->
name|waModes
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_add_processing
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|const
name|struct
name|usb2_audio_processing_unit_0
modifier|*
name|d0
init|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|pu
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_processing_unit_1
modifier|*
name|d1
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|d0
operator|->
name|baSourceId
operator|+
name|d0
operator|->
name|bNrInPins
operator|)
decl_stmt|;
name|struct
name|uaudio_mixer_node
name|mix
decl_stmt|;
name|uint16_t
name|ptype
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|mix
argument_list|,
sizeof|sizeof
argument_list|(
name|mix
argument_list|)
argument_list|)
expr_stmt|;
name|ptype
operator|=
name|UGETW
argument_list|(
name|d0
operator|->
name|wProcessType
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"wProcessType=%d bUnitId=%d "
literal|"bNrInPins=%d\n"
argument_list|,
name|ptype
argument_list|,
name|d0
operator|->
name|bUnitId
argument_list|,
name|d0
operator|->
name|bNrInPins
argument_list|)
expr_stmt|;
if|if
condition|(
name|d1
operator|->
name|bControlSize
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|d1
operator|->
name|bmControls
index|[
literal|0
index|]
operator|&
name|UA_PROC_ENABLE_MASK
condition|)
block|{
name|mix
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
name|d0
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
name|mix
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|mix
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
name|XX_ENABLE_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uaudio_mixer_determine_class
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
name|UPDOWNMIX_PROCESS
case|:
name|uaudio_mixer_add_processing_updown
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOLBY_PROLOGIC_PROCESS
case|:
case|case
name|P3D_STEREO_EXTENDER_PROCESS
case|:
case|case
name|REVERBATION_PROCESS
case|:
case|case
name|CHORUS_PROCESS
case|:
case|case
name|DYN_RANGE_COMP_PROCESS
case|:
default|default:
name|DPRINTF
argument_list|(
literal|"unit %d, type=%d is not implemented\n"
argument_list|,
name|d0
operator|->
name|bUnitId
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_add_extension
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|const
name|struct
name|usb2_audio_extension_unit_0
modifier|*
name|d0
init|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|eu
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_extension_unit_1
modifier|*
name|d1
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|d0
operator|->
name|baSourceId
operator|+
name|d0
operator|->
name|bNrInPins
operator|)
decl_stmt|;
name|struct
name|uaudio_mixer_node
name|mix
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"bUnitId=%d bNrInPins=%d\n"
argument_list|,
name|d0
operator|->
name|bUnitId
argument_list|,
name|d0
operator|->
name|bNrInPins
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_uq_au_no_xu
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|d1
operator|->
name|bControlSize
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|d1
operator|->
name|bmControls
index|[
literal|0
index|]
operator|&
name|UA_EXT_ENABLE_MASK
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|mix
argument_list|,
sizeof|sizeof
argument_list|(
name|mix
argument_list|)
argument_list|)
expr_stmt|;
name|mix
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
name|d0
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
name|mix
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|mix
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
name|UA_EXT_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uaudio_mixer_determine_class
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|uaudio_mixer_verify_desc
parameter_list|(
specifier|const
name|void
modifier|*
name|arg
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
specifier|const
name|struct
name|usb2_audio_mixer_unit_1
modifier|*
name|d1
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_extension_unit_1
modifier|*
name|e1
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_processing_unit_1
modifier|*
name|u1
decl_stmt|;
union|union
block|{
specifier|const
name|struct
name|usb2_descriptor
modifier|*
name|desc
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_input_terminal
modifier|*
name|it
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_output_terminal
modifier|*
name|ot
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_mixer_unit_0
modifier|*
name|mu
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_selector_unit
modifier|*
name|su
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_feature_unit
modifier|*
name|fu
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_processing_unit_0
modifier|*
name|pu
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_extension_unit_0
modifier|*
name|eu
decl_stmt|;
block|}
name|u
union|;
name|u
operator|.
name|desc
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bDescriptorType
operator|!=
name|UDESC_CS_INTERFACE
condition|)
block|{
goto|goto
name|error
goto|;
block|}
switch|switch
condition|(
name|u
operator|.
name|desc
operator|->
name|bDescriptorSubtype
condition|)
block|{
case|case
name|UDESCSUB_AC_INPUT
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|it
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_OUTPUT
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|ot
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_MIXER
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|mu
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|len
operator|+=
name|u
operator|.
name|mu
operator|->
name|bNrInPins
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|d1
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|u
operator|.
name|mu
operator|->
name|baSourceId
operator|+
name|u
operator|.
name|mu
operator|->
name|bNrInPins
operator|)
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|d1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_SELECTOR
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|su
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|len
operator|+=
name|u
operator|.
name|su
operator|->
name|bNrInPins
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_FEATURE
case|:
name|len
operator|+=
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|fu
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_PROCESSING
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|pu
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|len
operator|+=
name|u
operator|.
name|pu
operator|->
name|bNrInPins
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|u1
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|u
operator|.
name|pu
operator|->
name|baSourceId
operator|+
name|u
operator|.
name|pu
operator|->
name|bNrInPins
operator|)
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u1
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|len
operator|+=
name|u1
operator|->
name|bControlSize
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_EXTENSION
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|eu
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|len
operator|+=
name|u
operator|.
name|eu
operator|->
name|bNrInPins
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|e1
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|u
operator|.
name|eu
operator|->
name|baSourceId
operator|+
name|u
operator|.
name|eu
operator|->
name|bNrInPins
operator|)
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|len
operator|+=
name|e1
operator|->
name|bControlSize
expr_stmt|;
break|break;
default|default:
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
block|{
goto|goto
name|error
goto|;
block|}
return|return
operator|(
name|u
operator|.
name|desc
operator|)
return|;
name|error
label|:
if|if
condition|(
name|u
operator|.
name|desc
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"invalid descriptor, type=%d, "
literal|"sub_type=%d, len=%d of %d bytes\n"
argument_list|,
name|u
operator|.
name|desc
operator|->
name|bDescriptorType
argument_list|,
name|u
operator|.
name|desc
operator|->
name|bDescriptorSubtype
argument_list|,
name|u
operator|.
name|desc
operator|->
name|bLength
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|USB_DEBUG
end_if

begin_function
specifier|static
name|void
name|uaudio_mixer_dump_cluster
parameter_list|(
name|uint8_t
name|id
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|channel_names
index|[
literal|16
index|]
init|=
block|{
literal|"LEFT"
block|,
literal|"RIGHT"
block|,
literal|"CENTER"
block|,
literal|"LFE"
block|,
literal|"LEFT_SURROUND"
block|,
literal|"RIGHT_SURROUND"
block|,
literal|"LEFT_CENTER"
block|,
literal|"RIGHT_CENTER"
block|,
literal|"SURROUND"
block|,
literal|"LEFT_SIDE"
block|,
literal|"RIGHT_SIDE"
block|,
literal|"TOP"
block|,
literal|"RESERVED12"
block|,
literal|"RESERVED13"
block|,
literal|"RESERVED14"
block|,
literal|"RESERVED15"
block|, 	}
decl_stmt|;
name|uint16_t
name|cc
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_cluster
name|cl
init|=
name|uaudio_mixer_get_cluster
argument_list|(
name|id
argument_list|,
name|iot
argument_list|)
decl_stmt|;
name|cc
operator|=
name|UGETW
argument_list|(
name|cl
operator|.
name|wChannelConfig
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"cluster: bNrChannels=%u iChannelNames=%u wChannelConfig="
literal|"0x%04x:\n"
argument_list|,
name|cl
operator|.
name|iChannelNames
argument_list|,
name|cl
operator|.
name|bNrChannels
argument_list|,
name|cc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cc
operator|&
literal|1
condition|)
block|{
name|DPRINTF
argument_list|(
literal|" - %s\n"
argument_list|,
name|channel_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|cc
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|struct
name|usb2_audio_cluster
name|uaudio_mixer_get_cluster
parameter_list|(
name|uint8_t
name|id
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|)
block|{
name|struct
name|usb2_audio_cluster
name|r
decl_stmt|;
specifier|const
name|struct
name|usb2_descriptor
modifier|*
name|dp
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_RECURSE_LIMIT
condition|;
name|i
operator|++
control|)
block|{
comment|/* avoid infinite loops */
name|dp
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|desc
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
switch|switch
condition|(
name|dp
operator|->
name|bDescriptorSubtype
condition|)
block|{
case|case
name|UDESCSUB_AC_INPUT
case|:
name|r
operator|.
name|bNrChannels
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|it
operator|->
name|bNrChannels
expr_stmt|;
name|r
operator|.
name|wChannelConfig
index|[
literal|0
index|]
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|it
operator|->
name|wChannelConfig
index|[
literal|0
index|]
expr_stmt|;
name|r
operator|.
name|wChannelConfig
index|[
literal|1
index|]
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|it
operator|->
name|wChannelConfig
index|[
literal|1
index|]
expr_stmt|;
name|r
operator|.
name|iChannelNames
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|it
operator|->
name|iChannelNames
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|UDESCSUB_AC_OUTPUT
case|:
name|id
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|ot
operator|->
name|bSourceId
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_MIXER
case|:
name|r
operator|=
operator|*
operator|(
specifier|const
expr|struct
name|usb2_audio_cluster
operator|*
operator|)
operator|&
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|mu
operator|->
name|baSourceId
index|[
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|mu
operator|->
name|bNrInPins
index|]
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|UDESCSUB_AC_SELECTOR
case|:
if|if
condition|(
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|su
operator|->
name|bNrInPins
operator|>
literal|0
condition|)
block|{
comment|/* XXX This is not really right */
name|id
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|su
operator|->
name|baSourceId
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
case|case
name|UDESCSUB_AC_FEATURE
case|:
name|id
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|fu
operator|->
name|bSourceId
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_PROCESSING
case|:
name|r
operator|=
operator|*
operator|(
operator|(
specifier|const
expr|struct
name|usb2_audio_cluster
operator|*
operator|)
operator|&
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|pu
operator|->
name|baSourceId
index|[
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|pu
operator|->
name|bNrInPins
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|UDESCSUB_AC_EXTENSION
case|:
name|r
operator|=
operator|*
operator|(
operator|(
specifier|const
expr|struct
name|usb2_audio_cluster
operator|*
operator|)
operator|&
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|eu
operator|->
name|baSourceId
index|[
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|eu
operator|->
name|bNrInPins
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
default|default:
goto|goto
name|error
goto|;
block|}
block|}
name|error
label|:
name|DPRINTF
argument_list|(
literal|"bad data\n"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|done
label|:
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|USB_DEBUG
end_if

begin_struct
struct|struct
name|uaudio_tt_to_string
block|{
name|uint16_t
name|terminal_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|uaudio_tt_to_string
name|uaudio_tt_to_string
index|[]
init|=
block|{
comment|/* USB terminal types */
block|{
name|UAT_UNDEFINED
block|,
literal|"UAT_UNDEFINED"
block|}
block|,
block|{
name|UAT_STREAM
block|,
literal|"UAT_STREAM"
block|}
block|,
block|{
name|UAT_VENDOR
block|,
literal|"UAT_VENDOR"
block|}
block|,
comment|/* input terminal types */
block|{
name|UATI_UNDEFINED
block|,
literal|"UATI_UNDEFINED"
block|}
block|,
block|{
name|UATI_MICROPHONE
block|,
literal|"UATI_MICROPHONE"
block|}
block|,
block|{
name|UATI_DESKMICROPHONE
block|,
literal|"UATI_DESKMICROPHONE"
block|}
block|,
block|{
name|UATI_PERSONALMICROPHONE
block|,
literal|"UATI_PERSONALMICROPHONE"
block|}
block|,
block|{
name|UATI_OMNIMICROPHONE
block|,
literal|"UATI_OMNIMICROPHONE"
block|}
block|,
block|{
name|UATI_MICROPHONEARRAY
block|,
literal|"UATI_MICROPHONEARRAY"
block|}
block|,
block|{
name|UATI_PROCMICROPHONEARR
block|,
literal|"UATI_PROCMICROPHONEARR"
block|}
block|,
comment|/* output terminal types */
block|{
name|UATO_UNDEFINED
block|,
literal|"UATO_UNDEFINED"
block|}
block|,
block|{
name|UATO_SPEAKER
block|,
literal|"UATO_SPEAKER"
block|}
block|,
block|{
name|UATO_HEADPHONES
block|,
literal|"UATO_HEADPHONES"
block|}
block|,
block|{
name|UATO_DISPLAYAUDIO
block|,
literal|"UATO_DISPLAYAUDIO"
block|}
block|,
block|{
name|UATO_DESKTOPSPEAKER
block|,
literal|"UATO_DESKTOPSPEAKER"
block|}
block|,
block|{
name|UATO_ROOMSPEAKER
block|,
literal|"UATO_ROOMSPEAKER"
block|}
block|,
block|{
name|UATO_COMMSPEAKER
block|,
literal|"UATO_COMMSPEAKER"
block|}
block|,
block|{
name|UATO_SUBWOOFER
block|,
literal|"UATO_SUBWOOFER"
block|}
block|,
comment|/* bidir terminal types */
block|{
name|UATB_UNDEFINED
block|,
literal|"UATB_UNDEFINED"
block|}
block|,
block|{
name|UATB_HANDSET
block|,
literal|"UATB_HANDSET"
block|}
block|,
block|{
name|UATB_HEADSET
block|,
literal|"UATB_HEADSET"
block|}
block|,
block|{
name|UATB_SPEAKERPHONE
block|,
literal|"UATB_SPEAKERPHONE"
block|}
block|,
block|{
name|UATB_SPEAKERPHONEESUP
block|,
literal|"UATB_SPEAKERPHONEESUP"
block|}
block|,
block|{
name|UATB_SPEAKERPHONEECANC
block|,
literal|"UATB_SPEAKERPHONEECANC"
block|}
block|,
comment|/* telephony terminal types */
block|{
name|UATT_UNDEFINED
block|,
literal|"UATT_UNDEFINED"
block|}
block|,
block|{
name|UATT_PHONELINE
block|,
literal|"UATT_PHONELINE"
block|}
block|,
block|{
name|UATT_TELEPHONE
block|,
literal|"UATT_TELEPHONE"
block|}
block|,
block|{
name|UATT_DOWNLINEPHONE
block|,
literal|"UATT_DOWNLINEPHONE"
block|}
block|,
comment|/* external terminal types */
block|{
name|UATE_UNDEFINED
block|,
literal|"UATE_UNDEFINED"
block|}
block|,
block|{
name|UATE_ANALOGCONN
block|,
literal|"UATE_ANALOGCONN"
block|}
block|,
block|{
name|UATE_LINECONN
block|,
literal|"UATE_LINECONN"
block|}
block|,
block|{
name|UATE_LEGACYCONN
block|,
literal|"UATE_LEGACYCONN"
block|}
block|,
block|{
name|UATE_DIGITALAUIFC
block|,
literal|"UATE_DIGITALAUIFC"
block|}
block|,
block|{
name|UATE_SPDIF
block|,
literal|"UATE_SPDIF"
block|}
block|,
block|{
name|UATE_1394DA
block|,
literal|"UATE_1394DA"
block|}
block|,
block|{
name|UATE_1394DV
block|,
literal|"UATE_1394DV"
block|}
block|,
comment|/* embedded function terminal types */
block|{
name|UATF_UNDEFINED
block|,
literal|"UATF_UNDEFINED"
block|}
block|,
block|{
name|UATF_CALIBNOISE
block|,
literal|"UATF_CALIBNOISE"
block|}
block|,
block|{
name|UATF_EQUNOISE
block|,
literal|"UATF_EQUNOISE"
block|}
block|,
block|{
name|UATF_CDPLAYER
block|,
literal|"UATF_CDPLAYER"
block|}
block|,
block|{
name|UATF_DAT
block|,
literal|"UATF_DAT"
block|}
block|,
block|{
name|UATF_DCC
block|,
literal|"UATF_DCC"
block|}
block|,
block|{
name|UATF_MINIDISK
block|,
literal|"UATF_MINIDISK"
block|}
block|,
block|{
name|UATF_ANALOGTAPE
block|,
literal|"UATF_ANALOGTAPE"
block|}
block|,
block|{
name|UATF_PHONOGRAPH
block|,
literal|"UATF_PHONOGRAPH"
block|}
block|,
block|{
name|UATF_VCRAUDIO
block|,
literal|"UATF_VCRAUDIO"
block|}
block|,
block|{
name|UATF_VIDEODISCAUDIO
block|,
literal|"UATF_VIDEODISCAUDIO"
block|}
block|,
block|{
name|UATF_DVDAUDIO
block|,
literal|"UATF_DVDAUDIO"
block|}
block|,
block|{
name|UATF_TVTUNERAUDIO
block|,
literal|"UATF_TVTUNERAUDIO"
block|}
block|,
block|{
name|UATF_SATELLITE
block|,
literal|"UATF_SATELLITE"
block|}
block|,
block|{
name|UATF_CABLETUNER
block|,
literal|"UATF_CABLETUNER"
block|}
block|,
block|{
name|UATF_DSS
block|,
literal|"UATF_DSS"
block|}
block|,
block|{
name|UATF_RADIORECV
block|,
literal|"UATF_RADIORECV"
block|}
block|,
block|{
name|UATF_RADIOXMIT
block|,
literal|"UATF_RADIOXMIT"
block|}
block|,
block|{
name|UATF_MULTITRACK
block|,
literal|"UATF_MULTITRACK"
block|}
block|,
block|{
name|UATF_SYNTHESIZER
block|,
literal|"UATF_SYNTHESIZER"
block|}
block|,
comment|/* unknown */
block|{
literal|0x0000
block|,
literal|"UNKNOWN"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|uaudio_mixer_get_terminal_name
parameter_list|(
name|uint16_t
name|terminal_type
parameter_list|)
block|{
specifier|const
name|struct
name|uaudio_tt_to_string
modifier|*
name|uat
init|=
name|uaudio_tt_to_string
decl_stmt|;
while|while
condition|(
name|uat
operator|->
name|terminal_type
condition|)
block|{
if|if
condition|(
name|uat
operator|->
name|terminal_type
operator|==
name|terminal_type
condition|)
block|{
break|break;
block|}
name|uat
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|uat
operator|->
name|terminal_type
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"unknown terminal type (0x%04x)"
argument_list|,
name|terminal_type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|uat
operator|->
name|desc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|uint16_t
name|uaudio_mixer_determine_class
parameter_list|(
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
name|mix
parameter_list|)
block|{
name|uint16_t
name|terminal_type
init|=
literal|0x0000
decl_stmt|;
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|input
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|output
index|[
literal|2
index|]
decl_stmt|;
name|input
index|[
literal|0
index|]
operator|=
name|uaudio_mixer_get_input
argument_list|(
name|iot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|input
index|[
literal|1
index|]
operator|=
name|uaudio_mixer_get_input
argument_list|(
name|iot
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|output
index|[
literal|0
index|]
operator|=
name|uaudio_mixer_get_output
argument_list|(
name|iot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|=
name|uaudio_mixer_get_output
argument_list|(
name|iot
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * check if there is only 	 * one output terminal: 	 */
if|if
condition|(
name|output
index|[
literal|0
index|]
operator|&&
operator|(
operator|!
name|output
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|terminal_type
operator|=
name|UGETW
argument_list|(
name|output
index|[
literal|0
index|]
operator|->
name|u
operator|.
name|ot
operator|->
name|wTerminalType
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the only output terminal is USB, 	 * the class is UAC_RECORD. 	 */
if|if
condition|(
operator|(
name|terminal_type
operator|&
literal|0xff00
operator|)
operator|==
operator|(
name|UAT_UNDEFINED
operator|&
literal|0xff00
operator|)
condition|)
block|{
name|mix
operator|->
name|class
operator|=
name|UAC_RECORD
expr_stmt|;
if|if
condition|(
name|input
index|[
literal|0
index|]
operator|&&
operator|(
operator|!
name|input
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|terminal_type
operator|=
name|UGETW
argument_list|(
name|input
index|[
literal|0
index|]
operator|->
name|u
operator|.
name|it
operator|->
name|wTerminalType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|terminal_type
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
comment|/* 	 * if the unit is connected to just 	 * one input terminal, the 	 * class is UAC_INPUT: 	 */
if|if
condition|(
name|input
index|[
literal|0
index|]
operator|&&
operator|(
operator|!
name|input
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|mix
operator|->
name|class
operator|=
name|UAC_INPUT
expr_stmt|;
name|terminal_type
operator|=
name|UGETW
argument_list|(
name|input
index|[
literal|0
index|]
operator|->
name|u
operator|.
name|it
operator|->
name|wTerminalType
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Otherwise, the class is UAC_OUTPUT. 	 */
name|mix
operator|->
name|class
operator|=
name|UAC_OUTPUT
expr_stmt|;
name|done
label|:
return|return
operator|(
name|terminal_type
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|uaudio_tt_to_feature
block|{
name|uint16_t
name|terminal_type
decl_stmt|;
name|uint16_t
name|feature
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|uaudio_tt_to_feature
name|uaudio_tt_to_feature
index|[]
init|=
block|{
block|{
name|UAT_STREAM
block|,
name|SOUND_MIXER_PCM
block|}
block|,
block|{
name|UATI_MICROPHONE
block|,
name|SOUND_MIXER_MIC
block|}
block|,
block|{
name|UATI_DESKMICROPHONE
block|,
name|SOUND_MIXER_MIC
block|}
block|,
block|{
name|UATI_PERSONALMICROPHONE
block|,
name|SOUND_MIXER_MIC
block|}
block|,
block|{
name|UATI_OMNIMICROPHONE
block|,
name|SOUND_MIXER_MIC
block|}
block|,
block|{
name|UATI_MICROPHONEARRAY
block|,
name|SOUND_MIXER_MIC
block|}
block|,
block|{
name|UATI_PROCMICROPHONEARR
block|,
name|SOUND_MIXER_MIC
block|}
block|,
block|{
name|UATO_SPEAKER
block|,
name|SOUND_MIXER_SPEAKER
block|}
block|,
block|{
name|UATO_DESKTOPSPEAKER
block|,
name|SOUND_MIXER_SPEAKER
block|}
block|,
block|{
name|UATO_ROOMSPEAKER
block|,
name|SOUND_MIXER_SPEAKER
block|}
block|,
block|{
name|UATO_COMMSPEAKER
block|,
name|SOUND_MIXER_SPEAKER
block|}
block|,
block|{
name|UATE_ANALOGCONN
block|,
name|SOUND_MIXER_LINE
block|}
block|,
block|{
name|UATE_LINECONN
block|,
name|SOUND_MIXER_LINE
block|}
block|,
block|{
name|UATE_LEGACYCONN
block|,
name|SOUND_MIXER_LINE
block|}
block|,
block|{
name|UATE_DIGITALAUIFC
block|,
name|SOUND_MIXER_ALTPCM
block|}
block|,
block|{
name|UATE_SPDIF
block|,
name|SOUND_MIXER_ALTPCM
block|}
block|,
block|{
name|UATE_1394DA
block|,
name|SOUND_MIXER_ALTPCM
block|}
block|,
block|{
name|UATE_1394DV
block|,
name|SOUND_MIXER_ALTPCM
block|}
block|,
block|{
name|UATF_CDPLAYER
block|,
name|SOUND_MIXER_CD
block|}
block|,
block|{
name|UATF_SYNTHESIZER
block|,
name|SOUND_MIXER_SYNTH
block|}
block|,
block|{
name|UATF_VIDEODISCAUDIO
block|,
name|SOUND_MIXER_VIDEO
block|}
block|,
block|{
name|UATF_DVDAUDIO
block|,
name|SOUND_MIXER_VIDEO
block|}
block|,
block|{
name|UATF_TVTUNERAUDIO
block|,
name|SOUND_MIXER_VIDEO
block|}
block|,
comment|/* telephony terminal types */
block|{
name|UATT_UNDEFINED
block|,
name|SOUND_MIXER_PHONEIN
block|}
block|,
comment|/* SOUND_MIXER_PHONEOUT */
block|{
name|UATT_PHONELINE
block|,
name|SOUND_MIXER_PHONEIN
block|}
block|,
comment|/* SOUND_MIXER_PHONEOUT */
block|{
name|UATT_TELEPHONE
block|,
name|SOUND_MIXER_PHONEIN
block|}
block|,
comment|/* SOUND_MIXER_PHONEOUT */
block|{
name|UATT_DOWNLINEPHONE
block|,
name|SOUND_MIXER_PHONEIN
block|}
block|,
comment|/* SOUND_MIXER_PHONEOUT */
block|{
name|UATF_RADIORECV
block|,
name|SOUND_MIXER_RADIO
block|}
block|,
block|{
name|UATF_RADIOXMIT
block|,
name|SOUND_MIXER_RADIO
block|}
block|,
block|{
name|UAT_UNDEFINED
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UAT_VENDOR
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATI_UNDEFINED
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
comment|/* output terminal types */
block|{
name|UATO_UNDEFINED
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATO_DISPLAYAUDIO
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATO_SUBWOOFER
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATO_HEADPHONES
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
comment|/* bidir terminal types */
block|{
name|UATB_UNDEFINED
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATB_HANDSET
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATB_HEADSET
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATB_SPEAKERPHONE
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATB_SPEAKERPHONEESUP
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATB_SPEAKERPHONEECANC
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
comment|/* external terminal types */
block|{
name|UATE_UNDEFINED
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
comment|/* embedded function terminal types */
block|{
name|UATF_UNDEFINED
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_CALIBNOISE
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_EQUNOISE
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_DAT
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_DCC
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_MINIDISK
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_ANALOGTAPE
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_PHONOGRAPH
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_VCRAUDIO
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_SATELLITE
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_CABLETUNER
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_DSS
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_MULTITRACK
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
literal|0xffff
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
comment|/* default */
block|{
literal|0x0000
block|,
name|SOUND_MIXER_VOLUME
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|uint16_t
name|uaudio_mixer_feature_name
parameter_list|(
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
name|mix
parameter_list|)
block|{
specifier|const
name|struct
name|uaudio_tt_to_feature
modifier|*
name|uat
init|=
name|uaudio_tt_to_feature
decl_stmt|;
name|uint16_t
name|terminal_type
init|=
name|uaudio_mixer_determine_class
argument_list|(
name|iot
argument_list|,
name|mix
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|mix
operator|->
name|class
operator|==
name|UAC_RECORD
operator|)
operator|&&
operator|(
name|terminal_type
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|SOUND_MIXER_IMIX
operator|)
return|;
block|}
while|while
condition|(
name|uat
operator|->
name|terminal_type
condition|)
block|{
if|if
condition|(
name|uat
operator|->
name|terminal_type
operator|==
name|terminal_type
condition|)
block|{
break|break;
block|}
name|uat
operator|++
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"terminal_type=%s (0x%04x) -> %d\n"
argument_list|,
name|uaudio_mixer_get_terminal_name
argument_list|(
name|terminal_type
argument_list|)
argument_list|,
name|terminal_type
argument_list|,
name|uat
operator|->
name|feature
argument_list|)
expr_stmt|;
return|return
operator|(
name|uat
operator|->
name|feature
operator|)
return|;
block|}
end_function

begin_function
specifier|const
specifier|static
name|struct
name|uaudio_terminal_node
modifier|*
name|uaudio_mixer_get_input
parameter_list|(
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|uint8_t
name|index
parameter_list|)
block|{
name|struct
name|uaudio_terminal_node
modifier|*
name|root
init|=
name|iot
operator|->
name|root
decl_stmt|;
name|uint8_t
name|n
decl_stmt|;
name|n
operator|=
name|iot
operator|->
name|usr
operator|.
name|id_max
expr_stmt|;
do|do
block|{
if|if
condition|(
name|iot
operator|->
name|usr
operator|.
name|bit_input
index|[
name|n
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|n
operator|%
literal|8
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|index
operator|--
condition|)
block|{
return|return
operator|(
name|root
operator|+
name|n
operator|)
return|;
block|}
block|}
block|}
do|while
condition|(
name|n
operator|--
condition|)
do|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|const
specifier|static
name|struct
name|uaudio_terminal_node
modifier|*
name|uaudio_mixer_get_output
parameter_list|(
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|uint8_t
name|index
parameter_list|)
block|{
name|struct
name|uaudio_terminal_node
modifier|*
name|root
init|=
name|iot
operator|->
name|root
decl_stmt|;
name|uint8_t
name|n
decl_stmt|;
name|n
operator|=
name|iot
operator|->
name|usr
operator|.
name|id_max
expr_stmt|;
do|do
block|{
if|if
condition|(
name|iot
operator|->
name|usr
operator|.
name|bit_output
index|[
name|n
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|n
operator|%
literal|8
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|index
operator|--
condition|)
block|{
return|return
operator|(
name|root
operator|+
name|n
operator|)
return|;
block|}
block|}
block|}
do|while
condition|(
name|n
operator|--
condition|)
do|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_find_inputs_sub
parameter_list|(
name|struct
name|uaudio_terminal_node
modifier|*
name|root
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|p_id
parameter_list|,
name|uint8_t
name|n_id
parameter_list|,
name|struct
name|uaudio_search_result
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
decl_stmt|;
name|uint8_t
name|n
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|recurse_level
operator|>=
name|UAUDIO_RECURSE_LIMIT
condition|)
block|{
return|return;
block|}
name|info
operator|->
name|recurse_level
operator|++
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_id
condition|;
name|n
operator|++
control|)
block|{
name|i
operator|=
name|p_id
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|bit_visited
index|[
name|i
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|%
literal|8
operator|)
operator|)
condition|)
block|{
comment|/* don't go into a circle */
name|DPRINTF
argument_list|(
literal|"avoided going into a circle at id=%d!\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|info
operator|->
name|bit_visited
index|[
name|i
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
block|}
name|iot
operator|=
operator|(
name|root
operator|+
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|iot
operator|->
name|u
operator|.
name|desc
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
switch|switch
condition|(
name|iot
operator|->
name|u
operator|.
name|desc
operator|->
name|bDescriptorSubtype
condition|)
block|{
case|case
name|UDESCSUB_AC_INPUT
case|:
name|info
operator|->
name|bit_input
index|[
name|i
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_FEATURE
case|:
name|uaudio_mixer_find_inputs_sub
argument_list|(
name|root
argument_list|,
operator|&
name|iot
operator|->
name|u
operator|.
name|fu
operator|->
name|bSourceId
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_OUTPUT
case|:
name|uaudio_mixer_find_inputs_sub
argument_list|(
name|root
argument_list|,
operator|&
name|iot
operator|->
name|u
operator|.
name|ot
operator|->
name|bSourceId
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_MIXER
case|:
name|uaudio_mixer_find_inputs_sub
argument_list|(
name|root
argument_list|,
name|iot
operator|->
name|u
operator|.
name|mu
operator|->
name|baSourceId
argument_list|,
name|iot
operator|->
name|u
operator|.
name|mu
operator|->
name|bNrInPins
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_SELECTOR
case|:
name|uaudio_mixer_find_inputs_sub
argument_list|(
name|root
argument_list|,
name|iot
operator|->
name|u
operator|.
name|su
operator|->
name|baSourceId
argument_list|,
name|iot
operator|->
name|u
operator|.
name|su
operator|->
name|bNrInPins
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_PROCESSING
case|:
name|uaudio_mixer_find_inputs_sub
argument_list|(
name|root
argument_list|,
name|iot
operator|->
name|u
operator|.
name|pu
operator|->
name|baSourceId
argument_list|,
name|iot
operator|->
name|u
operator|.
name|pu
operator|->
name|bNrInPins
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_EXTENSION
case|:
name|uaudio_mixer_find_inputs_sub
argument_list|(
name|root
argument_list|,
name|iot
operator|->
name|u
operator|.
name|eu
operator|->
name|baSourceId
argument_list|,
name|iot
operator|->
name|u
operator|.
name|eu
operator|->
name|bNrInPins
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_HEADER
case|:
default|default:
break|break;
block|}
block|}
name|info
operator|->
name|recurse_level
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_find_outputs_sub
parameter_list|(
name|struct
name|uaudio_terminal_node
modifier|*
name|root
parameter_list|,
name|uint8_t
name|id
parameter_list|,
name|uint8_t
name|n_id
parameter_list|,
name|struct
name|uaudio_search_result
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
init|=
operator|(
name|root
operator|+
name|id
operator|)
decl_stmt|;
name|uint8_t
name|j
decl_stmt|;
name|j
operator|=
name|n_id
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|j
operator|!=
name|id
operator|)
operator|&&
operator|(
operator|(
name|root
operator|+
name|j
operator|)
operator|->
name|u
operator|.
name|desc
operator|)
operator|&&
operator|(
operator|(
name|root
operator|+
name|j
operator|)
operator|->
name|u
operator|.
name|desc
operator|->
name|bDescriptorSubtype
operator|==
name|UDESCSUB_AC_OUTPUT
operator|)
condition|)
block|{
comment|/* 			 * "j" (output)<--- virtual wire<--- "id" (input) 			 * 			 * if "j" has "id" on the input, then "id" have "j" on 			 * the output, because they are connected: 			 */
if|if
condition|(
operator|(
name|root
operator|+
name|j
operator|)
operator|->
name|usr
operator|.
name|bit_input
index|[
name|id
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|id
operator|%
literal|8
operator|)
operator|)
condition|)
block|{
name|iot
operator|->
name|usr
operator|.
name|bit_output
index|[
name|j
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|j
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|j
operator|--
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_fill_info
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|void
modifier|*
name|desc
parameter_list|)
block|{
specifier|const
name|struct
name|usb2_audio_control_descriptor
modifier|*
name|acdp
decl_stmt|;
name|struct
name|usb2_config_descriptor
modifier|*
name|cd
init|=
name|usb2_get_config_descriptor
argument_list|(
name|udev
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|usb2_descriptor
modifier|*
name|dp
decl_stmt|;
specifier|const
name|struct
name|usb2_audio_unit
modifier|*
name|au
decl_stmt|;
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|wTotalLen
decl_stmt|;
name|uint8_t
name|ID_max
init|=
literal|0
decl_stmt|;
comment|/* inclusive */
name|uint8_t
name|i
decl_stmt|;
name|desc
operator|=
name|usb2_desc_foreach
argument_list|(
name|cd
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"no Audio Control header\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|acdp
operator|=
name|desc
expr_stmt|;
if|if
condition|(
operator|(
name|acdp
operator|->
name|bLength
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|acdp
argument_list|)
operator|)
operator|||
operator|(
name|acdp
operator|->
name|bDescriptorType
operator|!=
name|UDESC_CS_INTERFACE
operator|)
operator|||
operator|(
name|acdp
operator|->
name|bDescriptorSubtype
operator|!=
name|UDESCSUB_AC_HEADER
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"invalid Audio Control header\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* "wTotalLen" is allowed to be corrupt */
name|wTotalLen
operator|=
name|UGETW
argument_list|(
name|acdp
operator|->
name|wTotalLength
argument_list|)
operator|-
name|acdp
operator|->
name|bLength
expr_stmt|;
comment|/* get USB audio revision */
name|sc
operator|->
name|sc_audio_rev
operator|=
name|UGETW
argument_list|(
name|acdp
operator|->
name|bcdADC
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"found AC header, vers=%03x, len=%d\n"
argument_list|,
name|sc
operator|->
name|sc_audio_rev
argument_list|,
name|wTotalLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_audio_rev
operator|!=
name|UAUDIO_VERSION
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_uq_bad_adc
condition|)
block|{  		}
else|else
block|{
name|DPRINTF
argument_list|(
literal|"invalid audio version\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|iot
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uaudio_terminal_node
argument_list|)
operator|*
literal|256
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|iot
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"no memory!\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
while|while
condition|(
operator|(
name|desc
operator|=
name|usb2_desc_foreach
argument_list|(
name|cd
argument_list|,
name|desc
argument_list|)
operator|)
condition|)
block|{
name|dp
operator|=
name|desc
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|bLength
operator|>
name|wTotalLen
condition|)
block|{
break|break;
block|}
else|else
block|{
name|wTotalLen
operator|-=
name|dp
operator|->
name|bLength
expr_stmt|;
block|}
name|au
operator|=
name|uaudio_mixer_verify_desc
argument_list|(
name|dp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|au
condition|)
block|{
name|iot
index|[
name|au
operator|->
name|bUnitId
index|]
operator|.
name|u
operator|.
name|desc
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|au
expr_stmt|;
if|if
condition|(
name|au
operator|->
name|bUnitId
operator|>
name|ID_max
condition|)
block|{
name|ID_max
operator|=
name|au
operator|->
name|bUnitId
expr_stmt|;
block|}
block|}
block|}
name|DPRINTF
argument_list|(
literal|"Maximum ID=%d\n"
argument_list|,
name|ID_max
argument_list|)
expr_stmt|;
comment|/* 	 * determine sourcing inputs for 	 * all nodes in the tree: 	 */
name|i
operator|=
name|ID_max
expr_stmt|;
do|do
block|{
name|uaudio_mixer_find_inputs_sub
argument_list|(
name|iot
argument_list|,
operator|&
name|i
argument_list|,
literal|1
argument_list|,
operator|&
operator|(
operator|(
name|iot
operator|+
name|i
operator|)
operator|->
name|usr
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|--
condition|)
do|;
comment|/* 	 * determine outputs for 	 * all nodes in the tree: 	 */
name|i
operator|=
name|ID_max
expr_stmt|;
do|do
block|{
name|uaudio_mixer_find_outputs_sub
argument_list|(
name|iot
argument_list|,
name|i
argument_list|,
name|ID_max
argument_list|,
operator|&
operator|(
operator|(
name|iot
operator|+
name|i
operator|)
operator|->
name|usr
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|--
condition|)
do|;
comment|/* set "id_max" and "root" */
name|i
operator|=
name|ID_max
expr_stmt|;
do|do
block|{
operator|(
name|iot
operator|+
name|i
operator|)
operator|->
name|usr
operator|.
name|id_max
operator|=
name|ID_max
expr_stmt|;
operator|(
name|iot
operator|+
name|i
operator|)
operator|->
name|root
operator|=
name|iot
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|--
condition|)
do|;
if|#
directive|if
name|USB_DEBUG
name|i
operator|=
name|ID_max
expr_stmt|;
do|do
block|{
name|uint8_t
name|j
decl_stmt|;
if|if
condition|(
name|iot
index|[
name|i
index|]
operator|.
name|u
operator|.
name|desc
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
name|DPRINTF
argument_list|(
literal|"id %d:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|iot
index|[
name|i
index|]
operator|.
name|u
operator|.
name|desc
operator|->
name|bDescriptorSubtype
condition|)
block|{
case|case
name|UDESCSUB_AC_INPUT
case|:
name|DPRINTF
argument_list|(
literal|" - AC_INPUT type=%s\n"
argument_list|,
name|uaudio_mixer_get_terminal_name
argument_list|(
name|UGETW
argument_list|(
name|iot
index|[
name|i
index|]
operator|.
name|u
operator|.
name|it
operator|->
name|wTerminalType
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|uaudio_mixer_dump_cluster
argument_list|(
name|i
argument_list|,
name|iot
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_OUTPUT
case|:
name|DPRINTF
argument_list|(
literal|" - AC_OUTPUT type=%s "
literal|"src=%d\n"
argument_list|,
name|uaudio_mixer_get_terminal_name
argument_list|(
name|UGETW
argument_list|(
name|iot
index|[
name|i
index|]
operator|.
name|u
operator|.
name|ot
operator|->
name|wTerminalType
argument_list|)
argument_list|)
argument_list|,
name|iot
index|[
name|i
index|]
operator|.
name|u
operator|.
name|ot
operator|->
name|bSourceId
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_MIXER
case|:
name|DPRINTF
argument_list|(
literal|" - AC_MIXER src:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|iot
index|[
name|i
index|]
operator|.
name|u
operator|.
name|mu
operator|->
name|bNrInPins
condition|;
name|j
operator|++
control|)
block|{
name|DPRINTF
argument_list|(
literal|"   - %d\n"
argument_list|,
name|iot
index|[
name|i
index|]
operator|.
name|u
operator|.
name|mu
operator|->
name|baSourceId
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|uaudio_mixer_dump_cluster
argument_list|(
name|i
argument_list|,
name|iot
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_SELECTOR
case|:
name|DPRINTF
argument_list|(
literal|" - AC_SELECTOR src:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|iot
index|[
name|i
index|]
operator|.
name|u
operator|.
name|su
operator|->
name|bNrInPins
condition|;
name|j
operator|++
control|)
block|{
name|DPRINTF
argument_list|(
literal|"   - %d\n"
argument_list|,
name|iot
index|[
name|i
index|]
operator|.
name|u
operator|.
name|su
operator|->
name|baSourceId
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UDESCSUB_AC_FEATURE
case|:
name|DPRINTF
argument_list|(
literal|" - AC_FEATURE src=%d\n"
argument_list|,
name|iot
index|[
name|i
index|]
operator|.
name|u
operator|.
name|fu
operator|->
name|bSourceId
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_PROCESSING
case|:
name|DPRINTF
argument_list|(
literal|" - AC_PROCESSING src:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|iot
index|[
name|i
index|]
operator|.
name|u
operator|.
name|pu
operator|->
name|bNrInPins
condition|;
name|j
operator|++
control|)
block|{
name|DPRINTF
argument_list|(
literal|"   - %d\n"
argument_list|,
name|iot
index|[
name|i
index|]
operator|.
name|u
operator|.
name|pu
operator|->
name|baSourceId
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|uaudio_mixer_dump_cluster
argument_list|(
name|i
argument_list|,
name|iot
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_EXTENSION
case|:
name|DPRINTF
argument_list|(
literal|" - AC_EXTENSION src:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|iot
index|[
name|i
index|]
operator|.
name|u
operator|.
name|eu
operator|->
name|bNrInPins
condition|;
name|j
operator|++
control|)
block|{
name|DPRINTF
argument_list|(
literal|"%d "
argument_list|,
name|iot
index|[
name|i
index|]
operator|.
name|u
operator|.
name|eu
operator|->
name|baSourceId
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|uaudio_mixer_dump_cluster
argument_list|(
name|i
argument_list|,
name|iot
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
literal|"unknown audio control (subtype=%d)\n"
argument_list|,
name|iot
index|[
name|i
index|]
operator|.
name|u
operator|.
name|desc
operator|->
name|bDescriptorSubtype
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"Inputs to this ID are:\n"
argument_list|)
expr_stmt|;
name|j
operator|=
name|ID_max
expr_stmt|;
do|do
block|{
if|if
condition|(
name|iot
index|[
name|i
index|]
operator|.
name|usr
operator|.
name|bit_input
index|[
name|j
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|j
operator|%
literal|8
operator|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"  -- ID=%d\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|j
operator|--
condition|)
do|;
name|DPRINTF
argument_list|(
literal|"Outputs from this ID are:\n"
argument_list|)
expr_stmt|;
name|j
operator|=
name|ID_max
expr_stmt|;
do|do
block|{
if|if
condition|(
name|iot
index|[
name|i
index|]
operator|.
name|usr
operator|.
name|bit_output
index|[
name|j
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|j
operator|%
literal|8
operator|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"  -- ID=%d\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|j
operator|--
condition|)
do|;
block|}
do|while
condition|(
name|i
operator|--
condition|)
do|;
endif|#
directive|endif
comment|/* 	 * scan the config to create a linked 	 * list of "mixer" nodes: 	 */
name|i
operator|=
name|ID_max
expr_stmt|;
do|do
block|{
name|dp
operator|=
name|iot
index|[
name|i
index|]
operator|.
name|u
operator|.
name|desc
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"id=%d subtype=%d\n"
argument_list|,
name|i
argument_list|,
name|dp
operator|->
name|bDescriptorSubtype
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dp
operator|->
name|bDescriptorSubtype
condition|)
block|{
case|case
name|UDESCSUB_AC_HEADER
case|:
name|DPRINTF
argument_list|(
literal|"unexpected AC header\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_INPUT
case|:
name|uaudio_mixer_add_input
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_OUTPUT
case|:
name|uaudio_mixer_add_output
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_MIXER
case|:
name|uaudio_mixer_add_mixer
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_SELECTOR
case|:
name|uaudio_mixer_add_selector
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_FEATURE
case|:
name|uaudio_mixer_add_feature
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_PROCESSING
case|:
name|uaudio_mixer_add_processing
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_EXTENSION
case|:
name|uaudio_mixer_add_extension
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
literal|"bad AC desc subtype=0x%02x\n"
argument_list|,
name|dp
operator|->
name|bDescriptorSubtype
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|i
operator|--
condition|)
do|;
name|done
label|:
if|if
condition|(
name|iot
condition|)
block|{
name|free
argument_list|(
name|iot
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|uaudio_mixer_get
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|what
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
name|mc
parameter_list|)
block|{
name|struct
name|usb2_device_request
name|req
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|uint16_t
name|len
init|=
name|MIX_SIZE
argument_list|(
name|mc
operator|->
name|type
argument_list|)
decl_stmt|;
name|uint8_t
name|data
index|[
literal|4
index|]
decl_stmt|;
name|usb2_error_t
name|err
decl_stmt|;
if|if
condition|(
name|mc
operator|->
name|wValue
index|[
literal|0
index|]
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|req
operator|.
name|bmRequestType
operator|=
name|UT_READ_CLASS_INTERFACE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|what
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|mc
operator|->
name|wValue
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|mc
operator|->
name|wIndex
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb2_do_request
argument_list|(
name|udev
argument_list|,
operator|&
name|Giant
argument_list|,
operator|&
name|req
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"err=%s\n"
argument_list|,
name|usb2_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|<
literal|1
condition|)
block|{
name|data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<
literal|2
condition|)
block|{
name|data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|val
operator|=
operator|(
name|data
index|[
literal|0
index|]
operator||
operator|(
name|data
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"val=%d\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_write_cfg_callback
parameter_list|(
name|struct
name|usb2_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|usb2_device_request
name|req
decl_stmt|;
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|xfer
operator|->
name|priv_sc
decl_stmt|;
name|struct
name|uaudio_mixer_node
modifier|*
name|mc
init|=
name|sc
operator|->
name|sc_mixer_curr
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|uint8_t
name|repeat
init|=
literal|1
decl_stmt|;
name|uint8_t
name|update
decl_stmt|;
name|uint8_t
name|chan
decl_stmt|;
name|uint8_t
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|tr_transferred
label|:
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
block|{
name|mc
operator|=
name|sc
operator|->
name|sc_mixer_root
expr_stmt|;
name|sc
operator|->
name|sc_mixer_curr
operator|=
name|mc
expr_stmt|;
name|sc
operator|->
name|sc_mixer_chan
operator|=
literal|0
expr_stmt|;
name|repeat
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|mc
condition|)
block|{
while|while
condition|(
name|sc
operator|->
name|sc_mixer_chan
operator|<
name|mc
operator|->
name|nchan
condition|)
block|{
name|len
operator|=
name|MIX_SIZE
argument_list|(
name|mc
operator|->
name|type
argument_list|)
expr_stmt|;
name|chan
operator|=
name|sc
operator|->
name|sc_mixer_chan
expr_stmt|;
name|sc
operator|->
name|sc_mixer_chan
operator|++
expr_stmt|;
name|update
operator|=
operator|(
operator|(
name|mc
operator|->
name|update
index|[
name|chan
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|chan
operator|%
literal|8
operator|)
operator|)
operator|)
operator|&&
operator|(
name|mc
operator|->
name|wValue
index|[
name|chan
index|]
operator|!=
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|mc
operator|->
name|update
index|[
name|chan
operator|/
literal|8
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|chan
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|update
condition|)
block|{
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_CLASS_INTERFACE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|SET_CUR
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|mc
operator|->
name|wValue
index|[
name|chan
index|]
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|mc
operator|->
name|wIndex
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|mc
operator|->
name|wData
index|[
name|chan
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|buf
index|[
literal|1
index|]
operator|=
operator|(
name|mc
operator|->
name|wData
index|[
name|chan
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
block|}
name|usb2_copy_in
argument_list|(
name|xfer
operator|->
name|frbuffers
argument_list|,
literal|0
argument_list|,
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|usb2_copy_in
argument_list|(
name|xfer
operator|->
name|frbuffers
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|frlengths
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|frlengths
index|[
literal|1
index|]
operator|=
name|len
expr_stmt|;
name|xfer
operator|->
name|nframes
operator|=
name|xfer
operator|->
name|frlengths
index|[
literal|1
index|]
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|usb2_start_hardware
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|mc
operator|=
name|mc
operator|->
name|next
expr_stmt|;
name|sc
operator|->
name|sc_mixer_curr
operator|=
name|mc
expr_stmt|;
name|sc
operator|->
name|sc_mixer_chan
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|repeat
condition|)
block|{
goto|goto
name|tr_setup
goto|;
block|}
break|break;
default|default:
comment|/* Error */
name|DPRINTF
argument_list|(
literal|"error=%s\n"
argument_list|,
name|usb2_errstr
argument_list|(
name|xfer
operator|->
name|error
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
comment|/* do nothing - we are detaching */
break|break;
block|}
goto|goto
name|tr_transferred
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|usb2_error_t
name|uaudio_set_speed
parameter_list|(
name|struct
name|usb2_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|endpt
parameter_list|,
name|uint32_t
name|speed
parameter_list|)
block|{
name|struct
name|usb2_device_request
name|req
decl_stmt|;
name|uint8_t
name|data
index|[
literal|3
index|]
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"endpt=%d speed=%u\n"
argument_list|,
name|endpt
argument_list|,
name|speed
argument_list|)
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_CLASS_ENDPOINT
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|SET_CUR
expr_stmt|;
name|USETW2
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|SAMPLING_FREQ_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|endpt
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
name|speed
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|speed
operator|>>
literal|8
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
name|speed
operator|>>
literal|16
expr_stmt|;
return|return
operator|(
name|usb2_do_request
argument_list|(
name|udev
argument_list|,
operator|&
name|Giant
argument_list|,
operator|&
name|req
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_mixer_signext
parameter_list|(
name|uint8_t
name|type
parameter_list|,
name|int
name|val
parameter_list|)
block|{
if|if
condition|(
operator|!
name|MIX_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|MIX_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|2
condition|)
block|{
name|val
operator|=
operator|(
name|int16_t
operator|)
name|val
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
operator|(
name|int8_t
operator|)
name|val
expr_stmt|;
block|}
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_mixer_bsd2value
parameter_list|(
name|struct
name|uaudio_mixer_node
modifier|*
name|mc
parameter_list|,
name|int32_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_ON_OFF
condition|)
block|{
name|val
operator|=
operator|(
name|val
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_SELECTOR
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|<
name|mc
operator|->
name|minval
operator|)
operator|||
operator|(
name|val
operator|>
name|mc
operator|->
name|maxval
operator|)
condition|)
block|{
name|val
operator|=
name|mc
operator|->
name|minval
expr_stmt|;
block|}
block|}
else|else
block|{
name|val
operator|=
operator|(
operator|(
operator|(
name|val
operator|+
operator|(
name|mc
operator|->
name|delta
operator|/
literal|2
operator|)
operator|)
operator|*
name|mc
operator|->
name|mul
operator|)
operator|/
literal|255
operator|)
operator|+
name|mc
operator|->
name|minval
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"type=0x%03x val=%d min=%d max=%d val=%d\n"
argument_list|,
name|mc
operator|->
name|type
argument_list|,
name|val
argument_list|,
name|mc
operator|->
name|minval
argument_list|,
name|mc
operator|->
name|maxval
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_ctl_set
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
name|mc
parameter_list|,
name|uint8_t
name|chan
parameter_list|,
name|int32_t
name|val
parameter_list|)
block|{
name|val
operator|=
name|uaudio_mixer_bsd2value
argument_list|(
name|mc
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|mc
operator|->
name|update
index|[
name|chan
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|chan
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
name|mc
operator|->
name|wData
index|[
name|chan
index|]
operator|=
name|val
expr_stmt|;
comment|/* start the transfer, if not already started */
name|usb2_transfer_start
argument_list|(
name|sc
operator|->
name|sc_mixer_xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_init
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|uaudio_mixer_node
modifier|*
name|mc
decl_stmt|;
name|int32_t
name|i
decl_stmt|;
for|for
control|(
name|mc
operator|=
name|sc
operator|->
name|sc_mixer_root
init|;
name|mc
condition|;
name|mc
operator|=
name|mc
operator|->
name|next
control|)
block|{
if|if
condition|(
name|mc
operator|->
name|ctl
operator|!=
name|SOUND_MIXER_NRDEVICES
condition|)
block|{
comment|/* 			 * Set device mask bits. See 			 * /usr/include/machine/soundcard.h 			 */
name|sc
operator|->
name|sc_mix_info
operator||=
operator|(
literal|1
operator|<<
name|mc
operator|->
name|ctl
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mc
operator|->
name|ctl
operator|==
name|SOUND_MIXER_NRDEVICES
operator|)
operator|&&
operator|(
name|mc
operator|->
name|type
operator|==
name|MIX_SELECTOR
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|mc
operator|->
name|minval
init|;
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<=
name|mc
operator|->
name|maxval
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mc
operator|->
name|slctrtype
index|[
name|i
operator|-
literal|1
index|]
operator|==
name|SOUND_MIXER_NRDEVICES
condition|)
block|{
continue|continue;
block|}
name|sc
operator|->
name|sc_recsrc_info
operator||=
literal|1
operator|<<
name|mc
operator|->
name|slctrtype
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|int
name|uaudio_mixer_init_sub
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usb2_transfer_setup
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|sc
operator|->
name|sc_mixer_iface_index
argument_list|,
name|sc
operator|->
name|sc_mixer_xfer
argument_list|,
name|uaudio_mixer_config
argument_list|,
literal|1
argument_list|,
name|sc
argument_list|,
name|mixer_get_lock
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"could not allocate USB "
literal|"transfer for audio mixer!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_mix_info
operator|&
name|SOUND_MASK_VOLUME
operator|)
condition|)
block|{
name|mix_setparentchild
argument_list|(
name|m
argument_list|,
name|SOUND_MIXER_VOLUME
argument_list|,
name|SOUND_MASK_PCM
argument_list|)
expr_stmt|;
name|mix_setrealdev
argument_list|(
name|m
argument_list|,
name|SOUND_MIXER_VOLUME
argument_list|,
name|SOUND_MIXER_NONE
argument_list|)
expr_stmt|;
block|}
name|mix_setdevs
argument_list|(
name|m
argument_list|,
name|sc
operator|->
name|sc_mix_info
argument_list|)
expr_stmt|;
name|mix_setrecdevs
argument_list|(
name|m
argument_list|,
name|sc
operator|->
name|sc_recsrc_info
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_mixer_uninit_sub
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|usb2_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_mixer_xfer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uaudio_mixer_set
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|type
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|right
parameter_list|)
block|{
name|struct
name|uaudio_mixer_node
modifier|*
name|mc
decl_stmt|;
for|for
control|(
name|mc
operator|=
name|sc
operator|->
name|sc_mixer_root
init|;
name|mc
condition|;
name|mc
operator|=
name|mc
operator|->
name|next
control|)
block|{
if|if
condition|(
name|mc
operator|->
name|ctl
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|mc
operator|->
name|nchan
operator|==
literal|2
condition|)
block|{
comment|/* set Right */
name|uaudio_mixer_ctl_set
argument_list|(
name|sc
argument_list|,
name|mc
argument_list|,
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|right
operator|*
literal|255
argument_list|)
operator|/
literal|100
argument_list|)
expr_stmt|;
block|}
comment|/* set Left or Mono */
name|uaudio_mixer_ctl_set
argument_list|(
name|sc
argument_list|,
name|mc
argument_list|,
literal|0
argument_list|,
call|(
name|int
call|)
argument_list|(
name|left
operator|*
literal|255
argument_list|)
operator|/
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|uint32_t
name|uaudio_mixer_setrecsrc
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|src
parameter_list|)
block|{
name|struct
name|uaudio_mixer_node
modifier|*
name|mc
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|int32_t
name|i
decl_stmt|;
for|for
control|(
name|mc
operator|=
name|sc
operator|->
name|sc_mixer_root
init|;
name|mc
condition|;
name|mc
operator|=
name|mc
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|mc
operator|->
name|ctl
operator|==
name|SOUND_MIXER_NRDEVICES
operator|)
operator|&&
operator|(
name|mc
operator|->
name|type
operator|==
name|MIX_SELECTOR
operator|)
condition|)
block|{
comment|/* compute selector mask */
name|mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|mc
operator|->
name|minval
init|;
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<=
name|mc
operator|->
name|maxval
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|mask
operator||=
operator|(
literal|1
operator|<<
name|mc
operator|->
name|slctrtype
index|[
name|i
operator|-
literal|1
index|]
operator|)
expr_stmt|;
block|}
name|temp
operator|=
name|mask
operator|&
name|src
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* find the first set bit */
name|temp
operator|=
operator|(
operator|-
name|temp
operator|)
operator|&
name|temp
expr_stmt|;
comment|/* update "src" */
name|src
operator|&=
operator|~
name|mask
expr_stmt|;
name|src
operator||=
name|temp
expr_stmt|;
for|for
control|(
name|i
operator|=
name|mc
operator|->
name|minval
init|;
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<=
name|mc
operator|->
name|maxval
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|temp
operator|!=
operator|(
literal|1
operator|<<
name|mc
operator|->
name|slctrtype
index|[
name|i
operator|-
literal|1
index|]
operator|)
condition|)
block|{
continue|continue;
block|}
name|uaudio_mixer_ctl_set
argument_list|(
name|sc
argument_list|,
name|mc
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|(
name|src
operator|)
return|;
block|}
end_function

begin_comment
comment|/*========================================================================*  * MIDI support routines  *========================================================================*/
end_comment

begin_function
specifier|static
name|void
name|umidi_read_clear_stall_callback
parameter_list|(
name|struct
name|usb2_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
name|xfer
operator|->
name|priv_sc
decl_stmt|;
name|struct
name|usb2_xfer
modifier|*
name|xfer_other
init|=
name|chan
operator|->
name|xfer
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|usb2_clear_stall_callback
argument_list|(
name|xfer
argument_list|,
name|xfer_other
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"stall cleared\n"
argument_list|)
expr_stmt|;
name|chan
operator|->
name|flags
operator|&=
operator|~
name|UMIDI_FLAG_READ_STALL
expr_stmt|;
name|usb2_transfer_start
argument_list|(
name|xfer_other
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umidi_bulk_read_callback
parameter_list|(
name|struct
name|usb2_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
name|xfer
operator|->
name|priv_sc
decl_stmt|;
name|struct
name|umidi_sub_chan
modifier|*
name|sub
decl_stmt|;
name|uint8_t
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|uint8_t
name|cmd_len
decl_stmt|;
name|uint8_t
name|cn
decl_stmt|;
name|uint16_t
name|pos
decl_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|DPRINTF
argument_list|(
literal|"actlen=%d bytes\n"
argument_list|,
name|xfer
operator|->
name|actlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|actlen
operator|==
literal|0
condition|)
block|{
comment|/* should not happen */
goto|goto
name|tr_error
goto|;
block|}
name|pos
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|xfer
operator|->
name|actlen
operator|>=
literal|4
condition|)
block|{
name|usb2_copy_out
argument_list|(
name|xfer
operator|->
name|frbuffers
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cmd_len
operator|=
name|umidi_cmd_to_len
index|[
name|buf
index|[
literal|0
index|]
operator|&
literal|0xF
index|]
expr_stmt|;
comment|/* command length */
name|cn
operator|=
name|buf
index|[
literal|0
index|]
operator|>>
literal|4
expr_stmt|;
comment|/* cable number */
name|sub
operator|=
operator|&
name|chan
operator|->
name|sub
index|[
name|cn
index|]
expr_stmt|;
if|if
condition|(
name|cmd_len
operator|&&
operator|(
name|cn
operator|<
name|chan
operator|->
name|max_cable
operator|)
operator|&&
name|sub
operator|->
name|read_open
condition|)
block|{
name|usb2_fifo_put_data
argument_list|(
name|sub
operator|->
name|fifo
operator|.
name|fp
index|[
name|USB_FIFO_RX
index|]
argument_list|,
name|xfer
operator|->
name|frbuffers
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
name|cmd_len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ignore the command */
block|}
name|xfer
operator|->
name|actlen
operator|-=
literal|4
expr_stmt|;
name|pos
operator|+=
literal|4
expr_stmt|;
block|}
case|case
name|USB_ST_SETUP
case|:
name|DPRINTF
argument_list|(
literal|"start\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|flags
operator|&
name|UMIDI_FLAG_READ_STALL
condition|)
block|{
name|usb2_transfer_start
argument_list|(
name|chan
operator|->
name|xfer
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|xfer
operator|->
name|frlengths
index|[
literal|0
index|]
operator|=
name|xfer
operator|->
name|max_data_length
expr_stmt|;
name|usb2_start_hardware
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
default|default:
name|tr_error
label|:
name|DPRINTF
argument_list|(
literal|"error=%s\n"
argument_list|,
name|usb2_errstr
argument_list|(
name|xfer
operator|->
name|error
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
comment|/* try to clear stall first */
name|chan
operator|->
name|flags
operator||=
name|UMIDI_FLAG_READ_STALL
expr_stmt|;
name|usb2_transfer_start
argument_list|(
name|chan
operator|->
name|xfer
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umidi_write_clear_stall_callback
parameter_list|(
name|struct
name|usb2_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
name|xfer
operator|->
name|priv_sc
decl_stmt|;
name|struct
name|usb2_xfer
modifier|*
name|xfer_other
init|=
name|chan
operator|->
name|xfer
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|usb2_clear_stall_callback
argument_list|(
name|xfer
argument_list|,
name|xfer_other
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"stall cleared\n"
argument_list|)
expr_stmt|;
name|chan
operator|->
name|flags
operator|&=
operator|~
name|UMIDI_FLAG_WRITE_STALL
expr_stmt|;
name|usb2_transfer_start
argument_list|(
name|xfer_other
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The following statemachine, that converts MIDI commands to  * USB MIDI packets, derives from Linux's usbmidi.c, which  * was written by "Clemens Ladisch":  *  * Returns:  *    0: No command  * Else: Command is complete  */
end_comment

begin_function
specifier|static
name|uint8_t
name|umidi_convert_to_usb
parameter_list|(
name|struct
name|umidi_sub_chan
modifier|*
name|sub
parameter_list|,
name|uint8_t
name|cn
parameter_list|,
name|uint8_t
name|b
parameter_list|)
block|{
name|uint8_t
name|p0
init|=
operator|(
name|cn
operator|<<
literal|4
operator|)
decl_stmt|;
if|if
condition|(
name|b
operator|>=
literal|0xf8
condition|)
block|{
name|sub
operator|->
name|temp_0
index|[
literal|0
index|]
operator|=
name|p0
operator||
literal|0x0f
expr_stmt|;
name|sub
operator|->
name|temp_0
index|[
literal|1
index|]
operator|=
name|b
expr_stmt|;
name|sub
operator|->
name|temp_0
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|sub
operator|->
name|temp_0
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|sub
operator|->
name|temp_cmd
operator|=
name|sub
operator|->
name|temp_0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|b
operator|>=
literal|0xf0
condition|)
block|{
switch|switch
condition|(
name|b
condition|)
block|{
case|case
literal|0xf0
case|:
comment|/* system exclusive begin */
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|=
name|b
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_SYSEX_1
expr_stmt|;
break|break;
case|case
literal|0xf1
case|:
comment|/* MIDI time code */
case|case
literal|0xf3
case|:
comment|/* song select */
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|=
name|b
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_1PARAM
expr_stmt|;
break|break;
case|case
literal|0xf2
case|:
comment|/* song position pointer */
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|=
name|b
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_2PARAM_1
expr_stmt|;
break|break;
case|case
literal|0xf4
case|:
comment|/* unknown */
case|case
literal|0xf5
case|:
comment|/* unknown */
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_UNKNOWN
expr_stmt|;
break|break;
case|case
literal|0xf6
case|:
comment|/* tune request */
name|sub
operator|->
name|temp_1
index|[
literal|0
index|]
operator|=
name|p0
operator||
literal|0x05
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|=
literal|0xf6
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|sub
operator|->
name|temp_cmd
operator|=
name|sub
operator|->
name|temp_1
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_UNKNOWN
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|0xf7
case|:
comment|/* system exclusive end */
switch|switch
condition|(
name|sub
operator|->
name|state
condition|)
block|{
case|case
name|UMIDI_ST_SYSEX_0
case|:
name|sub
operator|->
name|temp_1
index|[
literal|0
index|]
operator|=
name|p0
operator||
literal|0x05
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|=
literal|0xf7
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|sub
operator|->
name|temp_cmd
operator|=
name|sub
operator|->
name|temp_1
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_UNKNOWN
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|UMIDI_ST_SYSEX_1
case|:
name|sub
operator|->
name|temp_1
index|[
literal|0
index|]
operator|=
name|p0
operator||
literal|0x06
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|2
index|]
operator|=
literal|0xf7
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|sub
operator|->
name|temp_cmd
operator|=
name|sub
operator|->
name|temp_1
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_UNKNOWN
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|UMIDI_ST_SYSEX_2
case|:
name|sub
operator|->
name|temp_1
index|[
literal|0
index|]
operator|=
name|p0
operator||
literal|0x07
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|3
index|]
operator|=
literal|0xf7
expr_stmt|;
name|sub
operator|->
name|temp_cmd
operator|=
name|sub
operator|->
name|temp_1
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_UNKNOWN
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_UNKNOWN
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|b
operator|>=
literal|0x80
condition|)
block|{
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|=
name|b
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|>=
literal|0xc0
operator|)
operator|&&
operator|(
name|b
operator|<=
literal|0xdf
operator|)
condition|)
block|{
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_1PARAM
expr_stmt|;
block|}
else|else
block|{
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_2PARAM_1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* b< 0x80 */
switch|switch
condition|(
name|sub
operator|->
name|state
condition|)
block|{
case|case
name|UMIDI_ST_1PARAM
case|:
if|if
condition|(
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|<
literal|0xf0
condition|)
block|{
name|p0
operator||=
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|>>
literal|4
expr_stmt|;
block|}
else|else
block|{
name|p0
operator||=
literal|0x02
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_UNKNOWN
expr_stmt|;
block|}
name|sub
operator|->
name|temp_1
index|[
literal|0
index|]
operator|=
name|p0
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|2
index|]
operator|=
name|b
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|sub
operator|->
name|temp_cmd
operator|=
name|sub
operator|->
name|temp_1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|UMIDI_ST_2PARAM_1
case|:
name|sub
operator|->
name|temp_1
index|[
literal|2
index|]
operator|=
name|b
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_2PARAM_2
expr_stmt|;
break|break;
case|case
name|UMIDI_ST_2PARAM_2
case|:
if|if
condition|(
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|<
literal|0xf0
condition|)
block|{
name|p0
operator||=
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|>>
literal|4
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_2PARAM_1
expr_stmt|;
block|}
else|else
block|{
name|p0
operator||=
literal|0x03
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_UNKNOWN
expr_stmt|;
block|}
name|sub
operator|->
name|temp_1
index|[
literal|0
index|]
operator|=
name|p0
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|3
index|]
operator|=
name|b
expr_stmt|;
name|sub
operator|->
name|temp_cmd
operator|=
name|sub
operator|->
name|temp_1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|UMIDI_ST_SYSEX_0
case|:
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|=
name|b
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_SYSEX_1
expr_stmt|;
break|break;
case|case
name|UMIDI_ST_SYSEX_1
case|:
name|sub
operator|->
name|temp_1
index|[
literal|2
index|]
operator|=
name|b
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_SYSEX_2
expr_stmt|;
break|break;
case|case
name|UMIDI_ST_SYSEX_2
case|:
name|sub
operator|->
name|temp_1
index|[
literal|0
index|]
operator|=
name|p0
operator||
literal|0x04
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|3
index|]
operator|=
name|b
expr_stmt|;
name|sub
operator|->
name|temp_cmd
operator|=
name|sub
operator|->
name|temp_1
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_SYSEX_0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|umidi_bulk_write_callback
parameter_list|(
name|struct
name|usb2_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
name|xfer
operator|->
name|priv_sc
decl_stmt|;
name|struct
name|umidi_sub_chan
modifier|*
name|sub
decl_stmt|;
name|uint32_t
name|actlen
decl_stmt|;
name|uint16_t
name|total_length
decl_stmt|;
name|uint8_t
name|buf
decl_stmt|;
name|uint8_t
name|start_cable
decl_stmt|;
name|uint8_t
name|tr_any
decl_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|DPRINTF
argument_list|(
literal|"actlen=%d bytes\n"
argument_list|,
name|xfer
operator|->
name|actlen
argument_list|)
expr_stmt|;
case|case
name|USB_ST_SETUP
case|:
name|DPRINTF
argument_list|(
literal|"start\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|flags
operator|&
name|UMIDI_FLAG_WRITE_STALL
condition|)
block|{
name|usb2_transfer_start
argument_list|(
name|chan
operator|->
name|xfer
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|total_length
operator|=
literal|0
expr_stmt|;
comment|/* reset */
name|start_cable
operator|=
name|chan
operator|->
name|curr_cable
expr_stmt|;
name|tr_any
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* round robin de-queueing */
name|sub
operator|=
operator|&
name|chan
operator|->
name|sub
index|[
name|chan
operator|->
name|curr_cable
index|]
expr_stmt|;
if|if
condition|(
name|sub
operator|->
name|write_open
condition|)
block|{
name|usb2_fifo_get_data
argument_list|(
name|sub
operator|->
name|fifo
operator|.
name|fp
index|[
name|USB_FIFO_TX
index|]
argument_list|,
name|xfer
operator|->
name|frbuffers
argument_list|,
name|total_length
argument_list|,
literal|1
argument_list|,
operator|&
name|actlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|actlen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|actlen
condition|)
block|{
name|usb2_copy_out
argument_list|(
name|xfer
operator|->
name|frbuffers
argument_list|,
name|total_length
argument_list|,
operator|&
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tr_any
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"byte=0x%02x\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|umidi_convert_to_usb
argument_list|(
name|sub
argument_list|,
name|chan
operator|->
name|curr_cable
argument_list|,
name|buf
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"sub= %02x %02x %02x %02x\n"
argument_list|,
name|sub
operator|->
name|temp_cmd
index|[
literal|0
index|]
argument_list|,
name|sub
operator|->
name|temp_cmd
index|[
literal|1
index|]
argument_list|,
name|sub
operator|->
name|temp_cmd
index|[
literal|2
index|]
argument_list|,
name|sub
operator|->
name|temp_cmd
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|usb2_copy_in
argument_list|(
name|xfer
operator|->
name|frbuffers
argument_list|,
name|total_length
argument_list|,
name|sub
operator|->
name|temp_cmd
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|total_length
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|total_length
operator|>=
name|UMIDI_BULK_SIZE
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
continue|continue;
block|}
block|}
name|chan
operator|->
name|curr_cable
operator|++
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|curr_cable
operator|>=
name|chan
operator|->
name|max_cable
condition|)
block|{
name|chan
operator|->
name|curr_cable
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|chan
operator|->
name|curr_cable
operator|==
name|start_cable
condition|)
block|{
if|if
condition|(
name|tr_any
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|tr_any
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|total_length
condition|)
block|{
name|xfer
operator|->
name|frlengths
index|[
literal|0
index|]
operator|=
name|total_length
expr_stmt|;
name|usb2_start_hardware
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
comment|/* Error */
name|DPRINTF
argument_list|(
literal|"error=%s\n"
argument_list|,
name|usb2_errstr
argument_list|(
name|xfer
operator|->
name|error
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
comment|/* try to clear stall first */
name|chan
operator|->
name|flags
operator||=
name|UMIDI_FLAG_WRITE_STALL
expr_stmt|;
name|usb2_transfer_start
argument_list|(
name|chan
operator|->
name|xfer
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|umidi_sub_chan
modifier|*
name|umidi_sub_by_fifo
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
name|fifo
operator|->
name|priv_sc0
decl_stmt|;
name|struct
name|umidi_sub_chan
modifier|*
name|sub
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|UMIDI_CABLES_MAX
condition|;
name|n
operator|++
control|)
block|{
name|sub
operator|=
operator|&
name|chan
operator|->
name|sub
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sub
operator|->
name|fifo
operator|.
name|fp
index|[
name|USB_FIFO_RX
index|]
operator|==
name|fifo
operator|)
operator|||
operator|(
name|sub
operator|->
name|fifo
operator|.
name|fp
index|[
name|USB_FIFO_TX
index|]
operator|==
name|fifo
operator|)
condition|)
block|{
return|return
operator|(
name|sub
operator|)
return|;
block|}
block|}
name|panic
argument_list|(
literal|"%s:%d cannot find usb2_fifo!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|umidi_start_read
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
name|fifo
operator|->
name|priv_sc0
decl_stmt|;
name|usb2_transfer_start
argument_list|(
name|chan
operator|->
name|xfer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umidi_stop_read
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
name|fifo
operator|->
name|priv_sc0
decl_stmt|;
name|struct
name|umidi_sub_chan
modifier|*
name|sub
init|=
name|umidi_sub_by_fifo
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sub
operator|->
name|read_open
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|--
operator|(
name|chan
operator|->
name|read_open_refcount
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * XXX don't stop the read transfer here, hence that causes 		 * problems with some MIDI adapters 		 */
name|DPRINTF
argument_list|(
literal|"(stopping read transfer)\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umidi_start_write
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
name|fifo
operator|->
name|priv_sc0
decl_stmt|;
name|usb2_transfer_start
argument_list|(
name|chan
operator|->
name|xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umidi_stop_write
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
name|fifo
operator|->
name|priv_sc0
decl_stmt|;
name|struct
name|umidi_sub_chan
modifier|*
name|sub
init|=
name|umidi_sub_by_fifo
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sub
operator|->
name|write_open
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|--
operator|(
name|chan
operator|->
name|write_open_refcount
operator|)
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"(stopping write transfer)\n"
argument_list|)
expr_stmt|;
name|usb2_transfer_stop
argument_list|(
name|chan
operator|->
name|xfer
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|usb2_transfer_stop
argument_list|(
name|chan
operator|->
name|xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|umidi_open
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|fifo
parameter_list|,
name|int
name|fflags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
name|fifo
operator|->
name|priv_sc0
decl_stmt|;
name|struct
name|umidi_sub_chan
modifier|*
name|sub
init|=
name|umidi_sub_by_fifo
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
if|if
condition|(
name|fflags
operator|&
name|FREAD
condition|)
block|{
if|if
condition|(
name|usb2_fifo_alloc_buffer
argument_list|(
name|fifo
argument_list|,
literal|4
argument_list|,
operator|(
literal|1024
operator|/
literal|4
operator|)
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
name|fifo
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
name|chan
operator|->
name|read_open_refcount
operator|++
expr_stmt|;
name|sub
operator|->
name|read_open
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
name|fifo
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fflags
operator|&
name|FWRITE
condition|)
block|{
if|if
condition|(
name|usb2_fifo_alloc_buffer
argument_list|(
name|fifo
argument_list|,
literal|32
argument_list|,
operator|(
literal|1024
operator|/
literal|32
operator|)
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* clear stall first */
name|mtx_lock
argument_list|(
name|fifo
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
name|chan
operator|->
name|flags
operator||=
name|UMIDI_FLAG_WRITE_STALL
expr_stmt|;
name|chan
operator|->
name|write_open_refcount
operator|++
expr_stmt|;
name|sub
operator|->
name|write_open
operator|=
literal|1
expr_stmt|;
comment|/* reset */
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_UNKNOWN
expr_stmt|;
name|mtx_unlock
argument_list|(
name|fifo
operator|->
name|priv_mtx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_function
specifier|static
name|void
name|umidi_close
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|fifo
parameter_list|,
name|int
name|fflags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
if|if
condition|(
name|fflags
operator|&
name|FREAD
condition|)
block|{
name|usb2_fifo_free_buffer
argument_list|(
name|fifo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fflags
operator|&
name|FWRITE
condition|)
block|{
name|usb2_fifo_free_buffer
argument_list|(
name|fifo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|umidi_ioctl
parameter_list|(
name|struct
name|usb2_fifo
modifier|*
name|fifo
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|fflags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|umidi_init
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_midi_chan
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|chan
operator|->
name|mtx
argument_list|,
literal|"umidi lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|usb2_fifo_methods
name|umidi_fifo_methods
init|=
block|{
operator|.
name|f_start_read
operator|=
operator|&
name|umidi_start_read
block|,
operator|.
name|f_start_write
operator|=
operator|&
name|umidi_start_write
block|,
operator|.
name|f_stop_read
operator|=
operator|&
name|umidi_stop_read
block|,
operator|.
name|f_stop_write
operator|=
operator|&
name|umidi_stop_write
block|,
operator|.
name|f_open
operator|=
operator|&
name|umidi_open
block|,
operator|.
name|f_close
operator|=
operator|&
name|umidi_close
block|,
operator|.
name|f_ioctl
operator|=
operator|&
name|umidi_ioctl
block|,
operator|.
name|basename
index|[
literal|0
index|]
operator|=
literal|"umidi"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int32_t
name|umidi_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb2_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_midi_chan
decl_stmt|;
name|struct
name|umidi_sub_chan
modifier|*
name|sub
decl_stmt|;
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
if|if
condition|(
name|usb2_set_alt_interface_index
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|chan
operator|->
name|iface_index
argument_list|,
name|chan
operator|->
name|iface_alt_index
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"setting of alternate index failed!\n"
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
name|usb2_set_parent_iface
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|chan
operator|->
name|iface_index
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_index
argument_list|)
expr_stmt|;
name|error
operator|=
name|usb2_transfer_setup
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|chan
operator|->
name|iface_index
argument_list|,
name|chan
operator|->
name|xfer
argument_list|,
name|umidi_config
argument_list|,
name|UMIDI_N_TRANSFER
argument_list|,
name|chan
argument_list|,
operator|&
name|chan
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"error=%s\n"
argument_list|,
name|usb2_errstr
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
if|if
condition|(
operator|(
name|chan
operator|->
name|max_cable
operator|>
name|UMIDI_CABLES_MAX
operator|)
operator|||
operator|(
name|chan
operator|->
name|max_cable
operator|==
literal|0
operator|)
condition|)
block|{
name|chan
operator|->
name|max_cable
operator|=
name|UMIDI_CABLES_MAX
expr_stmt|;
block|}
comment|/* set interface permissions */
name|usb2_set_iface_perm
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|chan
operator|->
name|iface_index
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|chan
operator|->
name|max_cable
condition|;
name|n
operator|++
control|)
block|{
name|sub
operator|=
operator|&
name|chan
operator|->
name|sub
index|[
name|n
index|]
expr_stmt|;
name|error
operator|=
name|usb2_fifo_attach
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|chan
argument_list|,
operator|&
name|chan
operator|->
name|mtx
argument_list|,
operator|&
name|umidi_fifo_methods
argument_list|,
operator|&
name|sub
operator|->
name|fifo
argument_list|,
name|unit
argument_list|,
name|n
argument_list|,
name|chan
operator|->
name|iface_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|detach
goto|;
block|}
block|}
name|mtx_lock
argument_list|(
operator|&
name|chan
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* clear stall first */
name|chan
operator|->
name|flags
operator||=
name|UMIDI_FLAG_READ_STALL
expr_stmt|;
comment|/* 	 * NOTE: at least one device will not work properly unless 	 * the BULK pipe is open all the time. 	 */
name|usb2_transfer_start
argument_list|(
name|chan
operator|->
name|xfer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|chan
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
name|detach
label|:
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* failure */
block|}
end_function

begin_function
specifier|static
name|int32_t
name|umidi_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_midi_chan
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|UMIDI_CABLES_MAX
condition|;
name|n
operator|++
control|)
block|{
name|usb2_fifo_detach
argument_list|(
operator|&
name|chan
operator|->
name|sub
index|[
name|n
index|]
operator|.
name|fifo
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|chan
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|usb2_transfer_stop
argument_list|(
name|chan
operator|->
name|xfer
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|usb2_transfer_stop
argument_list|(
name|chan
operator|->
name|xfer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|chan
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|usb2_transfer_unsetup
argument_list|(
name|chan
operator|->
name|xfer
argument_list|,
name|UMIDI_N_TRANSFER
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|chan
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|uaudio
argument_list|,
name|ushub
argument_list|,
name|uaudio_driver
argument_list|,
name|uaudio_devclass
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|uaudio
argument_list|,
name|usb2_sound
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|uaudio
argument_list|,
name|usb2_core
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|uaudio
argument_list|,
name|sound
argument_list|,
name|SOUND_MINVER
argument_list|,
name|SOUND_PREFVER
argument_list|,
name|SOUND_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|uaudio
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

