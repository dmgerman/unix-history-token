begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $OpenBSD: glxsb.c,v 1.7 2007/02/12 14:31:45 tom Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2006 Tom Cosgrove<tom@openbsd.org>  * Copyright (c) 2003, 2004 Theo de Raadt  * Copyright (c) 2003 Jason Wright  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Driver for the security block on the AMD Geode LX processors  * http://www.amd.com/files/connectivitysolutions/geode/geode_lx/33234d_lx_ds.pdf  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/cryptodev.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/cryptosoft.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/xform.h>
end_include

begin_include
include|#
directive|include
file|"cryptodev_if.h"
end_include

begin_include
include|#
directive|include
file|"glxsb.h"
end_include

begin_define
define|#
directive|define
name|PCI_VENDOR_AMD
value|0x1022
end_define

begin_comment
comment|/* AMD */
end_comment

begin_define
define|#
directive|define
name|PCI_PRODUCT_AMD_GEODE_LX_CRYPTO
value|0x2082
end_define

begin_comment
comment|/* Geode LX Crypto */
end_comment

begin_define
define|#
directive|define
name|SB_GLD_MSR_CAP
value|0x58002000
end_define

begin_comment
comment|/* RO - Capabilities */
end_comment

begin_define
define|#
directive|define
name|SB_GLD_MSR_CONFIG
value|0x58002001
end_define

begin_comment
comment|/* RW - Master Config */
end_comment

begin_define
define|#
directive|define
name|SB_GLD_MSR_SMI
value|0x58002002
end_define

begin_comment
comment|/* RW - SMI */
end_comment

begin_define
define|#
directive|define
name|SB_GLD_MSR_ERROR
value|0x58002003
end_define

begin_comment
comment|/* RW - Error */
end_comment

begin_define
define|#
directive|define
name|SB_GLD_MSR_PM
value|0x58002004
end_define

begin_comment
comment|/* RW - Power Mgmt */
end_comment

begin_define
define|#
directive|define
name|SB_GLD_MSR_DIAG
value|0x58002005
end_define

begin_comment
comment|/* RW - Diagnostic */
end_comment

begin_define
define|#
directive|define
name|SB_GLD_MSR_CTRL
value|0x58002006
end_define

begin_comment
comment|/* RW - Security Block Cntrl */
end_comment

begin_comment
comment|/* For GLD_MSR_CTRL: */
end_comment

begin_define
define|#
directive|define
name|SB_GMC_DIV0
value|0x0000
end_define

begin_comment
comment|/* AES update divisor values */
end_comment

begin_define
define|#
directive|define
name|SB_GMC_DIV1
value|0x0001
end_define

begin_define
define|#
directive|define
name|SB_GMC_DIV2
value|0x0002
end_define

begin_define
define|#
directive|define
name|SB_GMC_DIV3
value|0x0003
end_define

begin_define
define|#
directive|define
name|SB_GMC_DIV_MASK
value|0x0003
end_define

begin_define
define|#
directive|define
name|SB_GMC_SBI
value|0x0004
end_define

begin_comment
comment|/* AES swap bits */
end_comment

begin_define
define|#
directive|define
name|SB_GMC_SBY
value|0x0008
end_define

begin_comment
comment|/* AES swap bytes */
end_comment

begin_define
define|#
directive|define
name|SB_GMC_TW
value|0x0010
end_define

begin_comment
comment|/* Time write (EEPROM) */
end_comment

begin_define
define|#
directive|define
name|SB_GMC_T_SEL0
value|0x0000
end_define

begin_comment
comment|/* RNG post-proc: none */
end_comment

begin_define
define|#
directive|define
name|SB_GMC_T_SEL1
value|0x0100
end_define

begin_comment
comment|/* RNG post-proc: LFSR */
end_comment

begin_define
define|#
directive|define
name|SB_GMC_T_SEL2
value|0x0200
end_define

begin_comment
comment|/* RNG post-proc: whitener */
end_comment

begin_define
define|#
directive|define
name|SB_GMC_T_SEL3
value|0x0300
end_define

begin_comment
comment|/* RNG LFSR+whitener */
end_comment

begin_define
define|#
directive|define
name|SB_GMC_T_SEL_MASK
value|0x0300
end_define

begin_define
define|#
directive|define
name|SB_GMC_T_NE
value|0x0400
end_define

begin_comment
comment|/* Noise (generator) Enable */
end_comment

begin_define
define|#
directive|define
name|SB_GMC_T_TM
value|0x0800
end_define

begin_comment
comment|/* RNG test mode */
end_comment

begin_comment
comment|/*     (deterministic) */
end_comment

begin_comment
comment|/* Security Block configuration/control registers (offsets from base) */
end_comment

begin_define
define|#
directive|define
name|SB_CTL_A
value|0x0000
end_define

begin_comment
comment|/* RW - SB Control A */
end_comment

begin_define
define|#
directive|define
name|SB_CTL_B
value|0x0004
end_define

begin_comment
comment|/* RW - SB Control B */
end_comment

begin_define
define|#
directive|define
name|SB_AES_INT
value|0x0008
end_define

begin_comment
comment|/* RW - SB AES Interrupt */
end_comment

begin_define
define|#
directive|define
name|SB_SOURCE_A
value|0x0010
end_define

begin_comment
comment|/* RW - Source A */
end_comment

begin_define
define|#
directive|define
name|SB_DEST_A
value|0x0014
end_define

begin_comment
comment|/* RW - Destination A */
end_comment

begin_define
define|#
directive|define
name|SB_LENGTH_A
value|0x0018
end_define

begin_comment
comment|/* RW - Length A */
end_comment

begin_define
define|#
directive|define
name|SB_SOURCE_B
value|0x0020
end_define

begin_comment
comment|/* RW - Source B */
end_comment

begin_define
define|#
directive|define
name|SB_DEST_B
value|0x0024
end_define

begin_comment
comment|/* RW - Destination B */
end_comment

begin_define
define|#
directive|define
name|SB_LENGTH_B
value|0x0028
end_define

begin_comment
comment|/* RW - Length B */
end_comment

begin_define
define|#
directive|define
name|SB_WKEY
value|0x0030
end_define

begin_comment
comment|/* WO - Writable Key 0-3 */
end_comment

begin_define
define|#
directive|define
name|SB_WKEY_0
value|0x0030
end_define

begin_comment
comment|/* WO - Writable Key 0 */
end_comment

begin_define
define|#
directive|define
name|SB_WKEY_1
value|0x0034
end_define

begin_comment
comment|/* WO - Writable Key 1 */
end_comment

begin_define
define|#
directive|define
name|SB_WKEY_2
value|0x0038
end_define

begin_comment
comment|/* WO - Writable Key 2 */
end_comment

begin_define
define|#
directive|define
name|SB_WKEY_3
value|0x003C
end_define

begin_comment
comment|/* WO - Writable Key 3 */
end_comment

begin_define
define|#
directive|define
name|SB_CBC_IV
value|0x0040
end_define

begin_comment
comment|/* RW - CBC IV 0-3 */
end_comment

begin_define
define|#
directive|define
name|SB_CBC_IV_0
value|0x0040
end_define

begin_comment
comment|/* RW - CBC IV 0 */
end_comment

begin_define
define|#
directive|define
name|SB_CBC_IV_1
value|0x0044
end_define

begin_comment
comment|/* RW - CBC IV 1 */
end_comment

begin_define
define|#
directive|define
name|SB_CBC_IV_2
value|0x0048
end_define

begin_comment
comment|/* RW - CBC IV 2 */
end_comment

begin_define
define|#
directive|define
name|SB_CBC_IV_3
value|0x004C
end_define

begin_comment
comment|/* RW - CBC IV 3 */
end_comment

begin_define
define|#
directive|define
name|SB_RANDOM_NUM
value|0x0050
end_define

begin_comment
comment|/* RW - Random Number */
end_comment

begin_define
define|#
directive|define
name|SB_RANDOM_NUM_STATUS
value|0x0054
end_define

begin_comment
comment|/* RW - Random Number Status */
end_comment

begin_define
define|#
directive|define
name|SB_EEPROM_COMM
value|0x0800
end_define

begin_comment
comment|/* RW - EEPROM Command */
end_comment

begin_define
define|#
directive|define
name|SB_EEPROM_ADDR
value|0x0804
end_define

begin_comment
comment|/* RW - EEPROM Address */
end_comment

begin_define
define|#
directive|define
name|SB_EEPROM_DATA
value|0x0808
end_define

begin_comment
comment|/* RW - EEPROM Data */
end_comment

begin_define
define|#
directive|define
name|SB_EEPROM_SEC_STATE
value|0x080C
end_define

begin_comment
comment|/* RW - EEPROM Security State */
end_comment

begin_comment
comment|/* For SB_CTL_A and _B */
end_comment

begin_define
define|#
directive|define
name|SB_CTL_ST
value|0x0001
end_define

begin_comment
comment|/* Start operation (enc/dec) */
end_comment

begin_define
define|#
directive|define
name|SB_CTL_ENC
value|0x0002
end_define

begin_comment
comment|/* Encrypt (0 is decrypt) */
end_comment

begin_define
define|#
directive|define
name|SB_CTL_DEC
value|0x0000
end_define

begin_comment
comment|/* Decrypt */
end_comment

begin_define
define|#
directive|define
name|SB_CTL_WK
value|0x0004
end_define

begin_comment
comment|/* Use writable key (we set) */
end_comment

begin_define
define|#
directive|define
name|SB_CTL_DC
value|0x0008
end_define

begin_comment
comment|/* Destination coherent */
end_comment

begin_define
define|#
directive|define
name|SB_CTL_SC
value|0x0010
end_define

begin_comment
comment|/* Source coherent */
end_comment

begin_define
define|#
directive|define
name|SB_CTL_CBC
value|0x0020
end_define

begin_comment
comment|/* CBC (0 is ECB) */
end_comment

begin_comment
comment|/* For SB_AES_INT */
end_comment

begin_define
define|#
directive|define
name|SB_AI_DISABLE_AES_A
value|0x0001
end_define

begin_comment
comment|/* Disable AES A compl int */
end_comment

begin_define
define|#
directive|define
name|SB_AI_ENABLE_AES_A
value|0x0000
end_define

begin_comment
comment|/* Enable AES A compl int */
end_comment

begin_define
define|#
directive|define
name|SB_AI_DISABLE_AES_B
value|0x0002
end_define

begin_comment
comment|/* Disable AES B compl int */
end_comment

begin_define
define|#
directive|define
name|SB_AI_ENABLE_AES_B
value|0x0000
end_define

begin_comment
comment|/* Enable AES B compl int */
end_comment

begin_define
define|#
directive|define
name|SB_AI_DISABLE_EEPROM
value|0x0004
end_define

begin_comment
comment|/* Disable EEPROM op comp int */
end_comment

begin_define
define|#
directive|define
name|SB_AI_ENABLE_EEPROM
value|0x0000
end_define

begin_comment
comment|/* Enable EEPROM op compl int */
end_comment

begin_define
define|#
directive|define
name|SB_AI_AES_A_COMPLETE
value|0x10000
end_define

begin_comment
comment|/* AES A operation complete */
end_comment

begin_define
define|#
directive|define
name|SB_AI_AES_B_COMPLETE
value|0x20000
end_define

begin_comment
comment|/* AES B operation complete */
end_comment

begin_define
define|#
directive|define
name|SB_AI_EEPROM_COMPLETE
value|0x40000
end_define

begin_comment
comment|/* EEPROM operation complete */
end_comment

begin_define
define|#
directive|define
name|SB_AI_CLEAR_INTR
define|\
value|(SB_AI_DISABLE_AES_A | SB_AI_DISABLE_AES_B |\ 	SB_AI_DISABLE_EEPROM | SB_AI_AES_A_COMPLETE |\ 	SB_AI_AES_B_COMPLETE | SB_AI_EEPROM_COMPLETE)
end_define

begin_define
define|#
directive|define
name|SB_RNS_TRNG_VALID
value|0x0001
end_define

begin_comment
comment|/* in SB_RANDOM_NUM_STATUS */
end_comment

begin_define
define|#
directive|define
name|SB_MEM_SIZE
value|0x0810
end_define

begin_comment
comment|/* Size of memory block */
end_comment

begin_define
define|#
directive|define
name|SB_AES_ALIGN
value|0x0010
end_define

begin_comment
comment|/* Source and dest buffers */
end_comment

begin_comment
comment|/* must be 16-byte aligned */
end_comment

begin_define
define|#
directive|define
name|SB_AES_BLOCK_SIZE
value|0x0010
end_define

begin_comment
comment|/*  * The Geode LX security block AES acceleration doesn't perform scatter-  * gather: it just takes source and destination addresses.  Therefore the  * plain- and ciphertexts need to be contiguous.  To this end, we allocate  * a buffer for both, and accept the overhead of copying in and out.  If  * the number of bytes in one operation is bigger than allowed for by the  * buffer (buffer is twice the size of the max length, as it has both input  * and output) then we have to perform multiple encryptions/decryptions.  */
end_comment

begin_define
define|#
directive|define
name|GLXSB_MAX_AES_LEN
value|16384
end_define

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_GLXSB
argument_list|,
literal|"glxsb_data"
argument_list|,
literal|"Glxsb Data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|glxsb_dma_map
block|{
name|bus_dmamap_t
name|dma_map
decl_stmt|;
comment|/* DMA map */
name|bus_dma_segment_t
name|dma_seg
decl_stmt|;
comment|/* segments */
name|int
name|dma_nsegs
decl_stmt|;
comment|/* #segments */
name|int
name|dma_size
decl_stmt|;
comment|/* size */
name|caddr_t
name|dma_vaddr
decl_stmt|;
comment|/* virtual address */
name|bus_addr_t
name|dma_paddr
decl_stmt|;
comment|/* physical address */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|glxsb_taskop
block|{
name|struct
name|glxsb_session
modifier|*
name|to_ses
decl_stmt|;
comment|/* crypto session */
name|struct
name|cryptop
modifier|*
name|to_crp
decl_stmt|;
comment|/* cryptop to perfom */
name|struct
name|cryptodesc
modifier|*
name|to_enccrd
decl_stmt|;
comment|/* enccrd to perform */
name|struct
name|cryptodesc
modifier|*
name|to_maccrd
decl_stmt|;
comment|/* maccrd to perform */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|glxsb_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
comment|/* device backpointer */
name|struct
name|resource
modifier|*
name|sc_sr
decl_stmt|;
comment|/* resource */
name|int
name|sc_rid
decl_stmt|;
comment|/* resource rid */
name|struct
name|callout
name|sc_rngco
decl_stmt|;
comment|/* RNG callout */
name|int
name|sc_rnghz
decl_stmt|;
comment|/* RNG callout ticks */
name|bus_dma_tag_t
name|sc_dmat
decl_stmt|;
comment|/* DMA tag */
name|struct
name|glxsb_dma_map
name|sc_dma
decl_stmt|;
comment|/* DMA map */
name|int32_t
name|sc_cid
decl_stmt|;
comment|/* crypto tag */
name|uint32_t
name|sc_sid
decl_stmt|;
comment|/* session id */
name|TAILQ_HEAD
argument_list|(
argument|ses_head
argument_list|,
argument|glxsb_session
argument_list|)
name|sc_sessions
expr_stmt|;
comment|/* crypto sessions */
name|struct
name|rwlock
name|sc_sessions_lock
decl_stmt|;
comment|/* sessions lock */
name|struct
name|mtx
name|sc_task_mtx
decl_stmt|;
comment|/* task mutex */
name|struct
name|taskqueue
modifier|*
name|sc_tq
decl_stmt|;
comment|/* task queue */
name|struct
name|task
name|sc_cryptotask
decl_stmt|;
comment|/* task */
name|struct
name|glxsb_taskop
name|sc_to
decl_stmt|;
comment|/* task's crypto operation */
name|int
name|sc_task_count
decl_stmt|;
comment|/* tasks count */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|glxsb_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|glxsb_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|glxsb_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|glxsb_dmamap_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|glxsb_dma_alloc
parameter_list|(
name|struct
name|glxsb_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|glxsb_dma_pre_op
parameter_list|(
name|struct
name|glxsb_softc
modifier|*
parameter_list|,
name|struct
name|glxsb_dma_map
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|glxsb_dma_post_op
parameter_list|(
name|struct
name|glxsb_softc
modifier|*
parameter_list|,
name|struct
name|glxsb_dma_map
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|glxsb_dma_free
parameter_list|(
name|struct
name|glxsb_softc
modifier|*
parameter_list|,
name|struct
name|glxsb_dma_map
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|glxsb_rnd
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|glxsb_crypto_setup
parameter_list|(
name|struct
name|glxsb_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|glxsb_crypto_newsession
parameter_list|(
name|device_t
parameter_list|,
name|uint32_t
modifier|*
parameter_list|,
name|struct
name|cryptoini
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|glxsb_crypto_freesession
parameter_list|(
name|device_t
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|glxsb_aes
parameter_list|(
name|struct
name|glxsb_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|glxsb_crypto_encdec
parameter_list|(
name|struct
name|cryptop
modifier|*
parameter_list|,
name|struct
name|cryptodesc
modifier|*
parameter_list|,
name|struct
name|glxsb_session
modifier|*
parameter_list|,
name|struct
name|glxsb_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|glxsb_crypto_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|glxsb_crypto_process
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|cryptop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|glxsb_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|glxsb_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|glxsb_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|glxsb_detach
argument_list|)
block|,
comment|/* crypto device methods */
name|DEVMETHOD
argument_list|(
name|cryptodev_newsession
argument_list|,
name|glxsb_crypto_newsession
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cryptodev_freesession
argument_list|,
name|glxsb_crypto_freesession
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cryptodev_process
argument_list|,
name|glxsb_crypto_process
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|glxsb_driver
init|=
block|{
literal|"glxsb"
block|,
name|glxsb_methods
block|,
expr|sizeof
operator|(
expr|struct
name|glxsb_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|glxsb_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|glxsb
argument_list|,
name|pci
argument_list|,
name|glxsb_driver
argument_list|,
name|glxsb_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|glxsb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|glxsb
argument_list|,
name|crypto
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|glxsb_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_VENDOR_AMD
operator|&&
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_AMD_GEODE_LX_CRYPTO
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"AMD Geode LX Security Block (AES-128-CBC, RNG)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|glxsb_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|glxsb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint64_t
name|msr
decl_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|msr
operator|=
name|rdmsr
argument_list|(
name|SB_GLD_MSR_CAP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msr
operator|&
literal|0xFFFF00
operator|)
operator|!=
literal|0x130400
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unknown ID 0x%x\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|msr
operator|&
literal|0xFFFF00
operator|)
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Map in the security block configuration/control registers */
name|sc
operator|->
name|sc_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sr
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|sc_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_sr
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot map register space\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Configure the Security Block. 	 * 	 * We want to enable the noise generator (T_NE), and enable the 	 * linear feedback shift register and whitener post-processing 	 * (T_SEL = 3).  Also ensure that test mode (deterministic values) 	 * is disabled. 	 */
name|msr
operator|=
name|rdmsr
argument_list|(
name|SB_GLD_MSR_CTRL
argument_list|)
expr_stmt|;
name|msr
operator|&=
operator|~
operator|(
name|SB_GMC_T_TM
operator||
name|SB_GMC_T_SEL_MASK
operator|)
expr_stmt|;
name|msr
operator||=
name|SB_GMC_T_NE
operator||
name|SB_GMC_T_SEL3
expr_stmt|;
if|#
directive|if
literal|0
block|msr |= SB_GMC_SBI | SB_GMC_SBY;
comment|/* for AES, if necessary */
endif|#
directive|endif
name|wrmsr
argument_list|(
name|SB_GLD_MSR_CTRL
argument_list|,
name|msr
argument_list|)
expr_stmt|;
comment|/* Disable interrupts */
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_sr
argument_list|,
name|SB_AES_INT
argument_list|,
name|SB_AI_CLEAR_INTR
argument_list|)
expr_stmt|;
comment|/* Allocate a contiguous DMA-able buffer to work in */
if|if
condition|(
name|glxsb_dma_alloc
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail0
goto|;
comment|/* Initialize our task queue */
name|sc
operator|->
name|sc_tq
operator|=
name|taskqueue_create
argument_list|(
literal|"glxsb_taskq"
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_tq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot create task queue\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail0
goto|;
block|}
if|if
condition|(
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|sc_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot start task queue\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_cryptotask
argument_list|,
literal|0
argument_list|,
name|glxsb_crypto_task
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize crypto */
if|if
condition|(
name|glxsb_crypto_setup
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
comment|/* Install a periodic collector for the "true" (AMD's word) RNG */
if|if
condition|(
name|hz
operator|>
literal|100
condition|)
name|sc
operator|->
name|sc_rnghz
operator|=
name|hz
operator|/
literal|100
expr_stmt|;
else|else
name|sc
operator|->
name|sc_rnghz
operator|=
literal|1
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_rngco
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|glxsb_rnd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|fail0
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|sc_rid
argument_list|,
name|sc
operator|->
name|sc_sr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|glxsb_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|glxsb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|glxsb_session
modifier|*
name|ses
decl_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ses
argument_list|,
argument|&sc->sc_sessions
argument_list|,
argument|ses_next
argument_list|)
block|{
if|if
condition|(
name|ses
operator|->
name|ses_used
condition|)
block|{
name|rw_wunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions_lock
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot detach, sessions still active.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions
argument_list|)
condition|)
block|{
name|ses
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions
argument_list|,
name|ses
argument_list|,
name|ses_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ses
argument_list|,
name|M_GLXSB
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions_lock
argument_list|)
expr_stmt|;
name|crypto_unregister_all
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_rngco
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_cryptotask
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|glxsb_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_dma
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|sc_rid
argument_list|,
name|sc
operator|->
name|sc_sr
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_task_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	callback for bus_dmamap_load()  */
end_comment

begin_function
specifier|static
name|void
name|glxsb_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|seg
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|paddr
init|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
decl_stmt|;
operator|*
name|paddr
operator|=
name|seg
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|glxsb_dma_alloc
parameter_list|(
name|struct
name|glxsb_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|glxsb_dma_map
modifier|*
name|dma
init|=
operator|&
name|sc
operator|->
name|sc_dma
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|dma
operator|->
name|dma_nsegs
operator|=
literal|1
expr_stmt|;
name|dma
operator|->
name|dma_size
operator|=
name|GLXSB_MAX_AES_LEN
operator|*
literal|2
expr_stmt|;
comment|/* Setup DMA descriptor area */
name|rc
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
comment|/* parent */
name|SB_AES_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignments, bounds */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|dma
operator|->
name|dma_size
argument_list|,
comment|/* maxsize */
name|dma
operator|->
name|dma_nsegs
argument_list|,
comment|/* nsegments */
name|dma
operator|->
name|dma_size
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|sc_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot allocate DMA tag (%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|rc
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot allocate DMA memory of %d bytes (%d)\n"
argument_list|,
name|dma
operator|->
name|dma_size
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|fail0
goto|;
block|}
name|rc
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_size
argument_list|,
name|glxsb_dmamap_cb
argument_list|,
operator|&
name|dma
operator|->
name|dma_paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot load DMA memory for %d bytes (%d)\n"
argument_list|,
name|dma
operator|->
name|dma_size
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|fail0
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|glxsb_dma_pre_op
parameter_list|(
name|struct
name|glxsb_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|glxsb_dma_map
modifier|*
name|dma
parameter_list|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|glxsb_dma_post_op
parameter_list|(
name|struct
name|glxsb_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|glxsb_dma_map
modifier|*
name|dma
parameter_list|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|glxsb_dma_free
parameter_list|(
name|struct
name|glxsb_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|glxsb_dma_map
modifier|*
name|dma
parameter_list|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|glxsb_rnd
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|glxsb_softc
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|uint32_t
name|status
decl_stmt|,
name|value
decl_stmt|;
name|status
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|sc_sr
argument_list|,
name|SB_RANDOM_NUM_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|SB_RNS_TRNG_VALID
condition|)
block|{
name|value
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|sc_sr
argument_list|,
name|SB_RANDOM_NUM
argument_list|)
expr_stmt|;
comment|/* feed with one uint32 */
name|random_harvest
argument_list|(
operator|&
name|value
argument_list|,
literal|4
argument_list|,
literal|32
operator|/
literal|2
argument_list|,
name|RANDOM_PURE_GLXSB
argument_list|)
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_rngco
argument_list|,
name|sc
operator|->
name|sc_rnghz
argument_list|,
name|glxsb_rnd
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|glxsb_crypto_setup
parameter_list|(
name|struct
name|glxsb_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|sc_cid
operator|=
name|crypto_get_driverid
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|CRYPTOCAP_F_HARDWARE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cid
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot get crypto driver id\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sid
operator|=
literal|1
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions_lock
argument_list|,
literal|"glxsb_sessions_lock"
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_task_mtx
argument_list|,
literal|"glxsb_crypto_mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_AES_CBC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|crypto_fail
goto|;
if|if
condition|(
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_NULL_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|crypto_fail
goto|;
if|if
condition|(
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_MD5_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|crypto_fail
goto|;
if|if
condition|(
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_SHA1_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|crypto_fail
goto|;
if|if
condition|(
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_RIPEMD160_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|crypto_fail
goto|;
if|if
condition|(
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_SHA2_256_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|crypto_fail
goto|;
if|if
condition|(
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_SHA2_384_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|crypto_fail
goto|;
if|if
condition|(
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_SHA2_512_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|crypto_fail
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|crypto_fail
label|:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot register crypto\n"
argument_list|)
expr_stmt|;
name|crypto_unregister_all
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_task_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|glxsb_crypto_newsession
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint32_t
modifier|*
name|sidp
parameter_list|,
name|struct
name|cryptoini
modifier|*
name|cri
parameter_list|)
block|{
name|struct
name|glxsb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|glxsb_session
modifier|*
name|ses
init|=
name|NULL
decl_stmt|;
name|struct
name|cryptoini
modifier|*
name|encini
decl_stmt|,
modifier|*
name|macini
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|sidp
operator|==
name|NULL
operator|||
name|cri
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|encini
operator|=
name|macini
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|cri
operator|!=
name|NULL
condition|;
name|cri
operator|=
name|cri
operator|->
name|cri_next
control|)
block|{
switch|switch
condition|(
name|cri
operator|->
name|cri_alg
condition|)
block|{
case|case
name|CRYPTO_NULL_HMAC
case|:
case|case
name|CRYPTO_MD5_HMAC
case|:
case|case
name|CRYPTO_SHA1_HMAC
case|:
case|case
name|CRYPTO_RIPEMD160_HMAC
case|:
case|case
name|CRYPTO_SHA2_256_HMAC
case|:
case|case
name|CRYPTO_SHA2_384_HMAC
case|:
case|case
name|CRYPTO_SHA2_512_HMAC
case|:
if|if
condition|(
name|macini
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|macini
operator|=
name|cri
expr_stmt|;
break|break;
case|case
name|CRYPTO_AES_CBC
case|:
if|if
condition|(
name|encini
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|encini
operator|=
name|cri
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/* 	 * We only support HMAC algorithms to be able to work with 	 * ipsec(4), so if we are asked only for authentication without 	 * encryption, don't pretend we can accellerate it. 	 */
if|if
condition|(
name|encini
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Look for a free session 	 * 	 * Free sessions goes first, so if first session is used, we need to 	 * allocate one. 	 */
name|rw_wlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions_lock
argument_list|)
expr_stmt|;
name|ses
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions
argument_list|)
expr_stmt|;
if|if
condition|(
name|ses
operator|==
name|NULL
operator|||
name|ses
operator|->
name|ses_used
condition|)
block|{
name|ses
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ses
argument_list|)
argument_list|,
name|M_GLXSB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ses
operator|==
name|NULL
condition|)
block|{
name|rw_wunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|ses
operator|->
name|ses_id
operator|=
name|sc
operator|->
name|sc_sid
operator|++
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions
argument_list|,
name|ses
argument_list|,
name|ses_next
argument_list|)
expr_stmt|;
block|}
name|ses
operator|->
name|ses_used
operator|=
literal|1
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions
argument_list|,
name|ses
argument_list|,
name|ses_next
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|encini
operator|->
name|cri_alg
operator|==
name|CRYPTO_AES_CBC
condition|)
block|{
if|if
condition|(
name|encini
operator|->
name|cri_klen
operator|!=
literal|128
condition|)
block|{
name|glxsb_crypto_freesession
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|ses
operator|->
name|ses_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|arc4rand
argument_list|(
name|ses
operator|->
name|ses_iv
argument_list|,
sizeof|sizeof
argument_list|(
name|ses
operator|->
name|ses_iv
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ses
operator|->
name|ses_klen
operator|=
name|encini
operator|->
name|cri_klen
expr_stmt|;
comment|/* Copy the key (Geode LX wants the primary key only) */
name|bcopy
argument_list|(
name|encini
operator|->
name|cri_key
argument_list|,
name|ses
operator|->
name|ses_key
argument_list|,
sizeof|sizeof
argument_list|(
name|ses
operator|->
name|ses_key
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|macini
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|glxsb_hash_setup
argument_list|(
name|ses
argument_list|,
name|macini
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|glxsb_crypto_freesession
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|ses
operator|->
name|ses_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
operator|*
name|sidp
operator|=
name|ses
operator|->
name|ses_id
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|glxsb_crypto_freesession
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint64_t
name|tid
parameter_list|)
block|{
name|struct
name|glxsb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|glxsb_session
modifier|*
name|ses
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|sid
init|=
operator|(
operator|(
name|uint32_t
operator|)
name|tid
operator|)
operator|&
literal|0xffffffff
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rw_wlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_REVERSE
argument_list|(
argument|ses
argument_list|,
argument|&sc->sc_sessions
argument_list|,
argument|ses_head
argument_list|,
argument|ses_next
argument_list|)
block|{
if|if
condition|(
name|ses
operator|->
name|ses_id
operator|==
name|sid
condition|)
break|break;
block|}
if|if
condition|(
name|ses
operator|==
name|NULL
condition|)
block|{
name|rw_wunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions
argument_list|,
name|ses
argument_list|,
name|ses_next
argument_list|)
expr_stmt|;
name|glxsb_hash_free
argument_list|(
name|ses
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ses
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ses
argument_list|)
argument_list|)
expr_stmt|;
name|ses
operator|->
name|ses_used
operator|=
literal|0
expr_stmt|;
name|ses
operator|->
name|ses_id
operator|=
name|sid
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions
argument_list|,
name|ses
argument_list|,
name|ses_next
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|glxsb_aes
parameter_list|(
name|struct
name|glxsb_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|control
parameter_list|,
name|uint32_t
name|psrc
parameter_list|,
name|uint32_t
name|pdst
parameter_list|,
name|void
modifier|*
name|key
parameter_list|,
name|int
name|len
parameter_list|,
name|void
modifier|*
name|iv
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|len
operator|&
literal|0xF
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"len must be a multiple of 16 (not %d)\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Set the source */
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_sr
argument_list|,
name|SB_SOURCE_A
argument_list|,
name|psrc
argument_list|)
expr_stmt|;
comment|/* Set the destination address */
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_sr
argument_list|,
name|SB_DEST_A
argument_list|,
name|pdst
argument_list|)
expr_stmt|;
comment|/* Set the data length */
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_sr
argument_list|,
name|SB_LENGTH_A
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Set the IV */
if|if
condition|(
name|iv
operator|!=
name|NULL
condition|)
block|{
name|bus_write_region_4
argument_list|(
name|sc
operator|->
name|sc_sr
argument_list|,
name|SB_CBC_IV
argument_list|,
name|iv
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|control
operator||=
name|SB_CTL_CBC
expr_stmt|;
block|}
comment|/* Set the key */
name|bus_write_region_4
argument_list|(
name|sc
operator|->
name|sc_sr
argument_list|,
name|SB_WKEY
argument_list|,
name|key
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Ask the security block to do it */
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_sr
argument_list|,
name|SB_CTL_A
argument_list|,
name|control
operator||
name|SB_CTL_WK
operator||
name|SB_CTL_DC
operator||
name|SB_CTL_SC
operator||
name|SB_CTL_ST
argument_list|)
expr_stmt|;
comment|/* 	 * Now wait until it is done. 	 * 	 * We do a busy wait.  Obviously the number of iterations of 	 * the loop required to perform the AES operation depends upon 	 * the number of bytes to process. 	 * 	 * On a 500 MHz Geode LX we see 	 * 	 *	length (bytes)	typical max iterations 	 *	    16		   12 	 *	    64		   22 	 *	   256		   59 	 *	  1024		  212 	 *	  8192		1,537 	 * 	 * Since we have a maximum size of operation defined in 	 * GLXSB_MAX_AES_LEN, we use this constant to decide how long 	 * to wait.  Allow an order of magnitude longer than it should 	 * really take, just in case. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GLXSB_MAX_AES_LEN
operator|*
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|sc_sr
argument_list|,
name|SB_CTL_A
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|SB_CTL_ST
operator|)
operator|==
literal|0
condition|)
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"operation failed to complete\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|glxsb_crypto_encdec
parameter_list|(
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|,
name|struct
name|cryptodesc
modifier|*
name|crd
parameter_list|,
name|struct
name|glxsb_session
modifier|*
name|ses
parameter_list|,
name|struct
name|glxsb_softc
modifier|*
name|sc
parameter_list|)
block|{
name|char
modifier|*
name|op_src
decl_stmt|,
modifier|*
name|op_dst
decl_stmt|;
name|uint32_t
name|op_psrc
decl_stmt|,
name|op_pdst
decl_stmt|;
name|uint8_t
name|op_iv
index|[
name|SB_AES_BLOCK_SIZE
index|]
decl_stmt|,
modifier|*
name|piv
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|len
decl_stmt|,
name|tlen
decl_stmt|,
name|xlen
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|uint32_t
name|control
decl_stmt|;
if|if
condition|(
name|crd
operator|==
name|NULL
operator|||
operator|(
name|crd
operator|->
name|crd_len
operator|%
name|SB_AES_BLOCK_SIZE
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* How much of our buffer will we need to use? */
name|xlen
operator|=
name|crd
operator|->
name|crd_len
operator|>
name|GLXSB_MAX_AES_LEN
condition|?
name|GLXSB_MAX_AES_LEN
else|:
name|crd
operator|->
name|crd_len
expr_stmt|;
comment|/* 	 * XXX Check if we can have input == output on Geode LX. 	 * XXX In the meantime, use two separate (adjacent) buffers. 	 */
name|op_src
operator|=
name|sc
operator|->
name|sc_dma
operator|.
name|dma_vaddr
expr_stmt|;
name|op_dst
operator|=
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|sc_dma
operator|.
name|dma_vaddr
operator|+
name|xlen
expr_stmt|;
name|op_psrc
operator|=
name|sc
operator|->
name|sc_dma
operator|.
name|dma_paddr
expr_stmt|;
name|op_pdst
operator|=
name|sc
operator|->
name|sc_dma
operator|.
name|dma_paddr
operator|+
name|xlen
expr_stmt|;
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
block|{
name|control
operator|=
name|SB_CTL_ENC
expr_stmt|;
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
condition|)
name|bcopy
argument_list|(
name|crd
operator|->
name|crd_iv
argument_list|,
name|op_iv
argument_list|,
sizeof|sizeof
argument_list|(
name|op_iv
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|ses
operator|->
name|ses_iv
argument_list|,
name|op_iv
argument_list|,
sizeof|sizeof
argument_list|(
name|op_iv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_PRESENT
operator|)
operator|==
literal|0
condition|)
block|{
name|crypto_copyback
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crd
operator|->
name|crd_inject
argument_list|,
sizeof|sizeof
argument_list|(
name|op_iv
argument_list|)
argument_list|,
name|op_iv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|control
operator|=
name|SB_CTL_DEC
expr_stmt|;
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
condition|)
name|bcopy
argument_list|(
name|crd
operator|->
name|crd_iv
argument_list|,
name|op_iv
argument_list|,
sizeof|sizeof
argument_list|(
name|op_iv
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crd
operator|->
name|crd_inject
argument_list|,
sizeof|sizeof
argument_list|(
name|op_iv
argument_list|)
argument_list|,
name|op_iv
argument_list|)
expr_stmt|;
block|}
block|}
name|offset
operator|=
literal|0
expr_stmt|;
name|tlen
operator|=
name|crd
operator|->
name|crd_len
expr_stmt|;
name|piv
operator|=
name|op_iv
expr_stmt|;
comment|/* Process the data in GLXSB_MAX_AES_LEN chunks */
while|while
condition|(
name|tlen
operator|>
literal|0
condition|)
block|{
name|len
operator|=
operator|(
name|tlen
operator|>
name|GLXSB_MAX_AES_LEN
operator|)
condition|?
name|GLXSB_MAX_AES_LEN
else|:
name|tlen
expr_stmt|;
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crd
operator|->
name|crd_skip
operator|+
name|offset
argument_list|,
name|len
argument_list|,
name|op_src
argument_list|)
expr_stmt|;
name|glxsb_dma_pre_op
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_dma
argument_list|)
expr_stmt|;
name|error
operator|=
name|glxsb_aes
argument_list|(
name|sc
argument_list|,
name|control
argument_list|,
name|op_psrc
argument_list|,
name|op_pdst
argument_list|,
name|ses
operator|->
name|ses_key
argument_list|,
name|len
argument_list|,
name|op_iv
argument_list|)
expr_stmt|;
name|glxsb_dma_post_op
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|crypto_copyback
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crd
operator|->
name|crd_skip
operator|+
name|offset
argument_list|,
name|len
argument_list|,
name|op_dst
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|len
expr_stmt|;
name|tlen
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|tlen
operator|<=
literal|0
condition|)
block|{
comment|/* Ideally, just == 0 */
comment|/* Finished - put the IV in session IV */
name|piv
operator|=
name|ses
operator|->
name|ses_iv
expr_stmt|;
block|}
comment|/* 		 * Copy out last block for use as next iteration/session IV. 		 * 		 * piv is set to op_iv[] before the loop starts, but is 		 * set to ses->ses_iv if we're going to exit the loop this 		 * time. 		 */
if|if
condition|(
name|crd
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
name|bcopy
argument_list|(
name|op_dst
operator|+
name|len
operator|-
sizeof|sizeof
argument_list|(
name|op_iv
argument_list|)
argument_list|,
name|piv
argument_list|,
sizeof|sizeof
argument_list|(
name|op_iv
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Decryption, only need this if another iteration */
if|if
condition|(
name|tlen
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|op_src
operator|+
name|len
operator|-
sizeof|sizeof
argument_list|(
name|op_iv
argument_list|)
argument_list|,
name|piv
argument_list|,
sizeof|sizeof
argument_list|(
name|op_iv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* while */
comment|/* All AES processing has now been done. */
name|bzero
argument_list|(
name|sc
operator|->
name|sc_dma
operator|.
name|dma_vaddr
argument_list|,
name|xlen
operator|*
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|glxsb_crypto_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|glxsb_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|glxsb_session
modifier|*
name|ses
decl_stmt|;
name|struct
name|cryptop
modifier|*
name|crp
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|enccrd
decl_stmt|,
modifier|*
name|maccrd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|maccrd
operator|=
name|sc
operator|->
name|sc_to
operator|.
name|to_maccrd
expr_stmt|;
name|enccrd
operator|=
name|sc
operator|->
name|sc_to
operator|.
name|to_enccrd
expr_stmt|;
name|crp
operator|=
name|sc
operator|->
name|sc_to
operator|.
name|to_crp
expr_stmt|;
name|ses
operator|=
name|sc
operator|->
name|sc_to
operator|.
name|to_ses
expr_stmt|;
comment|/* Perform data authentication if requested before encryption */
if|if
condition|(
name|maccrd
operator|!=
name|NULL
operator|&&
name|maccrd
operator|->
name|crd_next
operator|==
name|enccrd
condition|)
block|{
name|error
operator|=
name|glxsb_hash_process
argument_list|(
name|ses
argument_list|,
name|maccrd
argument_list|,
name|crp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|glxsb_crypto_encdec
argument_list|(
name|crp
argument_list|,
name|enccrd
argument_list|,
name|ses
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Perform data authentication if requested after encryption */
if|if
condition|(
name|maccrd
operator|!=
name|NULL
operator|&&
name|enccrd
operator|->
name|crd_next
operator|==
name|maccrd
condition|)
block|{
name|error
operator|=
name|glxsb_hash_process
argument_list|(
name|ses
argument_list|,
name|maccrd
argument_list|,
name|crp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_task_mtx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_task_count
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_task_mtx
argument_list|)
expr_stmt|;
name|crp
operator|->
name|crp_etype
operator|=
name|error
expr_stmt|;
name|crypto_unblock
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_SYMQ
argument_list|)
expr_stmt|;
name|crypto_done
argument_list|(
name|crp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|glxsb_crypto_process
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|,
name|int
name|hint
parameter_list|)
block|{
name|struct
name|glxsb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|glxsb_session
modifier|*
name|ses
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crd
decl_stmt|,
modifier|*
name|enccrd
decl_stmt|,
modifier|*
name|maccrd
decl_stmt|;
name|uint32_t
name|sid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|enccrd
operator|=
name|maccrd
operator|=
name|NULL
expr_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|crp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|crp
operator|->
name|crp_callback
operator|==
name|NULL
operator|||
name|crp
operator|->
name|crp_desc
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|crd
operator|=
name|crp
operator|->
name|crp_desc
init|;
name|crd
operator|!=
name|NULL
condition|;
name|crd
operator|=
name|crd
operator|->
name|crd_next
control|)
block|{
switch|switch
condition|(
name|crd
operator|->
name|crd_alg
condition|)
block|{
case|case
name|CRYPTO_NULL_HMAC
case|:
case|case
name|CRYPTO_MD5_HMAC
case|:
case|case
name|CRYPTO_SHA1_HMAC
case|:
case|case
name|CRYPTO_RIPEMD160_HMAC
case|:
case|case
name|CRYPTO_SHA2_256_HMAC
case|:
case|case
name|CRYPTO_SHA2_384_HMAC
case|:
case|case
name|CRYPTO_SHA2_512_HMAC
case|:
if|if
condition|(
name|maccrd
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|maccrd
operator|=
name|crd
expr_stmt|;
break|break;
case|case
name|CRYPTO_AES_CBC
case|:
if|if
condition|(
name|enccrd
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|enccrd
operator|=
name|crd
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
if|if
condition|(
name|enccrd
operator|==
name|NULL
operator|||
name|enccrd
operator|->
name|crd_len
operator|%
name|AES_BLOCK_LEN
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sid
operator|=
name|crp
operator|->
name|crp_sid
operator|&
literal|0xffffffff
expr_stmt|;
name|rw_rlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_REVERSE
argument_list|(
argument|ses
argument_list|,
argument|&sc->sc_sessions
argument_list|,
argument|ses_head
argument_list|,
argument|ses_next
argument_list|)
block|{
if|if
condition|(
name|ses
operator|->
name|ses_id
operator|==
name|sid
condition|)
break|break;
block|}
name|rw_runlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ses
operator|==
name|NULL
operator|||
operator|!
name|ses
operator|->
name|ses_used
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_task_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_task_count
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_task_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERESTART
operator|)
return|;
block|}
name|sc
operator|->
name|sc_task_count
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_to
operator|.
name|to_maccrd
operator|=
name|maccrd
expr_stmt|;
name|sc
operator|->
name|sc_to
operator|.
name|to_enccrd
operator|=
name|enccrd
expr_stmt|;
name|sc
operator|->
name|sc_to
operator|.
name|to_crp
operator|=
name|crp
expr_stmt|;
name|sc
operator|->
name|sc_to
operator|.
name|to_ses
operator|=
name|ses
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_task_mtx
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_cryptotask
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|crp
operator|->
name|crp_etype
operator|=
name|error
expr_stmt|;
name|crypto_done
argument_list|(
name|crp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

