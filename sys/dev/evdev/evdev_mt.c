begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Vladimir Kondratyev<wulf@cicgroup.ru>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<dev/evdev/evdev.h>
end_include

begin_include
include|#
directive|include
file|<dev/evdev/evdev_private.h>
end_include

begin_include
include|#
directive|include
file|<dev/evdev/input.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|debugf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|printf("evdev: " fmt "\n", ##args)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debugf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|uint16_t
name|evdev_fngmap
index|[]
init|=
block|{
name|BTN_TOOL_FINGER
block|,
name|BTN_TOOL_DOUBLETAP
block|,
name|BTN_TOOL_TRIPLETAP
block|,
name|BTN_TOOL_QUADTAP
block|,
name|BTN_TOOL_QUINTTAP
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint16_t
name|evdev_mtstmap
index|[]
index|[
literal|2
index|]
init|=
block|{
block|{
name|ABS_MT_POSITION_X
block|,
name|ABS_X
block|}
block|,
block|{
name|ABS_MT_POSITION_Y
block|,
name|ABS_Y
block|}
block|,
block|{
name|ABS_MT_PRESSURE
block|,
name|ABS_PRESSURE
block|}
block|,
block|{
name|ABS_MT_TOUCH_MAJOR
block|,
name|ABS_TOOL_WIDTH
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|evdev_mt_slot
block|{
name|uint64_t
name|ev_report
decl_stmt|;
name|int32_t
name|ev_mt_states
index|[
name|MT_CNT
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|evdev_mt
block|{
name|int32_t
name|ev_mt_last_reported_slot
decl_stmt|;
name|struct
name|evdev_mt_slot
name|ev_mt_slots
index|[]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
name|evdev_mt_init
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|)
block|{
name|int32_t
name|slot
decl_stmt|,
name|slots
decl_stmt|;
name|slots
operator|=
name|MAXIMAL_MT_SLOT
argument_list|(
name|evdev
argument_list|)
operator|+
literal|1
expr_stmt|;
name|evdev
operator|->
name|ev_mt
operator|=
name|malloc
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|evdev_mt
argument_list|,
name|ev_mt_slots
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|evdev_mt_slot
argument_list|)
operator|*
name|slots
argument_list|,
name|M_EVDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* Initialize multitouch protocol type B states */
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|slots
condition|;
name|slot
operator|++
control|)
block|{
comment|/* 		 * .ev_report should not be initialized to initial value of 		 * report counter (0) as it brokes free slot detection in 		 * evdev_get_mt_slot_by_tracking_id. So initialize it to -1 		 */
name|evdev
operator|->
name|ev_mt
operator|->
name|ev_mt_slots
index|[
name|slot
index|]
operator|=
operator|(
expr|struct
name|evdev_mt_slot
operator|)
block|{
operator|.
name|ev_report
operator|=
literal|0xFFFFFFFFFFFFFFFFULL
block|,
operator|.
name|ev_mt_states
index|[
name|ABS_MT_INDEX
argument_list|(
name|ABS_MT_TRACKING_ID
argument_list|)
index|]
operator|=
operator|-
literal|1
block|, 		}
expr_stmt|;
block|}
if|if
condition|(
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_flags
argument_list|,
name|EVDEV_FLAG_MT_STCOMPAT
argument_list|)
condition|)
name|evdev_support_mt_compat
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evdev_mt_free
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|)
block|{
name|free
argument_list|(
name|evdev
operator|->
name|ev_mt
argument_list|,
name|M_EVDEV
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int32_t
name|evdev_get_last_mt_slot
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|)
block|{
return|return
operator|(
name|evdev
operator|->
name|ev_mt
operator|->
name|ev_mt_last_reported_slot
operator|)
return|;
block|}
end_function

begin_function
name|void
name|evdev_set_last_mt_slot
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|int32_t
name|slot
parameter_list|)
block|{
name|evdev
operator|->
name|ev_mt
operator|->
name|ev_mt_slots
index|[
name|slot
index|]
operator|.
name|ev_report
operator|=
name|evdev
operator|->
name|ev_report_count
expr_stmt|;
name|evdev
operator|->
name|ev_mt
operator|->
name|ev_mt_last_reported_slot
operator|=
name|slot
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|int32_t
name|evdev_get_mt_value
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|int32_t
name|slot
parameter_list|,
name|int16_t
name|code
parameter_list|)
block|{
return|return
operator|(
name|evdev
operator|->
name|ev_mt
operator|->
name|ev_mt_slots
index|[
name|slot
index|]
operator|.
name|ev_mt_states
index|[
name|ABS_MT_INDEX
argument_list|(
name|code
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|inline
name|void
name|evdev_set_mt_value
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|int32_t
name|slot
parameter_list|,
name|int16_t
name|code
parameter_list|,
name|int32_t
name|value
parameter_list|)
block|{
name|evdev
operator|->
name|ev_mt
operator|->
name|ev_mt_slots
index|[
name|slot
index|]
operator|.
name|ev_mt_states
index|[
name|ABS_MT_INDEX
argument_list|(
name|code
argument_list|)
index|]
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_function
name|int32_t
name|evdev_get_mt_slot_by_tracking_id
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|int32_t
name|tracking_id
parameter_list|)
block|{
name|int32_t
name|tr_id
decl_stmt|,
name|slot
decl_stmt|,
name|free_slot
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<=
name|MAXIMAL_MT_SLOT
argument_list|(
name|evdev
argument_list|)
condition|;
name|slot
operator|++
control|)
block|{
name|tr_id
operator|=
name|evdev_get_mt_value
argument_list|(
name|evdev
argument_list|,
name|slot
argument_list|,
name|ABS_MT_TRACKING_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr_id
operator|==
name|tracking_id
condition|)
return|return
operator|(
name|slot
operator|)
return|;
comment|/* 		 * Its possible that slot will be reassigned in a place of just 		 * released one within the same report. To avoid this compare 		 * report counter with slot`s report number updated with each 		 * ABS_MT_TRACKING_ID change. 		 */
if|if
condition|(
name|free_slot
operator|==
operator|-
literal|1
operator|&&
name|tr_id
operator|==
operator|-
literal|1
operator|&&
name|evdev
operator|->
name|ev_mt
operator|->
name|ev_mt_slots
index|[
name|slot
index|]
operator|.
name|ev_report
operator|!=
name|evdev
operator|->
name|ev_report_count
condition|)
name|free_slot
operator|=
name|slot
expr_stmt|;
block|}
return|return
operator|(
name|free_slot
operator|)
return|;
block|}
end_function

begin_function
name|void
name|evdev_support_nfingers
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|int32_t
name|nfingers
parameter_list|)
block|{
name|int32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MIN
argument_list|(
name|nitems
argument_list|(
name|evdev_fngmap
argument_list|)
argument_list|,
name|nfingers
argument_list|)
condition|;
name|i
operator|++
control|)
name|evdev_support_key
argument_list|(
name|evdev
argument_list|,
name|evdev_fngmap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evdev_support_mt_compat
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|)
block|{
name|int32_t
name|i
decl_stmt|;
if|if
condition|(
name|evdev
operator|->
name|ev_absinfo
operator|==
name|NULL
condition|)
return|return;
name|evdev_support_event
argument_list|(
name|evdev
argument_list|,
name|EV_KEY
argument_list|)
expr_stmt|;
name|evdev_support_key
argument_list|(
name|evdev
argument_list|,
name|BTN_TOUCH
argument_list|)
expr_stmt|;
comment|/* Touchscreens should not advertise tap tool capabilities */
if|if
condition|(
operator|!
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_prop_flags
argument_list|,
name|INPUT_PROP_DIRECT
argument_list|)
condition|)
name|evdev_support_nfingers
argument_list|(
name|evdev
argument_list|,
name|MAXIMAL_MT_SLOT
argument_list|(
name|evdev
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Echo 0-th MT-slot as ST-slot */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|evdev_mtstmap
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_abs_flags
argument_list|,
name|evdev_mtstmap
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
name|evdev_support_abs
argument_list|(
name|evdev
argument_list|,
name|evdev_mtstmap
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|evdev
operator|->
name|ev_absinfo
index|[
name|evdev_mtstmap
index|[
name|i
index|]
index|[
literal|0
index|]
index|]
operator|.
name|value
argument_list|,
name|evdev
operator|->
name|ev_absinfo
index|[
name|evdev_mtstmap
index|[
name|i
index|]
index|[
literal|0
index|]
index|]
operator|.
name|minimum
argument_list|,
name|evdev
operator|->
name|ev_absinfo
index|[
name|evdev_mtstmap
index|[
name|i
index|]
index|[
literal|0
index|]
index|]
operator|.
name|maximum
argument_list|,
name|evdev
operator|->
name|ev_absinfo
index|[
name|evdev_mtstmap
index|[
name|i
index|]
index|[
literal|0
index|]
index|]
operator|.
name|fuzz
argument_list|,
name|evdev
operator|->
name|ev_absinfo
index|[
name|evdev_mtstmap
index|[
name|i
index|]
index|[
literal|0
index|]
index|]
operator|.
name|flat
argument_list|,
name|evdev
operator|->
name|ev_absinfo
index|[
name|evdev_mtstmap
index|[
name|i
index|]
index|[
literal|0
index|]
index|]
operator|.
name|resolution
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|evdev_count_fingers
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|)
block|{
name|int32_t
name|nfingers
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAXIMAL_MT_SLOT
argument_list|(
name|evdev
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|evdev_get_mt_value
argument_list|(
name|evdev
argument_list|,
name|i
argument_list|,
name|ABS_MT_TRACKING_ID
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|nfingers
operator|++
expr_stmt|;
return|return
operator|(
name|nfingers
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|evdev_send_nfingers
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|int32_t
name|nfingers
parameter_list|)
block|{
name|int32_t
name|i
decl_stmt|;
name|EVDEV_LOCK_ASSERT
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfingers
operator|>
name|nitems
argument_list|(
name|evdev_fngmap
argument_list|)
condition|)
name|nfingers
operator|=
name|nitems
argument_list|(
name|evdev_fngmap
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|evdev_fngmap
argument_list|)
condition|;
name|i
operator|++
control|)
name|evdev_send_event
argument_list|(
name|evdev
argument_list|,
name|EV_KEY
argument_list|,
name|evdev_fngmap
index|[
name|i
index|]
argument_list|,
name|nfingers
operator|==
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evdev_push_nfingers
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|int32_t
name|nfingers
parameter_list|)
block|{
name|EVDEV_ENTER
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
name|evdev_send_nfingers
argument_list|(
name|evdev
argument_list|,
name|nfingers
argument_list|)
expr_stmt|;
name|EVDEV_EXIT
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evdev_send_mt_compat
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|)
block|{
name|int32_t
name|nfingers
decl_stmt|,
name|i
decl_stmt|;
name|EVDEV_LOCK_ASSERT
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
name|nfingers
operator|=
name|evdev_count_fingers
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
name|evdev_send_event
argument_list|(
name|evdev
argument_list|,
name|EV_KEY
argument_list|,
name|BTN_TOUCH
argument_list|,
name|nfingers
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|evdev_get_mt_value
argument_list|(
name|evdev
argument_list|,
literal|0
argument_list|,
name|ABS_MT_TRACKING_ID
argument_list|)
operator|!=
operator|-
literal|1
condition|)
comment|/* Echo 0-th MT-slot as ST-slot */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|evdev_mtstmap
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_abs_flags
argument_list|,
name|evdev_mtstmap
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
condition|)
name|evdev_send_event
argument_list|(
name|evdev
argument_list|,
name|EV_ABS
argument_list|,
name|evdev_mtstmap
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|evdev_get_mt_value
argument_list|(
name|evdev
argument_list|,
literal|0
argument_list|,
name|evdev_mtstmap
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Touchscreens should not report tool taps */
if|if
condition|(
operator|!
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_prop_flags
argument_list|,
name|INPUT_PROP_DIRECT
argument_list|)
condition|)
name|evdev_send_nfingers
argument_list|(
name|evdev
argument_list|,
name|nfingers
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfingers
operator|==
literal|0
condition|)
name|evdev_send_event
argument_list|(
name|evdev
argument_list|,
name|EV_ABS
argument_list|,
name|ABS_PRESSURE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evdev_push_mt_compat
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|)
block|{
name|EVDEV_ENTER
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
name|evdev_send_mt_compat
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
name|EVDEV_EXIT
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evdev_send_mt_autorel
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|)
block|{
name|int32_t
name|slot
decl_stmt|;
name|EVDEV_LOCK_ASSERT
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<=
name|MAXIMAL_MT_SLOT
argument_list|(
name|evdev
argument_list|)
condition|;
name|slot
operator|++
control|)
block|{
if|if
condition|(
name|evdev
operator|->
name|ev_mt
operator|->
name|ev_mt_slots
index|[
name|slot
index|]
operator|.
name|ev_report
operator|!=
name|evdev
operator|->
name|ev_report_count
operator|&&
name|evdev_get_mt_value
argument_list|(
name|evdev
argument_list|,
name|slot
argument_list|,
name|ABS_MT_TRACKING_ID
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|evdev_send_event
argument_list|(
name|evdev
argument_list|,
name|EV_ABS
argument_list|,
name|ABS_MT_SLOT
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|evdev_send_event
argument_list|(
name|evdev
argument_list|,
name|EV_ABS
argument_list|,
name|ABS_MT_TRACKING_ID
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

