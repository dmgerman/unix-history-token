begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014 Jakub Wojciech Klama<jceel@FreeBSD.org>  * Copyright (c) 2015-2016 Vladimir Kondratyev<wulf@cicgroup.ru>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_evdev.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/bitstring.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<dev/evdev/input.h>
end_include

begin_include
include|#
directive|include
file|<dev/evdev/evdev.h>
end_include

begin_include
include|#
directive|include
file|<dev/evdev/evdev_private.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVDEV_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|debugf
parameter_list|(
name|client
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|printf("evdev cdev: "fmt"\n", ##args)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debugf
parameter_list|(
name|client
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEF_RING_REPORTS
value|8
end_define

begin_decl_stmt
specifier|static
name|d_open_t
name|evdev_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|evdev_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|evdev_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|evdev_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|evdev_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_kqfilter_t
name|evdev_kqfilter
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|evdev_kqread
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evdev_kqdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evdev_dtor
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|evdev_ioctl_eviocgbit
parameter_list|(
name|struct
name|evdev_dev
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evdev_client_filter_queue
parameter_list|(
name|struct
name|evdev_client
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|evdev_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|evdev_open
block|,
operator|.
name|d_read
operator|=
name|evdev_read
block|,
operator|.
name|d_write
operator|=
name|evdev_write
block|,
operator|.
name|d_ioctl
operator|=
name|evdev_ioctl
block|,
operator|.
name|d_poll
operator|=
name|evdev_poll
block|,
operator|.
name|d_kqfilter
operator|=
name|evdev_kqfilter
block|,
operator|.
name|d_name
operator|=
literal|"evdev"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|evdev_cdev_filterops
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|1
block|,
operator|.
name|f_attach
operator|=
name|NULL
block|,
operator|.
name|f_detach
operator|=
name|evdev_kqdetach
block|,
operator|.
name|f_event
operator|=
name|evdev_kqread
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|evdev_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|evdev_dev
modifier|*
name|evdev
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|struct
name|evdev_client
modifier|*
name|client
decl_stmt|;
name|size_t
name|buffer_size
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|evdev
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Initialize client structure */
name|buffer_size
operator|=
name|evdev
operator|->
name|ev_report_size
operator|*
name|DEF_RING_REPORTS
expr_stmt|;
name|client
operator|=
name|malloc
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|evdev_client
argument_list|,
name|ec_buffer
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|input_event
argument_list|)
operator|*
name|buffer_size
argument_list|,
name|M_EVDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* Initialize ring buffer */
name|client
operator|->
name|ec_buffer_size
operator|=
name|buffer_size
expr_stmt|;
name|client
operator|->
name|ec_buffer_head
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|ec_buffer_tail
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|ec_buffer_ready
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|ec_evdev
operator|=
name|evdev
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|client
operator|->
name|ec_buffer_mtx
argument_list|,
literal|"evclient"
argument_list|,
literal|"evdev"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|knlist_init_mtx
argument_list|(
operator|&
name|client
operator|->
name|ec_selp
operator|.
name|si_note
argument_list|,
operator|&
name|client
operator|->
name|ec_buffer_mtx
argument_list|)
expr_stmt|;
comment|/* Avoid race with evdev_unregister */
name|EVDEV_LOCK
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|si_drv1
operator|==
name|NULL
condition|)
name|ret
operator|=
name|ENODEV
expr_stmt|;
else|else
name|ret
operator|=
name|evdev_register_client
argument_list|(
name|evdev
argument_list|,
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|evdev_revoke_client
argument_list|(
name|client
argument_list|)
expr_stmt|;
comment|/* 	 * Unlock evdev here because non-sleepable lock held  	 * while calling devfs_set_cdevpriv upsets WITNESS 	 */
name|EVDEV_UNLOCK
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|devfs_set_cdevpriv
argument_list|(
name|client
argument_list|,
name|evdev_dtor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|debugf
argument_list|(
name|client
argument_list|,
literal|"cannot register evdev client"
argument_list|)
expr_stmt|;
name|evdev_dtor
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|evdev_dtor
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|evdev_client
modifier|*
name|client
init|=
operator|(
expr|struct
name|evdev_client
operator|*
operator|)
name|data
decl_stmt|;
name|EVDEV_LOCK
argument_list|(
name|client
operator|->
name|ec_evdev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|client
operator|->
name|ec_revoked
condition|)
name|evdev_dispose_client
argument_list|(
name|client
operator|->
name|ec_evdev
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|EVDEV_UNLOCK
argument_list|(
name|client
operator|->
name|ec_evdev
argument_list|)
expr_stmt|;
name|knlist_clear
argument_list|(
operator|&
name|client
operator|->
name|ec_selp
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seldrain
argument_list|(
operator|&
name|client
operator|->
name|ec_selp
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|client
operator|->
name|ec_selp
operator|.
name|si_note
argument_list|)
expr_stmt|;
name|funsetown
argument_list|(
operator|&
name|client
operator|->
name|ec_sigio
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|client
operator|->
name|ec_buffer_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|client
argument_list|,
name|M_EVDEV
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|evdev_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|evdev_client
modifier|*
name|client
decl_stmt|;
name|struct
name|input_event
modifier|*
name|event
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|remaining
decl_stmt|;
name|ret
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|debugf
argument_list|(
name|client
argument_list|,
literal|"read %zd bytes by thread %d"
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|uio
operator|->
name|uio_td
operator|->
name|td_tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|ec_revoked
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Zero-sized reads are allowed for error checking */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|!=
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|input_event
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|remaining
operator|=
name|uio
operator|->
name|uio_resid
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|input_event
argument_list|)
expr_stmt|;
name|EVDEV_CLIENT_LOCKQ
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVDEV_CLIENT_EMPTYQ
argument_list|(
name|client
argument_list|)
condition|)
block|{
if|if
condition|(
name|ioflag
operator|&
name|O_NONBLOCK
condition|)
name|ret
operator|=
name|EWOULDBLOCK
expr_stmt|;
else|else
block|{
if|if
condition|(
name|remaining
operator|!=
literal|0
condition|)
block|{
name|client
operator|->
name|ec_blocked
operator|=
name|true
expr_stmt|;
name|ret
operator|=
name|mtx_sleep
argument_list|(
name|client
argument_list|,
operator|&
name|client
operator|->
name|ec_buffer_mtx
argument_list|,
name|PCATCH
argument_list|,
literal|"evread"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
name|ret
operator|==
literal|0
operator|&&
operator|!
name|EVDEV_CLIENT_EMPTYQ
argument_list|(
name|client
argument_list|)
operator|&&
name|remaining
operator|>
literal|0
condition|)
block|{
name|event
operator|=
operator|&
name|client
operator|->
name|ec_buffer
index|[
name|client
operator|->
name|ec_buffer_head
index|]
expr_stmt|;
name|client
operator|->
name|ec_buffer_head
operator|=
operator|(
name|client
operator|->
name|ec_buffer_head
operator|+
literal|1
operator|)
operator|%
name|client
operator|->
name|ec_buffer_size
expr_stmt|;
name|remaining
operator|--
expr_stmt|;
name|EVDEV_CLIENT_UNLOCKQ
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|ret
operator|=
name|uiomove
argument_list|(
name|event
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|input_event
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|EVDEV_CLIENT_LOCKQ
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
name|EVDEV_CLIENT_UNLOCKQ
argument_list|(
name|client
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|evdev_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|evdev_dev
modifier|*
name|evdev
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|struct
name|evdev_client
modifier|*
name|client
decl_stmt|;
name|struct
name|input_event
name|event
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|ret
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|debugf
argument_list|(
name|client
argument_list|,
literal|"write %zd bytes by thread %d"
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|uio
operator|->
name|uio_td
operator|->
name|td_tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|ec_revoked
operator|||
name|evdev
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|%
sizeof|sizeof
argument_list|(
expr|struct
name|input_event
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|debugf
argument_list|(
name|client
argument_list|,
literal|"write size not multiple of input_event size"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|uiomove
argument_list|(
operator|&
name|event
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|input_event
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|ret
operator|=
name|evdev_inject_event
argument_list|(
name|evdev
argument_list|,
name|event
operator|.
name|type
argument_list|,
name|event
operator|.
name|code
argument_list|,
name|event
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|evdev_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|evdev_client
modifier|*
name|client
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
name|ret
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|POLLNVAL
operator|)
return|;
name|debugf
argument_list|(
name|client
argument_list|,
literal|"poll by thread %d"
argument_list|,
name|td
operator|->
name|td_tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|ec_revoked
condition|)
return|return
operator|(
name|POLLHUP
operator|)
return|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
name|EVDEV_CLIENT_LOCKQ
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EVDEV_CLIENT_EMPTYQ
argument_list|(
name|client
argument_list|)
condition|)
name|revents
operator|=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
else|else
block|{
name|client
operator|->
name|ec_selected
operator|=
name|true
expr_stmt|;
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|client
operator|->
name|ec_selp
argument_list|)
expr_stmt|;
block|}
name|EVDEV_CLIENT_UNLOCKQ
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|evdev_kqfilter
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|evdev_client
modifier|*
name|client
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|client
operator|->
name|ec_revoked
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
switch|switch
condition|(
name|kn
operator|->
name|kn_filter
condition|)
block|{
case|case
name|EVFILT_READ
case|:
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|evdev_cdev_filterops
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|kn
operator|->
name|kn_hook
operator|=
operator|(
name|caddr_t
operator|)
name|client
expr_stmt|;
name|knlist_add
argument_list|(
operator|&
name|client
operator|->
name|ec_selp
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|evdev_kqread
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|evdev_client
modifier|*
name|client
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|client
operator|=
operator|(
expr|struct
name|evdev_client
operator|*
operator|)
name|kn
operator|->
name|kn_hook
expr_stmt|;
name|EVDEV_CLIENT_LOCKQ_ASSERT
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|ec_revoked
condition|)
block|{
name|kn
operator|->
name|kn_flags
operator||=
name|EV_EOF
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|kn
operator|->
name|kn_data
operator|=
name|EVDEV_CLIENT_SIZEQ
argument_list|(
name|client
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|input_event
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|!
name|EVDEV_CLIENT_EMPTYQ
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|evdev_kqdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|evdev_client
modifier|*
name|client
decl_stmt|;
name|client
operator|=
operator|(
expr|struct
name|evdev_client
operator|*
operator|)
name|kn
operator|->
name|kn_hook
expr_stmt|;
name|knlist_remove
argument_list|(
operator|&
name|client
operator|->
name|ec_selp
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|evdev_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|evdev_dev
modifier|*
name|evdev
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|struct
name|evdev_client
modifier|*
name|client
decl_stmt|;
name|struct
name|input_keymap_entry
modifier|*
name|ke
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|len
decl_stmt|,
name|limit
decl_stmt|,
name|type_num
decl_stmt|;
name|uint32_t
name|code
decl_stmt|;
name|size_t
name|nvalues
decl_stmt|;
name|ret
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|client
operator|->
name|ec_revoked
operator|||
name|evdev
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* file I/O ioctl handling */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FIOSETOWN
case|:
return|return
operator|(
name|fsetown
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
operator|&
name|client
operator|->
name|ec_sigio
argument_list|)
operator|)
return|;
case|case
name|FIOGETOWN
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|fgetown
argument_list|(
operator|&
name|client
operator|->
name|ec_sigio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FIONBIO
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FIOASYNC
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|client
operator|->
name|ec_async
operator|=
name|true
expr_stmt|;
else|else
name|client
operator|->
name|ec_async
operator|=
name|false
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FIONREAD
case|:
name|EVDEV_CLIENT_LOCKQ
argument_list|(
name|client
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|EVDEV_CLIENT_SIZEQ
argument_list|(
name|client
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|input_event
argument_list|)
expr_stmt|;
name|EVDEV_CLIENT_UNLOCKQ
argument_list|(
name|client
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|len
operator|=
name|IOCPARM_LEN
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
name|client
argument_list|,
literal|"ioctl called: cmd=0x%08lx, data=%p"
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* evdev fixed-length ioctls handling */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|EVIOCGVERSION
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|EV_VERSION
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCGID
case|:
name|debugf
argument_list|(
name|client
argument_list|,
literal|"EVIOCGID: bus=%d vendor=0x%04x product=0x%04x"
argument_list|,
name|evdev
operator|->
name|ev_id
operator|.
name|bustype
argument_list|,
name|evdev
operator|->
name|ev_id
operator|.
name|vendor
argument_list|,
name|evdev
operator|->
name|ev_id
operator|.
name|product
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
operator|&
name|evdev
operator|->
name|ev_id
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|input_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCGREP
case|:
if|if
condition|(
operator|!
name|evdev_event_supported
argument_list|(
name|evdev
argument_list|,
name|EV_REP
argument_list|)
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|evdev
operator|->
name|ev_rep
argument_list|,
sizeof|sizeof
argument_list|(
name|evdev
operator|->
name|ev_rep
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCSREP
case|:
if|if
condition|(
operator|!
name|evdev_event_supported
argument_list|(
name|evdev
argument_list|,
name|EV_REP
argument_list|)
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
name|evdev_inject_event
argument_list|(
name|evdev
argument_list|,
name|EV_REP
argument_list|,
name|REP_DELAY
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|evdev_inject_event
argument_list|(
name|evdev
argument_list|,
name|EV_REP
argument_list|,
name|REP_PERIOD
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCGKEYCODE
case|:
comment|/* Fake unsupported ioctl */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCGKEYCODE_V2
case|:
if|if
condition|(
name|evdev
operator|->
name|ev_methods
operator|==
name|NULL
operator|||
name|evdev
operator|->
name|ev_methods
operator|->
name|ev_get_keycode
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
name|ke
operator|=
operator|(
expr|struct
name|input_keymap_entry
operator|*
operator|)
name|data
expr_stmt|;
name|evdev
operator|->
name|ev_methods
operator|->
name|ev_get_keycode
argument_list|(
name|evdev
argument_list|,
name|evdev
operator|->
name|ev_softc
argument_list|,
name|ke
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCSKEYCODE
case|:
comment|/* Fake unsupported ioctl */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCSKEYCODE_V2
case|:
if|if
condition|(
name|evdev
operator|->
name|ev_methods
operator|==
name|NULL
operator|||
name|evdev
operator|->
name|ev_methods
operator|->
name|ev_set_keycode
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
name|ke
operator|=
operator|(
expr|struct
name|input_keymap_entry
operator|*
operator|)
name|data
expr_stmt|;
name|evdev
operator|->
name|ev_methods
operator|->
name|ev_set_keycode
argument_list|(
name|evdev
argument_list|,
name|evdev
operator|->
name|ev_softc
argument_list|,
name|ke
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCGABS
argument_list|(
literal|0
argument_list|)
operator|...
name|EVIOCGABS
argument_list|(
name|ABS_MAX
argument_list|)
case|:
if|if
condition|(
name|evdev
operator|->
name|ev_absinfo
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memcpy
argument_list|(
name|data
argument_list|,
operator|&
name|evdev
operator|->
name|ev_absinfo
index|[
name|cmd
operator|-
name|EVIOCGABS
argument_list|(
literal|0
argument_list|)
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|input_absinfo
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCSABS
argument_list|(
literal|0
argument_list|)
operator|...
name|EVIOCSABS
argument_list|(
name|ABS_MAX
argument_list|)
case|:
if|if
condition|(
name|evdev
operator|->
name|ev_absinfo
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|code
operator|=
name|cmd
operator|-
name|EVIOCSABS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* mt-slot number can not be changed */
if|if
condition|(
name|code
operator|==
name|ABS_MT_SLOT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|EVDEV_LOCK
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
name|evdev_set_absinfo
argument_list|(
name|evdev
argument_list|,
name|code
argument_list|,
operator|(
expr|struct
name|input_absinfo
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|EVDEV_UNLOCK
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCSFF
case|:
case|case
name|EVIOCRMFF
case|:
case|case
name|EVIOCGEFFECTS
case|:
comment|/* Fake unsupported ioctls */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCGRAB
case|:
name|EVDEV_LOCK
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|ret
operator|=
name|evdev_grab_client
argument_list|(
name|evdev
argument_list|,
name|client
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|evdev_release_client
argument_list|(
name|evdev
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|EVDEV_UNLOCK
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
case|case
name|EVIOCREVOKE
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|EVDEV_LOCK
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|si_drv1
operator|!=
name|NULL
operator|&&
operator|!
name|client
operator|->
name|ec_revoked
condition|)
block|{
name|evdev_dispose_client
argument_list|(
name|evdev
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|evdev_revoke_client
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
name|EVDEV_UNLOCK
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCSCLOCKID
case|:
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
case|case
name|CLOCK_REALTIME
case|:
name|client
operator|->
name|ec_clock_id
operator|=
name|EV_CLOCK_REALTIME
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CLOCK_MONOTONIC
case|:
name|client
operator|->
name|ec_clock_id
operator|=
name|EV_CLOCK_MONOTONIC
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/* evdev variable-length ioctls handling */
switch|switch
condition|(
name|IOCBASECMD
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
case|case
name|EVIOCGNAME
argument_list|(
literal|0
argument_list|)
case|:
name|strlcpy
argument_list|(
name|data
argument_list|,
name|evdev
operator|->
name|ev_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCGPHYS
argument_list|(
literal|0
argument_list|)
case|:
if|if
condition|(
name|evdev
operator|->
name|ev_shortname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|strlcpy
argument_list|(
name|data
argument_list|,
name|evdev
operator|->
name|ev_shortname
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCGUNIQ
argument_list|(
literal|0
argument_list|)
case|:
if|if
condition|(
name|evdev
operator|->
name|ev_serial
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|strlcpy
argument_list|(
name|data
argument_list|,
name|evdev
operator|->
name|ev_serial
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCGPROP
argument_list|(
literal|0
argument_list|)
case|:
name|limit
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|bitstr_size
argument_list|(
name|INPUT_PROP_CNT
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|evdev
operator|->
name|ev_prop_flags
argument_list|,
name|limit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCGMTSLOTS
argument_list|(
literal|0
argument_list|)
case|:
if|if
condition|(
name|evdev
operator|->
name|ev_mt
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|code
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|ABS_IS_MT
argument_list|(
name|code
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|nvalues
operator|=
name|MIN
argument_list|(
name|len
operator|/
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
operator|-
literal|1
argument_list|,
name|MAXIMAL_MT_SLOT
argument_list|(
name|evdev
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nvalues
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|int32_t
operator|*
operator|)
name|data
operator|)
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|evdev_get_mt_value
argument_list|(
name|evdev
argument_list|,
name|i
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCGKEY
argument_list|(
literal|0
argument_list|)
case|:
name|limit
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|bitstr_size
argument_list|(
name|KEY_CNT
argument_list|)
argument_list|)
expr_stmt|;
name|EVDEV_LOCK
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
name|evdev_client_filter_queue
argument_list|(
name|client
argument_list|,
name|EV_KEY
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|evdev
operator|->
name|ev_key_states
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|EVDEV_UNLOCK
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCGLED
argument_list|(
literal|0
argument_list|)
case|:
name|limit
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|bitstr_size
argument_list|(
name|LED_CNT
argument_list|)
argument_list|)
expr_stmt|;
name|EVDEV_LOCK
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
name|evdev_client_filter_queue
argument_list|(
name|client
argument_list|,
name|EV_LED
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|evdev
operator|->
name|ev_led_states
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|EVDEV_UNLOCK
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCGSND
argument_list|(
literal|0
argument_list|)
case|:
name|limit
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|bitstr_size
argument_list|(
name|SND_CNT
argument_list|)
argument_list|)
expr_stmt|;
name|EVDEV_LOCK
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
name|evdev_client_filter_queue
argument_list|(
name|client
argument_list|,
name|EV_SND
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|evdev
operator|->
name|ev_snd_states
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|EVDEV_UNLOCK
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCGSW
argument_list|(
literal|0
argument_list|)
case|:
name|limit
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|bitstr_size
argument_list|(
name|SW_CNT
argument_list|)
argument_list|)
expr_stmt|;
name|EVDEV_LOCK
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
name|evdev_client_filter_queue
argument_list|(
name|client
argument_list|,
name|EV_SW
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|evdev
operator|->
name|ev_sw_states
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|EVDEV_UNLOCK
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVIOCGBIT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|...
name|EVIOCGBIT
argument_list|(
name|EV_MAX
argument_list|,
literal|0
argument_list|)
case|:
name|type_num
operator|=
name|IOCBASECMD
argument_list|(
name|cmd
argument_list|)
operator|-
name|EVIOCGBIT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
name|client
argument_list|,
literal|"EVIOCGBIT(%d): data=%p, len=%d"
argument_list|,
name|type_num
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|evdev_ioctl_eviocgbit
argument_list|(
name|evdev
argument_list|,
name|type_num
argument_list|,
name|len
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|evdev_ioctl_eviocgbit
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|len
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|unsigned
name|long
modifier|*
name|bitmap
decl_stmt|;
name|int
name|limit
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0
case|:
name|bitmap
operator|=
name|evdev
operator|->
name|ev_type_flags
expr_stmt|;
name|limit
operator|=
name|EV_CNT
expr_stmt|;
break|break;
case|case
name|EV_KEY
case|:
name|bitmap
operator|=
name|evdev
operator|->
name|ev_key_flags
expr_stmt|;
name|limit
operator|=
name|KEY_CNT
expr_stmt|;
break|break;
case|case
name|EV_REL
case|:
name|bitmap
operator|=
name|evdev
operator|->
name|ev_rel_flags
expr_stmt|;
name|limit
operator|=
name|REL_CNT
expr_stmt|;
break|break;
case|case
name|EV_ABS
case|:
name|bitmap
operator|=
name|evdev
operator|->
name|ev_abs_flags
expr_stmt|;
name|limit
operator|=
name|ABS_CNT
expr_stmt|;
break|break;
case|case
name|EV_MSC
case|:
name|bitmap
operator|=
name|evdev
operator|->
name|ev_msc_flags
expr_stmt|;
name|limit
operator|=
name|MSC_CNT
expr_stmt|;
break|break;
case|case
name|EV_LED
case|:
name|bitmap
operator|=
name|evdev
operator|->
name|ev_led_flags
expr_stmt|;
name|limit
operator|=
name|LED_CNT
expr_stmt|;
break|break;
case|case
name|EV_SND
case|:
name|bitmap
operator|=
name|evdev
operator|->
name|ev_snd_flags
expr_stmt|;
name|limit
operator|=
name|SND_CNT
expr_stmt|;
break|break;
case|case
name|EV_SW
case|:
name|bitmap
operator|=
name|evdev
operator|->
name|ev_sw_flags
expr_stmt|;
name|limit
operator|=
name|SW_CNT
expr_stmt|;
break|break;
case|case
name|EV_FF
case|:
comment|/* 		 * We don't support EV_FF now, so let's 		 * just fake it returning only zeros. 		 */
name|bzero
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
comment|/* 	 * Clear ioctl data buffer in case it's bigger than 	 * bitmap size 	 */
name|bzero
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|limit
operator|=
name|bitstr_size
argument_list|(
name|limit
argument_list|)
expr_stmt|;
name|len
operator|=
name|MIN
argument_list|(
name|limit
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|bitmap
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|evdev_revoke_client
parameter_list|(
name|struct
name|evdev_client
modifier|*
name|client
parameter_list|)
block|{
name|EVDEV_LOCK_ASSERT
argument_list|(
name|client
operator|->
name|ec_evdev
argument_list|)
expr_stmt|;
name|client
operator|->
name|ec_revoked
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evdev_notify_event
parameter_list|(
name|struct
name|evdev_client
modifier|*
name|client
parameter_list|)
block|{
name|EVDEV_CLIENT_LOCKQ_ASSERT
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|ec_blocked
condition|)
block|{
name|client
operator|->
name|ec_blocked
operator|=
name|false
expr_stmt|;
name|wakeup
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|client
operator|->
name|ec_selected
condition|)
block|{
name|client
operator|->
name|ec_selected
operator|=
name|false
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|client
operator|->
name|ec_selp
argument_list|)
expr_stmt|;
block|}
name|KNOTE_LOCKED
argument_list|(
operator|&
name|client
operator|->
name|ec_selp
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|ec_async
operator|&&
name|client
operator|->
name|ec_sigio
operator|!=
name|NULL
condition|)
name|pgsigio
argument_list|(
operator|&
name|client
operator|->
name|ec_sigio
argument_list|,
name|SIGIO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|evdev_cdev_create
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|)
block|{
name|struct
name|make_dev_args
name|mda
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|unit
init|=
literal|0
decl_stmt|;
name|make_dev_args_init
argument_list|(
operator|&
name|mda
argument_list|)
expr_stmt|;
name|mda
operator|.
name|mda_flags
operator|=
name|MAKEDEV_WAITOK
operator||
name|MAKEDEV_CHECKNAME
expr_stmt|;
name|mda
operator|.
name|mda_devsw
operator|=
operator|&
name|evdev_cdevsw
expr_stmt|;
name|mda
operator|.
name|mda_uid
operator|=
name|UID_ROOT
expr_stmt|;
name|mda
operator|.
name|mda_gid
operator|=
name|GID_WHEEL
expr_stmt|;
name|mda
operator|.
name|mda_mode
operator|=
literal|0600
expr_stmt|;
name|mda
operator|.
name|mda_si_drv1
operator|=
name|evdev
expr_stmt|;
comment|/* Try to coexist with cuse-backed input/event devices */
while|while
condition|(
operator|(
name|ret
operator|=
name|make_dev_s
argument_list|(
operator|&
name|mda
argument_list|,
operator|&
name|evdev
operator|->
name|ev_cdev
argument_list|,
literal|"input/event%d"
argument_list|,
name|unit
argument_list|)
operator|)
operator|==
name|EEXIST
condition|)
name|unit
operator|++
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|evdev
operator|->
name|ev_unit
operator|=
name|unit
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evdev_cdev_destroy
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|)
block|{
name|destroy_dev
argument_list|(
name|evdev
operator|->
name|ev_cdev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|evdev_client_gettime
parameter_list|(
name|struct
name|evdev_client
modifier|*
name|client
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
switch|switch
condition|(
name|client
operator|->
name|ec_clock_id
condition|)
block|{
case|case
name|EV_CLOCK_BOOTTIME
case|:
comment|/* 		 * XXX: FreeBSD does not support true POSIX monotonic clock. 		 *      So aliase EV_CLOCK_BOOTTIME to EV_CLOCK_MONOTONIC. 		 */
case|case
name|EV_CLOCK_MONOTONIC
case|:
name|microuptime
argument_list|(
name|tv
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_CLOCK_REALTIME
case|:
default|default:
name|microtime
argument_list|(
name|tv
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|evdev_client_push
parameter_list|(
name|struct
name|evdev_client
modifier|*
name|client
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|code
parameter_list|,
name|int32_t
name|value
parameter_list|)
block|{
name|struct
name|timeval
name|time
decl_stmt|;
name|size_t
name|count
decl_stmt|,
name|head
decl_stmt|,
name|tail
decl_stmt|,
name|ready
decl_stmt|;
name|EVDEV_CLIENT_LOCKQ_ASSERT
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|head
operator|=
name|client
operator|->
name|ec_buffer_head
expr_stmt|;
name|tail
operator|=
name|client
operator|->
name|ec_buffer_tail
expr_stmt|;
name|ready
operator|=
name|client
operator|->
name|ec_buffer_ready
expr_stmt|;
name|count
operator|=
name|client
operator|->
name|ec_buffer_size
expr_stmt|;
comment|/* If queue is full drop its content and place SYN_DROPPED event */
if|if
condition|(
operator|(
name|tail
operator|+
literal|1
operator|)
operator|%
name|count
operator|==
name|head
condition|)
block|{
name|debugf
argument_list|(
name|client
argument_list|,
literal|"client %p: buffer overflow"
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|head
operator|=
operator|(
name|tail
operator|+
name|count
operator|-
literal|1
operator|)
operator|%
name|count
expr_stmt|;
name|client
operator|->
name|ec_buffer
index|[
name|head
index|]
operator|=
operator|(
expr|struct
name|input_event
operator|)
block|{
operator|.
name|type
operator|=
name|EV_SYN
block|,
operator|.
name|code
operator|=
name|SYN_DROPPED
block|,
operator|.
name|value
operator|=
literal|0
block|}
expr_stmt|;
comment|/* 		 * XXX: Here is a small race window from now till the end of 		 *      report. The queue is empty but client has been already 		 *      notified of data readyness. Can be fixed in two ways: 		 * 1. Implement bulk insert so queue lock would not be dropped 		 *    till the SYN_REPORT event. 		 * 2. Insert SYN_REPORT just now and skip remaining events 		 */
name|client
operator|->
name|ec_buffer_head
operator|=
name|head
expr_stmt|;
name|client
operator|->
name|ec_buffer_ready
operator|=
name|head
expr_stmt|;
block|}
name|client
operator|->
name|ec_buffer
index|[
name|tail
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|client
operator|->
name|ec_buffer
index|[
name|tail
index|]
operator|.
name|code
operator|=
name|code
expr_stmt|;
name|client
operator|->
name|ec_buffer
index|[
name|tail
index|]
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|client
operator|->
name|ec_buffer_tail
operator|=
operator|(
name|tail
operator|+
literal|1
operator|)
operator|%
name|count
expr_stmt|;
comment|/* Allow users to read events only after report has been completed */
if|if
condition|(
name|type
operator|==
name|EV_SYN
operator|&&
name|code
operator|==
name|SYN_REPORT
condition|)
block|{
name|evdev_client_gettime
argument_list|(
name|client
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ready
operator|!=
name|client
operator|->
name|ec_buffer_tail
condition|;
name|ready
operator|=
operator|(
name|ready
operator|+
literal|1
operator|)
operator|%
name|count
control|)
name|client
operator|->
name|ec_buffer
index|[
name|ready
index|]
operator|.
name|time
operator|=
name|time
expr_stmt|;
name|client
operator|->
name|ec_buffer_ready
operator|=
name|client
operator|->
name|ec_buffer_tail
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|evdev_client_dumpqueue
parameter_list|(
name|struct
name|evdev_client
modifier|*
name|client
parameter_list|)
block|{
name|struct
name|input_event
modifier|*
name|event
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|head
decl_stmt|,
name|tail
decl_stmt|,
name|ready
decl_stmt|,
name|size
decl_stmt|;
name|head
operator|=
name|client
operator|->
name|ec_buffer_head
expr_stmt|;
name|tail
operator|=
name|client
operator|->
name|ec_buffer_tail
expr_stmt|;
name|ready
operator|=
name|client
operator|->
name|ec_buffer_ready
expr_stmt|;
name|size
operator|=
name|client
operator|->
name|ec_buffer_size
expr_stmt|;
name|printf
argument_list|(
literal|"evdev client: %p\n"
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"event queue: head=%zu ready=%zu tail=%zu size=%zu\n"
argument_list|,
name|head
argument_list|,
name|ready
argument_list|,
name|tail
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"queue contents:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|event
operator|=
operator|&
name|client
operator|->
name|ec_buffer
index|[
name|i
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%zu: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|head
operator|||
name|i
operator|>
name|tail
condition|)
name|printf
argument_list|(
literal|"unused\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"type=%d code=%d value=%d "
argument_list|,
name|event
operator|->
name|type
argument_list|,
name|event
operator|->
name|code
argument_list|,
name|event
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|head
condition|)
name|printf
argument_list|(
literal|"<- head\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|tail
condition|)
name|printf
argument_list|(
literal|"<- tail\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|ready
condition|)
name|printf
argument_list|(
literal|"<- ready\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|evdev_client_filter_queue
parameter_list|(
name|struct
name|evdev_client
modifier|*
name|client
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|struct
name|input_event
modifier|*
name|event
decl_stmt|;
name|size_t
name|head
decl_stmt|,
name|tail
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|;
name|bool
name|last_was_syn
init|=
name|false
decl_stmt|;
name|EVDEV_CLIENT_LOCKQ
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|i
operator|=
name|head
operator|=
name|client
operator|->
name|ec_buffer_head
expr_stmt|;
name|tail
operator|=
name|client
operator|->
name|ec_buffer_tail
expr_stmt|;
name|count
operator|=
name|client
operator|->
name|ec_buffer_size
expr_stmt|;
name|client
operator|->
name|ec_buffer_ready
operator|=
name|client
operator|->
name|ec_buffer_tail
expr_stmt|;
while|while
condition|(
name|i
operator|!=
name|client
operator|->
name|ec_buffer_tail
condition|)
block|{
name|event
operator|=
operator|&
name|client
operator|->
name|ec_buffer
index|[
name|i
index|]
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|count
expr_stmt|;
comment|/* Skip event of given type */
if|if
condition|(
name|event
operator|->
name|type
operator|==
name|type
condition|)
continue|continue;
comment|/* Remove empty SYN_REPORT events */
if|if
condition|(
name|event
operator|->
name|type
operator|==
name|EV_SYN
operator|&&
name|event
operator|->
name|code
operator|==
name|SYN_REPORT
condition|)
block|{
if|if
condition|(
name|last_was_syn
condition|)
continue|continue;
else|else
name|client
operator|->
name|ec_buffer_ready
operator|=
operator|(
name|tail
operator|+
literal|1
operator|)
operator|%
name|count
expr_stmt|;
block|}
comment|/* Rewrite entry */
name|memcpy
argument_list|(
operator|&
name|client
operator|->
name|ec_buffer
index|[
name|tail
index|]
argument_list|,
name|event
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|input_event
argument_list|)
argument_list|)
expr_stmt|;
name|last_was_syn
operator|=
operator|(
name|event
operator|->
name|type
operator|==
name|EV_SYN
operator|&&
name|event
operator|->
name|code
operator|==
name|SYN_REPORT
operator|)
expr_stmt|;
name|tail
operator|=
operator|(
name|tail
operator|+
literal|1
operator|)
operator|%
name|count
expr_stmt|;
block|}
name|client
operator|->
name|ec_buffer_head
operator|=
name|i
expr_stmt|;
name|client
operator|->
name|ec_buffer_tail
operator|=
name|tail
expr_stmt|;
name|EVDEV_CLIENT_UNLOCKQ
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

