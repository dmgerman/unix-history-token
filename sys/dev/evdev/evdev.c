begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014 Jakub Wojciech Klama<jceel@FreeBSD.org>  * Copyright (c) 2015-2016 Vladimir Kondratyev<wulf@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_evdev.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bitstring.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<dev/evdev/evdev.h>
end_include

begin_include
include|#
directive|include
file|<dev/evdev/evdev_private.h>
end_include

begin_include
include|#
directive|include
file|<dev/evdev/input.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVDEV_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|debugf
parameter_list|(
name|evdev
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|printf("evdev: " fmt "\n", ##args)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debugf
parameter_list|(
name|evdev
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FEATURE
end_ifdef

begin_expr_stmt
name|FEATURE
argument_list|(
name|evdev
argument_list|,
literal|"Input event devices support"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|evdev_sparse_result
block|{
name|EV_SKIP_EVENT
block|,
comment|/* Event value not changed */
name|EV_REPORT_EVENT
block|,
comment|/* Event value changed */
name|EV_REPORT_MT_SLOT
block|,
comment|/* Event value and MT slot number changed */
block|}
enum|;
end_enum

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_EVDEV
argument_list|,
literal|"evdev"
argument_list|,
literal|"evdev memory"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|evdev_rcpt_mask
init|=
name|EVDEV_RCPT_SYSMOUSE
operator||
name|EVDEV_RCPT_KBDMUX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|evdev_sysmouse_t_axis
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|EVDEV_SUPPORT
end_ifdef

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|evdev
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Evdev args"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_evdev
argument_list|,
name|OID_AUTO
argument_list|,
name|rcpt_mask
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|evdev_rcpt_mask
argument_list|,
literal|0
argument_list|,
literal|"Who is receiving events: bit0 - sysmouse, bit1 - kbdmux, "
literal|"bit2 - mouse hardware, bit3 - keyboard hardware"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_evdev
argument_list|,
name|OID_AUTO
argument_list|,
name|sysmouse_t_axis
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|evdev_sysmouse_t_axis
argument_list|,
literal|0
argument_list|,
literal|"Extract T-axis from 0-none, 1-ums, 2-psm"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|evdev_start_repeat
parameter_list|(
name|struct
name|evdev_dev
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evdev_stop_repeat
parameter_list|(
name|struct
name|evdev_dev
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|evdev_check_event
parameter_list|(
name|struct
name|evdev_dev
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|uint16_t
parameter_list|,
name|int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|void
name|bit_change
parameter_list|(
name|bitstr_t
modifier|*
name|bitstr
parameter_list|,
name|int
name|bit
parameter_list|,
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
condition|)
name|bit_set
argument_list|(
name|bitstr
argument_list|,
name|bit
argument_list|)
expr_stmt|;
else|else
name|bit_clear
argument_list|(
name|bitstr
argument_list|,
name|bit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|evdev_dev
modifier|*
name|evdev_alloc
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|evdev_dev
argument_list|)
argument_list|,
name|M_EVDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|evdev_free
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|)
block|{
if|if
condition|(
name|evdev
operator|!=
name|NULL
operator|&&
name|evdev
operator|->
name|ev_cdev
operator|!=
name|NULL
operator|&&
name|evdev
operator|->
name|ev_cdev
operator|->
name|si_drv1
operator|!=
name|NULL
condition|)
name|evdev_unregister
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|evdev
argument_list|,
name|M_EVDEV
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|input_absinfo
modifier|*
name|evdev_alloc_absinfo
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|input_absinfo
argument_list|)
operator|*
name|ABS_CNT
argument_list|,
name|M_EVDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|evdev_free_absinfo
parameter_list|(
name|struct
name|input_absinfo
modifier|*
name|absinfo
parameter_list|)
block|{
name|free
argument_list|(
name|absinfo
argument_list|,
name|M_EVDEV
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|evdev_set_report_size
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|size_t
name|report_size
parameter_list|)
block|{
if|if
condition|(
name|report_size
operator|>
name|KEY_CNT
operator|+
name|REL_CNT
operator|+
name|ABS_CNT
operator|+
name|MAX_MT_SLOTS
operator|*
name|MT_CNT
operator|+
name|MSC_CNT
operator|+
name|LED_CNT
operator|+
name|SND_CNT
operator|+
name|SW_CNT
operator|+
name|FF_CNT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|evdev
operator|->
name|ev_report_size
operator|=
name|report_size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|evdev_estimate_report_size
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|)
block|{
name|size_t
name|size
init|=
literal|0
decl_stmt|;
name|int
name|res
decl_stmt|;
comment|/* 	 * Keyboards generate one event per report but other devices with 	 * buttons like mouses can report events simultaneously 	 */
name|bit_ffs_at
argument_list|(
name|evdev
operator|->
name|ev_key_flags
argument_list|,
name|KEY_OK
argument_list|,
name|KEY_CNT
operator|-
name|KEY_OK
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
name|bit_ffs
argument_list|(
name|evdev
operator|->
name|ev_key_flags
argument_list|,
name|BTN_MISC
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|size
operator|+=
operator|(
name|res
operator|!=
operator|-
literal|1
operator|)
expr_stmt|;
name|bit_count
argument_list|(
name|evdev
operator|->
name|ev_key_flags
argument_list|,
name|BTN_MISC
argument_list|,
name|KEY_OK
operator|-
name|BTN_MISC
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|size
operator|+=
name|res
expr_stmt|;
comment|/* All relative axes can be reported simultaneously */
name|bit_count
argument_list|(
name|evdev
operator|->
name|ev_rel_flags
argument_list|,
literal|0
argument_list|,
name|REL_CNT
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|size
operator|+=
name|res
expr_stmt|;
comment|/* 	 * All absolute axes can be reported simultaneously. 	 * Multitouch axes can be reported ABS_MT_SLOT times 	 */
if|if
condition|(
name|evdev
operator|->
name|ev_absinfo
operator|!=
name|NULL
condition|)
block|{
name|bit_count
argument_list|(
name|evdev
operator|->
name|ev_abs_flags
argument_list|,
literal|0
argument_list|,
name|ABS_CNT
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|size
operator|+=
name|res
expr_stmt|;
name|bit_count
argument_list|(
name|evdev
operator|->
name|ev_abs_flags
argument_list|,
name|ABS_MT_FIRST
argument_list|,
name|MT_CNT
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
block|{
name|res
operator|++
expr_stmt|;
comment|/* ABS_MT_SLOT or SYN_MT_REPORT */
if|if
condition|(
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_abs_flags
argument_list|,
name|ABS_MT_SLOT
argument_list|)
condition|)
comment|/* MT type B */
name|size
operator|+=
name|res
operator|*
name|MAXIMAL_MT_SLOT
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
else|else
comment|/* MT type A */
name|size
operator|+=
name|res
operator|*
operator|(
name|MAX_MT_REPORTS
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
comment|/* All misc events can be reported simultaneously */
name|bit_count
argument_list|(
name|evdev
operator|->
name|ev_msc_flags
argument_list|,
literal|0
argument_list|,
name|MSC_CNT
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|size
operator|+=
name|res
expr_stmt|;
comment|/* All leds can be reported simultaneously */
name|bit_count
argument_list|(
name|evdev
operator|->
name|ev_led_flags
argument_list|,
literal|0
argument_list|,
name|LED_CNT
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|size
operator|+=
name|res
expr_stmt|;
comment|/* Assume other events are generated once per report */
name|bit_ffs
argument_list|(
name|evdev
operator|->
name|ev_snd_flags
argument_list|,
name|SND_CNT
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|size
operator|+=
operator|(
name|res
operator|!=
operator|-
literal|1
operator|)
expr_stmt|;
name|bit_ffs
argument_list|(
name|evdev
operator|->
name|ev_sw_flags
argument_list|,
name|SW_CNT
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|size
operator|+=
operator|(
name|res
operator|!=
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* XXX: FF part is not implemented yet */
name|size
operator|++
expr_stmt|;
comment|/* SYN_REPORT */
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|evdev_register_common
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|debugf
argument_list|(
name|evdev
argument_list|,
literal|"%s: registered evdev provider: %s<%s>\n"
argument_list|,
name|evdev
operator|->
name|ev_shortname
argument_list|,
name|evdev
operator|->
name|ev_name
argument_list|,
name|evdev
operator|->
name|ev_serial
argument_list|)
expr_stmt|;
comment|/* Initialize internal structures */
name|LIST_INIT
argument_list|(
operator|&
name|evdev
operator|->
name|ev_clients
argument_list|)
expr_stmt|;
if|if
condition|(
name|evdev_event_supported
argument_list|(
name|evdev
argument_list|,
name|EV_REP
argument_list|)
operator|&&
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_flags
argument_list|,
name|EVDEV_FLAG_SOFTREPEAT
argument_list|)
condition|)
block|{
comment|/* Initialize callout */
name|callout_init_mtx
argument_list|(
operator|&
name|evdev
operator|->
name|ev_rep_callout
argument_list|,
operator|&
name|evdev
operator|->
name|ev_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|evdev
operator|->
name|ev_rep
index|[
name|REP_DELAY
index|]
operator|==
literal|0
operator|&&
name|evdev
operator|->
name|ev_rep
index|[
name|REP_PERIOD
index|]
operator|==
literal|0
condition|)
block|{
comment|/* Supply default values */
name|evdev
operator|->
name|ev_rep
index|[
name|REP_DELAY
index|]
operator|=
literal|250
expr_stmt|;
name|evdev
operator|->
name|ev_rep
index|[
name|REP_PERIOD
index|]
operator|=
literal|33
expr_stmt|;
block|}
block|}
comment|/* Initialize multitouch protocol type B states */
if|if
condition|(
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_abs_flags
argument_list|,
name|ABS_MT_SLOT
argument_list|)
operator|&&
name|evdev
operator|->
name|ev_absinfo
operator|!=
name|NULL
operator|&&
name|MAXIMAL_MT_SLOT
argument_list|(
name|evdev
argument_list|)
operator|>
literal|0
condition|)
name|evdev_mt_init
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
comment|/* Estimate maximum report size */
if|if
condition|(
name|evdev
operator|->
name|ev_report_size
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|evdev_set_report_size
argument_list|(
name|evdev
argument_list|,
name|evdev_estimate_report_size
argument_list|(
name|evdev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|bail_out
goto|;
block|}
comment|/* Create char device node */
name|ret
operator|=
name|evdev_cdev_create
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
name|bail_out
label|:
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evdev_register
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|evdev
operator|->
name|ev_lock_type
operator|=
name|EV_LOCK_INTERNAL
expr_stmt|;
name|evdev
operator|->
name|ev_lock
operator|=
operator|&
name|evdev
operator|->
name|ev_mtx
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|evdev
operator|->
name|ev_mtx
argument_list|,
literal|"evmtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|ret
operator|=
name|evdev_register_common
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|evdev
operator|->
name|ev_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evdev_register_mtx
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|struct
name|mtx
modifier|*
name|mtx
parameter_list|)
block|{
name|evdev
operator|->
name|ev_lock_type
operator|=
name|EV_LOCK_MTX
expr_stmt|;
name|evdev
operator|->
name|ev_lock
operator|=
name|mtx
expr_stmt|;
return|return
operator|(
name|evdev_register_common
argument_list|(
name|evdev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evdev_unregister
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|)
block|{
name|struct
name|evdev_client
modifier|*
name|client
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|debugf
argument_list|(
name|evdev
argument_list|,
literal|"%s: unregistered evdev provider: %s\n"
argument_list|,
name|evdev
operator|->
name|ev_shortname
argument_list|,
name|evdev
operator|->
name|ev_name
argument_list|)
expr_stmt|;
name|EVDEV_LOCK
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
name|evdev
operator|->
name|ev_cdev
operator|->
name|si_drv1
operator|=
name|NULL
expr_stmt|;
comment|/* Wake up sleepers */
name|LIST_FOREACH
argument_list|(
argument|client
argument_list|,
argument|&evdev->ev_clients
argument_list|,
argument|ec_link
argument_list|)
block|{
name|evdev_revoke_client
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|evdev_dispose_client
argument_list|(
name|evdev
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|EVDEV_CLIENT_LOCKQ
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|evdev_notify_event
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|EVDEV_CLIENT_UNLOCKQ
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
name|EVDEV_UNLOCK
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
comment|/* destroy_dev can sleep so release lock */
name|ret
operator|=
name|evdev_cdev_destroy
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
name|evdev
operator|->
name|ev_cdev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|evdev
operator|->
name|ev_lock_type
operator|==
name|EV_LOCK_INTERNAL
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|evdev
operator|->
name|ev_mtx
argument_list|)
expr_stmt|;
name|evdev_free_absinfo
argument_list|(
name|evdev
operator|->
name|ev_absinfo
argument_list|)
expr_stmt|;
name|evdev_mt_free
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|inline
name|void
name|evdev_set_name
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|snprintf
argument_list|(
name|evdev
operator|->
name|ev_name
argument_list|,
name|NAMELEN
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|evdev_set_id
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|bustype
parameter_list|,
name|uint16_t
name|vendor
parameter_list|,
name|uint16_t
name|product
parameter_list|,
name|uint16_t
name|version
parameter_list|)
block|{
name|evdev
operator|->
name|ev_id
operator|=
operator|(
expr|struct
name|input_id
operator|)
block|{
operator|.
name|bustype
operator|=
name|bustype
block|,
operator|.
name|vendor
operator|=
name|vendor
block|,
operator|.
name|product
operator|=
name|product
block|,
operator|.
name|version
operator|=
name|version
block|}
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|evdev_set_phys
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|snprintf
argument_list|(
name|evdev
operator|->
name|ev_shortname
argument_list|,
name|NAMELEN
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|evdev_set_serial
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
specifier|const
name|char
modifier|*
name|serial
parameter_list|)
block|{
name|snprintf
argument_list|(
name|evdev
operator|->
name|ev_serial
argument_list|,
name|NAMELEN
argument_list|,
literal|"%s"
argument_list|,
name|serial
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|evdev_set_methods
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|void
modifier|*
name|softc
parameter_list|,
specifier|const
name|struct
name|evdev_methods
modifier|*
name|methods
parameter_list|)
block|{
name|evdev
operator|->
name|ev_methods
operator|=
name|methods
expr_stmt|;
name|evdev
operator|->
name|ev_softc
operator|=
name|softc
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|evdev_support_prop
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|prop
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|prop
operator|<
name|INPUT_PROP_CNT
argument_list|,
operator|(
literal|"invalid evdev input property"
operator|)
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|evdev
operator|->
name|ev_prop_flags
argument_list|,
name|prop
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|evdev_support_event
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|type
operator|<
name|EV_CNT
argument_list|,
operator|(
literal|"invalid evdev event property"
operator|)
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|evdev
operator|->
name|ev_type_flags
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|evdev_support_key
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|code
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|code
operator|<
name|KEY_CNT
argument_list|,
operator|(
literal|"invalid evdev key property"
operator|)
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|evdev
operator|->
name|ev_key_flags
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|evdev_support_rel
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|code
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|code
operator|<
name|REL_CNT
argument_list|,
operator|(
literal|"invalid evdev rel property"
operator|)
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|evdev
operator|->
name|ev_rel_flags
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|evdev_support_abs
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|code
parameter_list|,
name|int32_t
name|value
parameter_list|,
name|int32_t
name|minimum
parameter_list|,
name|int32_t
name|maximum
parameter_list|,
name|int32_t
name|fuzz
parameter_list|,
name|int32_t
name|flat
parameter_list|,
name|int32_t
name|resolution
parameter_list|)
block|{
name|struct
name|input_absinfo
name|absinfo
decl_stmt|;
name|KASSERT
argument_list|(
name|code
operator|<
name|ABS_CNT
argument_list|,
operator|(
literal|"invalid evdev abs property"
operator|)
argument_list|)
expr_stmt|;
name|absinfo
operator|=
operator|(
expr|struct
name|input_absinfo
operator|)
block|{
operator|.
name|value
operator|=
name|value
block|,
operator|.
name|minimum
operator|=
name|minimum
block|,
operator|.
name|maximum
operator|=
name|maximum
block|,
operator|.
name|fuzz
operator|=
name|fuzz
block|,
operator|.
name|flat
operator|=
name|flat
block|,
operator|.
name|resolution
operator|=
name|resolution
block|, 	}
expr_stmt|;
name|evdev_set_abs_bit
argument_list|(
name|evdev
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|evdev_set_absinfo
argument_list|(
name|evdev
argument_list|,
name|code
argument_list|,
operator|&
name|absinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|evdev_set_abs_bit
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|code
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|code
operator|<
name|ABS_CNT
argument_list|,
operator|(
literal|"invalid evdev abs property"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|evdev
operator|->
name|ev_absinfo
operator|==
name|NULL
condition|)
name|evdev
operator|->
name|ev_absinfo
operator|=
name|evdev_alloc_absinfo
argument_list|()
expr_stmt|;
name|bit_set
argument_list|(
name|evdev
operator|->
name|ev_abs_flags
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|evdev_support_msc
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|code
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|code
operator|<
name|MSC_CNT
argument_list|,
operator|(
literal|"invalid evdev msc property"
operator|)
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|evdev
operator|->
name|ev_msc_flags
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|evdev_support_led
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|code
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|code
operator|<
name|LED_CNT
argument_list|,
operator|(
literal|"invalid evdev led property"
operator|)
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|evdev
operator|->
name|ev_led_flags
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|evdev_support_snd
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|code
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|code
operator|<
name|SND_CNT
argument_list|,
operator|(
literal|"invalid evdev snd property"
operator|)
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|evdev
operator|->
name|ev_snd_flags
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|evdev_support_sw
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|code
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|code
operator|<
name|SW_CNT
argument_list|,
operator|(
literal|"invalid evdev sw property"
operator|)
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|evdev
operator|->
name|ev_sw_flags
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|evdev_event_supported
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|type
operator|<
name|EV_CNT
argument_list|,
operator|(
literal|"invalid evdev event property"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_type_flags
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|inline
name|void
name|evdev_set_absinfo
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|axis
parameter_list|,
name|struct
name|input_absinfo
modifier|*
name|absinfo
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|axis
operator|<
name|ABS_CNT
argument_list|,
operator|(
literal|"invalid evdev abs property"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|axis
operator|==
name|ABS_MT_SLOT
operator|&&
operator|(
name|absinfo
operator|->
name|maximum
operator|<
literal|1
operator|||
name|absinfo
operator|->
name|maximum
operator|>=
name|MAX_MT_SLOTS
operator|)
condition|)
return|return;
if|if
condition|(
name|evdev
operator|->
name|ev_absinfo
operator|==
name|NULL
condition|)
name|evdev
operator|->
name|ev_absinfo
operator|=
name|evdev_alloc_absinfo
argument_list|()
expr_stmt|;
if|if
condition|(
name|axis
operator|==
name|ABS_MT_SLOT
condition|)
name|evdev
operator|->
name|ev_absinfo
index|[
name|ABS_MT_SLOT
index|]
operator|.
name|maximum
operator|=
name|absinfo
operator|->
name|maximum
expr_stmt|;
else|else
name|memcpy
argument_list|(
operator|&
name|evdev
operator|->
name|ev_absinfo
index|[
name|axis
index|]
argument_list|,
name|absinfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|input_absinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|evdev_set_repeat_params
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|property
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|property
operator|<
name|REP_CNT
argument_list|,
operator|(
literal|"invalid evdev repeat property"
operator|)
argument_list|)
expr_stmt|;
name|evdev
operator|->
name|ev_rep
index|[
name|property
index|]
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|evdev_set_flag
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|flag
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|flag
operator|<
name|EVDEV_FLAG_CNT
argument_list|,
operator|(
literal|"invalid evdev flag property"
operator|)
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|evdev
operator|->
name|ev_flags
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|evdev_check_event
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|code
parameter_list|,
name|int32_t
name|value
parameter_list|)
block|{
if|if
condition|(
name|type
operator|>=
name|EV_CNT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Allow SYN events implicitly */
if|if
condition|(
name|type
operator|!=
name|EV_SYN
operator|&&
operator|!
name|evdev_event_supported
argument_list|(
name|evdev
argument_list|,
name|type
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EV_SYN
case|:
if|if
condition|(
name|code
operator|>=
name|SYN_CNT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|EV_KEY
case|:
if|if
condition|(
name|code
operator|>=
name|KEY_CNT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_key_flags
argument_list|,
name|code
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|EV_REL
case|:
if|if
condition|(
name|code
operator|>=
name|REL_CNT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_rel_flags
argument_list|,
name|code
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|EV_ABS
case|:
if|if
condition|(
name|code
operator|>=
name|ABS_CNT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_abs_flags
argument_list|,
name|code
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|code
operator|==
name|ABS_MT_SLOT
operator|&&
operator|(
name|value
operator|<
literal|0
operator|||
name|value
operator|>
name|MAXIMAL_MT_SLOT
argument_list|(
name|evdev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ABS_IS_MT
argument_list|(
name|code
argument_list|)
operator|&&
name|evdev
operator|->
name|ev_mt
operator|==
name|NULL
operator|&&
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_abs_flags
argument_list|,
name|ABS_MT_SLOT
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|EV_MSC
case|:
if|if
condition|(
name|code
operator|>=
name|MSC_CNT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_msc_flags
argument_list|,
name|code
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|EV_LED
case|:
if|if
condition|(
name|code
operator|>=
name|LED_CNT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_led_flags
argument_list|,
name|code
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|EV_SND
case|:
if|if
condition|(
name|code
operator|>=
name|SND_CNT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_snd_flags
argument_list|,
name|code
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|EV_SW
case|:
if|if
condition|(
name|code
operator|>=
name|SW_CNT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_sw_flags
argument_list|,
name|code
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|EV_REP
case|:
if|if
condition|(
name|code
operator|>=
name|REP_CNT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|evdev_modify_event
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|code
parameter_list|,
name|int32_t
modifier|*
name|value
parameter_list|)
block|{
name|EVDEV_LOCK_ASSERT
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EV_KEY
case|:
if|if
condition|(
operator|!
name|evdev_event_supported
argument_list|(
name|evdev
argument_list|,
name|EV_REP
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_flags
argument_list|,
name|EVDEV_FLAG_SOFTREPEAT
argument_list|)
condition|)
block|{
comment|/* Detect driver key repeats. */
if|if
condition|(
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_key_states
argument_list|,
name|code
argument_list|)
operator|&&
operator|*
name|value
operator|==
name|KEY_EVENT_DOWN
condition|)
operator|*
name|value
operator|=
name|KEY_EVENT_REPEAT
expr_stmt|;
block|}
else|else
block|{
comment|/* Start/stop callout for evdev repeats */
if|if
condition|(
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_key_states
argument_list|,
name|code
argument_list|)
operator|==
operator|!
operator|*
name|value
operator|&&
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|evdev
operator|->
name|ev_clients
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|value
operator|==
name|KEY_EVENT_DOWN
condition|)
name|evdev_start_repeat
argument_list|(
name|evdev
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
name|evdev_stop_repeat
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EV_ABS
case|:
comment|/* TBD: implement fuzz */
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|evdev_sparse_result
name|evdev_sparse_event
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|code
parameter_list|,
name|int32_t
name|value
parameter_list|)
block|{
name|int32_t
name|last_mt_slot
decl_stmt|;
name|EVDEV_LOCK_ASSERT
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
comment|/* 	 * For certain event types, update device state bits 	 * and convert level reporting to edge reporting 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EV_KEY
case|:
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|KEY_EVENT_UP
case|:
case|case
name|KEY_EVENT_DOWN
case|:
if|if
condition|(
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_key_states
argument_list|,
name|code
argument_list|)
operator|==
name|value
condition|)
return|return
operator|(
name|EV_SKIP_EVENT
operator|)
return|;
name|bit_change
argument_list|(
name|evdev
operator|->
name|ev_key_states
argument_list|,
name|code
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_EVENT_REPEAT
case|:
if|if
condition|(
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_key_states
argument_list|,
name|code
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|evdev_event_supported
argument_list|(
name|evdev
argument_list|,
name|EV_REP
argument_list|)
condition|)
return|return
operator|(
name|EV_SKIP_EVENT
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|EV_SKIP_EVENT
operator|)
return|;
block|}
break|break;
case|case
name|EV_LED
case|:
if|if
condition|(
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_led_states
argument_list|,
name|code
argument_list|)
operator|==
name|value
condition|)
return|return
operator|(
name|EV_SKIP_EVENT
operator|)
return|;
name|bit_change
argument_list|(
name|evdev
operator|->
name|ev_led_states
argument_list|,
name|code
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_SND
case|:
name|bit_change
argument_list|(
name|evdev
operator|->
name|ev_snd_states
argument_list|,
name|code
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_SW
case|:
if|if
condition|(
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_sw_states
argument_list|,
name|code
argument_list|)
operator|==
name|value
condition|)
return|return
operator|(
name|EV_SKIP_EVENT
operator|)
return|;
name|bit_change
argument_list|(
name|evdev
operator|->
name|ev_sw_states
argument_list|,
name|code
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_REP
case|:
if|if
condition|(
name|evdev
operator|->
name|ev_rep
index|[
name|code
index|]
operator|==
name|value
condition|)
return|return
operator|(
name|EV_SKIP_EVENT
operator|)
return|;
name|evdev_set_repeat_params
argument_list|(
name|evdev
argument_list|,
name|code
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_REL
case|:
if|if
condition|(
name|value
operator|==
literal|0
condition|)
return|return
operator|(
name|EV_SKIP_EVENT
operator|)
return|;
break|break;
comment|/* For EV_ABS, save last value in absinfo and ev_mt_states */
case|case
name|EV_ABS
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ABS_MT_SLOT
case|:
comment|/* Postpone ABS_MT_SLOT till next event */
name|evdev_set_last_mt_slot
argument_list|(
name|evdev
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|EV_SKIP_EVENT
operator|)
return|;
case|case
name|ABS_MT_FIRST
operator|...
name|ABS_MT_LAST
case|:
comment|/* Pass MT protocol type A events as is */
if|if
condition|(
operator|!
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_abs_flags
argument_list|,
name|ABS_MT_SLOT
argument_list|)
condition|)
break|break;
comment|/* Don`t repeat MT protocol type B events */
name|last_mt_slot
operator|=
name|evdev_get_last_mt_slot
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|evdev_get_mt_value
argument_list|(
name|evdev
argument_list|,
name|last_mt_slot
argument_list|,
name|code
argument_list|)
operator|==
name|value
condition|)
return|return
operator|(
name|EV_SKIP_EVENT
operator|)
return|;
name|evdev_set_mt_value
argument_list|(
name|evdev
argument_list|,
name|last_mt_slot
argument_list|,
name|code
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_mt_slot
operator|!=
name|CURRENT_MT_SLOT
argument_list|(
name|evdev
argument_list|)
condition|)
block|{
name|CURRENT_MT_SLOT
argument_list|(
name|evdev
argument_list|)
operator|=
name|last_mt_slot
expr_stmt|;
name|evdev
operator|->
name|ev_report_opened
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|EV_REPORT_MT_SLOT
operator|)
return|;
block|}
break|break;
default|default:
if|if
condition|(
name|evdev
operator|->
name|ev_absinfo
index|[
name|code
index|]
operator|.
name|value
operator|==
name|value
condition|)
return|return
operator|(
name|EV_SKIP_EVENT
operator|)
return|;
name|evdev
operator|->
name|ev_absinfo
index|[
name|code
index|]
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
break|break;
case|case
name|EV_SYN
case|:
if|if
condition|(
name|code
operator|==
name|SYN_REPORT
condition|)
block|{
comment|/* Count empty reports as well as non empty */
name|evdev
operator|->
name|ev_report_count
operator|++
expr_stmt|;
comment|/* Skip empty reports */
if|if
condition|(
operator|!
name|evdev
operator|->
name|ev_report_opened
condition|)
return|return
operator|(
name|EV_SKIP_EVENT
operator|)
return|;
name|evdev
operator|->
name|ev_report_opened
operator|=
name|false
expr_stmt|;
return|return
operator|(
name|EV_REPORT_EVENT
operator|)
return|;
block|}
break|break;
block|}
name|evdev
operator|->
name|ev_report_opened
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|EV_REPORT_EVENT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|evdev_propagate_event
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|code
parameter_list|,
name|int32_t
name|value
parameter_list|)
block|{
name|struct
name|evdev_client
modifier|*
name|client
decl_stmt|;
name|debugf
argument_list|(
name|evdev
argument_list|,
literal|"%s pushed event %d/%d/%d"
argument_list|,
name|evdev
operator|->
name|ev_shortname
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|EVDEV_LOCK_ASSERT
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
comment|/* Propagate event through all clients */
name|LIST_FOREACH
argument_list|(
argument|client
argument_list|,
argument|&evdev->ev_clients
argument_list|,
argument|ec_link
argument_list|)
block|{
if|if
condition|(
name|evdev
operator|->
name|ev_grabber
operator|!=
name|NULL
operator|&&
name|evdev
operator|->
name|ev_grabber
operator|!=
name|client
condition|)
continue|continue;
name|EVDEV_CLIENT_LOCKQ
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|evdev_client_push
argument_list|(
name|client
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|EV_SYN
operator|&&
name|code
operator|==
name|SYN_REPORT
condition|)
name|evdev_notify_event
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|EVDEV_CLIENT_UNLOCKQ
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
name|evdev
operator|->
name|ev_event_count
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evdev_send_event
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|code
parameter_list|,
name|int32_t
name|value
parameter_list|)
block|{
name|enum
name|evdev_sparse_result
name|sparse
decl_stmt|;
name|EVDEV_LOCK_ASSERT
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
name|sparse
operator|=
name|evdev_sparse_event
argument_list|(
name|evdev
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|value
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sparse
condition|)
block|{
case|case
name|EV_REPORT_MT_SLOT
case|:
comment|/* report postponed ABS_MT_SLOT */
name|evdev_propagate_event
argument_list|(
name|evdev
argument_list|,
name|EV_ABS
argument_list|,
name|ABS_MT_SLOT
argument_list|,
name|CURRENT_MT_SLOT
argument_list|(
name|evdev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|EV_REPORT_EVENT
case|:
name|evdev_propagate_event
argument_list|(
name|evdev
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|EV_SKIP_EVENT
case|:
break|break;
block|}
block|}
end_function

begin_function
name|int
name|evdev_push_event
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|code
parameter_list|,
name|int32_t
name|value
parameter_list|)
block|{
if|if
condition|(
name|evdev_check_event
argument_list|(
name|evdev
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|value
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|EVDEV_ENTER
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
name|evdev_modify_event
argument_list|(
name|evdev
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|EV_SYN
operator|&&
name|code
operator|==
name|SYN_REPORT
operator|&&
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_flags
argument_list|,
name|EVDEV_FLAG_MT_AUTOREL
argument_list|)
condition|)
name|evdev_send_mt_autorel
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|EV_SYN
operator|&&
name|code
operator|==
name|SYN_REPORT
operator|&&
name|evdev
operator|->
name|ev_report_opened
operator|&&
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_flags
argument_list|,
name|EVDEV_FLAG_MT_STCOMPAT
argument_list|)
condition|)
name|evdev_send_mt_compat
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
name|evdev_send_event
argument_list|(
name|evdev
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|EVDEV_EXIT
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evdev_inject_event
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|code
parameter_list|,
name|int32_t
name|value
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EV_REP
case|:
comment|/* evdev repeats should not be processed by hardware driver */
if|if
condition|(
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_flags
argument_list|,
name|EVDEV_FLAG_SOFTREPEAT
argument_list|)
condition|)
goto|goto
name|push
goto|;
comment|/* FALLTHROUGH */
case|case
name|EV_LED
case|:
case|case
name|EV_MSC
case|:
case|case
name|EV_SND
case|:
case|case
name|EV_FF
case|:
if|if
condition|(
name|evdev
operator|->
name|ev_methods
operator|!=
name|NULL
operator|&&
name|evdev
operator|->
name|ev_methods
operator|->
name|ev_event
operator|!=
name|NULL
condition|)
name|evdev
operator|->
name|ev_methods
operator|->
name|ev_event
argument_list|(
name|evdev
argument_list|,
name|evdev
operator|->
name|ev_softc
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* 		 * Leds and driver repeats should be reported in ev_event 		 * method body to interoperate with kbdmux states and rates 		 * propagation so both ways (ioctl and evdev) of changing it 		 * will produce only one evdev event report to client. 		 */
if|if
condition|(
name|type
operator|==
name|EV_LED
operator|||
name|type
operator|==
name|EV_REP
condition|)
break|break;
comment|/* FALLTHROUGH */
case|case
name|EV_SYN
case|:
case|case
name|EV_KEY
case|:
case|case
name|EV_REL
case|:
case|case
name|EV_ABS
case|:
case|case
name|EV_SW
case|:
name|push
label|:
if|if
condition|(
name|evdev
operator|->
name|ev_lock_type
operator|!=
name|EV_LOCK_INTERNAL
condition|)
name|EVDEV_LOCK
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|evdev_push_event
argument_list|(
name|evdev
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|evdev
operator|->
name|ev_lock_type
operator|!=
name|EV_LOCK_INTERNAL
condition|)
name|EVDEV_UNLOCK
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evdev_register_client
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|struct
name|evdev_client
modifier|*
name|client
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|debugf
argument_list|(
name|evdev
argument_list|,
literal|"adding new client for device %s"
argument_list|,
name|evdev
operator|->
name|ev_shortname
argument_list|)
expr_stmt|;
name|EVDEV_LOCK_ASSERT
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|evdev
operator|->
name|ev_clients
argument_list|)
operator|&&
name|evdev
operator|->
name|ev_methods
operator|!=
name|NULL
operator|&&
name|evdev
operator|->
name|ev_methods
operator|->
name|ev_open
operator|!=
name|NULL
condition|)
block|{
name|debugf
argument_list|(
name|evdev
argument_list|,
literal|"calling ev_open() on device %s"
argument_list|,
name|evdev
operator|->
name|ev_shortname
argument_list|)
expr_stmt|;
name|ret
operator|=
name|evdev
operator|->
name|ev_methods
operator|->
name|ev_open
argument_list|(
name|evdev
argument_list|,
name|evdev
operator|->
name|ev_softc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|evdev
operator|->
name|ev_clients
argument_list|,
name|client
argument_list|,
name|ec_link
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|evdev_dispose_client
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|struct
name|evdev_client
modifier|*
name|client
parameter_list|)
block|{
name|debugf
argument_list|(
name|evdev
argument_list|,
literal|"removing client for device %s"
argument_list|,
name|evdev
operator|->
name|ev_shortname
argument_list|)
expr_stmt|;
name|EVDEV_LOCK_ASSERT
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|client
argument_list|,
name|ec_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|evdev
operator|->
name|ev_clients
argument_list|)
condition|)
block|{
if|if
condition|(
name|evdev
operator|->
name|ev_methods
operator|!=
name|NULL
operator|&&
name|evdev
operator|->
name|ev_methods
operator|->
name|ev_close
operator|!=
name|NULL
condition|)
name|evdev
operator|->
name|ev_methods
operator|->
name|ev_close
argument_list|(
name|evdev
argument_list|,
name|evdev
operator|->
name|ev_softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|evdev_event_supported
argument_list|(
name|evdev
argument_list|,
name|EV_REP
argument_list|)
operator|&&
name|bit_test
argument_list|(
name|evdev
operator|->
name|ev_flags
argument_list|,
name|EVDEV_FLAG_SOFTREPEAT
argument_list|)
condition|)
name|evdev_stop_repeat
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
block|}
name|evdev_release_client
argument_list|(
name|evdev
argument_list|,
name|client
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|evdev_grab_client
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|struct
name|evdev_client
modifier|*
name|client
parameter_list|)
block|{
name|EVDEV_LOCK_ASSERT
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|evdev
operator|->
name|ev_grabber
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|evdev
operator|->
name|ev_grabber
operator|=
name|client
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evdev_release_client
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|struct
name|evdev_client
modifier|*
name|client
parameter_list|)
block|{
name|EVDEV_LOCK_ASSERT
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|evdev
operator|->
name|ev_grabber
operator|!=
name|client
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|evdev
operator|->
name|ev_grabber
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|evdev_repeat_callout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|evdev_dev
modifier|*
name|evdev
init|=
operator|(
expr|struct
name|evdev_dev
operator|*
operator|)
name|arg
decl_stmt|;
name|evdev_send_event
argument_list|(
name|evdev
argument_list|,
name|EV_KEY
argument_list|,
name|evdev
operator|->
name|ev_rep_key
argument_list|,
name|KEY_EVENT_REPEAT
argument_list|)
expr_stmt|;
name|evdev_send_event
argument_list|(
name|evdev
argument_list|,
name|EV_SYN
argument_list|,
name|SYN_REPORT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|evdev
operator|->
name|ev_rep
index|[
name|REP_PERIOD
index|]
condition|)
name|callout_reset
argument_list|(
operator|&
name|evdev
operator|->
name|ev_rep_callout
argument_list|,
name|evdev
operator|->
name|ev_rep
index|[
name|REP_PERIOD
index|]
operator|*
name|hz
operator|/
literal|1000
argument_list|,
name|evdev_repeat_callout
argument_list|,
name|evdev
argument_list|)
expr_stmt|;
else|else
name|evdev
operator|->
name|ev_rep_key
operator|=
name|KEY_RESERVED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evdev_start_repeat
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|,
name|uint16_t
name|key
parameter_list|)
block|{
name|EVDEV_LOCK_ASSERT
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|evdev
operator|->
name|ev_rep
index|[
name|REP_DELAY
index|]
condition|)
block|{
name|evdev
operator|->
name|ev_rep_key
operator|=
name|key
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|evdev
operator|->
name|ev_rep_callout
argument_list|,
name|evdev
operator|->
name|ev_rep
index|[
name|REP_DELAY
index|]
operator|*
name|hz
operator|/
literal|1000
argument_list|,
name|evdev_repeat_callout
argument_list|,
name|evdev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|evdev_stop_repeat
parameter_list|(
name|struct
name|evdev_dev
modifier|*
name|evdev
parameter_list|)
block|{
name|EVDEV_LOCK_ASSERT
argument_list|(
name|evdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|evdev
operator|->
name|ev_rep_key
operator|!=
name|KEY_RESERVED
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|evdev
operator|->
name|ev_rep_callout
argument_list|)
expr_stmt|;
name|evdev
operator|->
name|ev_rep_key
operator|=
name|KEY_RESERVED
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|evdev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

