begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Oleksandr Tymoshenko<gonzo@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_acpi.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/spibus/spi.h>
end_include

begin_include
include|#
directive|include
file|<dev/spibus/spibusvar.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/accommon.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpivar.h>
end_include

begin_include
include|#
directive|include
file|"spibus_if.h"
end_include

begin_comment
comment|/**  *	Macros for driver mutex locking  */
end_comment

begin_define
define|#
directive|define
name|INTELSPI_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&(_sc)->sc_mtx)
end_define

begin_define
define|#
directive|define
name|INTELSPI_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&(_sc)->sc_mtx)
end_define

begin_define
define|#
directive|define
name|INTELSPI_LOCK_INIT
parameter_list|(
name|_sc
parameter_list|)
define|\
value|mtx_init(&_sc->sc_mtx, device_get_nameunit((_sc)->sc_dev), \ 	    "intelspi", MTX_DEF)
end_define

begin_define
define|#
directive|define
name|INTELSPI_LOCK_DESTROY
parameter_list|(
name|_sc
parameter_list|)
value|mtx_destroy(&(_sc)->sc_mtx)
end_define

begin_define
define|#
directive|define
name|INTELSPI_ASSERT_LOCKED
parameter_list|(
name|_sc
parameter_list|)
value|mtx_assert(&(_sc)->sc_mtx, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|INTELSPI_ASSERT_UNLOCKED
parameter_list|(
name|_sc
parameter_list|)
value|mtx_assert(&(_sc)->sc_mtx, MA_NOTOWNED)
end_define

begin_define
define|#
directive|define
name|INTELSPI_WRITE
parameter_list|(
name|_sc
parameter_list|,
name|_off
parameter_list|,
name|_val
parameter_list|)
define|\
value|bus_write_4((_sc)->sc_mem_res, (_off), (_val))
end_define

begin_define
define|#
directive|define
name|INTELSPI_READ
parameter_list|(
name|_sc
parameter_list|,
name|_off
parameter_list|)
define|\
value|bus_read_4((_sc)->sc_mem_res, (_off))
end_define

begin_define
define|#
directive|define
name|INTELSPI_BUSY
value|0x1
end_define

begin_define
define|#
directive|define
name|TX_FIFO_THRESHOLD
value|2
end_define

begin_define
define|#
directive|define
name|RX_FIFO_THRESHOLD
value|2
end_define

begin_define
define|#
directive|define
name|CLOCK_DIV_10MHZ
value|5
end_define

begin_define
define|#
directive|define
name|DATA_SIZE_8BITS
value|8
end_define

begin_define
define|#
directive|define
name|CS_LOW
value|0
end_define

begin_define
define|#
directive|define
name|CS_HIGH
value|1
end_define

begin_define
define|#
directive|define
name|INTELSPI_SSPREG_SSCR0
value|0x0
end_define

begin_define
define|#
directive|define
name|SSCR0_SCR
parameter_list|(
name|n
parameter_list|)
value|(((n) - 1)<< 8)
end_define

begin_define
define|#
directive|define
name|SSCR0_SSE
value|(1<< 7)
end_define

begin_define
define|#
directive|define
name|SSCR0_FRF_SPI
value|(0<< 4)
end_define

begin_define
define|#
directive|define
name|SSCR0_DSS
parameter_list|(
name|n
parameter_list|)
value|(((n) - 1)<< 0)
end_define

begin_define
define|#
directive|define
name|INTELSPI_SSPREG_SSCR1
value|0x4
end_define

begin_define
define|#
directive|define
name|SSCR1_TINTE
value|(1<< 19)
end_define

begin_define
define|#
directive|define
name|SSCR1_RFT
parameter_list|(
name|n
parameter_list|)
value|(((n) - 1)<< 10)
end_define

begin_define
define|#
directive|define
name|SSCR1_RFT_MASK
value|(0xf<< 10)
end_define

begin_define
define|#
directive|define
name|SSCR1_TFT
parameter_list|(
name|n
parameter_list|)
value|(((n) - 1)<< 6)
end_define

begin_define
define|#
directive|define
name|SSCR1_SPI_SPH
value|(1<< 4)
end_define

begin_define
define|#
directive|define
name|SSCR1_SPI_SPO
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|SSCR1_MODE_MASK
value|(SSCR1_SPI_SPO | SSCR1_SPI_SPH)
end_define

begin_define
define|#
directive|define
name|SSCR1_MODE_0
value|(0)
end_define

begin_define
define|#
directive|define
name|SSCR1_MODE_1
value|(SSCR1_SPI_SPH)
end_define

begin_define
define|#
directive|define
name|SSCR1_MODE_2
value|(SSCR1_SPI_SPO)
end_define

begin_define
define|#
directive|define
name|SSCR1_MODE_3
value|(SSCR1_SPI_SPO | SSCR1_SPI_SPH)
end_define

begin_define
define|#
directive|define
name|SSCR1_TIE
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|SSCR1_RIE
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|INTELSPI_SSPREG_SSSR
value|0x8
end_define

begin_define
define|#
directive|define
name|SSSR_RFL_MASK
value|(0xf<< 12)
end_define

begin_define
define|#
directive|define
name|SSSR_TFL_MASK
value|(0xf<< 8)
end_define

begin_define
define|#
directive|define
name|SSSR_RNE
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|SSSR_TNF
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|INTELSPI_SSPREG_SSITR
value|0xC
end_define

begin_define
define|#
directive|define
name|INTELSPI_SSPREG_SSDR
value|0x10
end_define

begin_define
define|#
directive|define
name|INTELSPI_SSPREG_SSTO
value|0x28
end_define

begin_define
define|#
directive|define
name|INTELSPI_SSPREG_SSPSP
value|0x2C
end_define

begin_define
define|#
directive|define
name|INTELSPI_SSPREG_SSTSA
value|0x30
end_define

begin_define
define|#
directive|define
name|INTELSPI_SSPREG_SSRSA
value|0x34
end_define

begin_define
define|#
directive|define
name|INTELSPI_SSPREG_SSTSS
value|0x38
end_define

begin_define
define|#
directive|define
name|INTELSPI_SSPREG_SSACD
value|0x3C
end_define

begin_define
define|#
directive|define
name|INTELSPI_SSPREG_ITF
value|0x40
end_define

begin_define
define|#
directive|define
name|INTELSPI_SSPREG_SITF
value|0x44
end_define

begin_define
define|#
directive|define
name|INTELSPI_SSPREG_SIRF
value|0x48
end_define

begin_define
define|#
directive|define
name|INTELSPI_SSPREG_PRV_CLOCK_PARAMS
value|0x400
end_define

begin_define
define|#
directive|define
name|INTELSPI_SSPREG_RESETS
value|0x404
end_define

begin_define
define|#
directive|define
name|INTELSPI_SSPREG_GENERAL
value|0x408
end_define

begin_define
define|#
directive|define
name|INTELSPI_SSPREG_SSP_REG
value|0x40C
end_define

begin_define
define|#
directive|define
name|INTELSPI_SSPREG_SPI_CS_CTRL
value|0x418
end_define

begin_define
define|#
directive|define
name|SPI_CS_CTRL_CS_MASK
value|(3)
end_define

begin_define
define|#
directive|define
name|SPI_CS_CTRL_SW_MODE
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|SPI_CS_CTRL_HW_MODE
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|SPI_CS_CTRL_CS_HIGH
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|SPI_CS_CTRL_CS_LOW
value|(0<< 1)
end_define

begin_struct
struct|struct
name|intelspi_softc
block|{
name|ACPI_HANDLE
name|sc_handle
decl_stmt|;
name|device_t
name|sc_dev
decl_stmt|;
name|struct
name|mtx
name|sc_mtx
decl_stmt|;
name|int
name|sc_mem_rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|sc_mem_res
decl_stmt|;
name|int
name|sc_irq_rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|sc_irq_res
decl_stmt|;
name|void
modifier|*
name|sc_irq_ih
decl_stmt|;
name|struct
name|spi_command
modifier|*
name|sc_cmd
decl_stmt|;
name|uint32_t
name|sc_len
decl_stmt|;
name|uint32_t
name|sc_read
decl_stmt|;
name|uint32_t
name|sc_flags
decl_stmt|;
name|uint32_t
name|sc_written
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|intelspi_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|intelspi_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|intelspi_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intelspi_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|intelspi_txfifo_full
parameter_list|(
name|struct
name|intelspi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|sssr
decl_stmt|;
name|INTELSPI_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sssr
operator|=
name|INTELSPI_READ
argument_list|(
name|sc
argument_list|,
name|INTELSPI_SSPREG_SSSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|sssr
operator|&
name|SSSR_TNF
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intelspi_rxfifo_empty
parameter_list|(
name|struct
name|intelspi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|sssr
decl_stmt|;
name|INTELSPI_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sssr
operator|=
name|INTELSPI_READ
argument_list|(
name|sc
argument_list|,
name|INTELSPI_SSPREG_SSSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|sssr
operator|&
name|SSSR_RNE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intelspi_fill_tx_fifo
parameter_list|(
name|struct
name|intelspi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|spi_command
modifier|*
name|cmd
decl_stmt|;
name|uint32_t
name|written
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|INTELSPI_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|sc
operator|->
name|sc_cmd
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_written
operator|<
name|sc
operator|->
name|sc_len
operator|&&
operator|!
name|intelspi_txfifo_full
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|cmd
operator|->
name|tx_cmd
expr_stmt|;
name|written
operator|=
name|sc
operator|->
name|sc_written
operator|++
expr_stmt|;
if|if
condition|(
name|written
operator|>=
name|cmd
operator|->
name|tx_cmd_sz
condition|)
block|{
name|data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|cmd
operator|->
name|tx_data
expr_stmt|;
name|written
operator|-=
name|cmd
operator|->
name|tx_cmd_sz
expr_stmt|;
block|}
name|INTELSPI_WRITE
argument_list|(
name|sc
argument_list|,
name|INTELSPI_SSPREG_SSDR
argument_list|,
name|data
index|[
name|written
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|intelspi_drain_rx_fifo
parameter_list|(
name|struct
name|intelspi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|spi_command
modifier|*
name|cmd
decl_stmt|;
name|uint32_t
name|read
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|INTELSPI_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|sc
operator|->
name|sc_cmd
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_read
operator|<
name|sc
operator|->
name|sc_len
operator|&&
operator|!
name|intelspi_rxfifo_empty
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|cmd
operator|->
name|rx_cmd
expr_stmt|;
name|read
operator|=
name|sc
operator|->
name|sc_read
operator|++
expr_stmt|;
if|if
condition|(
name|read
operator|>=
name|cmd
operator|->
name|rx_cmd_sz
condition|)
block|{
name|data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|cmd
operator|->
name|rx_data
expr_stmt|;
name|read
operator|-=
name|cmd
operator|->
name|rx_cmd_sz
expr_stmt|;
block|}
name|data
index|[
name|read
index|]
operator|=
name|INTELSPI_READ
argument_list|(
name|sc
argument_list|,
name|INTELSPI_SSPREG_SSDR
argument_list|)
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|intelspi_transaction_done
parameter_list|(
name|struct
name|intelspi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|txfifo_empty
decl_stmt|;
name|uint32_t
name|sssr
decl_stmt|;
name|INTELSPI_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_written
operator|!=
name|sc
operator|->
name|sc_len
operator|||
name|sc
operator|->
name|sc_read
operator|!=
name|sc
operator|->
name|sc_len
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sssr
operator|=
name|INTELSPI_READ
argument_list|(
name|sc
argument_list|,
name|INTELSPI_SSPREG_SSSR
argument_list|)
expr_stmt|;
name|txfifo_empty
operator|=
operator|(
operator|(
name|sssr
operator|&
name|SSSR_TFL_MASK
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sssr
operator|&
name|SSSR_TNF
operator|)
expr_stmt|;
if|if
condition|(
name|txfifo_empty
operator|&&
operator|!
operator|(
name|sssr
operator|&
name|SSSR_RNE
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intelspi_transact
parameter_list|(
name|struct
name|intelspi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|INTELSPI_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* TX - Fill up the FIFO. */
name|intelspi_fill_tx_fifo
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* RX - Drain the FIFO. */
name|intelspi_drain_rx_fifo
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check for end of transfer. */
return|return
name|intelspi_transaction_done
argument_list|(
name|sc
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intelspi_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|intelspi_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|intelspi_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|INTELSPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|INTELSPI_BUSY
operator|)
operator|==
literal|0
condition|)
block|{
name|INTELSPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check if SSP if off */
name|reg
operator|=
name|INTELSPI_READ
argument_list|(
name|sc
argument_list|,
name|INTELSPI_SSPREG_SSSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0xffffffffU
condition|)
block|{
name|INTELSPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for end of transfer. */
if|if
condition|(
name|intelspi_transact
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Disable interrupts */
name|reg
operator|=
name|INTELSPI_READ
argument_list|(
name|sc
argument_list|,
name|INTELSPI_SSPREG_SSCR1
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|SSCR1_TIE
operator||
name|SSCR1_RIE
operator||
name|SSCR1_TINTE
operator|)
expr_stmt|;
name|INTELSPI_WRITE
argument_list|(
name|sc
argument_list|,
name|INTELSPI_SSPREG_SSCR1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
block|}
name|INTELSPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intelspi_init
parameter_list|(
name|struct
name|intelspi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|INTELSPI_WRITE
argument_list|(
name|sc
argument_list|,
name|INTELSPI_SSPREG_SSCR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Manual CS control */
name|reg
operator|=
name|INTELSPI_READ
argument_list|(
name|sc
argument_list|,
name|INTELSPI_SSPREG_SPI_CS_CTRL
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|SPI_CS_CTRL_CS_MASK
operator|)
expr_stmt|;
name|reg
operator||=
operator|(
name|SPI_CS_CTRL_SW_MODE
operator||
name|SPI_CS_CTRL_CS_HIGH
operator|)
expr_stmt|;
name|INTELSPI_WRITE
argument_list|(
name|sc
argument_list|,
name|INTELSPI_SSPREG_SPI_CS_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Set TX/RX FIFO IRQ threshold levels */
name|reg
operator|=
name|SSCR1_TFT
argument_list|(
name|TX_FIFO_THRESHOLD
argument_list|)
operator||
name|SSCR1_RFT
argument_list|(
name|RX_FIFO_THRESHOLD
argument_list|)
expr_stmt|;
comment|/* 	 * Set SPI mode. This should be part of transaction or sysctl 	 */
name|reg
operator||=
name|SSCR1_MODE_0
expr_stmt|;
name|INTELSPI_WRITE
argument_list|(
name|sc
argument_list|,
name|INTELSPI_SSPREG_SSCR1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* 	 * Parent clock on Minowboard Turbot is 50MHz 	 * divide it by 5 to set to more or less reasonable 	 * value. But this should be part of transaction config 	 * or sysctl 	 */
name|reg
operator|=
name|SSCR0_SCR
argument_list|(
name|CLOCK_DIV_10MHZ
argument_list|)
expr_stmt|;
comment|/* Put SSP in SPI mode */
name|reg
operator||=
name|SSCR0_FRF_SPI
expr_stmt|;
comment|/* Data size */
name|reg
operator||=
name|SSCR0_DSS
argument_list|(
name|DATA_SIZE_8BITS
argument_list|)
expr_stmt|;
comment|/* Enable SSP */
name|reg
operator||=
name|SSCR0_SSE
expr_stmt|;
name|INTELSPI_WRITE
argument_list|(
name|sc
argument_list|,
name|INTELSPI_SSPREG_SSCR0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intelspi_set_cs
parameter_list|(
name|struct
name|intelspi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|reg
operator|=
name|INTELSPI_READ
argument_list|(
name|sc
argument_list|,
name|INTELSPI_SSPREG_SPI_CS_CTRL
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|SPI_CS_CTRL_CS_MASK
operator|)
expr_stmt|;
name|reg
operator||=
name|SPI_CS_CTRL_SW_MODE
expr_stmt|;
if|if
condition|(
name|level
operator|==
name|CS_HIGH
condition|)
name|reg
operator||=
name|SPI_CS_CTRL_CS_HIGH
expr_stmt|;
else|else
name|reg
operator||=
name|SPI_CS_CTRL_CS_LOW
expr_stmt|;
name|INTELSPI_WRITE
argument_list|(
name|sc
argument_list|,
name|INTELSPI_SSPREG_SPI_CS_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|intelspi_transfer
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|spi_command
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|intelspi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint32_t
name|sscr1
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
name|cmd
operator|->
name|tx_cmd_sz
operator|==
name|cmd
operator|->
name|rx_cmd_sz
argument_list|,
operator|(
literal|"TX/RX command sizes should be equal"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cmd
operator|->
name|tx_data_sz
operator|==
name|cmd
operator|->
name|rx_data_sz
argument_list|,
operator|(
literal|"TX/RX data sizes should be equal"
operator|)
argument_list|)
expr_stmt|;
name|INTELSPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If the controller is in use wait until it is available. */
while|while
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|INTELSPI_BUSY
condition|)
block|{
name|err
operator|=
name|mtx_sleep
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|,
literal|"intelspi"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EINTR
condition|)
block|{
name|INTELSPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
comment|/* Now we have control over SPI controller. */
name|sc
operator|->
name|sc_flags
operator|=
name|INTELSPI_BUSY
expr_stmt|;
comment|/* Save a pointer to the SPI command. */
name|sc
operator|->
name|sc_cmd
operator|=
name|cmd
expr_stmt|;
name|sc
operator|->
name|sc_read
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_written
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_len
operator|=
name|cmd
operator|->
name|tx_cmd_sz
operator|+
name|cmd
operator|->
name|tx_data_sz
expr_stmt|;
comment|/* Enable CS */
name|intelspi_set_cs
argument_list|(
name|sc
argument_list|,
name|CS_LOW
argument_list|)
expr_stmt|;
comment|/* Transfer as much as possible to FIFOs */
if|if
condition|(
operator|!
name|intelspi_transact
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* If FIFO is not large enough - enable interrupts */
name|sscr1
operator|=
name|INTELSPI_READ
argument_list|(
name|sc
argument_list|,
name|INTELSPI_SSPREG_SSCR1
argument_list|)
expr_stmt|;
name|sscr1
operator||=
operator|(
name|SSCR1_TIE
operator||
name|SSCR1_RIE
operator||
name|SSCR1_TINTE
operator|)
expr_stmt|;
name|INTELSPI_WRITE
argument_list|(
name|sc
argument_list|,
name|INTELSPI_SSPREG_SSCR1
argument_list|,
name|sscr1
argument_list|)
expr_stmt|;
comment|/* and wait for transaction to complete */
name|err
operator|=
name|mtx_sleep
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|,
literal|"intelspi"
argument_list|,
name|hz
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* de-asser CS */
name|intelspi_set_cs
argument_list|(
name|sc
argument_list|,
name|CS_HIGH
argument_list|)
expr_stmt|;
comment|/* Clear transaction details */
name|sc
operator|->
name|sc_cmd
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_read
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_written
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_len
operator|=
literal|0
expr_stmt|;
comment|/* Make sure the SPI engine and interrupts are disabled. */
name|sscr1
operator|=
name|INTELSPI_READ
argument_list|(
name|sc
argument_list|,
name|INTELSPI_SSPREG_SSCR1
argument_list|)
expr_stmt|;
name|sscr1
operator|&=
operator|~
operator|(
name|SSCR1_TIE
operator||
name|SSCR1_RIE
operator||
name|SSCR1_TINTE
operator|)
expr_stmt|;
name|INTELSPI_WRITE
argument_list|(
name|sc
argument_list|,
name|INTELSPI_SSPREG_SSCR1
argument_list|,
name|sscr1
argument_list|)
expr_stmt|;
comment|/* Release the controller and wakeup the next thread waiting for it. */
name|sc
operator|->
name|sc_flags
operator|=
literal|0
expr_stmt|;
name|wakeup_one
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|INTELSPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Check for transfer timeout.  The SPI controller doesn't 	 * return errors. 	 */
if|if
condition|(
name|err
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"transfer timeout\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EIO
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intelspi_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|gpio_ids
index|[]
init|=
block|{
literal|"80860F0E"
block|,
name|NULL
block|}
decl_stmt|;
if|if
condition|(
name|acpi_disabled
argument_list|(
literal|"spi"
argument_list|)
operator|||
name|ACPI_ID_PROBE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|gpio_ids
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Intel SPI Controller"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intelspi_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|intelspi_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_handle
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|INTELSPI_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mem_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_mem_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|sc_mem_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mem_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't allocate memory resource\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|sc
operator|->
name|sc_irq_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|sc_irq_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't allocate IRQ resource\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Hook up our interrupt handler. */
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq_res
argument_list|,
name|INTR_TYPE_MISC
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|intelspi_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_irq_ih
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot setup the interrupt handler\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|intelspi_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"spibus"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
name|error
label|:
name|INTELSPI_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mem_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|sc_mem_rid
argument_list|,
name|sc
operator|->
name|sc_mem_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|sc_irq_rid
argument_list|,
name|sc
operator|->
name|sc_irq_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intelspi_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|intelspi_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|INTELSPI_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq_ih
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq_res
argument_list|,
name|sc
operator|->
name|sc_irq_ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mem_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|sc_mem_rid
argument_list|,
name|sc
operator|->
name|sc_mem_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|sc_irq_rid
argument_list|,
name|sc
operator|->
name|sc_irq_res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|intelspi_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|intelspi_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|intelspi_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|intelspi_detach
argument_list|)
block|,
comment|/* SPI interface */
name|DEVMETHOD
argument_list|(
name|spibus_transfer
argument_list|,
name|intelspi_transfer
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|intelspi_driver
init|=
block|{
literal|"spi"
block|,
name|intelspi_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|intelspi_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|intelspi_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|intelspi
argument_list|,
name|acpi
argument_list|,
name|intelspi_driver
argument_list|,
name|intelspi_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|intelspi
argument_list|,
name|acpi
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|intelspi
argument_list|,
name|spibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

