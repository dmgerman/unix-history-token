begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Kazutaka YOKOTA<yokota@zodiac.mech.utsunomiya-u.ac.jp>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer as  *    the first lines of this file unmodified.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_kbd.h"
end_include

begin_include
include|#
directive|include
file|"opt_atkbd.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/vm86.h>
end_include

begin_include
include|#
directive|include
file|<machine/pc/bios.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __i386__ */
end_comment

begin_include
include|#
directive|include
file|<sys/kbio.h>
end_include

begin_include
include|#
directive|include
file|<dev/kbd/kbdreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/kbd/atkbdreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/kbd/atkbdcreg.h>
end_include

begin_include
include|#
directive|include
file|<isa/isareg.h>
end_include

begin_decl_stmt
specifier|static
name|timeout_t
name|atkbd_timeout
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|atkbd_probe_unit
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|ctlr
parameter_list|,
name|int
name|irq
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|keyboard_switch_t
modifier|*
name|sw
decl_stmt|;
name|int
name|args
index|[
literal|2
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sw
operator|=
name|kbd_get_switch
argument_list|(
name|ATKBD_DRIVER_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|args
index|[
literal|0
index|]
operator|=
name|ctlr
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|irq
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|sw
operator|->
name|probe
call|)
argument_list|(
name|unit
argument_list|,
name|args
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|atkbd_attach_unit
parameter_list|(
name|int
name|unit
parameter_list|,
name|keyboard_t
modifier|*
modifier|*
name|kbd
parameter_list|,
name|int
name|ctlr
parameter_list|,
name|int
name|irq
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|keyboard_switch_t
modifier|*
name|sw
decl_stmt|;
name|int
name|args
index|[
literal|2
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sw
operator|=
name|kbd_get_switch
argument_list|(
name|ATKBD_DRIVER_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
comment|/* reset, initialize and enable the device */
name|args
index|[
literal|0
index|]
operator|=
name|ctlr
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|irq
expr_stmt|;
operator|*
name|kbd
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|sw
operator|->
name|probe
call|)
argument_list|(
name|unit
argument_list|,
name|args
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
call|(
modifier|*
name|sw
operator|->
name|init
call|)
argument_list|(
name|unit
argument_list|,
name|kbd
argument_list|,
name|args
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
call|(
modifier|*
name|sw
operator|->
name|enable
call|)
argument_list|(
operator|*
name|kbd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KBD_INSTALL_CDEV
comment|/* attach a virtual keyboard cdev */
name|error
operator|=
name|kbd_attach
argument_list|(
operator|*
name|kbd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
endif|#
directive|endif
comment|/* 	 * This is a kludge to compensate for lost keyboard interrupts. 	 * A similar code used to be in syscons. See below. XXX 	 */
name|atkbd_timeout
argument_list|(
operator|*
name|kbd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
call|(
modifier|*
name|sw
operator|->
name|diag
call|)
argument_list|(
operator|*
name|kbd
argument_list|,
name|bootverbose
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atkbd_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|keyboard_t
modifier|*
name|kbd
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * The original text of the following comments are extracted  	 * from syscons.c (1.287) 	 *  	 * With release 2.1 of the Xaccel server, the keyboard is left 	 * hanging pretty often. Apparently an interrupt from the 	 * keyboard is lost, and I don't know why (yet). 	 * This ugly hack calls the low-level interrupt routine if input 	 * is ready for the keyboard and conveniently hides the problem. XXX 	 * 	 * Try removing anything stuck in the keyboard controller; whether 	 * it's a keyboard scan code or mouse data. The low-level 	 * interrupt routine doesn't read the mouse data directly,  	 * but the keyboard controller driver will, as a side effect. 	 */
comment|/* 	 * And here is bde's original comment about this: 	 * 	 * This is necessary to handle edge triggered interrupts - if we 	 * returned when our IRQ is high due to unserviced input, then there 	 * would be no more keyboard IRQs until the keyboard is reset by 	 * external powers. 	 * 	 * The keyboard apparently unwedges the irq in most cases. 	 */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|kbd
operator|=
operator|(
name|keyboard_t
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|kbdsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|->
name|lock
operator|)
operator|(
name|kbd
operator|,
name|TRUE
operator|)
condition|)
block|{
comment|/* 		 * We have seen the lock flag is not set. Let's reset 		 * the flag early, otherwise the LED update routine fails 		 * which may want the lock during the interrupt routine. 		 */
operator|(
operator|*
name|kbdsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|->
name|lock
operator|)
operator|(
name|kbd
operator|,
name|FALSE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|kbdsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|->
name|check_char
operator|)
operator|(
name|kbd
operator|)
condition|)
operator|(
operator|*
name|kbdsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|->
name|intr
operator|)
operator|(
name|kbd
operator|,
name|NULL
operator|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|atkbd_timeout
argument_list|,
name|arg
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* LOW-LEVEL */
end_comment

begin_include
include|#
directive|include
file|<machine/limits.h>
end_include

begin_define
define|#
directive|define
name|ATKBD_DEFAULT
value|0
end_define

begin_typedef
typedef|typedef
struct|struct
name|atkbd_state
block|{
name|KBDC
name|kbdc
decl_stmt|;
comment|/* keyboard controller */
comment|/* XXX: don't move this field; pcvt 					 * expects `kbdc' to be the first 					 * field in this structure. */
name|int
name|ks_mode
decl_stmt|;
comment|/* input mode (K_XLATE,K_RAW,K_CODE) */
name|int
name|ks_flags
decl_stmt|;
comment|/* flags */
define|#
directive|define
name|COMPOSE
value|(1<< 0)
name|int
name|ks_polling
decl_stmt|;
name|int
name|ks_state
decl_stmt|;
comment|/* shift/lock key state */
name|int
name|ks_accents
decl_stmt|;
comment|/* accent key index (> 0) */
name|u_int
name|ks_composed_char
decl_stmt|;
comment|/* composed char code (> 0) */
name|u_char
name|ks_prefix
decl_stmt|;
comment|/* AT scan code prefix */
block|}
name|atkbd_state_t
typedef|;
end_typedef

begin_comment
comment|/* keyboard driver declaration */
end_comment

begin_function_decl
specifier|static
name|int
name|atkbd_configure
parameter_list|(
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|kbd_probe_t
name|atkbd_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_init_t
name|atkbd_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_term_t
name|atkbd_term
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_intr_t
name|atkbd_intr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_test_if_t
name|atkbd_test_if
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_enable_t
name|atkbd_enable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_disable_t
name|atkbd_disable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_read_t
name|atkbd_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_check_t
name|atkbd_check
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_read_char_t
name|atkbd_read_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_check_char_t
name|atkbd_check_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_ioctl_t
name|atkbd_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_lock_t
name|atkbd_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_clear_state_t
name|atkbd_clear_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_get_state_t
name|atkbd_get_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_set_state_t
name|atkbd_set_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_poll_mode_t
name|atkbd_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|keyboard_switch_t
name|atkbdsw
init|=
block|{
name|atkbd_probe
block|,
name|atkbd_init
block|,
name|atkbd_term
block|,
name|atkbd_intr
block|,
name|atkbd_test_if
block|,
name|atkbd_enable
block|,
name|atkbd_disable
block|,
name|atkbd_read
block|,
name|atkbd_check
block|,
name|atkbd_read_char
block|,
name|atkbd_check_char
block|,
name|atkbd_ioctl
block|,
name|atkbd_lock
block|,
name|atkbd_clear_state
block|,
name|atkbd_get_state
block|,
name|atkbd_set_state
block|,
name|genkbd_get_fkeystr
block|,
name|atkbd_poll
block|,
name|genkbd_diag
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|KEYBOARD_DRIVER
argument_list|(
name|atkbd
argument_list|,
name|atkbdsw
argument_list|,
name|atkbd_configure
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* local functions */
end_comment

begin_function_decl
specifier|static
name|int
name|get_typematic
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setup_kbd_port
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|intr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_kbd_echo
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|probe_keyboard
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|init_keyboard
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
modifier|*
name|type
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_kbd
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|command
parameter_list|,
name|int
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_kbd_id
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|typematic
parameter_list|(
name|int
name|delay
parameter_list|,
name|int
name|rate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|typematic_delay
parameter_list|(
name|int
name|delay
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|typematic_rate
parameter_list|(
name|int
name|rate
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* local variables */
end_comment

begin_comment
comment|/* the initial key map, accent map and fkey strings */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ATKBD_DFLT_KEYMAP
end_ifdef

begin_define
define|#
directive|define
name|KBD_DFLT_KEYMAP
end_define

begin_include
include|#
directive|include
file|"atkbdmap.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/kbd/kbdtables.h>
end_include

begin_comment
comment|/* structures for the default keyboard */
end_comment

begin_decl_stmt
specifier|static
name|keyboard_t
name|default_kbd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|atkbd_state_t
name|default_kbd_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keymap_t
name|default_keymap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|accentmap_t
name|default_accentmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fkeytab_t
name|default_fkeytab
index|[
name|NUM_FKEYS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * The back door to the keyboard driver!  * This function is called by the console driver, via the kbdio module,  * to tickle keyboard drivers when the low-level console is being initialized.  * Almost nothing in the kernel has been initialied yet.  Try to probe  * keyboards if possible.  * NOTE: because of the way the low-level console is initialized, this routine  * may be called more than once!!  */
end_comment

begin_function
specifier|static
name|int
name|atkbd_configure
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|keyboard_t
modifier|*
name|kbd
decl_stmt|;
name|int
name|arg
index|[
literal|2
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* probe the keyboard controller */
name|atkbdc_configure
argument_list|()
expr_stmt|;
comment|/* if the driver is disabled, unregister the keyboard if any */
if|if
condition|(
operator|(
name|resource_int_value
argument_list|(
literal|"atkbd"
argument_list|,
name|ATKBD_DEFAULT
argument_list|,
literal|"disabled"
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|i
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|kbd_find_keyboard
argument_list|(
name|ATKBD_DRIVER_NAME
argument_list|,
name|ATKBD_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|kbd
operator|=
name|kbd_get_keyboard
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|kbd_unregister
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
name|kbd
operator|->
name|kb_flags
operator|&=
operator|~
name|KB_REGISTERED
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* XXX: a kludge to obtain the device configuration flags */
if|if
condition|(
name|resource_int_value
argument_list|(
literal|"atkbd"
argument_list|,
name|ATKBD_DEFAULT
argument_list|,
literal|"flags"
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|i
expr_stmt|;
comment|/* probe the default keyboard */
name|arg
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|kbd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|atkbd_probe
argument_list|(
name|ATKBD_DEFAULT
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|atkbd_init
argument_list|(
name|ATKBD_DEFAULT
argument_list|,
operator|&
name|kbd
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* return the number of found keyboards */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* low-level functions */
end_comment

begin_comment
comment|/* detect a keyboard */
end_comment

begin_function
specifier|static
name|int
name|atkbd_probe
parameter_list|(
name|int
name|unit
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|KBDC
name|kbdc
decl_stmt|;
name|int
modifier|*
name|data
init|=
operator|(
name|int
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* data[0]: controller, data[1]: irq */
comment|/* XXX */
if|if
condition|(
name|unit
operator|==
name|ATKBD_DEFAULT
condition|)
block|{
if|if
condition|(
name|KBD_IS_PROBED
argument_list|(
operator|&
name|default_kbd
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|kbdc
operator|=
name|atkbdc_open
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbdc
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|probe_keyboard
argument_list|(
name|kbdc
argument_list|,
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|KB_CONF_FAIL_IF_NO_KBD
condition|)
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* reset and initialize the device */
end_comment

begin_function
specifier|static
name|int
name|atkbd_init
parameter_list|(
name|int
name|unit
parameter_list|,
name|keyboard_t
modifier|*
modifier|*
name|kbdp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|keyboard_t
modifier|*
name|kbd
decl_stmt|;
name|atkbd_state_t
modifier|*
name|state
decl_stmt|;
name|keymap_t
modifier|*
name|keymap
decl_stmt|;
name|accentmap_t
modifier|*
name|accmap
decl_stmt|;
name|fkeytab_t
modifier|*
name|fkeymap
decl_stmt|;
name|int
name|fkeymap_size
decl_stmt|;
name|int
name|delay
index|[
literal|2
index|]
decl_stmt|;
name|int
modifier|*
name|data
init|=
operator|(
name|int
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* data[0]: controller, data[1]: irq */
comment|/* XXX */
if|if
condition|(
name|unit
operator|==
name|ATKBD_DEFAULT
condition|)
block|{
operator|*
name|kbdp
operator|=
name|kbd
operator|=
operator|&
name|default_kbd
expr_stmt|;
if|if
condition|(
name|KBD_IS_INITIALIZED
argument_list|(
name|kbd
argument_list|)
operator|&&
name|KBD_IS_CONFIGURED
argument_list|(
name|kbd
argument_list|)
condition|)
return|return
literal|0
return|;
name|state
operator|=
operator|&
name|default_kbd_state
expr_stmt|;
name|keymap
operator|=
operator|&
name|default_keymap
expr_stmt|;
name|accmap
operator|=
operator|&
name|default_accentmap
expr_stmt|;
name|fkeymap
operator|=
name|default_fkeytab
expr_stmt|;
name|fkeymap_size
operator|=
sizeof|sizeof
argument_list|(
name|default_fkeytab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|default_fkeytab
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|kbdp
operator|==
name|NULL
condition|)
block|{
operator|*
name|kbdp
operator|=
name|kbd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|kbd
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|state
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|state
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|keymap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|key_map
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|accmap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|accent_map
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|fkeymap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fkey_tab
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|fkeymap_size
operator|=
sizeof|sizeof
argument_list|(
name|fkey_tab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|fkey_tab
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kbd
operator|==
name|NULL
operator|)
operator|||
operator|(
name|state
operator|==
name|NULL
operator|)
operator|||
operator|(
name|keymap
operator|==
name|NULL
operator|)
operator|||
operator|(
name|accmap
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fkeymap
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|state
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|state
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|keymap
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|keymap
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|accmap
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|accmap
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|fkeymap
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|fkeymap
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbd
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|kbd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|KBD_IS_INITIALIZED
argument_list|(
operator|*
name|kbdp
argument_list|)
operator|&&
name|KBD_IS_CONFIGURED
argument_list|(
operator|*
name|kbdp
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
name|kbd
operator|=
operator|*
name|kbdp
expr_stmt|;
name|state
operator|=
operator|(
name|atkbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
expr_stmt|;
name|bzero
argument_list|(
name|state
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|keymap
operator|=
name|kbd
operator|->
name|kb_keymap
expr_stmt|;
name|accmap
operator|=
name|kbd
operator|->
name|kb_accentmap
expr_stmt|;
name|fkeymap
operator|=
name|kbd
operator|->
name|kb_fkeytab
expr_stmt|;
name|fkeymap_size
operator|=
name|kbd
operator|->
name|kb_fkeytab_size
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|KBD_IS_PROBED
argument_list|(
name|kbd
argument_list|)
condition|)
block|{
name|state
operator|->
name|kbdc
operator|=
name|atkbdc_open
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|kbdc
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|kbd_init_struct
argument_list|(
name|kbd
argument_list|,
name|ATKBD_DRIVER_NAME
argument_list|,
name|KB_OTHER
argument_list|,
name|unit
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|key_map
argument_list|,
name|keymap
argument_list|,
sizeof|sizeof
argument_list|(
name|key_map
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|accent_map
argument_list|,
name|accmap
argument_list|,
sizeof|sizeof
argument_list|(
name|accent_map
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fkey_tab
argument_list|,
name|fkeymap
argument_list|,
name|imin
argument_list|(
name|fkeymap_size
operator|*
sizeof|sizeof
argument_list|(
name|fkeymap
index|[
literal|0
index|]
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|fkey_tab
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|kbd_set_maps
argument_list|(
name|kbd
argument_list|,
name|keymap
argument_list|,
name|accmap
argument_list|,
name|fkeymap
argument_list|,
name|fkeymap_size
argument_list|)
expr_stmt|;
name|kbd
operator|->
name|kb_data
operator|=
operator|(
name|void
operator|*
operator|)
name|state
expr_stmt|;
if|if
condition|(
name|probe_keyboard
argument_list|(
name|state
operator|->
name|kbdc
argument_list|,
name|flags
argument_list|)
condition|)
block|{
comment|/* shouldn't happen */
if|if
condition|(
name|flags
operator|&
name|KB_CONF_FAIL_IF_NO_KBD
condition|)
return|return
name|ENXIO
return|;
block|}
else|else
block|{
name|KBD_FOUND_DEVICE
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
block|}
name|atkbd_clear_state
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
name|state
operator|->
name|ks_mode
operator|=
name|K_XLATE
expr_stmt|;
comment|/*  		 * FIXME: set the initial value for lock keys in ks_state 		 * according to the BIOS data? 		 */
name|KBD_PROBE_DONE
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|KBD_IS_INITIALIZED
argument_list|(
name|kbd
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|KB_CONF_PROBE_ONLY
operator|)
condition|)
block|{
name|kbd
operator|->
name|kb_config
operator|=
name|flags
operator|&
operator|~
name|KB_CONF_PROBE_ONLY
expr_stmt|;
if|if
condition|(
name|KBD_HAS_DEVICE
argument_list|(
name|kbd
argument_list|)
operator|&&
name|init_keyboard
argument_list|(
name|state
operator|->
name|kbdc
argument_list|,
operator|&
name|kbd
operator|->
name|kb_type
argument_list|,
name|kbd
operator|->
name|kb_config
argument_list|)
operator|&&
operator|(
name|kbd
operator|->
name|kb_config
operator|&
name|KB_CONF_FAIL_IF_NO_KBD
operator|)
condition|)
return|return
name|ENXIO
return|;
name|atkbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|KDSETLED
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|state
operator|->
name|ks_state
argument_list|)
expr_stmt|;
name|get_typematic
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
name|delay
index|[
literal|0
index|]
operator|=
name|kbd
operator|->
name|kb_delay1
expr_stmt|;
name|delay
index|[
literal|1
index|]
operator|=
name|kbd
operator|->
name|kb_delay2
expr_stmt|;
name|atkbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|KDSETREPEAT
argument_list|,
operator|(
name|caddr_t
operator|)
name|delay
argument_list|)
expr_stmt|;
name|KBD_INIT_DONE
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|KBD_IS_CONFIGURED
argument_list|(
name|kbd
argument_list|)
condition|)
block|{
if|if
condition|(
name|kbd_register
argument_list|(
name|kbd
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ENXIO
return|;
name|KBD_CONFIG_DONE
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* finish using this keyboard */
end_comment

begin_function
specifier|static
name|int
name|atkbd_term
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
name|kbd_unregister
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* keyboard interrupt routine */
end_comment

begin_function
specifier|static
name|int
name|atkbd_intr
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|atkbd_state_t
modifier|*
name|state
decl_stmt|;
name|int
name|delay
index|[
literal|2
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|KBD_IS_ACTIVE
argument_list|(
name|kbd
argument_list|)
operator|&&
name|KBD_IS_BUSY
argument_list|(
name|kbd
argument_list|)
condition|)
block|{
comment|/* let the callback function to process the input */
call|(
modifier|*
name|kbd
operator|->
name|kb_callback
operator|.
name|kc_func
call|)
argument_list|(
name|kbd
argument_list|,
name|KBDIO_KEYINPUT
argument_list|,
name|kbd
operator|->
name|kb_callback
operator|.
name|kc_arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* read and discard the input; no one is waiting for input */
do|do
block|{
name|c
operator|=
name|atkbd_read_char
argument_list|(
name|kbd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
name|NOKEY
condition|)
do|;
if|if
condition|(
operator|!
name|KBD_HAS_DEVICE
argument_list|(
name|kbd
argument_list|)
condition|)
block|{
comment|/* 			 * The keyboard was not detected before; 			 * it must have been reconnected! 			 */
name|state
operator|=
operator|(
name|atkbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
expr_stmt|;
name|init_keyboard
argument_list|(
name|state
operator|->
name|kbdc
argument_list|,
operator|&
name|kbd
operator|->
name|kb_type
argument_list|,
name|kbd
operator|->
name|kb_config
argument_list|)
expr_stmt|;
name|atkbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|KDSETLED
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|state
operator|->
name|ks_state
argument_list|)
expr_stmt|;
name|get_typematic
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
name|delay
index|[
literal|0
index|]
operator|=
name|kbd
operator|->
name|kb_delay1
expr_stmt|;
name|delay
index|[
literal|1
index|]
operator|=
name|kbd
operator|->
name|kb_delay2
expr_stmt|;
name|atkbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|KDSETREPEAT
argument_list|,
operator|(
name|caddr_t
operator|)
name|delay
argument_list|)
expr_stmt|;
name|KBD_FOUND_DEVICE
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* test the interface to the device */
end_comment

begin_function
specifier|static
name|int
name|atkbd_test_if
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|empty_both_buffers
argument_list|(
operator|(
operator|(
name|atkbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
operator|)
operator|->
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|test_controller
argument_list|(
operator|(
operator|(
name|atkbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
operator|)
operator|->
name|kbdc
argument_list|)
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
elseif|else
if|if
condition|(
name|test_kbd_port
argument_list|(
operator|(
operator|(
name|atkbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
operator|)
operator|->
name|kbdc
argument_list|)
operator|!=
literal|0
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*   * Enable the access to the device; until this function is called,  * the client cannot read from the keyboard.  */
end_comment

begin_function
specifier|static
name|int
name|atkbd_enable
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|KBD_ACTIVATE
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* disallow the access to the device */
end_comment

begin_function
specifier|static
name|int
name|atkbd_disable
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|KBD_DEACTIVATE
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* read one byte from the keyboard if it's allowed */
end_comment

begin_function
specifier|static
name|int
name|atkbd_read
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|wait
condition|)
name|c
operator|=
name|read_kbd_data
argument_list|(
operator|(
operator|(
name|atkbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
operator|)
operator|->
name|kbdc
argument_list|)
expr_stmt|;
else|else
name|c
operator|=
name|read_kbd_data_no_wait
argument_list|(
operator|(
operator|(
name|atkbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
operator|)
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
operator|++
name|kbd
operator|->
name|kb_count
expr_stmt|;
return|return
operator|(
name|KBD_IS_ACTIVE
argument_list|(
name|kbd
argument_list|)
condition|?
name|c
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* check if data is waiting */
end_comment

begin_function
specifier|static
name|int
name|atkbd_check
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
if|if
condition|(
operator|!
name|KBD_IS_ACTIVE
argument_list|(
name|kbd
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|kbdc_data_ready
argument_list|(
operator|(
operator|(
name|atkbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
operator|)
operator|->
name|kbdc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* read char from the keyboard */
end_comment

begin_function
specifier|static
name|u_int
name|atkbd_read_char
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|atkbd_state_t
modifier|*
name|state
decl_stmt|;
name|u_int
name|action
decl_stmt|;
name|int
name|scancode
decl_stmt|;
name|int
name|keycode
decl_stmt|;
name|state
operator|=
operator|(
name|atkbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
expr_stmt|;
name|next_code
label|:
comment|/* do we have a composed char to return? */
if|if
condition|(
operator|!
operator|(
name|state
operator|->
name|ks_flags
operator|&
name|COMPOSE
operator|)
operator|&&
operator|(
name|state
operator|->
name|ks_composed_char
operator|>
literal|0
operator|)
condition|)
block|{
name|action
operator|=
name|state
operator|->
name|ks_composed_char
expr_stmt|;
name|state
operator|->
name|ks_composed_char
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|action
operator|>
name|UCHAR_MAX
condition|)
return|return
name|ERRKEY
return|;
return|return
name|action
return|;
block|}
comment|/* see if there is something in the keyboard port */
if|if
condition|(
name|wait
condition|)
block|{
do|do
block|{
name|scancode
operator|=
name|read_kbd_data
argument_list|(
name|state
operator|->
name|kbdc
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|scancode
operator|==
operator|-
literal|1
condition|)
do|;
block|}
else|else
block|{
name|scancode
operator|=
name|read_kbd_data_no_wait
argument_list|(
name|state
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|scancode
operator|==
operator|-
literal|1
condition|)
return|return
name|NOKEY
return|;
block|}
operator|++
name|kbd
operator|->
name|kb_count
expr_stmt|;
if|#
directive|if
name|KBDIO_DEBUG
operator|>=
literal|10
name|printf
argument_list|(
literal|"atkbd_read_char(): scancode:0x%x\n"
argument_list|,
name|scancode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* return the byte as is for the K_RAW mode */
if|if
condition|(
name|state
operator|->
name|ks_mode
operator|==
name|K_RAW
condition|)
return|return
name|scancode
return|;
comment|/* translate the scan code into a keycode */
name|keycode
operator|=
name|scancode
operator|&
literal|0x7F
expr_stmt|;
switch|switch
condition|(
name|state
operator|->
name|ks_prefix
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* normal scancode */
switch|switch
condition|(
name|scancode
condition|)
block|{
case|case
literal|0xB8
case|:
comment|/* left alt (compose key) released */
if|if
condition|(
name|state
operator|->
name|ks_flags
operator|&
name|COMPOSE
condition|)
block|{
name|state
operator|->
name|ks_flags
operator|&=
operator|~
name|COMPOSE
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|ks_composed_char
operator|>
name|UCHAR_MAX
condition|)
name|state
operator|->
name|ks_composed_char
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|0x38
case|:
comment|/* left alt (compose key) pressed */
if|if
condition|(
operator|!
operator|(
name|state
operator|->
name|ks_flags
operator|&
name|COMPOSE
operator|)
condition|)
block|{
name|state
operator|->
name|ks_flags
operator||=
name|COMPOSE
expr_stmt|;
name|state
operator|->
name|ks_composed_char
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|0xE0
case|:
case|case
literal|0xE1
case|:
name|state
operator|->
name|ks_prefix
operator|=
name|scancode
expr_stmt|;
goto|goto
name|next_code
goto|;
block|}
break|break;
case|case
literal|0xE0
case|:
comment|/* 0xE0 prefix */
name|state
operator|->
name|ks_prefix
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|keycode
condition|)
block|{
case|case
literal|0x1C
case|:
comment|/* right enter key */
name|keycode
operator|=
literal|0x59
expr_stmt|;
break|break;
case|case
literal|0x1D
case|:
comment|/* right ctrl key */
name|keycode
operator|=
literal|0x5A
expr_stmt|;
break|break;
case|case
literal|0x35
case|:
comment|/* keypad divide key */
name|keycode
operator|=
literal|0x5B
expr_stmt|;
break|break;
case|case
literal|0x37
case|:
comment|/* print scrn key */
name|keycode
operator|=
literal|0x5C
expr_stmt|;
break|break;
case|case
literal|0x38
case|:
comment|/* right alt key (alt gr) */
name|keycode
operator|=
literal|0x5D
expr_stmt|;
break|break;
case|case
literal|0x46
case|:
comment|/* ctrl-pause/break on AT 101 (see below) */
name|keycode
operator|=
literal|0x68
expr_stmt|;
break|break;
case|case
literal|0x47
case|:
comment|/* grey home key */
name|keycode
operator|=
literal|0x5E
expr_stmt|;
break|break;
case|case
literal|0x48
case|:
comment|/* grey up arrow key */
name|keycode
operator|=
literal|0x5F
expr_stmt|;
break|break;
case|case
literal|0x49
case|:
comment|/* grey page up key */
name|keycode
operator|=
literal|0x60
expr_stmt|;
break|break;
case|case
literal|0x4B
case|:
comment|/* grey left arrow key */
name|keycode
operator|=
literal|0x61
expr_stmt|;
break|break;
case|case
literal|0x4D
case|:
comment|/* grey right arrow key */
name|keycode
operator|=
literal|0x62
expr_stmt|;
break|break;
case|case
literal|0x4F
case|:
comment|/* grey end key */
name|keycode
operator|=
literal|0x63
expr_stmt|;
break|break;
case|case
literal|0x50
case|:
comment|/* grey down arrow key */
name|keycode
operator|=
literal|0x64
expr_stmt|;
break|break;
case|case
literal|0x51
case|:
comment|/* grey page down key */
name|keycode
operator|=
literal|0x65
expr_stmt|;
break|break;
case|case
literal|0x52
case|:
comment|/* grey insert key */
name|keycode
operator|=
literal|0x66
expr_stmt|;
break|break;
case|case
literal|0x53
case|:
comment|/* grey delete key */
name|keycode
operator|=
literal|0x67
expr_stmt|;
break|break;
comment|/* the following 3 are only used on the MS "Natural" keyboard */
case|case
literal|0x5b
case|:
comment|/* left Window key */
name|keycode
operator|=
literal|0x69
expr_stmt|;
break|break;
case|case
literal|0x5c
case|:
comment|/* right Window key */
name|keycode
operator|=
literal|0x6a
expr_stmt|;
break|break;
case|case
literal|0x5d
case|:
comment|/* menu key */
name|keycode
operator|=
literal|0x6b
expr_stmt|;
break|break;
default|default:
comment|/* ignore everything else */
goto|goto
name|next_code
goto|;
block|}
break|break;
case|case
literal|0xE1
case|:
comment|/* 0xE1 prefix */
comment|/*  		 * The pause/break key on the 101 keyboard produces: 		 * E1-1D-45 E1-9D-C5 		 * Ctrl-pause/break produces: 		 * E0-46 E0-C6 (See above.) 		 */
name|state
operator|->
name|ks_prefix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keycode
operator|==
literal|0x1D
condition|)
name|state
operator|->
name|ks_prefix
operator|=
literal|0x1D
expr_stmt|;
goto|goto
name|next_code
goto|;
comment|/* NOT REACHED */
case|case
literal|0x1D
case|:
comment|/* pause / break */
name|state
operator|->
name|ks_prefix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keycode
operator|!=
literal|0x45
condition|)
goto|goto
name|next_code
goto|;
name|keycode
operator|=
literal|0x68
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|kbd
operator|->
name|kb_type
operator|==
name|KB_84
condition|)
block|{
switch|switch
condition|(
name|keycode
condition|)
block|{
case|case
literal|0x37
case|:
comment|/* *(numpad)/print screen */
if|if
condition|(
name|state
operator|->
name|ks_flags
operator|&
name|SHIFTS
condition|)
name|keycode
operator|=
literal|0x5c
expr_stmt|;
comment|/* print screen */
break|break;
case|case
literal|0x45
case|:
comment|/* num lock/pause */
if|if
condition|(
name|state
operator|->
name|ks_flags
operator|&
name|CTLS
condition|)
name|keycode
operator|=
literal|0x68
expr_stmt|;
comment|/* pause */
break|break;
case|case
literal|0x46
case|:
comment|/* scroll lock/break */
if|if
condition|(
name|state
operator|->
name|ks_flags
operator|&
name|CTLS
condition|)
name|keycode
operator|=
literal|0x6c
expr_stmt|;
comment|/* break */
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|kbd
operator|->
name|kb_type
operator|==
name|KB_101
condition|)
block|{
switch|switch
condition|(
name|keycode
condition|)
block|{
case|case
literal|0x5c
case|:
comment|/* print screen */
if|if
condition|(
name|state
operator|->
name|ks_flags
operator|&
name|ALTS
condition|)
name|keycode
operator|=
literal|0x54
expr_stmt|;
comment|/* sysrq */
break|break;
case|case
literal|0x68
case|:
comment|/* pause/break */
if|if
condition|(
name|state
operator|->
name|ks_flags
operator|&
name|CTLS
condition|)
name|keycode
operator|=
literal|0x6c
expr_stmt|;
comment|/* break */
break|break;
block|}
block|}
comment|/* return the key code in the K_CODE mode */
if|if
condition|(
name|state
operator|->
name|ks_mode
operator|==
name|K_CODE
condition|)
return|return
operator|(
name|keycode
operator||
operator|(
name|scancode
operator|&
literal|0x80
operator|)
operator|)
return|;
comment|/* compose a character code */
if|if
condition|(
name|state
operator|->
name|ks_flags
operator|&
name|COMPOSE
condition|)
block|{
switch|switch
condition|(
name|keycode
operator||
operator|(
name|scancode
operator|&
literal|0x80
operator|)
condition|)
block|{
comment|/* key pressed, process it */
case|case
literal|0x47
case|:
case|case
literal|0x48
case|:
case|case
literal|0x49
case|:
comment|/* keypad 7,8,9 */
name|state
operator|->
name|ks_composed_char
operator|*=
literal|10
expr_stmt|;
name|state
operator|->
name|ks_composed_char
operator|+=
name|keycode
operator|-
literal|0x40
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|ks_composed_char
operator|>
name|UCHAR_MAX
condition|)
return|return
name|ERRKEY
return|;
goto|goto
name|next_code
goto|;
case|case
literal|0x4B
case|:
case|case
literal|0x4C
case|:
case|case
literal|0x4D
case|:
comment|/* keypad 4,5,6 */
name|state
operator|->
name|ks_composed_char
operator|*=
literal|10
expr_stmt|;
name|state
operator|->
name|ks_composed_char
operator|+=
name|keycode
operator|-
literal|0x47
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|ks_composed_char
operator|>
name|UCHAR_MAX
condition|)
return|return
name|ERRKEY
return|;
goto|goto
name|next_code
goto|;
case|case
literal|0x4F
case|:
case|case
literal|0x50
case|:
case|case
literal|0x51
case|:
comment|/* keypad 1,2,3 */
name|state
operator|->
name|ks_composed_char
operator|*=
literal|10
expr_stmt|;
name|state
operator|->
name|ks_composed_char
operator|+=
name|keycode
operator|-
literal|0x4E
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|ks_composed_char
operator|>
name|UCHAR_MAX
condition|)
return|return
name|ERRKEY
return|;
goto|goto
name|next_code
goto|;
case|case
literal|0x52
case|:
comment|/* keypad 0 */
name|state
operator|->
name|ks_composed_char
operator|*=
literal|10
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|ks_composed_char
operator|>
name|UCHAR_MAX
condition|)
return|return
name|ERRKEY
return|;
goto|goto
name|next_code
goto|;
comment|/* key released, no interest here */
case|case
literal|0xC7
case|:
case|case
literal|0xC8
case|:
case|case
literal|0xC9
case|:
comment|/* keypad 7,8,9 */
case|case
literal|0xCB
case|:
case|case
literal|0xCC
case|:
case|case
literal|0xCD
case|:
comment|/* keypad 4,5,6 */
case|case
literal|0xCF
case|:
case|case
literal|0xD0
case|:
case|case
literal|0xD1
case|:
comment|/* keypad 1,2,3 */
case|case
literal|0xD2
case|:
comment|/* keypad 0 */
goto|goto
name|next_code
goto|;
case|case
literal|0x38
case|:
comment|/* left alt key */
break|break;
default|default:
if|if
condition|(
name|state
operator|->
name|ks_composed_char
operator|>
literal|0
condition|)
block|{
name|state
operator|->
name|ks_flags
operator|&=
operator|~
name|COMPOSE
expr_stmt|;
name|state
operator|->
name|ks_composed_char
operator|=
literal|0
expr_stmt|;
return|return
name|ERRKEY
return|;
block|}
break|break;
block|}
block|}
comment|/* keycode to key action */
name|action
operator|=
name|genkbd_keyaction
argument_list|(
name|kbd
argument_list|,
name|keycode
argument_list|,
name|scancode
operator|&
literal|0x80
argument_list|,
operator|&
name|state
operator|->
name|ks_state
argument_list|,
operator|&
name|state
operator|->
name|ks_accents
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|NOKEY
condition|)
goto|goto
name|next_code
goto|;
else|else
return|return
name|action
return|;
block|}
end_function

begin_comment
comment|/* check if char is waiting */
end_comment

begin_function
specifier|static
name|int
name|atkbd_check_char
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
name|atkbd_state_t
modifier|*
name|state
decl_stmt|;
if|if
condition|(
operator|!
name|KBD_IS_ACTIVE
argument_list|(
name|kbd
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|state
operator|=
operator|(
name|atkbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|state
operator|->
name|ks_flags
operator|&
name|COMPOSE
operator|)
operator|&&
operator|(
name|state
operator|->
name|ks_composed_char
operator|>
literal|0
operator|)
condition|)
return|return
name|TRUE
return|;
return|return
name|kbdc_data_ready
argument_list|(
name|state
operator|->
name|kbdc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* some useful control functions */
end_comment

begin_function
specifier|static
name|int
name|atkbd_ioctl
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
comment|/* trasnlate LED_XXX bits into the device specific bits */
specifier|static
name|u_char
name|ledmap
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|2
block|,
literal|6
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|7
block|, 	}
decl_stmt|;
name|atkbd_state_t
modifier|*
name|state
init|=
name|kbd
operator|->
name|kb_data
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|KDGKBMODE
case|:
comment|/* get keyboard mode */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|state
operator|->
name|ks_mode
expr_stmt|;
break|break;
case|case
name|KDSKBMODE
case|:
comment|/* set keyboard mode */
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
condition|)
block|{
case|case
name|K_XLATE
case|:
if|if
condition|(
name|state
operator|->
name|ks_mode
operator|!=
name|K_XLATE
condition|)
block|{
comment|/* make lock key state and LED state match */
name|state
operator|->
name|ks_state
operator|&=
operator|~
name|LOCK_MASK
expr_stmt|;
name|state
operator|->
name|ks_state
operator||=
name|KBD_LED_VAL
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
block|}
comment|/* FALL THROUGH */
case|case
name|K_RAW
case|:
case|case
name|K_CODE
case|:
if|if
condition|(
name|state
operator|->
name|ks_mode
operator|!=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
condition|)
block|{
name|atkbd_clear_state
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
name|state
operator|->
name|ks_mode
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
block|}
break|break;
default|default:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
break|break;
case|case
name|KDGETLED
case|:
comment|/* get keyboard LED */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|KBD_LED_VAL
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
break|break;
case|case
name|KDSETLED
case|:
comment|/* set keyboard LED */
comment|/* NOTE: lock key state in ks_state won't be changed */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|&
operator|~
name|LOCK_MASK
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|i
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* replace CAPS LED with ALTGR LED for ALTGR keyboards */
if|if
condition|(
name|state
operator|->
name|ks_mode
operator|==
name|K_XLATE
operator|&&
name|kbd
operator|->
name|kb_keymap
operator|->
name|n_keys
operator|>
name|ALTGR_OFFSET
condition|)
block|{
if|if
condition|(
name|i
operator|&
name|ALKED
condition|)
name|i
operator||=
name|CLKED
expr_stmt|;
else|else
name|i
operator|&=
operator|~
name|CLKED
expr_stmt|;
block|}
if|if
condition|(
name|KBD_HAS_DEVICE
argument_list|(
name|kbd
argument_list|)
condition|)
block|{
name|error
operator|=
name|write_kbd
argument_list|(
name|state
operator|->
name|kbdc
argument_list|,
name|KBDC_SET_LEDS
argument_list|,
name|ledmap
index|[
name|i
operator|&
name|LED_MASK
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|KBD_LED_VAL
argument_list|(
name|kbd
argument_list|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
break|break;
case|case
name|KDGKBSTATE
case|:
comment|/* get lock key state */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|state
operator|->
name|ks_state
operator|&
name|LOCK_MASK
expr_stmt|;
break|break;
case|case
name|KDSKBSTATE
case|:
comment|/* set lock key state */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|&
operator|~
name|LOCK_MASK
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|state
operator|->
name|ks_state
operator|&=
operator|~
name|LOCK_MASK
expr_stmt|;
name|state
operator|->
name|ks_state
operator||=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* set LEDs and quit */
return|return
name|atkbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|KDSETLED
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|KDSETREPEAT
case|:
comment|/* set keyboard repeat rate (new interface) */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|KBD_HAS_DEVICE
argument_list|(
name|kbd
argument_list|)
condition|)
return|return
literal|0
return|;
name|i
operator|=
name|typematic
argument_list|(
operator|(
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|write_kbd
argument_list|(
name|state
operator|->
name|kbdc
argument_list|,
name|KBDC_SET_TYPEMATIC
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|kbd
operator|->
name|kb_delay1
operator|=
name|typematic_delay
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|kbd
operator|->
name|kb_delay2
operator|=
name|typematic_rate
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
case|case
name|KDSETRAD
case|:
comment|/* set keyboard repeat rate (old interface) */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|KBD_HAS_DEVICE
argument_list|(
name|kbd
argument_list|)
condition|)
return|return
literal|0
return|;
name|error
operator|=
name|write_kbd
argument_list|(
name|state
operator|->
name|kbdc
argument_list|,
name|KBDC_SET_TYPEMATIC
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|kbd
operator|->
name|kb_delay1
operator|=
name|typematic_delay
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
name|kbd
operator|->
name|kb_delay2
operator|=
name|typematic_rate
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
case|case
name|PIO_KEYMAP
case|:
comment|/* set keyboard translation table */
case|case
name|PIO_KEYMAPENT
case|:
comment|/* set keyboard translation table entry */
case|case
name|PIO_DEADKEYMAP
case|:
comment|/* set accent key translation table */
name|state
operator|->
name|ks_accents
operator|=
literal|0
expr_stmt|;
comment|/* FALL THROUGH */
default|default:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|genkbd_commonioctl
argument_list|(
name|kbd
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* lock the access to the keyboard */
end_comment

begin_function
specifier|static
name|int
name|atkbd_lock
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|int
name|lock
parameter_list|)
block|{
return|return
name|kbdc_lock
argument_list|(
operator|(
operator|(
name|atkbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
operator|)
operator|->
name|kbdc
argument_list|,
name|lock
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* clear the internal state of the keyboard */
end_comment

begin_function
specifier|static
name|void
name|atkbd_clear_state
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
name|atkbd_state_t
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|(
name|atkbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
expr_stmt|;
name|state
operator|->
name|ks_flags
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|ks_polling
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|ks_state
operator|&=
name|LOCK_MASK
expr_stmt|;
comment|/* preserve locking key state */
name|state
operator|->
name|ks_accents
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|ks_composed_char
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|state->ks_prefix = 0;
comment|/* XXX */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* save the internal state */
end_comment

begin_function
specifier|static
name|int
name|atkbd_get_state
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
sizeof|sizeof
argument_list|(
name|atkbd_state_t
argument_list|)
return|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|atkbd_state_t
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|bcopy
argument_list|(
name|kbd
operator|->
name|kb_data
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|atkbd_state_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* set the internal state */
end_comment

begin_function
specifier|static
name|int
name|atkbd_set_state
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|atkbd_state_t
argument_list|)
condition|)
return|return
name|ENOMEM
return|;
if|if
condition|(
operator|(
operator|(
name|atkbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
operator|)
operator|->
name|kbdc
operator|!=
operator|(
operator|(
name|atkbd_state_t
operator|*
operator|)
name|buf
operator|)
operator|->
name|kbdc
condition|)
return|return
name|ENOMEM
return|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|kbd
operator|->
name|kb_data
argument_list|,
sizeof|sizeof
argument_list|(
name|atkbd_state_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atkbd_poll
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|int
name|on
parameter_list|)
block|{
name|atkbd_state_t
modifier|*
name|state
decl_stmt|;
name|int
name|s
decl_stmt|;
name|state
operator|=
operator|(
name|atkbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|on
condition|)
operator|++
name|state
operator|->
name|ks_polling
expr_stmt|;
else|else
operator|--
name|state
operator|->
name|ks_polling
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* local functions */
end_comment

begin_function
specifier|static
name|int
name|get_typematic
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__i386__
comment|/* 	 * Only some systems allow us to retrieve the keyboard repeat  	 * rate previously set via the BIOS... 	 */
name|struct
name|vm86frame
name|vmf
decl_stmt|;
name|u_int32_t
name|p
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
name|vmf
argument_list|)
argument_list|)
expr_stmt|;
name|vmf
operator|.
name|vmf_ax
operator|=
literal|0xc000
expr_stmt|;
name|vm86_intcall
argument_list|(
literal|0x15
argument_list|,
operator|&
name|vmf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vmf
operator|.
name|vmf_eflags
operator|&
name|PSL_C
operator|)
operator|||
name|vmf
operator|.
name|vmf_ah
condition|)
return|return
name|ENODEV
return|;
name|p
operator|=
name|BIOS_PADDRTOVADDR
argument_list|(
operator|(
operator|(
name|u_int32_t
operator|)
name|vmf
operator|.
name|vmf_es
operator|<<
literal|4
operator|)
operator|+
name|vmf
operator|.
name|vmf_bx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|readb
argument_list|(
name|p
operator|+
literal|6
argument_list|)
operator|&
literal|0x40
operator|)
operator|==
literal|0
condition|)
comment|/* int 16, function 0x09 supported? */
return|return
name|ENODEV
return|;
name|vmf
operator|.
name|vmf_ax
operator|=
literal|0x0900
expr_stmt|;
name|vm86_intcall
argument_list|(
literal|0x16
argument_list|,
operator|&
name|vmf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vmf
operator|.
name|vmf_al
operator|&
literal|0x08
operator|)
operator|==
literal|0
condition|)
comment|/* int 16, function 0x0306 supported? */
return|return
name|ENODEV
return|;
name|vmf
operator|.
name|vmf_ax
operator|=
literal|0x0306
expr_stmt|;
name|vm86_intcall
argument_list|(
literal|0x16
argument_list|,
operator|&
name|vmf
argument_list|)
expr_stmt|;
name|kbd
operator|->
name|kb_delay1
operator|=
name|typematic_delay
argument_list|(
name|vmf
operator|.
name|vmf_bh
operator|<<
literal|5
argument_list|)
expr_stmt|;
name|kbd
operator|->
name|kb_delay2
operator|=
name|typematic_rate
argument_list|(
name|vmf
operator|.
name|vmf_bl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
else|#
directive|else
return|return
name|ENODEV
return|;
endif|#
directive|endif
comment|/* __i386__ */
block|}
end_function

begin_function
specifier|static
name|int
name|setup_kbd_port
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|intr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|kbdc
argument_list|,
name|KBD_KBD_CONTROL_BITS
argument_list|,
operator|(
operator|(
name|port
operator|)
condition|?
name|KBD_ENABLE_KBD_PORT
else|:
name|KBD_DISABLE_KBD_PORT
operator|)
operator||
operator|(
operator|(
name|intr
operator|)
condition|?
name|KBD_ENABLE_KBD_INT
else|:
name|KBD_DISABLE_KBD_INT
operator|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_kbd_echo
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
comment|/* enable the keyboard port, but disable the keyboard intr. */
if|if
condition|(
name|setup_kbd_port
argument_list|(
name|kbdc
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
condition|)
comment|/* CONTROLLER ERROR: there is very little we can do... */
return|return
name|ENXIO
return|;
comment|/* see if something is present */
name|write_kbd_command
argument_list|(
name|kbdc
argument_list|,
name|KBDC_ECHO
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_kbd_data
argument_list|(
name|kbdc
argument_list|)
operator|!=
name|KBD_ECHO
condition|)
block|{
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|test_controller
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
name|test_kbd_port
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* enable the keyboard port and intr. */
if|if
condition|(
name|setup_kbd_port
argument_list|(
name|kbdc
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
comment|/* 		 * CONTROLLER ERROR  		 * This is serious; the keyboard intr is left disabled!  		 */
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|probe_keyboard
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|/* 	 * Don't try to print anything in this function.  The low-level  	 * console may not have been initialized yet... 	 */
name|int
name|err
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|m
decl_stmt|;
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
comment|/* driver error? */
return|return
name|ENXIO
return|;
block|}
comment|/* temporarily block data transmission from the keyboard */
name|write_controller_command
argument_list|(
name|kbdc
argument_list|,
name|KBDC_DISABLE_KBD_PORT
argument_list|)
expr_stmt|;
comment|/* flush any noise in the buffer */
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|/* save the current keyboard controller command byte */
name|m
operator|=
name|kbdc_get_device_mask
argument_list|(
name|kbdc
argument_list|)
operator|&
operator|~
name|KBD_KBD_CONTROL_BITS
expr_stmt|;
name|c
operator|=
name|get_controller_command_byte
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|kbdc_set_device_mask
argument_list|(
name|kbdc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/*  	 * The keyboard may have been screwed up by the boot block. 	 * We may just be able to recover from error by testing the controller 	 * and the keyboard port. The controller command byte needs to be 	 * saved before this recovery operation, as some controllers seem  	 * to set the command byte to particular values. 	 */
name|test_controller
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
name|test_kbd_port
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
name|err
operator|=
name|get_kbd_echo
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
comment|/* 	 * Even if the keyboard doesn't seem to be present (err != 0), 	 * we shall enable the keyboard port and interrupt so that 	 * the driver will be operable when the keyboard is attached 	 * to the system later.  It is NOT recommended to hot-plug 	 * the AT keyboard, but many people do so... 	 */
name|kbdc_set_device_mask
argument_list|(
name|kbdc
argument_list|,
name|m
operator||
name|KBD_KBD_CONTROL_BITS
argument_list|)
expr_stmt|;
name|setup_kbd_port
argument_list|(
name|kbdc
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (err == 0) { 		kbdc_set_device_mask(kbdc, m | KBD_KBD_CONTROL_BITS); 	} else {
comment|/* try to restore the command byte as before */
block|set_controller_command_byte(kbdc, 0xff, c); 		kbdc_set_device_mask(kbdc, m); 	}
endif|#
directive|endif
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_keyboard
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
modifier|*
name|type
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|codeset
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
comment|/* driver error? */
return|return
name|EIO
return|;
block|}
comment|/* temporarily block data transmission from the keyboard */
name|write_controller_command
argument_list|(
name|kbdc
argument_list|,
name|KBDC_DISABLE_KBD_PORT
argument_list|)
expr_stmt|;
comment|/* save the current controller command byte */
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|200
argument_list|)
expr_stmt|;
name|c
operator|=
name|get_controller_command_byte
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"atkbd: unable to get the current command byte value.\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"atkbd: the current kbd controller command byte %04x\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* override the keyboard lock switch */
block|c |= KBD_OVERRIDE_KBD_LOCK;
endif|#
directive|endif
comment|/* enable the keyboard port, but disable the keyboard intr. */
if|if
condition|(
name|setup_kbd_port
argument_list|(
name|kbdc
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR: there is very little we can do... */
name|printf
argument_list|(
literal|"atkbd: unable to set the command byte.\n"
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/*  	 * Check if we have an XT keyboard before we attempt to reset it.  	 * The procedure assumes that the keyboard and the controller have  	 * been set up properly by BIOS and have not been messed up  	 * during the boot process. 	 */
name|codeset
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|KB_CONF_ALT_SCANCODESET
condition|)
comment|/* the user says there is a XT keyboard */
name|codeset
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|KBD_DETECT_XT_KEYBOARD
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
name|KBD_TRANSLATION
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* SET_SCANCODE_SET is not always supported; ignore error */
if|if
condition|(
name|send_kbd_command_and_data
argument_list|(
name|kbdc
argument_list|,
name|KBDC_SET_SCANCODE_SET
argument_list|,
literal|0
argument_list|)
operator|==
name|KBD_ACK
condition|)
name|codeset
operator|=
name|read_kbd_data
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"atkbd: scancode set %d\n"
argument_list|,
name|codeset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* KBD_DETECT_XT_KEYBOARD */
operator|*
name|type
operator|=
name|KB_OTHER
expr_stmt|;
name|id
operator|=
name|get_kbd_id
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|id
condition|)
block|{
case|case
literal|0x41ab
case|:
comment|/* 101/102/... Enhanced */
case|case
literal|0x83ab
case|:
comment|/* ditto */
case|case
literal|0x54ab
case|:
comment|/* SpaceSaver */
case|case
literal|0x84ab
case|:
comment|/* ditto */
if|#
directive|if
literal|0
block|case 0x90ab:
comment|/* 'G' */
block|case 0x91ab:
comment|/* 'P' */
block|case 0x92ab:
comment|/* 'A' */
endif|#
directive|endif
operator|*
name|type
operator|=
name|KB_101
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
comment|/* AT 84 keyboard doesn't return ID */
operator|*
name|type
operator|=
name|KB_84
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"atkbd: keyboard ID 0x%x (%d)\n"
argument_list|,
name|id
argument_list|,
operator|*
name|type
argument_list|)
expr_stmt|;
comment|/* reset keyboard hardware */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|KB_CONF_NO_RESET
operator|)
operator|&&
operator|!
name|reset_kbd
argument_list|(
name|kbdc
argument_list|)
condition|)
block|{
comment|/* 		 * KEYBOARD ERROR 		 * Keyboard reset may fail either because the keyboard 		 * doen't exist, or because the keyboard doesn't pass 		 * the self-test, or the keyboard controller on the 		 * motherboard and the keyboard somehow fail to shake hands. 		 * It is just possible, particularly in the last case, 		 * that the keyoard controller may be left in a hung state. 		 * test_controller() and test_kbd_port() appear to bring 		 * the keyboard controller back (I don't know why and how, 		 * though.) 		 */
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|test_controller
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
name|test_kbd_port
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
comment|/* 		 * We could disable the keyboard port and interrupt... but,  		 * the keyboard may still exist (see above).  		 */
name|set_controller_command_byte
argument_list|(
name|kbdc
argument_list|,
literal|0xff
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"atkbd: failed to reset the keyboard.\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* 	 * Allow us to set the XT_KEYBD flag in UserConfig so that keyboards 	 * such as those on the IBM ThinkPad laptop computers can be used 	 * with the standard console driver. 	 */
if|if
condition|(
name|codeset
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|send_kbd_command_and_data
argument_list|(
name|kbdc
argument_list|,
name|KBDC_SET_SCANCODE_SET
argument_list|,
name|codeset
argument_list|)
operator|==
name|KBD_ACK
condition|)
block|{
comment|/* XT kbd doesn't need scan code translation */
name|c
operator|&=
operator|~
name|KBD_TRANSLATION
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * KEYBOARD ERROR  			 * The XT kbd isn't usable unless the proper scan 			 * code set is selected.  			 */
name|set_controller_command_byte
argument_list|(
name|kbdc
argument_list|,
literal|0xff
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"atkbd: unable to set the XT keyboard mode.\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|__alpha__
if|if
condition|(
name|send_kbd_command_and_data
argument_list|(
name|kbdc
argument_list|,
name|KBDC_SET_SCANCODE_SET
argument_list|,
literal|2
argument_list|)
operator|!=
name|KBD_ACK
condition|)
block|{
name|printf
argument_list|(
literal|"atkbd: can't set translation.\n"
argument_list|)
expr_stmt|;
block|}
name|c
operator||=
name|KBD_TRANSLATION
expr_stmt|;
endif|#
directive|endif
comment|/* enable the keyboard port and intr. */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|kbdc
argument_list|,
name|KBD_KBD_CONTROL_BITS
operator||
name|KBD_TRANSLATION
operator||
name|KBD_OVERRIDE_KBD_LOCK
argument_list|,
operator|(
name|c
operator|&
operator|(
name|KBD_TRANSLATION
operator||
name|KBD_OVERRIDE_KBD_LOCK
operator|)
operator|)
operator||
name|KBD_ENABLE_KBD_PORT
operator||
name|KBD_ENABLE_KBD_INT
argument_list|)
condition|)
block|{
comment|/* 		 * CONTROLLER ERROR  		 * This is serious; we are left with the disabled 		 * keyboard intr.  		 */
name|set_controller_command_byte
argument_list|(
name|kbdc
argument_list|,
literal|0xff
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"atkbd: unable to enable the keyboard port and intr.\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_kbd
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|command
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
comment|/* prevent the timeout routine from polling the keyboard */
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|EBUSY
return|;
comment|/* disable the keyboard and mouse interrupt */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|c = get_controller_command_byte(kbdc);     if ((c == -1)  	|| !set_controller_command_byte(kbdc,              kbdc_get_device_mask(kbdc),             KBD_DISABLE_KBD_PORT | KBD_DISABLE_KBD_INT                 | KBD_DISABLE_AUX_PORT | KBD_DISABLE_AUX_INT)) {
comment|/* CONTROLLER ERROR */
block|kbdc_lock(kbdc, FALSE); 	splx(s); 	return EIO;     }
comment|/*       * Now that the keyboard controller is told not to generate       * the keyboard and mouse interrupts, call `splx()' to allow       * the other tty interrupts. The clock interrupt may also occur,       * but the timeout routine (`scrn_timer()') will be blocked       * by the lock flag set via `kbdc_lock()'      */
block|splx(s);
endif|#
directive|endif
if|if
condition|(
name|send_kbd_command_and_data
argument_list|(
name|kbdc
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
operator|!=
name|KBD_ACK
condition|)
name|send_kbd_command
argument_list|(
name|kbdc
argument_list|,
name|KBDC_ENABLE_KBD
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* restore the interrupts */
block|if (!set_controller_command_byte(kbdc,             kbdc_get_device_mask(kbdc), 	    c& (KBD_KBD_CONTROL_BITS | KBD_AUX_CONTROL_BITS))) {
comment|/* CONTROLLER ERROR */
block|}
else|#
directive|else
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_kbd_id
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|id1
decl_stmt|,
name|id2
decl_stmt|;
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|id1
operator|=
name|id2
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|send_kbd_command
argument_list|(
name|kbdc
argument_list|,
name|KBDC_SEND_DEV_ID
argument_list|)
operator|!=
name|KBD_ACK
condition|)
return|return
operator|-
literal|1
return|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* 10 msec delay */
name|id1
operator|=
name|read_kbd_data
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|id1
operator|!=
operator|-
literal|1
condition|)
name|id2
operator|=
name|read_kbd_data
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|id1
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|id2
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|test_controller
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
name|test_kbd_port
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
operator|(
name|id2
operator|<<
literal|8
operator|)
operator||
name|id1
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|delays
index|[]
init|=
block|{
literal|250
block|,
literal|500
block|,
literal|750
block|,
literal|1000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rates
index|[]
init|=
block|{
literal|34
block|,
literal|38
block|,
literal|42
block|,
literal|46
block|,
literal|50
block|,
literal|55
block|,
literal|59
block|,
literal|63
block|,
literal|68
block|,
literal|76
block|,
literal|84
block|,
literal|92
block|,
literal|100
block|,
literal|110
block|,
literal|118
block|,
literal|126
block|,
literal|136
block|,
literal|152
block|,
literal|168
block|,
literal|184
block|,
literal|200
block|,
literal|220
block|,
literal|236
block|,
literal|252
block|,
literal|272
block|,
literal|304
block|,
literal|336
block|,
literal|368
block|,
literal|400
block|,
literal|440
block|,
literal|472
block|,
literal|504
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|typematic_delay
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|delays
index|[
operator|(
name|i
operator|>>
literal|5
operator|)
operator|&
literal|3
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|typematic_rate
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|rates
index|[
name|i
operator|&
literal|0x1f
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|typematic
parameter_list|(
name|int
name|delay
parameter_list|,
name|int
name|rate
parameter_list|)
block|{
name|int
name|value
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|delays
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|delays
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|delay
operator|>=
name|delays
index|[
name|i
index|]
condition|)
break|break;
block|}
name|value
operator|=
name|i
operator|<<
literal|5
expr_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|rates
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rates
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|rate
operator|>=
name|rates
index|[
name|i
index|]
condition|)
break|break;
block|}
name|value
operator||=
name|i
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

end_unit

