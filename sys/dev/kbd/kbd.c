begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Kazutaka YOKOTA<yokota@zodiac.mech.utsunomiya-u.ac.jp>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer as  *    the first lines of this file unmodified.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $Id: kbd.c,v 1.4 1999/03/10 10:36:52 yokota Exp $  */
end_comment

begin_include
include|#
directive|include
file|"kbd.h"
end_include

begin_include
include|#
directive|include
file|"opt_kbd.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<machine/console.h>
end_include

begin_include
include|#
directive|include
file|<dev/kbd/kbdreg.h>
end_include

begin_comment
comment|/* local arrays */
end_comment

begin_comment
comment|/*  * We need at least one entry each in order to initialize a keyboard  * for the kernel console.  The arrays will be increased dynamically  * when necessary.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|keyboards
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyboard_t
modifier|*
name|kbd_ini
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyboard_t
modifier|*
modifier|*
name|keyboard
init|=
operator|&
name|kbd_ini
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyboard_switch_t
modifier|*
name|kbdsw_ini
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|keyboard_switch_t
modifier|*
modifier|*
name|kbdsw
init|=
operator|&
name|kbdsw_ini
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KBD_INSTALL_CDEV
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
modifier|*
name|kbdcdevsw_ini
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
modifier|*
modifier|*
name|kbdcdevsw
init|=
operator|&
name|kbdcdevsw_ini
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ARRAY_DELTA
value|4
end_define

begin_function
specifier|static
name|int
name|kbd_realloc_array
parameter_list|(
name|void
parameter_list|)
block|{
name|keyboard_t
modifier|*
modifier|*
name|new_kbd
decl_stmt|;
name|keyboard_switch_t
modifier|*
modifier|*
name|new_kbdsw
decl_stmt|;
ifdef|#
directive|ifdef
name|KBD_INSTALL_CDEV
name|struct
name|cdevsw
modifier|*
modifier|*
name|new_cdevsw
decl_stmt|;
endif|#
directive|endif
name|int
name|newsize
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|newsize
operator|=
operator|(
operator|(
name|keyboards
operator|+
name|ARRAY_DELTA
operator|)
operator|/
name|ARRAY_DELTA
operator|)
operator|*
name|ARRAY_DELTA
expr_stmt|;
name|new_kbd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_kbd
argument_list|)
operator|*
name|newsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_kbd
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|new_kbdsw
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_kbdsw
argument_list|)
operator|*
name|newsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_kbdsw
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|new_kbd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
ifdef|#
directive|ifdef
name|KBD_INSTALL_CDEV
name|new_cdevsw
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_cdevsw
argument_list|)
operator|*
name|newsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_cdevsw
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|new_kbd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_kbdsw
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
endif|#
directive|endif
name|bzero
argument_list|(
name|new_kbd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_kbd
argument_list|)
operator|*
name|newsize
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|new_kbdsw
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_kbdsw
argument_list|)
operator|*
name|newsize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|keyboard
argument_list|,
name|new_kbd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|keyboard
argument_list|)
operator|*
name|keyboards
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|kbdsw
argument_list|,
name|new_kbdsw
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|kbdsw
argument_list|)
operator|*
name|keyboards
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KBD_INSTALL_CDEV
name|bzero
argument_list|(
name|new_cdevsw
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_cdevsw
argument_list|)
operator|*
name|newsize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|kbdcdevsw
argument_list|,
name|new_cdevsw
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|kbdcdevsw
argument_list|)
operator|*
name|keyboards
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|keyboards
operator|>
literal|1
condition|)
block|{
name|free
argument_list|(
name|keyboard
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kbdsw
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KBD_INSTALL_CDEV
name|free
argument_list|(
name|kbdcdevsw
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|keyboard
operator|=
name|new_kbd
expr_stmt|;
name|kbdsw
operator|=
name|new_kbdsw
expr_stmt|;
ifdef|#
directive|ifdef
name|KBD_INSTALL_CDEV
name|kbdcdevsw
operator|=
name|new_cdevsw
expr_stmt|;
endif|#
directive|endif
name|keyboards
operator|=
name|newsize
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"kbd: new array size %d\n"
argument_list|,
name|keyboards
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Low-level keyboard driver functions  * Keyboard subdrivers, such as the AT keyboard driver and the USB keyboard  * driver, call these functions to initialize the keyboard_t structure  * and register it to the virtual keyboard driver `kbd'.  */
end_comment

begin_comment
comment|/* initialize the keyboard_t structure */
end_comment

begin_function
name|void
name|kbd_init_struct
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|config
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|port_size
parameter_list|)
block|{
name|kbd
operator|->
name|kb_flags
operator|=
name|KB_NO_DEVICE
expr_stmt|;
comment|/* device has not been found */
name|kbd
operator|->
name|kb_name
operator|=
name|name
expr_stmt|;
name|kbd
operator|->
name|kb_type
operator|=
name|type
expr_stmt|;
name|kbd
operator|->
name|kb_unit
operator|=
name|unit
expr_stmt|;
name|kbd
operator|->
name|kb_config
operator|=
name|config
operator|&
operator|~
name|KB_CONF_PROBE_ONLY
expr_stmt|;
name|kbd
operator|->
name|kb_led
operator|=
literal|0
expr_stmt|;
comment|/* unknown */
name|kbd
operator|->
name|kb_io_base
operator|=
name|port
expr_stmt|;
name|kbd
operator|->
name|kb_io_size
operator|=
name|port_size
expr_stmt|;
name|kbd
operator|->
name|kb_data
operator|=
name|NULL
expr_stmt|;
name|kbd
operator|->
name|kb_keymap
operator|=
name|NULL
expr_stmt|;
name|kbd
operator|->
name|kb_accentmap
operator|=
name|NULL
expr_stmt|;
name|kbd
operator|->
name|kb_fkeytab
operator|=
name|NULL
expr_stmt|;
name|kbd
operator|->
name|kb_fkeytab_size
operator|=
literal|0
expr_stmt|;
name|kbd
operator|->
name|kb_delay1
operator|=
name|KB_DELAY1
expr_stmt|;
comment|/* these values are advisory only */
name|kbd
operator|->
name|kb_delay2
operator|=
name|KB_DELAY2
expr_stmt|;
block|}
end_function

begin_function
name|void
name|kbd_set_maps
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|keymap_t
modifier|*
name|keymap
parameter_list|,
name|accentmap_t
modifier|*
name|accmap
parameter_list|,
name|fkeytab_t
modifier|*
name|fkeymap
parameter_list|,
name|int
name|fkeymap_size
parameter_list|)
block|{
name|kbd
operator|->
name|kb_keymap
operator|=
name|keymap
expr_stmt|;
name|kbd
operator|->
name|kb_accentmap
operator|=
name|accmap
expr_stmt|;
name|kbd
operator|->
name|kb_fkeytab
operator|=
name|fkeymap
expr_stmt|;
name|kbd
operator|->
name|kb_fkeytab_size
operator|=
name|fkeymap_size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* register a keyboard and associate it with a function table */
end_comment

begin_function
name|int
name|kbd_register
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
name|keyboard_driver_t
modifier|*
modifier|*
name|list
decl_stmt|;
name|keyboard_driver_t
modifier|*
name|p
decl_stmt|;
name|int
name|index
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|keyboards
condition|;
operator|++
name|index
control|)
block|{
if|if
condition|(
name|keyboard
index|[
name|index
index|]
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|index
operator|>=
name|keyboards
condition|)
block|{
if|if
condition|(
name|kbd_realloc_array
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|kbd
operator|->
name|kb_index
operator|=
name|index
expr_stmt|;
name|KBD_UNBUSY
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
name|KBD_VALID
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
name|kbd
operator|->
name|kb_active
operator|=
literal|0
expr_stmt|;
comment|/* disabled until someone calls kbd_enable() */
name|kbd
operator|->
name|kb_token
operator|=
name|NULL
expr_stmt|;
name|kbd
operator|->
name|kb_callback
operator|.
name|kc_func
operator|=
name|NULL
expr_stmt|;
name|kbd
operator|->
name|kb_callback
operator|.
name|kc_arg
operator|=
name|NULL
expr_stmt|;
name|list
operator|=
operator|(
name|keyboard_driver_t
operator|*
operator|*
operator|)
name|kbddriver_set
operator|.
name|ls_items
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|list
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|kbd
operator|->
name|kb_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keyboard
index|[
name|index
index|]
operator|=
name|kbd
expr_stmt|;
name|kbdsw
index|[
name|index
index|]
operator|=
name|p
operator|->
name|kbdsw
expr_stmt|;
return|return
name|index
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|kbd_unregister
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|kbd
operator|->
name|kb_index
operator|<
literal|0
operator|)
operator|||
operator|(
name|kbd
operator|->
name|kb_index
operator|>=
name|keyboards
operator|)
condition|)
return|return
name|ENOENT
return|;
if|if
condition|(
name|keyboard
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|!=
name|kbd
condition|)
return|return
name|ENOENT
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|KBD_IS_BUSY
argument_list|(
name|kbd
argument_list|)
condition|)
block|{
name|error
operator|=
call|(
modifier|*
name|kbd
operator|->
name|kb_callback
operator|.
name|kc_func
call|)
argument_list|(
name|kbd
argument_list|,
name|KBDIO_UNLOADING
argument_list|,
name|kbd
operator|->
name|kb_callback
operator|.
name|kc_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|KBD_IS_BUSY
argument_list|(
name|kbd
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
block|}
name|KBD_INVALID
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
name|keyboard
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|=
name|NULL
expr_stmt|;
name|kbdsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* find a funciton table by the driver name */
end_comment

begin_function
name|keyboard_switch_t
modifier|*
name|kbd_get_switch
parameter_list|(
name|char
modifier|*
name|driver
parameter_list|)
block|{
name|keyboard_driver_t
modifier|*
modifier|*
name|list
decl_stmt|;
name|keyboard_driver_t
modifier|*
name|p
decl_stmt|;
name|list
operator|=
operator|(
name|keyboard_driver_t
operator|*
operator|*
operator|)
name|kbddriver_set
operator|.
name|ls_items
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|list
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|driver
argument_list|)
operator|==
literal|0
condition|)
return|return
name|p
operator|->
name|kbdsw
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Keyboard client functions  * Keyboard clients, such as the console driver `syscons' and the keyboard  * cdev driver, use these functions to claim and release a keyboard for  * exclusive use.  */
end_comment

begin_comment
comment|/* find the keyboard specified by a driver name and a unit number */
end_comment

begin_function
name|int
name|kbd_find_keyboard
parameter_list|(
name|char
modifier|*
name|driver
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keyboards
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|keyboard
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|KBD_IS_VALID
argument_list|(
name|keyboard
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
literal|"*"
argument_list|,
name|driver
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|keyboard
index|[
name|i
index|]
operator|->
name|kb_name
argument_list|,
name|driver
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|unit
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|keyboard
index|[
name|i
index|]
operator|->
name|kb_unit
operator|!=
name|unit
operator|)
condition|)
continue|continue;
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* allocate a keyboard */
end_comment

begin_function
name|int
name|kbd_allocate
parameter_list|(
name|char
modifier|*
name|driver
parameter_list|,
name|int
name|unit
parameter_list|,
name|void
modifier|*
name|id
parameter_list|,
name|kbd_callback_func_t
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|index
operator|=
name|kbd_find_keyboard
argument_list|(
name|driver
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|KBD_IS_BUSY
argument_list|(
name|keyboard
index|[
name|index
index|]
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|keyboard
index|[
name|index
index|]
operator|->
name|kb_token
operator|=
name|id
expr_stmt|;
name|KBD_BUSY
argument_list|(
name|keyboard
index|[
name|index
index|]
argument_list|)
expr_stmt|;
name|keyboard
index|[
name|index
index|]
operator|->
name|kb_callback
operator|.
name|kc_func
operator|=
name|func
expr_stmt|;
name|keyboard
index|[
name|index
index|]
operator|->
name|kb_callback
operator|.
name|kc_arg
operator|=
name|arg
expr_stmt|;
operator|(
operator|*
name|kbdsw
index|[
name|index
index|]
operator|->
name|clear_state
operator|)
operator|(
name|keyboard
index|[
name|index
index|]
operator|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_function
name|int
name|kbd_release
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|void
modifier|*
name|id
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|KBD_IS_VALID
argument_list|(
name|kbd
argument_list|)
operator|||
operator|!
name|KBD_IS_BUSY
argument_list|(
name|kbd
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kbd
operator|->
name|kb_token
operator|!=
name|id
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
else|else
block|{
name|kbd
operator|->
name|kb_token
operator|=
name|NULL
expr_stmt|;
name|KBD_UNBUSY
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
name|kbd
operator|->
name|kb_callback
operator|.
name|kc_func
operator|=
name|NULL
expr_stmt|;
name|kbd
operator|->
name|kb_callback
operator|.
name|kc_arg
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|kbdsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|->
name|clear_state
operator|)
operator|(
name|kbd
operator|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|kbd_change_callback
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|void
modifier|*
name|id
parameter_list|,
name|kbd_callback_func_t
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|KBD_IS_VALID
argument_list|(
name|kbd
argument_list|)
operator|||
operator|!
name|KBD_IS_BUSY
argument_list|(
name|kbd
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kbd
operator|->
name|kb_token
operator|!=
name|id
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|kbd
operator|->
name|kb_callback
operator|.
name|kc_func
operator|=
name|func
expr_stmt|;
name|kbd
operator|->
name|kb_callback
operator|.
name|kc_arg
operator|=
name|arg
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* get a keyboard structure */
end_comment

begin_function
name|keyboard_t
modifier|*
name|kbd_get_keyboard
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
operator|(
name|index
operator|<
literal|0
operator|)
operator|||
operator|(
name|index
operator|>=
name|keyboards
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|KBD_IS_VALID
argument_list|(
name|keyboard
index|[
name|index
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|keyboard
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * The back door for the console driver; configure keyboards  * This function is for the kernel console to initialize keyboards  * at very early stage.  */
end_comment

begin_function
name|int
name|kbd_configure
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|keyboard_driver_t
modifier|*
modifier|*
name|list
decl_stmt|;
name|keyboard_driver_t
modifier|*
name|p
decl_stmt|;
name|list
operator|=
operator|(
name|keyboard_driver_t
operator|*
operator|*
operator|)
name|kbddriver_set
operator|.
name|ls_items
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|list
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|configure
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|p
operator|->
name|configure
call|)
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KBD_INSTALL_CDEV
end_ifdef

begin_comment
comment|/*  * Virtual keyboard cdev driver functions  * The virtual keyboard driver dispatches driver functions to  * appropriate subdrivers.  */
end_comment

begin_define
define|#
directive|define
name|KBD_UNIT
parameter_list|(
name|dev
parameter_list|)
value|minor(dev)
end_define

begin_decl_stmt
specifier|static
name|d_open_t
name|kbdopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|kbdclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|kbdread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|kbdwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|kbdioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_reset_t
name|kbdreset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_devtotty_t
name|kbddevtotty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|kbdpoll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_mmap_t
name|kbdmmap
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|112
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|kbd_cdevsw
init|=
block|{
name|kbdopen
block|,
name|kbdclose
block|,
name|kbdread
block|,
name|kbdwrite
block|,
comment|/* ??? */
name|kbdioctl
block|,
name|nullstop
block|,
name|kbdreset
block|,
name|kbddevtotty
block|,
name|kbdpoll
block|,
name|kbdmmap
block|,
name|nostrategy
block|,
literal|"kbd"
block|,
name|NULL
block|,
operator|-
literal|1
block|,
name|nodump
block|,
name|nopsize
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|vkbdattach
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|static
name|int
name|kbd_devsw_installed
init|=
name|FALSE
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|kbd_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|kbd_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|kbd_devsw_installed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|PSEUDO_SET
argument_list|(
name|vkbdattach
argument_list|,
name|kbd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|kbd_attach
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|struct
name|cdevsw
modifier|*
name|cdevsw
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|kbd
operator|->
name|kb_index
operator|>=
name|keyboards
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|keyboard
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|!=
name|kbd
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|kbd
operator|->
name|kb_minor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|kbdcdevsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|=
name|cdevsw
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* XXX: DEVFS? */
name|printf
argument_list|(
literal|"kbd%d at %s%d\n"
argument_list|,
name|kbd
operator|->
name|kb_index
argument_list|,
name|kbd
operator|->
name|kb_name
argument_list|,
name|kbd
operator|->
name|kb_unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|kbd_detach
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|struct
name|cdevsw
modifier|*
name|cdevsw
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|kbd
operator|->
name|kb_index
operator|>=
name|keyboards
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|keyboard
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|!=
name|kbd
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|kbdcdevsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|!=
name|cdevsw
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|kbdcdevsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kbdopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|KBD_UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|keyboards
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|kbdcdevsw
index|[
name|unit
index|]
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|KBD_IS_BUSY
argument_list|(
name|keyboard
index|[
name|unit
index|]
argument_list|)
condition|)
return|return
name|EBUSY
return|;
return|return
operator|(
operator|*
name|kbdcdevsw
index|[
name|unit
index|]
operator|->
name|d_open
operator|)
operator|(
name|makedev
argument_list|(
literal|0
argument_list|,
name|keyboard
index|[
name|unit
index|]
operator|->
name|kb_minor
argument_list|)
operator|,
name|flag
operator|,
name|mode
operator|,
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kbdclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|KBD_UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbdcdevsw
index|[
name|unit
index|]
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
return|return
operator|(
operator|*
name|kbdcdevsw
index|[
name|unit
index|]
operator|->
name|d_close
operator|)
operator|(
name|makedev
argument_list|(
literal|0
argument_list|,
name|keyboard
index|[
name|unit
index|]
operator|->
name|kb_minor
argument_list|)
operator|,
name|flag
operator|,
name|mode
operator|,
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kbdread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|KBD_UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbdcdevsw
index|[
name|unit
index|]
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
return|return
operator|(
operator|*
name|kbdcdevsw
index|[
name|unit
index|]
operator|->
name|d_read
operator|)
operator|(
name|makedev
argument_list|(
literal|0
argument_list|,
name|keyboard
index|[
name|unit
index|]
operator|->
name|kb_minor
argument_list|)
operator|,
name|uio
operator|,
name|flag
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kbdwrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|KBD_UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbdcdevsw
index|[
name|unit
index|]
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
return|return
operator|(
operator|*
name|kbdcdevsw
index|[
name|unit
index|]
operator|->
name|d_write
operator|)
operator|(
name|makedev
argument_list|(
literal|0
argument_list|,
name|keyboard
index|[
name|unit
index|]
operator|->
name|kb_minor
argument_list|)
operator|,
name|uio
operator|,
name|flag
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kbdioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|KBD_UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbdcdevsw
index|[
name|unit
index|]
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
return|return
operator|(
operator|*
name|kbdcdevsw
index|[
name|unit
index|]
operator|->
name|d_ioctl
operator|)
operator|(
name|makedev
argument_list|(
literal|0
argument_list|,
name|keyboard
index|[
name|unit
index|]
operator|->
name|kb_minor
argument_list|)
operator|,
name|cmd
operator|,
name|arg
operator|,
name|flag
operator|,
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kbdreset
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|KBD_UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbdcdevsw
index|[
name|unit
index|]
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
return|return
operator|(
operator|*
name|kbdcdevsw
index|[
name|unit
index|]
operator|->
name|d_reset
operator|)
operator|(
name|makedev
argument_list|(
literal|0
argument_list|,
name|keyboard
index|[
name|unit
index|]
operator|->
name|kb_minor
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|tty
modifier|*
name|kbddevtotty
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|KBD_UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbdcdevsw
index|[
name|unit
index|]
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
operator|(
operator|*
name|kbdcdevsw
index|[
name|unit
index|]
operator|->
name|d_devtotty
operator|)
operator|(
name|makedev
argument_list|(
literal|0
argument_list|,
name|keyboard
index|[
name|unit
index|]
operator|->
name|kb_minor
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kbdpoll
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|event
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|KBD_UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbdcdevsw
index|[
name|unit
index|]
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
return|return
operator|(
operator|*
name|kbdcdevsw
index|[
name|unit
index|]
operator|->
name|d_poll
operator|)
operator|(
name|makedev
argument_list|(
literal|0
argument_list|,
name|keyboard
index|[
name|unit
index|]
operator|->
name|kb_minor
argument_list|)
operator|,
name|event
operator|,
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kbdmmap
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|KBD_UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbdcdevsw
index|[
name|unit
index|]
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
return|return
operator|(
operator|*
name|kbdcdevsw
index|[
name|unit
index|]
operator|->
name|d_mmap
operator|)
operator|(
name|makedev
argument_list|(
literal|0
argument_list|,
name|keyboard
index|[
name|unit
index|]
operator|->
name|kb_minor
argument_list|)
operator|,
name|offset
operator|,
name|nprot
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic keyboard cdev driver functions  * Keyboard subdrivers may call these functions to implement common  * driver functions.  */
end_comment

begin_define
define|#
directive|define
name|KB_QSIZE
value|512
end_define

begin_define
define|#
directive|define
name|KB_BUFSIZE
value|64
end_define

begin_decl_stmt
specifier|static
name|kbd_callback_func_t
name|genkbd_event
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|genkbdopen
parameter_list|(
name|genkbd_softc_t
modifier|*
name|sc
parameter_list|,
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|KBD_IS_VALID
argument_list|(
name|kbd
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|i
operator|=
name|kbd_allocate
argument_list|(
name|kbd
operator|->
name|kb_name
argument_list|,
name|kbd
operator|->
name|kb_unit
argument_list|,
name|sc
argument_list|,
name|genkbd_event
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
comment|/* assert(i == kbd->kb_index) */
comment|/* assert(kbd == kbd_get_keyboard(i)) */
comment|/* 	 * NOTE: even when we have successfully claimed a keyboard, 	 * the device may still be missing (!KBD_HAS_DEVICE(kbd)). 	 */
if|#
directive|if
literal|0
block|bzero(&sc->gkb_q, sizeof(sc->gkb_q));
endif|#
directive|endif
name|clist_alloc_cblocks
argument_list|(
operator|&
name|sc
operator|->
name|gkb_q
argument_list|,
name|KB_QSIZE
argument_list|,
name|KB_QSIZE
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* XXX */
name|sc
operator|->
name|gkb_rsel
operator|.
name|si_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|gkb_rsel
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|genkbdclose
parameter_list|(
name|genkbd_softc_t
modifier|*
name|sc
parameter_list|,
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
comment|/* 	 * NOTE: the device may have already become invalid. 	 * !KBD_IS_VALID(kbd) 	 */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|kbd_release
argument_list|(
name|kbd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|clist_free_cblocks(&sc->gkb_q);
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|genkbdread
parameter_list|(
name|genkbd_softc_t
modifier|*
name|sc
parameter_list|,
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|u_char
name|buffer
index|[
name|KB_BUFSIZE
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* wait for input */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|gkb_q
operator|.
name|c_cc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|KBD_IS_VALID
argument_list|(
name|kbd
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
if|if
condition|(
name|flag
operator|&
name|IO_NDELAY
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EWOULDBLOCK
return|;
block|}
name|sc
operator|->
name|gkb_flags
operator||=
name|KB_ASLEEP
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"kbdrea"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|sc
operator|->
name|gkb_flags
operator|&=
operator|~
name|KB_ASLEEP
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* copy as much input as possible */
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|imin
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|q_to_b
argument_list|(
operator|&
name|sc
operator|->
name|gkb_q
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
break|break;
name|error
operator|=
name|uiomove
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|genkbdwrite
parameter_list|(
name|genkbd_softc_t
modifier|*
name|sc
parameter_list|,
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
if|if
condition|(
operator|!
name|KBD_IS_VALID
argument_list|(
name|kbd
argument_list|)
condition|)
return|return
name|ENXIO
return|;
return|return
name|ENODEV
return|;
block|}
end_function

begin_function
name|int
name|genkbdioctl
parameter_list|(
name|genkbd_softc_t
modifier|*
name|sc
parameter_list|,
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|kbd
operator|==
name|NULL
condition|)
comment|/* XXX */
return|return
name|ENXIO
return|;
if|if
condition|(
operator|!
name|KBD_IS_VALID
argument_list|(
name|kbd
argument_list|)
condition|)
return|return
name|ENXIO
return|;
name|error
operator|=
operator|(
operator|*
name|kbdsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|->
name|ioctl
operator|)
operator|(
name|kbd
operator|,
name|cmd
operator|,
name|arg
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|genkbdpoll
parameter_list|(
name|genkbd_softc_t
modifier|*
name|sc
parameter_list|,
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|revents
decl_stmt|;
name|int
name|s
decl_stmt|;
name|revents
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|gkb_q
operator|.
name|c_cc
operator|>
literal|0
operator|)
operator|||
operator|!
name|KBD_IS_VALID
argument_list|(
name|kbd
argument_list|)
condition|)
name|revents
operator||=
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
else|else
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|sc
operator|->
name|gkb_rsel
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|revents
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|genkbd_event
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|genkbd_softc_t
modifier|*
name|sc
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* assert(KBD_IS_VALID(kbd)) */
name|sc
operator|=
operator|(
name|genkbd_softc_t
operator|*
operator|)
name|arg
expr_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|KBDIO_KEYINPUT
case|:
break|break;
case|case
name|KBDIO_UNLOADING
case|:
comment|/* the keyboard is going... */
name|kbd_release
argument_list|(
name|kbd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
comment|/* obtain the current key input mode */
if|if
condition|(
operator|(
operator|*
name|kbdsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|->
name|ioctl
operator|)
operator|(
name|kbd
operator|,
name|KDGKBMODE
operator|,
operator|(
name|caddr_t
operator|)
operator|&
name|mode
operator|)
condition|)
name|mode
operator|=
name|K_XLATE
expr_stmt|;
comment|/* read all pending input */
while|while
condition|(
operator|(
operator|*
name|kbdsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|->
name|check_char
operator|)
operator|(
name|kbd
operator|)
condition|)
block|{
name|c
operator|=
operator|(
operator|*
name|kbdsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|->
name|read_char
operator|)
operator|(
name|kbd
operator|,
name|FALSE
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NOKEY
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
name|ERRKEY
condition|)
comment|/* XXX: ring bell? */
continue|continue;
if|if
condition|(
operator|!
name|KBD_IS_BUSY
argument_list|(
name|kbd
argument_list|)
condition|)
comment|/* the device is not open, discard the input */
continue|continue;
comment|/* store the byte as is for K_RAW and K_CODE modes */
if|if
condition|(
name|mode
operator|!=
name|K_XLATE
condition|)
block|{
name|putc
argument_list|(
name|KEYCHAR
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|gkb_q
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* K_XLATE */
if|if
condition|(
name|c
operator|&
name|RELKEY
condition|)
comment|/* key release is ignored */
continue|continue;
comment|/* process special keys; most of them are just ignored... */
if|if
condition|(
name|c
operator|&
name|SPCLKEY
condition|)
block|{
switch|switch
condition|(
name|KEYCHAR
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* locking keys */
case|case
name|NLK
case|:
case|case
name|CLK
case|:
case|case
name|SLK
case|:
case|case
name|ALK
case|:
comment|/* shift keys */
case|case
name|LSH
case|:
case|case
name|RSH
case|:
case|case
name|LCTR
case|:
case|case
name|RCTR
case|:
case|case
name|LALT
case|:
case|case
name|RALT
case|:
case|case
name|ASH
case|:
case|case
name|META
case|:
comment|/* other special keys */
case|case
name|NOP
case|:
case|case
name|SPSC
case|:
case|case
name|RBT
case|:
case|case
name|SUSP
case|:
case|case
name|STBY
case|:
case|case
name|DBG
case|:
case|case
name|NEXT
case|:
comment|/* ignore them... */
continue|continue;
case|case
name|BTAB
case|:
comment|/* a backtab: ESC [ Z */
name|putc
argument_list|(
literal|0x1b
argument_list|,
operator|&
name|sc
operator|->
name|gkb_q
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'['
argument_list|,
operator|&
name|sc
operator|->
name|gkb_q
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'Z'
argument_list|,
operator|&
name|sc
operator|->
name|gkb_q
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* normal chars, normal chars with the META, function keys */
switch|switch
condition|(
name|KEYFLAGS
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* a normal char */
name|putc
argument_list|(
name|KEYCHAR
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|gkb_q
argument_list|)
expr_stmt|;
break|break;
case|case
name|MKEY
case|:
comment|/* the META flag: prepend ESC */
name|putc
argument_list|(
literal|0x1b
argument_list|,
operator|&
name|sc
operator|->
name|gkb_q
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|KEYCHAR
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|gkb_q
argument_list|)
expr_stmt|;
break|break;
case|case
name|FKEY
operator||
name|SPCLKEY
case|:
comment|/* a function key, return string */
name|cp
operator|=
operator|(
operator|*
name|kbdsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|->
name|get_fkeystr
operator|)
operator|(
name|kbd
operator|,
name|KEYCHAR
argument_list|(
name|c
argument_list|)
operator|,
operator|&
name|len
operator|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
name|putc
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
operator|&
name|sc
operator|->
name|gkb_q
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* wake up sleeping/polling processes */
if|if
condition|(
name|sc
operator|->
name|gkb_q
operator|.
name|c_cc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|gkb_flags
operator|&
name|KB_ASLEEP
condition|)
block|{
name|sc
operator|->
name|gkb_flags
operator|&=
operator|~
name|KB_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|sc
operator|->
name|gkb_rsel
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KBD_INSTALL_CDEV */
end_comment

begin_comment
comment|/*  * Generic low-level keyboard functions  * The low-level functions in the keyboard subdriver may use these  * functions.  */
end_comment

begin_function
name|int
name|genkbd_commonioctl
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|keyarg_t
modifier|*
name|keyp
decl_stmt|;
name|fkeyarg_t
modifier|*
name|fkeyp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|KDGKBINFO
case|:
comment|/* get keyboard information */
operator|(
operator|(
name|keyboard_info_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|kb_index
operator|=
name|kbd
operator|->
name|kb_index
expr_stmt|;
name|i
operator|=
name|imin
argument_list|(
name|strlen
argument_list|(
name|kbd
operator|->
name|kb_name
argument_list|)
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|(
operator|(
name|keyboard_info_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|kb_name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|kbd
operator|->
name|kb_name
argument_list|,
operator|(
operator|(
name|keyboard_info_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|kb_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|(
operator|(
name|keyboard_info_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|kb_unit
operator|=
name|kbd
operator|->
name|kb_unit
expr_stmt|;
operator|(
operator|(
name|keyboard_info_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|kb_type
operator|=
name|kbd
operator|->
name|kb_type
expr_stmt|;
operator|(
operator|(
name|keyboard_info_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|kb_config
operator|=
name|kbd
operator|->
name|kb_config
expr_stmt|;
operator|(
operator|(
name|keyboard_info_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|kb_flags
operator|=
name|kbd
operator|->
name|kb_flags
expr_stmt|;
break|break;
case|case
name|KDGKBTYPE
case|:
comment|/* get keyboard type */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|kbd
operator|->
name|kb_type
expr_stmt|;
break|break;
case|case
name|GIO_KEYMAP
case|:
comment|/* get keyboard translation table */
name|bcopy
argument_list|(
name|kbd
operator|->
name|kb_keymap
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|kbd
operator|->
name|kb_keymap
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIO_KEYMAP
case|:
comment|/* set keyboard translation table */
ifndef|#
directive|ifndef
name|KBD_DISABLE_KEYMAP_LOAD
name|bzero
argument_list|(
name|kbd
operator|->
name|kb_accentmap
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|kbd
operator|->
name|kb_accentmap
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|arg
argument_list|,
name|kbd
operator|->
name|kb_keymap
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|kbd
operator|->
name|kb_keymap
argument_list|)
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENODEV
return|;
endif|#
directive|endif
case|case
name|GIO_KEYMAPENT
case|:
comment|/* get keyboard translation table entry */
name|keyp
operator|=
operator|(
name|keyarg_t
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|keyp
operator|->
name|keynum
operator|>=
sizeof|sizeof
argument_list|(
name|kbd
operator|->
name|kb_keymap
operator|->
name|key
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|kbd
operator|->
name|kb_keymap
operator|->
name|key
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|bcopy
argument_list|(
operator|&
name|kbd
operator|->
name|kb_keymap
operator|->
name|key
index|[
name|keyp
operator|->
name|keynum
index|]
argument_list|,
operator|&
name|keyp
operator|->
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|keyp
operator|->
name|key
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIO_KEYMAPENT
case|:
comment|/* set keyboard translation table entry */
ifndef|#
directive|ifndef
name|KBD_DISABLE_KEYMAP_LOAD
name|keyp
operator|=
operator|(
name|keyarg_t
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|keyp
operator|->
name|keynum
operator|>=
sizeof|sizeof
argument_list|(
name|kbd
operator|->
name|kb_keymap
operator|->
name|key
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|kbd
operator|->
name|kb_keymap
operator|->
name|key
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|bcopy
argument_list|(
operator|&
name|keyp
operator|->
name|key
argument_list|,
operator|&
name|kbd
operator|->
name|kb_keymap
operator|->
name|key
index|[
name|keyp
operator|->
name|keynum
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|keyp
operator|->
name|key
argument_list|)
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENODEV
return|;
endif|#
directive|endif
case|case
name|GIO_DEADKEYMAP
case|:
comment|/* get accent key translation table */
name|bcopy
argument_list|(
name|kbd
operator|->
name|kb_accentmap
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|kbd
operator|->
name|kb_accentmap
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIO_DEADKEYMAP
case|:
comment|/* set accent key translation table */
ifndef|#
directive|ifndef
name|KBD_DISABLE_KEYMAP_LOAD
name|bcopy
argument_list|(
name|arg
argument_list|,
name|kbd
operator|->
name|kb_accentmap
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|kbd
operator|->
name|kb_accentmap
argument_list|)
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENODEV
return|;
endif|#
directive|endif
case|case
name|GETFKEY
case|:
comment|/* get functionkey string */
name|fkeyp
operator|=
operator|(
name|fkeyarg_t
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|fkeyp
operator|->
name|keynum
operator|>=
name|kbd
operator|->
name|kb_fkeytab_size
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|bcopy
argument_list|(
name|kbd
operator|->
name|kb_fkeytab
index|[
name|fkeyp
operator|->
name|keynum
index|]
operator|.
name|str
argument_list|,
name|fkeyp
operator|->
name|keydef
argument_list|,
name|kbd
operator|->
name|kb_fkeytab
index|[
name|fkeyp
operator|->
name|keynum
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|fkeyp
operator|->
name|flen
operator|=
name|kbd
operator|->
name|kb_fkeytab
index|[
name|fkeyp
operator|->
name|keynum
index|]
operator|.
name|len
expr_stmt|;
break|break;
case|case
name|SETFKEY
case|:
comment|/* set functionkey string */
ifndef|#
directive|ifndef
name|KBD_DISABLE_KEYMAP_LOAD
name|fkeyp
operator|=
operator|(
name|fkeyarg_t
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|fkeyp
operator|->
name|keynum
operator|>=
name|kbd
operator|->
name|kb_fkeytab_size
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|kbd
operator|->
name|kb_fkeytab
index|[
name|fkeyp
operator|->
name|keynum
index|]
operator|.
name|len
operator|=
name|imin
argument_list|(
name|fkeyp
operator|->
name|flen
argument_list|,
name|MAXFK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fkeyp
operator|->
name|keydef
argument_list|,
name|kbd
operator|->
name|kb_fkeytab
index|[
name|fkeyp
operator|->
name|keynum
index|]
operator|.
name|str
argument_list|,
name|kbd
operator|->
name|kb_fkeytab
index|[
name|fkeyp
operator|->
name|keynum
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENODEV
return|;
endif|#
directive|endif
default|default:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOIOCTL
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* get a pointer to the string associated with the given function key */
end_comment

begin_function
name|u_char
modifier|*
name|genkbd_get_fkeystr
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|int
name|fkey
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
if|if
condition|(
name|kbd
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|fkey
operator|-=
name|F_FN
expr_stmt|;
if|if
condition|(
name|fkey
operator|>
name|kbd
operator|->
name|kb_fkeytab_size
condition|)
return|return
name|NULL
return|;
operator|*
name|len
operator|=
name|kbd
operator|->
name|kb_fkeytab
index|[
name|fkey
index|]
operator|.
name|len
expr_stmt|;
return|return
name|kbd
operator|->
name|kb_fkeytab
index|[
name|fkey
index|]
operator|.
name|str
return|;
block|}
end_function

begin_comment
comment|/* diagnostic dump */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_kbd_type_name
parameter_list|(
name|int
name|type
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|name_table
index|[]
init|=
block|{
block|{
name|KB_84
block|,
literal|"AT 84"
block|}
block|,
block|{
name|KB_101
block|,
literal|"AT 101/102"
block|}
block|,
block|{
name|KB_OTHER
block|,
literal|"generic"
block|}
block|, 	}
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|name_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|name_table
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|type
operator|==
name|name_table
index|[
name|i
index|]
operator|.
name|type
condition|)
return|return
name|name_table
index|[
name|i
index|]
operator|.
name|name
return|;
block|}
return|return
literal|"unknown"
return|;
block|}
end_function

begin_function
name|void
name|genkbd_diag
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|int
name|level
parameter_list|)
block|{
if|if
condition|(
name|level
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"kbd%d: %s%d, %s (%d), config:0x%x, flags:0x%x"
argument_list|,
name|kbd
operator|->
name|kb_index
argument_list|,
name|kbd
operator|->
name|kb_name
argument_list|,
name|kbd
operator|->
name|kb_unit
argument_list|,
name|get_kbd_type_name
argument_list|(
name|kbd
operator|->
name|kb_type
argument_list|)
argument_list|,
name|kbd
operator|->
name|kb_type
argument_list|,
name|kbd
operator|->
name|kb_config
argument_list|,
name|kbd
operator|->
name|kb_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbd
operator|->
name|kb_io_base
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|", port:0x%x-0x%x"
argument_list|,
name|kbd
operator|->
name|kb_io_base
argument_list|,
name|kbd
operator|->
name|kb_io_base
operator|+
name|kbd
operator|->
name|kb_io_size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|set_lockkey_state
parameter_list|(
name|k
parameter_list|,
name|s
parameter_list|,
name|l
parameter_list|)
define|\
value|if (!((s)& l ## DOWN)) {				\ 		int i;						\ 		(s) |= l ## DOWN;				\ 		(s) ^= l ## ED;					\ 		i = (s)& LOCK_MASK;				\ 		(*kbdsw[(k)->kb_index]->ioctl)((k), KDSETLED, (caddr_t)&i); \ 	}
end_define

begin_function
specifier|static
name|u_int
name|save_accent_key
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|u_int
name|key
parameter_list|,
name|int
modifier|*
name|accents
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* make an index into the accent map */
name|i
operator|=
name|key
operator|-
name|F_ACC
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|>
name|kbd
operator|->
name|kb_accentmap
operator|->
name|n_accs
operator|)
operator|||
operator|(
name|kbd
operator|->
name|kb_accentmap
operator|->
name|acc
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|accchar
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* the index is out of range or pointing to an empty entry */
operator|*
name|accents
operator|=
literal|0
expr_stmt|;
return|return
name|ERRKEY
return|;
block|}
comment|/*  	 * If the same accent key has been hit twice, produce the accent char 	 * itself. 	 */
if|if
condition|(
name|i
operator|==
operator|*
name|accents
condition|)
block|{
name|key
operator|=
name|kbd
operator|->
name|kb_accentmap
operator|->
name|acc
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|accchar
expr_stmt|;
operator|*
name|accents
operator|=
literal|0
expr_stmt|;
return|return
name|key
return|;
block|}
comment|/* remember the index and wait for the next key  */
operator|*
name|accents
operator|=
name|i
expr_stmt|;
return|return
name|NOKEY
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|make_accent_char
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|u_int
name|ch
parameter_list|,
name|int
modifier|*
name|accents
parameter_list|)
block|{
name|struct
name|acc_t
modifier|*
name|acc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|acc
operator|=
operator|&
name|kbd
operator|->
name|kb_accentmap
operator|->
name|acc
index|[
operator|*
name|accents
operator|-
literal|1
index|]
expr_stmt|;
operator|*
name|accents
operator|=
literal|0
expr_stmt|;
comment|/*  	 * If the accent key is followed by the space key, 	 * produce the accent char itself. 	 */
if|if
condition|(
name|ch
operator|==
literal|' '
condition|)
return|return
name|acc
operator|->
name|accchar
return|;
comment|/* scan the accent map */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ACCENTCHARS
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|acc
operator|->
name|map
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|0
condition|)
comment|/* end of table */
break|break;
if|if
condition|(
name|acc
operator|->
name|map
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
name|ch
condition|)
return|return
name|acc
operator|->
name|map
index|[
name|i
index|]
index|[
literal|1
index|]
return|;
block|}
comment|/* this char cannot be accented... */
return|return
name|ERRKEY
return|;
block|}
end_function

begin_function
name|int
name|genkbd_keyaction
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|int
name|keycode
parameter_list|,
name|int
name|up
parameter_list|,
name|int
modifier|*
name|shiftstate
parameter_list|,
name|int
modifier|*
name|accents
parameter_list|)
block|{
name|struct
name|keyent_t
modifier|*
name|key
decl_stmt|;
name|int
name|state
init|=
operator|*
name|shiftstate
decl_stmt|;
name|int
name|action
decl_stmt|;
name|int
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
name|f
operator|=
name|state
operator|&
operator|(
name|AGRS
operator||
name|ALKED
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|==
name|AGRS1
operator|)
operator|||
operator|(
name|f
operator|==
name|AGRS2
operator|)
operator|||
operator|(
name|f
operator|==
name|ALKED
operator|)
condition|)
name|keycode
operator|+=
name|ALTGR_OFFSET
expr_stmt|;
name|key
operator|=
operator|&
name|kbd
operator|->
name|kb_keymap
operator|->
name|key
index|[
name|keycode
index|]
expr_stmt|;
name|i
operator|=
operator|(
operator|(
name|state
operator|&
name|SHIFTS
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|state
operator|&
name|CTLS
operator|)
condition|?
literal|2
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|state
operator|&
name|ALTS
operator|)
condition|?
literal|4
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|key
operator|->
name|flgs
operator|&
name|FLAG_LOCK_C
operator|)
operator|&&
operator|(
name|state
operator|&
name|CLKED
operator|)
operator|)
operator|||
operator|(
operator|(
name|key
operator|->
name|flgs
operator|&
name|FLAG_LOCK_N
operator|)
operator|&&
operator|(
name|state
operator|&
name|NLKED
operator|)
operator|)
condition|)
name|i
operator|^=
literal|1
expr_stmt|;
name|action
operator|=
name|key
operator|->
name|map
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|up
condition|)
block|{
comment|/* break: key released */
if|if
condition|(
name|key
operator|->
name|spcl
operator|&
operator|(
literal|0x80
operator|>>
name|i
operator|)
condition|)
block|{
comment|/* special keys */
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|LSH
case|:
name|state
operator|&=
operator|~
name|SHIFTS1
expr_stmt|;
break|break;
case|case
name|RSH
case|:
name|state
operator|&=
operator|~
name|SHIFTS2
expr_stmt|;
break|break;
case|case
name|LCTR
case|:
name|state
operator|&=
operator|~
name|CTLS1
expr_stmt|;
break|break;
case|case
name|RCTR
case|:
name|state
operator|&=
operator|~
name|CTLS2
expr_stmt|;
break|break;
case|case
name|LALT
case|:
name|state
operator|&=
operator|~
name|ALTS1
expr_stmt|;
break|break;
case|case
name|RALT
case|:
name|state
operator|&=
operator|~
name|ALTS2
expr_stmt|;
break|break;
case|case
name|ASH
case|:
name|state
operator|&=
operator|~
name|AGRS1
expr_stmt|;
break|break;
case|case
name|META
case|:
name|state
operator|&=
operator|~
name|METAS1
expr_stmt|;
break|break;
case|case
name|NLK
case|:
name|state
operator|&=
operator|~
name|NLKDOWN
expr_stmt|;
break|break;
case|case
name|CLK
case|:
ifndef|#
directive|ifndef
name|PC98
name|state
operator|&=
operator|~
name|CLKDOWN
expr_stmt|;
else|#
directive|else
name|state
operator|&=
operator|~
name|CLKED
expr_stmt|;
name|i
operator|=
name|state
operator|&
name|LOCK_MASK
expr_stmt|;
operator|(
operator|*
name|kbdsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|->
name|ioctl
operator|)
operator|(
name|kbd
operator|,
name|KDSETLED
operator|,
operator|(
name|caddr_t
operator|)
operator|&
name|i
operator|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SLK
case|:
name|state
operator|&=
operator|~
name|SLKDOWN
expr_stmt|;
break|break;
case|case
name|ALK
case|:
name|state
operator|&=
operator|~
name|ALKDOWN
expr_stmt|;
break|break;
block|}
operator|*
name|shiftstate
operator|=
name|state
expr_stmt|;
return|return
operator|(
name|SPCLKEY
operator||
name|RELKEY
operator||
name|action
operator|)
return|;
block|}
comment|/* release events of regular keys are not reported */
return|return
name|NOKEY
return|;
block|}
else|else
block|{
comment|/* make: key pressed */
if|if
condition|(
name|key
operator|->
name|spcl
operator|&
operator|(
literal|0x80
operator|>>
name|i
operator|)
condition|)
block|{
comment|/* special keys */
switch|switch
condition|(
name|action
condition|)
block|{
comment|/* LOCKING KEYS */
case|case
name|NLK
case|:
name|set_lockkey_state
argument_list|(
name|kbd
argument_list|,
name|state
argument_list|,
name|NLK
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLK
case|:
ifndef|#
directive|ifndef
name|PC98
name|set_lockkey_state
argument_list|(
name|kbd
argument_list|,
name|state
argument_list|,
name|CLK
argument_list|)
expr_stmt|;
else|#
directive|else
name|state
operator||=
name|CLKED
expr_stmt|;
name|i
operator|=
name|state
operator|&
name|LOCK_MASK
expr_stmt|;
operator|(
operator|*
name|kbdsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|->
name|ioctl
operator|)
operator|(
name|kbd
operator|,
name|KDSETLED
operator|,
operator|(
name|caddr_t
operator|)
operator|&
name|i
operator|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SLK
case|:
name|set_lockkey_state
argument_list|(
name|kbd
argument_list|,
name|state
argument_list|,
name|SLK
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALK
case|:
name|set_lockkey_state
argument_list|(
name|kbd
argument_list|,
name|state
argument_list|,
name|ALK
argument_list|)
expr_stmt|;
break|break;
comment|/* NON-LOCKING KEYS */
case|case
name|SPSC
case|:
case|case
name|RBT
case|:
case|case
name|SUSP
case|:
case|case
name|STBY
case|:
case|case
name|DBG
case|:
case|case
name|NEXT
case|:
operator|*
name|accents
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BTAB
case|:
operator|*
name|accents
operator|=
literal|0
expr_stmt|;
name|action
operator||=
name|BKEY
expr_stmt|;
break|break;
case|case
name|LSH
case|:
name|state
operator||=
name|SHIFTS1
expr_stmt|;
break|break;
case|case
name|RSH
case|:
name|state
operator||=
name|SHIFTS2
expr_stmt|;
break|break;
case|case
name|LCTR
case|:
name|state
operator||=
name|CTLS1
expr_stmt|;
break|break;
case|case
name|RCTR
case|:
name|state
operator||=
name|CTLS2
expr_stmt|;
break|break;
case|case
name|LALT
case|:
name|state
operator||=
name|ALTS1
expr_stmt|;
break|break;
case|case
name|RALT
case|:
name|state
operator||=
name|ALTS2
expr_stmt|;
break|break;
case|case
name|ASH
case|:
name|state
operator||=
name|AGRS1
expr_stmt|;
break|break;
case|case
name|META
case|:
name|state
operator||=
name|METAS1
expr_stmt|;
break|break;
default|default:
comment|/* is this an accent (dead) key? */
if|if
condition|(
name|action
operator|>=
name|F_ACC
operator|&&
name|action
operator|<=
name|L_ACC
condition|)
block|{
name|action
operator|=
name|save_accent_key
argument_list|(
name|kbd
argument_list|,
name|action
argument_list|,
name|accents
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|NOKEY
case|:
case|case
name|ERRKEY
case|:
return|return
name|action
return|;
default|default:
if|if
condition|(
name|state
operator|&
name|METAS
condition|)
return|return
operator|(
name|action
operator||
name|MKEY
operator|)
return|;
else|else
return|return
name|action
return|;
block|}
comment|/* NOT REACHED */
block|}
comment|/* other special keys */
if|if
condition|(
operator|*
name|accents
operator|>
literal|0
condition|)
block|{
operator|*
name|accents
operator|=
literal|0
expr_stmt|;
return|return
name|ERRKEY
return|;
block|}
if|if
condition|(
name|action
operator|>=
name|F_FN
operator|&&
name|action
operator|<=
name|L_FN
condition|)
name|action
operator||=
name|FKEY
expr_stmt|;
comment|/* XXX: return fkey string for the FKEY? */
block|}
operator|*
name|shiftstate
operator|=
name|state
expr_stmt|;
return|return
operator|(
name|SPCLKEY
operator||
name|action
operator|)
return|;
block|}
else|else
block|{
comment|/* regular keys */
if|if
condition|(
operator|*
name|accents
operator|>
literal|0
condition|)
block|{
comment|/* make an accented char */
name|action
operator|=
name|make_accent_char
argument_list|(
name|kbd
argument_list|,
name|action
argument_list|,
name|accents
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|ERRKEY
condition|)
return|return
name|action
return|;
block|}
if|if
condition|(
name|state
operator|&
name|METAS
condition|)
name|action
operator||=
name|MKEY
expr_stmt|;
return|return
name|action
return|;
block|}
block|}
comment|/* NOT REACHED */
block|}
end_function

end_unit

