begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Luoqi Chen.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<dev/aic/aic6360reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/aic/aicvar.h>
end_include

begin_function_decl
specifier|static
name|void
name|aic_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aic_execute_scb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aic_start
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aic_select
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aic_selected
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aic_reselected
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aic_reconnect
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|,
name|int
name|tag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aic_cmd
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aic_msgin
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aic_handle_msgin
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aic_msgout
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aic_datain
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aic_dataout
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aic_done
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|,
name|struct
name|aic_scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aic_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aic_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aic_scsi_reset
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aic_chip_reset
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aic_reset
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|,
name|int
name|initiate_reset
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|devclass_t
name|aic_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|aic_scb
modifier|*
name|free_scbs
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|aic_scb
modifier|*
name|aic_get_scb
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
block|{
name|struct
name|aic_scb
modifier|*
name|scb
decl_stmt|;
name|int
name|s
init|=
name|splcam
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|scb
operator|=
name|free_scbs
operator|)
operator|!=
name|NULL
condition|)
name|free_scbs
operator|=
operator|(
expr|struct
name|aic_scb
operator|*
operator|)
name|free_scbs
operator|->
name|ccb
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|scb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|aic_free_scb
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|,
name|struct
name|aic_scb
modifier|*
name|scb
parameter_list|)
block|{
name|int
name|s
init|=
name|splcam
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|aic
operator|->
name|flags
operator|&
name|AIC_RESOURCE_SHORTAGE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_RELEASE_SIMQ
operator|)
operator|==
literal|0
condition|)
block|{
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|aic
operator|->
name|flags
operator|&=
operator|~
name|AIC_RESOURCE_SHORTAGE
expr_stmt|;
block|}
name|scb
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|free_scbs
expr_stmt|;
name|free_scbs
operator|=
name|scb
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aic_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|aic_softc
modifier|*
name|aic
decl_stmt|;
name|int
name|s
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"aic_action\n"
operator|)
argument_list|)
expr_stmt|;
name|aic
operator|=
operator|(
expr|struct
name|aic_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
comment|/* Execute the requested I/O operation */
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
block|{
name|struct
name|aic_scb
modifier|*
name|scb
decl_stmt|;
if|if
condition|(
operator|(
name|scb
operator|=
name|aic_get_scb
argument_list|(
name|aic
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|aic
operator|->
name|flags
operator||=
name|AIC_RESOURCE_SHORTAGE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|aic
operator|->
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|scb
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_scb_ptr
operator|=
name|scb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_aic_ptr
operator|=
name|aic
expr_stmt|;
name|scb
operator|->
name|target
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|scb
operator|->
name|lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
name|scb
operator|->
name|cmd_len
operator|=
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_PHYS
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|aic_free_scb
argument_list|(
name|aic
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|scb
operator|->
name|cmd_ptr
operator|=
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_ptr
expr_stmt|;
block|}
else|else
block|{
name|scb
operator|->
name|cmd_ptr
operator|=
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|||
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|aic_free_scb
argument_list|(
name|aic
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|scb
operator|->
name|data_ptr
operator|=
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|scb
operator|->
name|data_len
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
block|}
else|else
block|{
name|scb
operator|->
name|data_ptr
operator|=
name|NULL
expr_stmt|;
name|scb
operator|->
name|data_len
operator|=
literal|0
expr_stmt|;
block|}
name|aic_execute_scb
argument_list|(
name|scb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scb
operator|->
name|flags
operator||=
name|SCB_DEVICE_RESET
expr_stmt|;
name|aic_execute_scb
argument_list|(
name|scb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|struct
name|aic_tinfo
modifier|*
name|ti
init|=
operator|&
name|aic
operator|->
name|tinfo
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_DISC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|aic
operator|->
name|flags
operator|&
name|AIC_DISC_ENABLE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|spi
operator|->
name|flags
operator|&
name|CTS_SPI_FLAGS_DISC_ENB
operator|)
operator|!=
literal|0
condition|)
name|ti
operator|->
name|flags
operator||=
name|TINFO_DISC_ENB
expr_stmt|;
else|else
name|ti
operator|->
name|flags
operator|&=
operator|~
name|TINFO_DISC_ENB
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scsi
operator|->
name|valid
operator|&
name|CTS_SCSI_VALID_TQ
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
operator|)
operator|!=
literal|0
condition|)
name|ti
operator|->
name|flags
operator||=
name|TINFO_TAG_ENB
expr_stmt|;
else|else
name|ti
operator|->
name|flags
operator|&=
operator|~
name|TINFO_TAG_ENB
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|!=
literal|0
condition|)
block|{
name|ti
operator|->
name|goal
operator|.
name|period
operator|=
name|spi
operator|->
name|sync_period
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|goal
operator|.
name|period
operator|>
name|aic
operator|->
name|min_period
condition|)
block|{
name|ti
operator|->
name|goal
operator|.
name|period
operator|=
literal|0
expr_stmt|;
name|ti
operator|->
name|goal
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ti
operator|->
name|goal
operator|.
name|period
operator|<
name|aic
operator|->
name|max_period
condition|)
name|ti
operator|->
name|goal
operator|.
name|period
operator|=
name|aic
operator|->
name|max_period
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|!=
literal|0
condition|)
block|{
name|ti
operator|->
name|goal
operator|.
name|offset
operator|=
name|spi
operator|->
name|sync_offset
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|goal
operator|.
name|offset
operator|==
literal|0
condition|)
name|ti
operator|->
name|goal
operator|.
name|period
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ti
operator|->
name|goal
operator|.
name|offset
operator|>
name|AIC_SYNC_OFFSET
condition|)
name|ti
operator|->
name|goal
operator|.
name|offset
operator|=
name|AIC_SYNC_OFFSET
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ti
operator|->
name|goal
operator|.
name|period
operator|!=
name|ti
operator|->
name|current
operator|.
name|period
operator|)
operator|||
operator|(
name|ti
operator|->
name|goal
operator|.
name|offset
operator|!=
name|ti
operator|->
name|current
operator|.
name|offset
operator|)
condition|)
name|ti
operator|->
name|flags
operator||=
name|TINFO_SDTR_NEGO
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|struct
name|aic_tinfo
modifier|*
name|ti
init|=
operator|&
name|aic
operator|->
name|tinfo
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
decl_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|scsi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|spi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ti
operator|->
name|flags
operator|&
name|TINFO_DISC_ENB
operator|)
operator|!=
literal|0
condition|)
name|spi
operator|->
name|flags
operator||=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|ti
operator|->
name|flags
operator|&
name|TINFO_TAG_ENB
operator|)
operator|!=
literal|0
condition|)
name|scsi
operator|->
name|flags
operator||=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
block|{
name|spi
operator|->
name|sync_period
operator|=
name|ti
operator|->
name|current
operator|.
name|period
expr_stmt|;
name|spi
operator|->
name|sync_offset
operator|=
name|ti
operator|->
name|current
operator|.
name|offset
expr_stmt|;
block|}
else|else
block|{
name|spi
operator|->
name|sync_period
operator|=
name|ti
operator|->
name|user
operator|.
name|period
expr_stmt|;
name|spi
operator|->
name|sync_offset
operator|=
name|ti
operator|->
name|user
operator|.
name|offset
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|spi
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
operator||
name|CTS_SPI_VALID_BUS_WIDTH
operator||
name|CTS_SPI_VALID_DISC
expr_stmt|;
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|cam_calc_geometry
argument_list|(
operator|&
name|ccb
operator|->
name|ccg
argument_list|,
comment|/*extended*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
name|aic_reset
argument_list|(
name|aic
argument_list|,
comment|/*initiate_reset*/
name|TRUE
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
literal|7
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|7
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|aic
operator|->
name|initiator
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"Adaptec"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|aic_execute_scb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|aic_scb
modifier|*
name|scb
init|=
operator|(
expr|struct
name|aic_scb
operator|*
operator|)
name|arg
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|scb
operator|->
name|ccb
decl_stmt|;
name|struct
name|aic_softc
modifier|*
name|aic
init|=
operator|(
expr|struct
name|aic_softc
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_aic_ptr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|aic_free_scb
argument_list|(
name|aic
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|scb
operator|->
name|flags
operator||=
name|SCB_ACTIVE
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|aic
operator|->
name|pending_ccbs
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|aic_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|aic_start
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start another command if the controller is not busy.  */
end_comment

begin_function
specifier|static
name|void
name|aic_start
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|struct
name|aic_tinfo
modifier|*
name|ti
decl_stmt|;
if|if
condition|(
name|aic
operator|->
name|state
operator|!=
name|AIC_IDLE
condition|)
return|return;
name|TAILQ_FOREACH
argument_list|(
argument|ccb_h
argument_list|,
argument|&aic->pending_ccbs
argument_list|,
argument|sim_links.tqe
argument_list|)
block|{
name|ti
operator|=
operator|&
name|aic
operator|->
name|tinfo
index|[
name|ccb_h
operator|->
name|target_id
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ti
operator|->
name|lubusy
operator|&
operator|(
literal|1
operator|<<
name|ccb_h
operator|->
name|target_lun
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aic
operator|->
name|pending_ccbs
argument_list|,
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|aic
operator|->
name|nexus
operator|=
operator|(
expr|struct
name|aic_scb
operator|*
operator|)
name|ccb_h
operator|->
name|ccb_scb_ptr
expr_stmt|;
name|aic_select
argument_list|(
name|aic
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"aic_start: idle\n"
operator|)
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SIMODE0
argument_list|,
name|ENSELDI
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SIMODE1
argument_list|,
name|ENSCSIRST
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SCSISEQ
argument_list|,
name|ENRESELI
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start a selection.  */
end_comment

begin_function
specifier|static
name|void
name|aic_select
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
block|{
name|struct
name|aic_scb
modifier|*
name|scb
init|=
name|aic
operator|->
name|nexus
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"aic_select - ccb %p\n"
operator|,
name|scb
operator|->
name|ccb
operator|)
argument_list|)
expr_stmt|;
name|aic
operator|->
name|state
operator|=
name|AIC_SELECTING
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SCSIID
argument_list|,
name|aic
operator|->
name|initiator
operator|<<
name|OID_S
operator||
name|scb
operator|->
name|target
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SXFRCTL1
argument_list|,
name|STIMO_256ms
operator||
name|ENSTIMER
operator||
operator|(
name|aic
operator|->
name|flags
operator|&
name|AIC_PARITY_ENABLE
condition|?
name|ENSPCHK
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SIMODE0
argument_list|,
name|ENSELDI
operator||
name|ENSELDO
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENSELTIMO
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SCSISEQ
argument_list|,
name|ENRESELI
operator||
name|ENSELO
operator||
name|ENAUTOATNO
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We have successfully selected a target, prepare for the information  * transfer phases.  */
end_comment

begin_function
specifier|static
name|void
name|aic_selected
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
block|{
name|struct
name|aic_scb
modifier|*
name|scb
init|=
name|aic
operator|->
name|nexus
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|scb
operator|->
name|ccb
decl_stmt|;
name|struct
name|aic_tinfo
modifier|*
name|ti
init|=
operator|&
name|aic
operator|->
name|tinfo
index|[
name|scb
operator|->
name|target
index|]
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"aic_selected - ccb %p\n"
operator|,
name|ccb
operator|)
argument_list|)
expr_stmt|;
name|aic
operator|->
name|state
operator|=
name|AIC_HASNEXUS
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_DEVICE_RESET
condition|)
block|{
name|aic
operator|->
name|msg_buf
index|[
literal|0
index|]
operator|=
name|MSG_BUS_DEV_RESET
expr_stmt|;
name|aic
operator|->
name|msg_len
operator|=
literal|1
expr_stmt|;
name|aic
operator|->
name|msg_outq
operator|=
name|AIC_MSG_MSGBUF
expr_stmt|;
block|}
else|else
block|{
name|aic
operator|->
name|msg_outq
operator|=
name|AIC_MSG_IDENTIFY
expr_stmt|;
if|if
condition|(
operator|(
name|ti
operator|->
name|flags
operator|&
name|TINFO_TAG_ENB
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
operator|!=
literal|0
condition|)
name|aic
operator|->
name|msg_outq
operator||=
name|AIC_MSG_TAG_Q
expr_stmt|;
else|else
name|ti
operator|->
name|lubusy
operator||=
literal|1
operator|<<
name|scb
operator|->
name|lun
expr_stmt|;
if|if
condition|(
operator|(
name|ti
operator|->
name|flags
operator|&
name|TINFO_SDTR_NEGO
operator|)
operator|!=
literal|0
condition|)
name|aic
operator|->
name|msg_outq
operator||=
name|AIC_MSG_SDTR
expr_stmt|;
block|}
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|CLRSINT0
argument_list|,
name|CLRSELDO
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRBUSFREE
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SCSISEQ
argument_list|,
name|ENAUTOATNP
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SIMODE0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SCSIRATE
argument_list|,
name|ti
operator|->
name|scsirate
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We are re-selected by a target, save the target id and wait for the  * target to further identify itself.  */
end_comment

begin_function
specifier|static
name|void
name|aic_reselected
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
block|{
name|u_int8_t
name|selid
decl_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"aic_reselected\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we have started a selection, it must have lost out in 	 * the arbitration, put the command back to the pending queue. 	 */
if|if
condition|(
name|aic
operator|->
name|nexus
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aic
operator|->
name|pending_ccbs
argument_list|,
operator|&
name|aic
operator|->
name|nexus
operator|->
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|aic
operator|->
name|nexus
operator|=
name|NULL
expr_stmt|;
block|}
name|selid
operator|=
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|SELID
argument_list|)
operator|&
operator|~
operator|(
literal|1
operator|<<
name|aic
operator|->
name|initiator
operator|)
expr_stmt|;
if|if
condition|(
name|selid
operator|&
operator|(
name|selid
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* this should never have happened */
name|printf
argument_list|(
literal|"aic_reselected: invalid selid %x\n"
argument_list|,
name|selid
argument_list|)
expr_stmt|;
name|aic_reset
argument_list|(
name|aic
argument_list|,
comment|/*initiate_reset*/
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|aic
operator|->
name|state
operator|=
name|AIC_RESELECTED
expr_stmt|;
name|aic
operator|->
name|target
operator|=
name|ffs
argument_list|(
name|selid
argument_list|)
operator|-
literal|1
expr_stmt|;
name|aic
operator|->
name|lun
operator|=
operator|-
literal|1
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|CLRSINT0
argument_list|,
name|CLRSELDI
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRBUSFREE
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SIMODE0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SCSISEQ
argument_list|,
name|ENAUTOATNP
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SCSIRATE
argument_list|,
name|aic
operator|->
name|tinfo
index|[
name|aic
operator|->
name|target
index|]
operator|.
name|scsirate
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Raise ATNO to signal the target that we have a message for it.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|aic_sched_msgout
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|,
name|u_int8_t
name|msg
parameter_list|)
block|{
if|if
condition|(
name|msg
condition|)
block|{
name|aic
operator|->
name|msg_buf
index|[
literal|0
index|]
operator|=
name|msg
expr_stmt|;
name|aic
operator|->
name|msg_len
operator|=
literal|1
expr_stmt|;
block|}
name|aic
operator|->
name|msg_outq
operator||=
name|AIC_MSG_MSGBUF
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SCSISIGO
argument_list|,
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|SCSISIGI
argument_list|)
operator||
name|ATNO
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait for SPIORDY (SCSI PIO ready) flag, or a phase change.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|aic_spiordy
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
block|{
while|while
condition|(
operator|!
operator|(
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|DMASTAT
argument_list|)
operator|&
name|INTSTAT
operator|)
operator|&&
operator|!
operator|(
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|SSTAT0
argument_list|)
operator|&
name|SPIORDY
operator|)
condition|)
empty_stmt|;
return|return
operator|!
operator|(
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|DMASTAT
argument_list|)
operator|&
name|INTSTAT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reestablish a disconnected nexus.  */
end_comment

begin_function
specifier|static
name|void
name|aic_reconnect
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|struct
name|aic_scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"aic_reconnect\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Find the nexus */
name|scb
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ccb_h
argument_list|,
argument|&aic->nexus_ccbs
argument_list|,
argument|sim_links.tqe
argument_list|)
block|{
name|scb
operator|=
operator|(
expr|struct
name|aic_scb
operator|*
operator|)
name|ccb_h
operator|->
name|ccb_scb_ptr
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|target
operator|==
name|aic
operator|->
name|target
operator|&&
name|scb
operator|->
name|lun
operator|==
name|aic
operator|->
name|lun
operator|&&
operator|(
name|tag
operator|==
operator|-
literal|1
operator|||
name|scb
operator|->
name|tag
operator|==
name|tag
operator|)
condition|)
break|break;
block|}
comment|/* ABORT if nothing is found */
if|if
condition|(
operator|!
name|ccb_h
condition|)
block|{
if|if
condition|(
name|tag
operator|==
operator|-
literal|1
condition|)
name|aic_sched_msgout
argument_list|(
name|aic
argument_list|,
name|MSG_ABORT
argument_list|)
expr_stmt|;
else|else
name|aic_sched_msgout
argument_list|(
name|aic
argument_list|,
name|MSG_ABORT_TAG
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_UNSOL_RESEL
argument_list|,
name|aic
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Reestablish the nexus */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aic
operator|->
name|nexus_ccbs
argument_list|,
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|aic
operator|->
name|nexus
operator|=
name|scb
expr_stmt|;
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_DISCONNECTED
expr_stmt|;
name|aic
operator|->
name|state
operator|=
name|AIC_HASNEXUS
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read messages.  */
end_comment

begin_function
specifier|static
name|void
name|aic_msgin
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
block|{
name|int
name|msglen
decl_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"aic_msgin\n"
operator|)
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENPHASEMIS
operator||
name|ENBUSFREE
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SXFRCTL0
argument_list|,
name|CHEN
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
name|aic
operator|->
name|flags
operator|&=
operator|~
name|AIC_DROP_MSGIN
expr_stmt|;
name|aic
operator|->
name|msg_len
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* 		 * If a parity error is detected, drop the remaining 		 * bytes and inform the target so it could resend 		 * the messages. 		 */
if|if
condition|(
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|SSTAT1
argument_list|)
operator|&
name|SCSIPERR
condition|)
block|{
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSCSIPERR
argument_list|)
expr_stmt|;
name|aic
operator|->
name|flags
operator||=
name|AIC_DROP_MSGIN
expr_stmt|;
name|aic_sched_msgout
argument_list|(
name|aic
argument_list|,
name|MSG_PARITY_ERROR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|aic
operator|->
name|flags
operator|&
name|AIC_DROP_MSGIN
operator|)
condition|)
block|{
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|SCSIDAT
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* read the message byte without ACKing on it */
name|aic
operator|->
name|msg_buf
index|[
name|aic
operator|->
name|msg_len
operator|++
index|]
operator|=
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|SCSIBUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|msg_buf
index|[
literal|0
index|]
operator|==
name|MSG_EXTENDED
condition|)
block|{
if|if
condition|(
name|aic
operator|->
name|msg_len
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|SCSIDAT
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|aic
operator|->
name|msg_buf
index|[
literal|2
index|]
condition|)
block|{
case|case
name|MSG_EXT_SDTR
case|:
name|msglen
operator|=
name|MSG_EXT_SDTR_LEN
expr_stmt|;
break|break;
case|case
name|MSG_EXT_WDTR
case|:
name|msglen
operator|=
name|MSG_EXT_WDTR_LEN
expr_stmt|;
break|break;
default|default:
name|msglen
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|aic
operator|->
name|msg_buf
index|[
literal|1
index|]
operator|!=
name|msglen
condition|)
block|{
name|aic
operator|->
name|flags
operator||=
name|AIC_DROP_MSGIN
expr_stmt|;
name|aic_sched_msgout
argument_list|(
name|aic
argument_list|,
name|MSG_MESSAGE_REJECT
argument_list|)
expr_stmt|;
block|}
name|msglen
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aic
operator|->
name|msg_buf
index|[
literal|0
index|]
operator|>=
literal|0x20
operator|&&
name|aic
operator|->
name|msg_buf
index|[
literal|0
index|]
operator|<=
literal|0x2f
condition|)
name|msglen
operator|=
literal|2
expr_stmt|;
else|else
name|msglen
operator|=
literal|1
expr_stmt|;
comment|/* 		 * If we have a complete message, handle it before the final 		 * ACK (in case we decide to reject the message). 		 */
if|if
condition|(
name|aic
operator|->
name|msg_len
operator|==
name|msglen
condition|)
block|{
name|aic_handle_msgin
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|aic
operator|->
name|msg_len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* ACK on the message byte */
operator|(
name|void
operator|)
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|SCSIDAT
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|aic_spiordy
argument_list|(
name|aic
argument_list|)
condition|)
do|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SXFRCTL0
argument_list|,
name|CHEN
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a message.  */
end_comment

begin_function
specifier|static
name|void
name|aic_handle_msgin
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
block|{
name|struct
name|aic_scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|struct
name|aic_tinfo
modifier|*
name|ti
decl_stmt|;
name|struct
name|ccb_trans_settings
name|neg
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|neg
operator|.
name|xport_specific
operator|.
name|spi
decl_stmt|;
if|if
condition|(
name|aic
operator|->
name|state
operator|==
name|AIC_RESELECTED
condition|)
block|{
if|if
condition|(
operator|!
name|MSG_ISIDENTIFY
argument_list|(
name|aic
operator|->
name|msg_buf
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|aic_sched_msgout
argument_list|(
name|aic
argument_list|,
name|MSG_MESSAGE_REJECT
argument_list|)
expr_stmt|;
return|return;
block|}
name|aic
operator|->
name|lun
operator|=
name|aic
operator|->
name|msg_buf
index|[
literal|0
index|]
operator|&
name|MSG_IDENTIFY_LUNMASK
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|tinfo
index|[
name|aic
operator|->
name|target
index|]
operator|.
name|lubusy
operator|&
operator|(
literal|1
operator|<<
name|aic
operator|->
name|lun
operator|)
condition|)
name|aic_reconnect
argument_list|(
name|aic
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|aic
operator|->
name|state
operator|=
name|AIC_RECONNECTING
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|aic
operator|->
name|state
operator|==
name|AIC_RECONNECTING
condition|)
block|{
if|if
condition|(
name|aic
operator|->
name|msg_buf
index|[
literal|0
index|]
operator|!=
name|MSG_SIMPLE_Q_TAG
condition|)
block|{
name|aic_sched_msgout
argument_list|(
name|aic
argument_list|,
name|MSG_MESSAGE_REJECT
argument_list|)
expr_stmt|;
return|return;
block|}
name|aic_reconnect
argument_list|(
name|aic
argument_list|,
name|aic
operator|->
name|msg_buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|aic
operator|->
name|msg_buf
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MSG_CMDCOMPLETE
case|:
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|scb
operator|=
name|aic
operator|->
name|nexus
expr_stmt|;
name|ccb_h
operator|=
operator|&
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
expr_stmt|;
name|csio
operator|=
operator|&
name|scb
operator|->
name|ccb
operator|->
name|csio
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* auto REQUEST SENSE command */
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_SENSE
expr_stmt|;
name|csio
operator|->
name|sense_resid
operator|=
name|scb
operator|->
name|data_len
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|status
operator|==
name|SCSI_STATUS_OK
condition|)
block|{
name|ccb_h
operator|->
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
operator||
name|CAM_AUTOSNS_VALID
expr_stmt|;
comment|/*scsi_sense_print(csio);*/
block|}
else|else
block|{
name|ccb_h
operator|->
name|status
operator||=
name|CAM_AUTOSENSE_FAIL
expr_stmt|;
name|printf
argument_list|(
literal|"ccb %p sense failed %x\n"
argument_list|,
name|ccb_h
argument_list|,
name|scb
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|csio
operator|->
name|scsi_status
operator|=
name|scb
operator|->
name|status
expr_stmt|;
name|csio
operator|->
name|resid
operator|=
name|scb
operator|->
name|data_len
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|status
operator|==
name|SCSI_STATUS_OK
condition|)
block|{
comment|/* everything goes well */
name|ccb_h
operator|->
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIS_AUTOSENSE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|csio
operator|->
name|scsi_status
operator|==
name|SCSI_STATUS_CHECK_COND
operator|||
name|csio
operator|->
name|scsi_status
operator|==
name|SCSI_STATUS_CMD_TERMINATED
operator|)
condition|)
block|{
comment|/* try to retrieve sense information */
name|scb
operator|->
name|flags
operator||=
name|SCB_SENSE
expr_stmt|;
name|aic
operator|->
name|flags
operator||=
name|AIC_BUSFREE_OK
expr_stmt|;
return|return;
block|}
else|else
name|ccb_h
operator|->
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
block|}
name|aic_done
argument_list|(
name|aic
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|aic
operator|->
name|flags
operator||=
name|AIC_BUSFREE_OK
expr_stmt|;
break|break;
block|}
case|case
name|MSG_EXTENDED
case|:
switch|switch
condition|(
name|aic
operator|->
name|msg_buf
index|[
literal|2
index|]
condition|)
block|{
case|case
name|MSG_EXT_SDTR
case|:
name|scb
operator|=
name|aic
operator|->
name|nexus
expr_stmt|;
name|ti
operator|=
operator|&
name|aic
operator|->
name|tinfo
index|[
name|scb
operator|->
name|target
index|]
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|flags
operator|&
name|TINFO_SDTR_SENT
condition|)
block|{
name|ti
operator|->
name|current
operator|.
name|period
operator|=
name|aic
operator|->
name|msg_buf
index|[
literal|3
index|]
expr_stmt|;
name|ti
operator|->
name|current
operator|.
name|offset
operator|=
name|aic
operator|->
name|msg_buf
index|[
literal|4
index|]
expr_stmt|;
block|}
else|else
block|{
name|ti
operator|->
name|current
operator|.
name|period
operator|=
name|aic
operator|->
name|msg_buf
index|[
literal|3
index|]
operator|=
name|max
argument_list|(
name|ti
operator|->
name|goal
operator|.
name|period
argument_list|,
name|aic
operator|->
name|msg_buf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|ti
operator|->
name|current
operator|.
name|offset
operator|=
name|aic
operator|->
name|msg_buf
index|[
literal|4
index|]
operator|=
name|min
argument_list|(
name|ti
operator|->
name|goal
operator|.
name|offset
argument_list|,
name|aic
operator|->
name|msg_buf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* 				 * The target initiated the negotiation, 				 * send back a response. 				 */
name|aic_sched_msgout
argument_list|(
name|aic
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ti
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TINFO_SDTR_SENT
operator||
name|TINFO_SDTR_NEGO
operator|)
expr_stmt|;
name|ti
operator|->
name|scsirate
operator|=
name|ti
operator|->
name|current
operator|.
name|offset
condition|?
name|ti
operator|->
name|current
operator|.
name|offset
operator||
operator|(
operator|(
name|ti
operator|->
name|current
operator|.
name|period
operator|*
literal|4
operator|+
literal|49
operator|)
operator|/
literal|50
operator|-
literal|2
operator|)
operator|<<
literal|4
else|:
literal|0
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SCSIRATE
argument_list|,
name|ti
operator|->
name|scsirate
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|neg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|neg
argument_list|)
argument_list|)
expr_stmt|;
name|neg
operator|.
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|neg
operator|.
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|neg
operator|.
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|neg
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|spi
operator|->
name|sync_period
operator|=
name|ti
operator|->
name|goal
operator|.
name|period
operator|=
name|ti
operator|->
name|current
operator|.
name|period
expr_stmt|;
name|spi
operator|->
name|sync_offset
operator|=
name|ti
operator|->
name|goal
operator|.
name|offset
operator|=
name|ti
operator|->
name|current
operator|.
name|offset
expr_stmt|;
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
expr_stmt|;
name|ccb_h
operator|=
operator|&
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|neg
operator|.
name|ccb_h
argument_list|,
name|ccb_h
operator|->
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_TRANSFER_NEG
argument_list|,
name|ccb_h
operator|->
name|path
argument_list|,
operator|&
name|neg
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_EXT_WDTR
case|:
default|default:
name|aic_sched_msgout
argument_list|(
name|aic
argument_list|,
name|MSG_MESSAGE_REJECT
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|MSG_DISCONNECT
case|:
name|scb
operator|=
name|aic
operator|->
name|nexus
expr_stmt|;
name|ccb_h
operator|=
operator|&
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|aic
operator|->
name|nexus_ccbs
argument_list|,
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_DISCONNECTED
expr_stmt|;
name|aic
operator|->
name|flags
operator||=
name|AIC_BUSFREE_OK
expr_stmt|;
name|aic
operator|->
name|nexus
operator|=
name|NULL
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb_h
operator|->
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"disconnected\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_MESSAGE_REJECT
case|:
switch|switch
condition|(
name|aic
operator|->
name|msg_outq
operator|&
operator|-
name|aic
operator|->
name|msg_outq
condition|)
block|{
case|case
name|AIC_MSG_TAG_Q
case|:
name|scb
operator|=
name|aic
operator|->
name|nexus
expr_stmt|;
name|ti
operator|=
operator|&
name|aic
operator|->
name|tinfo
index|[
name|scb
operator|->
name|target
index|]
expr_stmt|;
name|ti
operator|->
name|flags
operator|&=
operator|~
name|TINFO_TAG_ENB
expr_stmt|;
name|ti
operator|->
name|lubusy
operator||=
literal|1
operator|<<
name|scb
operator|->
name|lun
expr_stmt|;
break|break;
case|case
name|AIC_MSG_SDTR
case|:
name|scb
operator|=
name|aic
operator|->
name|nexus
expr_stmt|;
name|ti
operator|=
operator|&
name|aic
operator|->
name|tinfo
index|[
name|scb
operator|->
name|target
index|]
expr_stmt|;
name|ti
operator|->
name|current
operator|.
name|period
operator|=
name|ti
operator|->
name|goal
operator|.
name|period
operator|=
literal|0
expr_stmt|;
name|ti
operator|->
name|current
operator|.
name|offset
operator|=
name|ti
operator|->
name|goal
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|ti
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TINFO_SDTR_SENT
operator||
name|TINFO_SDTR_NEGO
operator|)
expr_stmt|;
name|ti
operator|->
name|scsirate
operator|=
literal|0
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SCSIRATE
argument_list|,
name|ti
operator|->
name|scsirate
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|neg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|neg
argument_list|)
argument_list|)
expr_stmt|;
name|neg
operator|.
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|neg
operator|.
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|neg
operator|.
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|neg
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|spi
operator|->
name|sync_period
operator|=
name|ti
operator|->
name|current
operator|.
name|period
expr_stmt|;
name|spi
operator|->
name|sync_offset
operator|=
name|ti
operator|->
name|current
operator|.
name|offset
expr_stmt|;
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
expr_stmt|;
name|ccb_h
operator|=
operator|&
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|neg
operator|.
name|ccb_h
argument_list|,
name|ccb_h
operator|->
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_TRANSFER_NEG
argument_list|,
name|ccb_h
operator|->
name|path
argument_list|,
operator|&
name|neg
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|MSG_SAVEDATAPOINTER
case|:
break|break;
case|case
name|MSG_RESTOREPOINTERS
case|:
break|break;
case|case
name|MSG_NOOP
case|:
break|break;
default|default:
name|aic_sched_msgout
argument_list|(
name|aic
argument_list|,
name|MSG_MESSAGE_REJECT
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Send messages.  */
end_comment

begin_function
specifier|static
name|void
name|aic_msgout
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
block|{
name|struct
name|aic_scb
modifier|*
name|scb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|aic_tinfo
modifier|*
name|ti
decl_stmt|;
name|int
name|msgidx
init|=
literal|0
decl_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"aic_msgout\n"
operator|)
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENPHASEMIS
operator||
name|ENBUSFREE
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SXFRCTL0
argument_list|,
name|CHEN
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
comment|/* 	 * If the previous phase is also the message out phase, 	 * we need to retransmit all the messages, probably 	 * because the target has detected a parity error during 	 * the past transmission. 	 */
if|if
condition|(
name|aic
operator|->
name|prev_phase
operator|==
name|PH_MSGOUT
condition|)
name|aic
operator|->
name|msg_outq
operator|=
name|aic
operator|->
name|msg_sent
expr_stmt|;
do|do
block|{
name|int
name|q
init|=
name|aic
operator|->
name|msg_outq
decl_stmt|;
if|if
condition|(
name|msgidx
operator|>
literal|0
operator|&&
name|msgidx
operator|==
name|aic
operator|->
name|msg_len
condition|)
block|{
comment|/* complete message sent, start the next one */
name|q
operator|&=
operator|-
name|q
expr_stmt|;
name|aic
operator|->
name|msg_sent
operator||=
name|q
expr_stmt|;
name|aic
operator|->
name|msg_outq
operator|^=
name|q
expr_stmt|;
name|q
operator|=
name|aic
operator|->
name|msg_outq
expr_stmt|;
name|msgidx
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|msgidx
operator|==
literal|0
condition|)
block|{
comment|/* setup the message */
switch|switch
condition|(
name|q
operator|&
operator|-
name|q
condition|)
block|{
case|case
name|AIC_MSG_IDENTIFY
case|:
name|scb
operator|=
name|aic
operator|->
name|nexus
expr_stmt|;
name|ccb
operator|=
name|scb
operator|->
name|ccb
expr_stmt|;
name|ti
operator|=
operator|&
name|aic
operator|->
name|tinfo
index|[
name|scb
operator|->
name|target
index|]
expr_stmt|;
name|aic
operator|->
name|msg_buf
index|[
literal|0
index|]
operator|=
name|MSG_IDENTIFY
argument_list|(
name|scb
operator|->
name|lun
argument_list|,
operator|(
name|ti
operator|->
name|flags
operator|&
name|TINFO_DISC_ENB
operator|)
operator|&&
operator|!
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_DISCONNECT
operator|)
argument_list|)
expr_stmt|;
name|aic
operator|->
name|msg_len
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AIC_MSG_TAG_Q
case|:
name|scb
operator|=
name|aic
operator|->
name|nexus
expr_stmt|;
name|ccb
operator|=
name|scb
operator|->
name|ccb
expr_stmt|;
name|aic
operator|->
name|msg_buf
index|[
literal|0
index|]
operator|=
name|ccb
operator|->
name|csio
operator|.
name|tag_action
expr_stmt|;
name|aic
operator|->
name|msg_buf
index|[
literal|1
index|]
operator|=
name|scb
operator|->
name|tag
expr_stmt|;
name|aic
operator|->
name|msg_len
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|AIC_MSG_SDTR
case|:
name|scb
operator|=
name|aic
operator|->
name|nexus
expr_stmt|;
name|ti
operator|=
operator|&
name|aic
operator|->
name|tinfo
index|[
name|scb
operator|->
name|target
index|]
expr_stmt|;
name|aic
operator|->
name|msg_buf
index|[
literal|0
index|]
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|aic
operator|->
name|msg_buf
index|[
literal|1
index|]
operator|=
name|MSG_EXT_SDTR_LEN
expr_stmt|;
name|aic
operator|->
name|msg_buf
index|[
literal|2
index|]
operator|=
name|MSG_EXT_SDTR
expr_stmt|;
name|aic
operator|->
name|msg_buf
index|[
literal|3
index|]
operator|=
name|ti
operator|->
name|goal
operator|.
name|period
expr_stmt|;
name|aic
operator|->
name|msg_buf
index|[
literal|4
index|]
operator|=
name|ti
operator|->
name|goal
operator|.
name|offset
expr_stmt|;
name|aic
operator|->
name|msg_len
operator|=
name|MSG_EXT_SDTR_LEN
operator|+
literal|2
expr_stmt|;
name|ti
operator|->
name|flags
operator||=
name|TINFO_SDTR_SENT
expr_stmt|;
break|break;
case|case
name|AIC_MSG_MSGBUF
case|:
comment|/* a single message already in the buffer */
if|if
condition|(
name|aic
operator|->
name|msg_buf
index|[
literal|0
index|]
operator|==
name|MSG_BUS_DEV_RESET
operator|||
name|aic
operator|->
name|msg_buf
index|[
literal|0
index|]
operator|==
name|MSG_ABORT
operator|||
name|aic
operator|->
name|msg_buf
index|[
literal|0
index|]
operator|==
name|MSG_ABORT_TAG
condition|)
name|aic
operator|->
name|flags
operator||=
name|AIC_BUSFREE_OK
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * If this is the last message byte of all messages, 		 * clear ATNO to signal transmission complete. 		 */
if|if
condition|(
operator|(
name|q
operator|&
operator|(
name|q
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
name|msgidx
operator|==
name|aic
operator|->
name|msg_len
operator|-
literal|1
condition|)
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRATNO
argument_list|)
expr_stmt|;
comment|/* transmit the message byte */
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SCSIDAT
argument_list|,
name|aic
operator|->
name|msg_buf
index|[
name|msgidx
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|aic_spiordy
argument_list|(
name|aic
argument_list|)
condition|)
do|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SXFRCTL0
argument_list|,
name|CHEN
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read data bytes.  */
end_comment

begin_function
specifier|static
name|void
name|aic_datain
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
block|{
name|struct
name|aic_scb
modifier|*
name|scb
init|=
name|aic
operator|->
name|nexus
decl_stmt|;
name|u_int8_t
name|dmastat
decl_stmt|,
name|dmacntrl0
decl_stmt|;
name|int
name|n
decl_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"aic_datain\n"
operator|)
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENPHASEMIS
operator||
name|ENBUSFREE
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SXFRCTL0
argument_list|,
name|SCSIEN
operator||
name|DMAEN
operator||
name|CHEN
argument_list|)
expr_stmt|;
name|dmacntrl0
operator|=
name|ENDMA
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|flags
operator|&
name|AIC_DWIO_ENABLE
condition|)
name|dmacntrl0
operator||=
name|DWORDPIO
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
name|dmacntrl0
argument_list|)
expr_stmt|;
while|while
condition|(
name|scb
operator|->
name|data_len
operator|>
literal|0
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* wait for the fifo to fill up or a phase change */
name|dmastat
operator|=
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|DMASTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmastat
operator|&
operator|(
name|INTSTAT
operator||
name|DFIFOFULL
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|dmastat
operator|&
name|DFIFOFULL
condition|)
block|{
name|n
operator|=
name|FIFOSIZE
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * No more data, wait for the remaining bytes in 			 * the scsi fifo to be transfer to the host fifo. 			 */
while|while
condition|(
operator|!
operator|(
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|SSTAT2
argument_list|)
operator|&
name|SEMPTY
operator|)
condition|)
empty_stmt|;
name|n
operator|=
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|FIFOSTAT
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|imin
argument_list|(
name|scb
operator|->
name|data_len
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|flags
operator|&
name|AIC_DWIO_ENABLE
condition|)
block|{
if|if
condition|(
name|n
operator|>=
literal|12
condition|)
block|{
name|aic_insl
argument_list|(
name|aic
argument_list|,
name|DMADATALONG
argument_list|,
name|scb
operator|->
name|data_ptr
argument_list|,
name|n
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|scb
operator|->
name|data_ptr
operator|+=
name|n
operator|&
operator|~
literal|3
expr_stmt|;
name|scb
operator|->
name|data_len
operator|-=
name|n
operator|&
operator|~
literal|3
expr_stmt|;
name|n
operator|&=
literal|3
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|n
operator|>=
literal|8
condition|)
block|{
name|aic_insw
argument_list|(
name|aic
argument_list|,
name|DMADATA
argument_list|,
name|scb
operator|->
name|data_ptr
argument_list|,
name|n
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|scb
operator|->
name|data_ptr
operator|+=
name|n
operator|&
operator|~
literal|1
expr_stmt|;
name|scb
operator|->
name|data_len
operator|-=
name|n
operator|&
operator|~
literal|1
expr_stmt|;
name|n
operator|&=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
condition|)
block|{
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
name|ENDMA
operator||
name|B8MODE
argument_list|)
expr_stmt|;
name|aic_insb
argument_list|(
name|aic
argument_list|,
name|DMADATA
argument_list|,
name|scb
operator|->
name|data_ptr
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|scb
operator|->
name|data_ptr
operator|+=
name|n
expr_stmt|;
name|scb
operator|->
name|data_len
operator|-=
name|n
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
name|dmacntrl0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dmastat
operator|&
name|INTSTAT
condition|)
break|break;
block|}
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SXFRCTL0
argument_list|,
name|CHEN
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send data bytes.  */
end_comment

begin_function
specifier|static
name|void
name|aic_dataout
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
block|{
name|struct
name|aic_scb
modifier|*
name|scb
init|=
name|aic
operator|->
name|nexus
decl_stmt|;
name|u_int8_t
name|dmastat
decl_stmt|,
name|dmacntrl0
decl_stmt|,
name|sstat2
decl_stmt|;
name|int
name|n
decl_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"aic_dataout\n"
operator|)
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENPHASEMIS
operator||
name|ENBUSFREE
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SXFRCTL0
argument_list|,
name|SCSIEN
operator||
name|DMAEN
operator||
name|CHEN
argument_list|)
expr_stmt|;
name|dmacntrl0
operator|=
name|ENDMA
operator||
name|WRITE
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|flags
operator|&
name|AIC_DWIO_ENABLE
condition|)
name|dmacntrl0
operator||=
name|DWORDPIO
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
name|dmacntrl0
argument_list|)
expr_stmt|;
while|while
condition|(
name|scb
operator|->
name|data_len
operator|>
literal|0
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* wait for the fifo to clear up or a phase change */
name|dmastat
operator|=
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|DMASTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmastat
operator|&
operator|(
name|INTSTAT
operator||
name|DFIFOEMP
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|dmastat
operator|&
name|INTSTAT
condition|)
break|break;
name|n
operator|=
name|imin
argument_list|(
name|scb
operator|->
name|data_len
argument_list|,
name|FIFOSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|flags
operator|&
name|AIC_DWIO_ENABLE
condition|)
block|{
if|if
condition|(
name|n
operator|>=
literal|12
condition|)
block|{
name|aic_outsl
argument_list|(
name|aic
argument_list|,
name|DMADATALONG
argument_list|,
name|scb
operator|->
name|data_ptr
argument_list|,
name|n
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|scb
operator|->
name|data_ptr
operator|+=
name|n
operator|&
operator|~
literal|3
expr_stmt|;
name|scb
operator|->
name|data_len
operator|-=
name|n
operator|&
operator|~
literal|3
expr_stmt|;
name|n
operator|&=
literal|3
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|n
operator|>=
literal|8
condition|)
block|{
name|aic_outsw
argument_list|(
name|aic
argument_list|,
name|DMADATA
argument_list|,
name|scb
operator|->
name|data_ptr
argument_list|,
name|n
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|scb
operator|->
name|data_ptr
operator|+=
name|n
operator|&
operator|~
literal|1
expr_stmt|;
name|scb
operator|->
name|data_len
operator|-=
name|n
operator|&
operator|~
literal|1
expr_stmt|;
name|n
operator|&=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
condition|)
block|{
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
name|ENDMA
operator||
name|WRITE
operator||
name|B8MODE
argument_list|)
expr_stmt|;
name|aic_outsb
argument_list|(
name|aic
argument_list|,
name|DMADATA
argument_list|,
name|scb
operator|->
name|data_ptr
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|scb
operator|->
name|data_ptr
operator|+=
name|n
expr_stmt|;
name|scb
operator|->
name|data_len
operator|-=
name|n
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
name|dmacntrl0
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* wait until all bytes in the fifos are transmitted */
name|dmastat
operator|=
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|DMASTAT
argument_list|)
expr_stmt|;
name|sstat2
operator|=
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|SSTAT2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dmastat
operator|&
name|DFIFOEMP
operator|)
operator|&&
operator|(
name|sstat2
operator|&
name|SEMPTY
operator|)
condition|)
break|break;
if|if
condition|(
name|dmastat
operator|&
name|INTSTAT
condition|)
block|{
comment|/* adjust for untransmitted bytes */
name|n
operator|=
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|FIFOSTAT
argument_list|)
operator|+
operator|(
name|sstat2
operator|&
literal|0xf
operator|)
expr_stmt|;
name|scb
operator|->
name|data_ptr
operator|-=
name|n
expr_stmt|;
name|scb
operator|->
name|data_len
operator|+=
name|n
expr_stmt|;
comment|/* clear the fifo */
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SXFRCTL0
argument_list|,
name|CHEN
operator||
name|CLRCH
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
name|RSTFIFO
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SXFRCTL0
argument_list|,
name|CHEN
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send the scsi command.  */
end_comment

begin_function
specifier|static
name|void
name|aic_cmd
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
block|{
name|struct
name|aic_scb
modifier|*
name|scb
init|=
name|aic
operator|->
name|nexus
decl_stmt|;
name|struct
name|scsi_request_sense
name|sense_cmd
decl_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"aic_cmd\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
condition|)
block|{
comment|/* autosense request */
name|sense_cmd
operator|.
name|opcode
operator|=
name|REQUEST_SENSE
expr_stmt|;
name|sense_cmd
operator|.
name|byte2
operator|=
name|scb
operator|->
name|lun
operator|<<
literal|5
expr_stmt|;
name|sense_cmd
operator|.
name|length
operator|=
name|scb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|sense_len
expr_stmt|;
name|sense_cmd
operator|.
name|control
operator|=
literal|0
expr_stmt|;
name|sense_cmd
operator|.
name|unused
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sense_cmd
operator|.
name|unused
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|cmd_ptr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|sense_cmd
expr_stmt|;
name|scb
operator|->
name|cmd_len
operator|=
sizeof|sizeof
argument_list|(
name|sense_cmd
argument_list|)
expr_stmt|;
name|scb
operator|->
name|data_ptr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|scb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
name|scb
operator|->
name|data_len
operator|=
name|scb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|sense_len
expr_stmt|;
block|}
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENPHASEMIS
operator||
name|ENBUSFREE
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
name|ENDMA
operator||
name|WRITE
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SXFRCTL0
argument_list|,
name|SCSIEN
operator||
name|DMAEN
operator||
name|CHEN
argument_list|)
expr_stmt|;
name|aic_outsw
argument_list|(
name|aic
argument_list|,
name|DMADATA
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|scb
operator|->
name|cmd_ptr
argument_list|,
name|scb
operator|->
name|cmd_len
operator|>>
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|SSTAT2
argument_list|)
operator|&
name|SEMPTY
operator|)
operator|==
literal|0
operator|&&
operator|(
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|DMASTAT
argument_list|)
operator|&
name|INTSTAT
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SXFRCTL0
argument_list|,
name|CHEN
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Finish off a command. The caller is responsible to remove the ccb  * from any queue.  */
end_comment

begin_function
specifier|static
name|void
name|aic_done
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|,
name|struct
name|aic_scb
modifier|*
name|scb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|scb
operator|->
name|ccb
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"aic_done - ccb %p status %x resid %d\n"
operator|,
name|ccb
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|,
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|)
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|aic_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_DEVICE_RESET
operator|)
operator|!=
literal|0
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|!=
name|XPT_RESET_DEV
condition|)
block|{
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|cam_status
name|error
decl_stmt|;
name|error
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|aic
operator|->
name|sim
argument_list|)
argument_list|,
name|scb
operator|->
name|target
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_async
argument_list|(
name|AC_SENT_BDR
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
name|ccb_h
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|aic
operator|->
name|pending_ccbs
argument_list|)
expr_stmt|;
while|while
condition|(
name|ccb_h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|aic_scb
modifier|*
name|pending_scb
decl_stmt|;
name|pending_scb
operator|=
operator|(
expr|struct
name|aic_scb
operator|*
operator|)
name|ccb_h
operator|->
name|ccb_scb_ptr
expr_stmt|;
if|if
condition|(
name|ccb_h
operator|->
name|target_id
operator|==
name|scb
operator|->
name|target
condition|)
block|{
name|ccb_h
operator|->
name|status
operator||=
name|CAM_BDR_SENT
expr_stmt|;
name|ccb_h
operator|=
name|TAILQ_NEXT
argument_list|(
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aic
operator|->
name|pending_ccbs
argument_list|,
operator|&
name|pending_scb
operator|->
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|aic_done
argument_list|(
name|aic
argument_list|,
name|pending_scb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ccb_h
operator|->
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|aic_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|pending_scb
argument_list|,
operator|(
name|ccb_h
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|ccb_h
operator|=
name|TAILQ_NEXT
argument_list|(
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
block|}
block|}
name|ccb_h
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|aic
operator|->
name|nexus_ccbs
argument_list|)
expr_stmt|;
while|while
condition|(
name|ccb_h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|aic_scb
modifier|*
name|nexus_scb
decl_stmt|;
name|nexus_scb
operator|=
operator|(
expr|struct
name|aic_scb
operator|*
operator|)
name|ccb_h
operator|->
name|ccb_scb_ptr
expr_stmt|;
if|if
condition|(
name|ccb_h
operator|->
name|target_id
operator|==
name|scb
operator|->
name|target
condition|)
block|{
name|ccb_h
operator|->
name|status
operator||=
name|CAM_BDR_SENT
expr_stmt|;
name|ccb_h
operator|=
name|TAILQ_NEXT
argument_list|(
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aic
operator|->
name|nexus_ccbs
argument_list|,
operator|&
name|nexus_scb
operator|->
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|aic_done
argument_list|(
name|aic
argument_list|,
name|nexus_scb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ccb_h
operator|->
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|aic_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|nexus_scb
argument_list|,
operator|(
name|ccb_h
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|ccb_h
operator|=
name|TAILQ_NEXT
argument_list|(
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|aic
operator|->
name|nexus
operator|==
name|scb
operator|||
name|scb
operator|->
name|flags
operator|&
name|SCB_DISCONNECTED
condition|)
name|aic
operator|->
name|tinfo
index|[
name|scb
operator|->
name|target
index|]
operator|.
name|lubusy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|scb
operator|->
name|lun
operator|)
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|nexus
operator|==
name|scb
condition|)
block|{
name|aic
operator|->
name|nexus
operator|=
name|NULL
expr_stmt|;
block|}
name|aic_free_scb
argument_list|(
name|aic
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aic_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|aic_intr
argument_list|(
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aic_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|aic_scb
modifier|*
name|scb
init|=
operator|(
expr|struct
name|aic_scb
operator|*
operator|)
name|arg
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|scb
operator|->
name|ccb
decl_stmt|;
name|struct
name|aic_softc
modifier|*
name|aic
init|=
operator|(
expr|struct
name|aic_softc
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_aic_ptr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ccb %p - timed out"
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|nexus
operator|&&
name|aic
operator|->
name|nexus
operator|!=
name|scb
condition|)
name|printf
argument_list|(
literal|", nexus %p"
argument_list|,
name|aic
operator|->
name|nexus
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", phase 0x%x, state %d\n"
argument_list|,
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|SCSISIGI
argument_list|)
argument_list|,
name|aic
operator|->
name|state
argument_list|)
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ccb %p - timed out already completed\n"
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_DEVICE_RESET
operator|)
operator|==
literal|0
operator|&&
name|aic
operator|->
name|nexus
operator|==
name|scb
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
init|=
operator|&
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
decl_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|status
operator|&
name|CAM_RELEASE_SIMQ
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|aic
operator|->
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|ccb_h
argument_list|,
argument|&aic->pending_ccbs
argument_list|,
argument|sim_links.tqe
argument_list|)
block|{
name|untimeout
argument_list|(
name|aic_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb_h
operator|->
name|ccb_scb_ptr
argument_list|,
name|ccb_h
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|ccb_h
argument_list|,
argument|&aic->nexus_ccbs
argument_list|,
argument|sim_links.tqe
argument_list|)
block|{
name|untimeout
argument_list|(
name|aic_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb_h
operator|->
name|ccb_scb_ptr
argument_list|,
name|ccb_h
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
block|}
name|scb
operator|->
name|flags
operator||=
name|SCB_DEVICE_RESET
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|aic_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
name|aic_sched_msgout
argument_list|(
name|aic
argument_list|,
name|MSG_BUS_DEV_RESET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|aic
operator|->
name|nexus
operator|==
name|scb
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_CMD_TIMEOUT
expr_stmt|;
name|aic_done
argument_list|(
name|aic
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
name|aic_reset
argument_list|(
name|aic
argument_list|,
comment|/*initiate_reset*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aic_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|aic_softc
modifier|*
name|aic
init|=
operator|(
expr|struct
name|aic_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|u_int8_t
name|sstat0
decl_stmt|,
name|sstat1
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|aic_scb
modifier|*
name|scb
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|DMASTAT
argument_list|)
operator|&
name|INTSTAT
operator|)
condition|)
return|return;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sstat0
operator|=
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|SSTAT0
argument_list|)
expr_stmt|;
name|sstat1
operator|=
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|SSTAT1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sstat1
operator|&
name|SCSIRSTI
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* a device-initiated bus reset */
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSCSIRSTI
argument_list|)
expr_stmt|;
name|aic_reset
argument_list|(
name|aic
argument_list|,
comment|/*initiate_reset*/
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|sstat1
operator|&
name|SCSIPERR
operator|)
operator|!=
literal|0
condition|)
block|{
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSCSIPERR
argument_list|)
expr_stmt|;
name|aic_sched_msgout
argument_list|(
name|aic
argument_list|,
name|MSG_PARITY_ERROR
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
name|INTEN
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|SSTAT4
argument_list|)
condition|)
block|{
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|CLRSERR
argument_list|,
name|CLRSYNCERR
operator||
name|CLRFWERR
operator||
name|CLRFRERR
argument_list|)
expr_stmt|;
name|aic_reset
argument_list|(
name|aic
argument_list|,
comment|/*initiate_reset*/
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|aic
operator|->
name|state
operator|<=
name|AIC_SELECTING
condition|)
block|{
if|if
condition|(
operator|(
name|sstat0
operator|&
name|SELDI
operator|)
operator|!=
literal|0
condition|)
block|{
name|aic_reselected
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
name|INTEN
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|sstat0
operator|&
name|SELDO
operator|)
operator|!=
literal|0
condition|)
block|{
name|aic_selected
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
name|INTEN
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|sstat1
operator|&
name|SELTO
operator|)
operator|!=
literal|0
condition|)
block|{
name|scb
operator|=
name|aic
operator|->
name|nexus
expr_stmt|;
name|ccb
operator|=
name|scb
operator|->
name|ccb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
name|aic_done
argument_list|(
name|aic
argument_list|,
name|scb
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sstat1
operator|&
name|BUSFREE
operator|)
operator|==
literal|0
condition|)
name|sstat1
operator|=
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|SSTAT1
argument_list|)
expr_stmt|;
name|aic
operator|->
name|flags
operator||=
name|AIC_BUSFREE_OK
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|sstat1
operator|&
name|BUSFREE
operator|)
operator|!=
literal|0
condition|)
block|{
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SCSISEQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|CLRSINT0
argument_list|,
name|sstat0
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|CLRSINT1
argument_list|,
name|sstat1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|=
name|aic
operator|->
name|nexus
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|aic
operator|->
name|flags
operator|&
name|AIC_BUSFREE_OK
operator|)
operator|==
literal|0
condition|)
block|{
name|ccb
operator|=
name|scb
operator|->
name|ccb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UNEXP_BUSFREE
expr_stmt|;
name|aic_done
argument_list|(
name|aic
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_DEVICE_RESET
condition|)
block|{
name|ccb
operator|=
name|scb
operator|->
name|ccb
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_RESET_DEV
condition|)
block|{
name|xpt_async
argument_list|(
name|AC_SENT_BDR
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
block|}
else|else
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_CMD_TIMEOUT
expr_stmt|;
name|aic_done
argument_list|(
name|aic
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
condition|)
block|{
comment|/* autosense request */
name|aic
operator|->
name|flags
operator|&=
operator|~
name|AIC_BUSFREE_OK
expr_stmt|;
name|aic
operator|->
name|tinfo
index|[
name|scb
operator|->
name|target
index|]
operator|.
name|lubusy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|scb
operator|->
name|lun
operator|)
expr_stmt|;
name|aic_select
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
name|INTEN
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|aic
operator|->
name|flags
operator|&=
operator|~
name|AIC_BUSFREE_OK
expr_stmt|;
name|aic
operator|->
name|state
operator|=
name|AIC_IDLE
expr_stmt|;
name|aic_start
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
name|INTEN
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|sstat1
operator|&
name|REQINIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int8_t
name|phase
init|=
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|PH_MASK
decl_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SCSISIGO
argument_list|,
name|phase
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRPHASECHG
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|phase
condition|)
block|{
case|case
name|PH_MSGOUT
case|:
name|aic_msgout
argument_list|(
name|aic
argument_list|)
expr_stmt|;
break|break;
case|case
name|PH_MSGIN
case|:
name|aic_msgin
argument_list|(
name|aic
argument_list|)
expr_stmt|;
break|break;
case|case
name|PH_STAT
case|:
name|scb
operator|=
name|aic
operator|->
name|nexus
expr_stmt|;
name|ccb
operator|=
name|scb
operator|->
name|ccb
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SXFRCTL0
argument_list|,
name|CHEN
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
name|scb
operator|->
name|status
operator|=
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|SCSIDAT
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SXFRCTL0
argument_list|,
name|CHEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|PH_CMD
case|:
name|aic_cmd
argument_list|(
name|aic
argument_list|)
expr_stmt|;
break|break;
case|case
name|PH_DATAIN
case|:
name|aic_datain
argument_list|(
name|aic
argument_list|)
expr_stmt|;
break|break;
case|case
name|PH_DATAOUT
case|:
name|aic_dataout
argument_list|(
name|aic
argument_list|)
expr_stmt|;
break|break;
block|}
name|aic
operator|->
name|prev_phase
operator|=
name|phase
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
name|INTEN
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"aic_intr: unexpected intr sstat0 %x sstat1 %x\n"
argument_list|,
name|sstat0
argument_list|,
name|sstat1
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
name|INTEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset ourselves.  */
end_comment

begin_function
specifier|static
name|void
name|aic_chip_reset
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
block|{
comment|/* 	 * Doc. recommends to clear these two registers before 	 * operations commence 	 */
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SCSITEST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|TEST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset SCSI-FIFO and abort any transfers */
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SXFRCTL0
argument_list|,
name|CHEN
operator||
name|CLRCH
operator||
name|CLRSTCNT
argument_list|)
expr_stmt|;
comment|/* Reset HOST-FIFO */
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
name|RSTFIFO
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable all selection features */
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SCSISEQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SXFRCTL1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable interrupts */
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SIMODE0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SIMODE1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear interrupts */
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|CLRSINT0
argument_list|,
literal|0x7f
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|CLRSINT1
argument_list|,
literal|0xef
argument_list|)
expr_stmt|;
comment|/* Disable synchronous transfers */
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SCSIRATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Haven't seen ant errors (yet) */
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|CLRSERR
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
comment|/* Set our SCSI-ID */
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SCSIID
argument_list|,
name|aic
operator|->
name|initiator
operator|<<
name|OID_S
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|BRSTCNTRL
argument_list|,
name|EISA_BRST_TIM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the SCSI bus  */
end_comment

begin_function
specifier|static
name|void
name|aic_scsi_reset
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
block|{
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SCSISEQ
argument_list|,
name|SCSIRSTO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|SCSISEQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset. Abort all pending commands.  */
end_comment

begin_function
specifier|static
name|void
name|aic_reset
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|,
name|int
name|initiate_reset
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|CAM_DEBUG_PRINT
argument_list|(
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"aic_reset\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|initiate_reset
condition|)
name|aic_scsi_reset
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|aic_chip_reset
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|aic
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ccb_h
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|aic
operator|->
name|pending_ccbs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aic
operator|->
name|pending_ccbs
argument_list|,
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator||=
name|CAM_SCSI_BUS_RESET
expr_stmt|;
name|aic_done
argument_list|(
name|aic
argument_list|,
operator|(
expr|struct
name|aic_scb
operator|*
operator|)
name|ccb_h
operator|->
name|ccb_scb_ptr
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ccb_h
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|aic
operator|->
name|nexus_ccbs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aic
operator|->
name|nexus_ccbs
argument_list|,
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator||=
name|CAM_SCSI_BUS_RESET
expr_stmt|;
name|aic_done
argument_list|(
name|aic
argument_list|,
operator|(
expr|struct
name|aic_scb
operator|*
operator|)
name|ccb_h
operator|->
name|ccb_scb_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aic
operator|->
name|nexus
condition|)
block|{
name|ccb_h
operator|=
operator|&
name|aic
operator|->
name|nexus
operator|->
name|ccb
operator|->
name|ccb_h
expr_stmt|;
name|ccb_h
operator|->
name|status
operator||=
name|CAM_SCSI_BUS_RESET
expr_stmt|;
name|aic_done
argument_list|(
name|aic
argument_list|,
name|aic
operator|->
name|nexus
argument_list|)
expr_stmt|;
block|}
name|aic
operator|->
name|state
operator|=
name|AIC_IDLE
expr_stmt|;
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
name|INTEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|aic_chip_names
index|[]
init|=
block|{
literal|"AIC6260"
block|,
literal|"AIC6360"
block|,
literal|"AIC6370"
block|,
literal|"GM82C700"
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|idstring
decl_stmt|;
block|}
name|aic_chip_ids
index|[]
init|=
block|{
block|{
name|AIC6360
block|,
name|IDSTRING_AIC6360
block|}
block|,
block|{
name|AIC6370
block|,
name|IDSTRING_AIC6370
block|}
block|,
block|{
name|GM82C700
block|,
name|IDSTRING_GM82C700
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|void
name|aic_init
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
block|{
name|struct
name|aic_scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|aic_tinfo
modifier|*
name|ti
decl_stmt|;
name|u_int8_t
name|porta
decl_stmt|,
name|portb
decl_stmt|;
name|char
name|chip_id
index|[
literal|33
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|aic
operator|->
name|pending_ccbs
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|aic
operator|->
name|nexus_ccbs
argument_list|)
expr_stmt|;
name|aic
operator|->
name|nexus
operator|=
name|NULL
expr_stmt|;
name|aic
operator|->
name|state
operator|=
name|AIC_IDLE
expr_stmt|;
name|aic
operator|->
name|prev_phase
operator|=
operator|-
literal|1
expr_stmt|;
name|aic
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|aic_chip_reset
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|aic_scsi_reset
argument_list|(
name|aic
argument_list|)
expr_stmt|;
comment|/* determine the chip type from its ID string */
name|aic
operator|->
name|chip_type
operator|=
name|AIC6260
expr_stmt|;
name|aic_insb
argument_list|(
name|aic
argument_list|,
name|ID
argument_list|,
name|chip_id
argument_list|,
sizeof|sizeof
argument_list|(
name|chip_id
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|chip_id
index|[
sizeof|sizeof
argument_list|(
name|chip_id
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|aic_chip_ids
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|aic_chip_ids
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|chip_id
argument_list|,
name|aic_chip_ids
index|[
name|i
index|]
operator|.
name|idstring
argument_list|)
condition|)
block|{
name|aic
operator|->
name|chip_type
operator|=
name|aic_chip_ids
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
break|break;
block|}
block|}
name|porta
operator|=
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|PORTA
argument_list|)
expr_stmt|;
name|portb
operator|=
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|PORTB
argument_list|)
expr_stmt|;
name|aic
operator|->
name|initiator
operator|=
name|PORTA_ID
argument_list|(
name|porta
argument_list|)
expr_stmt|;
if|if
condition|(
name|PORTA_PARITY
argument_list|(
name|porta
argument_list|)
condition|)
name|aic
operator|->
name|flags
operator||=
name|AIC_PARITY_ENABLE
expr_stmt|;
if|if
condition|(
name|PORTB_DISC
argument_list|(
name|portb
argument_list|)
condition|)
name|aic
operator|->
name|flags
operator||=
name|AIC_DISC_ENABLE
expr_stmt|;
if|if
condition|(
name|PORTB_DMA
argument_list|(
name|portb
argument_list|)
condition|)
name|aic
operator|->
name|flags
operator||=
name|AIC_DMA_ENABLE
expr_stmt|;
comment|/* 	 * We can do fast SCSI (10MHz clock rate) if bit 4 of portb 	 * is set and we've got a 6360.  The 6260 can only do standard 	 * 5MHz SCSI. 	 */
if|if
condition|(
name|aic
operator|->
name|chip_type
operator|>
name|AIC6260
operator|||
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|REV
argument_list|)
condition|)
block|{
if|if
condition|(
name|PORTB_FSYNC
argument_list|(
name|portb
argument_list|)
condition|)
name|aic
operator|->
name|flags
operator||=
name|AIC_FAST_ENABLE
expr_stmt|;
name|aic
operator|->
name|flags
operator||=
name|AIC_DWIO_ENABLE
expr_stmt|;
block|}
if|if
condition|(
name|aic
operator|->
name|flags
operator|&
name|AIC_FAST_ENABLE
condition|)
name|aic
operator|->
name|max_period
operator|=
name|AIC_FAST_SYNC_PERIOD
expr_stmt|;
else|else
name|aic
operator|->
name|max_period
operator|=
name|AIC_SYNC_PERIOD
expr_stmt|;
name|aic
operator|->
name|min_period
operator|=
name|AIC_MIN_SYNC_PERIOD
expr_stmt|;
name|free_scbs
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|255
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|scb
operator|=
operator|&
name|aic
operator|->
name|scbs
index|[
name|i
index|]
expr_stmt|;
name|scb
operator|->
name|tag
operator|=
name|i
expr_stmt|;
name|aic_free_scb
argument_list|(
name|aic
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|aic
operator|->
name|initiator
condition|)
continue|continue;
name|ti
operator|=
operator|&
name|aic
operator|->
name|tinfo
index|[
name|i
index|]
expr_stmt|;
name|bzero
argument_list|(
name|ti
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ti
argument_list|)
argument_list|)
expr_stmt|;
name|ti
operator|->
name|flags
operator|=
name|TINFO_TAG_ENB
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|flags
operator|&
name|AIC_DISC_ENABLE
condition|)
name|ti
operator|->
name|flags
operator||=
name|TINFO_DISC_ENB
expr_stmt|;
name|ti
operator|->
name|user
operator|.
name|period
operator|=
name|aic
operator|->
name|max_period
expr_stmt|;
name|ti
operator|->
name|user
operator|.
name|offset
operator|=
name|AIC_SYNC_OFFSET
expr_stmt|;
name|ti
operator|->
name|scsirate
operator|=
literal|0
expr_stmt|;
block|}
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
name|INTEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|aic_probe
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Remove aic6360 from possible powerdown mode */
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
define|#
directive|define
name|STSIZE
value|16
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset stack pointer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STSIZE
condition|;
name|i
operator|++
control|)
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|STACK
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* See if we can pull out the same sequence */
name|aic_outb
argument_list|(
name|aic
argument_list|,
name|DMACNTRL1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STSIZE
operator|&&
name|aic_inb
argument_list|(
name|aic
argument_list|,
name|STACK
argument_list|)
operator|==
name|i
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|!=
name|STSIZE
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
undef|#
directive|undef
name|STSIZE
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|aic_attach
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
comment|/* 	 * Create the device queue for our SIM. 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * Construct our SIM entry 	 */
name|aic
operator|->
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|aic_action
argument_list|,
name|aic_poll
argument_list|,
literal|"aic"
argument_list|,
name|aic
argument_list|,
name|aic
operator|->
name|unit
argument_list|,
operator|&
name|Giant
argument_list|,
literal|2
argument_list|,
literal|256
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|sim
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|aic
operator|->
name|sim
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|aic
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|aic
operator|->
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|aic
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|aic
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|aic
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|aic_init
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"aic%d: %s"
argument_list|,
name|aic
operator|->
name|unit
argument_list|,
name|aic_chip_names
index|[
name|aic
operator|->
name|chip_type
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|flags
operator|&
name|AIC_DMA_ENABLE
condition|)
name|printf
argument_list|(
literal|", dma"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|flags
operator|&
name|AIC_DISC_ENABLE
condition|)
name|printf
argument_list|(
literal|", disconnection"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|flags
operator|&
name|AIC_PARITY_ENABLE
condition|)
name|printf
argument_list|(
literal|", parity check"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|flags
operator|&
name|AIC_FAST_ENABLE
condition|)
name|printf
argument_list|(
literal|", fast SCSI"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|aic_detach
parameter_list|(
name|struct
name|aic_softc
modifier|*
name|aic
parameter_list|)
block|{
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|aic
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|aic
operator|->
name|path
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|aic
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|aic
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

