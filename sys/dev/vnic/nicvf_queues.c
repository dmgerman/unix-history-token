begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2015 Cavium Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bitset.h>
end_include

begin_include
include|#
directive|include
file|<sys/bitstring.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf_ring.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stdatomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/ifq.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_lro.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|"thunder_bgx.h"
end_include

begin_include
include|#
directive|include
file|"nic_reg.h"
end_include

begin_include
include|#
directive|include
file|"nic.h"
end_include

begin_include
include|#
directive|include
file|"q_struct.h"
end_include

begin_include
include|#
directive|include
file|"nicvf_queues.h"
end_include

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_undef
undef|#
directive|undef
name|DEBUG
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
name|dev
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|device_printf(dev, fmt, ##__VA_ARGS__)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
name|dev
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|MALLOC_DECLARE
argument_list|(
name|M_NICVF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|nicvf_free_snd_queue
parameter_list|(
name|struct
name|nicvf
modifier|*
parameter_list|,
name|struct
name|snd_queue
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|nicvf_get_rcv_mbuf
parameter_list|(
name|struct
name|nicvf
modifier|*
parameter_list|,
name|struct
name|cqe_rx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nicvf_sq_disable
parameter_list|(
name|struct
name|nicvf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nicvf_sq_enable
parameter_list|(
name|struct
name|nicvf
modifier|*
parameter_list|,
name|struct
name|snd_queue
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nicvf_put_sq_desc
parameter_list|(
name|struct
name|snd_queue
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nicvf_cmp_queue_config
parameter_list|(
name|struct
name|nicvf
modifier|*
parameter_list|,
name|struct
name|queue_set
modifier|*
parameter_list|,
name|int
parameter_list|,
name|boolean_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nicvf_sq_free_used_descs
parameter_list|(
name|struct
name|nicvf
modifier|*
parameter_list|,
name|struct
name|snd_queue
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicvf_tx_mbuf_locked
parameter_list|(
name|struct
name|snd_queue
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nicvf_rbdr_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nicvf_rbdr_task_nowait
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|rbuf_info
block|{
name|bus_dma_tag_t
name|dmat
decl_stmt|;
name|bus_dmamap_t
name|dmap
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|GET_RBUF_INFO
parameter_list|(
name|x
parameter_list|)
value|((struct rbuf_info *)((x) - NICVF_RCV_BUF_ALIGN_BYTES))
end_define

begin_comment
comment|/* Poll a register for a specific value */
end_comment

begin_function
specifier|static
name|int
name|nicvf_poll_reg
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|int
name|qidx
parameter_list|,
name|uint64_t
name|reg
parameter_list|,
name|int
name|bit_pos
parameter_list|,
name|int
name|bits
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|uint64_t
name|bit_mask
decl_stmt|;
name|uint64_t
name|reg_val
decl_stmt|;
name|int
name|timeout
init|=
literal|10
decl_stmt|;
name|bit_mask
operator|=
operator|(
literal|1UL
operator|<<
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
name|bit_mask
operator|=
operator|(
name|bit_mask
operator|<<
name|bit_pos
operator|)
expr_stmt|;
while|while
condition|(
name|timeout
condition|)
block|{
name|reg_val
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|reg
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|reg_val
operator|&
name|bit_mask
operator|)
operator|>>
name|bit_pos
operator|)
operator|==
name|val
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Poll on reg 0x%lx failed\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Callback for bus_dmamap_load() */
end_comment

begin_function
specifier|static
name|void
name|nicvf_dmamap_q_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|paddr
decl_stmt|;
name|KASSERT
argument_list|(
name|nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"wrong number of segments, should be 1"
operator|)
argument_list|)
expr_stmt|;
name|paddr
operator|=
name|arg
expr_stmt|;
operator|*
name|paddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate memory for a queue's descriptors */
end_comment

begin_function
specifier|static
name|int
name|nicvf_alloc_q_desc_mem
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|q_desc_mem
modifier|*
name|dmem
parameter_list|,
name|int
name|q_len
parameter_list|,
name|int
name|desc_size
parameter_list|,
name|int
name|align_bytes
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|err_dmat
decl_stmt|;
comment|/* Create DMA tag first */
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
argument_list|,
comment|/* parent tag */
name|align_bytes
argument_list|,
comment|/* alignment */
literal|0
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filtfunc, filtfuncarg */
operator|(
name|q_len
operator|*
name|desc_size
operator|)
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
operator|(
name|q_len
operator|*
name|desc_size
operator|)
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockfuncarg */
operator|&
name|dmem
operator|->
name|dmat
argument_list|)
expr_stmt|;
comment|/* dmat */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Failed to create busdma tag for descriptors ring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* Allocate segment of continuous DMA safe memory */
name|err
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
comment|/* DMA tag */
operator|&
name|dmem
operator|->
name|base
argument_list|,
comment|/* virtual address */
operator|(
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
operator|)
argument_list|,
comment|/* flags */
operator|&
name|dmem
operator|->
name|dmap
argument_list|)
expr_stmt|;
comment|/* DMA map */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Failed to allocate DMA safe memory for"
literal|"descriptors ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|dmamem_fail
goto|;
block|}
name|err
operator|=
name|bus_dmamap_load
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
name|dmem
operator|->
name|dmap
argument_list|,
name|dmem
operator|->
name|base
argument_list|,
operator|(
name|q_len
operator|*
name|desc_size
operator|)
argument_list|,
comment|/* allocation size */
name|nicvf_dmamap_q_cb
argument_list|,
comment|/* map to DMA address cb. */
operator|&
name|dmem
operator|->
name|phys_base
argument_list|,
comment|/* physical address */
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Cannot load DMA map of descriptors ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|dmamap_fail
goto|;
block|}
name|dmem
operator|->
name|q_len
operator|=
name|q_len
expr_stmt|;
name|dmem
operator|->
name|size
operator|=
operator|(
name|desc_size
operator|*
name|q_len
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|dmamap_fail
label|:
name|bus_dmamem_free
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
name|dmem
operator|->
name|base
argument_list|,
name|dmem
operator|->
name|dmap
argument_list|)
expr_stmt|;
name|dmem
operator|->
name|phys_base
operator|=
literal|0
expr_stmt|;
name|dmamem_fail
label|:
name|err_dmat
operator|=
name|bus_dma_tag_destroy
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|)
expr_stmt|;
name|dmem
operator|->
name|base
operator|=
name|NULL
expr_stmt|;
name|KASSERT
argument_list|(
name|err_dmat
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Trying to destroy BUSY DMA tag"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free queue's descriptor memory */
end_comment

begin_function
specifier|static
name|void
name|nicvf_free_q_desc_mem
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|q_desc_mem
modifier|*
name|dmem
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|dmem
operator|==
name|NULL
operator|)
operator|||
operator|(
name|dmem
operator|->
name|base
operator|==
name|NULL
operator|)
condition|)
return|return;
comment|/* Unload a map */
name|bus_dmamap_sync
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
name|dmem
operator|->
name|dmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
name|dmem
operator|->
name|dmap
argument_list|)
expr_stmt|;
comment|/* Free DMA memory */
name|bus_dmamem_free
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
name|dmem
operator|->
name|base
argument_list|,
name|dmem
operator|->
name|dmap
argument_list|)
expr_stmt|;
comment|/* Destroy DMA tag */
name|err
operator|=
name|bus_dma_tag_destroy
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Trying to destroy BUSY DMA tag"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|dmem
operator|->
name|phys_base
operator|=
literal|0
expr_stmt|;
name|dmem
operator|->
name|base
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate buffer for packet reception  * HW returns memory address where packet is DMA'ed but not a pointer  * into RBDR ring, so save buffer address at the start of fragment and  * align the start address to a cache aligned address  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|nicvf_alloc_rcv_buffer
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|rbdr
modifier|*
name|rbdr
parameter_list|,
name|bus_dmamap_t
name|dmap
parameter_list|,
name|int
name|mflags
parameter_list|,
name|uint32_t
name|buf_len
parameter_list|,
name|bus_addr_t
modifier|*
name|rbuf
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
name|struct
name|rbuf_info
modifier|*
name|rinfo
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|1
index|]
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mbuf
operator|=
name|m_getjcl
argument_list|(
name|mflags
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbuf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * The length is equal to the actual length + one 128b line 	 * used as a room for rbuf_info structure. 	 */
name|mbuf
operator|->
name|m_len
operator|=
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|buf_len
expr_stmt|;
name|err
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rbdr
operator|->
name|rbdr_buff_dmat
argument_list|,
name|dmap
argument_list|,
name|mbuf
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Failed to map mbuf into DMA visible memory, err: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|rbdr
operator|->
name|rbdr_buff_dmat
argument_list|,
name|dmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|nsegs
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"Unexpected number of DMA segments for RB: %d"
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
comment|/* 	 * Now use the room for rbuf_info structure 	 * and adjust mbuf data and length. 	 */
name|rinfo
operator|=
operator|(
expr|struct
name|rbuf_info
operator|*
operator|)
name|mbuf
operator|->
name|m_data
expr_stmt|;
name|m_adj
argument_list|(
name|mbuf
argument_list|,
name|NICVF_RCV_BUF_ALIGN_BYTES
argument_list|)
expr_stmt|;
name|rinfo
operator|->
name|dmat
operator|=
name|rbdr
operator|->
name|rbdr_buff_dmat
expr_stmt|;
name|rinfo
operator|->
name|dmap
operator|=
name|dmap
expr_stmt|;
name|rinfo
operator|->
name|mbuf
operator|=
name|mbuf
expr_stmt|;
operator|*
name|rbuf
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
operator|+
name|NICVF_RCV_BUF_ALIGN_BYTES
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Retrieve mbuf for received packet */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|nicvf_rb_ptr_to_mbuf
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|bus_addr_t
name|rb_ptr
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
name|struct
name|rbuf_info
modifier|*
name|rinfo
decl_stmt|;
comment|/* Get buffer start address and alignment offset */
name|rinfo
operator|=
name|GET_RBUF_INFO
argument_list|(
name|PHYS_TO_DMAP
argument_list|(
name|rb_ptr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now retrieve mbuf to give to stack */
name|mbuf
operator|=
name|rinfo
operator|->
name|mbuf
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|mbuf
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"%s: Received packet fragment with NULL mbuf"
argument_list|,
name|device_get_nameunit
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear the mbuf in the descriptor to indicate 	 * that this slot is processed and free to use. 	 */
name|rinfo
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rinfo
operator|->
name|dmat
argument_list|,
name|rinfo
operator|->
name|dmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rinfo
operator|->
name|dmat
argument_list|,
name|rinfo
operator|->
name|dmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|mbuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate RBDR ring and populate receive buffers */
end_comment

begin_function
specifier|static
name|int
name|nicvf_init_rbdr
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|rbdr
modifier|*
name|rbdr
parameter_list|,
name|int
name|ring_len
parameter_list|,
name|int
name|buf_size
parameter_list|,
name|int
name|qidx
parameter_list|)
block|{
name|bus_dmamap_t
name|dmap
decl_stmt|;
name|bus_addr_t
name|rbuf
decl_stmt|;
name|struct
name|rbdr_entry_t
modifier|*
name|desc
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* Allocate rbdr descriptors ring */
name|err
operator|=
name|nicvf_alloc_q_desc_mem
argument_list|(
name|nic
argument_list|,
operator|&
name|rbdr
operator|->
name|dmem
argument_list|,
name|ring_len
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rbdr_entry_t
argument_list|)
argument_list|,
name|NICVF_RCV_BUF_ALIGN_BYTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Failed to create RBDR descriptors ring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|rbdr
operator|->
name|desc
operator|=
name|rbdr
operator|->
name|dmem
operator|.
name|base
expr_stmt|;
comment|/* 	 * Buffer size has to be in multiples of 128 bytes. 	 * Make room for metadata of size of one line (128 bytes). 	 */
name|rbdr
operator|->
name|dma_size
operator|=
name|buf_size
operator|-
name|NICVF_RCV_BUF_ALIGN_BYTES
expr_stmt|;
name|rbdr
operator|->
name|enable
operator|=
name|TRUE
expr_stmt|;
name|rbdr
operator|->
name|thresh
operator|=
name|RBDR_THRESH
expr_stmt|;
name|rbdr
operator|->
name|nic
operator|=
name|nic
expr_stmt|;
name|rbdr
operator|->
name|idx
operator|=
name|qidx
expr_stmt|;
comment|/* 	 * Create DMA tag for Rx buffers. 	 * Each map created using this tag is intended to store Rx payload for 	 * one fragment and one header structure containing rbuf_info (thus 	 * additional 128 byte line since RB must be a multiple of 128 byte 	 * cache line). 	 */
if|if
condition|(
name|buf_size
operator|>
name|MCLBYTES
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Buffer size to large for mbuf cluster\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
argument_list|,
comment|/* parent tag */
name|NICVF_RCV_BUF_ALIGN_BYTES
argument_list|,
comment|/* alignment */
literal|0
argument_list|,
comment|/* boundary */
name|DMAP_MAX_PHYSADDR
argument_list|,
comment|/* lowaddr */
name|DMAP_MIN_PHYSADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filtfunc, filtfuncarg */
name|roundup2
argument_list|(
name|buf_size
argument_list|,
name|MCLBYTES
argument_list|)
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|roundup2
argument_list|(
name|buf_size
argument_list|,
name|MCLBYTES
argument_list|)
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockfuncarg */
operator|&
name|rbdr
operator|->
name|rbdr_buff_dmat
argument_list|)
expr_stmt|;
comment|/* dmat */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Failed to create busdma tag for RBDR buffers\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|rbdr
operator|->
name|rbdr_buff_dmaps
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rbdr
operator|->
name|rbdr_buff_dmaps
argument_list|)
operator|*
name|ring_len
argument_list|,
name|M_NICVF
argument_list|,
operator|(
name|M_WAITOK
operator||
name|M_ZERO
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|ring_len
condition|;
name|idx
operator|++
control|)
block|{
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|rbdr
operator|->
name|rbdr_buff_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Failed to create DMA map for RB\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|rbdr
operator|->
name|rbdr_buff_dmaps
index|[
name|idx
index|]
operator|=
name|dmap
expr_stmt|;
name|err
operator|=
name|nicvf_alloc_rcv_buffer
argument_list|(
name|nic
argument_list|,
name|rbdr
argument_list|,
name|dmap
argument_list|,
name|M_WAITOK
argument_list|,
name|DMA_BUFFER_LEN
argument_list|,
operator|&
name|rbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|desc
operator|=
name|GET_RBDR_DESC
argument_list|(
name|rbdr
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|desc
operator|->
name|buf_addr
operator|=
operator|(
name|rbuf
operator|>>
name|NICVF_RCV_BUF_ALIGN
operator|)
expr_stmt|;
block|}
comment|/* Allocate taskqueue */
name|TASK_INIT
argument_list|(
operator|&
name|rbdr
operator|->
name|rbdr_task
argument_list|,
literal|0
argument_list|,
name|nicvf_rbdr_task
argument_list|,
name|rbdr
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|rbdr
operator|->
name|rbdr_task_nowait
argument_list|,
literal|0
argument_list|,
name|nicvf_rbdr_task_nowait
argument_list|,
name|rbdr
argument_list|)
expr_stmt|;
name|rbdr
operator|->
name|rbdr_taskq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"nicvf_rbdr_taskq"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|rbdr
operator|->
name|rbdr_taskq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|rbdr
operator|->
name|rbdr_taskq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s: rbdr_taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free RBDR ring and its receive buffers */
end_comment

begin_function
specifier|static
name|void
name|nicvf_free_rbdr
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|rbdr
modifier|*
name|rbdr
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
decl_stmt|;
name|struct
name|rbdr_entry_t
modifier|*
name|desc
decl_stmt|;
name|struct
name|rbuf_info
modifier|*
name|rinfo
decl_stmt|;
name|bus_addr_t
name|buf_addr
decl_stmt|;
name|int
name|head
decl_stmt|,
name|tail
decl_stmt|,
name|idx
decl_stmt|;
name|int
name|err
decl_stmt|;
name|qs
operator|=
name|nic
operator|->
name|qs
expr_stmt|;
if|if
condition|(
operator|(
name|qs
operator|==
name|NULL
operator|)
operator|||
operator|(
name|rbdr
operator|==
name|NULL
operator|)
condition|)
return|return;
name|rbdr
operator|->
name|enable
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|rbdr
operator|->
name|rbdr_taskq
operator|!=
name|NULL
condition|)
block|{
comment|/* Remove tasks */
while|while
condition|(
name|taskqueue_cancel
argument_list|(
name|rbdr
operator|->
name|rbdr_taskq
argument_list|,
operator|&
name|rbdr
operator|->
name|rbdr_task_nowait
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Finish the nowait task first */
name|taskqueue_drain
argument_list|(
name|rbdr
operator|->
name|rbdr_taskq
argument_list|,
operator|&
name|rbdr
operator|->
name|rbdr_task_nowait
argument_list|)
expr_stmt|;
block|}
name|taskqueue_free
argument_list|(
name|rbdr
operator|->
name|rbdr_taskq
argument_list|)
expr_stmt|;
name|rbdr
operator|->
name|rbdr_taskq
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|taskqueue_cancel
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|rbdr
operator|->
name|rbdr_task
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Now finish the sleepable task */
name|taskqueue_drain
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|rbdr
operator|->
name|rbdr_task
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Free all of the memory under the RB descriptors. 	 * There are assumptions here: 	 * 1. Corresponding RBDR is disabled 	 *    - it is safe to operate using head and tail indexes 	 * 2. All bffers that were received are properly freed by 	 *    the receive handler 	 *    - there is no need to unload DMA map and free MBUF for other 	 *      descriptors than unused ones 	 */
if|if
condition|(
name|rbdr
operator|->
name|rbdr_buff_dmat
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
name|rbdr
operator|->
name|head
expr_stmt|;
name|tail
operator|=
name|rbdr
operator|->
name|tail
expr_stmt|;
while|while
condition|(
name|head
operator|!=
name|tail
condition|)
block|{
name|desc
operator|=
name|GET_RBDR_DESC
argument_list|(
name|rbdr
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|buf_addr
operator|=
name|desc
operator|->
name|buf_addr
operator|<<
name|NICVF_RCV_BUF_ALIGN
expr_stmt|;
name|rinfo
operator|=
name|GET_RBUF_INFO
argument_list|(
name|PHYS_TO_DMAP
argument_list|(
name|buf_addr
argument_list|)
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rbdr
operator|->
name|rbdr_buff_dmat
argument_list|,
name|rinfo
operator|->
name|dmap
argument_list|)
expr_stmt|;
name|mbuf
operator|=
name|rinfo
operator|->
name|mbuf
expr_stmt|;
comment|/* This will destroy everything including rinfo! */
name|m_freem
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
name|head
operator|++
expr_stmt|;
name|head
operator|&=
operator|(
name|rbdr
operator|->
name|dmem
operator|.
name|q_len
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* Free tail descriptor */
name|desc
operator|=
name|GET_RBDR_DESC
argument_list|(
name|rbdr
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|buf_addr
operator|=
name|desc
operator|->
name|buf_addr
operator|<<
name|NICVF_RCV_BUF_ALIGN
expr_stmt|;
name|rinfo
operator|=
name|GET_RBUF_INFO
argument_list|(
name|PHYS_TO_DMAP
argument_list|(
name|buf_addr
argument_list|)
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rbdr
operator|->
name|rbdr_buff_dmat
argument_list|,
name|rinfo
operator|->
name|dmap
argument_list|)
expr_stmt|;
name|mbuf
operator|=
name|rinfo
operator|->
name|mbuf
expr_stmt|;
comment|/* This will destroy everything including rinfo! */
name|m_freem
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
comment|/* Destroy DMA maps */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|qs
operator|->
name|rbdr_len
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|rbdr
operator|->
name|rbdr_buff_dmaps
index|[
name|idx
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|err
operator|=
name|bus_dmamap_destroy
argument_list|(
name|rbdr
operator|->
name|rbdr_buff_dmat
argument_list|,
name|rbdr
operator|->
name|rbdr_buff_dmaps
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Could not destroy DMA map for RB, desc: %d"
operator|,
name|__func__
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
name|rbdr
operator|->
name|rbdr_buff_dmaps
index|[
name|idx
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now destroy the tag */
name|err
operator|=
name|bus_dma_tag_destroy
argument_list|(
name|rbdr
operator|->
name|rbdr_buff_dmat
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Trying to destroy BUSY DMA tag"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|rbdr
operator|->
name|head
operator|=
literal|0
expr_stmt|;
name|rbdr
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Free RBDR ring */
name|nicvf_free_q_desc_mem
argument_list|(
name|nic
argument_list|,
operator|&
name|rbdr
operator|->
name|dmem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Refill receive buffer descriptors with new buffers.  */
end_comment

begin_function
specifier|static
name|int
name|nicvf_refill_rbdr
parameter_list|(
name|struct
name|rbdr
modifier|*
name|rbdr
parameter_list|,
name|int
name|mflags
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
decl_stmt|;
name|int
name|rbdr_idx
decl_stmt|;
name|int
name|tail
decl_stmt|,
name|qcount
decl_stmt|;
name|int
name|refill_rb_cnt
decl_stmt|;
name|struct
name|rbdr_entry_t
modifier|*
name|desc
decl_stmt|;
name|bus_dmamap_t
name|dmap
decl_stmt|;
name|bus_addr_t
name|rbuf
decl_stmt|;
name|boolean_t
name|rb_alloc_fail
decl_stmt|;
name|int
name|new_rb
decl_stmt|;
name|rb_alloc_fail
operator|=
name|TRUE
expr_stmt|;
name|new_rb
operator|=
literal|0
expr_stmt|;
name|nic
operator|=
name|rbdr
operator|->
name|nic
expr_stmt|;
name|qs
operator|=
name|nic
operator|->
name|qs
expr_stmt|;
name|rbdr_idx
operator|=
name|rbdr
operator|->
name|idx
expr_stmt|;
comment|/* Check if it's enabled */
if|if
condition|(
operator|!
name|rbdr
operator|->
name|enable
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Get no of desc's to be refilled */
name|qcount
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_STATUS0
argument_list|,
name|rbdr_idx
argument_list|)
expr_stmt|;
name|qcount
operator|&=
literal|0x7FFFF
expr_stmt|;
comment|/* Doorbell can be ringed with a max of ring size minus 1 */
if|if
condition|(
name|qcount
operator|>=
operator|(
name|qs
operator|->
name|rbdr_len
operator|-
literal|1
operator|)
condition|)
block|{
name|rb_alloc_fail
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
name|refill_rb_cnt
operator|=
name|qs
operator|->
name|rbdr_len
operator|-
name|qcount
operator|-
literal|1
expr_stmt|;
comment|/* Start filling descs from tail */
name|tail
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_TAIL
argument_list|,
name|rbdr_idx
argument_list|)
operator|>>
literal|3
expr_stmt|;
while|while
condition|(
name|refill_rb_cnt
condition|)
block|{
name|tail
operator|++
expr_stmt|;
name|tail
operator|&=
operator|(
name|rbdr
operator|->
name|dmem
operator|.
name|q_len
operator|-
literal|1
operator|)
expr_stmt|;
name|dmap
operator|=
name|rbdr
operator|->
name|rbdr_buff_dmaps
index|[
name|tail
index|]
expr_stmt|;
if|if
condition|(
name|nicvf_alloc_rcv_buffer
argument_list|(
name|nic
argument_list|,
name|rbdr
argument_list|,
name|dmap
argument_list|,
name|mflags
argument_list|,
name|DMA_BUFFER_LEN
argument_list|,
operator|&
name|rbuf
argument_list|)
condition|)
block|{
comment|/* Something went wrong. Resign */
break|break;
block|}
name|desc
operator|=
name|GET_RBDR_DESC
argument_list|(
name|rbdr
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|desc
operator|->
name|buf_addr
operator|=
operator|(
name|rbuf
operator|>>
name|NICVF_RCV_BUF_ALIGN
operator|)
expr_stmt|;
name|refill_rb_cnt
operator|--
expr_stmt|;
name|new_rb
operator|++
expr_stmt|;
block|}
comment|/* make sure all memory stores are done before ringing doorbell */
name|wmb
argument_list|()
expr_stmt|;
comment|/* Check if buffer allocation failed */
if|if
condition|(
name|refill_rb_cnt
operator|==
literal|0
condition|)
name|rb_alloc_fail
operator|=
name|FALSE
expr_stmt|;
comment|/* Notify HW */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_DOOR
argument_list|,
name|rbdr_idx
argument_list|,
name|new_rb
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
operator|!
name|rb_alloc_fail
condition|)
block|{
comment|/* 		 * Re-enable RBDR interrupts only 		 * if buffer allocation is success. 		 */
name|nicvf_enable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_RBDR
argument_list|,
name|rbdr_idx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Refill RBs even if sleep is needed to reclaim memory */
end_comment

begin_function
specifier|static
name|void
name|nicvf_rbdr_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|rbdr
modifier|*
name|rbdr
decl_stmt|;
name|int
name|err
decl_stmt|;
name|rbdr
operator|=
operator|(
expr|struct
name|rbdr
operator|*
operator|)
name|arg
expr_stmt|;
name|err
operator|=
name|nicvf_refill_rbdr
argument_list|(
name|rbdr
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|err
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"%s: Failed to refill RBs even when sleep enabled"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Refill RBs as soon as possible without waiting */
end_comment

begin_function
specifier|static
name|void
name|nicvf_rbdr_task_nowait
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|rbdr
modifier|*
name|rbdr
decl_stmt|;
name|int
name|err
decl_stmt|;
name|rbdr
operator|=
operator|(
expr|struct
name|rbdr
operator|*
operator|)
name|arg
expr_stmt|;
name|err
operator|=
name|nicvf_refill_rbdr
argument_list|(
name|rbdr
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Schedule another, sleepable kernel thread 		 * that will for sure refill the buffers. 		 */
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|rbdr
operator|->
name|rbdr_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_rcv_pkt_handler
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|cmp_queue
modifier|*
name|cq
parameter_list|,
name|struct
name|cqe_rx_t
modifier|*
name|cqe_rx
parameter_list|,
name|int
name|cqe_type
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
name|struct
name|rcv_queue
modifier|*
name|rq
decl_stmt|;
name|int
name|rq_idx
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|rq_idx
operator|=
name|cqe_rx
operator|->
name|rq_idx
expr_stmt|;
name|rq
operator|=
operator|&
name|nic
operator|->
name|qs
operator|->
name|rq
index|[
name|rq_idx
index|]
expr_stmt|;
comment|/* Check for errors */
name|err
operator|=
name|nicvf_check_cqe_rx_errs
argument_list|(
name|nic
argument_list|,
name|cq
argument_list|,
name|cqe_rx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|!
name|cqe_rx
operator|->
name|rb_cnt
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mbuf
operator|=
name|nicvf_get_rcv_mbuf
argument_list|(
name|nic
argument_list|,
name|cqe_rx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbuf
operator|==
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Packet not received\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* If error packet */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|rq
operator|->
name|lro_enabled
operator|&&
operator|(
operator|(
name|cqe_rx
operator|->
name|l3_type
operator|==
name|L3TYPE_IPV4
operator|)
operator|&&
operator|(
name|cqe_rx
operator|->
name|l4_type
operator|==
name|L4TYPE_TCP
operator|)
operator|)
operator|&&
operator|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
operator|)
operator|==
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
condition|)
block|{
comment|/* 		 * At this point it is known that there are no errors in the 		 * packet. Attempt to LRO enqueue. Send to stack if no resources 		 * or enqueue error. 		 */
if|if
condition|(
operator|(
name|rq
operator|->
name|lro
operator|.
name|lro_cnt
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|tcp_lro_rx
argument_list|(
operator|&
name|rq
operator|->
name|lro
argument_list|,
name|mbuf
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Push this packet to the stack later to avoid 	 * unlocking completion task in the middle of work. 	 */
name|err
operator|=
name|buf_ring_enqueue
argument_list|(
name|cq
operator|->
name|rx_br
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Failed to enqueue this mbuf. 		 * We don't drop it, just schedule another task. 		 */
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_snd_pkt_handler
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|cmp_queue
modifier|*
name|cq
parameter_list|,
name|struct
name|cqe_send_t
modifier|*
name|cqe_tx
parameter_list|,
name|int
name|cqe_type
parameter_list|)
block|{
name|bus_dmamap_t
name|dmap
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
name|struct
name|snd_queue
modifier|*
name|sq
decl_stmt|;
name|struct
name|sq_hdr_subdesc
modifier|*
name|hdr
decl_stmt|;
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|sq
operator|=
operator|&
name|nic
operator|->
name|qs
operator|->
name|sq
index|[
name|cqe_tx
operator|->
name|sq_idx
index|]
expr_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|sq_hdr_subdesc
operator|*
operator|)
name|GET_SQ_DESC
argument_list|(
name|sq
argument_list|,
name|cqe_tx
operator|->
name|sqe_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|subdesc_type
operator|!=
name|SQ_DESC_TYPE_HEADER
condition|)
return|return;
name|dprintf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"%s Qset #%d SQ #%d SQ ptr #%d subdesc count %d\n"
argument_list|,
name|__func__
argument_list|,
name|cqe_tx
operator|->
name|sq_qs
argument_list|,
name|cqe_tx
operator|->
name|sq_idx
argument_list|,
name|cqe_tx
operator|->
name|sqe_ptr
argument_list|,
name|hdr
operator|->
name|subdesc_cnt
argument_list|)
expr_stmt|;
name|dmap
operator|=
operator|(
name|bus_dmamap_t
operator|)
name|sq
operator|->
name|snd_buff
index|[
name|cqe_tx
operator|->
name|sqe_ptr
index|]
operator|.
name|dmap
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sq
operator|->
name|snd_buff_dmat
argument_list|,
name|dmap
argument_list|)
expr_stmt|;
name|mbuf
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|sq
operator|->
name|snd_buff
index|[
name|cqe_tx
operator|->
name|sqe_ptr
index|]
operator|.
name|mbuf
expr_stmt|;
if|if
condition|(
name|mbuf
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
name|sq
operator|->
name|snd_buff
index|[
name|cqe_tx
operator|->
name|sqe_ptr
index|]
operator|.
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|nicvf_put_sq_desc
argument_list|(
name|sq
argument_list|,
name|hdr
operator|->
name|subdesc_cnt
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|nicvf_check_cqe_tx_errs
argument_list|(
name|nic
argument_list|,
name|cq
argument_list|,
name|cqe_tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_cq_intr_handler
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|uint8_t
name|cq_idx
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|processed_cqe
decl_stmt|,
name|work_done
init|=
literal|0
decl_stmt|,
name|tx_done
init|=
literal|0
decl_stmt|;
name|int
name|cqe_count
decl_stmt|,
name|cqe_head
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
init|=
name|nic
operator|->
name|qs
decl_stmt|;
name|struct
name|cmp_queue
modifier|*
name|cq
init|=
operator|&
name|qs
operator|->
name|cq
index|[
name|cq_idx
index|]
decl_stmt|;
name|struct
name|snd_queue
modifier|*
name|sq
init|=
operator|&
name|qs
operator|->
name|sq
index|[
name|cq_idx
index|]
decl_stmt|;
name|struct
name|rcv_queue
modifier|*
name|rq
decl_stmt|;
name|struct
name|cqe_rx_t
modifier|*
name|cq_desc
decl_stmt|;
name|struct
name|lro_ctrl
modifier|*
name|lro
decl_stmt|;
name|int
name|rq_idx
decl_stmt|;
name|int
name|cmp_err
decl_stmt|;
name|NICVF_CMP_LOCK
argument_list|(
name|cq
argument_list|)
expr_stmt|;
name|cmp_err
operator|=
literal|0
expr_stmt|;
name|processed_cqe
operator|=
literal|0
expr_stmt|;
comment|/* Get no of valid CQ entries to process */
name|cqe_count
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_STATUS
argument_list|,
name|cq_idx
argument_list|)
expr_stmt|;
name|cqe_count
operator|&=
name|CQ_CQE_COUNT
expr_stmt|;
if|if
condition|(
name|cqe_count
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Get head of the valid CQ entries */
name|cqe_head
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_HEAD
argument_list|,
name|cq_idx
argument_list|)
operator|>>
literal|9
expr_stmt|;
name|cqe_head
operator|&=
literal|0xFFFF
expr_stmt|;
name|dprintf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"%s CQ%d cqe_count %d cqe_head %d\n"
argument_list|,
name|__func__
argument_list|,
name|cq_idx
argument_list|,
name|cqe_count
argument_list|,
name|cqe_head
argument_list|)
expr_stmt|;
while|while
condition|(
name|processed_cqe
operator|<
name|cqe_count
condition|)
block|{
comment|/* Get the CQ descriptor */
name|cq_desc
operator|=
operator|(
expr|struct
name|cqe_rx_t
operator|*
operator|)
name|GET_CQ_DESC
argument_list|(
name|cq
argument_list|,
name|cqe_head
argument_list|)
expr_stmt|;
name|cqe_head
operator|++
expr_stmt|;
name|cqe_head
operator|&=
operator|(
name|cq
operator|->
name|dmem
operator|.
name|q_len
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Prefetch next CQ descriptor */
name|__builtin_prefetch
argument_list|(
operator|(
expr|struct
name|cqe_rx_t
operator|*
operator|)
name|GET_CQ_DESC
argument_list|(
name|cq
argument_list|,
name|cqe_head
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"CQ%d cq_desc->cqe_type %d\n"
argument_list|,
name|cq_idx
argument_list|,
name|cq_desc
operator|->
name|cqe_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cq_desc
operator|->
name|cqe_type
condition|)
block|{
case|case
name|CQE_TYPE_RX
case|:
name|cmp_err
operator|=
name|nicvf_rcv_pkt_handler
argument_list|(
name|nic
argument_list|,
name|cq
argument_list|,
name|cq_desc
argument_list|,
name|CQE_TYPE_RX
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|cmp_err
operator|!=
literal|0
argument_list|)
condition|)
block|{
comment|/* 				 * Ups. Cannot finish now. 				 * Let's try again later. 				 */
goto|goto
name|done
goto|;
block|}
name|work_done
operator|++
expr_stmt|;
break|break;
case|case
name|CQE_TYPE_SEND
case|:
name|nicvf_snd_pkt_handler
argument_list|(
name|nic
argument_list|,
name|cq
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cq_desc
argument_list|,
name|CQE_TYPE_SEND
argument_list|)
expr_stmt|;
name|tx_done
operator|++
expr_stmt|;
break|break;
case|case
name|CQE_TYPE_INVALID
case|:
case|case
name|CQE_TYPE_RX_SPLIT
case|:
case|case
name|CQE_TYPE_RX_TCP
case|:
case|case
name|CQE_TYPE_SEND_PTP
case|:
comment|/* Ignore for now */
break|break;
block|}
name|processed_cqe
operator|++
expr_stmt|;
block|}
name|done
label|:
name|dprintf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"%s CQ%d processed_cqe %d work_done %d\n"
argument_list|,
name|__func__
argument_list|,
name|cq_idx
argument_list|,
name|processed_cqe
argument_list|,
name|work_done
argument_list|)
expr_stmt|;
comment|/* Ring doorbell to inform H/W to reuse processed CQEs */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_DOOR
argument_list|,
name|cq_idx
argument_list|,
name|processed_cqe
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tx_done
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|if_getdrvflags
argument_list|(
name|nic
operator|->
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* Reenable TXQ if its stopped earlier due to SQ full */
name|if_setdrvflagbits
argument_list|(
name|nic
operator|->
name|ifp
argument_list|,
name|IFF_DRV_RUNNING
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sq
operator|->
name|snd_taskq
argument_list|,
operator|&
name|sq
operator|->
name|snd_task
argument_list|)
expr_stmt|;
block|}
name|out
label|:
comment|/* 	 * Flush any outstanding LRO work 	 */
name|rq_idx
operator|=
name|cq_idx
expr_stmt|;
name|rq
operator|=
operator|&
name|nic
operator|->
name|qs
operator|->
name|rq
index|[
name|rq_idx
index|]
expr_stmt|;
name|lro
operator|=
operator|&
name|rq
operator|->
name|lro
expr_stmt|;
name|tcp_lro_flush_all
argument_list|(
name|lro
argument_list|)
expr_stmt|;
name|NICVF_CMP_UNLOCK
argument_list|(
name|cq
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|nic
operator|->
name|ifp
expr_stmt|;
comment|/* Push received MBUFs to the stack */
while|while
condition|(
operator|!
name|buf_ring_empty
argument_list|(
name|cq
operator|->
name|rx_br
argument_list|)
condition|)
block|{
name|mbuf
operator|=
name|buf_ring_dequeue_mc
argument_list|(
name|cq
operator|->
name|rx_br
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|mbuf
operator|!=
name|NULL
argument_list|)
condition|)
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cmp_err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Qset error interrupt handler  *  * As of now only CQ errors are handled  */
end_comment

begin_function
specifier|static
name|void
name|nicvf_qs_err_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
decl_stmt|;
name|int
name|qidx
decl_stmt|;
name|uint64_t
name|status
decl_stmt|;
name|boolean_t
name|enable
init|=
name|TRUE
decl_stmt|;
name|nic
operator|=
operator|(
expr|struct
name|nicvf
operator|*
operator|)
name|arg
expr_stmt|;
name|qs
operator|=
name|nic
operator|->
name|qs
expr_stmt|;
comment|/* Deactivate network interface */
name|if_setdrvflagbits
argument_list|(
name|nic
operator|->
name|ifp
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|,
name|IFF_DRV_RUNNING
argument_list|)
expr_stmt|;
comment|/* Check if it is CQ err */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|cq_cnt
condition|;
name|qidx
operator|++
control|)
block|{
name|status
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_STATUS
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|CQ_ERR_MASK
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Process already queued CQEs and reconfig CQ */
name|nicvf_disable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_CQ
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|nicvf_sq_disable
argument_list|(
name|nic
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nicvf_cq_intr_handler
argument_list|(
name|nic
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|nicvf_cmp_queue_config
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|nicvf_sq_free_used_descs
argument_list|(
name|nic
argument_list|,
operator|&
name|qs
operator|->
name|sq
index|[
name|qidx
index|]
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|nicvf_sq_enable
argument_list|(
name|nic
argument_list|,
operator|&
name|qs
operator|->
name|sq
index|[
name|qidx
index|]
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|nicvf_enable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_CQ
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
block|}
name|if_setdrvflagbits
argument_list|(
name|nic
operator|->
name|ifp
argument_list|,
name|IFF_DRV_RUNNING
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
comment|/* Re-enable Qset error interrupt */
name|nicvf_enable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_QS_ERR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_cmp_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|cmp_queue
modifier|*
name|cq
decl_stmt|;
name|struct
name|nicvf
modifier|*
name|nic
decl_stmt|;
name|int
name|cmp_err
decl_stmt|;
name|cq
operator|=
operator|(
expr|struct
name|cmp_queue
operator|*
operator|)
name|arg
expr_stmt|;
name|nic
operator|=
name|cq
operator|->
name|nic
expr_stmt|;
comment|/* Handle CQ descriptors */
name|cmp_err
operator|=
name|nicvf_cq_intr_handler
argument_list|(
name|nic
argument_list|,
name|cq
operator|->
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|cmp_err
operator|!=
literal|0
argument_list|)
condition|)
block|{
comment|/* 		 * Schedule another thread here since we did not 		 * process the entire CQ due to Tx or Rx CQ parse error. 		 */
name|taskqueue_enqueue
argument_list|(
name|cq
operator|->
name|cmp_taskq
argument_list|,
operator|&
name|cq
operator|->
name|cmp_task
argument_list|)
expr_stmt|;
block|}
name|nicvf_clear_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_CQ
argument_list|,
name|cq
operator|->
name|idx
argument_list|)
expr_stmt|;
comment|/* Reenable interrupt (previously disabled in nicvf_intr_handler() */
name|nicvf_enable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_CQ
argument_list|,
name|cq
operator|->
name|idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize completion queue */
end_comment

begin_function
specifier|static
name|int
name|nicvf_init_cmp_queue
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|cmp_queue
modifier|*
name|cq
parameter_list|,
name|int
name|q_len
parameter_list|,
name|int
name|qidx
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
comment|/* Initizalize lock */
name|snprintf
argument_list|(
name|cq
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|cq
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s: CQ(%d) lock"
argument_list|,
name|device_get_nameunit
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|cq
operator|->
name|mtx
argument_list|,
name|cq
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|err
operator|=
name|nicvf_alloc_q_desc_mem
argument_list|(
name|nic
argument_list|,
operator|&
name|cq
operator|->
name|dmem
argument_list|,
name|q_len
argument_list|,
name|CMP_QUEUE_DESC_SIZE
argument_list|,
name|NICVF_CQ_BASE_ALIGN_BYTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Could not allocate DMA memory for CQ\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|cq
operator|->
name|desc
operator|=
name|cq
operator|->
name|dmem
operator|.
name|base
expr_stmt|;
name|cq
operator|->
name|thresh
operator|=
name|pass1_silicon
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
condition|?
literal|0
else|:
name|CMP_QUEUE_CQE_THRESH
expr_stmt|;
name|cq
operator|->
name|nic
operator|=
name|nic
expr_stmt|;
name|cq
operator|->
name|idx
operator|=
name|qidx
expr_stmt|;
name|nic
operator|->
name|cq_coalesce_usecs
operator|=
operator|(
name|CMP_QUEUE_TIMER_THRESH
operator|*
literal|0.05
operator|)
operator|-
literal|1
expr_stmt|;
name|cq
operator|->
name|rx_br
operator|=
name|buf_ring_alloc
argument_list|(
name|CMP_QUEUE_LEN
operator|*
literal|8
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
operator|&
name|cq
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* Allocate taskqueue */
name|TASK_INIT
argument_list|(
operator|&
name|cq
operator|->
name|cmp_task
argument_list|,
literal|0
argument_list|,
name|nicvf_cmp_task
argument_list|,
name|cq
argument_list|)
expr_stmt|;
name|cq
operator|->
name|cmp_taskq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"nicvf_cmp_taskq"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|cq
operator|->
name|cmp_taskq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|cq
operator|->
name|cmp_taskq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s: cmp_taskq(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_free_cmp_queue
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|cmp_queue
modifier|*
name|cq
parameter_list|)
block|{
if|if
condition|(
name|cq
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * The completion queue itself should be disabled by now 	 * (ref. nicvf_snd_queue_config()). 	 * Ensure that it is safe to disable it or panic. 	 */
if|if
condition|(
name|cq
operator|->
name|enable
condition|)
name|panic
argument_list|(
literal|"%s: Trying to free working CQ(%d)"
argument_list|,
name|__func__
argument_list|,
name|cq
operator|->
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|cq
operator|->
name|cmp_taskq
operator|!=
name|NULL
condition|)
block|{
comment|/* Remove task */
while|while
condition|(
name|taskqueue_cancel
argument_list|(
name|cq
operator|->
name|cmp_taskq
argument_list|,
operator|&
name|cq
operator|->
name|cmp_task
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|taskqueue_drain
argument_list|(
name|cq
operator|->
name|cmp_taskq
argument_list|,
operator|&
name|cq
operator|->
name|cmp_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|cq
operator|->
name|cmp_taskq
argument_list|)
expr_stmt|;
name|cq
operator|->
name|cmp_taskq
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Completion interrupt will possibly enable interrupts again 	 * so disable interrupting now after we finished processing 	 * completion task. It is safe to do so since the corresponding CQ 	 * was already disabled. 	 */
name|nicvf_disable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_CQ
argument_list|,
name|cq
operator|->
name|idx
argument_list|)
expr_stmt|;
name|nicvf_clear_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_CQ
argument_list|,
name|cq
operator|->
name|idx
argument_list|)
expr_stmt|;
name|NICVF_CMP_LOCK
argument_list|(
name|cq
argument_list|)
expr_stmt|;
name|nicvf_free_q_desc_mem
argument_list|(
name|nic
argument_list|,
operator|&
name|cq
operator|->
name|dmem
argument_list|)
expr_stmt|;
name|drbr_free
argument_list|(
name|cq
operator|->
name|rx_br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|NICVF_CMP_UNLOCK
argument_list|(
name|cq
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|cq
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cq
operator|->
name|mtx_name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cq
operator|->
name|mtx_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|nicvf_xmit_locked
parameter_list|(
name|struct
name|snd_queue
modifier|*
name|sq
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
name|int
name|err
decl_stmt|;
name|NICVF_TX_LOCK_ASSERT
argument_list|(
name|sq
argument_list|)
expr_stmt|;
name|nic
operator|=
name|sq
operator|->
name|nic
expr_stmt|;
name|ifp
operator|=
name|nic
operator|->
name|ifp
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
name|drbr_peek
argument_list|(
name|ifp
argument_list|,
name|sq
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Send a copy of the frame to the BPF listener */
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|err
operator|=
name|nicvf_tx_mbuf_locked
argument_list|(
name|sq
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|sq
operator|->
name|br
argument_list|)
expr_stmt|;
else|else
name|drbr_putback
argument_list|(
name|ifp
argument_list|,
name|sq
operator|->
name|br
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
block|}
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|sq
operator|->
name|br
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_snd_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|snd_queue
modifier|*
name|sq
init|=
operator|(
expr|struct
name|snd_queue
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|nicvf
modifier|*
name|nic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|nic
operator|=
name|sq
operator|->
name|nic
expr_stmt|;
name|ifp
operator|=
name|nic
operator|->
name|ifp
expr_stmt|;
comment|/* 	 * Skip sending anything if the driver is not running, 	 * SQ full or link is down. 	 */
if|if
condition|(
operator|(
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
operator|)
operator|||
operator|!
name|nic
operator|->
name|link_up
condition|)
return|return;
name|NICVF_TX_LOCK
argument_list|(
name|sq
argument_list|)
expr_stmt|;
name|err
operator|=
name|nicvf_xmit_locked
argument_list|(
name|sq
argument_list|)
expr_stmt|;
name|NICVF_TX_UNLOCK
argument_list|(
name|sq
argument_list|)
expr_stmt|;
comment|/* Try again */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|taskqueue_enqueue
argument_list|(
name|sq
operator|->
name|snd_taskq
argument_list|,
operator|&
name|sq
operator|->
name|snd_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize transmit queue */
end_comment

begin_function
specifier|static
name|int
name|nicvf_init_snd_queue
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|snd_queue
modifier|*
name|sq
parameter_list|,
name|int
name|q_len
parameter_list|,
name|int
name|qidx
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* Initizalize TX lock for this queue */
name|snprintf
argument_list|(
name|sq
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sq
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s: SQ(%d) lock"
argument_list|,
name|device_get_nameunit
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sq
operator|->
name|mtx
argument_list|,
name|sq
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|NICVF_TX_LOCK
argument_list|(
name|sq
argument_list|)
expr_stmt|;
comment|/* Allocate buffer ring */
name|sq
operator|->
name|br
operator|=
name|buf_ring_alloc
argument_list|(
name|q_len
operator|/
name|MIN_SQ_DESC_PER_PKT_XMIT
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
operator|&
name|sq
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|br
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"ERROR: Could not set up buf ring for SQ(%d)\n"
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Allocate DMA memory for Tx descriptors */
name|err
operator|=
name|nicvf_alloc_q_desc_mem
argument_list|(
name|nic
argument_list|,
operator|&
name|sq
operator|->
name|dmem
argument_list|,
name|q_len
argument_list|,
name|SND_QUEUE_DESC_SIZE
argument_list|,
name|NICVF_SQ_BASE_ALIGN_BYTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Could not allocate DMA memory for SQ\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|sq
operator|->
name|desc
operator|=
name|sq
operator|->
name|dmem
operator|.
name|base
expr_stmt|;
name|sq
operator|->
name|head
operator|=
name|sq
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|sq
operator|->
name|free_cnt
argument_list|,
name|q_len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sq
operator|->
name|thresh
operator|=
name|SND_QUEUE_THRESH
expr_stmt|;
name|sq
operator|->
name|idx
operator|=
name|qidx
expr_stmt|;
name|sq
operator|->
name|nic
operator|=
name|nic
expr_stmt|;
comment|/* 	 * Allocate DMA maps for Tx buffers 	 */
comment|/* Create DMA tag first */
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
argument_list|,
comment|/* parent tag */
literal|1
argument_list|,
comment|/* alignment */
literal|0
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filtfunc, filtfuncarg */
name|NICVF_TSO_MAXSIZE
argument_list|,
comment|/* maxsize */
name|NICVF_TSO_NSEGS
argument_list|,
comment|/* nsegments */
name|MCLBYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockfuncarg */
operator|&
name|sq
operator|->
name|snd_buff_dmat
argument_list|)
expr_stmt|;
comment|/* dmat */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Failed to create busdma tag for Tx buffers\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Allocate send buffers array */
name|sq
operator|->
name|snd_buff
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sq
operator|->
name|snd_buff
argument_list|)
operator|*
name|q_len
argument_list|,
name|M_NICVF
argument_list|,
operator|(
name|M_NOWAIT
operator||
name|M_ZERO
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|snd_buff
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Could not allocate memory for Tx buffers array\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Now populate maps */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|q_len
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|sq
operator|->
name|snd_buff_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|sq
operator|->
name|snd_buff
index|[
name|i
index|]
operator|.
name|dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Failed to create DMA maps for Tx buffers\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|NICVF_TX_UNLOCK
argument_list|(
name|sq
argument_list|)
expr_stmt|;
comment|/* Allocate taskqueue */
name|TASK_INIT
argument_list|(
operator|&
name|sq
operator|->
name|snd_task
argument_list|,
literal|0
argument_list|,
name|nicvf_snd_task
argument_list|,
name|sq
argument_list|)
expr_stmt|;
name|sq
operator|->
name|snd_taskq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"nicvf_snd_taskq"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sq
operator|->
name|snd_taskq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|sq
operator|->
name|snd_taskq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s: snd_taskq(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|NICVF_TX_UNLOCK
argument_list|(
name|sq
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_free_snd_queue
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|snd_queue
modifier|*
name|sq
parameter_list|)
block|{
name|struct
name|queue_set
modifier|*
name|qs
init|=
name|nic
operator|->
name|qs
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|sq
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|sq
operator|->
name|snd_taskq
operator|!=
name|NULL
condition|)
block|{
comment|/* Remove task */
while|while
condition|(
name|taskqueue_cancel
argument_list|(
name|sq
operator|->
name|snd_taskq
argument_list|,
operator|&
name|sq
operator|->
name|snd_task
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|taskqueue_drain
argument_list|(
name|sq
operator|->
name|snd_taskq
argument_list|,
operator|&
name|sq
operator|->
name|snd_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sq
operator|->
name|snd_taskq
argument_list|)
expr_stmt|;
name|sq
operator|->
name|snd_taskq
operator|=
name|NULL
expr_stmt|;
block|}
name|NICVF_TX_LOCK
argument_list|(
name|sq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|snd_buff_dmat
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sq
operator|->
name|snd_buff
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qs
operator|->
name|sq_len
condition|;
name|i
operator|++
control|)
block|{
name|m_freem
argument_list|(
name|sq
operator|->
name|snd_buff
index|[
name|i
index|]
operator|.
name|mbuf
argument_list|)
expr_stmt|;
name|sq
operator|->
name|snd_buff
index|[
name|i
index|]
operator|.
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sq
operator|->
name|snd_buff_dmat
argument_list|,
name|sq
operator|->
name|snd_buff
index|[
name|i
index|]
operator|.
name|dmap
argument_list|)
expr_stmt|;
name|err
operator|=
name|bus_dmamap_destroy
argument_list|(
name|sq
operator|->
name|snd_buff_dmat
argument_list|,
name|sq
operator|->
name|snd_buff
index|[
name|i
index|]
operator|.
name|dmap
argument_list|)
expr_stmt|;
comment|/* 				 * If bus_dmamap_destroy fails it can cause 				 * random panic later if the tag is also 				 * destroyed in the process. 				 */
name|KASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Could not destroy DMA map for SQ"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|sq
operator|->
name|snd_buff
argument_list|,
name|M_NICVF
argument_list|)
expr_stmt|;
name|err
operator|=
name|bus_dma_tag_destroy
argument_list|(
name|sq
operator|->
name|snd_buff_dmat
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Trying to destroy BUSY DMA tag"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Free private driver ring for this send queue */
if|if
condition|(
name|sq
operator|->
name|br
operator|!=
name|NULL
condition|)
name|drbr_free
argument_list|(
name|sq
operator|->
name|br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|dmem
operator|.
name|base
operator|!=
name|NULL
condition|)
name|nicvf_free_q_desc_mem
argument_list|(
name|nic
argument_list|,
operator|&
name|sq
operator|->
name|dmem
argument_list|)
expr_stmt|;
name|NICVF_TX_UNLOCK
argument_list|(
name|sq
argument_list|)
expr_stmt|;
comment|/* Destroy Tx lock */
name|mtx_destroy
argument_list|(
operator|&
name|sq
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sq
operator|->
name|mtx_name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sq
operator|->
name|mtx_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_reclaim_snd_queue
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|queue_set
modifier|*
name|qs
parameter_list|,
name|int
name|qidx
parameter_list|)
block|{
comment|/* Disable send queue */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check if SQ is stopped */
if|if
condition|(
name|nicvf_poll_reg
argument_list|(
name|nic
argument_list|,
name|qidx
argument_list|,
name|NIC_QSET_SQ_0_7_STATUS
argument_list|,
literal|21
argument_list|,
literal|1
argument_list|,
literal|0x01
argument_list|)
condition|)
return|return;
comment|/* Reset send queue */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
name|NICVF_SQ_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_reclaim_rcv_queue
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|queue_set
modifier|*
name|qs
parameter_list|,
name|int
name|qidx
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
comment|/* Make sure all packets in the pipeline are written back into mem */
name|mbx
operator|.
name|msg
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_RQ_SW_SYNC
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_reclaim_cmp_queue
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|queue_set
modifier|*
name|qs
parameter_list|,
name|int
name|qidx
parameter_list|)
block|{
comment|/* Disable timer threshold (doesn't get reset upon CQ reset */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_CFG2
argument_list|,
name|qidx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable completion queue */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset completion queue */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
name|NICVF_CQ_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_reclaim_rbdr
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|rbdr
modifier|*
name|rbdr
parameter_list|,
name|int
name|qidx
parameter_list|)
block|{
name|uint64_t
name|tmp
decl_stmt|,
name|fifo_state
decl_stmt|;
name|int
name|timeout
init|=
literal|10
decl_stmt|;
comment|/* Save head and tail pointers for feeing up buffers */
name|rbdr
operator|->
name|head
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_HEAD
argument_list|,
name|qidx
argument_list|)
operator|>>
literal|3
expr_stmt|;
name|rbdr
operator|->
name|tail
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_TAIL
argument_list|,
name|qidx
argument_list|)
operator|>>
literal|3
expr_stmt|;
comment|/* 	 * If RBDR FIFO is in 'FAIL' state then do a reset first 	 * before relaiming. 	 */
name|fifo_state
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_STATUS0
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|fifo_state
operator|>>
literal|62
operator|)
operator|&
literal|0x03
operator|)
operator|==
literal|0x3
condition|)
block|{
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_CFG
argument_list|,
name|qidx
argument_list|,
name|NICVF_RBDR_RESET
argument_list|)
expr_stmt|;
block|}
comment|/* Disable RBDR */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_CFG
argument_list|,
name|qidx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nicvf_poll_reg
argument_list|(
name|nic
argument_list|,
name|qidx
argument_list|,
name|NIC_QSET_RBDR_0_1_STATUS0
argument_list|,
literal|62
argument_list|,
literal|2
argument_list|,
literal|0x00
argument_list|)
condition|)
return|return;
while|while
condition|(
literal|1
condition|)
block|{
name|tmp
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_PREFETCH_STATUS
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|&
literal|0xFFFFFFFF
operator|)
operator|==
operator|(
operator|(
name|tmp
operator|>>
literal|32
operator|)
operator|&
literal|0xFFFFFFFF
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Failed polling on prefetch status\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_CFG
argument_list|,
name|qidx
argument_list|,
name|NICVF_RBDR_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|nicvf_poll_reg
argument_list|(
name|nic
argument_list|,
name|qidx
argument_list|,
name|NIC_QSET_RBDR_0_1_STATUS0
argument_list|,
literal|62
argument_list|,
literal|2
argument_list|,
literal|0x02
argument_list|)
condition|)
return|return;
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_CFG
argument_list|,
name|qidx
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
if|if
condition|(
name|nicvf_poll_reg
argument_list|(
name|nic
argument_list|,
name|qidx
argument_list|,
name|NIC_QSET_RBDR_0_1_STATUS0
argument_list|,
literal|62
argument_list|,
literal|2
argument_list|,
literal|0x00
argument_list|)
condition|)
return|return;
block|}
end_function

begin_comment
comment|/* Configures receive queue */
end_comment

begin_function
specifier|static
name|void
name|nicvf_rcv_queue_config
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|queue_set
modifier|*
name|qs
parameter_list|,
name|int
name|qidx
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|struct
name|rcv_queue
modifier|*
name|rq
decl_stmt|;
name|struct
name|rq_cfg
name|rq_cfg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|lro_ctrl
modifier|*
name|lro
decl_stmt|;
name|ifp
operator|=
name|nic
operator|->
name|ifp
expr_stmt|;
name|rq
operator|=
operator|&
name|qs
operator|->
name|rq
index|[
name|qidx
index|]
expr_stmt|;
name|rq
operator|->
name|enable
operator|=
name|enable
expr_stmt|;
name|lro
operator|=
operator|&
name|rq
operator|->
name|lro
expr_stmt|;
comment|/* Disable receive queue */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rq
operator|->
name|enable
condition|)
block|{
name|nicvf_reclaim_rcv_queue
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
comment|/* Free LRO memory */
name|tcp_lro_free
argument_list|(
name|lro
argument_list|)
expr_stmt|;
name|rq
operator|->
name|lro_enabled
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
comment|/* Configure LRO if enabled */
name|rq
operator|->
name|lro_enabled
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_LRO
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tcp_lro_init
argument_list|(
name|lro
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Failed to initialize LRO for RXQ%d\n"
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rq
operator|->
name|lro_enabled
operator|=
name|TRUE
expr_stmt|;
name|lro
operator|->
name|ifp
operator|=
name|nic
operator|->
name|ifp
expr_stmt|;
block|}
block|}
name|rq
operator|->
name|cq_qs
operator|=
name|qs
operator|->
name|vnic_id
expr_stmt|;
name|rq
operator|->
name|cq_idx
operator|=
name|qidx
expr_stmt|;
name|rq
operator|->
name|start_rbdr_qs
operator|=
name|qs
operator|->
name|vnic_id
expr_stmt|;
name|rq
operator|->
name|start_qs_rbdr_idx
operator|=
name|qs
operator|->
name|rbdr_cnt
operator|-
literal|1
expr_stmt|;
name|rq
operator|->
name|cont_rbdr_qs
operator|=
name|qs
operator|->
name|vnic_id
expr_stmt|;
name|rq
operator|->
name|cont_qs_rbdr_idx
operator|=
name|qs
operator|->
name|rbdr_cnt
operator|-
literal|1
expr_stmt|;
comment|/* all writes of RBDR data to be loaded into L2 Cache as well*/
name|rq
operator|->
name|caching
operator|=
literal|1
expr_stmt|;
comment|/* Send a mailbox msg to PF to config RQ */
name|mbx
operator|.
name|rq
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_RQ_CFG
expr_stmt|;
name|mbx
operator|.
name|rq
operator|.
name|qs_num
operator|=
name|qs
operator|->
name|vnic_id
expr_stmt|;
name|mbx
operator|.
name|rq
operator|.
name|rq_num
operator|=
name|qidx
expr_stmt|;
name|mbx
operator|.
name|rq
operator|.
name|cfg
operator|=
operator|(
name|rq
operator|->
name|caching
operator|<<
literal|26
operator|)
operator||
operator|(
name|rq
operator|->
name|cq_qs
operator|<<
literal|19
operator|)
operator||
operator|(
name|rq
operator|->
name|cq_idx
operator|<<
literal|16
operator|)
operator||
operator|(
name|rq
operator|->
name|cont_rbdr_qs
operator|<<
literal|9
operator|)
operator||
operator|(
name|rq
operator|->
name|cont_qs_rbdr_idx
operator|<<
literal|8
operator|)
operator||
operator|(
name|rq
operator|->
name|start_rbdr_qs
operator|<<
literal|1
operator|)
operator||
operator|(
name|rq
operator|->
name|start_qs_rbdr_idx
operator|)
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
name|mbx
operator|.
name|rq
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_RQ_BP_CFG
expr_stmt|;
name|mbx
operator|.
name|rq
operator|.
name|cfg
operator|=
operator|(
literal|1UL
operator|<<
literal|63
operator|)
operator||
operator|(
literal|1UL
operator|<<
literal|62
operator|)
operator||
operator|(
name|qs
operator|->
name|vnic_id
operator|<<
literal|0
operator|)
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
comment|/* 	 * RQ drop config 	 * Enable CQ drop to reserve sufficient CQEs for all tx packets 	 */
name|mbx
operator|.
name|rq
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_RQ_DROP_CFG
expr_stmt|;
name|mbx
operator|.
name|rq
operator|.
name|cfg
operator|=
operator|(
literal|1UL
operator|<<
literal|62
operator|)
operator||
operator|(
name|RQ_CQ_DROP
operator|<<
literal|8
operator|)
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RQ_GEN_CFG
argument_list|,
literal|0
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Enable Receive queue */
name|rq_cfg
operator|.
name|ena
operator|=
literal|1
expr_stmt|;
name|rq_cfg
operator|.
name|tcp_ena
operator|=
literal|0
expr_stmt|;
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|rq_cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Configures completion queue */
end_comment

begin_function
specifier|static
name|void
name|nicvf_cmp_queue_config
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|queue_set
modifier|*
name|qs
parameter_list|,
name|int
name|qidx
parameter_list|,
name|boolean_t
name|enable
parameter_list|)
block|{
name|struct
name|cmp_queue
modifier|*
name|cq
decl_stmt|;
name|struct
name|cq_cfg
name|cq_cfg
decl_stmt|;
name|cq
operator|=
operator|&
name|qs
operator|->
name|cq
index|[
name|qidx
index|]
expr_stmt|;
name|cq
operator|->
name|enable
operator|=
name|enable
expr_stmt|;
if|if
condition|(
operator|!
name|cq
operator|->
name|enable
condition|)
block|{
name|nicvf_reclaim_cmp_queue
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Reset completion queue */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
name|NICVF_CQ_RESET
argument_list|)
expr_stmt|;
comment|/* Set completion queue base address */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_BASE
argument_list|,
name|qidx
argument_list|,
call|(
name|uint64_t
call|)
argument_list|(
name|cq
operator|->
name|dmem
operator|.
name|phys_base
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable Completion queue */
name|cq_cfg
operator|.
name|ena
operator|=
literal|1
expr_stmt|;
name|cq_cfg
operator|.
name|reset
operator|=
literal|0
expr_stmt|;
name|cq_cfg
operator|.
name|caching
operator|=
literal|0
expr_stmt|;
name|cq_cfg
operator|.
name|qsize
operator|=
name|CMP_QSIZE
expr_stmt|;
name|cq_cfg
operator|.
name|avg_con
operator|=
literal|0
expr_stmt|;
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|cq_cfg
argument_list|)
expr_stmt|;
comment|/* Set threshold value for interrupt generation */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_THRESH
argument_list|,
name|qidx
argument_list|,
name|cq
operator|->
name|thresh
argument_list|)
expr_stmt|;
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_CFG2
argument_list|,
name|qidx
argument_list|,
name|nic
operator|->
name|cq_coalesce_usecs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Configures transmit queue */
end_comment

begin_function
specifier|static
name|void
name|nicvf_snd_queue_config
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|queue_set
modifier|*
name|qs
parameter_list|,
name|int
name|qidx
parameter_list|,
name|boolean_t
name|enable
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|struct
name|snd_queue
modifier|*
name|sq
decl_stmt|;
name|struct
name|sq_cfg
name|sq_cfg
decl_stmt|;
name|sq
operator|=
operator|&
name|qs
operator|->
name|sq
index|[
name|qidx
index|]
expr_stmt|;
name|sq
operator|->
name|enable
operator|=
name|enable
expr_stmt|;
if|if
condition|(
operator|!
name|sq
operator|->
name|enable
condition|)
block|{
name|nicvf_reclaim_snd_queue
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Reset send queue */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
name|NICVF_SQ_RESET
argument_list|)
expr_stmt|;
name|sq
operator|->
name|cq_qs
operator|=
name|qs
operator|->
name|vnic_id
expr_stmt|;
name|sq
operator|->
name|cq_idx
operator|=
name|qidx
expr_stmt|;
comment|/* Send a mailbox msg to PF to config SQ */
name|mbx
operator|.
name|sq
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_SQ_CFG
expr_stmt|;
name|mbx
operator|.
name|sq
operator|.
name|qs_num
operator|=
name|qs
operator|->
name|vnic_id
expr_stmt|;
name|mbx
operator|.
name|sq
operator|.
name|sq_num
operator|=
name|qidx
expr_stmt|;
name|mbx
operator|.
name|sq
operator|.
name|sqs_mode
operator|=
name|nic
operator|->
name|sqs_mode
expr_stmt|;
name|mbx
operator|.
name|sq
operator|.
name|cfg
operator|=
operator|(
name|sq
operator|->
name|cq_qs
operator|<<
literal|3
operator|)
operator||
name|sq
operator|->
name|cq_idx
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
comment|/* Set queue base address */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_BASE
argument_list|,
name|qidx
argument_list|,
call|(
name|uint64_t
call|)
argument_list|(
name|sq
operator|->
name|dmem
operator|.
name|phys_base
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable send queue& set queue size */
name|sq_cfg
operator|.
name|ena
operator|=
literal|1
expr_stmt|;
name|sq_cfg
operator|.
name|reset
operator|=
literal|0
expr_stmt|;
name|sq_cfg
operator|.
name|ldwb
operator|=
literal|0
expr_stmt|;
name|sq_cfg
operator|.
name|qsize
operator|=
name|SND_QSIZE
expr_stmt|;
name|sq_cfg
operator|.
name|tstmp_bgx_intf
operator|=
literal|0
expr_stmt|;
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|sq_cfg
argument_list|)
expr_stmt|;
comment|/* Set threshold value for interrupt generation */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_THRESH
argument_list|,
name|qidx
argument_list|,
name|sq
operator|->
name|thresh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Configures receive buffer descriptor ring */
end_comment

begin_function
specifier|static
name|void
name|nicvf_rbdr_config
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|queue_set
modifier|*
name|qs
parameter_list|,
name|int
name|qidx
parameter_list|,
name|boolean_t
name|enable
parameter_list|)
block|{
name|struct
name|rbdr
modifier|*
name|rbdr
decl_stmt|;
name|struct
name|rbdr_cfg
name|rbdr_cfg
decl_stmt|;
name|rbdr
operator|=
operator|&
name|qs
operator|->
name|rbdr
index|[
name|qidx
index|]
expr_stmt|;
name|nicvf_reclaim_rbdr
argument_list|(
name|nic
argument_list|,
name|rbdr
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
return|return;
comment|/* Set descriptor base address */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_BASE
argument_list|,
name|qidx
argument_list|,
call|(
name|uint64_t
call|)
argument_list|(
name|rbdr
operator|->
name|dmem
operator|.
name|phys_base
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable RBDR& set queue size */
comment|/* Buffer size should be in multiples of 128 bytes */
name|rbdr_cfg
operator|.
name|ena
operator|=
literal|1
expr_stmt|;
name|rbdr_cfg
operator|.
name|reset
operator|=
literal|0
expr_stmt|;
name|rbdr_cfg
operator|.
name|ldwb
operator|=
literal|0
expr_stmt|;
name|rbdr_cfg
operator|.
name|qsize
operator|=
name|RBDR_SIZE
expr_stmt|;
name|rbdr_cfg
operator|.
name|avg_con
operator|=
literal|0
expr_stmt|;
name|rbdr_cfg
operator|.
name|lines
operator|=
name|rbdr
operator|->
name|dma_size
operator|/
literal|128
expr_stmt|;
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_CFG
argument_list|,
name|qidx
argument_list|,
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|rbdr_cfg
argument_list|)
expr_stmt|;
comment|/* Notify HW */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_DOOR
argument_list|,
name|qidx
argument_list|,
name|qs
operator|->
name|rbdr_len
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Set threshold value for interrupt generation */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_THRESH
argument_list|,
name|qidx
argument_list|,
name|rbdr
operator|->
name|thresh
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Requests PF to assign and enable Qset */
end_comment

begin_function
name|void
name|nicvf_qset_config
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|boolean_t
name|enable
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
decl_stmt|;
name|struct
name|qs_cfg
modifier|*
name|qs_cfg
decl_stmt|;
name|qs
operator|=
name|nic
operator|->
name|qs
expr_stmt|;
if|if
condition|(
name|qs
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Qset is still not allocated, don't init queues\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|qs
operator|->
name|enable
operator|=
name|enable
expr_stmt|;
name|qs
operator|->
name|vnic_id
operator|=
name|nic
operator|->
name|vf_id
expr_stmt|;
comment|/* Send a mailbox msg to PF to config Qset */
name|mbx
operator|.
name|qs
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_QS_CFG
expr_stmt|;
name|mbx
operator|.
name|qs
operator|.
name|num
operator|=
name|qs
operator|->
name|vnic_id
expr_stmt|;
name|mbx
operator|.
name|qs
operator|.
name|cfg
operator|=
literal|0
expr_stmt|;
name|qs_cfg
operator|=
operator|(
expr|struct
name|qs_cfg
operator|*
operator|)
operator|&
name|mbx
operator|.
name|qs
operator|.
name|cfg
expr_stmt|;
if|if
condition|(
name|qs
operator|->
name|enable
condition|)
block|{
name|qs_cfg
operator|->
name|ena
operator|=
literal|1
expr_stmt|;
name|qs_cfg
operator|->
name|vnic
operator|=
name|qs
operator|->
name|vnic_id
expr_stmt|;
block|}
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_free_resources
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|qidx
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
decl_stmt|;
name|qs
operator|=
name|nic
operator|->
name|qs
expr_stmt|;
comment|/* 	 * Remove QS error task first since it has to be dead 	 * to safely free completion queue tasks. 	 */
if|if
condition|(
name|qs
operator|->
name|qs_err_taskq
operator|!=
name|NULL
condition|)
block|{
comment|/* Shut down QS error tasks */
while|while
condition|(
name|taskqueue_cancel
argument_list|(
name|qs
operator|->
name|qs_err_taskq
argument_list|,
operator|&
name|qs
operator|->
name|qs_err_task
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|qs
operator|->
name|qs_err_taskq
argument_list|,
operator|&
name|qs
operator|->
name|qs_err_task
argument_list|)
expr_stmt|;
block|}
name|taskqueue_free
argument_list|(
name|qs
operator|->
name|qs_err_taskq
argument_list|)
expr_stmt|;
name|qs
operator|->
name|qs_err_taskq
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Free receive buffer descriptor ring */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|rbdr_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_free_rbdr
argument_list|(
name|nic
argument_list|,
operator|&
name|qs
operator|->
name|rbdr
index|[
name|qidx
index|]
argument_list|)
expr_stmt|;
comment|/* Free completion queue */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|cq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_free_cmp_queue
argument_list|(
name|nic
argument_list|,
operator|&
name|qs
operator|->
name|cq
index|[
name|qidx
index|]
argument_list|)
expr_stmt|;
comment|/* Free send queue */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|sq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_free_snd_queue
argument_list|(
name|nic
argument_list|,
operator|&
name|qs
operator|->
name|sq
index|[
name|qidx
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_alloc_resources
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|struct
name|queue_set
modifier|*
name|qs
init|=
name|nic
operator|->
name|qs
decl_stmt|;
name|int
name|qidx
decl_stmt|;
comment|/* Alloc receive buffer descriptor ring */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|rbdr_cnt
condition|;
name|qidx
operator|++
control|)
block|{
if|if
condition|(
name|nicvf_init_rbdr
argument_list|(
name|nic
argument_list|,
operator|&
name|qs
operator|->
name|rbdr
index|[
name|qidx
index|]
argument_list|,
name|qs
operator|->
name|rbdr_len
argument_list|,
name|DMA_BUFFER_LEN
argument_list|,
name|qidx
argument_list|)
condition|)
goto|goto
name|alloc_fail
goto|;
block|}
comment|/* Alloc send queue */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|sq_cnt
condition|;
name|qidx
operator|++
control|)
block|{
if|if
condition|(
name|nicvf_init_snd_queue
argument_list|(
name|nic
argument_list|,
operator|&
name|qs
operator|->
name|sq
index|[
name|qidx
index|]
argument_list|,
name|qs
operator|->
name|sq_len
argument_list|,
name|qidx
argument_list|)
condition|)
goto|goto
name|alloc_fail
goto|;
block|}
comment|/* Alloc completion queue */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|cq_cnt
condition|;
name|qidx
operator|++
control|)
block|{
if|if
condition|(
name|nicvf_init_cmp_queue
argument_list|(
name|nic
argument_list|,
operator|&
name|qs
operator|->
name|cq
index|[
name|qidx
index|]
argument_list|,
name|qs
operator|->
name|cq_len
argument_list|,
name|qidx
argument_list|)
condition|)
goto|goto
name|alloc_fail
goto|;
block|}
comment|/* Allocate QS error taskqueue */
name|TASK_INIT
argument_list|(
operator|&
name|qs
operator|->
name|qs_err_task
argument_list|,
literal|0
argument_list|,
name|nicvf_qs_err_task
argument_list|,
name|nic
argument_list|)
expr_stmt|;
name|qs
operator|->
name|qs_err_taskq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"nicvf_qs_err_taskq"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|qs
operator|->
name|qs_err_taskq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|qs
operator|->
name|qs_err_taskq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s: qs_taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|alloc_fail
label|:
name|nicvf_free_resources
argument_list|(
name|nic
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nicvf_set_qset_resources
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|struct
name|queue_set
modifier|*
name|qs
decl_stmt|;
name|qs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|qs
argument_list|)
argument_list|,
name|M_NICVF
argument_list|,
operator|(
name|M_ZERO
operator||
name|M_WAITOK
operator|)
argument_list|)
expr_stmt|;
name|nic
operator|->
name|qs
operator|=
name|qs
expr_stmt|;
comment|/* Set count of each queue */
name|qs
operator|->
name|rbdr_cnt
operator|=
name|RBDR_CNT
expr_stmt|;
name|qs
operator|->
name|rq_cnt
operator|=
name|RCV_QUEUE_CNT
expr_stmt|;
name|qs
operator|->
name|sq_cnt
operator|=
name|SND_QUEUE_CNT
expr_stmt|;
name|qs
operator|->
name|cq_cnt
operator|=
name|CMP_QUEUE_CNT
expr_stmt|;
comment|/* Set queue lengths */
name|qs
operator|->
name|rbdr_len
operator|=
name|RCV_BUF_COUNT
expr_stmt|;
name|qs
operator|->
name|sq_len
operator|=
name|SND_QUEUE_LEN
expr_stmt|;
name|qs
operator|->
name|cq_len
operator|=
name|CMP_QUEUE_LEN
expr_stmt|;
name|nic
operator|->
name|rx_queues
operator|=
name|qs
operator|->
name|rq_cnt
expr_stmt|;
name|nic
operator|->
name|tx_queues
operator|=
name|qs
operator|->
name|sq_cnt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nicvf_config_data_transfer
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|boolean_t
name|enable
parameter_list|)
block|{
name|boolean_t
name|disable
init|=
name|FALSE
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
decl_stmt|;
name|int
name|qidx
decl_stmt|;
name|qs
operator|=
name|nic
operator|->
name|qs
expr_stmt|;
if|if
condition|(
name|qs
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|enable
condition|)
block|{
if|if
condition|(
name|nicvf_alloc_resources
argument_list|(
name|nic
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|sq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_snd_queue_config
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|,
name|enable
argument_list|)
expr_stmt|;
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|cq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_cmp_queue_config
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|,
name|enable
argument_list|)
expr_stmt|;
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|rbdr_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_rbdr_config
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|,
name|enable
argument_list|)
expr_stmt|;
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|rq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_rcv_queue_config
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|,
name|enable
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|rq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_rcv_queue_config
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|,
name|disable
argument_list|)
expr_stmt|;
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|rbdr_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_rbdr_config
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|,
name|disable
argument_list|)
expr_stmt|;
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|sq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_snd_queue_config
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|,
name|disable
argument_list|)
expr_stmt|;
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|cq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_cmp_queue_config
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|,
name|disable
argument_list|)
expr_stmt|;
name|nicvf_free_resources
argument_list|(
name|nic
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a free desc from SQ  * returns descriptor ponter& descriptor number  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|nicvf_get_sq_desc
parameter_list|(
name|struct
name|snd_queue
modifier|*
name|sq
parameter_list|,
name|int
name|desc_cnt
parameter_list|)
block|{
name|int
name|qentry
decl_stmt|;
name|qentry
operator|=
name|sq
operator|->
name|tail
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|sq
operator|->
name|free_cnt
argument_list|,
name|desc_cnt
argument_list|)
expr_stmt|;
name|sq
operator|->
name|tail
operator|+=
name|desc_cnt
expr_stmt|;
name|sq
operator|->
name|tail
operator|&=
operator|(
name|sq
operator|->
name|dmem
operator|.
name|q_len
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|qentry
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free descriptor back to SQ for future use */
end_comment

begin_function
specifier|static
name|void
name|nicvf_put_sq_desc
parameter_list|(
name|struct
name|snd_queue
modifier|*
name|sq
parameter_list|,
name|int
name|desc_cnt
parameter_list|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|sq
operator|->
name|free_cnt
argument_list|,
name|desc_cnt
argument_list|)
expr_stmt|;
name|sq
operator|->
name|head
operator|+=
name|desc_cnt
expr_stmt|;
name|sq
operator|->
name|head
operator|&=
operator|(
name|sq
operator|->
name|dmem
operator|.
name|q_len
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|nicvf_get_nxt_sqentry
parameter_list|(
name|struct
name|snd_queue
modifier|*
name|sq
parameter_list|,
name|int
name|qentry
parameter_list|)
block|{
name|qentry
operator|++
expr_stmt|;
name|qentry
operator|&=
operator|(
name|sq
operator|->
name|dmem
operator|.
name|q_len
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|qentry
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_sq_enable
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|snd_queue
modifier|*
name|sq
parameter_list|,
name|int
name|qidx
parameter_list|)
block|{
name|uint64_t
name|sq_cfg
decl_stmt|;
name|sq_cfg
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_CFG
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|sq_cfg
operator||=
name|NICVF_SQ_EN
expr_stmt|;
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
name|sq_cfg
argument_list|)
expr_stmt|;
comment|/* Ring doorbell so that H/W restarts processing SQEs */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_DOOR
argument_list|,
name|qidx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_sq_disable
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|int
name|qidx
parameter_list|)
block|{
name|uint64_t
name|sq_cfg
decl_stmt|;
name|sq_cfg
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_CFG
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|sq_cfg
operator|&=
operator|~
name|NICVF_SQ_EN
expr_stmt|;
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
name|sq_cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_sq_free_used_descs
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|snd_queue
modifier|*
name|sq
parameter_list|,
name|int
name|qidx
parameter_list|)
block|{
name|uint64_t
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|struct
name|snd_buff
modifier|*
name|snd_buff
decl_stmt|;
name|struct
name|sq_hdr_subdesc
modifier|*
name|hdr
decl_stmt|;
name|NICVF_TX_LOCK
argument_list|(
name|sq
argument_list|)
expr_stmt|;
name|head
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_HEAD
argument_list|,
name|qidx
argument_list|)
operator|>>
literal|4
expr_stmt|;
name|tail
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_TAIL
argument_list|,
name|qidx
argument_list|)
operator|>>
literal|4
expr_stmt|;
while|while
condition|(
name|sq
operator|->
name|head
operator|!=
name|head
condition|)
block|{
name|hdr
operator|=
operator|(
expr|struct
name|sq_hdr_subdesc
operator|*
operator|)
name|GET_SQ_DESC
argument_list|(
name|sq
argument_list|,
name|sq
operator|->
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|subdesc_type
operator|!=
name|SQ_DESC_TYPE_HEADER
condition|)
block|{
name|nicvf_put_sq_desc
argument_list|(
name|sq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|snd_buff
operator|=
operator|&
name|sq
operator|->
name|snd_buff
index|[
name|sq
operator|->
name|head
index|]
expr_stmt|;
if|if
condition|(
name|snd_buff
operator|->
name|mbuf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sq
operator|->
name|snd_buff_dmat
argument_list|,
name|snd_buff
operator|->
name|dmap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|snd_buff
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|sq
operator|->
name|snd_buff
index|[
name|sq
operator|->
name|head
index|]
operator|.
name|mbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|nicvf_put_sq_desc
argument_list|(
name|sq
argument_list|,
name|hdr
operator|->
name|subdesc_cnt
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|NICVF_TX_UNLOCK
argument_list|(
name|sq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add SQ HEADER subdescriptor.  * First subdescriptor for every send descriptor.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|nicvf_sq_add_hdr_subdesc
parameter_list|(
name|struct
name|snd_queue
modifier|*
name|sq
parameter_list|,
name|int
name|qentry
parameter_list|,
name|int
name|subdesc_cnt
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
decl_stmt|;
name|struct
name|sq_hdr_subdesc
modifier|*
name|hdr
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
endif|#
directive|endif
name|uint16_t
name|etype
decl_stmt|;
name|int
name|ehdrlen
decl_stmt|,
name|iphlen
decl_stmt|,
name|poff
decl_stmt|,
name|proto
decl_stmt|;
name|nic
operator|=
name|sq
operator|->
name|nic
expr_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|sq_hdr_subdesc
operator|*
operator|)
name|GET_SQ_DESC
argument_list|(
name|sq
argument_list|,
name|qentry
argument_list|)
expr_stmt|;
name|sq
operator|->
name|snd_buff
index|[
name|qentry
index|]
operator|.
name|mbuf
operator|=
name|mbuf
expr_stmt|;
name|memset
argument_list|(
name|hdr
argument_list|,
literal|0
argument_list|,
name|SND_QUEUE_DESC_SIZE
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|subdesc_type
operator|=
name|SQ_DESC_TYPE_HEADER
expr_stmt|;
comment|/* Enable notification via CQE after processing SQE */
name|hdr
operator|->
name|post_cqe
operator|=
literal|1
expr_stmt|;
comment|/* No of subdescriptors following this */
name|hdr
operator|->
name|subdesc_cnt
operator|=
name|subdesc_cnt
expr_stmt|;
name|hdr
operator|->
name|tot_len
operator|=
name|len
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|mbuf
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_encap_proto
argument_list|)
expr_stmt|;
block|}
name|poff
operator|=
name|proto
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|etype
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
if|if
condition|(
name|mbuf
operator|->
name|m_len
operator|<
name|ehdrlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
block|{
name|mbuf
operator|=
name|m_pullup
argument_list|(
name|mbuf
argument_list|,
name|ehdrlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|sq
operator|->
name|snd_buff
index|[
name|qentry
index|]
operator|.
name|mbuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mbuf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|poff
operator|=
name|ip6_lasthdr
argument_list|(
name|mbuf
argument_list|,
name|ehdrlen
argument_list|,
name|IPPROTO_IPV6
argument_list|,
operator|&
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|poff
operator|<
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|poff
operator|+=
name|ehdrlen
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|ETHERTYPE_IP
case|:
if|if
condition|(
name|mbuf
operator|->
name|m_len
operator|<
name|ehdrlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|mbuf
operator|=
name|m_pullup
argument_list|(
name|mbuf
argument_list|,
name|ehdrlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|sq
operator|->
name|snd_buff
index|[
name|qentry
index|]
operator|.
name|mbuf
operator|=
name|mbuf
expr_stmt|;
if|if
condition|(
name|mbuf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mbuf
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
name|iphlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|poff
operator|=
name|ehdrlen
operator|+
name|iphlen
expr_stmt|;
name|proto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|hdr
operator|->
name|csum_l3
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|||
name|defined
argument_list|(
name|INET
argument_list|)
if|if
condition|(
name|poff
operator|>
literal|0
operator|&&
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|!=
literal|0
condition|)
block|{
name|hdr
operator|->
name|csum_l3
operator|=
literal|1
expr_stmt|;
comment|/* Enable IP csum calculation */
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
operator|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TCP
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|mbuf
operator|->
name|m_len
operator|<
operator|(
name|poff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|)
condition|)
block|{
name|mbuf
operator|=
name|m_pullup
argument_list|(
name|mbuf
argument_list|,
name|poff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|)
expr_stmt|;
name|sq
operator|->
name|snd_buff
index|[
name|qentry
index|]
operator|.
name|mbuf
operator|=
name|mbuf
expr_stmt|;
if|if
condition|(
name|mbuf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|hdr
operator|->
name|csum_l4
operator|=
name|SEND_L4_CSUM_TCP
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
operator|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_UDP
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|mbuf
operator|->
name|m_len
operator|<
operator|(
name|poff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|)
condition|)
block|{
name|mbuf
operator|=
name|m_pullup
argument_list|(
name|mbuf
argument_list|,
name|poff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|)
expr_stmt|;
name|sq
operator|->
name|snd_buff
index|[
name|qentry
index|]
operator|.
name|mbuf
operator|=
name|mbuf
expr_stmt|;
if|if
condition|(
name|mbuf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|hdr
operator|->
name|csum_l4
operator|=
name|SEND_L4_CSUM_UDP
expr_stmt|;
break|break;
case|case
name|IPPROTO_SCTP
case|:
if|if
condition|(
operator|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_SCTP
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|mbuf
operator|->
name|m_len
operator|<
operator|(
name|poff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
condition|)
block|{
name|mbuf
operator|=
name|m_pullup
argument_list|(
name|mbuf
argument_list|,
name|poff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|)
expr_stmt|;
name|sq
operator|->
name|snd_buff
index|[
name|qentry
index|]
operator|.
name|mbuf
operator|=
name|mbuf
expr_stmt|;
if|if
condition|(
name|mbuf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|hdr
operator|->
name|csum_l4
operator|=
name|SEND_L4_CSUM_SCTP
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|hdr
operator|->
name|l3_offset
operator|=
name|ehdrlen
expr_stmt|;
name|hdr
operator|->
name|l4_offset
operator|=
name|poff
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
operator|!=
literal|0
operator|)
operator|&&
name|nic
operator|->
name|hw_tso
condition|)
block|{
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|mbuf
operator|->
name|m_data
operator|+
name|poff
argument_list|)
operator|)
expr_stmt|;
name|hdr
operator|->
name|tso
operator|=
literal|1
expr_stmt|;
name|hdr
operator|->
name|tso_start
operator|=
name|poff
operator|+
operator|(
name|th
operator|->
name|th_off
operator|*
literal|4
operator|)
expr_stmt|;
name|hdr
operator|->
name|tso_max_paysize
operator|=
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
name|hdr
operator|->
name|inner_l3_offset
operator|=
name|ehdrlen
operator|-
literal|2
expr_stmt|;
name|nic
operator|->
name|drv_stats
operator|.
name|tx_tso
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SQ GATHER subdescriptor  * Must follow HDR descriptor  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|nicvf_sq_add_gather_subdesc
parameter_list|(
name|struct
name|snd_queue
modifier|*
name|sq
parameter_list|,
name|int
name|qentry
parameter_list|,
name|int
name|size
parameter_list|,
name|uint64_t
name|data
parameter_list|)
block|{
name|struct
name|sq_gather_subdesc
modifier|*
name|gather
decl_stmt|;
name|qentry
operator|&=
operator|(
name|sq
operator|->
name|dmem
operator|.
name|q_len
operator|-
literal|1
operator|)
expr_stmt|;
name|gather
operator|=
operator|(
expr|struct
name|sq_gather_subdesc
operator|*
operator|)
name|GET_SQ_DESC
argument_list|(
name|sq
argument_list|,
name|qentry
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|gather
argument_list|,
literal|0
argument_list|,
name|SND_QUEUE_DESC_SIZE
argument_list|)
expr_stmt|;
name|gather
operator|->
name|subdesc_type
operator|=
name|SQ_DESC_TYPE_GATHER
expr_stmt|;
name|gather
operator|->
name|ld_type
operator|=
name|NIC_SEND_LD_TYPE_E_LDD
expr_stmt|;
name|gather
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|gather
operator|->
name|addr
operator|=
name|data
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put an mbuf to a SQ for packet transfer. */
end_comment

begin_function
specifier|static
name|int
name|nicvf_tx_mbuf_locked
parameter_list|(
name|struct
name|snd_queue
modifier|*
name|sq
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mbufp
parameter_list|)
block|{
name|bus_dma_segment_t
name|segs
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|snd_buff
modifier|*
name|snd_buff
decl_stmt|;
name|size_t
name|seg
decl_stmt|;
name|int
name|nsegs
decl_stmt|,
name|qentry
decl_stmt|;
name|int
name|subdesc_cnt
decl_stmt|;
name|int
name|err
decl_stmt|;
name|NICVF_TX_LOCK_ASSERT
argument_list|(
name|sq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|free_cnt
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|snd_buff
operator|=
operator|&
name|sq
operator|->
name|snd_buff
index|[
name|sq
operator|->
name|tail
index|]
expr_stmt|;
name|err
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sq
operator|->
name|snd_buff_dmat
argument_list|,
name|snd_buff
operator|->
name|dmap
argument_list|,
operator|*
name|mbufp
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|err
operator|!=
literal|0
argument_list|)
condition|)
block|{
comment|/* ARM64TODO: Add mbuf defragmenting if we lack maps */
name|m_freem
argument_list|(
operator|*
name|mbufp
argument_list|)
expr_stmt|;
operator|*
name|mbufp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* Set how many subdescriptors is required */
name|subdesc_cnt
operator|=
name|MIN_SQ_DESC_PER_PKT_XMIT
operator|+
name|nsegs
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|subdesc_cnt
operator|>
name|sq
operator|->
name|free_cnt
condition|)
block|{
comment|/* ARM64TODO: Add mbuf defragmentation if we lack descriptors */
name|bus_dmamap_unload
argument_list|(
name|sq
operator|->
name|snd_buff_dmat
argument_list|,
name|snd_buff
operator|->
name|dmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|qentry
operator|=
name|nicvf_get_sq_desc
argument_list|(
name|sq
argument_list|,
name|subdesc_cnt
argument_list|)
expr_stmt|;
comment|/* Add SQ header subdesc */
name|err
operator|=
name|nicvf_sq_add_hdr_subdesc
argument_list|(
name|sq
argument_list|,
name|qentry
argument_list|,
name|subdesc_cnt
operator|-
literal|1
argument_list|,
operator|*
name|mbufp
argument_list|,
operator|(
operator|*
name|mbufp
operator|)
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|nicvf_put_sq_desc
argument_list|(
name|sq
argument_list|,
name|subdesc_cnt
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sq
operator|->
name|snd_buff_dmat
argument_list|,
name|snd_buff
operator|->
name|dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOBUFS
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|mbufp
argument_list|)
expr_stmt|;
operator|*
name|mbufp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* Add SQ gather subdescs */
for|for
control|(
name|seg
operator|=
literal|0
init|;
name|seg
operator|<
name|nsegs
condition|;
name|seg
operator|++
control|)
block|{
name|qentry
operator|=
name|nicvf_get_nxt_sqentry
argument_list|(
name|sq
argument_list|,
name|qentry
argument_list|)
expr_stmt|;
name|nicvf_sq_add_gather_subdesc
argument_list|(
name|sq
argument_list|,
name|qentry
argument_list|,
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
argument_list|,
name|segs
index|[
name|seg
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
block|}
comment|/* make sure all memory stores are done before ringing doorbell */
name|bus_dmamap_sync
argument_list|(
name|sq
operator|->
name|dmem
operator|.
name|dmat
argument_list|,
name|sq
operator|->
name|dmem
operator|.
name|dmap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
name|sq
operator|->
name|nic
operator|->
name|dev
argument_list|,
literal|"%s: sq->idx: %d, subdesc_cnt: %d\n"
argument_list|,
name|__func__
argument_list|,
name|sq
operator|->
name|idx
argument_list|,
name|subdesc_cnt
argument_list|)
expr_stmt|;
comment|/* Inform HW to xmit new packet */
name|nicvf_queue_reg_write
argument_list|(
name|sq
operator|->
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_DOOR
argument_list|,
name|sq
operator|->
name|idx
argument_list|,
name|subdesc_cnt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|frag_num
parameter_list|(
name|u_int
name|i
parameter_list|)
block|{
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
return|return
operator|(
operator|(
name|i
operator|&
operator|~
literal|3
operator|)
operator|+
literal|3
operator|-
operator|(
name|i
operator|&
literal|3
operator|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|i
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Returns MBUF for a received packet */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|nicvf_get_rcv_mbuf
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|cqe_rx_t
modifier|*
name|cqe_rx
parameter_list|)
block|{
name|int
name|frag
decl_stmt|;
name|int
name|payload_len
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf_frag
decl_stmt|;
name|uint16_t
modifier|*
name|rb_lens
init|=
name|NULL
decl_stmt|;
name|uint64_t
modifier|*
name|rb_ptrs
init|=
name|NULL
decl_stmt|;
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|rb_lens
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|cqe_rx
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
operator|)
expr_stmt|;
name|rb_ptrs
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|cqe_rx
operator|+
operator|(
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
operator|)
expr_stmt|;
name|dprintf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"%s rb_cnt %d rb0_ptr %lx rb0_sz %d\n"
argument_list|,
name|__func__
argument_list|,
name|cqe_rx
operator|->
name|rb_cnt
argument_list|,
name|cqe_rx
operator|->
name|rb0_ptr
argument_list|,
name|cqe_rx
operator|->
name|rb0_sz
argument_list|)
expr_stmt|;
for|for
control|(
name|frag
operator|=
literal|0
init|;
name|frag
operator|<
name|cqe_rx
operator|->
name|rb_cnt
condition|;
name|frag
operator|++
control|)
block|{
name|payload_len
operator|=
name|rb_lens
index|[
name|frag_num
argument_list|(
name|frag
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|frag
operator|==
literal|0
condition|)
block|{
comment|/* First fragment */
name|mbuf
operator|=
name|nicvf_rb_ptr_to_mbuf
argument_list|(
name|nic
argument_list|,
operator|(
operator|*
name|rb_ptrs
operator|-
name|cqe_rx
operator|->
name|align_pad
operator|)
argument_list|)
expr_stmt|;
name|mbuf
operator|->
name|m_len
operator|=
name|payload_len
expr_stmt|;
name|mbuf
operator|->
name|m_data
operator|+=
name|cqe_rx
operator|->
name|align_pad
expr_stmt|;
name|if_setrcvif
argument_list|(
name|mbuf
argument_list|,
name|nic
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add fragments */
name|mbuf_frag
operator|=
name|nicvf_rb_ptr_to_mbuf
argument_list|(
name|nic
argument_list|,
operator|*
name|rb_ptrs
argument_list|)
expr_stmt|;
name|m_append
argument_list|(
name|mbuf
argument_list|,
name|payload_len
argument_list|,
name|mbuf_frag
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mbuf_frag
argument_list|)
expr_stmt|;
block|}
comment|/* Next buffer pointer */
name|rb_ptrs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|__predict_true
argument_list|(
name|mbuf
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|m_fixhdr
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|cqe_rx
operator|->
name|rq_idx
expr_stmt|;
name|M_HASHTYPE_SET
argument_list|(
name|mbuf
argument_list|,
name|M_HASHTYPE_OPAQUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
operator|(
name|if_getcapenable
argument_list|(
name|nic
operator|->
name|ifp
argument_list|)
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
comment|/* 			 * HW by default verifies IP& TCP/UDP/SCTP checksums 			 */
if|if
condition|(
name|__predict_true
argument_list|(
name|cqe_rx
operator|->
name|l3_type
operator|==
name|L3TYPE_IPV4
argument_list|)
condition|)
block|{
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|cqe_rx
operator|->
name|l4_type
condition|)
block|{
case|case
name|L4TYPE_UDP
case|:
case|case
name|L4TYPE_TCP
case|:
comment|/* fall through */
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
break|break;
case|case
name|L4TYPE_SCTP
case|:
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_SCTP_VALID
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
return|return
operator|(
name|mbuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Enable interrupt */
end_comment

begin_function
name|void
name|nicvf_enable_intr
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|int
name|int_type
parameter_list|,
name|int
name|q_idx
parameter_list|)
block|{
name|uint64_t
name|reg_val
decl_stmt|;
name|reg_val
operator|=
name|nicvf_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_VF_ENA_W1S
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|int_type
condition|)
block|{
case|case
name|NICVF_INTR_CQ
case|:
name|reg_val
operator||=
operator|(
operator|(
literal|1UL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_CQ_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_SQ
case|:
name|reg_val
operator||=
operator|(
operator|(
literal|1UL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_SQ_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_RBDR
case|:
name|reg_val
operator||=
operator|(
operator|(
literal|1UL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_RBDR_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_PKT_DROP
case|:
name|reg_val
operator||=
operator|(
literal|1UL
operator|<<
name|NICVF_INTR_PKT_DROP_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_TCP_TIMER
case|:
name|reg_val
operator||=
operator|(
literal|1UL
operator|<<
name|NICVF_INTR_TCP_TIMER_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_MBOX
case|:
name|reg_val
operator||=
operator|(
literal|1UL
operator|<<
name|NICVF_INTR_MBOX_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_QS_ERR
case|:
name|reg_val
operator||=
operator|(
literal|1UL
operator|<<
name|NICVF_INTR_QS_ERR_SHIFT
operator|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Failed to enable interrupt: unknown type\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|nicvf_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_VF_ENA_W1S
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Disable interrupt */
end_comment

begin_function
name|void
name|nicvf_disable_intr
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|int
name|int_type
parameter_list|,
name|int
name|q_idx
parameter_list|)
block|{
name|uint64_t
name|reg_val
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|int_type
condition|)
block|{
case|case
name|NICVF_INTR_CQ
case|:
name|reg_val
operator||=
operator|(
operator|(
literal|1UL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_CQ_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_SQ
case|:
name|reg_val
operator||=
operator|(
operator|(
literal|1UL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_SQ_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_RBDR
case|:
name|reg_val
operator||=
operator|(
operator|(
literal|1UL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_RBDR_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_PKT_DROP
case|:
name|reg_val
operator||=
operator|(
literal|1UL
operator|<<
name|NICVF_INTR_PKT_DROP_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_TCP_TIMER
case|:
name|reg_val
operator||=
operator|(
literal|1UL
operator|<<
name|NICVF_INTR_TCP_TIMER_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_MBOX
case|:
name|reg_val
operator||=
operator|(
literal|1UL
operator|<<
name|NICVF_INTR_MBOX_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_QS_ERR
case|:
name|reg_val
operator||=
operator|(
literal|1UL
operator|<<
name|NICVF_INTR_QS_ERR_SHIFT
operator|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Failed to disable interrupt: unknown type\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|nicvf_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_VF_ENA_W1C
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear interrupt */
end_comment

begin_function
name|void
name|nicvf_clear_intr
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|int
name|int_type
parameter_list|,
name|int
name|q_idx
parameter_list|)
block|{
name|uint64_t
name|reg_val
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|int_type
condition|)
block|{
case|case
name|NICVF_INTR_CQ
case|:
name|reg_val
operator|=
operator|(
operator|(
literal|1UL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_CQ_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_SQ
case|:
name|reg_val
operator|=
operator|(
operator|(
literal|1UL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_SQ_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_RBDR
case|:
name|reg_val
operator|=
operator|(
operator|(
literal|1UL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_RBDR_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_PKT_DROP
case|:
name|reg_val
operator|=
operator|(
literal|1UL
operator|<<
name|NICVF_INTR_PKT_DROP_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_TCP_TIMER
case|:
name|reg_val
operator|=
operator|(
literal|1UL
operator|<<
name|NICVF_INTR_TCP_TIMER_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_MBOX
case|:
name|reg_val
operator|=
operator|(
literal|1UL
operator|<<
name|NICVF_INTR_MBOX_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_QS_ERR
case|:
name|reg_val
operator||=
operator|(
literal|1UL
operator|<<
name|NICVF_INTR_QS_ERR_SHIFT
operator|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Failed to clear interrupt: unknown type\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|nicvf_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_VF_INT
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check if interrupt is enabled */
end_comment

begin_function
name|int
name|nicvf_is_intr_enabled
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|int
name|int_type
parameter_list|,
name|int
name|q_idx
parameter_list|)
block|{
name|uint64_t
name|reg_val
decl_stmt|;
name|uint64_t
name|mask
init|=
literal|0xff
decl_stmt|;
name|reg_val
operator|=
name|nicvf_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_VF_ENA_W1S
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|int_type
condition|)
block|{
case|case
name|NICVF_INTR_CQ
case|:
name|mask
operator|=
operator|(
operator|(
literal|1UL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_CQ_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_SQ
case|:
name|mask
operator|=
operator|(
operator|(
literal|1UL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_SQ_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_RBDR
case|:
name|mask
operator|=
operator|(
operator|(
literal|1UL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_RBDR_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_PKT_DROP
case|:
name|mask
operator|=
name|NICVF_INTR_PKT_DROP_MASK
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_TCP_TIMER
case|:
name|mask
operator|=
name|NICVF_INTR_TCP_TIMER_MASK
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_MBOX
case|:
name|mask
operator|=
name|NICVF_INTR_MBOX_MASK
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_QS_ERR
case|:
name|mask
operator|=
name|NICVF_INTR_QS_ERR_MASK
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Failed to check interrupt enable: unknown type\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|reg_val
operator|&
name|mask
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nicvf_update_rq_stats
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|int
name|rq_idx
parameter_list|)
block|{
name|struct
name|rcv_queue
modifier|*
name|rq
decl_stmt|;
define|#
directive|define
name|GET_RQ_STATS
parameter_list|(
name|reg
parameter_list|)
define|\
value|nicvf_reg_read(nic, NIC_QSET_RQ_0_7_STAT_0_1 |\ 			    (rq_idx<< NIC_Q_NUM_SHIFT) | (reg<< 3))
name|rq
operator|=
operator|&
name|nic
operator|->
name|qs
operator|->
name|rq
index|[
name|rq_idx
index|]
expr_stmt|;
name|rq
operator|->
name|stats
operator|.
name|bytes
operator|=
name|GET_RQ_STATS
argument_list|(
name|RQ_SQ_STATS_OCTS
argument_list|)
expr_stmt|;
name|rq
operator|->
name|stats
operator|.
name|pkts
operator|=
name|GET_RQ_STATS
argument_list|(
name|RQ_SQ_STATS_PKTS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nicvf_update_sq_stats
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|int
name|sq_idx
parameter_list|)
block|{
name|struct
name|snd_queue
modifier|*
name|sq
decl_stmt|;
define|#
directive|define
name|GET_SQ_STATS
parameter_list|(
name|reg
parameter_list|)
define|\
value|nicvf_reg_read(nic, NIC_QSET_SQ_0_7_STAT_0_1 |\ 			    (sq_idx<< NIC_Q_NUM_SHIFT) | (reg<< 3))
name|sq
operator|=
operator|&
name|nic
operator|->
name|qs
operator|->
name|sq
index|[
name|sq_idx
index|]
expr_stmt|;
name|sq
operator|->
name|stats
operator|.
name|bytes
operator|=
name|GET_SQ_STATS
argument_list|(
name|RQ_SQ_STATS_OCTS
argument_list|)
expr_stmt|;
name|sq
operator|->
name|stats
operator|.
name|pkts
operator|=
name|GET_SQ_STATS
argument_list|(
name|RQ_SQ_STATS_PKTS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check for errors in the receive cmp.queue entry */
end_comment

begin_function
name|int
name|nicvf_check_cqe_rx_errs
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|cmp_queue
modifier|*
name|cq
parameter_list|,
name|struct
name|cqe_rx_t
modifier|*
name|cqe_rx
parameter_list|)
block|{
name|struct
name|nicvf_hw_stats
modifier|*
name|stats
init|=
operator|&
name|nic
operator|->
name|hw_stats
decl_stmt|;
name|struct
name|nicvf_drv_stats
modifier|*
name|drv_stats
init|=
operator|&
name|nic
operator|->
name|drv_stats
decl_stmt|;
if|if
condition|(
operator|!
name|cqe_rx
operator|->
name|err_level
operator|&&
operator|!
name|cqe_rx
operator|->
name|err_opcode
condition|)
block|{
name|drv_stats
operator|->
name|rx_frames_ok
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|cqe_rx
operator|->
name|err_opcode
condition|)
block|{
case|case
name|CQ_RX_ERROP_RE_PARTIAL
case|:
name|stats
operator|->
name|rx_bgx_truncated_pkts
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_RE_JABBER
case|:
name|stats
operator|->
name|rx_jabber_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_RE_FCS
case|:
name|stats
operator|->
name|rx_fcs_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_RE_RX_CTL
case|:
name|stats
operator|->
name|rx_bgx_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_PREL2_ERR
case|:
name|stats
operator|->
name|rx_prel2_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_L2_MAL
case|:
name|stats
operator|->
name|rx_l2_hdr_malformed
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_L2_OVERSIZE
case|:
name|stats
operator|->
name|rx_oversize
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_L2_UNDERSIZE
case|:
name|stats
operator|->
name|rx_undersize
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_L2_LENMISM
case|:
name|stats
operator|->
name|rx_l2_len_mismatch
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_L2_PCLP
case|:
name|stats
operator|->
name|rx_l2_pclp
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_IP_NOT
case|:
name|stats
operator|->
name|rx_ip_ver_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_IP_CSUM_ERR
case|:
name|stats
operator|->
name|rx_ip_csum_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_IP_MAL
case|:
name|stats
operator|->
name|rx_ip_hdr_malformed
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_IP_MALD
case|:
name|stats
operator|->
name|rx_ip_payload_malformed
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_IP_HOP
case|:
name|stats
operator|->
name|rx_ip_ttl_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_L3_PCLP
case|:
name|stats
operator|->
name|rx_l3_pclp
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_L4_MAL
case|:
name|stats
operator|->
name|rx_l4_malformed
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_L4_CHK
case|:
name|stats
operator|->
name|rx_l4_csum_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_UDP_LEN
case|:
name|stats
operator|->
name|rx_udp_len_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_L4_PORT
case|:
name|stats
operator|->
name|rx_l4_port_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_TCP_FLAG
case|:
name|stats
operator|->
name|rx_tcp_flag_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_TCP_OFFSET
case|:
name|stats
operator|->
name|rx_tcp_offset_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_L4_PCLP
case|:
name|stats
operator|->
name|rx_l4_pclp
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_RBDR_TRUNC
case|:
name|stats
operator|->
name|rx_truncated_pkts
operator|++
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check for errors in the send cmp.queue entry */
end_comment

begin_function
name|int
name|nicvf_check_cqe_tx_errs
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|cmp_queue
modifier|*
name|cq
parameter_list|,
name|struct
name|cqe_send_t
modifier|*
name|cqe_tx
parameter_list|)
block|{
name|struct
name|cmp_queue_stats
modifier|*
name|stats
init|=
operator|&
name|cq
operator|->
name|stats
decl_stmt|;
switch|switch
condition|(
name|cqe_tx
operator|->
name|send_status
condition|)
block|{
case|case
name|CQ_TX_ERROP_GOOD
case|:
name|stats
operator|->
name|tx
operator|.
name|good
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CQ_TX_ERROP_DESC_FAULT
case|:
name|stats
operator|->
name|tx
operator|.
name|desc_fault
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_HDR_CONS_ERR
case|:
name|stats
operator|->
name|tx
operator|.
name|hdr_cons_err
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_SUBDC_ERR
case|:
name|stats
operator|->
name|tx
operator|.
name|subdesc_err
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_IMM_SIZE_OFLOW
case|:
name|stats
operator|->
name|tx
operator|.
name|imm_size_oflow
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_DATA_SEQUENCE_ERR
case|:
name|stats
operator|->
name|tx
operator|.
name|data_seq_err
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_MEM_SEQUENCE_ERR
case|:
name|stats
operator|->
name|tx
operator|.
name|mem_seq_err
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_LOCK_VIOL
case|:
name|stats
operator|->
name|tx
operator|.
name|lock_viol
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_DATA_FAULT
case|:
name|stats
operator|->
name|tx
operator|.
name|data_fault
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_TSTMP_CONFLICT
case|:
name|stats
operator|->
name|tx
operator|.
name|tstmp_conflict
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_TSTMP_TIMEOUT
case|:
name|stats
operator|->
name|tx
operator|.
name|tstmp_timeout
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_MEM_FAULT
case|:
name|stats
operator|->
name|tx
operator|.
name|mem_fault
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_CK_OVERLAP
case|:
name|stats
operator|->
name|tx
operator|.
name|csum_overlap
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_CK_OFLOW
case|:
name|stats
operator|->
name|tx
operator|.
name|csum_overflow
operator|++
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

