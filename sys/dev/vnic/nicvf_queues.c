begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2015 Cavium Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<linux/pci.h>
end_include

begin_include
include|#
directive|include
file|<linux/netdevice.h>
end_include

begin_include
include|#
directive|include
file|<linux/ip.h>
end_include

begin_include
include|#
directive|include
file|<linux/etherdevice.h>
end_include

begin_include
include|#
directive|include
file|<net/ip.h>
end_include

begin_include
include|#
directive|include
file|<net/tso.h>
end_include

begin_include
include|#
directive|include
file|"nic_reg.h"
end_include

begin_include
include|#
directive|include
file|"nic.h"
end_include

begin_include
include|#
directive|include
file|"q_struct.h"
end_include

begin_include
include|#
directive|include
file|"nicvf_queues.h"
end_include

begin_struct
struct|struct
name|rbuf_info
block|{
name|struct
name|page
modifier|*
name|page
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|u64
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|GET_RBUF_INFO
parameter_list|(
name|x
parameter_list|)
value|((struct rbuf_info *)(x - NICVF_RCV_BUF_ALIGN_BYTES))
end_define

begin_comment
comment|/* Poll a register for a specific value */
end_comment

begin_function
specifier|static
name|int
name|nicvf_poll_reg
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|int
name|qidx
parameter_list|,
name|u64
name|reg
parameter_list|,
name|int
name|bit_pos
parameter_list|,
name|int
name|bits
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|u64
name|bit_mask
decl_stmt|;
name|u64
name|reg_val
decl_stmt|;
name|int
name|timeout
init|=
literal|10
decl_stmt|;
name|bit_mask
operator|=
operator|(
literal|1ULL
operator|<<
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
name|bit_mask
operator|=
operator|(
name|bit_mask
operator|<<
name|bit_pos
operator|)
expr_stmt|;
while|while
condition|(
name|timeout
condition|)
block|{
name|reg_val
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|reg
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|reg_val
operator|&
name|bit_mask
operator|)
operator|>>
name|bit_pos
operator|)
operator|==
name|val
condition|)
return|return
literal|0
return|;
name|usleep_range
argument_list|(
literal|1000
argument_list|,
literal|2000
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
name|netdev_err
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"Poll on reg 0x%llx failed\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Allocate memory for a queue's descriptors */
end_comment

begin_function
specifier|static
name|int
name|nicvf_alloc_q_desc_mem
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|q_desc_mem
modifier|*
name|dmem
parameter_list|,
name|int
name|q_len
parameter_list|,
name|int
name|desc_size
parameter_list|,
name|int
name|align_bytes
parameter_list|)
block|{
name|dmem
operator|->
name|q_len
operator|=
name|q_len
expr_stmt|;
name|dmem
operator|->
name|size
operator|=
operator|(
name|desc_size
operator|*
name|q_len
operator|)
operator|+
name|align_bytes
expr_stmt|;
comment|/* Save address, need it while freeing */
name|dmem
operator|->
name|unalign_base
operator|=
name|dma_zalloc_coherent
argument_list|(
operator|&
name|nic
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|dmem
operator|->
name|size
argument_list|,
operator|&
name|dmem
operator|->
name|dma
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dmem
operator|->
name|unalign_base
condition|)
return|return
operator|-
name|ENOMEM
return|;
comment|/* Align memory address for 'align_bytes' */
name|dmem
operator|->
name|phys_base
operator|=
name|NICVF_ALIGNED_ADDR
argument_list|(
operator|(
name|u64
operator|)
name|dmem
operator|->
name|dma
argument_list|,
name|align_bytes
argument_list|)
expr_stmt|;
name|dmem
operator|->
name|base
operator|=
name|dmem
operator|->
name|unalign_base
operator|+
operator|(
name|dmem
operator|->
name|phys_base
operator|-
name|dmem
operator|->
name|dma
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Free queue's descriptor memory */
end_comment

begin_function
specifier|static
name|void
name|nicvf_free_q_desc_mem
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|q_desc_mem
modifier|*
name|dmem
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dmem
condition|)
return|return;
name|dma_free_coherent
argument_list|(
operator|&
name|nic
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|dmem
operator|->
name|size
argument_list|,
name|dmem
operator|->
name|unalign_base
argument_list|,
name|dmem
operator|->
name|dma
argument_list|)
expr_stmt|;
name|dmem
operator|->
name|unalign_base
operator|=
name|NULL
expr_stmt|;
name|dmem
operator|->
name|base
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate buffer for packet reception  * HW returns memory address where packet is DMA'ed but not a pointer  * into RBDR ring, so save buffer address at the start of fragment and  * align the start address to a cache aligned address  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|nicvf_alloc_rcv_buffer
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|gfp_t
name|gfp
parameter_list|,
name|u32
name|buf_len
parameter_list|,
name|u64
modifier|*
modifier|*
name|rbuf
parameter_list|)
block|{
name|u64
name|data
decl_stmt|;
name|struct
name|rbuf_info
modifier|*
name|rinfo
decl_stmt|;
name|int
name|order
init|=
name|get_order
argument_list|(
name|buf_len
argument_list|)
decl_stmt|;
comment|/* Check if request can be accomodated in previous allocated page */
if|if
condition|(
name|nic
operator|->
name|rb_page
condition|)
block|{
if|if
condition|(
operator|(
name|nic
operator|->
name|rb_page_offset
operator|+
name|buf_len
operator|+
name|buf_len
operator|)
operator|>
operator|(
name|PAGE_SIZE
operator|<<
name|order
operator|)
condition|)
block|{
name|nic
operator|->
name|rb_page
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|nic
operator|->
name|rb_page_offset
operator|+=
name|buf_len
expr_stmt|;
name|get_page
argument_list|(
name|nic
operator|->
name|rb_page
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Allocate a new page */
if|if
condition|(
operator|!
name|nic
operator|->
name|rb_page
condition|)
block|{
name|nic
operator|->
name|rb_page
operator|=
name|alloc_pages
argument_list|(
name|gfp
operator||
name|__GFP_COMP
operator||
name|__GFP_NOWARN
argument_list|,
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nic
operator|->
name|rb_page
condition|)
block|{
name|netdev_err
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"Failed to allocate new rcv buffer\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|nic
operator|->
name|rb_page_offset
operator|=
literal|0
expr_stmt|;
block|}
name|data
operator|=
operator|(
name|u64
operator|)
name|page_address
argument_list|(
name|nic
operator|->
name|rb_page
argument_list|)
operator|+
name|nic
operator|->
name|rb_page_offset
expr_stmt|;
comment|/* Align buffer addr to cache line i.e 128 bytes */
name|rinfo
operator|=
operator|(
expr|struct
name|rbuf_info
operator|*
operator|)
operator|(
name|data
operator|+
name|NICVF_RCV_BUF_ALIGN_LEN
argument_list|(
name|data
argument_list|)
operator|)
expr_stmt|;
comment|/* Save page address for reference updation */
name|rinfo
operator|->
name|page
operator|=
name|nic
operator|->
name|rb_page
expr_stmt|;
comment|/* Store start address for later retrieval */
name|rinfo
operator|->
name|data
operator|=
operator|(
name|void
operator|*
operator|)
name|data
expr_stmt|;
comment|/* Store alignment offset */
name|rinfo
operator|->
name|offset
operator|=
name|NICVF_RCV_BUF_ALIGN_LEN
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
name|rinfo
operator|->
name|offset
expr_stmt|;
comment|/* Give next aligned address to hw for DMA */
operator|*
name|rbuf
operator|=
operator|(
name|u64
operator|*
operator|)
operator|(
name|data
operator|+
name|NICVF_RCV_BUF_ALIGN_BYTES
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Retrieve actual buffer start address and build skb for received packet */
end_comment

begin_function
specifier|static
name|struct
name|sk_buff
modifier|*
name|nicvf_rb_ptr_to_skb
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|u64
name|rb_ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|sk_buff
modifier|*
name|skb
decl_stmt|;
name|struct
name|rbuf_info
modifier|*
name|rinfo
decl_stmt|;
name|rb_ptr
operator|=
operator|(
name|u64
operator|)
name|phys_to_virt
argument_list|(
name|rb_ptr
argument_list|)
expr_stmt|;
comment|/* Get buffer start address and alignment offset */
name|rinfo
operator|=
name|GET_RBUF_INFO
argument_list|(
name|rb_ptr
argument_list|)
expr_stmt|;
comment|/* Now build an skb to give to stack */
name|skb
operator|=
name|build_skb
argument_list|(
name|rinfo
operator|->
name|data
argument_list|,
name|RCV_FRAG_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skb
condition|)
block|{
name|put_page
argument_list|(
name|rinfo
operator|->
name|page
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Set correct skb->data */
name|skb_reserve
argument_list|(
name|skb
argument_list|,
name|rinfo
operator|->
name|offset
operator|+
name|NICVF_RCV_BUF_ALIGN_BYTES
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rb_ptr
argument_list|)
expr_stmt|;
return|return
name|skb
return|;
block|}
end_function

begin_comment
comment|/* Allocate RBDR ring and populate receive buffers */
end_comment

begin_function
specifier|static
name|int
name|nicvf_init_rbdr
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|rbdr
modifier|*
name|rbdr
parameter_list|,
name|int
name|ring_len
parameter_list|,
name|int
name|buf_size
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|u64
modifier|*
name|rbuf
decl_stmt|;
name|struct
name|rbdr_entry_t
modifier|*
name|desc
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|nicvf_alloc_q_desc_mem
argument_list|(
name|nic
argument_list|,
operator|&
name|rbdr
operator|->
name|dmem
argument_list|,
name|ring_len
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rbdr_entry_t
argument_list|)
argument_list|,
name|NICVF_RCV_BUF_ALIGN_BYTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|rbdr
operator|->
name|desc
operator|=
name|rbdr
operator|->
name|dmem
operator|.
name|base
expr_stmt|;
comment|/* Buffer size has to be in multiples of 128 bytes */
name|rbdr
operator|->
name|dma_size
operator|=
name|buf_size
expr_stmt|;
name|rbdr
operator|->
name|enable
operator|=
name|true
expr_stmt|;
name|rbdr
operator|->
name|thresh
operator|=
name|RBDR_THRESH
expr_stmt|;
name|nic
operator|->
name|rb_page
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|ring_len
condition|;
name|idx
operator|++
control|)
block|{
name|err
operator|=
name|nicvf_alloc_rcv_buffer
argument_list|(
name|nic
argument_list|,
name|GFP_KERNEL
argument_list|,
name|RCV_FRAG_LEN
argument_list|,
operator|&
name|rbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|desc
operator|=
name|GET_RBDR_DESC
argument_list|(
name|rbdr
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|desc
operator|->
name|buf_addr
operator|=
name|virt_to_phys
argument_list|(
name|rbuf
argument_list|)
operator|>>
name|NICVF_RCV_BUF_ALIGN
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Free RBDR ring and its receive buffers */
end_comment

begin_function
specifier|static
name|void
name|nicvf_free_rbdr
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|rbdr
modifier|*
name|rbdr
parameter_list|)
block|{
name|int
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|u64
name|buf_addr
decl_stmt|;
name|struct
name|rbdr_entry_t
modifier|*
name|desc
decl_stmt|;
name|struct
name|rbuf_info
modifier|*
name|rinfo
decl_stmt|;
if|if
condition|(
operator|!
name|rbdr
condition|)
return|return;
name|rbdr
operator|->
name|enable
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|rbdr
operator|->
name|dmem
operator|.
name|base
condition|)
return|return;
name|head
operator|=
name|rbdr
operator|->
name|head
expr_stmt|;
name|tail
operator|=
name|rbdr
operator|->
name|tail
expr_stmt|;
comment|/* Free SKBs */
while|while
condition|(
name|head
operator|!=
name|tail
condition|)
block|{
name|desc
operator|=
name|GET_RBDR_DESC
argument_list|(
name|rbdr
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|buf_addr
operator|=
name|desc
operator|->
name|buf_addr
operator|<<
name|NICVF_RCV_BUF_ALIGN
expr_stmt|;
name|rinfo
operator|=
name|GET_RBUF_INFO
argument_list|(
operator|(
name|u64
operator|)
name|phys_to_virt
argument_list|(
name|buf_addr
argument_list|)
argument_list|)
expr_stmt|;
name|put_page
argument_list|(
name|rinfo
operator|->
name|page
argument_list|)
expr_stmt|;
name|head
operator|++
expr_stmt|;
name|head
operator|&=
operator|(
name|rbdr
operator|->
name|dmem
operator|.
name|q_len
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* Free SKB of tail desc */
name|desc
operator|=
name|GET_RBDR_DESC
argument_list|(
name|rbdr
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|buf_addr
operator|=
name|desc
operator|->
name|buf_addr
operator|<<
name|NICVF_RCV_BUF_ALIGN
expr_stmt|;
name|rinfo
operator|=
name|GET_RBUF_INFO
argument_list|(
operator|(
name|u64
operator|)
name|phys_to_virt
argument_list|(
name|buf_addr
argument_list|)
argument_list|)
expr_stmt|;
name|put_page
argument_list|(
name|rinfo
operator|->
name|page
argument_list|)
expr_stmt|;
comment|/* Free RBDR ring */
name|nicvf_free_q_desc_mem
argument_list|(
name|nic
argument_list|,
operator|&
name|rbdr
operator|->
name|dmem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Refill receive buffer descriptors with new buffers.  */
end_comment

begin_function
specifier|static
name|void
name|nicvf_refill_rbdr
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|gfp_t
name|gfp
parameter_list|)
block|{
name|struct
name|queue_set
modifier|*
name|qs
init|=
name|nic
operator|->
name|qs
decl_stmt|;
name|int
name|rbdr_idx
init|=
name|qs
operator|->
name|rbdr_cnt
decl_stmt|;
name|int
name|tail
decl_stmt|,
name|qcount
decl_stmt|;
name|int
name|refill_rb_cnt
decl_stmt|;
name|struct
name|rbdr
modifier|*
name|rbdr
decl_stmt|;
name|struct
name|rbdr_entry_t
modifier|*
name|desc
decl_stmt|;
name|u64
modifier|*
name|rbuf
decl_stmt|;
name|int
name|new_rb
init|=
literal|0
decl_stmt|;
name|refill
label|:
if|if
condition|(
operator|!
name|rbdr_idx
condition|)
return|return;
name|rbdr_idx
operator|--
expr_stmt|;
name|rbdr
operator|=
operator|&
name|qs
operator|->
name|rbdr
index|[
name|rbdr_idx
index|]
expr_stmt|;
comment|/* Check if it's enabled */
if|if
condition|(
operator|!
name|rbdr
operator|->
name|enable
condition|)
goto|goto
name|next_rbdr
goto|;
comment|/* Get no of desc's to be refilled */
name|qcount
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_STATUS0
argument_list|,
name|rbdr_idx
argument_list|)
expr_stmt|;
name|qcount
operator|&=
literal|0x7FFFF
expr_stmt|;
comment|/* Doorbell can be ringed with a max of ring size minus 1 */
if|if
condition|(
name|qcount
operator|>=
operator|(
name|qs
operator|->
name|rbdr_len
operator|-
literal|1
operator|)
condition|)
goto|goto
name|next_rbdr
goto|;
else|else
name|refill_rb_cnt
operator|=
name|qs
operator|->
name|rbdr_len
operator|-
name|qcount
operator|-
literal|1
expr_stmt|;
comment|/* Start filling descs from tail */
name|tail
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_TAIL
argument_list|,
name|rbdr_idx
argument_list|)
operator|>>
literal|3
expr_stmt|;
while|while
condition|(
name|refill_rb_cnt
condition|)
block|{
name|tail
operator|++
expr_stmt|;
name|tail
operator|&=
operator|(
name|rbdr
operator|->
name|dmem
operator|.
name|q_len
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|nicvf_alloc_rcv_buffer
argument_list|(
name|nic
argument_list|,
name|gfp
argument_list|,
name|RCV_FRAG_LEN
argument_list|,
operator|&
name|rbuf
argument_list|)
condition|)
break|break;
name|desc
operator|=
name|GET_RBDR_DESC
argument_list|(
name|rbdr
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|desc
operator|->
name|buf_addr
operator|=
name|virt_to_phys
argument_list|(
name|rbuf
argument_list|)
operator|>>
name|NICVF_RCV_BUF_ALIGN
expr_stmt|;
name|refill_rb_cnt
operator|--
expr_stmt|;
name|new_rb
operator|++
expr_stmt|;
block|}
comment|/* make sure all memory stores are done before ringing doorbell */
name|smp_wmb
argument_list|()
expr_stmt|;
comment|/* Check if buffer allocation failed */
if|if
condition|(
name|refill_rb_cnt
condition|)
name|nic
operator|->
name|rb_alloc_fail
operator|=
name|true
expr_stmt|;
else|else
name|nic
operator|->
name|rb_alloc_fail
operator|=
name|false
expr_stmt|;
comment|/* Notify HW */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_DOOR
argument_list|,
name|rbdr_idx
argument_list|,
name|new_rb
argument_list|)
expr_stmt|;
name|next_rbdr
label|:
comment|/* Re-enable RBDR interrupts only if buffer allocation is success */
if|if
condition|(
operator|!
name|nic
operator|->
name|rb_alloc_fail
operator|&&
name|rbdr
operator|->
name|enable
condition|)
name|nicvf_enable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_RBDR
argument_list|,
name|rbdr_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbdr_idx
condition|)
goto|goto
name|refill
goto|;
block|}
end_function

begin_comment
comment|/* Alloc rcv buffers in non-atomic mode for better success */
end_comment

begin_function
name|void
name|nicvf_rbdr_work
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
init|=
name|container_of
argument_list|(
name|work
argument_list|,
expr|struct
name|nicvf
argument_list|,
name|rbdr_work
operator|.
name|work
argument_list|)
decl_stmt|;
name|nicvf_refill_rbdr
argument_list|(
name|nic
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|rb_alloc_fail
condition|)
name|schedule_delayed_work
argument_list|(
operator|&
name|nic
operator|->
name|rbdr_work
argument_list|,
name|msecs_to_jiffies
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|nic
operator|->
name|rb_work_scheduled
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/* In Softirq context, alloc rcv buffers in atomic mode */
end_comment

begin_function
name|void
name|nicvf_rbdr_task
parameter_list|(
name|unsigned
name|long
name|data
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
init|=
operator|(
expr|struct
name|nicvf
operator|*
operator|)
name|data
decl_stmt|;
name|nicvf_refill_rbdr
argument_list|(
name|nic
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|rb_alloc_fail
condition|)
block|{
name|nic
operator|->
name|rb_work_scheduled
operator|=
name|true
expr_stmt|;
name|schedule_delayed_work
argument_list|(
operator|&
name|nic
operator|->
name|rbdr_work
argument_list|,
name|msecs_to_jiffies
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize completion queue */
end_comment

begin_function
specifier|static
name|int
name|nicvf_init_cmp_queue
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|cmp_queue
modifier|*
name|cq
parameter_list|,
name|int
name|q_len
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|nicvf_alloc_q_desc_mem
argument_list|(
name|nic
argument_list|,
operator|&
name|cq
operator|->
name|dmem
argument_list|,
name|q_len
argument_list|,
name|CMP_QUEUE_DESC_SIZE
argument_list|,
name|NICVF_CQ_BASE_ALIGN_BYTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|cq
operator|->
name|desc
operator|=
name|cq
operator|->
name|dmem
operator|.
name|base
expr_stmt|;
name|cq
operator|->
name|thresh
operator|=
name|CMP_QUEUE_CQE_THRESH
expr_stmt|;
name|nic
operator|->
name|cq_coalesce_usecs
operator|=
operator|(
name|CMP_QUEUE_TIMER_THRESH
operator|*
literal|0.05
operator|)
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_free_cmp_queue
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|cmp_queue
modifier|*
name|cq
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cq
condition|)
return|return;
if|if
condition|(
operator|!
name|cq
operator|->
name|dmem
operator|.
name|base
condition|)
return|return;
name|nicvf_free_q_desc_mem
argument_list|(
name|nic
argument_list|,
operator|&
name|cq
operator|->
name|dmem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize transmit queue */
end_comment

begin_function
specifier|static
name|int
name|nicvf_init_snd_queue
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|snd_queue
modifier|*
name|sq
parameter_list|,
name|int
name|q_len
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|nicvf_alloc_q_desc_mem
argument_list|(
name|nic
argument_list|,
operator|&
name|sq
operator|->
name|dmem
argument_list|,
name|q_len
argument_list|,
name|SND_QUEUE_DESC_SIZE
argument_list|,
name|NICVF_SQ_BASE_ALIGN_BYTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|sq
operator|->
name|desc
operator|=
name|sq
operator|->
name|dmem
operator|.
name|base
expr_stmt|;
name|sq
operator|->
name|skbuff
operator|=
name|kcalloc
argument_list|(
name|q_len
argument_list|,
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sq
operator|->
name|skbuff
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|sq
operator|->
name|head
operator|=
literal|0
expr_stmt|;
name|sq
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
name|atomic_set
argument_list|(
operator|&
name|sq
operator|->
name|free_cnt
argument_list|,
name|q_len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sq
operator|->
name|thresh
operator|=
name|SND_QUEUE_THRESH
expr_stmt|;
comment|/* Preallocate memory for TSO segment's header */
name|sq
operator|->
name|tso_hdrs
operator|=
name|dma_alloc_coherent
argument_list|(
operator|&
name|nic
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|q_len
operator|*
name|TSO_HEADER_SIZE
argument_list|,
operator|&
name|sq
operator|->
name|tso_hdrs_phys
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sq
operator|->
name|tso_hdrs
condition|)
return|return
operator|-
name|ENOMEM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_free_snd_queue
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|snd_queue
modifier|*
name|sq
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sq
condition|)
return|return;
if|if
condition|(
operator|!
name|sq
operator|->
name|dmem
operator|.
name|base
condition|)
return|return;
if|if
condition|(
name|sq
operator|->
name|tso_hdrs
condition|)
name|dma_free_coherent
argument_list|(
operator|&
name|nic
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|sq
operator|->
name|dmem
operator|.
name|q_len
operator|*
name|TSO_HEADER_SIZE
argument_list|,
name|sq
operator|->
name|tso_hdrs
argument_list|,
name|sq
operator|->
name|tso_hdrs_phys
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|sq
operator|->
name|skbuff
argument_list|)
expr_stmt|;
name|nicvf_free_q_desc_mem
argument_list|(
name|nic
argument_list|,
operator|&
name|sq
operator|->
name|dmem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_reclaim_snd_queue
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|queue_set
modifier|*
name|qs
parameter_list|,
name|int
name|qidx
parameter_list|)
block|{
comment|/* Disable send queue */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check if SQ is stopped */
if|if
condition|(
name|nicvf_poll_reg
argument_list|(
name|nic
argument_list|,
name|qidx
argument_list|,
name|NIC_QSET_SQ_0_7_STATUS
argument_list|,
literal|21
argument_list|,
literal|1
argument_list|,
literal|0x01
argument_list|)
condition|)
return|return;
comment|/* Reset send queue */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
name|NICVF_SQ_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_reclaim_rcv_queue
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|queue_set
modifier|*
name|qs
parameter_list|,
name|int
name|qidx
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
comment|/* Make sure all packets in the pipeline are written back into mem */
name|mbx
operator|.
name|msg
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_RQ_SW_SYNC
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_reclaim_cmp_queue
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|queue_set
modifier|*
name|qs
parameter_list|,
name|int
name|qidx
parameter_list|)
block|{
comment|/* Disable timer threshold (doesn't get reset upon CQ reset */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_CFG2
argument_list|,
name|qidx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable completion queue */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset completion queue */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
name|NICVF_CQ_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_reclaim_rbdr
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|rbdr
modifier|*
name|rbdr
parameter_list|,
name|int
name|qidx
parameter_list|)
block|{
name|u64
name|tmp
decl_stmt|,
name|fifo_state
decl_stmt|;
name|int
name|timeout
init|=
literal|10
decl_stmt|;
comment|/* Save head and tail pointers for feeing up buffers */
name|rbdr
operator|->
name|head
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_HEAD
argument_list|,
name|qidx
argument_list|)
operator|>>
literal|3
expr_stmt|;
name|rbdr
operator|->
name|tail
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_TAIL
argument_list|,
name|qidx
argument_list|)
operator|>>
literal|3
expr_stmt|;
comment|/* If RBDR FIFO is in 'FAIL' state then do a reset first 	 * before relaiming. 	 */
name|fifo_state
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_STATUS0
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|fifo_state
operator|>>
literal|62
operator|)
operator|&
literal|0x03
operator|)
operator|==
literal|0x3
condition|)
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_CFG
argument_list|,
name|qidx
argument_list|,
name|NICVF_RBDR_RESET
argument_list|)
expr_stmt|;
comment|/* Disable RBDR */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_CFG
argument_list|,
name|qidx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nicvf_poll_reg
argument_list|(
name|nic
argument_list|,
name|qidx
argument_list|,
name|NIC_QSET_RBDR_0_1_STATUS0
argument_list|,
literal|62
argument_list|,
literal|2
argument_list|,
literal|0x00
argument_list|)
condition|)
return|return;
while|while
condition|(
literal|1
condition|)
block|{
name|tmp
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_PREFETCH_STATUS
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|&
literal|0xFFFFFFFF
operator|)
operator|==
operator|(
operator|(
name|tmp
operator|>>
literal|32
operator|)
operator|&
literal|0xFFFFFFFF
operator|)
condition|)
break|break;
name|usleep_range
argument_list|(
literal|1000
argument_list|,
literal|2000
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|netdev_err
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"Failed polling on prefetch status\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_CFG
argument_list|,
name|qidx
argument_list|,
name|NICVF_RBDR_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|nicvf_poll_reg
argument_list|(
name|nic
argument_list|,
name|qidx
argument_list|,
name|NIC_QSET_RBDR_0_1_STATUS0
argument_list|,
literal|62
argument_list|,
literal|2
argument_list|,
literal|0x02
argument_list|)
condition|)
return|return;
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_CFG
argument_list|,
name|qidx
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
if|if
condition|(
name|nicvf_poll_reg
argument_list|(
name|nic
argument_list|,
name|qidx
argument_list|,
name|NIC_QSET_RBDR_0_1_STATUS0
argument_list|,
literal|62
argument_list|,
literal|2
argument_list|,
literal|0x00
argument_list|)
condition|)
return|return;
block|}
end_function

begin_function
name|void
name|nicvf_config_vlan_stripping
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|netdev_features_t
name|features
parameter_list|)
block|{
name|u64
name|rq_cfg
decl_stmt|;
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
name|int
name|sqs
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|rq_cfg
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RQ_GEN_CFG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable first VLAN stripping */
if|if
condition|(
name|features
operator|&
name|NETIF_F_HW_VLAN_CTAG_RX
condition|)
name|rq_cfg
operator||=
operator|(
literal|1ULL
operator|<<
literal|25
operator|)
expr_stmt|;
else|else
name|rq_cfg
operator|&=
operator|~
operator|(
literal|1ULL
operator|<<
literal|25
operator|)
expr_stmt|;
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RQ_GEN_CFG
argument_list|,
literal|0
argument_list|,
name|rq_cfg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
comment|/* Configure Secondary Qsets, if any */
for|for
control|(
name|sqs
operator|=
literal|0
init|;
name|sqs
operator|<
name|nic
operator|->
name|sqs_count
condition|;
name|sqs
operator|++
control|)
if|if
condition|(
name|nic
operator|->
name|snicvf
index|[
name|sqs
index|]
condition|)
name|nicvf_queue_reg_write
argument_list|(
name|nic
operator|->
name|snicvf
index|[
name|sqs
index|]
argument_list|,
name|NIC_QSET_RQ_GEN_CFG
argument_list|,
literal|0
argument_list|,
name|rq_cfg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Configures receive queue */
end_comment

begin_function
specifier|static
name|void
name|nicvf_rcv_queue_config
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|queue_set
modifier|*
name|qs
parameter_list|,
name|int
name|qidx
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|struct
name|rcv_queue
modifier|*
name|rq
decl_stmt|;
name|struct
name|cmp_queue
modifier|*
name|cq
decl_stmt|;
name|struct
name|rq_cfg
name|rq_cfg
decl_stmt|;
name|rq
operator|=
operator|&
name|qs
operator|->
name|rq
index|[
name|qidx
index|]
expr_stmt|;
name|rq
operator|->
name|enable
operator|=
name|enable
expr_stmt|;
comment|/* Disable receive queue */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rq
operator|->
name|enable
condition|)
block|{
name|nicvf_reclaim_rcv_queue
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
return|return;
block|}
name|rq
operator|->
name|cq_qs
operator|=
name|qs
operator|->
name|vnic_id
expr_stmt|;
name|rq
operator|->
name|cq_idx
operator|=
name|qidx
expr_stmt|;
name|rq
operator|->
name|start_rbdr_qs
operator|=
name|qs
operator|->
name|vnic_id
expr_stmt|;
name|rq
operator|->
name|start_qs_rbdr_idx
operator|=
name|qs
operator|->
name|rbdr_cnt
operator|-
literal|1
expr_stmt|;
name|rq
operator|->
name|cont_rbdr_qs
operator|=
name|qs
operator|->
name|vnic_id
expr_stmt|;
name|rq
operator|->
name|cont_qs_rbdr_idx
operator|=
name|qs
operator|->
name|rbdr_cnt
operator|-
literal|1
expr_stmt|;
comment|/* all writes of RBDR data to be loaded into L2 Cache as well*/
name|rq
operator|->
name|caching
operator|=
literal|1
expr_stmt|;
comment|/* Send a mailbox msg to PF to config RQ */
name|mbx
operator|.
name|rq
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_RQ_CFG
expr_stmt|;
name|mbx
operator|.
name|rq
operator|.
name|qs_num
operator|=
name|qs
operator|->
name|vnic_id
expr_stmt|;
name|mbx
operator|.
name|rq
operator|.
name|rq_num
operator|=
name|qidx
expr_stmt|;
name|mbx
operator|.
name|rq
operator|.
name|cfg
operator|=
operator|(
name|rq
operator|->
name|caching
operator|<<
literal|26
operator|)
operator||
operator|(
name|rq
operator|->
name|cq_qs
operator|<<
literal|19
operator|)
operator||
operator|(
name|rq
operator|->
name|cq_idx
operator|<<
literal|16
operator|)
operator||
operator|(
name|rq
operator|->
name|cont_rbdr_qs
operator|<<
literal|9
operator|)
operator||
operator|(
name|rq
operator|->
name|cont_qs_rbdr_idx
operator|<<
literal|8
operator|)
operator||
operator|(
name|rq
operator|->
name|start_rbdr_qs
operator|<<
literal|1
operator|)
operator||
operator|(
name|rq
operator|->
name|start_qs_rbdr_idx
operator|)
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
name|mbx
operator|.
name|rq
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_RQ_BP_CFG
expr_stmt|;
name|mbx
operator|.
name|rq
operator|.
name|cfg
operator|=
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
operator||
operator|(
literal|1ULL
operator|<<
literal|62
operator|)
operator||
operator|(
name|qs
operator|->
name|vnic_id
operator|<<
literal|0
operator|)
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
comment|/* RQ drop config 	 * Enable CQ drop to reserve sufficient CQEs for all tx packets 	 */
name|mbx
operator|.
name|rq
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_RQ_DROP_CFG
expr_stmt|;
name|mbx
operator|.
name|rq
operator|.
name|cfg
operator|=
operator|(
literal|1ULL
operator|<<
literal|62
operator|)
operator||
operator|(
name|RQ_CQ_DROP
operator|<<
literal|8
operator|)
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RQ_GEN_CFG
argument_list|,
literal|0
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nic
operator|->
name|sqs_mode
condition|)
name|nicvf_config_vlan_stripping
argument_list|(
name|nic
argument_list|,
name|nic
operator|->
name|netdev
operator|->
name|features
argument_list|)
expr_stmt|;
comment|/* Enable Receive queue */
name|rq_cfg
operator|.
name|ena
operator|=
literal|1
expr_stmt|;
name|rq_cfg
operator|.
name|tcp_ena
operator|=
literal|0
expr_stmt|;
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
operator|*
operator|(
name|u64
operator|*
operator|)
operator|&
name|rq_cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Configures completion queue */
end_comment

begin_function
name|void
name|nicvf_cmp_queue_config
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|queue_set
modifier|*
name|qs
parameter_list|,
name|int
name|qidx
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|struct
name|cmp_queue
modifier|*
name|cq
decl_stmt|;
name|struct
name|cq_cfg
name|cq_cfg
decl_stmt|;
name|cq
operator|=
operator|&
name|qs
operator|->
name|cq
index|[
name|qidx
index|]
expr_stmt|;
name|cq
operator|->
name|enable
operator|=
name|enable
expr_stmt|;
if|if
condition|(
operator|!
name|cq
operator|->
name|enable
condition|)
block|{
name|nicvf_reclaim_cmp_queue
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Reset completion queue */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
name|NICVF_CQ_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cq
operator|->
name|enable
condition|)
return|return;
name|spin_lock_init
argument_list|(
operator|&
name|cq
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* Set completion queue base address */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_BASE
argument_list|,
name|qidx
argument_list|,
call|(
name|u64
call|)
argument_list|(
name|cq
operator|->
name|dmem
operator|.
name|phys_base
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable Completion queue */
name|cq_cfg
operator|.
name|ena
operator|=
literal|1
expr_stmt|;
name|cq_cfg
operator|.
name|reset
operator|=
literal|0
expr_stmt|;
name|cq_cfg
operator|.
name|caching
operator|=
literal|0
expr_stmt|;
name|cq_cfg
operator|.
name|qsize
operator|=
name|CMP_QSIZE
expr_stmt|;
name|cq_cfg
operator|.
name|avg_con
operator|=
literal|0
expr_stmt|;
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
operator|*
operator|(
name|u64
operator|*
operator|)
operator|&
name|cq_cfg
argument_list|)
expr_stmt|;
comment|/* Set threshold value for interrupt generation */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_THRESH
argument_list|,
name|qidx
argument_list|,
name|cq
operator|->
name|thresh
argument_list|)
expr_stmt|;
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_CFG2
argument_list|,
name|qidx
argument_list|,
name|nic
operator|->
name|cq_coalesce_usecs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Configures transmit queue */
end_comment

begin_function
specifier|static
name|void
name|nicvf_snd_queue_config
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|queue_set
modifier|*
name|qs
parameter_list|,
name|int
name|qidx
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|struct
name|snd_queue
modifier|*
name|sq
decl_stmt|;
name|struct
name|sq_cfg
name|sq_cfg
decl_stmt|;
name|sq
operator|=
operator|&
name|qs
operator|->
name|sq
index|[
name|qidx
index|]
expr_stmt|;
name|sq
operator|->
name|enable
operator|=
name|enable
expr_stmt|;
if|if
condition|(
operator|!
name|sq
operator|->
name|enable
condition|)
block|{
name|nicvf_reclaim_snd_queue
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Reset send queue */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
name|NICVF_SQ_RESET
argument_list|)
expr_stmt|;
name|sq
operator|->
name|cq_qs
operator|=
name|qs
operator|->
name|vnic_id
expr_stmt|;
name|sq
operator|->
name|cq_idx
operator|=
name|qidx
expr_stmt|;
comment|/* Send a mailbox msg to PF to config SQ */
name|mbx
operator|.
name|sq
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_SQ_CFG
expr_stmt|;
name|mbx
operator|.
name|sq
operator|.
name|qs_num
operator|=
name|qs
operator|->
name|vnic_id
expr_stmt|;
name|mbx
operator|.
name|sq
operator|.
name|sq_num
operator|=
name|qidx
expr_stmt|;
name|mbx
operator|.
name|sq
operator|.
name|sqs_mode
operator|=
name|nic
operator|->
name|sqs_mode
expr_stmt|;
name|mbx
operator|.
name|sq
operator|.
name|cfg
operator|=
operator|(
name|sq
operator|->
name|cq_qs
operator|<<
literal|3
operator|)
operator||
name|sq
operator|->
name|cq_idx
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
comment|/* Set queue base address */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_BASE
argument_list|,
name|qidx
argument_list|,
call|(
name|u64
call|)
argument_list|(
name|sq
operator|->
name|dmem
operator|.
name|phys_base
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable send queue& set queue size */
name|sq_cfg
operator|.
name|ena
operator|=
literal|1
expr_stmt|;
name|sq_cfg
operator|.
name|reset
operator|=
literal|0
expr_stmt|;
name|sq_cfg
operator|.
name|ldwb
operator|=
literal|0
expr_stmt|;
name|sq_cfg
operator|.
name|qsize
operator|=
name|SND_QSIZE
expr_stmt|;
name|sq_cfg
operator|.
name|tstmp_bgx_intf
operator|=
literal|0
expr_stmt|;
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
operator|*
operator|(
name|u64
operator|*
operator|)
operator|&
name|sq_cfg
argument_list|)
expr_stmt|;
comment|/* Set threshold value for interrupt generation */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_THRESH
argument_list|,
name|qidx
argument_list|,
name|sq
operator|->
name|thresh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Configures receive buffer descriptor ring */
end_comment

begin_function
specifier|static
name|void
name|nicvf_rbdr_config
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|queue_set
modifier|*
name|qs
parameter_list|,
name|int
name|qidx
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|struct
name|rbdr
modifier|*
name|rbdr
decl_stmt|;
name|struct
name|rbdr_cfg
name|rbdr_cfg
decl_stmt|;
name|rbdr
operator|=
operator|&
name|qs
operator|->
name|rbdr
index|[
name|qidx
index|]
expr_stmt|;
name|nicvf_reclaim_rbdr
argument_list|(
name|nic
argument_list|,
name|rbdr
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
return|return;
comment|/* Set descriptor base address */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_BASE
argument_list|,
name|qidx
argument_list|,
call|(
name|u64
call|)
argument_list|(
name|rbdr
operator|->
name|dmem
operator|.
name|phys_base
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable RBDR& set queue size */
comment|/* Buffer size should be in multiples of 128 bytes */
name|rbdr_cfg
operator|.
name|ena
operator|=
literal|1
expr_stmt|;
name|rbdr_cfg
operator|.
name|reset
operator|=
literal|0
expr_stmt|;
name|rbdr_cfg
operator|.
name|ldwb
operator|=
literal|0
expr_stmt|;
name|rbdr_cfg
operator|.
name|qsize
operator|=
name|RBDR_SIZE
expr_stmt|;
name|rbdr_cfg
operator|.
name|avg_con
operator|=
literal|0
expr_stmt|;
name|rbdr_cfg
operator|.
name|lines
operator|=
name|rbdr
operator|->
name|dma_size
operator|/
literal|128
expr_stmt|;
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_CFG
argument_list|,
name|qidx
argument_list|,
operator|*
operator|(
name|u64
operator|*
operator|)
operator|&
name|rbdr_cfg
argument_list|)
expr_stmt|;
comment|/* Notify HW */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_DOOR
argument_list|,
name|qidx
argument_list|,
name|qs
operator|->
name|rbdr_len
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Set threshold value for interrupt generation */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_RBDR_0_1_THRESH
argument_list|,
name|qidx
argument_list|,
name|rbdr
operator|->
name|thresh
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Requests PF to assign and enable Qset */
end_comment

begin_function
name|void
name|nicvf_qset_config
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
init|=
name|nic
operator|->
name|qs
decl_stmt|;
name|struct
name|qs_cfg
modifier|*
name|qs_cfg
decl_stmt|;
if|if
condition|(
operator|!
name|qs
condition|)
block|{
name|netdev_warn
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"Qset is still not allocated, don't init queues\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|qs
operator|->
name|enable
operator|=
name|enable
expr_stmt|;
name|qs
operator|->
name|vnic_id
operator|=
name|nic
operator|->
name|vf_id
expr_stmt|;
comment|/* Send a mailbox msg to PF to config Qset */
name|mbx
operator|.
name|qs
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_QS_CFG
expr_stmt|;
name|mbx
operator|.
name|qs
operator|.
name|num
operator|=
name|qs
operator|->
name|vnic_id
expr_stmt|;
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
name|mbx
operator|.
name|qs
operator|.
name|sqs_count
operator|=
name|nic
operator|->
name|sqs_count
expr_stmt|;
endif|#
directive|endif
name|mbx
operator|.
name|qs
operator|.
name|cfg
operator|=
literal|0
expr_stmt|;
name|qs_cfg
operator|=
operator|(
expr|struct
name|qs_cfg
operator|*
operator|)
operator|&
name|mbx
operator|.
name|qs
operator|.
name|cfg
expr_stmt|;
if|if
condition|(
name|qs
operator|->
name|enable
condition|)
block|{
name|qs_cfg
operator|->
name|ena
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|qs_cfg
operator|->
name|be
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|qs_cfg
operator|->
name|vnic
operator|=
name|qs
operator|->
name|vnic_id
expr_stmt|;
block|}
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_free_resources
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|qidx
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
init|=
name|nic
operator|->
name|qs
decl_stmt|;
comment|/* Free receive buffer descriptor ring */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|rbdr_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_free_rbdr
argument_list|(
name|nic
argument_list|,
operator|&
name|qs
operator|->
name|rbdr
index|[
name|qidx
index|]
argument_list|)
expr_stmt|;
comment|/* Free completion queue */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|cq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_free_cmp_queue
argument_list|(
name|nic
argument_list|,
operator|&
name|qs
operator|->
name|cq
index|[
name|qidx
index|]
argument_list|)
expr_stmt|;
comment|/* Free send queue */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|sq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_free_snd_queue
argument_list|(
name|nic
argument_list|,
operator|&
name|qs
operator|->
name|sq
index|[
name|qidx
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_alloc_resources
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|qidx
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
init|=
name|nic
operator|->
name|qs
decl_stmt|;
comment|/* Alloc receive buffer descriptor ring */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|rbdr_cnt
condition|;
name|qidx
operator|++
control|)
block|{
if|if
condition|(
name|nicvf_init_rbdr
argument_list|(
name|nic
argument_list|,
operator|&
name|qs
operator|->
name|rbdr
index|[
name|qidx
index|]
argument_list|,
name|qs
operator|->
name|rbdr_len
argument_list|,
name|DMA_BUFFER_LEN
argument_list|)
condition|)
goto|goto
name|alloc_fail
goto|;
block|}
comment|/* Alloc send queue */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|sq_cnt
condition|;
name|qidx
operator|++
control|)
block|{
if|if
condition|(
name|nicvf_init_snd_queue
argument_list|(
name|nic
argument_list|,
operator|&
name|qs
operator|->
name|sq
index|[
name|qidx
index|]
argument_list|,
name|qs
operator|->
name|sq_len
argument_list|)
condition|)
goto|goto
name|alloc_fail
goto|;
block|}
comment|/* Alloc completion queue */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|cq_cnt
condition|;
name|qidx
operator|++
control|)
block|{
if|if
condition|(
name|nicvf_init_cmp_queue
argument_list|(
name|nic
argument_list|,
operator|&
name|qs
operator|->
name|cq
index|[
name|qidx
index|]
argument_list|,
name|qs
operator|->
name|cq_len
argument_list|)
condition|)
goto|goto
name|alloc_fail
goto|;
block|}
return|return
literal|0
return|;
name|alloc_fail
label|:
name|nicvf_free_resources
argument_list|(
name|nic
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
end_function

begin_function
name|int
name|nicvf_set_qset_resources
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|struct
name|queue_set
modifier|*
name|qs
decl_stmt|;
name|qs
operator|=
name|devm_kzalloc
argument_list|(
operator|&
name|nic
operator|->
name|pdev
operator|->
name|dev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|qs
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qs
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|nic
operator|->
name|qs
operator|=
name|qs
expr_stmt|;
comment|/* Set count of each queue */
name|qs
operator|->
name|rbdr_cnt
operator|=
name|RBDR_CNT
expr_stmt|;
ifdef|#
directive|ifdef
name|VNIC_RSS_SUPPORT
name|qs
operator|->
name|rq_cnt
operator|=
name|RCV_QUEUE_CNT
expr_stmt|;
else|#
directive|else
name|qs
operator|->
name|rq_cnt
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|qs
operator|->
name|sq_cnt
operator|=
name|SND_QUEUE_CNT
expr_stmt|;
name|qs
operator|->
name|cq_cnt
operator|=
name|CMP_QUEUE_CNT
expr_stmt|;
comment|/* Set queue lengths */
name|qs
operator|->
name|rbdr_len
operator|=
name|RCV_BUF_COUNT
expr_stmt|;
name|qs
operator|->
name|sq_len
operator|=
name|SND_QUEUE_LEN
expr_stmt|;
name|qs
operator|->
name|cq_len
operator|=
name|CMP_QUEUE_LEN
expr_stmt|;
name|nic
operator|->
name|rx_queues
operator|=
name|qs
operator|->
name|rq_cnt
expr_stmt|;
name|nic
operator|->
name|tx_queues
operator|=
name|qs
operator|->
name|sq_cnt
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|nicvf_config_data_transfer
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|bool
name|disable
init|=
name|false
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
init|=
name|nic
operator|->
name|qs
decl_stmt|;
name|int
name|qidx
decl_stmt|;
if|if
condition|(
operator|!
name|qs
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|enable
condition|)
block|{
if|if
condition|(
name|nicvf_alloc_resources
argument_list|(
name|nic
argument_list|)
condition|)
return|return
operator|-
name|ENOMEM
return|;
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|sq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_snd_queue_config
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|,
name|enable
argument_list|)
expr_stmt|;
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|cq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_cmp_queue_config
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|,
name|enable
argument_list|)
expr_stmt|;
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|rbdr_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_rbdr_config
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|,
name|enable
argument_list|)
expr_stmt|;
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|rq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_rcv_queue_config
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|,
name|enable
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|rq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_rcv_queue_config
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|,
name|disable
argument_list|)
expr_stmt|;
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|rbdr_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_rbdr_config
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|,
name|disable
argument_list|)
expr_stmt|;
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|sq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_snd_queue_config
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|,
name|disable
argument_list|)
expr_stmt|;
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|cq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_cmp_queue_config
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|,
name|disable
argument_list|)
expr_stmt|;
name|nicvf_free_resources
argument_list|(
name|nic
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get a free desc from SQ  * returns descriptor ponter& descriptor number  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|nicvf_get_sq_desc
parameter_list|(
name|struct
name|snd_queue
modifier|*
name|sq
parameter_list|,
name|int
name|desc_cnt
parameter_list|)
block|{
name|int
name|qentry
decl_stmt|;
name|qentry
operator|=
name|sq
operator|->
name|tail
expr_stmt|;
name|atomic_sub
argument_list|(
name|desc_cnt
argument_list|,
operator|&
name|sq
operator|->
name|free_cnt
argument_list|)
expr_stmt|;
name|sq
operator|->
name|tail
operator|+=
name|desc_cnt
expr_stmt|;
name|sq
operator|->
name|tail
operator|&=
operator|(
name|sq
operator|->
name|dmem
operator|.
name|q_len
operator|-
literal|1
operator|)
expr_stmt|;
return|return
name|qentry
return|;
block|}
end_function

begin_comment
comment|/* Free descriptor back to SQ for future use */
end_comment

begin_function
name|void
name|nicvf_put_sq_desc
parameter_list|(
name|struct
name|snd_queue
modifier|*
name|sq
parameter_list|,
name|int
name|desc_cnt
parameter_list|)
block|{
name|atomic_add
argument_list|(
name|desc_cnt
argument_list|,
operator|&
name|sq
operator|->
name|free_cnt
argument_list|)
expr_stmt|;
name|sq
operator|->
name|head
operator|+=
name|desc_cnt
expr_stmt|;
name|sq
operator|->
name|head
operator|&=
operator|(
name|sq
operator|->
name|dmem
operator|.
name|q_len
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|nicvf_get_nxt_sqentry
parameter_list|(
name|struct
name|snd_queue
modifier|*
name|sq
parameter_list|,
name|int
name|qentry
parameter_list|)
block|{
name|qentry
operator|++
expr_stmt|;
name|qentry
operator|&=
operator|(
name|sq
operator|->
name|dmem
operator|.
name|q_len
operator|-
literal|1
operator|)
expr_stmt|;
return|return
name|qentry
return|;
block|}
end_function

begin_function
name|void
name|nicvf_sq_enable
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|snd_queue
modifier|*
name|sq
parameter_list|,
name|int
name|qidx
parameter_list|)
block|{
name|u64
name|sq_cfg
decl_stmt|;
name|sq_cfg
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_CFG
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|sq_cfg
operator||=
name|NICVF_SQ_EN
expr_stmt|;
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
name|sq_cfg
argument_list|)
expr_stmt|;
comment|/* Ring doorbell so that H/W restarts processing SQEs */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_DOOR
argument_list|,
name|qidx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nicvf_sq_disable
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|int
name|qidx
parameter_list|)
block|{
name|u64
name|sq_cfg
decl_stmt|;
name|sq_cfg
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_CFG
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|sq_cfg
operator|&=
operator|~
name|NICVF_SQ_EN
expr_stmt|;
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_CFG
argument_list|,
name|qidx
argument_list|,
name|sq_cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nicvf_sq_free_used_descs
parameter_list|(
name|struct
name|net_device
modifier|*
name|netdev
parameter_list|,
name|struct
name|snd_queue
modifier|*
name|sq
parameter_list|,
name|int
name|qidx
parameter_list|)
block|{
name|u64
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|struct
name|sk_buff
modifier|*
name|skb
decl_stmt|;
name|struct
name|nicvf
modifier|*
name|nic
init|=
name|netdev_priv
argument_list|(
name|netdev
argument_list|)
decl_stmt|;
name|struct
name|sq_hdr_subdesc
modifier|*
name|hdr
decl_stmt|;
name|head
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_HEAD
argument_list|,
name|qidx
argument_list|)
operator|>>
literal|4
expr_stmt|;
name|tail
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_TAIL
argument_list|,
name|qidx
argument_list|)
operator|>>
literal|4
expr_stmt|;
while|while
condition|(
name|sq
operator|->
name|head
operator|!=
name|head
condition|)
block|{
name|hdr
operator|=
operator|(
expr|struct
name|sq_hdr_subdesc
operator|*
operator|)
name|GET_SQ_DESC
argument_list|(
name|sq
argument_list|,
name|sq
operator|->
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|subdesc_type
operator|!=
name|SQ_DESC_TYPE_HEADER
condition|)
block|{
name|nicvf_put_sq_desc
argument_list|(
name|sq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|skb
operator|=
operator|(
expr|struct
name|sk_buff
operator|*
operator|)
name|sq
operator|->
name|skbuff
index|[
name|sq
operator|->
name|head
index|]
expr_stmt|;
if|if
condition|(
name|skb
condition|)
name|dev_kfree_skb_any
argument_list|(
name|skb
argument_list|)
expr_stmt|;
name|atomic64_add
argument_list|(
literal|1
argument_list|,
operator|(
name|atomic64_t
operator|*
operator|)
operator|&
name|netdev
operator|->
name|stats
operator|.
name|tx_packets
argument_list|)
expr_stmt|;
name|atomic64_add
argument_list|(
name|hdr
operator|->
name|tot_len
argument_list|,
operator|(
name|atomic64_t
operator|*
operator|)
operator|&
name|netdev
operator|->
name|stats
operator|.
name|tx_bytes
argument_list|)
expr_stmt|;
name|nicvf_put_sq_desc
argument_list|(
name|sq
argument_list|,
name|hdr
operator|->
name|subdesc_cnt
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get the number of SQ descriptors needed to xmit this skb */
end_comment

begin_function
specifier|static
name|int
name|nicvf_sq_subdesc_required
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|sk_buff
modifier|*
name|skb
parameter_list|)
block|{
name|int
name|subdesc_cnt
init|=
name|MIN_SQ_DESC_PER_PKT_XMIT
decl_stmt|;
if|if
condition|(
name|skb_shinfo
argument_list|(
name|skb
argument_list|)
operator|->
name|gso_size
condition|)
block|{
name|subdesc_cnt
operator|=
name|nicvf_tso_count_subdescs
argument_list|(
name|skb
argument_list|)
expr_stmt|;
return|return
name|subdesc_cnt
return|;
block|}
if|if
condition|(
name|skb_shinfo
argument_list|(
name|skb
argument_list|)
operator|->
name|nr_frags
condition|)
name|subdesc_cnt
operator|+=
name|skb_shinfo
argument_list|(
name|skb
argument_list|)
operator|->
name|nr_frags
expr_stmt|;
return|return
name|subdesc_cnt
return|;
block|}
end_function

begin_comment
comment|/* Add SQ HEADER subdescriptor.  * First subdescriptor for every send descriptor.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|nicvf_sq_add_hdr_subdesc
parameter_list|(
name|struct
name|snd_queue
modifier|*
name|sq
parameter_list|,
name|int
name|qentry
parameter_list|,
name|int
name|subdesc_cnt
parameter_list|,
name|struct
name|sk_buff
modifier|*
name|skb
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|proto
decl_stmt|;
name|struct
name|sq_hdr_subdesc
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|sq_hdr_subdesc
operator|*
operator|)
name|GET_SQ_DESC
argument_list|(
name|sq
argument_list|,
name|qentry
argument_list|)
expr_stmt|;
name|sq
operator|->
name|skbuff
index|[
name|qentry
index|]
operator|=
operator|(
name|u64
operator|)
name|skb
expr_stmt|;
name|memset
argument_list|(
name|hdr
argument_list|,
literal|0
argument_list|,
name|SND_QUEUE_DESC_SIZE
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|subdesc_type
operator|=
name|SQ_DESC_TYPE_HEADER
expr_stmt|;
comment|/* Enable notification via CQE after processing SQE */
name|hdr
operator|->
name|post_cqe
operator|=
literal|1
expr_stmt|;
comment|/* No of subdescriptors following this */
name|hdr
operator|->
name|subdesc_cnt
operator|=
name|subdesc_cnt
expr_stmt|;
name|hdr
operator|->
name|tot_len
operator|=
name|len
expr_stmt|;
comment|/* Offload checksum calculation to HW */
if|if
condition|(
name|skb
operator|->
name|ip_summed
operator|==
name|CHECKSUM_PARTIAL
condition|)
block|{
name|hdr
operator|->
name|csum_l3
operator|=
literal|1
expr_stmt|;
comment|/* Enable IP csum calculation */
name|hdr
operator|->
name|l3_offset
operator|=
name|skb_network_offset
argument_list|(
name|skb
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|l4_offset
operator|=
name|skb_transport_offset
argument_list|(
name|skb
argument_list|)
expr_stmt|;
name|proto
operator|=
name|ip_hdr
argument_list|(
name|skb
argument_list|)
operator|->
name|protocol
expr_stmt|;
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|hdr
operator|->
name|csum_l4
operator|=
name|SEND_L4_CSUM_TCP
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|hdr
operator|->
name|csum_l4
operator|=
name|SEND_L4_CSUM_UDP
expr_stmt|;
break|break;
case|case
name|IPPROTO_SCTP
case|:
name|hdr
operator|->
name|csum_l4
operator|=
name|SEND_L4_CSUM_SCTP
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* SQ GATHER subdescriptor  * Must follow HDR descriptor  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|nicvf_sq_add_gather_subdesc
parameter_list|(
name|struct
name|snd_queue
modifier|*
name|sq
parameter_list|,
name|int
name|qentry
parameter_list|,
name|int
name|size
parameter_list|,
name|u64
name|data
parameter_list|)
block|{
name|struct
name|sq_gather_subdesc
modifier|*
name|gather
decl_stmt|;
name|qentry
operator|&=
operator|(
name|sq
operator|->
name|dmem
operator|.
name|q_len
operator|-
literal|1
operator|)
expr_stmt|;
name|gather
operator|=
operator|(
expr|struct
name|sq_gather_subdesc
operator|*
operator|)
name|GET_SQ_DESC
argument_list|(
name|sq
argument_list|,
name|qentry
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|gather
argument_list|,
literal|0
argument_list|,
name|SND_QUEUE_DESC_SIZE
argument_list|)
expr_stmt|;
name|gather
operator|->
name|subdesc_type
operator|=
name|SQ_DESC_TYPE_GATHER
expr_stmt|;
name|gather
operator|->
name|ld_type
operator|=
name|NIC_SEND_LD_TYPE_E_LDD
expr_stmt|;
name|gather
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|gather
operator|->
name|addr
operator|=
name|data
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append an skb to a SQ for packet transfer. */
end_comment

begin_function
name|int
name|nicvf_sq_append_skb
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|sk_buff
modifier|*
name|skb
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
name|int
name|subdesc_cnt
decl_stmt|;
name|int
name|sq_num
decl_stmt|,
name|qentry
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
decl_stmt|;
name|struct
name|snd_queue
modifier|*
name|sq
decl_stmt|;
name|sq_num
operator|=
name|skb_get_queue_mapping
argument_list|(
name|skb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
if|if
condition|(
name|sq_num
operator|>=
name|MAX_SND_QUEUES_PER_QS
condition|)
block|{
comment|/* Get secondary Qset's SQ structure */
name|i
operator|=
name|sq_num
operator|/
name|MAX_SND_QUEUES_PER_QS
expr_stmt|;
if|if
condition|(
operator|!
name|nic
operator|->
name|snicvf
index|[
name|i
operator|-
literal|1
index|]
condition|)
block|{
name|netdev_warn
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"Secondary Qset#%d's ptr not initialized\n"
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|nic
operator|=
operator|(
expr|struct
name|nicvf
operator|*
operator|)
name|nic
operator|->
name|snicvf
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|sq_num
operator|=
name|sq_num
operator|%
name|MAX_SND_QUEUES_PER_QS
expr_stmt|;
block|}
endif|#
directive|endif
name|qs
operator|=
name|nic
operator|->
name|qs
expr_stmt|;
name|sq
operator|=
operator|&
name|qs
operator|->
name|sq
index|[
name|sq_num
index|]
expr_stmt|;
name|subdesc_cnt
operator|=
name|nicvf_sq_subdesc_required
argument_list|(
name|nic
argument_list|,
name|skb
argument_list|)
expr_stmt|;
if|if
condition|(
name|subdesc_cnt
operator|>
name|atomic_read
argument_list|(
operator|&
name|sq
operator|->
name|free_cnt
argument_list|)
condition|)
goto|goto
name|append_fail
goto|;
name|qentry
operator|=
name|nicvf_get_sq_desc
argument_list|(
name|sq
argument_list|,
name|subdesc_cnt
argument_list|)
expr_stmt|;
comment|/* Add SQ header subdesc */
name|nicvf_sq_add_hdr_subdesc
argument_list|(
name|sq
argument_list|,
name|qentry
argument_list|,
name|subdesc_cnt
operator|-
literal|1
argument_list|,
name|skb
argument_list|,
name|skb
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* Add SQ gather subdescs */
name|qentry
operator|=
name|nicvf_get_nxt_sqentry
argument_list|(
name|sq
argument_list|,
name|qentry
argument_list|)
expr_stmt|;
name|size
operator|=
name|skb_is_nonlinear
argument_list|(
name|skb
argument_list|)
condition|?
name|skb_headlen
argument_list|(
name|skb
argument_list|)
else|:
name|skb
operator|->
name|len
expr_stmt|;
name|nicvf_sq_add_gather_subdesc
argument_list|(
name|sq
argument_list|,
name|qentry
argument_list|,
name|size
argument_list|,
name|virt_to_phys
argument_list|(
name|skb
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for scattered buffer */
if|if
condition|(
operator|!
name|skb_is_nonlinear
argument_list|(
name|skb
argument_list|)
condition|)
goto|goto
name|doorbell
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|skb_shinfo
argument_list|(
name|skb
argument_list|)
operator|->
name|nr_frags
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|skb_frag_struct
modifier|*
name|frag
decl_stmt|;
name|frag
operator|=
operator|&
name|skb_shinfo
argument_list|(
name|skb
argument_list|)
operator|->
name|frags
index|[
name|i
index|]
expr_stmt|;
name|qentry
operator|=
name|nicvf_get_nxt_sqentry
argument_list|(
name|sq
argument_list|,
name|qentry
argument_list|)
expr_stmt|;
name|size
operator|=
name|skb_frag_size
argument_list|(
name|frag
argument_list|)
expr_stmt|;
name|nicvf_sq_add_gather_subdesc
argument_list|(
name|sq
argument_list|,
name|qentry
argument_list|,
name|size
argument_list|,
name|virt_to_phys
argument_list|(
name|skb_frag_address
argument_list|(
name|frag
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|doorbell
label|:
comment|/* make sure all memory stores are done before ringing doorbell */
name|smp_wmb
argument_list|()
expr_stmt|;
comment|/* Inform HW to xmit new packet */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_SQ_0_7_DOOR
argument_list|,
name|sq_num
argument_list|,
name|subdesc_cnt
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|append_fail
label|:
comment|/* Use original PCI dev for debug log */
name|nic
operator|=
name|nic
operator|->
name|pnicvf
expr_stmt|;
name|netdev_dbg
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"Not enough SQ descriptors to xmit pkt\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|frag_num
parameter_list|(
name|unsigned
name|i
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
return|return
operator|(
name|i
operator|&
operator|~
literal|3
operator|)
operator|+
literal|3
operator|-
operator|(
name|i
operator|&
literal|3
operator|)
return|;
else|#
directive|else
return|return
name|i
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Returns SKB for a received packet */
end_comment

begin_function
name|struct
name|sk_buff
modifier|*
name|nicvf_get_rcv_skb
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|cqe_rx_t
modifier|*
name|cqe_rx
parameter_list|)
block|{
name|int
name|frag
decl_stmt|;
name|int
name|payload_len
init|=
literal|0
decl_stmt|;
name|struct
name|sk_buff
modifier|*
name|skb
init|=
name|NULL
decl_stmt|;
name|struct
name|sk_buff
modifier|*
name|skb_frag
init|=
name|NULL
decl_stmt|;
name|struct
name|sk_buff
modifier|*
name|prev_frag
init|=
name|NULL
decl_stmt|;
name|u16
modifier|*
name|rb_lens
init|=
name|NULL
decl_stmt|;
name|u64
modifier|*
name|rb_ptrs
init|=
name|NULL
decl_stmt|;
name|rb_lens
operator|=
operator|(
name|void
operator|*
operator|)
name|cqe_rx
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
operator|)
expr_stmt|;
name|rb_ptrs
operator|=
operator|(
name|void
operator|*
operator|)
name|cqe_rx
operator|+
operator|(
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
operator|)
expr_stmt|;
name|netdev_dbg
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"%s rb_cnt %d rb0_ptr %llx rb0_sz %d\n"
argument_list|,
name|__func__
argument_list|,
name|cqe_rx
operator|->
name|rb_cnt
argument_list|,
name|cqe_rx
operator|->
name|rb0_ptr
argument_list|,
name|cqe_rx
operator|->
name|rb0_sz
argument_list|)
expr_stmt|;
for|for
control|(
name|frag
operator|=
literal|0
init|;
name|frag
operator|<
name|cqe_rx
operator|->
name|rb_cnt
condition|;
name|frag
operator|++
control|)
block|{
name|payload_len
operator|=
name|rb_lens
index|[
name|frag_num
argument_list|(
name|frag
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|frag
condition|)
block|{
comment|/* First fragment */
name|skb
operator|=
name|nicvf_rb_ptr_to_skb
argument_list|(
name|nic
argument_list|,
operator|*
name|rb_ptrs
operator|-
name|cqe_rx
operator|->
name|align_pad
argument_list|,
name|payload_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skb
condition|)
return|return
name|NULL
return|;
name|skb_reserve
argument_list|(
name|skb
argument_list|,
name|cqe_rx
operator|->
name|align_pad
argument_list|)
expr_stmt|;
name|skb_put
argument_list|(
name|skb
argument_list|,
name|payload_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add fragments */
name|skb_frag
operator|=
name|nicvf_rb_ptr_to_skb
argument_list|(
name|nic
argument_list|,
operator|*
name|rb_ptrs
argument_list|,
name|payload_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skb_frag
condition|)
block|{
name|dev_kfree_skb
argument_list|(
name|skb
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|skb_shinfo
argument_list|(
name|skb
argument_list|)
operator|->
name|frag_list
condition|)
name|skb_shinfo
argument_list|(
name|skb
argument_list|)
operator|->
name|frag_list
operator|=
name|skb_frag
expr_stmt|;
else|else
name|prev_frag
operator|->
name|next
operator|=
name|skb_frag
expr_stmt|;
name|prev_frag
operator|=
name|skb_frag
expr_stmt|;
name|skb
operator|->
name|len
operator|+=
name|payload_len
expr_stmt|;
name|skb
operator|->
name|data_len
operator|+=
name|payload_len
expr_stmt|;
name|skb_frag
operator|->
name|len
operator|=
name|payload_len
expr_stmt|;
block|}
comment|/* Next buffer pointer */
name|rb_ptrs
operator|++
expr_stmt|;
block|}
return|return
name|skb
return|;
block|}
end_function

begin_comment
comment|/* Enable interrupt */
end_comment

begin_function
name|void
name|nicvf_enable_intr
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|int
name|int_type
parameter_list|,
name|int
name|q_idx
parameter_list|)
block|{
name|u64
name|reg_val
decl_stmt|;
name|reg_val
operator|=
name|nicvf_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_VF_ENA_W1S
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|int_type
condition|)
block|{
case|case
name|NICVF_INTR_CQ
case|:
name|reg_val
operator||=
operator|(
operator|(
literal|1ULL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_CQ_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_SQ
case|:
name|reg_val
operator||=
operator|(
operator|(
literal|1ULL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_SQ_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_RBDR
case|:
name|reg_val
operator||=
operator|(
operator|(
literal|1ULL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_RBDR_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_PKT_DROP
case|:
name|reg_val
operator||=
operator|(
literal|1ULL
operator|<<
name|NICVF_INTR_PKT_DROP_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_TCP_TIMER
case|:
name|reg_val
operator||=
operator|(
literal|1ULL
operator|<<
name|NICVF_INTR_TCP_TIMER_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_MBOX
case|:
name|reg_val
operator||=
operator|(
literal|1ULL
operator|<<
name|NICVF_INTR_MBOX_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_QS_ERR
case|:
name|reg_val
operator||=
operator|(
literal|1ULL
operator|<<
name|NICVF_INTR_QS_ERR_SHIFT
operator|)
expr_stmt|;
break|break;
default|default:
name|netdev_err
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"Failed to enable interrupt: unknown type\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|nicvf_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_VF_ENA_W1S
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Disable interrupt */
end_comment

begin_function
name|void
name|nicvf_disable_intr
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|int
name|int_type
parameter_list|,
name|int
name|q_idx
parameter_list|)
block|{
name|u64
name|reg_val
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|int_type
condition|)
block|{
case|case
name|NICVF_INTR_CQ
case|:
name|reg_val
operator||=
operator|(
operator|(
literal|1ULL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_CQ_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_SQ
case|:
name|reg_val
operator||=
operator|(
operator|(
literal|1ULL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_SQ_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_RBDR
case|:
name|reg_val
operator||=
operator|(
operator|(
literal|1ULL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_RBDR_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_PKT_DROP
case|:
name|reg_val
operator||=
operator|(
literal|1ULL
operator|<<
name|NICVF_INTR_PKT_DROP_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_TCP_TIMER
case|:
name|reg_val
operator||=
operator|(
literal|1ULL
operator|<<
name|NICVF_INTR_TCP_TIMER_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_MBOX
case|:
name|reg_val
operator||=
operator|(
literal|1ULL
operator|<<
name|NICVF_INTR_MBOX_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_QS_ERR
case|:
name|reg_val
operator||=
operator|(
literal|1ULL
operator|<<
name|NICVF_INTR_QS_ERR_SHIFT
operator|)
expr_stmt|;
break|break;
default|default:
name|netdev_err
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"Failed to disable interrupt: unknown type\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|nicvf_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_VF_ENA_W1C
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear interrupt */
end_comment

begin_function
name|void
name|nicvf_clear_intr
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|int
name|int_type
parameter_list|,
name|int
name|q_idx
parameter_list|)
block|{
name|u64
name|reg_val
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|int_type
condition|)
block|{
case|case
name|NICVF_INTR_CQ
case|:
name|reg_val
operator|=
operator|(
operator|(
literal|1ULL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_CQ_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_SQ
case|:
name|reg_val
operator|=
operator|(
operator|(
literal|1ULL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_SQ_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_RBDR
case|:
name|reg_val
operator|=
operator|(
operator|(
literal|1ULL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_RBDR_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_PKT_DROP
case|:
name|reg_val
operator|=
operator|(
literal|1ULL
operator|<<
name|NICVF_INTR_PKT_DROP_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_TCP_TIMER
case|:
name|reg_val
operator|=
operator|(
literal|1ULL
operator|<<
name|NICVF_INTR_TCP_TIMER_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_MBOX
case|:
name|reg_val
operator|=
operator|(
literal|1ULL
operator|<<
name|NICVF_INTR_MBOX_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_QS_ERR
case|:
name|reg_val
operator||=
operator|(
literal|1ULL
operator|<<
name|NICVF_INTR_QS_ERR_SHIFT
operator|)
expr_stmt|;
break|break;
default|default:
name|netdev_err
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"Failed to clear interrupt: unknown type\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|nicvf_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_VF_INT
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check if interrupt is enabled */
end_comment

begin_function
name|int
name|nicvf_is_intr_enabled
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|int
name|int_type
parameter_list|,
name|int
name|q_idx
parameter_list|)
block|{
name|u64
name|reg_val
decl_stmt|;
name|u64
name|mask
init|=
literal|0xff
decl_stmt|;
name|reg_val
operator|=
name|nicvf_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_VF_ENA_W1S
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|int_type
condition|)
block|{
case|case
name|NICVF_INTR_CQ
case|:
name|mask
operator|=
operator|(
operator|(
literal|1ULL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_CQ_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_SQ
case|:
name|mask
operator|=
operator|(
operator|(
literal|1ULL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_SQ_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_RBDR
case|:
name|mask
operator|=
operator|(
operator|(
literal|1ULL
operator|<<
name|q_idx
operator|)
operator|<<
name|NICVF_INTR_RBDR_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_PKT_DROP
case|:
name|mask
operator|=
name|NICVF_INTR_PKT_DROP_MASK
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_TCP_TIMER
case|:
name|mask
operator|=
name|NICVF_INTR_TCP_TIMER_MASK
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_MBOX
case|:
name|mask
operator|=
name|NICVF_INTR_MBOX_MASK
expr_stmt|;
break|break;
case|case
name|NICVF_INTR_QS_ERR
case|:
name|mask
operator|=
name|NICVF_INTR_QS_ERR_MASK
expr_stmt|;
break|break;
default|default:
name|netdev_err
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"Failed to check interrupt enable: unknown type\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|reg_val
operator|&
name|mask
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nicvf_update_rq_stats
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|int
name|rq_idx
parameter_list|)
block|{
name|struct
name|rcv_queue
modifier|*
name|rq
decl_stmt|;
define|#
directive|define
name|GET_RQ_STATS
parameter_list|(
name|reg
parameter_list|)
define|\
value|nicvf_reg_read(nic, NIC_QSET_RQ_0_7_STAT_0_1 |\ 			    (rq_idx<< NIC_Q_NUM_SHIFT) | (reg<< 3))
name|rq
operator|=
operator|&
name|nic
operator|->
name|qs
operator|->
name|rq
index|[
name|rq_idx
index|]
expr_stmt|;
name|rq
operator|->
name|stats
operator|.
name|bytes
operator|=
name|GET_RQ_STATS
argument_list|(
name|RQ_SQ_STATS_OCTS
argument_list|)
expr_stmt|;
name|rq
operator|->
name|stats
operator|.
name|pkts
operator|=
name|GET_RQ_STATS
argument_list|(
name|RQ_SQ_STATS_PKTS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nicvf_update_sq_stats
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|int
name|sq_idx
parameter_list|)
block|{
name|struct
name|snd_queue
modifier|*
name|sq
decl_stmt|;
define|#
directive|define
name|GET_SQ_STATS
parameter_list|(
name|reg
parameter_list|)
define|\
value|nicvf_reg_read(nic, NIC_QSET_SQ_0_7_STAT_0_1 |\ 			    (sq_idx<< NIC_Q_NUM_SHIFT) | (reg<< 3))
name|sq
operator|=
operator|&
name|nic
operator|->
name|qs
operator|->
name|sq
index|[
name|sq_idx
index|]
expr_stmt|;
name|sq
operator|->
name|stats
operator|.
name|bytes
operator|=
name|GET_SQ_STATS
argument_list|(
name|RQ_SQ_STATS_OCTS
argument_list|)
expr_stmt|;
name|sq
operator|->
name|stats
operator|.
name|pkts
operator|=
name|GET_SQ_STATS
argument_list|(
name|RQ_SQ_STATS_PKTS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check for errors in the receive cmp.queue entry */
end_comment

begin_function
name|int
name|nicvf_check_cqe_rx_errs
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|cmp_queue
modifier|*
name|cq
parameter_list|,
name|struct
name|cqe_rx_t
modifier|*
name|cqe_rx
parameter_list|)
block|{
name|struct
name|nicvf_hw_stats
modifier|*
name|stats
init|=
operator|&
name|nic
operator|->
name|hw_stats
decl_stmt|;
name|struct
name|nicvf_drv_stats
modifier|*
name|drv_stats
init|=
operator|&
name|nic
operator|->
name|drv_stats
decl_stmt|;
if|if
condition|(
operator|!
name|cqe_rx
operator|->
name|err_level
operator|&&
operator|!
name|cqe_rx
operator|->
name|err_opcode
condition|)
block|{
name|drv_stats
operator|->
name|rx_frames_ok
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|netif_msg_rx_err
argument_list|(
name|nic
argument_list|)
condition|)
name|netdev_err
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"%s: RX error CQE err_level 0x%x err_opcode 0x%x\n"
argument_list|,
name|nic
operator|->
name|netdev
operator|->
name|name
argument_list|,
name|cqe_rx
operator|->
name|err_level
argument_list|,
name|cqe_rx
operator|->
name|err_opcode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cqe_rx
operator|->
name|err_opcode
condition|)
block|{
case|case
name|CQ_RX_ERROP_RE_PARTIAL
case|:
name|stats
operator|->
name|rx_bgx_truncated_pkts
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_RE_JABBER
case|:
name|stats
operator|->
name|rx_jabber_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_RE_FCS
case|:
name|stats
operator|->
name|rx_fcs_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_RE_RX_CTL
case|:
name|stats
operator|->
name|rx_bgx_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_PREL2_ERR
case|:
name|stats
operator|->
name|rx_prel2_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_L2_MAL
case|:
name|stats
operator|->
name|rx_l2_hdr_malformed
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_L2_OVERSIZE
case|:
name|stats
operator|->
name|rx_oversize
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_L2_UNDERSIZE
case|:
name|stats
operator|->
name|rx_undersize
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_L2_LENMISM
case|:
name|stats
operator|->
name|rx_l2_len_mismatch
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_L2_PCLP
case|:
name|stats
operator|->
name|rx_l2_pclp
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_IP_NOT
case|:
name|stats
operator|->
name|rx_ip_ver_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_IP_CSUM_ERR
case|:
name|stats
operator|->
name|rx_ip_csum_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_IP_MAL
case|:
name|stats
operator|->
name|rx_ip_hdr_malformed
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_IP_MALD
case|:
name|stats
operator|->
name|rx_ip_payload_malformed
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_IP_HOP
case|:
name|stats
operator|->
name|rx_ip_ttl_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_L3_PCLP
case|:
name|stats
operator|->
name|rx_l3_pclp
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_L4_MAL
case|:
name|stats
operator|->
name|rx_l4_malformed
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_L4_CHK
case|:
name|stats
operator|->
name|rx_l4_csum_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_UDP_LEN
case|:
name|stats
operator|->
name|rx_udp_len_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_L4_PORT
case|:
name|stats
operator|->
name|rx_l4_port_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_TCP_FLAG
case|:
name|stats
operator|->
name|rx_tcp_flag_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_TCP_OFFSET
case|:
name|stats
operator|->
name|rx_tcp_offset_errs
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_L4_PCLP
case|:
name|stats
operator|->
name|rx_l4_pclp
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_RX_ERROP_RBDR_TRUNC
case|:
name|stats
operator|->
name|rx_truncated_pkts
operator|++
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check for errors in the send cmp.queue entry */
end_comment

begin_function
name|int
name|nicvf_check_cqe_tx_errs
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|cmp_queue
modifier|*
name|cq
parameter_list|,
name|struct
name|cqe_send_t
modifier|*
name|cqe_tx
parameter_list|)
block|{
name|struct
name|cmp_queue_stats
modifier|*
name|stats
init|=
operator|&
name|cq
operator|->
name|stats
decl_stmt|;
switch|switch
condition|(
name|cqe_tx
operator|->
name|send_status
condition|)
block|{
case|case
name|CQ_TX_ERROP_GOOD
case|:
name|stats
operator|->
name|tx
operator|.
name|good
operator|++
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CQ_TX_ERROP_DESC_FAULT
case|:
name|stats
operator|->
name|tx
operator|.
name|desc_fault
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_HDR_CONS_ERR
case|:
name|stats
operator|->
name|tx
operator|.
name|hdr_cons_err
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_SUBDC_ERR
case|:
name|stats
operator|->
name|tx
operator|.
name|subdesc_err
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_IMM_SIZE_OFLOW
case|:
name|stats
operator|->
name|tx
operator|.
name|imm_size_oflow
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_DATA_SEQUENCE_ERR
case|:
name|stats
operator|->
name|tx
operator|.
name|data_seq_err
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_MEM_SEQUENCE_ERR
case|:
name|stats
operator|->
name|tx
operator|.
name|mem_seq_err
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_LOCK_VIOL
case|:
name|stats
operator|->
name|tx
operator|.
name|lock_viol
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_DATA_FAULT
case|:
name|stats
operator|->
name|tx
operator|.
name|data_fault
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_TSTMP_CONFLICT
case|:
name|stats
operator|->
name|tx
operator|.
name|tstmp_conflict
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_TSTMP_TIMEOUT
case|:
name|stats
operator|->
name|tx
operator|.
name|tstmp_timeout
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_MEM_FAULT
case|:
name|stats
operator|->
name|tx
operator|.
name|mem_fault
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_CK_OVERLAP
case|:
name|stats
operator|->
name|tx
operator|.
name|csum_overlap
operator|++
expr_stmt|;
break|break;
case|case
name|CQ_TX_ERROP_CK_OFLOW
case|:
name|stats
operator|->
name|tx
operator|.
name|csum_overflow
operator|++
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

