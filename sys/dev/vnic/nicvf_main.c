begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2015 Cavium Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<linux/pci.h>
end_include

begin_include
include|#
directive|include
file|<linux/netdevice.h>
end_include

begin_include
include|#
directive|include
file|<linux/if_vlan.h>
end_include

begin_include
include|#
directive|include
file|<linux/etherdevice.h>
end_include

begin_include
include|#
directive|include
file|<linux/ethtool.h>
end_include

begin_include
include|#
directive|include
file|<linux/log2.h>
end_include

begin_include
include|#
directive|include
file|<linux/prefetch.h>
end_include

begin_include
include|#
directive|include
file|<linux/irq.h>
end_include

begin_include
include|#
directive|include
file|"nic_reg.h"
end_include

begin_include
include|#
directive|include
file|"nic.h"
end_include

begin_include
include|#
directive|include
file|"nicvf_queues.h"
end_include

begin_include
include|#
directive|include
file|"thunder_bgx.h"
end_include

begin_define
define|#
directive|define
name|DRV_NAME
value|"thunder-nicvf"
end_define

begin_define
define|#
directive|define
name|DRV_VERSION
value|"1.0"
end_define

begin_comment
comment|/* Supported devices */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pci_device_id
name|nicvf_id_table
index|[]
init|=
block|{
block|{
name|PCI_DEVICE_SUB
argument_list|(
argument|PCI_VENDOR_ID_CAVIUM
argument_list|,
argument|PCI_DEVICE_ID_THUNDER_NIC_VF
argument_list|,
argument|PCI_VENDOR_ID_CAVIUM
argument_list|,
literal|0xA11E
argument_list|)
block|}
block|,
block|{
name|PCI_DEVICE_SUB
argument_list|(
argument|PCI_VENDOR_ID_CAVIUM
argument_list|,
argument|PCI_DEVICE_ID_THUNDER_PASS1_NIC_VF
argument_list|,
argument|PCI_VENDOR_ID_CAVIUM
argument_list|,
literal|0xA11E
argument_list|)
block|}
block|,
block|{
literal|0
block|, }
comment|/* end of table */
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
literal|"Sunil Goutham"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DESCRIPTION
argument_list|(
literal|"Cavium Thunder NIC Virtual Function Driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|DRV_VERSION
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEVICE_TABLE
argument_list|(
name|pci
argument_list|,
name|nicvf_id_table
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|debug
init|=
literal|0x00
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|debug
argument_list|,
name|int
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|debug
argument_list|,
literal|"Debug message level bitmap"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|cpi_alg
init|=
name|CPI_ALG_NONE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|cpi_alg
argument_list|,
name|int
argument_list|,
name|S_IRUGO
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|cpi_alg
argument_list|,
literal|"PFC algorithm (0=none, 1=VLAN, 2=VLAN16, 3=IP Diffserv)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
specifier|inline
name|u8
name|nicvf_netdev_qidx
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|u8
name|qidx
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
if|if
condition|(
name|nic
operator|->
name|sqs_mode
condition|)
return|return
name|qidx
operator|+
operator|(
operator|(
name|nic
operator|->
name|sqs_id
operator|+
literal|1
operator|)
operator|*
name|MAX_CMP_QUEUES_PER_QS
operator|)
return|;
else|else
endif|#
directive|endif
return|return
name|qidx
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|nicvf_set_rx_frame_cnt
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|sk_buff
modifier|*
name|skb
parameter_list|)
block|{
if|if
condition|(
name|skb
operator|->
name|len
operator|<=
literal|64
condition|)
name|nic
operator|->
name|drv_stats
operator|.
name|rx_frames_64
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|skb
operator|->
name|len
operator|<=
literal|127
condition|)
name|nic
operator|->
name|drv_stats
operator|.
name|rx_frames_127
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|skb
operator|->
name|len
operator|<=
literal|255
condition|)
name|nic
operator|->
name|drv_stats
operator|.
name|rx_frames_255
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|skb
operator|->
name|len
operator|<=
literal|511
condition|)
name|nic
operator|->
name|drv_stats
operator|.
name|rx_frames_511
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|skb
operator|->
name|len
operator|<=
literal|1023
condition|)
name|nic
operator|->
name|drv_stats
operator|.
name|rx_frames_1023
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|skb
operator|->
name|len
operator|<=
literal|1518
condition|)
name|nic
operator|->
name|drv_stats
operator|.
name|rx_frames_1518
operator|++
expr_stmt|;
else|else
name|nic
operator|->
name|drv_stats
operator|.
name|rx_frames_jumbo
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The Cavium ThunderX network controller can *only* be found in SoCs  * containing the ThunderX ARM64 CPU implementation.  All accesses to the device  * registers on this platform are implicitly strongly ordered with respect  * to memory accesses. So writeq_relaxed() and readq_relaxed() are safe to use  * with no memory barriers in this driver.  The readq()/writeq() functions add  * explicit ordering operation which in this case are redundant, and only  * add overhead.  */
end_comment

begin_comment
comment|/* Register read/write APIs */
end_comment

begin_function
name|void
name|nicvf_reg_write
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|u64
name|offset
parameter_list|,
name|u64
name|val
parameter_list|)
block|{
name|writeq_relaxed
argument_list|(
name|val
argument_list|,
name|nic
operator|->
name|reg_base
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u64
name|nicvf_reg_read
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|u64
name|offset
parameter_list|)
block|{
return|return
name|readq_relaxed
argument_list|(
name|nic
operator|->
name|reg_base
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|nicvf_queue_reg_write
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|u64
name|offset
parameter_list|,
name|u64
name|qidx
parameter_list|,
name|u64
name|val
parameter_list|)
block|{
name|void
name|__iomem
modifier|*
name|addr
init|=
name|nic
operator|->
name|reg_base
operator|+
name|offset
decl_stmt|;
name|writeq_relaxed
argument_list|(
name|val
argument_list|,
name|addr
operator|+
operator|(
name|qidx
operator|<<
name|NIC_Q_NUM_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u64
name|nicvf_queue_reg_read
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|u64
name|offset
parameter_list|,
name|u64
name|qidx
parameter_list|)
block|{
name|void
name|__iomem
modifier|*
name|addr
init|=
name|nic
operator|->
name|reg_base
operator|+
name|offset
decl_stmt|;
return|return
name|readq_relaxed
argument_list|(
name|addr
operator|+
operator|(
name|qidx
operator|<<
name|NIC_Q_NUM_SHIFT
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* VF -> PF mailbox communication */
end_comment

begin_function
specifier|static
name|void
name|nicvf_write_to_mbx
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|union
name|nic_mbx
modifier|*
name|mbx
parameter_list|)
block|{
name|u64
modifier|*
name|msg
init|=
operator|(
name|u64
operator|*
operator|)
name|mbx
decl_stmt|;
name|nicvf_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_VF_PF_MAILBOX_0_1
operator|+
literal|0
argument_list|,
name|msg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|nicvf_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_VF_PF_MAILBOX_0_1
operator|+
literal|8
argument_list|,
name|msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|nicvf_send_msg_to_pf
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|union
name|nic_mbx
modifier|*
name|mbx
parameter_list|)
block|{
name|int
name|timeout
init|=
name|NIC_MBOX_MSG_TIMEOUT
decl_stmt|;
name|int
name|sleep
init|=
literal|10
decl_stmt|;
name|nic
operator|->
name|pf_acked
operator|=
name|false
expr_stmt|;
name|nic
operator|->
name|pf_nacked
operator|=
name|false
expr_stmt|;
name|nicvf_write_to_mbx
argument_list|(
name|nic
argument_list|,
name|mbx
argument_list|)
expr_stmt|;
comment|/* Wait for previous message to be acked, timeout 2sec */
while|while
condition|(
operator|!
name|nic
operator|->
name|pf_acked
condition|)
block|{
if|if
condition|(
name|nic
operator|->
name|pf_nacked
condition|)
return|return
operator|-
name|EINVAL
return|;
name|msleep
argument_list|(
name|sleep
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|pf_acked
condition|)
break|break;
name|timeout
operator|-=
name|sleep
expr_stmt|;
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|netdev_err
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"PF didn't ack to mbox msg %d from VF%d\n"
argument_list|,
operator|(
name|mbx
operator|->
name|msg
operator|.
name|msg
operator|&
literal|0xFF
operator|)
argument_list|,
name|nic
operator|->
name|vf_id
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Checks if VF is able to comminicate with PF * and also gets the VNIC number this VF is associated to. */
end_comment

begin_function
specifier|static
name|int
name|nicvf_check_pf_ready
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|msg
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_READY
expr_stmt|;
if|if
condition|(
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
condition|)
block|{
name|netdev_err
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"PF didn't respond to READY msg\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_read_bgx_stats
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|bgx_stats_msg
modifier|*
name|bgx
parameter_list|)
block|{
if|if
condition|(
name|bgx
operator|->
name|rx
condition|)
name|nic
operator|->
name|bgx_stats
operator|.
name|rx_stats
index|[
name|bgx
operator|->
name|idx
index|]
operator|=
name|bgx
operator|->
name|stats
expr_stmt|;
else|else
name|nic
operator|->
name|bgx_stats
operator|.
name|tx_stats
index|[
name|bgx
operator|->
name|idx
index|]
operator|=
name|bgx
operator|->
name|stats
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_handle_mbx_intr
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|u64
modifier|*
name|mbx_data
decl_stmt|;
name|u64
name|mbx_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mbx_addr
operator|=
name|NIC_VF_PF_MAILBOX_0_1
expr_stmt|;
name|mbx_data
operator|=
operator|(
name|u64
operator|*
operator|)
operator|&
name|mbx
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NIC_PF_VF_MAILBOX_SIZE
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|mbx_data
operator|=
name|nicvf_reg_read
argument_list|(
name|nic
argument_list|,
name|mbx_addr
argument_list|)
expr_stmt|;
name|mbx_data
operator|++
expr_stmt|;
name|mbx_addr
operator|+=
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
expr_stmt|;
block|}
name|netdev_dbg
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"Mbox message: msg: 0x%x\n"
argument_list|,
name|mbx
operator|.
name|msg
operator|.
name|msg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mbx
operator|.
name|msg
operator|.
name|msg
condition|)
block|{
case|case
name|NIC_MBOX_MSG_READY
case|:
name|nic
operator|->
name|pf_acked
operator|=
name|true
expr_stmt|;
name|nic
operator|->
name|vf_id
operator|=
name|mbx
operator|.
name|nic_cfg
operator|.
name|vf_id
operator|&
literal|0x7F
expr_stmt|;
name|nic
operator|->
name|tns_mode
operator|=
name|mbx
operator|.
name|nic_cfg
operator|.
name|tns_mode
operator|&
literal|0x7F
expr_stmt|;
name|nic
operator|->
name|node
operator|=
name|mbx
operator|.
name|nic_cfg
operator|.
name|node_id
expr_stmt|;
name|ether_addr_copy
argument_list|(
name|nic
operator|->
name|netdev
operator|->
name|dev_addr
argument_list|,
name|mbx
operator|.
name|nic_cfg
operator|.
name|mac_addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
name|nic
operator|->
name|sqs_mode
operator|=
name|mbx
operator|.
name|nic_cfg
operator|.
name|sqs_mode
expr_stmt|;
endif|#
directive|endif
name|nic
operator|->
name|loopback_supported
operator|=
name|mbx
operator|.
name|nic_cfg
operator|.
name|loopback_supported
expr_stmt|;
name|nic
operator|->
name|link_up
operator|=
name|false
expr_stmt|;
name|nic
operator|->
name|duplex
operator|=
literal|0
expr_stmt|;
name|nic
operator|->
name|speed
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_ACK
case|:
name|nic
operator|->
name|pf_acked
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_NACK
case|:
name|nic
operator|->
name|pf_nacked
operator|=
name|true
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|VNIC_RSS_SUPPORT
case|case
name|NIC_MBOX_MSG_RSS_SIZE
case|:
name|nic
operator|->
name|rss_info
operator|.
name|rss_size
operator|=
name|mbx
operator|.
name|rss_size
operator|.
name|ind_tbl_size
expr_stmt|;
name|nic
operator|->
name|pf_acked
operator|=
name|true
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|NIC_MBOX_MSG_BGX_STATS
case|:
name|nicvf_read_bgx_stats
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
operator|.
name|bgx_stats
argument_list|)
expr_stmt|;
name|nic
operator|->
name|pf_acked
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_BGX_LINK_CHANGE
case|:
name|nic
operator|->
name|pf_acked
operator|=
name|true
expr_stmt|;
name|nic
operator|->
name|link_up
operator|=
name|mbx
operator|.
name|link_status
operator|.
name|link_up
expr_stmt|;
name|nic
operator|->
name|duplex
operator|=
name|mbx
operator|.
name|link_status
operator|.
name|duplex
expr_stmt|;
name|nic
operator|->
name|speed
operator|=
name|mbx
operator|.
name|link_status
operator|.
name|speed
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|link_up
condition|)
block|{
name|netdev_info
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"%s: Link is Up %d Mbps %s\n"
argument_list|,
name|nic
operator|->
name|netdev
operator|->
name|name
argument_list|,
name|nic
operator|->
name|speed
argument_list|,
name|nic
operator|->
name|duplex
operator|==
name|DUPLEX_FULL
condition|?
literal|"Full duplex"
else|:
literal|"Half duplex"
argument_list|)
expr_stmt|;
name|netif_carrier_on
argument_list|(
name|nic
operator|->
name|netdev
argument_list|)
expr_stmt|;
name|netif_tx_start_all_queues
argument_list|(
name|nic
operator|->
name|netdev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|netdev_info
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"%s: Link is Down\n"
argument_list|,
name|nic
operator|->
name|netdev
operator|->
name|name
argument_list|)
expr_stmt|;
name|netif_carrier_off
argument_list|(
name|nic
operator|->
name|netdev
argument_list|)
expr_stmt|;
name|netif_tx_stop_all_queues
argument_list|(
name|nic
operator|->
name|netdev
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
case|case
name|NIC_MBOX_MSG_ALLOC_SQS
case|:
name|nic
operator|->
name|sqs_count
operator|=
name|mbx
operator|.
name|sqs_alloc
operator|.
name|qs_count
expr_stmt|;
name|nic
operator|->
name|pf_acked
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_SNICVF_PTR
case|:
comment|/* Primary VF: make note of secondary VF's pointer 		 * to be used while packet transmission. 		 */
name|nic
operator|->
name|snicvf
index|[
name|mbx
operator|.
name|nicvf
operator|.
name|sqs_id
index|]
operator|=
operator|(
expr|struct
name|nicvf
operator|*
operator|)
name|mbx
operator|.
name|nicvf
operator|.
name|nicvf
expr_stmt|;
name|nic
operator|->
name|pf_acked
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_PNICVF_PTR
case|:
comment|/* Secondary VF/Qset: make note of primary VF's pointer 		 * to be used while packet reception, to handover packet 		 * to primary VF's netdev. 		 */
name|nic
operator|->
name|pnicvf
operator|=
operator|(
expr|struct
name|nicvf
operator|*
operator|)
name|mbx
operator|.
name|nicvf
operator|.
name|nicvf
expr_stmt|;
name|nic
operator|->
name|pf_acked
operator|=
name|true
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|netdev_err
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"Invalid message from PF, msg 0x%x\n"
argument_list|,
name|mbx
operator|.
name|msg
operator|.
name|msg
argument_list|)
expr_stmt|;
break|break;
block|}
name|nicvf_clear_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_MBOX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_hw_set_mac_addr
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|net_device
modifier|*
name|netdev
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|mac
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_SET_MAC
expr_stmt|;
name|mbx
operator|.
name|mac
operator|.
name|vf_id
operator|=
name|nic
operator|->
name|vf_id
expr_stmt|;
name|ether_addr_copy
argument_list|(
name|mbx
operator|.
name|mac
operator|.
name|mac_addr
argument_list|,
name|netdev
operator|->
name|dev_addr
argument_list|)
expr_stmt|;
return|return
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_config_cpi
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|cpi_cfg
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_CPI_CFG
expr_stmt|;
name|mbx
operator|.
name|cpi_cfg
operator|.
name|vf_id
operator|=
name|nic
operator|->
name|vf_id
expr_stmt|;
name|mbx
operator|.
name|cpi_cfg
operator|.
name|cpi_alg
operator|=
name|nic
operator|->
name|cpi_alg
expr_stmt|;
name|mbx
operator|.
name|cpi_cfg
operator|.
name|rq_cnt
operator|=
name|nic
operator|->
name|qs
operator|->
name|rq_cnt
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VNIC_RSS_SUPPORT
end_ifdef

begin_function
specifier|static
name|void
name|nicvf_get_rss_size
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|rss_size
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_RSS_SIZE
expr_stmt|;
name|mbx
operator|.
name|rss_size
operator|.
name|vf_id
operator|=
name|nic
operator|->
name|vf_id
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nicvf_config_rss
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|struct
name|nicvf_rss_info
modifier|*
name|rss
init|=
operator|&
name|nic
operator|->
name|rss_info
decl_stmt|;
name|int
name|ind_tbl_len
init|=
name|rss
operator|->
name|rss_size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nextq
init|=
literal|0
decl_stmt|;
name|mbx
operator|.
name|rss_cfg
operator|.
name|vf_id
operator|=
name|nic
operator|->
name|vf_id
expr_stmt|;
name|mbx
operator|.
name|rss_cfg
operator|.
name|hash_bits
operator|=
name|rss
operator|->
name|hash_bits
expr_stmt|;
while|while
condition|(
name|ind_tbl_len
condition|)
block|{
name|mbx
operator|.
name|rss_cfg
operator|.
name|tbl_offset
operator|=
name|nextq
expr_stmt|;
name|mbx
operator|.
name|rss_cfg
operator|.
name|tbl_len
operator|=
name|min
argument_list|(
name|ind_tbl_len
argument_list|,
name|RSS_IND_TBL_LEN_PER_MBX_MSG
argument_list|)
expr_stmt|;
name|mbx
operator|.
name|rss_cfg
operator|.
name|msg
operator|=
name|mbx
operator|.
name|rss_cfg
operator|.
name|tbl_offset
condition|?
name|NIC_MBOX_MSG_RSS_CFG_CONT
else|:
name|NIC_MBOX_MSG_RSS_CFG
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mbx
operator|.
name|rss_cfg
operator|.
name|tbl_len
condition|;
name|i
operator|++
control|)
name|mbx
operator|.
name|rss_cfg
operator|.
name|ind_tbl
index|[
name|i
index|]
operator|=
name|rss
operator|->
name|ind_tbl
index|[
name|nextq
operator|++
index|]
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
name|ind_tbl_len
operator|-=
name|mbx
operator|.
name|rss_cfg
operator|.
name|tbl_len
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|nicvf_set_rss_key
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|struct
name|nicvf_rss_info
modifier|*
name|rss
init|=
operator|&
name|nic
operator|->
name|rss_info
decl_stmt|;
name|u64
name|key_addr
init|=
name|NIC_VNIC_RSS_KEY_0_4
decl_stmt|;
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|RSS_HASH_KEY_SIZE
condition|;
name|idx
operator|++
control|)
block|{
name|nicvf_reg_write
argument_list|(
name|nic
argument_list|,
name|key_addr
argument_list|,
name|rss
operator|->
name|key
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|key_addr
operator|+=
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_rss_init
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|struct
name|nicvf_rss_info
modifier|*
name|rss
init|=
operator|&
name|nic
operator|->
name|rss_info
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|nicvf_get_rss_size
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpi_alg
operator|!=
name|CPI_ALG_NONE
condition|)
block|{
name|rss
operator|->
name|enable
operator|=
name|false
expr_stmt|;
name|rss
operator|->
name|hash_bits
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rss
operator|->
name|enable
operator|=
name|true
expr_stmt|;
comment|/* Using the HW reset value for now */
name|rss
operator|->
name|key
index|[
literal|0
index|]
operator|=
literal|0xFEED0BADFEED0BADULL
expr_stmt|;
name|rss
operator|->
name|key
index|[
literal|1
index|]
operator|=
literal|0xFEED0BADFEED0BADULL
expr_stmt|;
name|rss
operator|->
name|key
index|[
literal|2
index|]
operator|=
literal|0xFEED0BADFEED0BADULL
expr_stmt|;
name|rss
operator|->
name|key
index|[
literal|3
index|]
operator|=
literal|0xFEED0BADFEED0BADULL
expr_stmt|;
name|rss
operator|->
name|key
index|[
literal|4
index|]
operator|=
literal|0xFEED0BADFEED0BADULL
expr_stmt|;
name|nicvf_set_rss_key
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|rss
operator|->
name|cfg
operator|=
name|RSS_IP_HASH_ENA
operator||
name|RSS_TCP_HASH_ENA
operator||
name|RSS_UDP_HASH_ENA
expr_stmt|;
name|nicvf_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_VNIC_RSS_CFG
argument_list|,
name|rss
operator|->
name|cfg
argument_list|)
expr_stmt|;
name|rss
operator|->
name|hash_bits
operator|=
name|ilog2
argument_list|(
name|rounddown_pow_of_two
argument_list|(
name|rss
operator|->
name|rss_size
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|rss
operator|->
name|rss_size
condition|;
name|idx
operator|++
control|)
name|rss
operator|->
name|ind_tbl
index|[
name|idx
index|]
operator|=
name|ethtool_rxfh_indir_default
argument_list|(
name|idx
argument_list|,
name|nic
operator|->
name|rx_queues
argument_list|)
expr_stmt|;
name|nicvf_config_rss
argument_list|(
name|nic
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
end_ifdef

begin_comment
comment|/* Request PF to allocate additional Qsets */
end_comment

begin_function
specifier|static
name|void
name|nicvf_request_sqs
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|int
name|sqs
decl_stmt|;
name|int
name|sqs_count
init|=
name|nic
operator|->
name|sqs_count
decl_stmt|;
name|int
name|rx_queues
init|=
literal|0
decl_stmt|,
name|tx_queues
init|=
literal|0
decl_stmt|;
comment|/* Only primary VF should request */
if|if
condition|(
name|nic
operator|->
name|sqs_mode
operator|||
operator|!
name|nic
operator|->
name|sqs_count
condition|)
return|return;
name|mbx
operator|.
name|sqs_alloc
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_ALLOC_SQS
expr_stmt|;
name|mbx
operator|.
name|sqs_alloc
operator|.
name|vf_id
operator|=
name|nic
operator|->
name|vf_id
expr_stmt|;
name|mbx
operator|.
name|sqs_alloc
operator|.
name|qs_count
operator|=
name|nic
operator|->
name|sqs_count
expr_stmt|;
if|if
condition|(
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
condition|)
block|{
comment|/* No response from PF */
name|nic
operator|->
name|sqs_count
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Return if no Secondary Qsets available */
if|if
condition|(
operator|!
name|nic
operator|->
name|sqs_count
condition|)
return|return;
if|if
condition|(
name|nic
operator|->
name|rx_queues
operator|>
name|MAX_RCV_QUEUES_PER_QS
condition|)
name|rx_queues
operator|=
name|nic
operator|->
name|rx_queues
operator|-
name|MAX_RCV_QUEUES_PER_QS
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|tx_queues
operator|>
name|MAX_SND_QUEUES_PER_QS
condition|)
name|tx_queues
operator|=
name|nic
operator|->
name|tx_queues
operator|-
name|MAX_SND_QUEUES_PER_QS
expr_stmt|;
comment|/* Set no of Rx/Tx queues in each of the SQsets */
for|for
control|(
name|sqs
operator|=
literal|0
init|;
name|sqs
operator|<
name|nic
operator|->
name|sqs_count
condition|;
name|sqs
operator|++
control|)
block|{
name|mbx
operator|.
name|nicvf
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_SNICVF_PTR
expr_stmt|;
name|mbx
operator|.
name|nicvf
operator|.
name|vf_id
operator|=
name|nic
operator|->
name|vf_id
expr_stmt|;
name|mbx
operator|.
name|nicvf
operator|.
name|sqs_id
operator|=
name|sqs
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
name|nic
operator|->
name|snicvf
index|[
name|sqs
index|]
operator|->
name|sqs_id
operator|=
name|sqs
expr_stmt|;
if|if
condition|(
name|rx_queues
operator|>
name|MAX_RCV_QUEUES_PER_QS
condition|)
block|{
name|nic
operator|->
name|snicvf
index|[
name|sqs
index|]
operator|->
name|qs
operator|->
name|rq_cnt
operator|=
name|MAX_RCV_QUEUES_PER_QS
expr_stmt|;
name|rx_queues
operator|-=
name|MAX_RCV_QUEUES_PER_QS
expr_stmt|;
block|}
else|else
block|{
name|nic
operator|->
name|snicvf
index|[
name|sqs
index|]
operator|->
name|qs
operator|->
name|rq_cnt
operator|=
name|rx_queues
expr_stmt|;
name|rx_queues
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tx_queues
operator|>
name|MAX_SND_QUEUES_PER_QS
condition|)
block|{
name|nic
operator|->
name|snicvf
index|[
name|sqs
index|]
operator|->
name|qs
operator|->
name|sq_cnt
operator|=
name|MAX_SND_QUEUES_PER_QS
expr_stmt|;
name|tx_queues
operator|-=
name|MAX_SND_QUEUES_PER_QS
expr_stmt|;
block|}
else|else
block|{
name|nic
operator|->
name|snicvf
index|[
name|sqs
index|]
operator|->
name|qs
operator|->
name|sq_cnt
operator|=
name|tx_queues
expr_stmt|;
name|tx_queues
operator|=
literal|0
expr_stmt|;
block|}
name|nic
operator|->
name|snicvf
index|[
name|sqs
index|]
operator|->
name|qs
operator|->
name|cq_cnt
operator|=
name|max
argument_list|(
name|nic
operator|->
name|snicvf
index|[
name|sqs
index|]
operator|->
name|qs
operator|->
name|rq_cnt
argument_list|,
name|nic
operator|->
name|snicvf
index|[
name|sqs
index|]
operator|->
name|qs
operator|->
name|sq_cnt
argument_list|)
expr_stmt|;
comment|/* Initialize secondary Qset's queues and its interrupts */
name|nicvf_open
argument_list|(
name|nic
operator|->
name|snicvf
index|[
name|sqs
index|]
operator|->
name|netdev
argument_list|)
expr_stmt|;
block|}
comment|/* Update stack with actual Rx/Tx queue count allocated */
if|if
condition|(
name|sqs_count
operator|!=
name|nic
operator|->
name|sqs_count
condition|)
name|nicvf_set_real_num_queues
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
name|nic
operator|->
name|tx_queues
argument_list|,
name|nic
operator|->
name|rx_queues
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send this Qset's nicvf pointer to PF.  * PF inturn sends primary VF's nicvf struct to secondary Qsets/VFs  * so that packets received by these Qsets can use primary VF's netdev  */
end_comment

begin_function
specifier|static
name|void
name|nicvf_send_vf_struct
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|nicvf
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_NICVF_PTR
expr_stmt|;
name|mbx
operator|.
name|nicvf
operator|.
name|sqs_mode
operator|=
name|nic
operator|->
name|sqs_mode
expr_stmt|;
name|mbx
operator|.
name|nicvf
operator|.
name|nicvf
operator|=
operator|(
name|u64
operator|)
name|nic
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_get_primary_vf_struct
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|nicvf
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_PNICVF_PTR
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|nicvf_set_real_num_queues
parameter_list|(
name|struct
name|net_device
modifier|*
name|netdev
parameter_list|,
name|int
name|tx_queues
parameter_list|,
name|int
name|rx_queues
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|netif_set_real_num_tx_queues
argument_list|(
name|netdev
argument_list|,
name|tx_queues
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|netdev_err
argument_list|(
name|netdev
argument_list|,
literal|"Failed to set no of Tx queues: %d\n"
argument_list|,
name|tx_queues
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|netif_set_real_num_rx_queues
argument_list|(
name|netdev
argument_list|,
name|rx_queues
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|netdev_err
argument_list|(
name|netdev
argument_list|,
literal|"Failed to set no of Rx queues: %d\n"
argument_list|,
name|rx_queues
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_init_resources
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|msg
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_CFG_DONE
expr_stmt|;
comment|/* Enable Qset */
name|nicvf_qset_config
argument_list|(
name|nic
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Initialize queues and HW for data transfer */
name|err
operator|=
name|nicvf_config_data_transfer
argument_list|(
name|nic
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|netdev_err
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"Failed to alloc/config VF's QSet resources\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* Send VF config done msg to PF */
name|nicvf_write_to_mbx
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_snd_pkt_handler
parameter_list|(
name|struct
name|net_device
modifier|*
name|netdev
parameter_list|,
name|struct
name|cmp_queue
modifier|*
name|cq
parameter_list|,
name|struct
name|cqe_send_t
modifier|*
name|cqe_tx
parameter_list|,
name|int
name|cqe_type
parameter_list|)
block|{
name|struct
name|sk_buff
modifier|*
name|skb
init|=
name|NULL
decl_stmt|;
name|struct
name|nicvf
modifier|*
name|nic
init|=
name|netdev_priv
argument_list|(
name|netdev
argument_list|)
decl_stmt|;
name|struct
name|snd_queue
modifier|*
name|sq
decl_stmt|;
name|struct
name|sq_hdr_subdesc
modifier|*
name|hdr
decl_stmt|;
name|sq
operator|=
operator|&
name|nic
operator|->
name|qs
operator|->
name|sq
index|[
name|cqe_tx
operator|->
name|sq_idx
index|]
expr_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|sq_hdr_subdesc
operator|*
operator|)
name|GET_SQ_DESC
argument_list|(
name|sq
argument_list|,
name|cqe_tx
operator|->
name|sqe_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|subdesc_type
operator|!=
name|SQ_DESC_TYPE_HEADER
condition|)
return|return;
name|netdev_dbg
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"%s Qset #%d SQ #%d SQ ptr #%d subdesc count %d\n"
argument_list|,
name|__func__
argument_list|,
name|cqe_tx
operator|->
name|sq_qs
argument_list|,
name|cqe_tx
operator|->
name|sq_idx
argument_list|,
name|cqe_tx
operator|->
name|sqe_ptr
argument_list|,
name|hdr
operator|->
name|subdesc_cnt
argument_list|)
expr_stmt|;
name|nicvf_put_sq_desc
argument_list|(
name|sq
argument_list|,
name|hdr
operator|->
name|subdesc_cnt
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nicvf_check_cqe_tx_errs
argument_list|(
name|nic
argument_list|,
name|cq
argument_list|,
name|cqe_tx
argument_list|)
expr_stmt|;
name|skb
operator|=
operator|(
expr|struct
name|sk_buff
operator|*
operator|)
name|sq
operator|->
name|skbuff
index|[
name|cqe_tx
operator|->
name|sqe_ptr
index|]
expr_stmt|;
comment|/* For TSO offloaded packets only one head SKB needs to be freed */
if|if
condition|(
name|skb
condition|)
block|{
name|prefetch
argument_list|(
name|skb
argument_list|)
expr_stmt|;
name|dev_consume_skb_any
argument_list|(
name|skb
argument_list|)
expr_stmt|;
name|sq
operator|->
name|skbuff
index|[
name|cqe_tx
operator|->
name|sqe_ptr
index|]
operator|=
operator|(
name|u64
operator|)
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|nicvf_set_rxhash
parameter_list|(
name|struct
name|net_device
modifier|*
name|netdev
parameter_list|,
name|struct
name|cqe_rx_t
modifier|*
name|cqe_rx
parameter_list|,
name|struct
name|sk_buff
modifier|*
name|skb
parameter_list|)
block|{
name|u8
name|hash_type
decl_stmt|;
name|u32
name|hash
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|netdev
operator|->
name|features
operator|&
name|NETIF_F_RXHASH
operator|)
condition|)
return|return;
switch|switch
condition|(
name|cqe_rx
operator|->
name|rss_alg
condition|)
block|{
case|case
name|RSS_ALG_TCP_IP
case|:
case|case
name|RSS_ALG_UDP_IP
case|:
name|hash_type
operator|=
name|PKT_HASH_TYPE_L4
expr_stmt|;
name|hash
operator|=
name|cqe_rx
operator|->
name|rss_tag
expr_stmt|;
break|break;
case|case
name|RSS_ALG_IP
case|:
name|hash_type
operator|=
name|PKT_HASH_TYPE_L3
expr_stmt|;
name|hash
operator|=
name|cqe_rx
operator|->
name|rss_tag
expr_stmt|;
break|break;
default|default:
name|hash_type
operator|=
name|PKT_HASH_TYPE_NONE
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
block|}
name|skb_set_hash
argument_list|(
name|skb
argument_list|,
name|hash
argument_list|,
name|hash_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_rcv_pkt_handler
parameter_list|(
name|struct
name|net_device
modifier|*
name|netdev
parameter_list|,
name|struct
name|napi_struct
modifier|*
name|napi
parameter_list|,
name|struct
name|cmp_queue
modifier|*
name|cq
parameter_list|,
name|struct
name|cqe_rx_t
modifier|*
name|cqe_rx
parameter_list|,
name|int
name|cqe_type
parameter_list|)
block|{
name|struct
name|sk_buff
modifier|*
name|skb
decl_stmt|;
name|struct
name|nicvf
modifier|*
name|nic
init|=
name|netdev_priv
argument_list|(
name|netdev
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|rq_idx
decl_stmt|;
name|rq_idx
operator|=
name|nicvf_netdev_qidx
argument_list|(
name|nic
argument_list|,
name|cqe_rx
operator|->
name|rq_idx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
if|if
condition|(
name|nic
operator|->
name|sqs_mode
condition|)
block|{
comment|/* Use primary VF's 'nicvf' struct */
name|nic
operator|=
name|nic
operator|->
name|pnicvf
expr_stmt|;
name|netdev
operator|=
name|nic
operator|->
name|netdev
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Check for errors */
name|err
operator|=
name|nicvf_check_cqe_rx_errs
argument_list|(
name|nic
argument_list|,
name|cq
argument_list|,
name|cqe_rx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|!
name|cqe_rx
operator|->
name|rb_cnt
condition|)
return|return;
name|skb
operator|=
name|nicvf_get_rcv_skb
argument_list|(
name|nic
argument_list|,
name|cqe_rx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skb
condition|)
block|{
name|netdev_dbg
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"Packet not received\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|netif_msg_pktdata
argument_list|(
name|nic
argument_list|)
condition|)
block|{
name|netdev_info
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"%s: skb 0x%p, len=%d\n"
argument_list|,
name|netdev
operator|->
name|name
argument_list|,
name|skb
argument_list|,
name|skb
operator|->
name|len
argument_list|)
expr_stmt|;
name|print_hex_dump
argument_list|(
name|KERN_INFO
argument_list|,
literal|""
argument_list|,
name|DUMP_PREFIX_OFFSET
argument_list|,
literal|16
argument_list|,
literal|1
argument_list|,
name|skb
operator|->
name|data
argument_list|,
name|skb
operator|->
name|len
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* If error packet, drop it here */
if|if
condition|(
name|err
condition|)
block|{
name|dev_kfree_skb_any
argument_list|(
name|skb
argument_list|)
expr_stmt|;
return|return;
block|}
name|nicvf_set_rx_frame_cnt
argument_list|(
name|nic
argument_list|,
name|skb
argument_list|)
expr_stmt|;
name|nicvf_set_rxhash
argument_list|(
name|netdev
argument_list|,
name|cqe_rx
argument_list|,
name|skb
argument_list|)
expr_stmt|;
name|skb_record_rx_queue
argument_list|(
name|skb
argument_list|,
name|rq_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|netdev
operator|->
name|hw_features
operator|&
name|NETIF_F_RXCSUM
condition|)
block|{
comment|/* HW by default verifies TCP/UDP/SCTP checksums */
name|skb
operator|->
name|ip_summed
operator|=
name|CHECKSUM_UNNECESSARY
expr_stmt|;
block|}
else|else
block|{
name|skb_checksum_none_assert
argument_list|(
name|skb
argument_list|)
expr_stmt|;
block|}
name|skb
operator|->
name|protocol
operator|=
name|eth_type_trans
argument_list|(
name|skb
argument_list|,
name|netdev
argument_list|)
expr_stmt|;
comment|/* Check for stripped VLAN */
if|if
condition|(
name|cqe_rx
operator|->
name|vlan_found
operator|&&
name|cqe_rx
operator|->
name|vlan_stripped
condition|)
name|__vlan_hwaccel_put_tag
argument_list|(
name|skb
argument_list|,
name|htons
argument_list|(
name|ETH_P_8021Q
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|cqe_rx
operator|->
name|vlan_tci
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|napi
operator|&&
operator|(
name|netdev
operator|->
name|features
operator|&
name|NETIF_F_GRO
operator|)
condition|)
name|napi_gro_receive
argument_list|(
name|napi
argument_list|,
name|skb
argument_list|)
expr_stmt|;
else|else
name|netif_receive_skb
argument_list|(
name|skb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_cq_intr_handler
parameter_list|(
name|struct
name|net_device
modifier|*
name|netdev
parameter_list|,
name|u8
name|cq_idx
parameter_list|,
name|struct
name|napi_struct
modifier|*
name|napi
parameter_list|,
name|int
name|budget
parameter_list|)
block|{
name|int
name|processed_cqe
decl_stmt|,
name|work_done
init|=
literal|0
decl_stmt|,
name|tx_done
init|=
literal|0
decl_stmt|;
name|int
name|cqe_count
decl_stmt|,
name|cqe_head
decl_stmt|;
name|struct
name|nicvf
modifier|*
name|nic
init|=
name|netdev_priv
argument_list|(
name|netdev
argument_list|)
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
init|=
name|nic
operator|->
name|qs
decl_stmt|;
name|struct
name|cmp_queue
modifier|*
name|cq
init|=
operator|&
name|qs
operator|->
name|cq
index|[
name|cq_idx
index|]
decl_stmt|;
name|struct
name|cqe_rx_t
modifier|*
name|cq_desc
decl_stmt|;
name|struct
name|netdev_queue
modifier|*
name|txq
decl_stmt|;
name|spin_lock_bh
argument_list|(
operator|&
name|cq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|loop
label|:
name|processed_cqe
operator|=
literal|0
expr_stmt|;
comment|/* Get no of valid CQ entries to process */
name|cqe_count
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_STATUS
argument_list|,
name|cq_idx
argument_list|)
expr_stmt|;
name|cqe_count
operator|&=
name|CQ_CQE_COUNT
expr_stmt|;
if|if
condition|(
operator|!
name|cqe_count
condition|)
goto|goto
name|done
goto|;
comment|/* Get head of the valid CQ entries */
name|cqe_head
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_HEAD
argument_list|,
name|cq_idx
argument_list|)
operator|>>
literal|9
expr_stmt|;
name|cqe_head
operator|&=
literal|0xFFFF
expr_stmt|;
name|netdev_dbg
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"%s CQ%d cqe_count %d cqe_head %d\n"
argument_list|,
name|__func__
argument_list|,
name|cq_idx
argument_list|,
name|cqe_count
argument_list|,
name|cqe_head
argument_list|)
expr_stmt|;
while|while
condition|(
name|processed_cqe
operator|<
name|cqe_count
condition|)
block|{
comment|/* Get the CQ descriptor */
name|cq_desc
operator|=
operator|(
expr|struct
name|cqe_rx_t
operator|*
operator|)
name|GET_CQ_DESC
argument_list|(
name|cq
argument_list|,
name|cqe_head
argument_list|)
expr_stmt|;
name|cqe_head
operator|++
expr_stmt|;
name|cqe_head
operator|&=
operator|(
name|cq
operator|->
name|dmem
operator|.
name|q_len
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Initiate prefetch for next descriptor */
name|prefetch
argument_list|(
operator|(
expr|struct
name|cqe_rx_t
operator|*
operator|)
name|GET_CQ_DESC
argument_list|(
name|cq
argument_list|,
name|cqe_head
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|work_done
operator|>=
name|budget
operator|)
operator|&&
name|napi
operator|&&
operator|(
name|cq_desc
operator|->
name|cqe_type
operator|!=
name|CQE_TYPE_SEND
operator|)
condition|)
block|{
break|break;
block|}
name|netdev_dbg
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"CQ%d cq_desc->cqe_type %d\n"
argument_list|,
name|cq_idx
argument_list|,
name|cq_desc
operator|->
name|cqe_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cq_desc
operator|->
name|cqe_type
condition|)
block|{
case|case
name|CQE_TYPE_RX
case|:
name|nicvf_rcv_pkt_handler
argument_list|(
name|netdev
argument_list|,
name|napi
argument_list|,
name|cq
argument_list|,
name|cq_desc
argument_list|,
name|CQE_TYPE_RX
argument_list|)
expr_stmt|;
name|work_done
operator|++
expr_stmt|;
break|break;
case|case
name|CQE_TYPE_SEND
case|:
name|nicvf_snd_pkt_handler
argument_list|(
name|netdev
argument_list|,
name|cq
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cq_desc
argument_list|,
name|CQE_TYPE_SEND
argument_list|)
expr_stmt|;
name|tx_done
operator|++
expr_stmt|;
break|break;
case|case
name|CQE_TYPE_INVALID
case|:
case|case
name|CQE_TYPE_RX_SPLIT
case|:
case|case
name|CQE_TYPE_RX_TCP
case|:
case|case
name|CQE_TYPE_SEND_PTP
case|:
comment|/* Ignore for now */
break|break;
block|}
name|processed_cqe
operator|++
expr_stmt|;
block|}
name|netdev_dbg
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"%s CQ%d processed_cqe %d work_done %d budget %d\n"
argument_list|,
name|__func__
argument_list|,
name|cq_idx
argument_list|,
name|processed_cqe
argument_list|,
name|work_done
argument_list|,
name|budget
argument_list|)
expr_stmt|;
comment|/* Ring doorbell to inform H/W to reuse processed CQEs */
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_DOOR
argument_list|,
name|cq_idx
argument_list|,
name|processed_cqe
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|work_done
operator|<
name|budget
operator|)
operator|&&
name|napi
condition|)
goto|goto
name|loop
goto|;
name|done
label|:
comment|/* Wakeup TXQ if its stopped earlier due to SQ full */
if|if
condition|(
name|tx_done
condition|)
block|{
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
name|netdev
operator|=
name|nic
operator|->
name|pnicvf
operator|->
name|netdev
expr_stmt|;
endif|#
directive|endif
name|txq
operator|=
name|netdev_get_tx_queue
argument_list|(
name|netdev
argument_list|,
name|nicvf_netdev_qidx
argument_list|(
name|nic
argument_list|,
name|cq_idx
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
name|nic
operator|=
name|nic
operator|->
name|pnicvf
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|netif_tx_queue_stopped
argument_list|(
name|txq
argument_list|)
operator|&&
name|netif_carrier_ok
argument_list|(
name|netdev
argument_list|)
condition|)
block|{
name|netif_tx_start_queue
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|nic
operator|->
name|drv_stats
operator|.
name|txq_wake
operator|++
expr_stmt|;
if|if
condition|(
name|netif_msg_tx_err
argument_list|(
name|nic
argument_list|)
condition|)
name|netdev_warn
argument_list|(
name|netdev
argument_list|,
literal|"%s: Transmit queue wakeup SQ%d\n"
argument_list|,
name|netdev
operator|->
name|name
argument_list|,
name|cq_idx
argument_list|)
expr_stmt|;
block|}
block|}
name|spin_unlock_bh
argument_list|(
operator|&
name|cq
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|work_done
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_poll
parameter_list|(
name|struct
name|napi_struct
modifier|*
name|napi
parameter_list|,
name|int
name|budget
parameter_list|)
block|{
name|u64
name|cq_head
decl_stmt|;
name|int
name|work_done
init|=
literal|0
decl_stmt|;
name|struct
name|net_device
modifier|*
name|netdev
init|=
name|napi
operator|->
name|dev
decl_stmt|;
name|struct
name|nicvf
modifier|*
name|nic
init|=
name|netdev_priv
argument_list|(
name|netdev
argument_list|)
decl_stmt|;
name|struct
name|nicvf_cq_poll
modifier|*
name|cq
decl_stmt|;
name|cq
operator|=
name|container_of
argument_list|(
name|napi
argument_list|,
expr|struct
name|nicvf_cq_poll
argument_list|,
name|napi
argument_list|)
expr_stmt|;
name|work_done
operator|=
name|nicvf_cq_intr_handler
argument_list|(
name|netdev
argument_list|,
name|cq
operator|->
name|cq_idx
argument_list|,
name|napi
argument_list|,
name|budget
argument_list|)
expr_stmt|;
if|if
condition|(
name|work_done
operator|<
name|budget
condition|)
block|{
comment|/* Slow packet rate, exit polling */
name|napi_complete
argument_list|(
name|napi
argument_list|)
expr_stmt|;
comment|/* Re-enable interrupts */
name|cq_head
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_HEAD
argument_list|,
name|cq
operator|->
name|cq_idx
argument_list|)
expr_stmt|;
name|nicvf_clear_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_CQ
argument_list|,
name|cq
operator|->
name|cq_idx
argument_list|)
expr_stmt|;
name|nicvf_queue_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_HEAD
argument_list|,
name|cq
operator|->
name|cq_idx
argument_list|,
name|cq_head
argument_list|)
expr_stmt|;
name|nicvf_enable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_CQ
argument_list|,
name|cq
operator|->
name|cq_idx
argument_list|)
expr_stmt|;
block|}
return|return
name|work_done
return|;
block|}
end_function

begin_comment
comment|/* Qset error interrupt handler  *  * As of now only CQ errors are handled  */
end_comment

begin_function
specifier|static
name|void
name|nicvf_handle_qs_err
parameter_list|(
name|unsigned
name|long
name|data
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
init|=
operator|(
expr|struct
name|nicvf
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
init|=
name|nic
operator|->
name|qs
decl_stmt|;
name|int
name|qidx
decl_stmt|;
name|u64
name|status
decl_stmt|;
name|netif_tx_disable
argument_list|(
name|nic
operator|->
name|netdev
argument_list|)
expr_stmt|;
comment|/* Check if it is CQ err */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|cq_cnt
condition|;
name|qidx
operator|++
control|)
block|{
name|status
operator|=
name|nicvf_queue_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_QSET_CQ_0_7_STATUS
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|CQ_ERR_MASK
operator|)
condition|)
continue|continue;
comment|/* Process already queued CQEs and reconfig CQ */
name|nicvf_disable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_CQ
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|nicvf_sq_disable
argument_list|(
name|nic
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|nicvf_cq_intr_handler
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
name|qidx
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nicvf_cmp_queue_config
argument_list|(
name|nic
argument_list|,
name|qs
argument_list|,
name|qidx
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|nicvf_sq_free_used_descs
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
operator|&
name|qs
operator|->
name|sq
index|[
name|qidx
index|]
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|nicvf_sq_enable
argument_list|(
name|nic
argument_list|,
operator|&
name|qs
operator|->
name|sq
index|[
name|qidx
index|]
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|nicvf_enable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_CQ
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
block|}
name|netif_tx_start_all_queues
argument_list|(
name|nic
operator|->
name|netdev
argument_list|)
expr_stmt|;
comment|/* Re-enable Qset error interrupt */
name|nicvf_enable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_QS_ERR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|nicvf_dump_intr_status
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
if|if
condition|(
name|netif_msg_intr
argument_list|(
name|nic
argument_list|)
condition|)
name|netdev_info
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"%s: interrupt status 0x%llx\n"
argument_list|,
name|nic
operator|->
name|netdev
operator|->
name|name
argument_list|,
name|nicvf_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_VF_INT
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|irqreturn_t
name|nicvf_misc_intr_handler
parameter_list|(
name|int
name|irq
parameter_list|,
name|void
modifier|*
name|nicvf_irq
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
init|=
operator|(
expr|struct
name|nicvf
operator|*
operator|)
name|nicvf_irq
decl_stmt|;
name|u64
name|intr
decl_stmt|;
name|nicvf_dump_intr_status
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|intr
operator|=
name|nicvf_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_VF_INT
argument_list|)
expr_stmt|;
comment|/* Check for spurious interrupt */
if|if
condition|(
operator|!
operator|(
name|intr
operator|&
name|NICVF_INTR_MBOX_MASK
operator|)
condition|)
return|return
name|IRQ_HANDLED
return|;
name|nicvf_handle_mbx_intr
argument_list|(
name|nic
argument_list|)
expr_stmt|;
return|return
name|IRQ_HANDLED
return|;
block|}
end_function

begin_function
specifier|static
name|irqreturn_t
name|nicvf_intr_handler
parameter_list|(
name|int
name|irq
parameter_list|,
name|void
modifier|*
name|cq_irq
parameter_list|)
block|{
name|struct
name|nicvf_cq_poll
modifier|*
name|cq_poll
init|=
operator|(
expr|struct
name|nicvf_cq_poll
operator|*
operator|)
name|cq_irq
decl_stmt|;
name|struct
name|nicvf
modifier|*
name|nic
init|=
name|cq_poll
operator|->
name|nicvf
decl_stmt|;
name|int
name|qidx
init|=
name|cq_poll
operator|->
name|cq_idx
decl_stmt|;
name|nicvf_dump_intr_status
argument_list|(
name|nic
argument_list|)
expr_stmt|;
comment|/* Disable interrupts */
name|nicvf_disable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_CQ
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
comment|/* Schedule NAPI */
name|napi_schedule
argument_list|(
operator|&
name|cq_poll
operator|->
name|napi
argument_list|)
expr_stmt|;
comment|/* Clear interrupt */
name|nicvf_clear_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_CQ
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
return|return
name|IRQ_HANDLED
return|;
block|}
end_function

begin_function
specifier|static
name|irqreturn_t
name|nicvf_rbdr_intr_handler
parameter_list|(
name|int
name|irq
parameter_list|,
name|void
modifier|*
name|nicvf_irq
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
init|=
operator|(
expr|struct
name|nicvf
operator|*
operator|)
name|nicvf_irq
decl_stmt|;
name|u8
name|qidx
decl_stmt|;
name|nicvf_dump_intr_status
argument_list|(
name|nic
argument_list|)
expr_stmt|;
comment|/* Disable RBDR interrupt and schedule softirq */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|nic
operator|->
name|qs
operator|->
name|rbdr_cnt
condition|;
name|qidx
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|nicvf_is_intr_enabled
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_RBDR
argument_list|,
name|qidx
argument_list|)
condition|)
continue|continue;
name|nicvf_disable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_RBDR
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|tasklet_hi_schedule
argument_list|(
operator|&
name|nic
operator|->
name|rbdr_task
argument_list|)
expr_stmt|;
comment|/* Clear interrupt */
name|nicvf_clear_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_RBDR
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
block|}
return|return
name|IRQ_HANDLED
return|;
block|}
end_function

begin_function
specifier|static
name|irqreturn_t
name|nicvf_qs_err_intr_handler
parameter_list|(
name|int
name|irq
parameter_list|,
name|void
modifier|*
name|nicvf_irq
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
init|=
operator|(
expr|struct
name|nicvf
operator|*
operator|)
name|nicvf_irq
decl_stmt|;
name|nicvf_dump_intr_status
argument_list|(
name|nic
argument_list|)
expr_stmt|;
comment|/* Disable Qset err interrupt and schedule softirq */
name|nicvf_disable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_QS_ERR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tasklet_hi_schedule
argument_list|(
operator|&
name|nic
operator|->
name|qs_err_task
argument_list|)
expr_stmt|;
name|nicvf_clear_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_QS_ERR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|IRQ_HANDLED
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_enable_msix
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|vec
decl_stmt|;
name|nic
operator|->
name|num_vec
operator|=
name|NIC_VF_MSIX_VECTORS
expr_stmt|;
for|for
control|(
name|vec
operator|=
literal|0
init|;
name|vec
operator|<
name|nic
operator|->
name|num_vec
condition|;
name|vec
operator|++
control|)
name|nic
operator|->
name|msix_entries
index|[
name|vec
index|]
operator|.
name|entry
operator|=
name|vec
expr_stmt|;
name|ret
operator|=
name|pci_enable_msix
argument_list|(
name|nic
operator|->
name|pdev
argument_list|,
name|nic
operator|->
name|msix_entries
argument_list|,
name|nic
operator|->
name|num_vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|netdev_err
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"Req for #%d msix vectors failed\n"
argument_list|,
name|nic
operator|->
name|num_vec
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nic
operator|->
name|msix_enabled
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_disable_msix
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
if|if
condition|(
name|nic
operator|->
name|msix_enabled
condition|)
block|{
name|pci_disable_msix
argument_list|(
name|nic
operator|->
name|pdev
argument_list|)
expr_stmt|;
name|nic
operator|->
name|msix_enabled
operator|=
literal|0
expr_stmt|;
name|nic
operator|->
name|num_vec
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_register_interrupts
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|irq
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|vector
decl_stmt|;
name|for_each_cq_irq
argument_list|(
argument|irq
argument_list|)
name|sprintf
argument_list|(
name|nic
operator|->
name|irq_name
index|[
name|irq
index|]
argument_list|,
literal|"NICVF%d CQ%d"
argument_list|,
name|nic
operator|->
name|vf_id
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|for_each_sq_irq
argument_list|(
argument|irq
argument_list|)
name|sprintf
argument_list|(
name|nic
operator|->
name|irq_name
index|[
name|irq
index|]
argument_list|,
literal|"NICVF%d SQ%d"
argument_list|,
name|nic
operator|->
name|vf_id
argument_list|,
name|irq
operator|-
name|NICVF_INTR_ID_SQ
argument_list|)
expr_stmt|;
name|for_each_rbdr_irq
argument_list|(
argument|irq
argument_list|)
name|sprintf
argument_list|(
name|nic
operator|->
name|irq_name
index|[
name|irq
index|]
argument_list|,
literal|"NICVF%d RBDR%d"
argument_list|,
name|nic
operator|->
name|vf_id
argument_list|,
name|irq
operator|-
name|NICVF_INTR_ID_RBDR
argument_list|)
expr_stmt|;
comment|/* Register CQ interrupts */
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
name|nic
operator|->
name|qs
operator|->
name|cq_cnt
condition|;
name|irq
operator|++
control|)
block|{
name|vector
operator|=
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|vector
expr_stmt|;
name|ret
operator|=
name|request_irq
argument_list|(
name|vector
argument_list|,
name|nicvf_intr_handler
argument_list|,
literal|0
argument_list|,
name|nic
operator|->
name|irq_name
index|[
name|irq
index|]
argument_list|,
name|nic
operator|->
name|napi
index|[
name|irq
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|nic
operator|->
name|irq_allocated
index|[
name|irq
index|]
operator|=
name|true
expr_stmt|;
block|}
comment|/* Register RBDR interrupt */
for|for
control|(
name|irq
operator|=
name|NICVF_INTR_ID_RBDR
init|;
name|irq
operator|<
operator|(
name|NICVF_INTR_ID_RBDR
operator|+
name|nic
operator|->
name|qs
operator|->
name|rbdr_cnt
operator|)
condition|;
name|irq
operator|++
control|)
block|{
name|vector
operator|=
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|vector
expr_stmt|;
name|ret
operator|=
name|request_irq
argument_list|(
name|vector
argument_list|,
name|nicvf_rbdr_intr_handler
argument_list|,
literal|0
argument_list|,
name|nic
operator|->
name|irq_name
index|[
name|irq
index|]
argument_list|,
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|nic
operator|->
name|irq_allocated
index|[
name|irq
index|]
operator|=
name|true
expr_stmt|;
block|}
comment|/* Register QS error interrupt */
name|sprintf
argument_list|(
name|nic
operator|->
name|irq_name
index|[
name|NICVF_INTR_ID_QS_ERR
index|]
argument_list|,
literal|"NICVF%d Qset error"
argument_list|,
name|nic
operator|->
name|vf_id
argument_list|)
expr_stmt|;
name|irq
operator|=
name|NICVF_INTR_ID_QS_ERR
expr_stmt|;
name|ret
operator|=
name|request_irq
argument_list|(
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|vector
argument_list|,
name|nicvf_qs_err_intr_handler
argument_list|,
literal|0
argument_list|,
name|nic
operator|->
name|irq_name
index|[
name|irq
index|]
argument_list|,
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|nic
operator|->
name|irq_allocated
index|[
name|irq
index|]
operator|=
name|true
expr_stmt|;
name|err
label|:
if|if
condition|(
name|ret
condition|)
name|netdev_err
argument_list|(
name|nic
operator|->
name|netdev
argument_list|,
literal|"request_irq failed, vector %d\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_unregister_interrupts
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|irq
decl_stmt|;
comment|/* Free registered interrupts */
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
name|nic
operator|->
name|num_vec
condition|;
name|irq
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|nic
operator|->
name|irq_allocated
index|[
name|irq
index|]
condition|)
continue|continue;
if|if
condition|(
name|irq
operator|<
name|NICVF_INTR_ID_SQ
condition|)
name|free_irq
argument_list|(
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|vector
argument_list|,
name|nic
operator|->
name|napi
index|[
name|irq
index|]
argument_list|)
expr_stmt|;
else|else
name|free_irq
argument_list|(
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|vector
argument_list|,
name|nic
argument_list|)
expr_stmt|;
name|nic
operator|->
name|irq_allocated
index|[
name|irq
index|]
operator|=
name|false
expr_stmt|;
block|}
comment|/* Disable MSI-X */
name|nicvf_disable_msix
argument_list|(
name|nic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize MSIX vectors and register MISC interrupt.  * Send READY message to PF to check if its alive  */
end_comment

begin_function
specifier|static
name|int
name|nicvf_register_misc_interrupt
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|irq
init|=
name|NICVF_INTR_ID_MISC
decl_stmt|;
comment|/* Return if mailbox interrupt is already registered */
if|if
condition|(
name|nic
operator|->
name|msix_enabled
condition|)
return|return
literal|0
return|;
comment|/* Enable MSI-X */
if|if
condition|(
operator|!
name|nicvf_enable_msix
argument_list|(
name|nic
argument_list|)
condition|)
return|return
literal|1
return|;
name|sprintf
argument_list|(
name|nic
operator|->
name|irq_name
index|[
name|irq
index|]
argument_list|,
literal|"%s Mbox"
argument_list|,
literal|"NICVF"
argument_list|)
expr_stmt|;
comment|/* Register Misc interrupt */
name|ret
operator|=
name|request_irq
argument_list|(
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|vector
argument_list|,
name|nicvf_misc_intr_handler
argument_list|,
literal|0
argument_list|,
name|nic
operator|->
name|irq_name
index|[
name|irq
index|]
argument_list|,
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|nic
operator|->
name|irq_allocated
index|[
name|irq
index|]
operator|=
name|true
expr_stmt|;
comment|/* Enable mailbox interrupt */
name|nicvf_enable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_MBOX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check if VF is able to communicate with PF */
if|if
condition|(
operator|!
name|nicvf_check_pf_ready
argument_list|(
name|nic
argument_list|)
condition|)
block|{
name|nicvf_disable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_MBOX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nicvf_unregister_interrupts
argument_list|(
name|nic
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|netdev_tx_t
name|nicvf_xmit
parameter_list|(
name|struct
name|sk_buff
modifier|*
name|skb
parameter_list|,
name|struct
name|net_device
modifier|*
name|netdev
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
init|=
name|netdev_priv
argument_list|(
name|netdev
argument_list|)
decl_stmt|;
name|int
name|qid
init|=
name|skb_get_queue_mapping
argument_list|(
name|skb
argument_list|)
decl_stmt|;
name|struct
name|netdev_queue
modifier|*
name|txq
init|=
name|netdev_get_tx_queue
argument_list|(
name|netdev
argument_list|,
name|qid
argument_list|)
decl_stmt|;
comment|/* Check for minimum packet length */
if|if
condition|(
name|skb
operator|->
name|len
operator|<=
name|ETH_HLEN
condition|)
block|{
name|dev_kfree_skb
argument_list|(
name|skb
argument_list|)
expr_stmt|;
return|return
name|NETDEV_TX_OK
return|;
block|}
if|if
condition|(
operator|!
name|netif_tx_queue_stopped
argument_list|(
name|txq
argument_list|)
operator|&&
operator|!
name|nicvf_sq_append_skb
argument_list|(
name|nic
argument_list|,
name|skb
argument_list|)
condition|)
block|{
name|netif_tx_stop_queue
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|nic
operator|->
name|drv_stats
operator|.
name|txq_stop
operator|++
expr_stmt|;
if|if
condition|(
name|netif_msg_tx_err
argument_list|(
name|nic
argument_list|)
condition|)
name|netdev_warn
argument_list|(
name|netdev
argument_list|,
literal|"%s: Transmit ring full, stopping SQ%d\n"
argument_list|,
name|netdev
operator|->
name|name
argument_list|,
name|qid
argument_list|)
expr_stmt|;
return|return
name|NETDEV_TX_BUSY
return|;
block|}
return|return
name|NETDEV_TX_OK
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|nicvf_free_cq_poll
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|struct
name|nicvf_cq_poll
modifier|*
name|cq_poll
init|=
name|NULL
decl_stmt|;
name|int
name|qidx
decl_stmt|;
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|nic
operator|->
name|qs
operator|->
name|cq_cnt
condition|;
name|qidx
operator|++
control|)
block|{
name|cq_poll
operator|=
name|nic
operator|->
name|napi
index|[
name|qidx
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|cq_poll
condition|)
continue|continue;
name|nic
operator|->
name|napi
index|[
name|qidx
index|]
operator|=
name|NULL
expr_stmt|;
name|kfree
argument_list|(
name|cq_poll
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|nicvf_stop
parameter_list|(
name|struct
name|net_device
modifier|*
name|netdev
parameter_list|)
block|{
name|int
name|irq
decl_stmt|,
name|qidx
decl_stmt|;
name|struct
name|nicvf
modifier|*
name|nic
init|=
name|netdev_priv
argument_list|(
name|netdev
argument_list|)
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
init|=
name|nic
operator|->
name|qs
decl_stmt|;
name|struct
name|nicvf_cq_poll
modifier|*
name|cq_poll
init|=
name|NULL
decl_stmt|;
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|msg
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_SHUTDOWN
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
name|netif_carrier_off
argument_list|(
name|netdev
argument_list|)
expr_stmt|;
name|netif_tx_stop_all_queues
argument_list|(
name|nic
operator|->
name|netdev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
comment|/* Teardown secondary qsets first */
if|if
condition|(
operator|!
name|nic
operator|->
name|sqs_mode
condition|)
block|{
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|nic
operator|->
name|sqs_count
condition|;
name|qidx
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|nic
operator|->
name|snicvf
index|[
name|qidx
index|]
condition|)
continue|continue;
name|nicvf_stop
argument_list|(
name|nic
operator|->
name|snicvf
index|[
name|qidx
index|]
operator|->
name|netdev
argument_list|)
expr_stmt|;
name|nic
operator|->
name|snicvf
index|[
name|qidx
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Disable RBDR& QS error interrupts */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|rbdr_cnt
condition|;
name|qidx
operator|++
control|)
block|{
name|nicvf_disable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_RBDR
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|nicvf_clear_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_RBDR
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
block|}
name|nicvf_disable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_QS_ERR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nicvf_clear_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_QS_ERR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait for pending IRQ handlers to finish */
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
name|nic
operator|->
name|num_vec
condition|;
name|irq
operator|++
control|)
name|synchronize_irq
argument_list|(
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|vector
argument_list|)
expr_stmt|;
name|tasklet_kill
argument_list|(
operator|&
name|nic
operator|->
name|rbdr_task
argument_list|)
expr_stmt|;
name|tasklet_kill
argument_list|(
operator|&
name|nic
operator|->
name|qs_err_task
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|rb_work_scheduled
condition|)
name|cancel_delayed_work_sync
argument_list|(
operator|&
name|nic
operator|->
name|rbdr_work
argument_list|)
expr_stmt|;
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|nic
operator|->
name|qs
operator|->
name|cq_cnt
condition|;
name|qidx
operator|++
control|)
block|{
name|cq_poll
operator|=
name|nic
operator|->
name|napi
index|[
name|qidx
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|cq_poll
condition|)
continue|continue;
name|napi_synchronize
argument_list|(
operator|&
name|cq_poll
operator|->
name|napi
argument_list|)
expr_stmt|;
comment|/* CQ intr is enabled while napi_complete, 		 * so disable it now 		 */
name|nicvf_disable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_CQ
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|nicvf_clear_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_CQ
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|napi_disable
argument_list|(
operator|&
name|cq_poll
operator|->
name|napi
argument_list|)
expr_stmt|;
name|netif_napi_del
argument_list|(
operator|&
name|cq_poll
operator|->
name|napi
argument_list|)
expr_stmt|;
block|}
name|netif_tx_disable
argument_list|(
name|netdev
argument_list|)
expr_stmt|;
comment|/* Free resources */
name|nicvf_config_data_transfer
argument_list|(
name|nic
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Disable HW Qset */
name|nicvf_qset_config
argument_list|(
name|nic
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* disable mailbox interrupt */
name|nicvf_disable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_MBOX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nicvf_unregister_interrupts
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|nicvf_free_cq_poll
argument_list|(
name|nic
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
comment|/* Clear multiqset info */
name|nic
operator|->
name|pnicvf
operator|=
name|nic
expr_stmt|;
name|nic
operator|->
name|sqs_count
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|nicvf_open
parameter_list|(
name|struct
name|net_device
modifier|*
name|netdev
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|qidx
decl_stmt|;
name|struct
name|nicvf
modifier|*
name|nic
init|=
name|netdev_priv
argument_list|(
name|netdev
argument_list|)
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
init|=
name|nic
operator|->
name|qs
decl_stmt|;
name|struct
name|nicvf_cq_poll
modifier|*
name|cq_poll
init|=
name|NULL
decl_stmt|;
name|nic
operator|->
name|mtu
operator|=
name|netdev
operator|->
name|mtu
expr_stmt|;
name|netif_carrier_off
argument_list|(
name|netdev
argument_list|)
expr_stmt|;
name|err
operator|=
name|nicvf_register_misc_interrupt
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* Register NAPI handler for processing CQEs */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|cq_cnt
condition|;
name|qidx
operator|++
control|)
block|{
name|cq_poll
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cq_poll
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cq_poll
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|napi_del
goto|;
block|}
name|cq_poll
operator|->
name|cq_idx
operator|=
name|qidx
expr_stmt|;
name|cq_poll
operator|->
name|nicvf
operator|=
name|nic
expr_stmt|;
name|netif_napi_add
argument_list|(
name|netdev
argument_list|,
operator|&
name|cq_poll
operator|->
name|napi
argument_list|,
name|nicvf_poll
argument_list|,
name|NAPI_POLL_WEIGHT
argument_list|)
expr_stmt|;
name|napi_enable
argument_list|(
operator|&
name|cq_poll
operator|->
name|napi
argument_list|)
expr_stmt|;
name|nic
operator|->
name|napi
index|[
name|qidx
index|]
operator|=
name|cq_poll
expr_stmt|;
block|}
comment|/* Check if we got MAC address from PF or else generate a radom MAC */
if|if
condition|(
name|is_zero_ether_addr
argument_list|(
name|netdev
operator|->
name|dev_addr
argument_list|)
condition|)
block|{
name|eth_hw_addr_random
argument_list|(
name|netdev
argument_list|)
expr_stmt|;
name|nicvf_hw_set_mac_addr
argument_list|(
name|nic
argument_list|,
name|netdev
argument_list|)
expr_stmt|;
block|}
comment|/* Init tasklet for handling Qset err interrupt */
name|tasklet_init
argument_list|(
operator|&
name|nic
operator|->
name|qs_err_task
argument_list|,
name|nicvf_handle_qs_err
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|nic
argument_list|)
expr_stmt|;
comment|/* Init RBDR tasklet which will refill RBDR */
name|tasklet_init
argument_list|(
operator|&
name|nic
operator|->
name|rbdr_task
argument_list|,
name|nicvf_rbdr_task
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|nic
argument_list|)
expr_stmt|;
name|INIT_DELAYED_WORK
argument_list|(
operator|&
name|nic
operator|->
name|rbdr_work
argument_list|,
name|nicvf_rbdr_work
argument_list|)
expr_stmt|;
comment|/* Configure CPI alorithm */
name|nic
operator|->
name|cpi_alg
operator|=
name|cpi_alg
expr_stmt|;
if|if
condition|(
operator|!
name|nic
operator|->
name|sqs_mode
condition|)
name|nicvf_config_cpi
argument_list|(
name|nic
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
name|nicvf_request_sqs
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|sqs_mode
condition|)
name|nicvf_get_primary_vf_struct
argument_list|(
name|nic
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VNIC_RSS_SUPPORT
comment|/* Configure receive side scaling */
if|if
condition|(
operator|!
name|nic
operator|->
name|sqs_mode
condition|)
name|nicvf_rss_init
argument_list|(
name|nic
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|err
operator|=
name|nicvf_register_interrupts
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Initialize the queues */
name|err
operator|=
name|nicvf_init_resources
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Make sure queue initialization is written */
name|wmb
argument_list|()
expr_stmt|;
name|nicvf_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_VF_INT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Enable Qset err interrupt */
name|nicvf_enable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_QS_ERR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable completion queue interrupt */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|cq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_enable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_CQ
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
comment|/* Enable RBDR threshold interrupt */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|rbdr_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_enable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_RBDR
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|nic
operator|->
name|drv_stats
operator|.
name|txq_stop
operator|=
literal|0
expr_stmt|;
name|nic
operator|->
name|drv_stats
operator|.
name|txq_wake
operator|=
literal|0
expr_stmt|;
name|netif_carrier_on
argument_list|(
name|netdev
argument_list|)
expr_stmt|;
name|netif_tx_start_all_queues
argument_list|(
name|netdev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|cleanup
label|:
name|nicvf_disable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_MBOX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nicvf_unregister_interrupts
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|tasklet_kill
argument_list|(
operator|&
name|nic
operator|->
name|qs_err_task
argument_list|)
expr_stmt|;
name|tasklet_kill
argument_list|(
operator|&
name|nic
operator|->
name|rbdr_task
argument_list|)
expr_stmt|;
name|napi_del
label|:
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|cq_cnt
condition|;
name|qidx
operator|++
control|)
block|{
name|cq_poll
operator|=
name|nic
operator|->
name|napi
index|[
name|qidx
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|cq_poll
condition|)
continue|continue;
name|napi_disable
argument_list|(
operator|&
name|cq_poll
operator|->
name|napi
argument_list|)
expr_stmt|;
name|netif_napi_del
argument_list|(
operator|&
name|cq_poll
operator|->
name|napi
argument_list|)
expr_stmt|;
block|}
name|nicvf_free_cq_poll
argument_list|(
name|nic
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_update_hw_max_frs
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|int
name|mtu
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|frs
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_SET_MAX_FRS
expr_stmt|;
name|mbx
operator|.
name|frs
operator|.
name|max_frs
operator|=
name|mtu
expr_stmt|;
name|mbx
operator|.
name|frs
operator|.
name|vf_id
operator|=
name|nic
operator|->
name|vf_id
expr_stmt|;
return|return
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_change_mtu
parameter_list|(
name|struct
name|net_device
modifier|*
name|netdev
parameter_list|,
name|int
name|new_mtu
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
init|=
name|netdev_priv
argument_list|(
name|netdev
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_mtu
operator|>
name|NIC_HW_MAX_FRS
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|new_mtu
operator|<
name|NIC_HW_MIN_FRS
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|nicvf_update_hw_max_frs
argument_list|(
name|nic
argument_list|,
name|new_mtu
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|netdev
operator|->
name|mtu
operator|=
name|new_mtu
expr_stmt|;
name|nic
operator|->
name|mtu
operator|=
name|new_mtu
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_set_mac_address
parameter_list|(
name|struct
name|net_device
modifier|*
name|netdev
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|addr
init|=
name|p
decl_stmt|;
name|struct
name|nicvf
modifier|*
name|nic
init|=
name|netdev_priv
argument_list|(
name|netdev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|is_valid_ether_addr
argument_list|(
name|addr
operator|->
name|sa_data
argument_list|)
condition|)
return|return
operator|-
name|EADDRNOTAVAIL
return|;
name|memcpy
argument_list|(
name|netdev
operator|->
name|dev_addr
argument_list|,
name|addr
operator|->
name|sa_data
argument_list|,
name|netdev
operator|->
name|addr_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|msix_enabled
condition|)
if|if
condition|(
name|nicvf_hw_set_mac_addr
argument_list|(
name|nic
argument_list|,
name|netdev
argument_list|)
condition|)
return|return
operator|-
name|EBUSY
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|nicvf_update_lmac_stats
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|stat
init|=
literal|0
decl_stmt|;
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
if|if
condition|(
operator|!
name|netif_running
argument_list|(
name|nic
operator|->
name|netdev
argument_list|)
condition|)
return|return;
name|mbx
operator|.
name|bgx_stats
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_BGX_STATS
expr_stmt|;
name|mbx
operator|.
name|bgx_stats
operator|.
name|vf_id
operator|=
name|nic
operator|->
name|vf_id
expr_stmt|;
comment|/* Rx stats */
name|mbx
operator|.
name|bgx_stats
operator|.
name|rx
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|stat
operator|<
name|BGX_RX_STATS_COUNT
condition|)
block|{
name|mbx
operator|.
name|bgx_stats
operator|.
name|idx
operator|=
name|stat
expr_stmt|;
if|if
condition|(
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
condition|)
return|return;
name|stat
operator|++
expr_stmt|;
block|}
name|stat
operator|=
literal|0
expr_stmt|;
comment|/* Tx stats */
name|mbx
operator|.
name|bgx_stats
operator|.
name|rx
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|stat
operator|<
name|BGX_TX_STATS_COUNT
condition|)
block|{
name|mbx
operator|.
name|bgx_stats
operator|.
name|idx
operator|=
name|stat
expr_stmt|;
if|if
condition|(
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
condition|)
return|return;
name|stat
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|nicvf_update_stats
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|qidx
decl_stmt|;
name|struct
name|nicvf_hw_stats
modifier|*
name|stats
init|=
operator|&
name|nic
operator|->
name|hw_stats
decl_stmt|;
name|struct
name|nicvf_drv_stats
modifier|*
name|drv_stats
init|=
operator|&
name|nic
operator|->
name|drv_stats
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
init|=
name|nic
operator|->
name|qs
decl_stmt|;
define|#
directive|define
name|GET_RX_STATS
parameter_list|(
name|reg
parameter_list|)
define|\
value|nicvf_reg_read(nic, NIC_VNIC_RX_STAT_0_13 | (reg<< 3))
define|#
directive|define
name|GET_TX_STATS
parameter_list|(
name|reg
parameter_list|)
define|\
value|nicvf_reg_read(nic, NIC_VNIC_TX_STAT_0_4 | (reg<< 3))
name|stats
operator|->
name|rx_bytes
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_OCTS
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_ucast_frames
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_UCAST
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_bcast_frames
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_BCAST
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_mcast_frames
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_MCAST
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_fcs_errors
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_FCS
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_l2_errors
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_L2ERR
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_drop_red
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_RED
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_drop_red_bytes
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_RED_OCTS
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_drop_overrun
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_ORUN
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_drop_overrun_bytes
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_ORUN_OCTS
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_drop_bcast
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_DRP_BCAST
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_drop_mcast
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_DRP_MCAST
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_drop_l3_bcast
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_DRP_L3BCAST
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_drop_l3_mcast
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_DRP_L3MCAST
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_bytes_ok
operator|=
name|GET_TX_STATS
argument_list|(
name|TX_OCTS
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_ucast_frames_ok
operator|=
name|GET_TX_STATS
argument_list|(
name|TX_UCAST
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_bcast_frames_ok
operator|=
name|GET_TX_STATS
argument_list|(
name|TX_BCAST
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_mcast_frames_ok
operator|=
name|GET_TX_STATS
argument_list|(
name|TX_MCAST
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_drops
operator|=
name|GET_TX_STATS
argument_list|(
name|TX_DROP
argument_list|)
expr_stmt|;
name|drv_stats
operator|->
name|tx_frames_ok
operator|=
name|stats
operator|->
name|tx_ucast_frames_ok
operator|+
name|stats
operator|->
name|tx_bcast_frames_ok
operator|+
name|stats
operator|->
name|tx_mcast_frames_ok
expr_stmt|;
name|drv_stats
operator|->
name|rx_drops
operator|=
name|stats
operator|->
name|rx_drop_red
operator|+
name|stats
operator|->
name|rx_drop_overrun
expr_stmt|;
name|drv_stats
operator|->
name|tx_drops
operator|=
name|stats
operator|->
name|tx_drops
expr_stmt|;
comment|/* Update RQ and SQ stats */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|rq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_update_rq_stats
argument_list|(
name|nic
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|sq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_update_sq_stats
argument_list|(
name|nic
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|rtnl_link_stats64
modifier|*
name|nicvf_get_stats64
parameter_list|(
name|struct
name|net_device
modifier|*
name|netdev
parameter_list|,
name|struct
name|rtnl_link_stats64
modifier|*
name|stats
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
init|=
name|netdev_priv
argument_list|(
name|netdev
argument_list|)
decl_stmt|;
name|struct
name|nicvf_hw_stats
modifier|*
name|hw_stats
init|=
operator|&
name|nic
operator|->
name|hw_stats
decl_stmt|;
name|struct
name|nicvf_drv_stats
modifier|*
name|drv_stats
init|=
operator|&
name|nic
operator|->
name|drv_stats
decl_stmt|;
name|nicvf_update_stats
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_bytes
operator|=
name|hw_stats
operator|->
name|rx_bytes
expr_stmt|;
name|stats
operator|->
name|rx_packets
operator|=
name|drv_stats
operator|->
name|rx_frames_ok
expr_stmt|;
name|stats
operator|->
name|rx_dropped
operator|=
name|drv_stats
operator|->
name|rx_drops
expr_stmt|;
name|stats
operator|->
name|multicast
operator|=
name|hw_stats
operator|->
name|rx_mcast_frames
expr_stmt|;
name|stats
operator|->
name|tx_bytes
operator|=
name|hw_stats
operator|->
name|tx_bytes_ok
expr_stmt|;
name|stats
operator|->
name|tx_packets
operator|=
name|drv_stats
operator|->
name|tx_frames_ok
expr_stmt|;
name|stats
operator|->
name|tx_dropped
operator|=
name|drv_stats
operator|->
name|tx_drops
expr_stmt|;
return|return
name|stats
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_tx_timeout
parameter_list|(
name|struct
name|net_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
init|=
name|netdev_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|netif_msg_tx_err
argument_list|(
name|nic
argument_list|)
condition|)
name|netdev_warn
argument_list|(
name|dev
argument_list|,
literal|"%s: Transmit timed out, resetting\n"
argument_list|,
name|dev
operator|->
name|name
argument_list|)
expr_stmt|;
name|schedule_work
argument_list|(
operator|&
name|nic
operator|->
name|reset_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_reset_task
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
decl_stmt|;
name|nic
operator|=
name|container_of
argument_list|(
name|work
argument_list|,
expr|struct
name|nicvf
argument_list|,
name|reset_task
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|netif_running
argument_list|(
name|nic
operator|->
name|netdev
argument_list|)
condition|)
return|return;
name|nicvf_stop
argument_list|(
name|nic
operator|->
name|netdev
argument_list|)
expr_stmt|;
name|nicvf_open
argument_list|(
name|nic
operator|->
name|netdev
argument_list|)
expr_stmt|;
name|nic
operator|->
name|netdev
operator|->
name|trans_start
operator|=
name|jiffies
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_config_loopback
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|netdev_features_t
name|features
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|lbk
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_LOOPBACK
expr_stmt|;
name|mbx
operator|.
name|lbk
operator|.
name|vf_id
operator|=
name|nic
operator|->
name|vf_id
expr_stmt|;
name|mbx
operator|.
name|lbk
operator|.
name|enable
operator|=
operator|(
name|features
operator|&
name|NETIF_F_LOOPBACK
operator|)
operator|!=
literal|0
expr_stmt|;
return|return
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|netdev_features_t
name|nicvf_fix_features
parameter_list|(
name|struct
name|net_device
modifier|*
name|netdev
parameter_list|,
name|netdev_features_t
name|features
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
init|=
name|netdev_priv
argument_list|(
name|netdev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|features
operator|&
name|NETIF_F_LOOPBACK
operator|)
operator|&&
name|netif_running
argument_list|(
name|netdev
argument_list|)
operator|&&
operator|!
name|nic
operator|->
name|loopback_supported
condition|)
name|features
operator|&=
operator|~
name|NETIF_F_LOOPBACK
expr_stmt|;
return|return
name|features
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_set_features
parameter_list|(
name|struct
name|net_device
modifier|*
name|netdev
parameter_list|,
name|netdev_features_t
name|features
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
init|=
name|netdev_priv
argument_list|(
name|netdev
argument_list|)
decl_stmt|;
name|netdev_features_t
name|changed
init|=
name|features
operator|^
name|netdev
operator|->
name|features
decl_stmt|;
if|if
condition|(
name|changed
operator|&
name|NETIF_F_HW_VLAN_CTAG_RX
condition|)
name|nicvf_config_vlan_stripping
argument_list|(
name|nic
argument_list|,
name|features
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|changed
operator|&
name|NETIF_F_LOOPBACK
operator|)
operator|&&
name|netif_running
argument_list|(
name|netdev
argument_list|)
condition|)
return|return
name|nicvf_config_loopback
argument_list|(
name|nic
argument_list|,
name|features
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|net_device_ops
name|nicvf_netdev_ops
init|=
block|{
operator|.
name|ndo_open
operator|=
name|nicvf_open
block|,
operator|.
name|ndo_stop
operator|=
name|nicvf_stop
block|,
operator|.
name|ndo_start_xmit
operator|=
name|nicvf_xmit
block|,
operator|.
name|ndo_change_mtu
operator|=
name|nicvf_change_mtu
block|,
operator|.
name|ndo_set_mac_address
operator|=
name|nicvf_set_mac_address
block|,
operator|.
name|ndo_get_stats64
operator|=
name|nicvf_get_stats64
block|,
operator|.
name|ndo_tx_timeout
operator|=
name|nicvf_tx_timeout
block|,
operator|.
name|ndo_fix_features
operator|=
name|nicvf_fix_features
block|,
operator|.
name|ndo_set_features
operator|=
name|nicvf_set_features
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|nicvf_probe
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
specifier|const
name|struct
name|pci_device_id
modifier|*
name|ent
parameter_list|)
block|{
name|struct
name|device
modifier|*
name|dev
init|=
operator|&
name|pdev
operator|->
name|dev
decl_stmt|;
name|struct
name|net_device
modifier|*
name|netdev
decl_stmt|;
name|struct
name|nicvf
modifier|*
name|nic
decl_stmt|;
name|int
name|err
decl_stmt|,
name|qcount
decl_stmt|;
name|err
operator|=
name|pci_enable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to enable PCI device\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|pci_request_regions
argument_list|(
name|pdev
argument_list|,
name|DRV_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
name|dev
argument_list|,
literal|"PCI request regions failed 0x%x\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_disable_device
goto|;
block|}
name|err
operator|=
name|pci_set_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|48
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
name|dev
argument_list|,
literal|"Unable to get usable DMA configuration\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_release_regions
goto|;
block|}
name|err
operator|=
name|pci_set_consistent_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|48
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
name|dev
argument_list|,
literal|"unable to get 48-bit DMA for consistent allocations\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_release_regions
goto|;
block|}
name|qcount
operator|=
name|MAX_CMP_QUEUES_PER_QS
expr_stmt|;
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
comment|/* Restrict multiqset support only for host bound VFs */
if|if
condition|(
name|pdev
operator|->
name|is_virtfn
condition|)
block|{
comment|/* Set max number of queues per VF */
name|qcount
operator|=
name|roundup
argument_list|(
name|num_online_cpus
argument_list|()
argument_list|,
name|MAX_CMP_QUEUES_PER_QS
argument_list|)
expr_stmt|;
name|qcount
operator|=
name|min
argument_list|(
name|qcount
argument_list|,
operator|(
name|MAX_SQS_PER_VF
operator|+
literal|1
operator|)
operator|*
name|MAX_CMP_QUEUES_PER_QS
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|netdev
operator|=
name|alloc_etherdev_mqs
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nicvf
argument_list|)
argument_list|,
name|qcount
argument_list|,
name|qcount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|netdev
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_release_regions
goto|;
block|}
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|netdev
argument_list|)
expr_stmt|;
name|SET_NETDEV_DEV
argument_list|(
name|netdev
argument_list|,
operator|&
name|pdev
operator|->
name|dev
argument_list|)
expr_stmt|;
name|nic
operator|=
name|netdev_priv
argument_list|(
name|netdev
argument_list|)
expr_stmt|;
name|nic
operator|->
name|netdev
operator|=
name|netdev
expr_stmt|;
name|nic
operator|->
name|pdev
operator|=
name|pdev
expr_stmt|;
name|nic
operator|->
name|pnicvf
operator|=
name|nic
expr_stmt|;
name|nic
operator|->
name|max_queues
operator|=
name|qcount
expr_stmt|;
comment|/* MAP VF's configuration registers */
name|nic
operator|->
name|reg_base
operator|=
name|pcim_iomap
argument_list|(
name|pdev
argument_list|,
name|PCI_CFG_REG_BAR_NUM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nic
operator|->
name|reg_base
condition|)
block|{
name|dev_err
argument_list|(
name|dev
argument_list|,
literal|"Cannot map config register space, aborting\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_free_netdev
goto|;
block|}
name|err
operator|=
name|nicvf_set_qset_resources
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_free_netdev
goto|;
comment|/* Check if PF is alive and get MAC address for this VF */
name|err
operator|=
name|nicvf_register_misc_interrupt
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_free_netdev
goto|;
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
name|nicvf_send_vf_struct
argument_list|(
name|nic
argument_list|)
expr_stmt|;
comment|/* Check if this VF is in QS only mode */
if|if
condition|(
name|nic
operator|->
name|sqs_mode
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|err
operator|=
name|nicvf_set_real_num_queues
argument_list|(
name|netdev
argument_list|,
name|nic
operator|->
name|tx_queues
argument_list|,
name|nic
operator|->
name|rx_queues
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_unregister_interrupts
goto|;
name|netdev
operator|->
name|hw_features
operator|=
operator|(
name|NETIF_F_RXCSUM
operator||
name|NETIF_F_IP_CSUM
operator||
name|NETIF_F_SG
operator||
name|NETIF_F_GRO
operator||
name|NETIF_F_HW_VLAN_CTAG_RX
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VNIC_RSS_SUPPORT
name|netdev
operator|->
name|hw_features
operator||=
name|NETIF_F_RXHASH
expr_stmt|;
endif|#
directive|endif
name|netdev
operator|->
name|features
operator||=
name|netdev
operator|->
name|hw_features
expr_stmt|;
name|netdev
operator|->
name|hw_features
operator||=
name|NETIF_F_LOOPBACK
expr_stmt|;
name|netdev
operator|->
name|vlan_features
operator|=
name|NETIF_F_SG
operator||
name|NETIF_F_IP_CSUM
expr_stmt|;
name|netdev
operator|->
name|netdev_ops
operator|=
operator|&
name|nicvf_netdev_ops
expr_stmt|;
name|netdev
operator|->
name|watchdog_timeo
operator|=
name|NICVF_TX_TIMEOUT
expr_stmt|;
name|INIT_WORK
argument_list|(
operator|&
name|nic
operator|->
name|reset_task
argument_list|,
name|nicvf_reset_task
argument_list|)
expr_stmt|;
name|err
operator|=
name|register_netdev
argument_list|(
name|netdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to register netdevice\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unregister_interrupts
goto|;
block|}
name|nic
operator|->
name|msg_enable
operator|=
name|debug
expr_stmt|;
name|nicvf_set_ethtool_ops
argument_list|(
name|netdev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_unregister_interrupts
label|:
name|nicvf_unregister_interrupts
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|err_free_netdev
label|:
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free_netdev
argument_list|(
name|netdev
argument_list|)
expr_stmt|;
name|err_release_regions
label|:
name|pci_release_regions
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|err_disable_device
label|:
name|pci_disable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_remove
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|struct
name|net_device
modifier|*
name|netdev
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|struct
name|nicvf
modifier|*
name|nic
init|=
name|netdev_priv
argument_list|(
name|netdev
argument_list|)
decl_stmt|;
name|struct
name|net_device
modifier|*
name|pnetdev
init|=
name|nic
operator|->
name|pnicvf
operator|->
name|netdev
decl_stmt|;
comment|/* Check if this Qset is assigned to different VF. 	 * If yes, clean primary and all secondary Qsets. 	 */
if|if
condition|(
name|pnetdev
operator|&&
operator|(
name|pnetdev
operator|->
name|reg_state
operator|==
name|NETREG_REGISTERED
operator|)
condition|)
name|unregister_netdev
argument_list|(
name|pnetdev
argument_list|)
expr_stmt|;
name|nicvf_unregister_interrupts
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free_netdev
argument_list|(
name|netdev
argument_list|)
expr_stmt|;
name|pci_release_regions
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|pci_disable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_shutdown
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|nicvf_remove
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|pci_driver
name|nicvf_driver
init|=
block|{
operator|.
name|name
operator|=
name|DRV_NAME
block|,
operator|.
name|id_table
operator|=
name|nicvf_id_table
block|,
operator|.
name|probe
operator|=
name|nicvf_probe
block|,
operator|.
name|remove
operator|=
name|nicvf_remove
block|,
operator|.
name|shutdown
operator|=
name|nicvf_shutdown
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|__init
name|nicvf_init_module
parameter_list|(
name|void
parameter_list|)
block|{
name|pr_info
argument_list|(
literal|"%s, ver %s\n"
argument_list|,
name|DRV_NAME
argument_list|,
name|DRV_VERSION
argument_list|)
expr_stmt|;
return|return
name|pci_register_driver
argument_list|(
operator|&
name|nicvf_driver
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__exit
name|nicvf_cleanup_module
parameter_list|(
name|void
parameter_list|)
block|{
name|pci_unregister_driver
argument_list|(
operator|&
name|nicvf_driver
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|module_init
argument_list|(
name|nicvf_init_module
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_exit
argument_list|(
name|nicvf_cleanup_module
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

