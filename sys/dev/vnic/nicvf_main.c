begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2015 Cavium Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bitset.h>
end_include

begin_include
include|#
directive|include
file|<sys/bitstring.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/stdatomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_lro.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnv.h>
end_include

begin_include
include|#
directive|include
file|<sys/nv.h>
end_include

begin_include
include|#
directive|include
file|<sys/iov_schema.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|"thunder_bgx.h"
end_include

begin_include
include|#
directive|include
file|"nic_reg.h"
end_include

begin_include
include|#
directive|include
file|"nic.h"
end_include

begin_include
include|#
directive|include
file|"nicvf_queues.h"
end_include

begin_define
define|#
directive|define
name|VNIC_VF_DEVSTR
value|"Cavium Thunder NIC Virtual Function Driver"
end_define

begin_define
define|#
directive|define
name|VNIC_VF_REG_RID
value|PCIR_BAR(PCI_CFG_REG_BAR_NUM)
end_define

begin_comment
comment|/* Lock for core interface settings */
end_comment

begin_define
define|#
directive|define
name|NICVF_CORE_LOCK_INIT
parameter_list|(
name|nic
parameter_list|)
define|\
value|sx_init(&(nic)->core_sx, device_get_nameunit((nic)->dev))
end_define

begin_define
define|#
directive|define
name|NICVF_CORE_LOCK_DESTROY
parameter_list|(
name|nic
parameter_list|)
define|\
value|sx_destroy(&(nic)->core_sx)
end_define

begin_define
define|#
directive|define
name|NICVF_CORE_LOCK
parameter_list|(
name|nic
parameter_list|)
value|sx_xlock(&(nic)->core_sx)
end_define

begin_define
define|#
directive|define
name|NICVF_CORE_UNLOCK
parameter_list|(
name|nic
parameter_list|)
value|sx_xunlock(&(nic)->core_sx)
end_define

begin_define
define|#
directive|define
name|NICVF_CORE_LOCK_ASSERT
parameter_list|(
name|nic
parameter_list|)
value|sx_assert(&(nic)->core_sx, SA_XLOCKED)
end_define

begin_define
define|#
directive|define
name|SPEED_10
value|10
end_define

begin_define
define|#
directive|define
name|SPEED_100
value|100
end_define

begin_define
define|#
directive|define
name|SPEED_1000
value|1000
end_define

begin_define
define|#
directive|define
name|SPEED_10000
value|10000
end_define

begin_define
define|#
directive|define
name|SPEED_40000
value|40000
end_define

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NICVF
argument_list|,
literal|"nicvf"
argument_list|,
literal|"ThunderX VNIC VF dynamic memory"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|nicvf_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicvf_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicvf_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|nicvf_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|nicvf_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|nicvf_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|nicvf_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|nicvf_driver
init|=
block|{
literal|"vnic"
block|,
name|nicvf_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|nicvf
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|nicvf_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|vnicvf
argument_list|,
name|pci
argument_list|,
name|nicvf_driver
argument_list|,
name|nicvf_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|vnicvf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|vnicvf
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|vnicvf
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|vnicvf
argument_list|,
name|vnicpf
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|nicvf_allocate_misc_interrupt
parameter_list|(
name|struct
name|nicvf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicvf_enable_misc_interrupt
parameter_list|(
name|struct
name|nicvf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicvf_allocate_net_interrupts
parameter_list|(
name|struct
name|nicvf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nicvf_release_all_interrupts
parameter_list|(
name|struct
name|nicvf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicvf_update_hw_max_frs
parameter_list|(
name|struct
name|nicvf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicvf_hw_set_mac_addr
parameter_list|(
name|struct
name|nicvf
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nicvf_config_cpi
parameter_list|(
name|struct
name|nicvf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicvf_rss_init
parameter_list|(
name|struct
name|nicvf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicvf_init_resources
parameter_list|(
name|struct
name|nicvf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicvf_setup_ifnet
parameter_list|(
name|struct
name|nicvf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicvf_setup_ifmedia
parameter_list|(
name|struct
name|nicvf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nicvf_hw_addr_random
parameter_list|(
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicvf_if_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nicvf_if_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nicvf_if_init_locked
parameter_list|(
name|struct
name|nicvf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicvf_if_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nicvf_if_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|nicvf_if_getcounter
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|ift_counter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicvf_stop_locked
parameter_list|(
name|struct
name|nicvf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nicvf_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicvf_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nicvf_tick_stats
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|nicvf_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|uint16_t
name|vendor_id
decl_stmt|;
name|uint16_t
name|device_id
decl_stmt|;
name|vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|vendor_id
operator|!=
name|PCI_VENDOR_ID_CAVIUM
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|device_id
operator|==
name|PCI_DEVICE_ID_THUNDER_NIC_VF
operator|||
name|device_id
operator|==
name|PCI_DEVICE_ID_THUNDER_PASS1_NIC_VF
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|VNIC_VF_DEVSTR
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|qcount
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|uint8_t
name|hwaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|uint8_t
name|zeromac
index|[]
init|=
block|{
index|[
literal|0
operator|...
operator|(
name|ETHER_ADDR_LEN
operator|-
literal|1
operator|)
index|]
operator|=
literal|0
block|}
decl_stmt|;
name|nic
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|nic
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|nic
operator|->
name|pnicvf
operator|=
name|nic
expr_stmt|;
name|NICVF_CORE_LOCK_INIT
argument_list|(
name|nic
argument_list|)
expr_stmt|;
comment|/* Enable HW TSO on Pass2 */
if|if
condition|(
operator|!
name|pass1_silicon
argument_list|(
name|dev
argument_list|)
condition|)
name|nic
operator|->
name|hw_tso
operator|=
name|TRUE
expr_stmt|;
name|rid
operator|=
name|VNIC_VF_REG_RID
expr_stmt|;
name|nic
operator|->
name|reg_base
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|reg_base
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate registers memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|qcount
operator|=
name|MAX_CMP_QUEUES_PER_QS
expr_stmt|;
name|nic
operator|->
name|max_queues
operator|=
name|qcount
expr_stmt|;
name|err
operator|=
name|nicvf_set_qset_resources
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|err_free_res
goto|;
comment|/* Check if PF is alive and get MAC address for this VF */
name|err
operator|=
name|nicvf_allocate_misc_interrupt
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|err_free_res
goto|;
name|NICVF_CORE_LOCK
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|err
operator|=
name|nicvf_enable_misc_interrupt
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|NICVF_CORE_UNLOCK
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|err_release_intr
goto|;
name|err
operator|=
name|nicvf_allocate_net_interrupts
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate network interface interrupts\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_ifnet
goto|;
block|}
comment|/* If no MAC address was obtained we generate random one */
if|if
condition|(
name|memcmp
argument_list|(
name|nic
operator|->
name|hwaddr
argument_list|,
name|zeromac
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nicvf_hw_addr_random
argument_list|(
name|hwaddr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nic
operator|->
name|hwaddr
argument_list|,
name|hwaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|NICVF_CORE_LOCK
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|nicvf_hw_set_mac_addr
argument_list|(
name|nic
argument_list|,
name|hwaddr
argument_list|)
expr_stmt|;
name|NICVF_CORE_UNLOCK
argument_list|(
name|nic
argument_list|)
expr_stmt|;
block|}
comment|/* Configure CPI alorithm */
name|nic
operator|->
name|cpi_alg
operator|=
name|CPI_ALG_NONE
expr_stmt|;
name|NICVF_CORE_LOCK
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|nicvf_config_cpi
argument_list|(
name|nic
argument_list|)
expr_stmt|;
comment|/* Configure receive side scaling */
if|if
condition|(
name|nic
operator|->
name|qs
operator|->
name|rq_cnt
operator|>
literal|1
condition|)
name|nicvf_rss_init
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|NICVF_CORE_UNLOCK
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|err
operator|=
name|nicvf_setup_ifnet
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not set-up ifnet\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_release_intr
goto|;
block|}
name|err
operator|=
name|nicvf_setup_ifmedia
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not set-up ifmedia\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_ifnet
goto|;
block|}
name|mtx_init
argument_list|(
operator|&
name|nic
operator|->
name|stats_mtx
argument_list|,
literal|"VNIC stats"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|nic
operator|->
name|stats_callout
argument_list|,
operator|&
name|nic
operator|->
name|stats_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|nic
operator|->
name|ifp
argument_list|,
name|nic
operator|->
name|hwaddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_free_ifnet
label|:
name|if_free
argument_list|(
name|nic
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|err_release_intr
label|:
name|nicvf_release_all_interrupts
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|err_free_res
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rman_get_rid
argument_list|(
name|nic
operator|->
name|reg_base
argument_list|)
argument_list|,
name|nic
operator|->
name|reg_base
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
decl_stmt|;
name|nic
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|NICVF_CORE_LOCK
argument_list|(
name|nic
argument_list|)
expr_stmt|;
comment|/* Shut down the port and release ring resources */
name|nicvf_stop_locked
argument_list|(
name|nic
argument_list|)
expr_stmt|;
comment|/* Release stats lock */
name|mtx_destroy
argument_list|(
operator|&
name|nic
operator|->
name|stats_mtx
argument_list|)
expr_stmt|;
comment|/* Release interrupts */
name|nicvf_release_all_interrupts
argument_list|(
name|nic
argument_list|)
expr_stmt|;
comment|/* Release memory resource */
if|if
condition|(
name|nic
operator|->
name|reg_base
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rman_get_rid
argument_list|(
name|nic
operator|->
name|reg_base
argument_list|)
argument_list|,
name|nic
operator|->
name|reg_base
argument_list|)
expr_stmt|;
block|}
comment|/* Remove all ifmedia configurations */
name|ifmedia_removeall
argument_list|(
operator|&
name|nic
operator|->
name|if_media
argument_list|)
expr_stmt|;
comment|/* Free this ifnet */
name|if_free
argument_list|(
name|nic
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|NICVF_CORE_UNLOCK
argument_list|(
name|nic
argument_list|)
expr_stmt|;
comment|/* Finally destroy the lock */
name|NICVF_CORE_LOCK_DESTROY
argument_list|(
name|nic
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_hw_addr_random
parameter_list|(
name|uint8_t
modifier|*
name|hwaddr
parameter_list|)
block|{
name|uint32_t
name|rnd
decl_stmt|;
name|uint8_t
name|addr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
comment|/* 	 * Create randomized MAC address. 	 * Set 'bsd' + random 24 low-order bits. 	 */
name|rnd
operator|=
name|arc4random
argument_list|()
operator|&
literal|0x00ffffff
expr_stmt|;
name|addr
index|[
literal|0
index|]
operator|=
literal|'b'
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
literal|'s'
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
literal|'d'
expr_stmt|;
name|addr
index|[
literal|3
index|]
operator|=
name|rnd
operator|>>
literal|16
expr_stmt|;
name|addr
index|[
literal|4
index|]
operator|=
name|rnd
operator|>>
literal|8
expr_stmt|;
name|addr
index|[
literal|5
index|]
operator|=
name|rnd
operator|>>
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|hwaddr
argument_list|,
name|addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_setup_ifnet
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Could not allocate ifnet structure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|nic
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
name|if_setsoftc
argument_list|(
name|ifp
argument_list|,
name|nic
argument_list|)
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|if_setflags
argument_list|(
name|ifp
argument_list|,
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
argument_list|)
expr_stmt|;
name|if_settransmitfn
argument_list|(
name|ifp
argument_list|,
name|nicvf_if_transmit
argument_list|)
expr_stmt|;
name|if_setqflushfn
argument_list|(
name|ifp
argument_list|,
name|nicvf_if_qflush
argument_list|)
expr_stmt|;
name|if_setioctlfn
argument_list|(
name|ifp
argument_list|,
name|nicvf_if_ioctl
argument_list|)
expr_stmt|;
name|if_setinitfn
argument_list|(
name|ifp
argument_list|,
name|nicvf_if_init
argument_list|)
expr_stmt|;
name|if_setgetcounterfn
argument_list|(
name|ifp
argument_list|,
name|nicvf_if_getcounter
argument_list|)
expr_stmt|;
name|if_setmtu
argument_list|(
name|ifp
argument_list|,
name|ETHERMTU
argument_list|)
expr_stmt|;
comment|/* Reset caps */
name|if_setcapabilities
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the default values */
name|if_setcapabilitiesbit
argument_list|(
name|ifp
argument_list|,
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_JUMBO_MTU
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_setcapabilitiesbit
argument_list|(
name|ifp
argument_list|,
name|IFCAP_LRO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|hw_tso
condition|)
block|{
comment|/* TSO */
name|if_setcapabilitiesbit
argument_list|(
name|ifp
argument_list|,
name|IFCAP_TSO4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* TSO parameters */
name|if_sethwtsomax
argument_list|(
name|ifp
argument_list|,
name|NICVF_TSO_MAXSIZE
argument_list|)
expr_stmt|;
name|if_sethwtsomaxsegcount
argument_list|(
name|ifp
argument_list|,
name|NICVF_TSO_NSEGS
argument_list|)
expr_stmt|;
name|if_sethwtsomaxsegsize
argument_list|(
name|ifp
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
block|}
comment|/* IP/TCP/UDP HW checksums */
name|if_setcapabilitiesbit
argument_list|(
name|ifp
argument_list|,
name|IFCAP_HWCSUM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_setcapabilitiesbit
argument_list|(
name|ifp
argument_list|,
name|IFCAP_HWSTATS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * HW offload enable 	 */
name|if_clearhwassist
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
operator|(
name|CSUM_IP
operator||
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_SCTP
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|hw_tso
condition|)
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
operator|(
name|CSUM_TSO
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_setcapenable
argument_list|(
name|ifp
argument_list|,
name|if_getcapabilities
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_setup_ifmedia
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|ifmedia_init
argument_list|(
operator|&
name|nic
operator|->
name|if_media
argument_list|,
name|IFM_IMASK
argument_list|,
name|nicvf_media_change
argument_list|,
name|nicvf_media_status
argument_list|)
expr_stmt|;
comment|/* 	 * Advertise availability of all possible connection types, 	 * even though not all are possible at the same time. 	 */
name|ifmedia_add
argument_list|(
operator|&
name|nic
operator|->
name|if_media
argument_list|,
operator|(
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_FDX
operator|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|nic
operator|->
name|if_media
argument_list|,
operator|(
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
operator|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|nic
operator|->
name|if_media
argument_list|,
operator|(
name|IFM_ETHER
operator||
name|IFM_1000_T
operator||
name|IFM_FDX
operator|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|nic
operator|->
name|if_media
argument_list|,
operator|(
name|IFM_ETHER
operator||
name|IFM_10G_SR
operator||
name|IFM_FDX
operator|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|nic
operator|->
name|if_media
argument_list|,
operator|(
name|IFM_ETHER
operator||
name|IFM_40G_CR4
operator||
name|IFM_FDX
operator|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|nic
operator|->
name|if_media
argument_list|,
operator|(
name|IFM_ETHER
operator||
name|IFM_AUTO
operator||
name|IFM_FDX
operator|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|nic
operator|->
name|if_media
argument_list|,
operator|(
name|IFM_ETHER
operator||
name|IFM_AUTO
operator||
name|IFM_FDX
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_if_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
decl_stmt|;
name|struct
name|rcv_queue
modifier|*
name|rq
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|err
decl_stmt|;
name|int
name|rq_idx
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|boolean_t
name|avoid_reset
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
name|nic
operator|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|ifa
operator|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
expr_stmt|;
endif|#
directive|endif
name|err
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
comment|/* Avoid reinitialization unless it's necessary */
if|if
condition|(
name|avoid_reset
condition|)
block|{
name|if_setflagbits
argument_list|(
name|ifp
argument_list|,
name|IFF_UP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|nicvf_if_init
argument_list|(
name|nic
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|!
operator|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_NOARP
operator|)
condition|)
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
name|err
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|<
name|NIC_HW_MIN_FRS
operator|||
name|ifr
operator|->
name|ifr_mtu
operator|>
name|NIC_HW_MAX_FRS
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|NICVF_CORE_LOCK
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|err
operator|=
name|nicvf_update_hw_max_frs
argument_list|(
name|nic
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|if_setmtu
argument_list|(
name|ifp
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
name|NICVF_CORE_UNLOCK
argument_list|(
name|nic
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|NICVF_CORE_LOCK
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|flags
operator|=
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|^
name|nic
operator|->
name|if_flags
expr_stmt|;
if|if
condition|(
operator|(
name|nic
operator|->
name|if_flags
operator|&
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|)
operator|&
name|IFF_PROMISC
condition|)
block|{
comment|/* Change promiscous mode */
if|#
directive|if
literal|0
comment|/* ARM64TODO */
block|nicvf_set_promiscous(nic);
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|nic
operator|->
name|if_flags
operator|^
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|)
operator|&
name|IFF_ALLMULTI
condition|)
block|{
comment|/* Change multicasting settings */
if|#
directive|if
literal|0
comment|/* ARM64TODO */
block|nicvf_set_multicast(nic);
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|nicvf_if_init_locked
argument_list|(
name|nic
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
name|nicvf_stop_locked
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|nic
operator|->
name|if_flags
operator|=
name|if_getflags
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|NICVF_CORE_UNLOCK
argument_list|(
name|nic
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
if|#
directive|if
literal|0
block|NICVF_CORE_LOCK(nic);
comment|/* ARM64TODO */
block|nicvf_set_multicast(nic); 			NICVF_CORE_UNLOCK(nic);
endif|#
directive|endif
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|err
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|nic
operator|->
name|if_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|mask
operator|=
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|^
name|ifr
operator|->
name|ifr_reqcap
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_MTU
condition|)
block|{
comment|/* No work to do except acknowledge the change took. */
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_VLAN_MTU
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_TXCSUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_RXCSUM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_TSO4
operator|)
operator|&&
name|nic
operator|->
name|hw_tso
condition|)
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_TSO4
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
block|{
comment|/* 			 * Lock the driver for a moment to avoid 			 * mismatch in per-queue settings. 			 */
name|NICVF_CORE_LOCK
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_LRO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|if_getdrvflags
argument_list|(
name|nic
operator|->
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Now disable LRO for subsequent packets. 				 * Atomicity of this change is not necessary 				 * as we don't need precise toggle of this 				 * feature for all threads processing the 				 * completion queue. 				 */
for|for
control|(
name|rq_idx
operator|=
literal|0
init|;
name|rq_idx
operator|<
name|nic
operator|->
name|qs
operator|->
name|rq_cnt
condition|;
name|rq_idx
operator|++
control|)
block|{
name|rq
operator|=
operator|&
name|nic
operator|->
name|qs
operator|->
name|rq
index|[
name|rq_idx
index|]
expr_stmt|;
name|rq
operator|->
name|lro_enabled
operator|=
operator|!
name|rq
operator|->
name|lro_enabled
expr_stmt|;
block|}
block|}
name|NICVF_CORE_UNLOCK
argument_list|(
name|nic
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|err
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_if_init_locked
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|struct
name|queue_set
modifier|*
name|qs
init|=
name|nic
operator|->
name|qs
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|qidx
decl_stmt|;
name|int
name|err
decl_stmt|;
name|caddr_t
name|if_addr
decl_stmt|;
name|NICVF_CORE_LOCK_ASSERT
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|nic
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
name|nicvf_stop_locked
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|err
operator|=
name|nicvf_enable_misc_interrupt
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Could not reenable Mbox interrupt\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get the latest MAC address */
name|if_addr
operator|=
name|if_getlladdr
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Update MAC address if changed */
if|if
condition|(
name|memcmp
argument_list|(
name|nic
operator|->
name|hwaddr
argument_list|,
name|if_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|nic
operator|->
name|hwaddr
argument_list|,
name|if_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|nicvf_hw_set_mac_addr
argument_list|(
name|nic
argument_list|,
name|if_addr
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the queues */
name|err
operator|=
name|nicvf_init_resources
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* Make sure queue initialization is written */
name|wmb
argument_list|()
expr_stmt|;
name|nicvf_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_VF_INT
argument_list|,
operator|~
literal|0UL
argument_list|)
expr_stmt|;
comment|/* Enable Qset err interrupt */
name|nicvf_enable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_QS_ERR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable completion queue interrupt */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|cq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_enable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_CQ
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
comment|/* Enable RBDR threshold interrupt */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|rbdr_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_enable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_RBDR
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|nic
operator|->
name|drv_stats
operator|.
name|txq_stop
operator|=
literal|0
expr_stmt|;
name|nic
operator|->
name|drv_stats
operator|.
name|txq_wake
operator|=
literal|0
expr_stmt|;
comment|/* Activate network interface */
name|if_setdrvflagbits
argument_list|(
name|ifp
argument_list|,
name|IFF_DRV_RUNNING
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
comment|/* Schedule callout to update stats */
name|callout_reset
argument_list|(
operator|&
name|nic
operator|->
name|stats_callout
argument_list|,
name|hz
argument_list|,
name|nicvf_tick_stats
argument_list|,
name|nic
argument_list|)
expr_stmt|;
return|return;
name|error
label|:
comment|/* Something went very wrong. Disable this ifnet for good */
name|if_setdrvflagbits
argument_list|(
name|ifp
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|,
name|IFF_DRV_RUNNING
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_if_init
parameter_list|(
name|void
modifier|*
name|if_softc
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
init|=
name|if_softc
decl_stmt|;
name|NICVF_CORE_LOCK
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|nicvf_if_init_locked
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|NICVF_CORE_UNLOCK
argument_list|(
name|nic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_if_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
init|=
name|nic
operator|->
name|qs
decl_stmt|;
name|struct
name|snd_queue
modifier|*
name|sq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mtmp
decl_stmt|;
name|int
name|qidx
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|qs
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"%s: missing queue set for %s"
argument_list|,
name|__func__
argument_list|,
name|device_get_nameunit
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Select queue */
if|if
condition|(
name|M_HASHTYPE_GET
argument_list|(
name|mbuf
argument_list|)
operator|!=
name|M_HASHTYPE_NONE
condition|)
name|qidx
operator|=
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|%
name|qs
operator|->
name|sq_cnt
expr_stmt|;
else|else
name|qidx
operator|=
name|curcpu
operator|%
name|qs
operator|->
name|sq_cnt
expr_stmt|;
name|sq
operator|=
operator|&
name|qs
operator|->
name|sq
index|[
name|qidx
index|]
expr_stmt|;
if|if
condition|(
name|mbuf
operator|->
name|m_next
operator|!=
name|NULL
operator|&&
operator|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_IP
operator||
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_SCTP
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|M_WRITABLE
argument_list|(
name|mbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mtmp
operator|=
name|m_dup
argument_list|(
name|mbuf
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtmp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|mbuf
operator|=
name|mtmp
expr_stmt|;
block|}
block|}
name|err
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|sq
operator|->
name|br
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
operator|)
operator|||
operator|!
name|nic
operator|->
name|link_up
operator|||
operator|(
name|err
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Try to enqueue packet to the ring buffer. 		 * If the driver is not active, link down or enqueue operation 		 * failed, return with the appropriate error code. 		 */
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|NICVF_TX_TRYLOCK
argument_list|(
name|sq
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|nicvf_xmit_locked
argument_list|(
name|sq
argument_list|)
expr_stmt|;
name|NICVF_TX_UNLOCK
argument_list|(
name|sq
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
else|else
name|taskqueue_enqueue
argument_list|(
name|sq
operator|->
name|snd_taskq
argument_list|,
operator|&
name|sq
operator|->
name|snd_task
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_if_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
decl_stmt|;
name|struct
name|snd_queue
modifier|*
name|sq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|nic
operator|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|qs
operator|=
name|nic
operator|->
name|qs
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|qs
operator|->
name|sq_cnt
condition|;
name|idx
operator|++
control|)
block|{
name|sq
operator|=
operator|&
name|qs
operator|->
name|sq
index|[
name|idx
index|]
expr_stmt|;
name|NICVF_TX_LOCK
argument_list|(
name|sq
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|mbuf
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|sq
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
name|NICVF_TX_UNLOCK
argument_list|(
name|sq
argument_list|)
expr_stmt|;
block|}
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|nicvf_if_getcounter
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|ift_counter
name|cnt
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
decl_stmt|;
name|struct
name|nicvf_hw_stats
modifier|*
name|hw_stats
decl_stmt|;
name|struct
name|nicvf_drv_stats
modifier|*
name|drv_stats
decl_stmt|;
name|nic
operator|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|hw_stats
operator|=
operator|&
name|nic
operator|->
name|hw_stats
expr_stmt|;
name|drv_stats
operator|=
operator|&
name|nic
operator|->
name|drv_stats
expr_stmt|;
switch|switch
condition|(
name|cnt
condition|)
block|{
case|case
name|IFCOUNTER_IPACKETS
case|:
return|return
operator|(
name|drv_stats
operator|->
name|rx_frames_ok
operator|)
return|;
case|case
name|IFCOUNTER_OPACKETS
case|:
return|return
operator|(
name|drv_stats
operator|->
name|tx_frames_ok
operator|)
return|;
case|case
name|IFCOUNTER_IBYTES
case|:
return|return
operator|(
name|hw_stats
operator|->
name|rx_bytes
operator|)
return|;
case|case
name|IFCOUNTER_OBYTES
case|:
return|return
operator|(
name|hw_stats
operator|->
name|tx_bytes_ok
operator|)
return|;
case|case
name|IFCOUNTER_IMCASTS
case|:
return|return
operator|(
name|hw_stats
operator|->
name|rx_mcast_frames
operator|)
return|;
case|case
name|IFCOUNTER_COLLISIONS
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|IFCOUNTER_IQDROPS
case|:
return|return
operator|(
name|drv_stats
operator|->
name|rx_drops
operator|)
return|;
case|case
name|IFCOUNTER_OQDROPS
case|:
return|return
operator|(
name|drv_stats
operator|->
name|tx_drops
operator|)
return|;
default|default:
return|return
operator|(
name|if_get_counter_default
argument_list|(
name|ifp
argument_list|,
name|cnt
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|NICVF_CORE_LOCK
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|link_up
condition|)
block|{
comment|/* Device attached to working network */
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
block|}
switch|switch
condition|(
name|nic
operator|->
name|speed
condition|)
block|{
case|case
name|SPEED_10
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10_T
expr_stmt|;
break|break;
case|case
name|SPEED_100
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_TX
expr_stmt|;
break|break;
case|case
name|SPEED_1000
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_T
expr_stmt|;
break|break;
case|case
name|SPEED_10000
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_SR
expr_stmt|;
break|break;
case|case
name|SPEED_40000
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_40G_CR4
expr_stmt|;
break|break;
default|default:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_AUTO
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nic
operator|->
name|duplex
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
else|else
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_HDX
expr_stmt|;
name|NICVF_CORE_UNLOCK
argument_list|(
name|nic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
name|__unused
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Register read/write APIs */
end_comment

begin_function
name|void
name|nicvf_reg_write
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|bus_space_handle_t
name|offset
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|bus_write_8
argument_list|(
name|nic
operator|->
name|reg_base
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|nicvf_reg_read
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
return|return
operator|(
name|bus_read_8
argument_list|(
name|nic
operator|->
name|reg_base
argument_list|,
name|offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nicvf_queue_reg_write
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|bus_space_handle_t
name|offset
parameter_list|,
name|uint64_t
name|qidx
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|bus_write_8
argument_list|(
name|nic
operator|->
name|reg_base
argument_list|,
name|offset
operator|+
operator|(
name|qidx
operator|<<
name|NIC_Q_NUM_SHIFT
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|nicvf_queue_reg_read
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|bus_space_handle_t
name|offset
parameter_list|,
name|uint64_t
name|qidx
parameter_list|)
block|{
return|return
operator|(
name|bus_read_8
argument_list|(
name|nic
operator|->
name|reg_base
argument_list|,
name|offset
operator|+
operator|(
name|qidx
operator|<<
name|NIC_Q_NUM_SHIFT
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* VF -> PF mailbox communication */
end_comment

begin_function
specifier|static
name|void
name|nicvf_write_to_mbx
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|union
name|nic_mbx
modifier|*
name|mbx
parameter_list|)
block|{
name|uint64_t
modifier|*
name|msg
init|=
operator|(
name|uint64_t
operator|*
operator|)
name|mbx
decl_stmt|;
name|nicvf_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_VF_PF_MAILBOX_0_1
operator|+
literal|0
argument_list|,
name|msg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|nicvf_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_VF_PF_MAILBOX_0_1
operator|+
literal|8
argument_list|,
name|msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|nicvf_send_msg_to_pf
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|union
name|nic_mbx
modifier|*
name|mbx
parameter_list|)
block|{
name|int
name|timeout
init|=
name|NIC_MBOX_MSG_TIMEOUT
operator|*
literal|10
decl_stmt|;
name|int
name|sleep
init|=
literal|2
decl_stmt|;
name|NICVF_CORE_LOCK_ASSERT
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|nic
operator|->
name|pf_acked
operator|=
name|FALSE
expr_stmt|;
name|nic
operator|->
name|pf_nacked
operator|=
name|FALSE
expr_stmt|;
name|nicvf_write_to_mbx
argument_list|(
name|nic
argument_list|,
name|mbx
argument_list|)
expr_stmt|;
comment|/* Wait for previous message to be acked, timeout 2sec */
while|while
condition|(
operator|!
name|nic
operator|->
name|pf_acked
condition|)
block|{
if|if
condition|(
name|nic
operator|->
name|pf_nacked
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|DELAY
argument_list|(
name|sleep
operator|*
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|pf_acked
condition|)
break|break;
name|timeout
operator|-=
name|sleep
expr_stmt|;
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"PF didn't ack to mbox msg %d from VF%d\n"
argument_list|,
operator|(
name|mbx
operator|->
name|msg
operator|.
name|msg
operator|&
literal|0xFF
operator|)
argument_list|,
name|nic
operator|->
name|vf_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Checks if VF is able to comminicate with PF  * and also gets the VNIC number this VF is associated to.  */
end_comment

begin_function
specifier|static
name|int
name|nicvf_check_pf_ready
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|msg
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_READY
expr_stmt|;
if|if
condition|(
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"PF didn't respond to READY msg\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_read_bgx_stats
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|struct
name|bgx_stats_msg
modifier|*
name|bgx
parameter_list|)
block|{
if|if
condition|(
name|bgx
operator|->
name|rx
condition|)
name|nic
operator|->
name|bgx_stats
operator|.
name|rx_stats
index|[
name|bgx
operator|->
name|idx
index|]
operator|=
name|bgx
operator|->
name|stats
expr_stmt|;
else|else
name|nic
operator|->
name|bgx_stats
operator|.
name|tx_stats
index|[
name|bgx
operator|->
name|idx
index|]
operator|=
name|bgx
operator|->
name|stats
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_handle_mbx_intr
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|uint64_t
modifier|*
name|mbx_data
decl_stmt|;
name|uint64_t
name|mbx_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mbx_addr
operator|=
name|NIC_VF_PF_MAILBOX_0_1
expr_stmt|;
name|mbx_data
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|mbx
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NIC_PF_VF_MAILBOX_SIZE
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|mbx_data
operator|=
name|nicvf_reg_read
argument_list|(
name|nic
argument_list|,
name|mbx_addr
argument_list|)
expr_stmt|;
name|mbx_data
operator|++
expr_stmt|;
name|mbx_addr
operator|+=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|mbx
operator|.
name|msg
operator|.
name|msg
condition|)
block|{
case|case
name|NIC_MBOX_MSG_READY
case|:
name|nic
operator|->
name|pf_acked
operator|=
name|TRUE
expr_stmt|;
name|nic
operator|->
name|vf_id
operator|=
name|mbx
operator|.
name|nic_cfg
operator|.
name|vf_id
operator|&
literal|0x7F
expr_stmt|;
name|nic
operator|->
name|tns_mode
operator|=
name|mbx
operator|.
name|nic_cfg
operator|.
name|tns_mode
operator|&
literal|0x7F
expr_stmt|;
name|nic
operator|->
name|node
operator|=
name|mbx
operator|.
name|nic_cfg
operator|.
name|node_id
expr_stmt|;
name|memcpy
argument_list|(
name|nic
operator|->
name|hwaddr
argument_list|,
name|mbx
operator|.
name|nic_cfg
operator|.
name|mac_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|nic
operator|->
name|loopback_supported
operator|=
name|mbx
operator|.
name|nic_cfg
operator|.
name|loopback_supported
expr_stmt|;
name|nic
operator|->
name|link_up
operator|=
name|FALSE
expr_stmt|;
name|nic
operator|->
name|duplex
operator|=
literal|0
expr_stmt|;
name|nic
operator|->
name|speed
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_ACK
case|:
name|nic
operator|->
name|pf_acked
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_NACK
case|:
name|nic
operator|->
name|pf_nacked
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_RSS_SIZE
case|:
name|nic
operator|->
name|rss_info
operator|.
name|rss_size
operator|=
name|mbx
operator|.
name|rss_size
operator|.
name|ind_tbl_size
expr_stmt|;
name|nic
operator|->
name|pf_acked
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_BGX_STATS
case|:
name|nicvf_read_bgx_stats
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
operator|.
name|bgx_stats
argument_list|)
expr_stmt|;
name|nic
operator|->
name|pf_acked
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_BGX_LINK_CHANGE
case|:
name|nic
operator|->
name|pf_acked
operator|=
name|TRUE
expr_stmt|;
name|nic
operator|->
name|link_up
operator|=
name|mbx
operator|.
name|link_status
operator|.
name|link_up
expr_stmt|;
name|nic
operator|->
name|duplex
operator|=
name|mbx
operator|.
name|link_status
operator|.
name|duplex
expr_stmt|;
name|nic
operator|->
name|speed
operator|=
name|mbx
operator|.
name|link_status
operator|.
name|speed
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|link_up
condition|)
block|{
name|if_setbaudrate
argument_list|(
name|nic
operator|->
name|ifp
argument_list|,
name|nic
operator|->
name|speed
operator|*
literal|1000000
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|nic
operator|->
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|if_setbaudrate
argument_list|(
name|nic
operator|->
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|nic
operator|->
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Invalid message from PF, msg 0x%x\n"
argument_list|,
name|mbx
operator|.
name|msg
operator|.
name|msg
argument_list|)
expr_stmt|;
break|break;
block|}
name|nicvf_clear_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_MBOX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_update_hw_max_frs
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|int
name|mtu
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|frs
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_SET_MAX_FRS
expr_stmt|;
name|mbx
operator|.
name|frs
operator|.
name|max_frs
operator|=
name|mtu
expr_stmt|;
name|mbx
operator|.
name|frs
operator|.
name|vf_id
operator|=
name|nic
operator|->
name|vf_id
expr_stmt|;
return|return
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_hw_set_mac_addr
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|,
name|uint8_t
modifier|*
name|hwaddr
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|mac
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_SET_MAC
expr_stmt|;
name|mbx
operator|.
name|mac
operator|.
name|vf_id
operator|=
name|nic
operator|->
name|vf_id
expr_stmt|;
name|memcpy
argument_list|(
name|mbx
operator|.
name|mac
operator|.
name|mac_addr
argument_list|,
name|hwaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_config_cpi
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|cpi_cfg
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_CPI_CFG
expr_stmt|;
name|mbx
operator|.
name|cpi_cfg
operator|.
name|vf_id
operator|=
name|nic
operator|->
name|vf_id
expr_stmt|;
name|mbx
operator|.
name|cpi_cfg
operator|.
name|cpi_alg
operator|=
name|nic
operator|->
name|cpi_alg
expr_stmt|;
name|mbx
operator|.
name|cpi_cfg
operator|.
name|rq_cnt
operator|=
name|nic
operator|->
name|qs
operator|->
name|rq_cnt
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_get_rss_size
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|rss_size
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_RSS_SIZE
expr_stmt|;
name|mbx
operator|.
name|rss_size
operator|.
name|vf_id
operator|=
name|nic
operator|->
name|vf_id
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_config_rss
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|struct
name|nicvf_rss_info
modifier|*
name|rss
decl_stmt|;
name|int
name|ind_tbl_len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nextq
decl_stmt|;
name|rss
operator|=
operator|&
name|nic
operator|->
name|rss_info
expr_stmt|;
name|ind_tbl_len
operator|=
name|rss
operator|->
name|rss_size
expr_stmt|;
name|nextq
operator|=
literal|0
expr_stmt|;
name|mbx
operator|.
name|rss_cfg
operator|.
name|vf_id
operator|=
name|nic
operator|->
name|vf_id
expr_stmt|;
name|mbx
operator|.
name|rss_cfg
operator|.
name|hash_bits
operator|=
name|rss
operator|->
name|hash_bits
expr_stmt|;
while|while
condition|(
name|ind_tbl_len
operator|!=
literal|0
condition|)
block|{
name|mbx
operator|.
name|rss_cfg
operator|.
name|tbl_offset
operator|=
name|nextq
expr_stmt|;
name|mbx
operator|.
name|rss_cfg
operator|.
name|tbl_len
operator|=
name|MIN
argument_list|(
name|ind_tbl_len
argument_list|,
name|RSS_IND_TBL_LEN_PER_MBX_MSG
argument_list|)
expr_stmt|;
name|mbx
operator|.
name|rss_cfg
operator|.
name|msg
operator|=
name|mbx
operator|.
name|rss_cfg
operator|.
name|tbl_offset
condition|?
name|NIC_MBOX_MSG_RSS_CFG_CONT
else|:
name|NIC_MBOX_MSG_RSS_CFG
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mbx
operator|.
name|rss_cfg
operator|.
name|tbl_len
condition|;
name|i
operator|++
control|)
name|mbx
operator|.
name|rss_cfg
operator|.
name|ind_tbl
index|[
name|i
index|]
operator|=
name|rss
operator|->
name|ind_tbl
index|[
name|nextq
operator|++
index|]
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
name|ind_tbl_len
operator|-=
name|mbx
operator|.
name|rss_cfg
operator|.
name|tbl_len
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_set_rss_key
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|struct
name|nicvf_rss_info
modifier|*
name|rss
decl_stmt|;
name|uint64_t
name|key_addr
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|rss
operator|=
operator|&
name|nic
operator|->
name|rss_info
expr_stmt|;
name|key_addr
operator|=
name|NIC_VNIC_RSS_KEY_0_4
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|RSS_HASH_KEY_SIZE
condition|;
name|idx
operator|++
control|)
block|{
name|nicvf_reg_write
argument_list|(
name|nic
argument_list|,
name|key_addr
argument_list|,
name|rss
operator|->
name|key
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|key_addr
operator|+=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_rss_init
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|struct
name|nicvf_rss_info
modifier|*
name|rss
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|nicvf_get_rss_size
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|rss
operator|=
operator|&
name|nic
operator|->
name|rss_info
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|cpi_alg
operator|!=
name|CPI_ALG_NONE
condition|)
block|{
name|rss
operator|->
name|enable
operator|=
name|FALSE
expr_stmt|;
name|rss
operator|->
name|hash_bits
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rss
operator|->
name|enable
operator|=
name|TRUE
expr_stmt|;
comment|/* Using the HW reset value for now */
name|rss
operator|->
name|key
index|[
literal|0
index|]
operator|=
literal|0xFEED0BADFEED0BADUL
expr_stmt|;
name|rss
operator|->
name|key
index|[
literal|1
index|]
operator|=
literal|0xFEED0BADFEED0BADUL
expr_stmt|;
name|rss
operator|->
name|key
index|[
literal|2
index|]
operator|=
literal|0xFEED0BADFEED0BADUL
expr_stmt|;
name|rss
operator|->
name|key
index|[
literal|3
index|]
operator|=
literal|0xFEED0BADFEED0BADUL
expr_stmt|;
name|rss
operator|->
name|key
index|[
literal|4
index|]
operator|=
literal|0xFEED0BADFEED0BADUL
expr_stmt|;
name|nicvf_set_rss_key
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|rss
operator|->
name|cfg
operator|=
name|RSS_IP_HASH_ENA
operator||
name|RSS_TCP_HASH_ENA
operator||
name|RSS_UDP_HASH_ENA
expr_stmt|;
name|nicvf_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_VNIC_RSS_CFG
argument_list|,
name|rss
operator|->
name|cfg
argument_list|)
expr_stmt|;
name|rss
operator|->
name|hash_bits
operator|=
name|fls
argument_list|(
name|rss
operator|->
name|rss_size
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|rss
operator|->
name|rss_size
condition|;
name|idx
operator|++
control|)
name|rss
operator|->
name|ind_tbl
index|[
name|idx
index|]
operator|=
name|idx
operator|%
name|nic
operator|->
name|rx_queues
expr_stmt|;
name|nicvf_config_rss
argument_list|(
name|nic
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_init_resources
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|msg
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_CFG_DONE
expr_stmt|;
comment|/* Enable Qset */
name|nicvf_qset_config
argument_list|(
name|nic
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Initialize queues and HW for data transfer */
name|err
operator|=
name|nicvf_config_data_transfer
argument_list|(
name|nic
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Failed to alloc/config VF's QSet resources\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* Send VF config done msg to PF */
name|nicvf_write_to_mbx
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_misc_intr_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
init|=
operator|(
expr|struct
name|nicvf
operator|*
operator|)
name|arg
decl_stmt|;
name|uint64_t
name|intr
decl_stmt|;
name|intr
operator|=
name|nicvf_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_VF_INT
argument_list|)
expr_stmt|;
comment|/* Check for spurious interrupt */
if|if
condition|(
operator|!
operator|(
name|intr
operator|&
name|NICVF_INTR_MBOX_MASK
operator|)
condition|)
return|return;
name|nicvf_handle_mbx_intr
argument_list|(
name|nic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_intr_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
decl_stmt|;
name|struct
name|cmp_queue
modifier|*
name|cq
decl_stmt|;
name|int
name|qidx
decl_stmt|;
name|cq
operator|=
operator|(
expr|struct
name|cmp_queue
operator|*
operator|)
name|arg
expr_stmt|;
name|nic
operator|=
name|cq
operator|->
name|nic
expr_stmt|;
name|qidx
operator|=
name|cq
operator|->
name|idx
expr_stmt|;
comment|/* Disable interrupts */
name|nicvf_disable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_CQ
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|cq
operator|->
name|cmp_taskq
argument_list|,
operator|&
name|cq
operator|->
name|cmp_task
argument_list|)
expr_stmt|;
comment|/* Clear interrupt */
name|nicvf_clear_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_CQ
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_rbdr_intr_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
decl_stmt|;
name|struct
name|rbdr
modifier|*
name|rbdr
decl_stmt|;
name|int
name|qidx
decl_stmt|;
name|nic
operator|=
operator|(
expr|struct
name|nicvf
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* Disable RBDR interrupt and schedule softirq */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|nic
operator|->
name|qs
operator|->
name|rbdr_cnt
condition|;
name|qidx
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|nicvf_is_intr_enabled
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_RBDR
argument_list|,
name|qidx
argument_list|)
condition|)
continue|continue;
name|nicvf_disable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_RBDR
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|qs
operator|=
name|nic
operator|->
name|qs
expr_stmt|;
name|rbdr
operator|=
operator|&
name|qs
operator|->
name|rbdr
index|[
name|qidx
index|]
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|rbdr
operator|->
name|rbdr_taskq
argument_list|,
operator|&
name|rbdr
operator|->
name|rbdr_task_nowait
argument_list|)
expr_stmt|;
comment|/* Clear interrupt */
name|nicvf_clear_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_RBDR
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_qs_err_intr_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
init|=
operator|(
expr|struct
name|nicvf
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
init|=
name|nic
operator|->
name|qs
decl_stmt|;
comment|/* Disable Qset err interrupt and schedule softirq */
name|nicvf_disable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_QS_ERR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|qs
operator|->
name|qs_err_taskq
argument_list|,
operator|&
name|qs
operator|->
name|qs_err_task
argument_list|)
expr_stmt|;
name|nicvf_clear_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_QS_ERR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_enable_msix
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|count
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
expr_stmt|;
name|rid
operator|=
name|dinfo
operator|->
name|cfg
operator|.
name|msix
operator|.
name|msix_table_bar
expr_stmt|;
name|nic
operator|->
name|msix_table_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|msix_table_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Could not allocate memory for MSI-X table\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|count
operator|=
name|nic
operator|->
name|num_vec
operator|=
name|NIC_VF_MSIX_VECTORS
expr_stmt|;
name|ret
operator|=
name|pci_alloc_msix
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|!=
literal|0
operator|)
operator|||
operator|(
name|count
operator|!=
name|nic
operator|->
name|num_vec
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Request for #%d msix vectors failed, error: %d\n"
argument_list|,
name|nic
operator|->
name|num_vec
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|nic
operator|->
name|msix_enabled
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_disable_msix
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
if|if
condition|(
name|nic
operator|->
name|msix_enabled
condition|)
block|{
name|pci_release_msi
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
expr_stmt|;
name|nic
operator|->
name|msix_enabled
operator|=
literal|0
expr_stmt|;
name|nic
operator|->
name|num_vec
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_release_all_interrupts
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* Free registered interrupts */
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
name|nic
operator|->
name|num_vec
condition|;
name|irq
operator|++
control|)
block|{
name|res
operator|=
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Teardown interrupt first */
if|if
condition|(
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|handle
operator|!=
name|NULL
condition|)
block|{
name|err
operator|=
name|bus_teardown_intr
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
argument_list|,
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|handle
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|,
operator|(
literal|"ERROR: Unable to teardown interrupt %d"
operator|,
name|irq
operator|)
argument_list|)
expr_stmt|;
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|handle
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_release_resource
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rman_get_rid
argument_list|(
name|res
argument_list|)
argument_list|,
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
argument_list|)
expr_stmt|;
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Disable MSI-X */
name|nicvf_disable_msix
argument_list|(
name|nic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize MSIX vectors and register MISC interrupt.  * Send READY message to PF to check if its alive  */
end_comment

begin_function
specifier|static
name|int
name|nicvf_allocate_misc_interrupt
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|irq
decl_stmt|,
name|rid
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* Return if mailbox interrupt is already registered */
if|if
condition|(
name|nic
operator|->
name|msix_enabled
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Enable MSI-X */
if|if
condition|(
name|nicvf_enable_msix
argument_list|(
name|nic
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|irq
operator|=
name|NICVF_INTR_ID_MISC
expr_stmt|;
name|rid
operator|=
name|irq
operator|+
literal|1
expr_stmt|;
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
operator|(
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Could not allocate Mbox interrupt for VF%d\n"
argument_list|,
name|device_get_unit
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ret
operator|=
name|bus_setup_intr
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
argument_list|,
operator|(
name|INTR_MPSAFE
operator||
name|INTR_TYPE_MISC
operator|)
argument_list|,
name|NULL
argument_list|,
name|nicvf_misc_intr_handler
argument_list|,
name|nic
argument_list|,
operator|&
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|res
operator|=
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
expr_stmt|;
name|bus_release_resource
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rman_get_rid
argument_list|(
name|res
argument_list|)
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_enable_misc_interrupt
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
comment|/* Enable mailbox interrupt */
name|nicvf_enable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_MBOX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check if VF is able to communicate with PF */
if|if
condition|(
operator|!
name|nicvf_check_pf_ready
argument_list|(
name|nic
argument_list|)
condition|)
block|{
name|nicvf_disable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_MBOX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_release_net_interrupts
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|int
name|err
decl_stmt|;
name|for_each_cq_irq
argument_list|(
argument|irq
argument_list|)
block|{
name|res
operator|=
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Teardown active interrupts first */
if|if
condition|(
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|handle
operator|!=
name|NULL
condition|)
block|{
name|err
operator|=
name|bus_teardown_intr
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
argument_list|,
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|handle
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|,
operator|(
literal|"ERROR: Unable to teardown CQ interrupt %d"
operator|,
operator|(
name|irq
operator|-
name|NICVF_INTR_ID_CQ
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
continue|continue;
block|}
comment|/* Release resource */
name|bus_release_resource
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rman_get_rid
argument_list|(
name|res
argument_list|)
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
operator|=
name|NULL
expr_stmt|;
block|}
name|for_each_rbdr_irq
argument_list|(
argument|irq
argument_list|)
block|{
name|res
operator|=
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Teardown active interrupts first */
if|if
condition|(
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|handle
operator|!=
name|NULL
condition|)
block|{
name|err
operator|=
name|bus_teardown_intr
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
argument_list|,
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|handle
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|,
operator|(
literal|"ERROR: Unable to teardown RDBR interrupt %d"
operator|,
operator|(
name|irq
operator|-
name|NICVF_INTR_ID_RBDR
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
continue|continue;
block|}
comment|/* Release resource */
name|bus_release_resource
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rman_get_rid
argument_list|(
name|res
argument_list|)
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
operator|=
name|NULL
expr_stmt|;
block|}
name|irq
operator|=
name|NICVF_INTR_ID_QS_ERR
expr_stmt|;
name|res
operator|=
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
block|{
comment|/* Teardown active interrupts first */
if|if
condition|(
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|handle
operator|!=
name|NULL
condition|)
block|{
name|err
operator|=
name|bus_teardown_intr
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
argument_list|,
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|handle
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|,
operator|(
literal|"ERROR: Unable to teardown QS Error interrupt %d"
operator|,
name|irq
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return;
block|}
comment|/* Release resource */
name|bus_release_resource
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rman_get_rid
argument_list|(
name|res
argument_list|)
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_allocate_net_interrupts
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|u_int
name|cpuid
decl_stmt|;
name|int
name|irq
decl_stmt|,
name|rid
decl_stmt|;
name|int
name|qidx
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* MSI-X must be configured by now */
if|if
condition|(
operator|!
name|nic
operator|->
name|msix_enabled
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Cannot alloacte queue interrups. "
literal|"MSI-X interrupts disabled.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Register CQ interrupts */
name|for_each_cq_irq
argument_list|(
argument|irq
argument_list|)
block|{
if|if
condition|(
name|irq
operator|>=
operator|(
name|NICVF_INTR_ID_CQ
operator|+
name|nic
operator|->
name|qs
operator|->
name|cq_cnt
operator|)
condition|)
break|break;
name|qidx
operator|=
name|irq
operator|-
name|NICVF_INTR_ID_CQ
expr_stmt|;
name|rid
operator|=
name|irq
operator|+
literal|1
expr_stmt|;
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
operator|(
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Could not allocate CQ interrupt %d for VF%d\n"
argument_list|,
operator|(
name|irq
operator|-
name|NICVF_INTR_ID_CQ
operator|)
argument_list|,
name|device_get_unit
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ret
operator|=
name|bus_setup_intr
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
argument_list|,
operator|(
name|INTR_MPSAFE
operator||
name|INTR_TYPE_NET
operator|)
argument_list|,
name|nicvf_intr_handler
argument_list|,
name|NULL
argument_list|,
operator|&
name|nic
operator|->
name|qs
operator|->
name|cq
index|[
name|qidx
index|]
argument_list|,
operator|&
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Could not setup CQ interrupt %d for VF%d\n"
argument_list|,
operator|(
name|irq
operator|-
name|NICVF_INTR_ID_CQ
operator|)
argument_list|,
name|device_get_unit
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|cpuid
operator|=
operator|(
name|device_get_unit
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
operator|*
name|CMP_QUEUE_CNT
operator|)
operator|+
name|qidx
expr_stmt|;
name|cpuid
operator|%=
name|mp_ncpus
expr_stmt|;
comment|/* 		 * Save CPU ID for later use when system-wide RSS is enabled. 		 * It will be used to pit the CQ task to the same CPU that got 		 * interrupted. 		 */
name|nic
operator|->
name|qs
operator|->
name|cq
index|[
name|qidx
index|]
operator|.
name|cmp_cpuid
operator|=
name|cpuid
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"bind CQ%d IRQ to CPU%d\n"
argument_list|,
name|qidx
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
block|}
comment|/* Bind interrupts to the given CPU */
name|bus_bind_intr
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
block|}
comment|/* Register RBDR interrupt */
name|for_each_rbdr_irq
argument_list|(
argument|irq
argument_list|)
block|{
if|if
condition|(
name|irq
operator|>=
operator|(
name|NICVF_INTR_ID_RBDR
operator|+
name|nic
operator|->
name|qs
operator|->
name|rbdr_cnt
operator|)
condition|)
break|break;
name|rid
operator|=
name|irq
operator|+
literal|1
expr_stmt|;
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
operator|(
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Could not allocate RBDR interrupt %d for VF%d\n"
argument_list|,
operator|(
name|irq
operator|-
name|NICVF_INTR_ID_RBDR
operator|)
argument_list|,
name|device_get_unit
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ret
operator|=
name|bus_setup_intr
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
argument_list|,
operator|(
name|INTR_MPSAFE
operator||
name|INTR_TYPE_NET
operator|)
argument_list|,
name|NULL
argument_list|,
name|nicvf_rbdr_intr_handler
argument_list|,
name|nic
argument_list|,
operator|&
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Could not setup RBDR interrupt %d for VF%d\n"
argument_list|,
operator|(
name|irq
operator|-
name|NICVF_INTR_ID_RBDR
operator|)
argument_list|,
name|device_get_unit
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
comment|/* Register QS error interrupt */
name|irq
operator|=
name|NICVF_INTR_ID_QS_ERR
expr_stmt|;
name|rid
operator|=
name|irq
operator|+
literal|1
expr_stmt|;
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
operator|(
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Could not allocate QS Error interrupt for VF%d\n"
argument_list|,
name|device_get_unit
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ret
operator|=
name|bus_setup_intr
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
argument_list|,
operator|(
name|INTR_MPSAFE
operator||
name|INTR_TYPE_NET
operator|)
argument_list|,
name|NULL
argument_list|,
name|nicvf_qs_err_intr_handler
argument_list|,
name|nic
argument_list|,
operator|&
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Could not setup QS Error interrupt for VF%d\n"
argument_list|,
name|device_get_unit
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|nicvf_release_net_interrupts
argument_list|(
name|nic
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicvf_stop_locked
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|qidx
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
init|=
name|nic
operator|->
name|qs
decl_stmt|;
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|NICVF_CORE_LOCK_ASSERT
argument_list|(
name|nic
argument_list|)
expr_stmt|;
comment|/* Stop callout. Can block here since holding SX lock */
name|callout_drain
argument_list|(
operator|&
name|nic
operator|->
name|stats_callout
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|nic
operator|->
name|ifp
expr_stmt|;
name|mbx
operator|.
name|msg
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_SHUTDOWN
expr_stmt|;
name|nicvf_send_msg_to_pf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
comment|/* Disable RBDR& QS error interrupts */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|rbdr_cnt
condition|;
name|qidx
operator|++
control|)
block|{
name|nicvf_disable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_RBDR
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
name|nicvf_clear_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_RBDR
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
block|}
name|nicvf_disable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_QS_ERR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nicvf_clear_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_QS_ERR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Deactivate network interface */
name|if_setdrvflagbits
argument_list|(
name|ifp
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|,
name|IFF_DRV_RUNNING
argument_list|)
expr_stmt|;
comment|/* Free resources */
name|nicvf_config_data_transfer
argument_list|(
name|nic
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Disable HW Qset */
name|nicvf_qset_config
argument_list|(
name|nic
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* disable mailbox interrupt */
name|nicvf_disable_intr
argument_list|(
name|nic
argument_list|,
name|NICVF_INTR_MBOX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_update_stats
parameter_list|(
name|struct
name|nicvf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|qidx
decl_stmt|;
name|struct
name|nicvf_hw_stats
modifier|*
name|stats
init|=
operator|&
name|nic
operator|->
name|hw_stats
decl_stmt|;
name|struct
name|nicvf_drv_stats
modifier|*
name|drv_stats
init|=
operator|&
name|nic
operator|->
name|drv_stats
decl_stmt|;
name|struct
name|queue_set
modifier|*
name|qs
init|=
name|nic
operator|->
name|qs
decl_stmt|;
define|#
directive|define
name|GET_RX_STATS
parameter_list|(
name|reg
parameter_list|)
define|\
value|nicvf_reg_read(nic, NIC_VNIC_RX_STAT_0_13 | ((reg)<< 3))
define|#
directive|define
name|GET_TX_STATS
parameter_list|(
name|reg
parameter_list|)
define|\
value|nicvf_reg_read(nic, NIC_VNIC_TX_STAT_0_4 | ((reg)<< 3))
name|stats
operator|->
name|rx_bytes
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_OCTS
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_ucast_frames
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_UCAST
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_bcast_frames
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_BCAST
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_mcast_frames
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_MCAST
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_fcs_errors
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_FCS
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_l2_errors
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_L2ERR
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_drop_red
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_RED
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_drop_red_bytes
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_RED_OCTS
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_drop_overrun
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_ORUN
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_drop_overrun_bytes
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_ORUN_OCTS
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_drop_bcast
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_DRP_BCAST
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_drop_mcast
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_DRP_MCAST
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_drop_l3_bcast
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_DRP_L3BCAST
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rx_drop_l3_mcast
operator|=
name|GET_RX_STATS
argument_list|(
name|RX_DRP_L3MCAST
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_bytes_ok
operator|=
name|GET_TX_STATS
argument_list|(
name|TX_OCTS
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_ucast_frames_ok
operator|=
name|GET_TX_STATS
argument_list|(
name|TX_UCAST
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_bcast_frames_ok
operator|=
name|GET_TX_STATS
argument_list|(
name|TX_BCAST
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_mcast_frames_ok
operator|=
name|GET_TX_STATS
argument_list|(
name|TX_MCAST
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_drops
operator|=
name|GET_TX_STATS
argument_list|(
name|TX_DROP
argument_list|)
expr_stmt|;
name|drv_stats
operator|->
name|tx_frames_ok
operator|=
name|stats
operator|->
name|tx_ucast_frames_ok
operator|+
name|stats
operator|->
name|tx_bcast_frames_ok
operator|+
name|stats
operator|->
name|tx_mcast_frames_ok
expr_stmt|;
name|drv_stats
operator|->
name|rx_drops
operator|=
name|stats
operator|->
name|rx_drop_red
operator|+
name|stats
operator|->
name|rx_drop_overrun
expr_stmt|;
name|drv_stats
operator|->
name|tx_drops
operator|=
name|stats
operator|->
name|tx_drops
expr_stmt|;
comment|/* Update RQ and SQ stats */
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|rq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_update_rq_stats
argument_list|(
name|nic
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
for|for
control|(
name|qidx
operator|=
literal|0
init|;
name|qidx
operator|<
name|qs
operator|->
name|sq_cnt
condition|;
name|qidx
operator|++
control|)
name|nicvf_update_sq_stats
argument_list|(
name|nic
argument_list|,
name|qidx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicvf_tick_stats
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nicvf
modifier|*
name|nic
decl_stmt|;
name|nic
operator|=
operator|(
expr|struct
name|nicvf
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* Read the statistics */
name|nicvf_update_stats
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|nic
operator|->
name|stats_callout
argument_list|,
name|hz
argument_list|,
name|nicvf_tick_stats
argument_list|,
name|nic
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

