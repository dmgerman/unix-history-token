begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2015 Cavium Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bitset.h>
end_include

begin_include
include|#
directive|include
file|<sys/bitstring.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/_inttypes.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnv.h>
end_include

begin_include
include|#
directive|include
file|<sys/nv.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PCI_IOV
end_ifdef

begin_include
include|#
directive|include
file|<sys/iov_schema.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_iov.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"thunder_bgx.h"
end_include

begin_include
include|#
directive|include
file|"nic_reg.h"
end_include

begin_include
include|#
directive|include
file|"nic.h"
end_include

begin_include
include|#
directive|include
file|"q_struct.h"
end_include

begin_define
define|#
directive|define
name|VNIC_PF_DEVSTR
value|"Cavium Thunder NIC Physical Function Driver"
end_define

begin_define
define|#
directive|define
name|VNIC_PF_REG_RID
value|PCIR_BAR(PCI_CFG_REG_BAR_NUM)
end_define

begin_define
define|#
directive|define
name|NIC_SET_VF_LMAC_MAP
parameter_list|(
name|bgx
parameter_list|,
name|lmac
parameter_list|)
value|((((bgx)& 0xF)<< 4) | ((lmac)& 0xF))
end_define

begin_define
define|#
directive|define
name|NIC_GET_BGX_FROM_VF_LMAC_MAP
parameter_list|(
name|map
parameter_list|)
value|(((map)>> 4)& 0xF)
end_define

begin_define
define|#
directive|define
name|NIC_GET_LMAC_FROM_VF_LMAC_MAP
parameter_list|(
name|map
parameter_list|)
value|((map)& 0xF)
end_define

begin_comment
comment|/* Structure to be used by the SR-IOV for VF configuration schemas */
end_comment

begin_struct
struct|struct
name|nicvf_info
block|{
name|boolean_t
name|vf_enabled
decl_stmt|;
name|int
name|vf_flags
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|nicpf
block|{
name|device_t
name|dev
decl_stmt|;
name|uint8_t
name|rev_id
decl_stmt|;
name|uint8_t
name|node
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
name|uint8_t
name|num_vf_en
decl_stmt|;
comment|/* No of VF enabled */
name|struct
name|nicvf_info
name|vf_info
index|[
name|MAX_NUM_VFS_SUPPORTED
index|]
decl_stmt|;
name|struct
name|resource
modifier|*
name|reg_base
decl_stmt|;
comment|/* Register start address */
name|struct
name|pkind_cfg
name|pkind
decl_stmt|;
name|uint8_t
name|vf_lmac_map
index|[
name|MAX_LMAC
index|]
decl_stmt|;
name|boolean_t
name|mbx_lock
index|[
name|MAX_NUM_VFS_SUPPORTED
index|]
decl_stmt|;
name|struct
name|callout
name|check_link
decl_stmt|;
name|struct
name|mtx
name|check_link_mtx
decl_stmt|;
name|uint8_t
name|link
index|[
name|MAX_LMAC
index|]
decl_stmt|;
name|uint8_t
name|duplex
index|[
name|MAX_LMAC
index|]
decl_stmt|;
name|uint32_t
name|speed
index|[
name|MAX_LMAC
index|]
decl_stmt|;
name|uint16_t
name|cpi_base
index|[
name|MAX_NUM_VFS_SUPPORTED
index|]
decl_stmt|;
name|uint16_t
name|rss_ind_tbl_size
decl_stmt|;
comment|/* MSI-X */
name|boolean_t
name|msix_enabled
decl_stmt|;
name|uint8_t
name|num_vec
decl_stmt|;
name|struct
name|msix_entry
name|msix_entries
index|[
name|NIC_PF_MSIX_VECTORS
index|]
decl_stmt|;
name|struct
name|resource
modifier|*
name|msix_table_res
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|nicpf_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicpf_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicpf_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|PCI_IOV
end_ifdef

begin_function_decl
specifier|static
name|int
name|nicpf_iov_init
parameter_list|(
name|device_t
parameter_list|,
name|uint16_t
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nicpf_iov_uninit
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nicpf_iov_addr_vf
parameter_list|(
name|device_t
parameter_list|,
name|uint16_t
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|device_method_t
name|nicpf_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|nicpf_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|nicpf_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|nicpf_detach
argument_list|)
block|,
comment|/* PCI SR-IOV interface */
ifdef|#
directive|ifdef
name|PCI_IOV
name|DEVMETHOD
argument_list|(
name|pci_iov_init
argument_list|,
name|nicpf_iov_init
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_iov_uninit
argument_list|,
name|nicpf_iov_uninit
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_iov_add_vf
argument_list|,
name|nicpf_iov_addr_vf
argument_list|)
block|,
endif|#
directive|endif
name|DEVMETHOD_END
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|nicpf_driver
init|=
block|{
literal|"vnicpf"
block|,
name|nicpf_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|nicpf
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|nicpf_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|nicpf
argument_list|,
name|pci
argument_list|,
name|nicpf_driver
argument_list|,
name|nicpf_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nicpf
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nicpf
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nicpf
argument_list|,
name|thunder_bgx
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|nicpf_alloc_res
parameter_list|(
name|struct
name|nicpf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nicpf_free_res
parameter_list|(
name|struct
name|nicpf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nic_set_lmac_vf_mapping
parameter_list|(
name|struct
name|nicpf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nic_init_hw
parameter_list|(
name|struct
name|nicpf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nic_sriov_init
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|nicpf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nic_poll_for_link
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nic_register_interrupts
parameter_list|(
name|struct
name|nicpf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nic_unregister_interrupts
parameter_list|(
name|struct
name|nicpf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Device interface  */
end_comment

begin_function
specifier|static
name|int
name|nicpf_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|uint16_t
name|vendor_id
decl_stmt|;
name|uint16_t
name|device_id
decl_stmt|;
name|vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|vendor_id
operator|==
name|PCI_VENDOR_ID_CAVIUM
operator|&&
name|device_id
operator|==
name|PCI_DEVICE_ID_THUNDER_NIC_PF
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|VNIC_PF_DEVSTR
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicpf_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|nicpf
modifier|*
name|nic
decl_stmt|;
name|int
name|err
decl_stmt|;
name|nic
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|nic
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/* Enable bus mastering */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Allocate PCI resources */
name|err
operator|=
name|nicpf_alloc_res
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate PCI resources\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|nic
operator|->
name|node
operator|=
name|nic_get_node_id
argument_list|(
name|nic
operator|->
name|reg_base
argument_list|)
expr_stmt|;
name|nic
operator|->
name|rev_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Enable Traffic Network Switch (TNS) bypass mode by default */
name|nic
operator|->
name|flags
operator|&=
operator|~
name|NIC_TNS_ENABLED
expr_stmt|;
name|nic_set_lmac_vf_mapping
argument_list|(
name|nic
argument_list|)
expr_stmt|;
comment|/* Initialize hardware */
name|nic_init_hw
argument_list|(
name|nic
argument_list|)
expr_stmt|;
comment|/* Set RSS TBL size for each VF */
name|nic
operator|->
name|rss_ind_tbl_size
operator|=
name|NIC_MAX_RSS_IDR_TBL_SIZE
expr_stmt|;
comment|/* Setup interrupts */
name|err
operator|=
name|nic_register_interrupts
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|err_free_res
goto|;
comment|/* Configure SRIOV */
name|err
operator|=
name|nic_sriov_init
argument_list|(
name|dev
argument_list|,
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|err_free_intr
goto|;
if|if
condition|(
name|nic
operator|->
name|flags
operator|&
name|NIC_TNS_ENABLED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mtx_init
argument_list|(
operator|&
name|nic
operator|->
name|check_link_mtx
argument_list|,
literal|"VNIC PF link poll"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Register physical link status poll callout */
name|callout_init_mtx
argument_list|(
operator|&
name|nic
operator|->
name|check_link
argument_list|,
operator|&
name|nic
operator|->
name|check_link_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nic
operator|->
name|check_link_mtx
argument_list|)
expr_stmt|;
name|nic_poll_for_link
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nic
operator|->
name|check_link_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_free_intr
label|:
name|nic_unregister_interrupts
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|err_free_res
label|:
name|nicpf_free_res
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|pci_disable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nicpf_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|nicpf
modifier|*
name|nic
decl_stmt|;
name|nic
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|nic
operator|->
name|check_link
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|nic
operator|->
name|check_link_mtx
argument_list|)
expr_stmt|;
name|nic_unregister_interrupts
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|nicpf_free_res
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|pci_disable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SR-IOV interface  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PCI_IOV
end_ifdef

begin_function
specifier|static
name|int
name|nicpf_iov_init
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint16_t
name|num_vfs
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|nicpf
modifier|*
name|nic
decl_stmt|;
name|nic
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|nic
operator|->
name|num_vf_en
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|num_vfs
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|num_vfs
operator|>
name|MAX_NUM_VFS_SUPPORTED
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Just set variables here. 	 * The number of VFs will be written to configuration 	 * space later in PCI_ADD_VF(). 	 */
name|nic
operator|->
name|num_vf_en
operator|=
name|num_vfs
expr_stmt|;
name|nic
operator|->
name|flags
operator||=
name|NIC_SRIOV_ENABLED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicpf_iov_uninit
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* ARM64TODO: Implement this function */
block|}
end_function

begin_function
specifier|static
name|int
name|nicpf_iov_addr_vf
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint16_t
name|vfnum
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
name|params
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|mac
decl_stmt|;
name|struct
name|nicpf
modifier|*
name|nic
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|bgx
decl_stmt|,
name|lmac
decl_stmt|;
name|nic
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nic
operator|->
name|flags
operator|&
name|NIC_SRIOV_ENABLED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|nvlist_exists_binary
argument_list|(
name|params
argument_list|,
literal|"mac-addr"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mac
operator|=
name|nvlist_get_binary
argument_list|(
name|params
argument_list|,
literal|"mac-addr"
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|bgx
operator|=
name|NIC_GET_BGX_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|vfnum
index|]
argument_list|)
expr_stmt|;
name|lmac
operator|=
name|NIC_GET_LMAC_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|vfnum
index|]
argument_list|)
expr_stmt|;
name|bgx_set_lmac_mac
argument_list|(
name|nic
operator|->
name|node
argument_list|,
name|bgx
argument_list|,
name|lmac
argument_list|,
name|mac
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Helper routines  */
end_comment

begin_function
specifier|static
name|int
name|nicpf_alloc_res
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|dev
operator|=
name|nic
operator|->
name|dev
expr_stmt|;
name|rid
operator|=
name|VNIC_PF_REG_RID
expr_stmt|;
name|nic
operator|->
name|reg_base
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|reg_base
operator|==
name|NULL
condition|)
block|{
comment|/* For verbose output print some more details */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate registers memory\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nicpf_free_res
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|dev
operator|=
name|nic
operator|->
name|dev
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|reg_base
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rman_get_rid
argument_list|(
name|nic
operator|->
name|reg_base
argument_list|)
argument_list|,
name|nic
operator|->
name|reg_base
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Register read/write APIs */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|nic_reg_write
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|bus_space_handle_t
name|offset
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|bus_write_8
argument_list|(
name|nic
operator|->
name|reg_base
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint64_t
name|nic_reg_read
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|bus_read_8
argument_list|(
name|nic
operator|->
name|reg_base
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* PF -> VF mailbox communication APIs */
end_comment

begin_function
specifier|static
name|void
name|nic_enable_mbx_intr
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
comment|/* Enable mailbox interrupt for all 128 VFs */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_MAILBOX_ENA_W1S
argument_list|,
operator|~
literal|0UL
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_MAILBOX_ENA_W1S
operator|+
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|~
literal|0UL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nic_clear_mbx_intr
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|vf
parameter_list|,
name|int
name|mbx_reg
parameter_list|)
block|{
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_MAILBOX_INT
operator|+
operator|(
name|mbx_reg
operator|<<
literal|3
operator|)
argument_list|,
operator|(
literal|1UL
operator|<<
name|vf
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|nic_get_mbx_addr
parameter_list|(
name|int
name|vf
parameter_list|)
block|{
return|return
operator|(
name|NIC_PF_VF_0_127_MAILBOX_0_1
operator|+
operator|(
name|vf
operator|<<
name|NIC_VF_NUM_SHIFT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a mailbox message to VF  * @vf: vf to which this message to be sent  * @mbx: Message to be sent  */
end_comment

begin_function
specifier|static
name|void
name|nic_send_msg_to_vf
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|vf
parameter_list|,
name|union
name|nic_mbx
modifier|*
name|mbx
parameter_list|)
block|{
name|bus_space_handle_t
name|mbx_addr
init|=
name|nic_get_mbx_addr
argument_list|(
name|vf
argument_list|)
decl_stmt|;
name|uint64_t
modifier|*
name|msg
init|=
operator|(
name|uint64_t
operator|*
operator|)
name|mbx
decl_stmt|;
comment|/* 	 * In first revision HW, mbox interrupt is triggerred 	 * when PF writes to MBOX(1), in next revisions when 	 * PF writes to MBOX(0) 	 */
if|if
condition|(
name|nic
operator|->
name|rev_id
operator|==
literal|0
condition|)
block|{
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|mbx_addr
operator|+
literal|0
argument_list|,
name|msg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|mbx_addr
operator|+
literal|8
argument_list|,
name|msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|mbx_addr
operator|+
literal|8
argument_list|,
name|msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|mbx_addr
operator|+
literal|0
argument_list|,
name|msg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Responds to VF's READY message with VF's  * ID, node, MAC address e.t.c  * @vf: VF which sent READY message  */
end_comment

begin_function
specifier|static
name|void
name|nic_mbx_send_ready
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|vf
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|int
name|bgx_idx
decl_stmt|,
name|lmac
decl_stmt|;
specifier|const
name|char
modifier|*
name|mac
decl_stmt|;
name|mbx
operator|.
name|nic_cfg
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_READY
expr_stmt|;
name|mbx
operator|.
name|nic_cfg
operator|.
name|vf_id
operator|=
name|vf
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|flags
operator|&
name|NIC_TNS_ENABLED
condition|)
name|mbx
operator|.
name|nic_cfg
operator|.
name|tns_mode
operator|=
name|NIC_TNS_MODE
expr_stmt|;
else|else
name|mbx
operator|.
name|nic_cfg
operator|.
name|tns_mode
operator|=
name|NIC_TNS_BYPASS_MODE
expr_stmt|;
if|if
condition|(
name|vf
operator|<
name|MAX_LMAC
condition|)
block|{
name|bgx_idx
operator|=
name|NIC_GET_BGX_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|vf
index|]
argument_list|)
expr_stmt|;
name|lmac
operator|=
name|NIC_GET_LMAC_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|vf
index|]
argument_list|)
expr_stmt|;
name|mac
operator|=
name|bgx_get_lmac_mac
argument_list|(
name|nic
operator|->
name|node
argument_list|,
name|bgx_idx
argument_list|,
name|lmac
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|mbx
operator|.
name|nic_cfg
operator|.
name|mac_addr
argument_list|,
name|mac
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
block|}
name|mbx
operator|.
name|nic_cfg
operator|.
name|node_id
operator|=
name|nic
operator|->
name|node
expr_stmt|;
name|mbx
operator|.
name|nic_cfg
operator|.
name|loopback_supported
operator|=
name|vf
operator|<
name|MAX_LMAC
expr_stmt|;
name|nic_send_msg_to_vf
argument_list|(
name|nic
argument_list|,
name|vf
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ACKs VF's mailbox message  * @vf: VF to which ACK to be sent  */
end_comment

begin_function
specifier|static
name|void
name|nic_mbx_send_ack
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|vf
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|msg
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_ACK
expr_stmt|;
name|nic_send_msg_to_vf
argument_list|(
name|nic
argument_list|,
name|vf
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * NACKs VF's mailbox message that PF is not able to  * complete the action  * @vf: VF to which ACK to be sent  */
end_comment

begin_function
specifier|static
name|void
name|nic_mbx_send_nack
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|vf
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|msg
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_NACK
expr_stmt|;
name|nic_send_msg_to_vf
argument_list|(
name|nic
argument_list|,
name|vf
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush all in flight receive packets to memory and  * bring down an active RQ  */
end_comment

begin_function
specifier|static
name|int
name|nic_rcv_queue_sw_sync
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
name|uint16_t
name|timeout
init|=
operator|~
literal|0x00
decl_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_SW_SYNC_RX
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Wait till sync cycle is finished */
while|while
condition|(
name|timeout
condition|)
block|{
if|if
condition|(
name|nic_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_PF_SW_SYNC_RX_DONE
argument_list|)
operator|&
literal|0x1
condition|)
break|break;
name|timeout
operator|--
expr_stmt|;
block|}
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_SW_SYNC_RX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Receive queue software sync failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get BGX Rx/Tx stats and respond to VF's request */
end_comment

begin_function
specifier|static
name|void
name|nic_get_bgx_stats
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|struct
name|bgx_stats_msg
modifier|*
name|bgx
parameter_list|)
block|{
name|int
name|bgx_idx
decl_stmt|,
name|lmac
decl_stmt|;
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|bgx_idx
operator|=
name|NIC_GET_BGX_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|bgx
operator|->
name|vf_id
index|]
argument_list|)
expr_stmt|;
name|lmac
operator|=
name|NIC_GET_LMAC_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|bgx
operator|->
name|vf_id
index|]
argument_list|)
expr_stmt|;
name|mbx
operator|.
name|bgx_stats
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_BGX_STATS
expr_stmt|;
name|mbx
operator|.
name|bgx_stats
operator|.
name|vf_id
operator|=
name|bgx
operator|->
name|vf_id
expr_stmt|;
name|mbx
operator|.
name|bgx_stats
operator|.
name|rx
operator|=
name|bgx
operator|->
name|rx
expr_stmt|;
name|mbx
operator|.
name|bgx_stats
operator|.
name|idx
operator|=
name|bgx
operator|->
name|idx
expr_stmt|;
if|if
condition|(
name|bgx
operator|->
name|rx
operator|!=
literal|0
condition|)
block|{
name|mbx
operator|.
name|bgx_stats
operator|.
name|stats
operator|=
name|bgx_get_rx_stats
argument_list|(
name|nic
operator|->
name|node
argument_list|,
name|bgx_idx
argument_list|,
name|lmac
argument_list|,
name|bgx
operator|->
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mbx
operator|.
name|bgx_stats
operator|.
name|stats
operator|=
name|bgx_get_tx_stats
argument_list|(
name|nic
operator|->
name|node
argument_list|,
name|bgx_idx
argument_list|,
name|lmac
argument_list|,
name|bgx
operator|->
name|idx
argument_list|)
expr_stmt|;
block|}
name|nic_send_msg_to_vf
argument_list|(
name|nic
argument_list|,
name|bgx
operator|->
name|vf_id
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update hardware min/max frame size */
end_comment

begin_function
specifier|static
name|int
name|nic_update_hw_frs
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|new_frs
parameter_list|,
name|int
name|vf
parameter_list|)
block|{
if|if
condition|(
operator|(
name|new_frs
operator|>
name|NIC_HW_MAX_FRS
operator|)
operator|||
operator|(
name|new_frs
operator|<
name|NIC_HW_MIN_FRS
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Invalid MTU setting from VF%d rejected, "
literal|"should be between %d and %d\n"
argument_list|,
name|vf
argument_list|,
name|NIC_HW_MIN_FRS
argument_list|,
name|NIC_HW_MAX_FRS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|new_frs
operator|+=
name|ETHER_HDR_LEN
expr_stmt|;
if|if
condition|(
name|new_frs
operator|<=
name|nic
operator|->
name|pkind
operator|.
name|maxlen
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nic
operator|->
name|pkind
operator|.
name|maxlen
operator|=
name|new_frs
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_PKIND_0_15_CFG
argument_list|,
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|nic
operator|->
name|pkind
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set minimum transmit packet size */
end_comment

begin_function
specifier|static
name|void
name|nic_set_tx_pkt_pad
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|lmac
decl_stmt|;
name|uint64_t
name|lmac_cfg
decl_stmt|;
comment|/* Max value that can be set is 60 */
if|if
condition|(
name|size
operator|>
literal|60
condition|)
name|size
operator|=
literal|60
expr_stmt|;
for|for
control|(
name|lmac
operator|=
literal|0
init|;
name|lmac
operator|<
operator|(
name|MAX_BGX_PER_CN88XX
operator|*
name|MAX_LMAC_PER_BGX
operator|)
condition|;
name|lmac
operator|++
control|)
block|{
name|lmac_cfg
operator|=
name|nic_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_PF_LMAC_0_7_CFG
operator||
operator|(
name|lmac
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|lmac_cfg
operator|&=
operator|~
operator|(
literal|0xF
operator|<<
literal|2
operator|)
expr_stmt|;
name|lmac_cfg
operator||=
operator|(
operator|(
name|size
operator|/
literal|4
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_LMAC_0_7_CFG
operator||
operator|(
name|lmac
operator|<<
literal|3
operator|)
argument_list|,
name|lmac_cfg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Function to check number of LMACs present and set VF::LMAC mapping.  * Mapping will be used while initializing channels.  */
end_comment

begin_function
specifier|static
name|void
name|nic_set_lmac_vf_mapping
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
name|unsigned
name|bgx_map
init|=
name|bgx_get_map
argument_list|(
name|nic
operator|->
name|node
argument_list|)
decl_stmt|;
name|int
name|bgx
decl_stmt|,
name|next_bgx_lmac
init|=
literal|0
decl_stmt|;
name|int
name|lmac
decl_stmt|,
name|lmac_cnt
init|=
literal|0
decl_stmt|;
name|uint64_t
name|lmac_credit
decl_stmt|;
name|nic
operator|->
name|num_vf_en
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|flags
operator|&
name|NIC_TNS_ENABLED
condition|)
block|{
name|nic
operator|->
name|num_vf_en
operator|=
name|DEFAULT_NUM_VF_ENABLED
expr_stmt|;
return|return;
block|}
for|for
control|(
name|bgx
operator|=
literal|0
init|;
name|bgx
operator|<
name|NIC_MAX_BGX
condition|;
name|bgx
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bgx_map
operator|&
operator|(
literal|1
operator|<<
name|bgx
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|lmac_cnt
operator|=
name|bgx_get_lmac_count
argument_list|(
name|nic
operator|->
name|node
argument_list|,
name|bgx
argument_list|)
expr_stmt|;
for|for
control|(
name|lmac
operator|=
literal|0
init|;
name|lmac
operator|<
name|lmac_cnt
condition|;
name|lmac
operator|++
control|)
name|nic
operator|->
name|vf_lmac_map
index|[
name|next_bgx_lmac
operator|++
index|]
operator|=
name|NIC_SET_VF_LMAC_MAP
argument_list|(
name|bgx
argument_list|,
name|lmac
argument_list|)
expr_stmt|;
name|nic
operator|->
name|num_vf_en
operator|+=
name|lmac_cnt
expr_stmt|;
comment|/* Program LMAC credits */
name|lmac_credit
operator|=
operator|(
literal|1UL
operator|<<
literal|1
operator|)
expr_stmt|;
comment|/* channel credit enable */
name|lmac_credit
operator||=
operator|(
literal|0x1ff
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* Max outstanding pkt count */
comment|/* 48KB BGX Tx buffer size, each unit is of size 16bytes */
name|lmac_credit
operator||=
operator|(
operator|(
operator|(
operator|(
operator|(
literal|48
operator|*
literal|1024
operator|)
operator|/
name|lmac_cnt
operator|)
operator|-
name|NIC_HW_MAX_FRS
operator|)
operator|/
literal|16
operator|)
operator|<<
literal|12
operator|)
expr_stmt|;
name|lmac
operator|=
name|bgx
operator|*
name|MAX_LMAC_PER_BGX
expr_stmt|;
for|for
control|(
init|;
name|lmac
operator|<
name|lmac_cnt
operator|+
operator|(
name|bgx
operator|*
name|MAX_LMAC_PER_BGX
operator|)
condition|;
name|lmac
operator|++
control|)
block|{
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_LMAC_0_7_CREDIT
operator|+
operator|(
name|lmac
operator|*
literal|8
operator|)
argument_list|,
name|lmac_credit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|TNS_PORT0_BLOCK
value|6
end_define

begin_define
define|#
directive|define
name|TNS_PORT1_BLOCK
value|7
end_define

begin_define
define|#
directive|define
name|BGX0_BLOCK
value|8
end_define

begin_define
define|#
directive|define
name|BGX1_BLOCK
value|9
end_define

begin_function
specifier|static
name|void
name|nic_init_hw
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Enable NIC HW block */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_CFG
argument_list|,
literal|0x3
argument_list|)
expr_stmt|;
comment|/* Enable backpressure */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_BP_CFG
argument_list|,
operator|(
literal|1UL
operator|<<
literal|6
operator|)
operator||
literal|0x03
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|flags
operator|&
name|NIC_TNS_ENABLED
condition|)
block|{
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_INTF_0_1_SEND_CFG
argument_list|,
operator|(
name|NIC_TNS_MODE
operator|<<
literal|7
operator|)
operator||
name|TNS_PORT0_BLOCK
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_INTF_0_1_SEND_CFG
operator||
operator|(
literal|1
operator|<<
literal|8
operator|)
argument_list|,
operator|(
name|NIC_TNS_MODE
operator|<<
literal|7
operator|)
operator||
name|TNS_PORT1_BLOCK
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_INTF_0_1_BP_CFG
argument_list|,
operator|(
literal|1UL
operator|<<
literal|63
operator|)
operator||
name|TNS_PORT0_BLOCK
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_INTF_0_1_BP_CFG
operator|+
operator|(
literal|1
operator|<<
literal|8
operator|)
argument_list|,
operator|(
literal|1UL
operator|<<
literal|63
operator|)
operator||
name|TNS_PORT1_BLOCK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Disable TNS mode on both interfaces */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_INTF_0_1_SEND_CFG
argument_list|,
operator|(
name|NIC_TNS_BYPASS_MODE
operator|<<
literal|7
operator|)
operator||
name|BGX0_BLOCK
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_INTF_0_1_SEND_CFG
operator||
operator|(
literal|1
operator|<<
literal|8
operator|)
argument_list|,
operator|(
name|NIC_TNS_BYPASS_MODE
operator|<<
literal|7
operator|)
operator||
name|BGX1_BLOCK
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_INTF_0_1_BP_CFG
argument_list|,
operator|(
literal|1UL
operator|<<
literal|63
operator|)
operator||
name|BGX0_BLOCK
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_INTF_0_1_BP_CFG
operator|+
operator|(
literal|1
operator|<<
literal|8
operator|)
argument_list|,
operator|(
literal|1UL
operator|<<
literal|63
operator|)
operator||
name|BGX1_BLOCK
argument_list|)
expr_stmt|;
block|}
comment|/* PKIND configuration */
name|nic
operator|->
name|pkind
operator|.
name|minlen
operator|=
literal|0
expr_stmt|;
name|nic
operator|->
name|pkind
operator|.
name|maxlen
operator|=
name|NIC_HW_MAX_FRS
operator|+
name|ETHER_HDR_LEN
expr_stmt|;
name|nic
operator|->
name|pkind
operator|.
name|lenerr_en
operator|=
literal|1
expr_stmt|;
name|nic
operator|->
name|pkind
operator|.
name|rx_hdr
operator|=
literal|0
expr_stmt|;
name|nic
operator|->
name|pkind
operator|.
name|hdr_sl
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NIC_MAX_PKIND
condition|;
name|i
operator|++
control|)
block|{
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_PKIND_0_15_CFG
operator||
operator|(
name|i
operator|<<
literal|3
operator|)
argument_list|,
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|nic
operator|->
name|pkind
argument_list|)
expr_stmt|;
block|}
name|nic_set_tx_pkt_pad
argument_list|(
name|nic
argument_list|,
name|NIC_HW_MIN_FRS
argument_list|)
expr_stmt|;
comment|/* Timer config */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_INTR_TIMER_CFG
argument_list|,
name|NICPF_CLK_PER_INT_TICK
argument_list|)
expr_stmt|;
comment|/* Enable VLAN ethertype matching and stripping */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_RX_ETYPE_0_7
argument_list|,
operator|(
literal|2
operator|<<
literal|19
operator|)
operator||
operator|(
name|ETYPE_ALG_VLAN_STRIP
operator|<<
literal|16
operator|)
operator||
name|ETHERTYPE_VLAN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Channel parse index configuration */
end_comment

begin_function
specifier|static
name|void
name|nic_config_cpi
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|struct
name|cpi_cfg_msg
modifier|*
name|cfg
parameter_list|)
block|{
name|uint32_t
name|vnic
decl_stmt|,
name|bgx
decl_stmt|,
name|lmac
decl_stmt|,
name|chan
decl_stmt|;
name|uint32_t
name|padd
decl_stmt|,
name|cpi_count
init|=
literal|0
decl_stmt|;
name|uint64_t
name|cpi_base
decl_stmt|,
name|cpi
decl_stmt|,
name|rssi_base
decl_stmt|,
name|rssi
decl_stmt|;
name|uint8_t
name|qset
decl_stmt|,
name|rq_idx
init|=
literal|0
decl_stmt|;
name|vnic
operator|=
name|cfg
operator|->
name|vf_id
expr_stmt|;
name|bgx
operator|=
name|NIC_GET_BGX_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|vnic
index|]
argument_list|)
expr_stmt|;
name|lmac
operator|=
name|NIC_GET_LMAC_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|vnic
index|]
argument_list|)
expr_stmt|;
name|chan
operator|=
operator|(
name|lmac
operator|*
name|MAX_BGX_CHANS_PER_LMAC
operator|)
operator|+
operator|(
name|bgx
operator|*
name|NIC_CHANS_PER_INF
operator|)
expr_stmt|;
name|cpi_base
operator|=
operator|(
name|lmac
operator|*
name|NIC_MAX_CPI_PER_LMAC
operator|)
operator|+
operator|(
name|bgx
operator|*
name|NIC_CPI_PER_BGX
operator|)
expr_stmt|;
name|rssi_base
operator|=
operator|(
name|lmac
operator|*
name|nic
operator|->
name|rss_ind_tbl_size
operator|)
operator|+
operator|(
name|bgx
operator|*
name|NIC_RSSI_PER_BGX
operator|)
expr_stmt|;
comment|/* Rx channel configuration */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_CHAN_0_255_RX_BP_CFG
operator||
operator|(
name|chan
operator|<<
literal|3
operator|)
argument_list|,
operator|(
literal|1UL
operator|<<
literal|63
operator|)
operator||
operator|(
name|vnic
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_CHAN_0_255_RX_CFG
operator||
operator|(
name|chan
operator|<<
literal|3
operator|)
argument_list|,
operator|(
operator|(
name|uint64_t
operator|)
name|cfg
operator|->
name|cpi_alg
operator|<<
literal|62
operator|)
operator||
operator|(
name|cpi_base
operator|<<
literal|48
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|cpi_alg
operator|==
name|CPI_ALG_NONE
condition|)
name|cpi_count
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cfg
operator|->
name|cpi_alg
operator|==
name|CPI_ALG_VLAN
condition|)
comment|/* 3 bits of PCP */
name|cpi_count
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|cfg
operator|->
name|cpi_alg
operator|==
name|CPI_ALG_VLAN16
condition|)
comment|/* 3 bits PCP + DEI */
name|cpi_count
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|cfg
operator|->
name|cpi_alg
operator|==
name|CPI_ALG_DIFF
condition|)
comment|/* 6bits DSCP */
name|cpi_count
operator|=
name|NIC_MAX_CPI_PER_LMAC
expr_stmt|;
comment|/* RSS Qset, Qidx mapping */
name|qset
operator|=
name|cfg
operator|->
name|vf_id
expr_stmt|;
name|rssi
operator|=
name|rssi_base
expr_stmt|;
for|for
control|(
init|;
name|rssi
operator|<
operator|(
name|rssi_base
operator|+
name|cfg
operator|->
name|rq_cnt
operator|)
condition|;
name|rssi
operator|++
control|)
block|{
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_RSSI_0_4097_RQ
operator||
operator|(
name|rssi
operator|<<
literal|3
operator|)
argument_list|,
operator|(
name|qset
operator|<<
literal|3
operator|)
operator||
name|rq_idx
argument_list|)
expr_stmt|;
name|rq_idx
operator|++
expr_stmt|;
block|}
name|rssi
operator|=
literal|0
expr_stmt|;
name|cpi
operator|=
name|cpi_base
expr_stmt|;
for|for
control|(
init|;
name|cpi
operator|<
operator|(
name|cpi_base
operator|+
name|cpi_count
operator|)
condition|;
name|cpi
operator|++
control|)
block|{
comment|/* Determine port to channel adder */
if|if
condition|(
name|cfg
operator|->
name|cpi_alg
operator|!=
name|CPI_ALG_DIFF
condition|)
name|padd
operator|=
name|cpi
operator|%
name|cpi_count
expr_stmt|;
else|else
name|padd
operator|=
name|cpi
operator|%
literal|8
expr_stmt|;
comment|/* 3 bits CS out of 6bits DSCP */
comment|/* Leave RSS_SIZE as '0' to disable RSS */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_CPI_0_2047_CFG
operator||
operator|(
name|cpi
operator|<<
literal|3
operator|)
argument_list|,
operator|(
name|vnic
operator|<<
literal|24
operator|)
operator||
operator|(
name|padd
operator|<<
literal|16
operator|)
operator||
operator|(
name|rssi_base
operator|+
name|rssi
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rssi
operator|+
literal|1
operator|)
operator|>=
name|cfg
operator|->
name|rq_cnt
condition|)
continue|continue;
if|if
condition|(
name|cfg
operator|->
name|cpi_alg
operator|==
name|CPI_ALG_VLAN
condition|)
name|rssi
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|cfg
operator|->
name|cpi_alg
operator|==
name|CPI_ALG_VLAN16
condition|)
name|rssi
operator|=
operator|(
operator|(
name|cpi
operator|-
name|cpi_base
operator|)
operator|&
literal|0xe
operator|)
operator|>>
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cfg
operator|->
name|cpi_alg
operator|==
name|CPI_ALG_DIFF
condition|)
name|rssi
operator|=
operator|(
operator|(
name|cpi
operator|-
name|cpi_base
operator|)
operator|&
literal|0x38
operator|)
operator|>>
literal|3
expr_stmt|;
block|}
name|nic
operator|->
name|cpi_base
index|[
name|cfg
operator|->
name|vf_id
index|]
operator|=
name|cpi_base
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 4 level transmit side scheduler configutation  * for TNS bypass mode  *  * Sample configuration for SQ0  * VNIC0-SQ0 -> TL4(0)   -> TL3[0]   -> TL2[0]  -> TL1[0] -> BGX0  * VNIC1-SQ0 -> TL4(8)   -> TL3[2]   -> TL2[0]  -> TL1[0] -> BGX0  * VNIC2-SQ0 -> TL4(16)  -> TL3[4]   -> TL2[1]  -> TL1[0] -> BGX0  * VNIC3-SQ0 -> TL4(24)  -> TL3[6]   -> TL2[1]  -> TL1[0] -> BGX0  * VNIC4-SQ0 -> TL4(512) -> TL3[128] -> TL2[32] -> TL1[1] -> BGX1  * VNIC5-SQ0 -> TL4(520) -> TL3[130] -> TL2[32] -> TL1[1] -> BGX1  * VNIC6-SQ0 -> TL4(528) -> TL3[132] -> TL2[33] -> TL1[1] -> BGX1  * VNIC7-SQ0 -> TL4(536) -> TL3[134] -> TL2[33] -> TL1[1] -> BGX1  */
end_comment

begin_function
specifier|static
name|void
name|nic_tx_channel_cfg
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|uint8_t
name|vnic
parameter_list|,
name|struct
name|sq_cfg_msg
modifier|*
name|sq
parameter_list|)
block|{
name|uint32_t
name|bgx
decl_stmt|,
name|lmac
decl_stmt|,
name|chan
decl_stmt|;
name|uint32_t
name|tl2
decl_stmt|,
name|tl3
decl_stmt|,
name|tl4
decl_stmt|;
name|uint32_t
name|rr_quantum
decl_stmt|;
name|uint8_t
name|sq_idx
init|=
name|sq
operator|->
name|sq_num
decl_stmt|;
name|uint8_t
name|pqs_vnic
decl_stmt|;
name|pqs_vnic
operator|=
name|vnic
expr_stmt|;
name|bgx
operator|=
name|NIC_GET_BGX_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|pqs_vnic
index|]
argument_list|)
expr_stmt|;
name|lmac
operator|=
name|NIC_GET_LMAC_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|pqs_vnic
index|]
argument_list|)
expr_stmt|;
comment|/* 24 bytes for FCS, IPG and preamble */
name|rr_quantum
operator|=
operator|(
operator|(
name|NIC_HW_MAX_FRS
operator|+
literal|24
operator|)
operator|/
literal|4
operator|)
expr_stmt|;
name|tl4
operator|=
operator|(
name|lmac
operator|*
name|NIC_TL4_PER_LMAC
operator|)
operator|+
operator|(
name|bgx
operator|*
name|NIC_TL4_PER_BGX
operator|)
expr_stmt|;
name|tl4
operator|+=
name|sq_idx
expr_stmt|;
name|tl3
operator|=
name|tl4
operator|/
operator|(
name|NIC_MAX_TL4
operator|/
name|NIC_MAX_TL3
operator|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_QSET_0_127_SQ_0_7_CFG2
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|vnic
operator|<<
name|NIC_QS_ID_SHIFT
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|sq_idx
operator|<<
name|NIC_Q_NUM_SHIFT
operator|)
argument_list|,
name|tl4
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_TL4_0_1023_CFG
operator||
operator|(
name|tl4
operator|<<
literal|3
operator|)
argument_list|,
operator|(
operator|(
name|uint64_t
operator|)
name|vnic
operator|<<
literal|27
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|sq_idx
operator|<<
literal|24
operator|)
operator||
name|rr_quantum
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_TL3_0_255_CFG
operator||
operator|(
name|tl3
operator|<<
literal|3
operator|)
argument_list|,
name|rr_quantum
argument_list|)
expr_stmt|;
name|chan
operator|=
operator|(
name|lmac
operator|*
name|MAX_BGX_CHANS_PER_LMAC
operator|)
operator|+
operator|(
name|bgx
operator|*
name|NIC_CHANS_PER_INF
operator|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_TL3_0_255_CHAN
operator||
operator|(
name|tl3
operator|<<
literal|3
operator|)
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* Enable backpressure on the channel */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_CHAN_0_255_TX_CFG
operator||
operator|(
name|chan
operator|<<
literal|3
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tl2
operator|=
name|tl3
operator|>>
literal|2
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_TL3A_0_63_CFG
operator||
operator|(
name|tl2
operator|<<
literal|3
operator|)
argument_list|,
name|tl2
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_TL2_0_63_CFG
operator||
operator|(
name|tl2
operator|<<
literal|3
operator|)
argument_list|,
name|rr_quantum
argument_list|)
expr_stmt|;
comment|/* No priorities as of now */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_TL2_0_63_PRI
operator||
operator|(
name|tl2
operator|<<
literal|3
operator|)
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nic_config_loopback
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|struct
name|set_loopback
modifier|*
name|lbk
parameter_list|)
block|{
name|int
name|bgx_idx
decl_stmt|,
name|lmac_idx
decl_stmt|;
if|if
condition|(
name|lbk
operator|->
name|vf_id
operator|>
name|MAX_LMAC
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bgx_idx
operator|=
name|NIC_GET_BGX_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|lbk
operator|->
name|vf_id
index|]
argument_list|)
expr_stmt|;
name|lmac_idx
operator|=
name|NIC_GET_LMAC_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|lbk
operator|->
name|vf_id
index|]
argument_list|)
expr_stmt|;
name|bgx_lmac_internal_loopback
argument_list|(
name|nic
operator|->
name|node
argument_list|,
name|bgx_idx
argument_list|,
name|lmac_idx
argument_list|,
name|lbk
operator|->
name|enable
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Interrupt handler to handle mailbox messages from VFs */
end_comment

begin_function
specifier|static
name|void
name|nic_handle_mbx_intr
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|vf
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|uint64_t
modifier|*
name|mbx_data
decl_stmt|;
name|uint64_t
name|mbx_addr
decl_stmt|;
name|uint64_t
name|reg_addr
decl_stmt|;
name|uint64_t
name|cfg
decl_stmt|;
name|int
name|bgx
decl_stmt|,
name|lmac
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|nic
operator|->
name|mbx_lock
index|[
name|vf
index|]
operator|=
name|TRUE
expr_stmt|;
name|mbx_addr
operator|=
name|nic_get_mbx_addr
argument_list|(
name|vf
argument_list|)
expr_stmt|;
name|mbx_data
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|mbx
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NIC_PF_VF_MAILBOX_SIZE
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|mbx_data
operator|=
name|nic_reg_read
argument_list|(
name|nic
argument_list|,
name|mbx_addr
argument_list|)
expr_stmt|;
name|mbx_data
operator|++
expr_stmt|;
name|mbx_addr
operator|+=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|mbx
operator|.
name|msg
operator|.
name|msg
condition|)
block|{
case|case
name|NIC_MBOX_MSG_READY
case|:
name|nic_mbx_send_ready
argument_list|(
name|nic
argument_list|,
name|vf
argument_list|)
expr_stmt|;
if|if
condition|(
name|vf
operator|<
name|MAX_LMAC
condition|)
block|{
name|nic
operator|->
name|link
index|[
name|vf
index|]
operator|=
literal|0
expr_stmt|;
name|nic
operator|->
name|duplex
index|[
name|vf
index|]
operator|=
literal|0
expr_stmt|;
name|nic
operator|->
name|speed
index|[
name|vf
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_QS_CFG
case|:
name|reg_addr
operator|=
name|NIC_PF_QSET_0_127_CFG
operator||
operator|(
name|mbx
operator|.
name|qs
operator|.
name|num
operator|<<
name|NIC_QS_ID_SHIFT
operator|)
expr_stmt|;
name|cfg
operator|=
name|mbx
operator|.
name|qs
operator|.
name|cfg
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|reg_addr
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_RQ_CFG
case|:
name|reg_addr
operator|=
name|NIC_PF_QSET_0_127_RQ_0_7_CFG
operator||
operator|(
name|mbx
operator|.
name|rq
operator|.
name|qs_num
operator|<<
name|NIC_QS_ID_SHIFT
operator|)
operator||
operator|(
name|mbx
operator|.
name|rq
operator|.
name|rq_num
operator|<<
name|NIC_Q_NUM_SHIFT
operator|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|reg_addr
argument_list|,
name|mbx
operator|.
name|rq
operator|.
name|cfg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_RQ_BP_CFG
case|:
name|reg_addr
operator|=
name|NIC_PF_QSET_0_127_RQ_0_7_BP_CFG
operator||
operator|(
name|mbx
operator|.
name|rq
operator|.
name|qs_num
operator|<<
name|NIC_QS_ID_SHIFT
operator|)
operator||
operator|(
name|mbx
operator|.
name|rq
operator|.
name|rq_num
operator|<<
name|NIC_Q_NUM_SHIFT
operator|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|reg_addr
argument_list|,
name|mbx
operator|.
name|rq
operator|.
name|cfg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_RQ_SW_SYNC
case|:
name|ret
operator|=
name|nic_rcv_queue_sw_sync
argument_list|(
name|nic
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_RQ_DROP_CFG
case|:
name|reg_addr
operator|=
name|NIC_PF_QSET_0_127_RQ_0_7_DROP_CFG
operator||
operator|(
name|mbx
operator|.
name|rq
operator|.
name|qs_num
operator|<<
name|NIC_QS_ID_SHIFT
operator|)
operator||
operator|(
name|mbx
operator|.
name|rq
operator|.
name|rq_num
operator|<<
name|NIC_Q_NUM_SHIFT
operator|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|reg_addr
argument_list|,
name|mbx
operator|.
name|rq
operator|.
name|cfg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_SQ_CFG
case|:
name|reg_addr
operator|=
name|NIC_PF_QSET_0_127_SQ_0_7_CFG
operator||
operator|(
name|mbx
operator|.
name|sq
operator|.
name|qs_num
operator|<<
name|NIC_QS_ID_SHIFT
operator|)
operator||
operator|(
name|mbx
operator|.
name|sq
operator|.
name|sq_num
operator|<<
name|NIC_Q_NUM_SHIFT
operator|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|reg_addr
argument_list|,
name|mbx
operator|.
name|sq
operator|.
name|cfg
argument_list|)
expr_stmt|;
name|nic_tx_channel_cfg
argument_list|(
name|nic
argument_list|,
name|mbx
operator|.
name|qs
operator|.
name|num
argument_list|,
operator|&
name|mbx
operator|.
name|sq
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_SET_MAC
case|:
name|lmac
operator|=
name|mbx
operator|.
name|mac
operator|.
name|vf_id
expr_stmt|;
name|bgx
operator|=
name|NIC_GET_BGX_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|lmac
index|]
argument_list|)
expr_stmt|;
name|lmac
operator|=
name|NIC_GET_LMAC_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|lmac
index|]
argument_list|)
expr_stmt|;
name|bgx_set_lmac_mac
argument_list|(
name|nic
operator|->
name|node
argument_list|,
name|bgx
argument_list|,
name|lmac
argument_list|,
name|mbx
operator|.
name|mac
operator|.
name|mac_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_SET_MAX_FRS
case|:
name|ret
operator|=
name|nic_update_hw_frs
argument_list|(
name|nic
argument_list|,
name|mbx
operator|.
name|frs
operator|.
name|max_frs
argument_list|,
name|mbx
operator|.
name|frs
operator|.
name|vf_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_CPI_CFG
case|:
name|nic_config_cpi
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
operator|.
name|cpi_cfg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_CFG_DONE
case|:
comment|/* Last message of VF config msg sequence */
name|nic
operator|->
name|vf_info
index|[
name|vf
index|]
operator|.
name|vf_enabled
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|unlock
goto|;
case|case
name|NIC_MBOX_MSG_SHUTDOWN
case|:
comment|/* First msg in VF teardown sequence */
name|nic
operator|->
name|vf_info
index|[
name|vf
index|]
operator|.
name|vf_enabled
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_BGX_STATS
case|:
name|nic_get_bgx_stats
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
operator|.
name|bgx_stats
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
case|case
name|NIC_MBOX_MSG_LOOPBACK
case|:
name|ret
operator|=
name|nic_config_loopback
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
operator|.
name|lbk
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Invalid msg from VF%d, msg 0x%x\n"
argument_list|,
name|vf
argument_list|,
name|mbx
operator|.
name|msg
operator|.
name|msg
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|nic_mbx_send_ack
argument_list|(
name|nic
argument_list|,
name|vf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mbx
operator|.
name|msg
operator|.
name|msg
operator|!=
name|NIC_MBOX_MSG_READY
condition|)
name|nic_mbx_send_nack
argument_list|(
name|nic
argument_list|,
name|vf
argument_list|)
expr_stmt|;
name|unlock
label|:
name|nic
operator|->
name|mbx_lock
index|[
name|vf
index|]
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nic_mbx_intr_handler
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|mbx
parameter_list|)
block|{
name|uint64_t
name|intr
decl_stmt|;
name|uint8_t
name|vf
decl_stmt|,
name|vf_per_mbx_reg
init|=
literal|64
decl_stmt|;
name|intr
operator|=
name|nic_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_PF_MAILBOX_INT
operator|+
operator|(
name|mbx
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|vf
operator|=
literal|0
init|;
name|vf
operator|<
name|vf_per_mbx_reg
condition|;
name|vf
operator|++
control|)
block|{
if|if
condition|(
name|intr
operator|&
operator|(
literal|1UL
operator|<<
name|vf
operator|)
condition|)
block|{
name|nic_handle_mbx_intr
argument_list|(
name|nic
argument_list|,
name|vf
operator|+
operator|(
name|mbx
operator|*
name|vf_per_mbx_reg
operator|)
argument_list|)
expr_stmt|;
name|nic_clear_mbx_intr
argument_list|(
name|nic
argument_list|,
name|vf
argument_list|,
name|mbx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nic_mbx0_intr_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nicpf
modifier|*
name|nic
init|=
operator|(
expr|struct
name|nicpf
operator|*
operator|)
name|arg
decl_stmt|;
name|nic_mbx_intr_handler
argument_list|(
name|nic
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nic_mbx1_intr_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nicpf
modifier|*
name|nic
init|=
operator|(
expr|struct
name|nicpf
operator|*
operator|)
name|arg
decl_stmt|;
name|nic_mbx_intr_handler
argument_list|(
name|nic
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nic_enable_msix
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|count
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
expr_stmt|;
name|rid
operator|=
name|dinfo
operator|->
name|cfg
operator|.
name|msix
operator|.
name|msix_table_bar
expr_stmt|;
name|nic
operator|->
name|msix_table_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|msix_table_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Could not allocate memory for MSI-X table\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|count
operator|=
name|nic
operator|->
name|num_vec
operator|=
name|NIC_PF_MSIX_VECTORS
expr_stmt|;
name|ret
operator|=
name|pci_alloc_msix
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|!=
literal|0
operator|)
operator|||
operator|(
name|count
operator|!=
name|nic
operator|->
name|num_vec
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
literal|"Request for #%d msix vectors failed, error: %d\n"
argument_list|,
name|nic
operator|->
name|num_vec
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|nic
operator|->
name|msix_enabled
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nic_disable_msix
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
if|if
condition|(
name|nic
operator|->
name|msix_enabled
condition|)
block|{
name|pci_release_msi
argument_list|(
name|nic
operator|->
name|dev
argument_list|)
expr_stmt|;
name|nic
operator|->
name|msix_enabled
operator|=
literal|0
expr_stmt|;
name|nic
operator|->
name|num_vec
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nic_free_all_interrupts
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|irq
decl_stmt|;
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
name|nic
operator|->
name|num_vec
condition|;
name|irq
operator|++
control|)
block|{
if|if
condition|(
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|handle
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
argument_list|,
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|handle
argument_list|)
expr_stmt|;
block|}
name|bus_release_resource
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|irq
argument_list|,
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nic_register_interrupts
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|irq
decl_stmt|,
name|rid
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Enable MSI-X */
name|ret
operator|=
name|nic_enable_msix
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
comment|/* Register mailbox interrupt handlers */
name|irq
operator|=
name|NIC_PF_INTR_ID_MBOX0
expr_stmt|;
name|rid
operator|=
name|irq
operator|+
literal|1
expr_stmt|;
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
operator|(
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ret
operator|=
name|bus_setup_intr
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
argument_list|,
operator|(
name|INTR_MPSAFE
operator||
name|INTR_TYPE_MISC
operator|)
argument_list|,
name|NULL
argument_list|,
name|nic_mbx0_intr_handler
argument_list|,
name|nic
argument_list|,
operator|&
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|irq
operator|=
name|NIC_PF_INTR_ID_MBOX1
expr_stmt|;
name|rid
operator|=
name|irq
operator|+
literal|1
expr_stmt|;
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
operator|(
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ret
operator|=
name|bus_setup_intr
argument_list|(
name|nic
operator|->
name|dev
argument_list|,
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|irq_res
argument_list|,
operator|(
name|INTR_MPSAFE
operator||
name|INTR_TYPE_MISC
operator|)
argument_list|,
name|NULL
argument_list|,
name|nic_mbx1_intr_handler
argument_list|,
name|nic
argument_list|,
operator|&
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* Enable mailbox interrupt */
name|nic_enable_mbx_intr
argument_list|(
name|nic
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|nic_free_all_interrupts
argument_list|(
name|nic
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nic_unregister_interrupts
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
name|nic_free_all_interrupts
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|nic_disable_msix
argument_list|(
name|nic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nic_sriov_init
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PCI_IOV
name|nvlist_t
modifier|*
name|pf_schema
decl_stmt|,
modifier|*
name|vf_schema
decl_stmt|;
name|int
name|iov_pos
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint16_t
name|total_vf_cnt
decl_stmt|;
name|err
operator|=
name|pci_find_extcap
argument_list|(
name|dev
argument_list|,
name|PCIZ_SRIOV
argument_list|,
operator|&
name|iov_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SR-IOV capability is not found in PCIe config space\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* Fix-up the number of enabled VFs */
name|total_vf_cnt
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|iov_pos
operator|+
name|PCIR_SRIOV_TOTAL_VFS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_vf_cnt
operator|<
name|nic
operator|->
name|num_vf_en
condition|)
name|nic
operator|->
name|num_vf_en
operator|=
name|total_vf_cnt
expr_stmt|;
if|if
condition|(
name|total_vf_cnt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Attach SR-IOV */
name|pf_schema
operator|=
name|pci_iov_schema_alloc_node
argument_list|()
expr_stmt|;
name|vf_schema
operator|=
name|pci_iov_schema_alloc_node
argument_list|()
expr_stmt|;
name|pci_iov_schema_add_unicast_mac
argument_list|(
name|vf_schema
argument_list|,
literal|"mac-addr"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * All VFs can change their MACs. 	 * This flag will be ignored but we set it just for the record. 	 */
name|pci_iov_schema_add_bool
argument_list|(
name|vf_schema
argument_list|,
literal|"allow-set-mac"
argument_list|,
name|IOV_SCHEMA_HASDEFAULT
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_iov_attach
argument_list|(
name|dev
argument_list|,
name|pf_schema
argument_list|,
name|vf_schema
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize SR-IOV (error=%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|nic
operator|->
name|num_vf_en
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Poll for BGX LMAC link status and update corresponding VF  * if there is a change, valid only if internal L2 switch  * is not present otherwise VF link is always treated as up  */
end_comment

begin_function
specifier|static
name|void
name|nic_poll_for_link
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|struct
name|nicpf
modifier|*
name|nic
decl_stmt|;
name|struct
name|bgx_link_status
name|link
decl_stmt|;
name|uint8_t
name|vf
decl_stmt|,
name|bgx
decl_stmt|,
name|lmac
decl_stmt|;
name|nic
operator|=
operator|(
expr|struct
name|nicpf
operator|*
operator|)
name|arg
expr_stmt|;
name|mbx
operator|.
name|link_status
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_BGX_LINK_CHANGE
expr_stmt|;
for|for
control|(
name|vf
operator|=
literal|0
init|;
name|vf
operator|<
name|nic
operator|->
name|num_vf_en
condition|;
name|vf
operator|++
control|)
block|{
comment|/* Poll only if VF is UP */
if|if
condition|(
operator|!
name|nic
operator|->
name|vf_info
index|[
name|vf
index|]
operator|.
name|vf_enabled
condition|)
continue|continue;
comment|/* Get BGX, LMAC indices for the VF */
name|bgx
operator|=
name|NIC_GET_BGX_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|vf
index|]
argument_list|)
expr_stmt|;
name|lmac
operator|=
name|NIC_GET_LMAC_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|vf
index|]
argument_list|)
expr_stmt|;
comment|/* Get interface link status */
name|bgx_get_lmac_link_state
argument_list|(
name|nic
operator|->
name|node
argument_list|,
name|bgx
argument_list|,
name|lmac
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
comment|/* Inform VF only if link status changed */
if|if
condition|(
name|nic
operator|->
name|link
index|[
name|vf
index|]
operator|==
name|link
operator|.
name|link_up
condition|)
continue|continue;
if|if
condition|(
operator|!
name|nic
operator|->
name|mbx_lock
index|[
name|vf
index|]
condition|)
block|{
name|nic
operator|->
name|link
index|[
name|vf
index|]
operator|=
name|link
operator|.
name|link_up
expr_stmt|;
name|nic
operator|->
name|duplex
index|[
name|vf
index|]
operator|=
name|link
operator|.
name|duplex
expr_stmt|;
name|nic
operator|->
name|speed
index|[
name|vf
index|]
operator|=
name|link
operator|.
name|speed
expr_stmt|;
comment|/* Send a mbox message to VF with current link status */
name|mbx
operator|.
name|link_status
operator|.
name|link_up
operator|=
name|link
operator|.
name|link_up
expr_stmt|;
name|mbx
operator|.
name|link_status
operator|.
name|duplex
operator|=
name|link
operator|.
name|duplex
expr_stmt|;
name|mbx
operator|.
name|link_status
operator|.
name|speed
operator|=
name|link
operator|.
name|speed
expr_stmt|;
name|nic_send_msg_to_vf
argument_list|(
name|nic
argument_list|,
name|vf
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
block|}
name|callout_reset
argument_list|(
operator|&
name|nic
operator|->
name|check_link
argument_list|,
name|hz
operator|*
literal|2
argument_list|,
name|nic_poll_for_link
argument_list|,
name|nic
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

