begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2015 Cavium Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<linux/pci.h>
end_include

begin_include
include|#
directive|include
file|<linux/etherdevice.h>
end_include

begin_include
include|#
directive|include
file|<linux/of.h>
end_include

begin_include
include|#
directive|include
file|"nic_reg.h"
end_include

begin_include
include|#
directive|include
file|"nic.h"
end_include

begin_include
include|#
directive|include
file|"q_struct.h"
end_include

begin_include
include|#
directive|include
file|"thunder_bgx.h"
end_include

begin_define
define|#
directive|define
name|DRV_NAME
value|"thunder-nic"
end_define

begin_define
define|#
directive|define
name|DRV_VERSION
value|"1.0"
end_define

begin_struct
struct|struct
name|nicpf
block|{
name|struct
name|pci_dev
modifier|*
name|pdev
decl_stmt|;
name|u8
name|rev_id
decl_stmt|;
name|u8
name|node
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|u8
name|num_vf_en
decl_stmt|;
comment|/* No of VF enabled */
name|bool
name|vf_enabled
index|[
name|MAX_NUM_VFS_SUPPORTED
index|]
decl_stmt|;
name|void
name|__iomem
modifier|*
name|reg_base
decl_stmt|;
comment|/* Register start address */
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
name|u8
name|num_sqs_en
decl_stmt|;
comment|/* Secondary qsets enabled */
name|u64
name|nicvf
index|[
name|MAX_NUM_VFS_SUPPORTED
index|]
decl_stmt|;
name|u8
name|vf_sqs
index|[
name|MAX_NUM_VFS_SUPPORTED
index|]
index|[
name|MAX_SQS_PER_VF
index|]
decl_stmt|;
name|u8
name|pqs_vf
index|[
name|MAX_NUM_VFS_SUPPORTED
index|]
decl_stmt|;
name|bool
name|sqs_used
index|[
name|MAX_NUM_VFS_SUPPORTED
index|]
decl_stmt|;
endif|#
directive|endif
name|struct
name|pkind_cfg
name|pkind
decl_stmt|;
define|#
directive|define
name|NIC_SET_VF_LMAC_MAP
parameter_list|(
name|bgx
parameter_list|,
name|lmac
parameter_list|)
value|(((bgx& 0xF)<< 4) | (lmac& 0xF))
define|#
directive|define
name|NIC_GET_BGX_FROM_VF_LMAC_MAP
parameter_list|(
name|map
parameter_list|)
value|((map>> 4)& 0xF)
define|#
directive|define
name|NIC_GET_LMAC_FROM_VF_LMAC_MAP
parameter_list|(
name|map
parameter_list|)
value|(map& 0xF)
name|u8
name|vf_lmac_map
index|[
name|MAX_LMAC
index|]
decl_stmt|;
name|struct
name|delayed_work
name|dwork
decl_stmt|;
name|struct
name|workqueue_struct
modifier|*
name|check_link
decl_stmt|;
name|u8
name|link
index|[
name|MAX_LMAC
index|]
decl_stmt|;
name|u8
name|duplex
index|[
name|MAX_LMAC
index|]
decl_stmt|;
name|u32
name|speed
index|[
name|MAX_LMAC
index|]
decl_stmt|;
name|u16
name|cpi_base
index|[
name|MAX_NUM_VFS_SUPPORTED
index|]
decl_stmt|;
name|u16
name|rss_ind_tbl_size
decl_stmt|;
name|bool
name|mbx_lock
index|[
name|MAX_NUM_VFS_SUPPORTED
index|]
decl_stmt|;
comment|/* MSI-X */
name|bool
name|msix_enabled
decl_stmt|;
name|u8
name|num_vec
decl_stmt|;
name|struct
name|msix_entry
name|msix_entries
index|[
name|NIC_PF_MSIX_VECTORS
index|]
decl_stmt|;
name|bool
name|irq_allocated
index|[
name|NIC_PF_MSIX_VECTORS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Supported devices */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pci_device_id
name|nic_id_table
index|[]
init|=
block|{
block|{
name|PCI_DEVICE
argument_list|(
argument|PCI_VENDOR_ID_CAVIUM
argument_list|,
argument|PCI_DEVICE_ID_THUNDER_NIC_PF
argument_list|)
block|}
block|,
block|{
literal|0
block|, }
comment|/* end of table */
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
literal|"Sunil Goutham"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DESCRIPTION
argument_list|(
literal|"Cavium Thunder NIC Physical Function Driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|DRV_VERSION
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEVICE_TABLE
argument_list|(
name|pci
argument_list|,
name|nic_id_table
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The Cavium ThunderX network controller can *only* be found in SoCs  * containing the ThunderX ARM64 CPU implementation.  All accesses to the device  * registers on this platform are implicitly strongly ordered with respect  * to memory accesses. So writeq_relaxed() and readq_relaxed() are safe to use  * with no memory barriers in this driver.  The readq()/writeq() functions add  * explicit ordering operation which in this case are redundant, and only  * add overhead.  */
end_comment

begin_comment
comment|/* Register read/write APIs */
end_comment

begin_function
specifier|static
name|void
name|nic_reg_write
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|u64
name|offset
parameter_list|,
name|u64
name|val
parameter_list|)
block|{
name|writeq_relaxed
argument_list|(
name|val
argument_list|,
name|nic
operator|->
name|reg_base
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u64
name|nic_reg_read
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|u64
name|offset
parameter_list|)
block|{
return|return
name|readq_relaxed
argument_list|(
name|nic
operator|->
name|reg_base
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* PF -> VF mailbox communication APIs */
end_comment

begin_function
specifier|static
name|void
name|nic_enable_mbx_intr
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
comment|/* Enable mailbox interrupt for all 128 VFs */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_MAILBOX_ENA_W1S
argument_list|,
operator|~
literal|0ull
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_MAILBOX_ENA_W1S
operator|+
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|,
operator|~
literal|0ull
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nic_clear_mbx_intr
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|vf
parameter_list|,
name|int
name|mbx_reg
parameter_list|)
block|{
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_MAILBOX_INT
operator|+
operator|(
name|mbx_reg
operator|<<
literal|3
operator|)
argument_list|,
name|BIT_ULL
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u64
name|nic_get_mbx_addr
parameter_list|(
name|int
name|vf
parameter_list|)
block|{
return|return
name|NIC_PF_VF_0_127_MAILBOX_0_1
operator|+
operator|(
name|vf
operator|<<
name|NIC_VF_NUM_SHIFT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Send a mailbox message to VF  * @vf: vf to which this message to be sent  * @mbx: Message to be sent  */
end_comment

begin_function
specifier|static
name|void
name|nic_send_msg_to_vf
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|vf
parameter_list|,
name|union
name|nic_mbx
modifier|*
name|mbx
parameter_list|)
block|{
name|void
name|__iomem
modifier|*
name|mbx_addr
init|=
name|nic
operator|->
name|reg_base
operator|+
name|nic_get_mbx_addr
argument_list|(
name|vf
argument_list|)
decl_stmt|;
name|u64
modifier|*
name|msg
init|=
operator|(
name|u64
operator|*
operator|)
name|mbx
decl_stmt|;
comment|/* In first revision HW, mbox interrupt is triggerred 	 * when PF writes to MBOX(1), in next revisions when 	 * PF writes to MBOX(0) 	 */
if|if
condition|(
name|nic
operator|->
name|rev_id
operator|==
literal|0
condition|)
block|{
comment|/* see the comment for nic_reg_write()/nic_reg_read() 		 * functions above 		 */
name|writeq_relaxed
argument_list|(
name|msg
index|[
literal|0
index|]
argument_list|,
name|mbx_addr
argument_list|)
expr_stmt|;
name|writeq_relaxed
argument_list|(
name|msg
index|[
literal|1
index|]
argument_list|,
name|mbx_addr
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeq_relaxed
argument_list|(
name|msg
index|[
literal|1
index|]
argument_list|,
name|mbx_addr
operator|+
literal|8
argument_list|)
expr_stmt|;
name|writeq_relaxed
argument_list|(
name|msg
index|[
literal|0
index|]
argument_list|,
name|mbx_addr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Responds to VF's READY message with VF's  * ID, node, MAC address e.t.c  * @vf: VF which sent READY message  */
end_comment

begin_function
specifier|static
name|void
name|nic_mbx_send_ready
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|vf
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|int
name|bgx_idx
decl_stmt|,
name|lmac
decl_stmt|;
specifier|const
name|char
modifier|*
name|mac
decl_stmt|;
name|mbx
operator|.
name|nic_cfg
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_READY
expr_stmt|;
name|mbx
operator|.
name|nic_cfg
operator|.
name|vf_id
operator|=
name|vf
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|flags
operator|&
name|NIC_TNS_ENABLED
condition|)
name|mbx
operator|.
name|nic_cfg
operator|.
name|tns_mode
operator|=
name|NIC_TNS_MODE
expr_stmt|;
else|else
name|mbx
operator|.
name|nic_cfg
operator|.
name|tns_mode
operator|=
name|NIC_TNS_BYPASS_MODE
expr_stmt|;
if|if
condition|(
name|vf
operator|<
name|MAX_LMAC
condition|)
block|{
name|bgx_idx
operator|=
name|NIC_GET_BGX_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|vf
index|]
argument_list|)
expr_stmt|;
name|lmac
operator|=
name|NIC_GET_LMAC_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|vf
index|]
argument_list|)
expr_stmt|;
name|mac
operator|=
name|bgx_get_lmac_mac
argument_list|(
name|nic
operator|->
name|node
argument_list|,
name|bgx_idx
argument_list|,
name|lmac
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac
condition|)
name|ether_addr_copy
argument_list|(
operator|(
name|u8
operator|*
operator|)
operator|&
name|mbx
operator|.
name|nic_cfg
operator|.
name|mac_addr
argument_list|,
name|mac
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
name|mbx
operator|.
name|nic_cfg
operator|.
name|sqs_mode
operator|=
operator|(
name|vf
operator|>=
name|nic
operator|->
name|num_vf_en
operator|)
condition|?
name|true
else|:
name|false
expr_stmt|;
endif|#
directive|endif
name|mbx
operator|.
name|nic_cfg
operator|.
name|node_id
operator|=
name|nic
operator|->
name|node
expr_stmt|;
name|mbx
operator|.
name|nic_cfg
operator|.
name|loopback_supported
operator|=
name|vf
operator|<
name|MAX_LMAC
expr_stmt|;
name|nic_send_msg_to_vf
argument_list|(
name|nic
argument_list|,
name|vf
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ACKs VF's mailbox message  * @vf: VF to which ACK to be sent  */
end_comment

begin_function
specifier|static
name|void
name|nic_mbx_send_ack
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|vf
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|msg
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_ACK
expr_stmt|;
name|nic_send_msg_to_vf
argument_list|(
name|nic
argument_list|,
name|vf
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NACKs VF's mailbox message that PF is not able to  * complete the action  * @vf: VF to which ACK to be sent  */
end_comment

begin_function
specifier|static
name|void
name|nic_mbx_send_nack
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|vf
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|msg
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_NACK
expr_stmt|;
name|nic_send_msg_to_vf
argument_list|(
name|nic
argument_list|,
name|vf
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flush all in flight receive packets to memory and  * bring down an active RQ  */
end_comment

begin_function
specifier|static
name|int
name|nic_rcv_queue_sw_sync
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
name|u16
name|timeout
init|=
operator|~
literal|0x00
decl_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_SW_SYNC_RX
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Wait till sync cycle is finished */
while|while
condition|(
name|timeout
condition|)
block|{
if|if
condition|(
name|nic_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_PF_SW_SYNC_RX_DONE
argument_list|)
operator|&
literal|0x1
condition|)
break|break;
name|timeout
operator|--
expr_stmt|;
block|}
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_SW_SYNC_RX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|nic
operator|->
name|pdev
operator|->
name|dev
argument_list|,
literal|"Receive queue software sync failed"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get BGX Rx/Tx stats and respond to VF's request */
end_comment

begin_function
specifier|static
name|void
name|nic_get_bgx_stats
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|struct
name|bgx_stats_msg
modifier|*
name|bgx
parameter_list|)
block|{
name|int
name|bgx_idx
decl_stmt|,
name|lmac
decl_stmt|;
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|bgx_idx
operator|=
name|NIC_GET_BGX_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|bgx
operator|->
name|vf_id
index|]
argument_list|)
expr_stmt|;
name|lmac
operator|=
name|NIC_GET_LMAC_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|bgx
operator|->
name|vf_id
index|]
argument_list|)
expr_stmt|;
name|mbx
operator|.
name|bgx_stats
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_BGX_STATS
expr_stmt|;
name|mbx
operator|.
name|bgx_stats
operator|.
name|vf_id
operator|=
name|bgx
operator|->
name|vf_id
expr_stmt|;
name|mbx
operator|.
name|bgx_stats
operator|.
name|rx
operator|=
name|bgx
operator|->
name|rx
expr_stmt|;
name|mbx
operator|.
name|bgx_stats
operator|.
name|idx
operator|=
name|bgx
operator|->
name|idx
expr_stmt|;
if|if
condition|(
name|bgx
operator|->
name|rx
condition|)
name|mbx
operator|.
name|bgx_stats
operator|.
name|stats
operator|=
name|bgx_get_rx_stats
argument_list|(
name|nic
operator|->
name|node
argument_list|,
name|bgx_idx
argument_list|,
name|lmac
argument_list|,
name|bgx
operator|->
name|idx
argument_list|)
expr_stmt|;
else|else
name|mbx
operator|.
name|bgx_stats
operator|.
name|stats
operator|=
name|bgx_get_tx_stats
argument_list|(
name|nic
operator|->
name|node
argument_list|,
name|bgx_idx
argument_list|,
name|lmac
argument_list|,
name|bgx
operator|->
name|idx
argument_list|)
expr_stmt|;
name|nic_send_msg_to_vf
argument_list|(
name|nic
argument_list|,
name|bgx
operator|->
name|vf_id
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update hardware min/max frame size */
end_comment

begin_function
specifier|static
name|int
name|nic_update_hw_frs
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|new_frs
parameter_list|,
name|int
name|vf
parameter_list|)
block|{
if|if
condition|(
operator|(
name|new_frs
operator|>
name|NIC_HW_MAX_FRS
operator|)
operator|||
operator|(
name|new_frs
operator|<
name|NIC_HW_MIN_FRS
operator|)
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|nic
operator|->
name|pdev
operator|->
name|dev
argument_list|,
literal|"Invalid MTU setting from VF%d rejected, should be between %d and %d\n"
argument_list|,
name|vf
argument_list|,
name|NIC_HW_MIN_FRS
argument_list|,
name|NIC_HW_MAX_FRS
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|new_frs
operator|+=
name|ETH_HLEN
expr_stmt|;
if|if
condition|(
name|new_frs
operator|<=
name|nic
operator|->
name|pkind
operator|.
name|maxlen
condition|)
return|return
literal|0
return|;
name|nic
operator|->
name|pkind
operator|.
name|maxlen
operator|=
name|new_frs
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_PKIND_0_15_CFG
argument_list|,
operator|*
operator|(
name|u64
operator|*
operator|)
operator|&
name|nic
operator|->
name|pkind
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set minimum transmit packet size */
end_comment

begin_function
specifier|static
name|void
name|nic_set_tx_pkt_pad
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|lmac
decl_stmt|;
name|u64
name|lmac_cfg
decl_stmt|;
comment|/* Max value that can be set is 60 */
if|if
condition|(
name|size
operator|>
literal|60
condition|)
name|size
operator|=
literal|60
expr_stmt|;
for|for
control|(
name|lmac
operator|=
literal|0
init|;
name|lmac
operator|<
operator|(
name|MAX_BGX_PER_CN88XX
operator|*
name|MAX_LMAC_PER_BGX
operator|)
condition|;
name|lmac
operator|++
control|)
block|{
name|lmac_cfg
operator|=
name|nic_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_PF_LMAC_0_7_CFG
operator||
operator|(
name|lmac
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|lmac_cfg
operator|&=
operator|~
operator|(
literal|0xF
operator|<<
literal|2
operator|)
expr_stmt|;
name|lmac_cfg
operator||=
operator|(
operator|(
name|size
operator|/
literal|4
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_LMAC_0_7_CFG
operator||
operator|(
name|lmac
operator|<<
literal|3
operator|)
argument_list|,
name|lmac_cfg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Function to check number of LMACs present and set VF::LMAC mapping.  * Mapping will be used while initializing channels.  */
end_comment

begin_function
specifier|static
name|void
name|nic_set_lmac_vf_mapping
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
name|unsigned
name|bgx_map
init|=
name|bgx_get_map
argument_list|(
name|nic
operator|->
name|node
argument_list|)
decl_stmt|;
name|int
name|bgx
decl_stmt|,
name|next_bgx_lmac
init|=
literal|0
decl_stmt|;
name|int
name|lmac
decl_stmt|,
name|lmac_cnt
init|=
literal|0
decl_stmt|;
name|u64
name|lmac_credit
decl_stmt|;
name|nic
operator|->
name|num_vf_en
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|flags
operator|&
name|NIC_TNS_ENABLED
condition|)
block|{
name|nic
operator|->
name|num_vf_en
operator|=
name|DEFAULT_NUM_VF_ENABLED
expr_stmt|;
return|return;
block|}
for|for
control|(
name|bgx
operator|=
literal|0
init|;
name|bgx
operator|<
name|NIC_MAX_BGX
condition|;
name|bgx
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|bgx_map
operator|&
operator|(
literal|1
operator|<<
name|bgx
operator|)
operator|)
condition|)
continue|continue;
name|lmac_cnt
operator|=
name|bgx_get_lmac_count
argument_list|(
name|nic
operator|->
name|node
argument_list|,
name|bgx
argument_list|)
expr_stmt|;
for|for
control|(
name|lmac
operator|=
literal|0
init|;
name|lmac
operator|<
name|lmac_cnt
condition|;
name|lmac
operator|++
control|)
name|nic
operator|->
name|vf_lmac_map
index|[
name|next_bgx_lmac
operator|++
index|]
operator|=
name|NIC_SET_VF_LMAC_MAP
argument_list|(
name|bgx
argument_list|,
name|lmac
argument_list|)
expr_stmt|;
name|nic
operator|->
name|num_vf_en
operator|+=
name|lmac_cnt
expr_stmt|;
comment|/* Program LMAC credits */
name|lmac_credit
operator|=
operator|(
literal|1ull
operator|<<
literal|1
operator|)
expr_stmt|;
comment|/* channel credit enable */
name|lmac_credit
operator||=
operator|(
literal|0x1ff
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* Max outstanding pkt count */
comment|/* 48KB BGX Tx buffer size, each unit is of size 16bytes */
name|lmac_credit
operator||=
operator|(
operator|(
operator|(
operator|(
operator|(
literal|48
operator|*
literal|1024
operator|)
operator|/
name|lmac_cnt
operator|)
operator|-
name|NIC_HW_MAX_FRS
operator|)
operator|/
literal|16
operator|)
operator|<<
literal|12
operator|)
expr_stmt|;
name|lmac
operator|=
name|bgx
operator|*
name|MAX_LMAC_PER_BGX
expr_stmt|;
for|for
control|(
init|;
name|lmac
operator|<
name|lmac_cnt
operator|+
operator|(
name|bgx
operator|*
name|MAX_LMAC_PER_BGX
operator|)
condition|;
name|lmac
operator|++
control|)
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_LMAC_0_7_CREDIT
operator|+
operator|(
name|lmac
operator|*
literal|8
operator|)
argument_list|,
name|lmac_credit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|TNS_PORT0_BLOCK
value|6
end_define

begin_define
define|#
directive|define
name|TNS_PORT1_BLOCK
value|7
end_define

begin_define
define|#
directive|define
name|BGX0_BLOCK
value|8
end_define

begin_define
define|#
directive|define
name|BGX1_BLOCK
value|9
end_define

begin_function
specifier|static
name|void
name|nic_init_hw
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Reset NIC, in case the driver is repeatedly inserted and removed */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_SOFT_RESET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Enable NIC HW block */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_CFG
argument_list|,
literal|0x3
argument_list|)
expr_stmt|;
comment|/* Enable backpressure */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_BP_CFG
argument_list|,
operator|(
literal|1ULL
operator|<<
literal|6
operator|)
operator||
literal|0x03
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|->
name|flags
operator|&
name|NIC_TNS_ENABLED
condition|)
block|{
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_INTF_0_1_SEND_CFG
argument_list|,
operator|(
name|NIC_TNS_MODE
operator|<<
literal|7
operator|)
operator||
name|TNS_PORT0_BLOCK
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_INTF_0_1_SEND_CFG
operator||
operator|(
literal|1
operator|<<
literal|8
operator|)
argument_list|,
operator|(
name|NIC_TNS_MODE
operator|<<
literal|7
operator|)
operator||
name|TNS_PORT1_BLOCK
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_INTF_0_1_BP_CFG
argument_list|,
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
operator||
name|TNS_PORT0_BLOCK
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_INTF_0_1_BP_CFG
operator|+
operator|(
literal|1
operator|<<
literal|8
operator|)
argument_list|,
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
operator||
name|TNS_PORT1_BLOCK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Disable TNS mode on both interfaces */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_INTF_0_1_SEND_CFG
argument_list|,
operator|(
name|NIC_TNS_BYPASS_MODE
operator|<<
literal|7
operator|)
operator||
name|BGX0_BLOCK
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_INTF_0_1_SEND_CFG
operator||
operator|(
literal|1
operator|<<
literal|8
operator|)
argument_list|,
operator|(
name|NIC_TNS_BYPASS_MODE
operator|<<
literal|7
operator|)
operator||
name|BGX1_BLOCK
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_INTF_0_1_BP_CFG
argument_list|,
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
operator||
name|BGX0_BLOCK
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_INTF_0_1_BP_CFG
operator|+
operator|(
literal|1
operator|<<
literal|8
operator|)
argument_list|,
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
operator||
name|BGX1_BLOCK
argument_list|)
expr_stmt|;
block|}
comment|/* PKIND configuration */
name|nic
operator|->
name|pkind
operator|.
name|minlen
operator|=
literal|0
expr_stmt|;
name|nic
operator|->
name|pkind
operator|.
name|maxlen
operator|=
name|NIC_HW_MAX_FRS
operator|+
name|ETH_HLEN
expr_stmt|;
name|nic
operator|->
name|pkind
operator|.
name|lenerr_en
operator|=
literal|1
expr_stmt|;
name|nic
operator|->
name|pkind
operator|.
name|rx_hdr
operator|=
literal|0
expr_stmt|;
name|nic
operator|->
name|pkind
operator|.
name|hdr_sl
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NIC_MAX_PKIND
condition|;
name|i
operator|++
control|)
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_PKIND_0_15_CFG
operator||
operator|(
name|i
operator|<<
literal|3
operator|)
argument_list|,
operator|*
operator|(
name|u64
operator|*
operator|)
operator|&
name|nic
operator|->
name|pkind
argument_list|)
expr_stmt|;
name|nic_set_tx_pkt_pad
argument_list|(
name|nic
argument_list|,
name|NIC_HW_MIN_FRS
argument_list|)
expr_stmt|;
comment|/* Timer config */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_INTR_TIMER_CFG
argument_list|,
name|NICPF_CLK_PER_INT_TICK
argument_list|)
expr_stmt|;
comment|/* Enable VLAN ethertype matching and stripping */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_RX_ETYPE_0_7
argument_list|,
operator|(
literal|2
operator|<<
literal|19
operator|)
operator||
operator|(
name|ETYPE_ALG_VLAN_STRIP
operator|<<
literal|16
operator|)
operator||
name|ETH_P_8021Q
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Channel parse index configuration */
end_comment

begin_function
specifier|static
name|void
name|nic_config_cpi
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|struct
name|cpi_cfg_msg
modifier|*
name|cfg
parameter_list|)
block|{
name|u32
name|vnic
decl_stmt|,
name|bgx
decl_stmt|,
name|lmac
decl_stmt|,
name|chan
decl_stmt|;
name|u32
name|padd
decl_stmt|,
name|cpi_count
init|=
literal|0
decl_stmt|;
name|u64
name|cpi_base
decl_stmt|,
name|cpi
decl_stmt|,
name|rssi_base
decl_stmt|,
name|rssi
decl_stmt|;
name|u8
name|qset
decl_stmt|,
name|rq_idx
init|=
literal|0
decl_stmt|;
name|vnic
operator|=
name|cfg
operator|->
name|vf_id
expr_stmt|;
name|bgx
operator|=
name|NIC_GET_BGX_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|vnic
index|]
argument_list|)
expr_stmt|;
name|lmac
operator|=
name|NIC_GET_LMAC_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|vnic
index|]
argument_list|)
expr_stmt|;
name|chan
operator|=
operator|(
name|lmac
operator|*
name|MAX_BGX_CHANS_PER_LMAC
operator|)
operator|+
operator|(
name|bgx
operator|*
name|NIC_CHANS_PER_INF
operator|)
expr_stmt|;
name|cpi_base
operator|=
operator|(
name|lmac
operator|*
name|NIC_MAX_CPI_PER_LMAC
operator|)
operator|+
operator|(
name|bgx
operator|*
name|NIC_CPI_PER_BGX
operator|)
expr_stmt|;
name|rssi_base
operator|=
operator|(
name|lmac
operator|*
name|nic
operator|->
name|rss_ind_tbl_size
operator|)
operator|+
operator|(
name|bgx
operator|*
name|NIC_RSSI_PER_BGX
operator|)
expr_stmt|;
comment|/* Rx channel configuration */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_CHAN_0_255_RX_BP_CFG
operator||
operator|(
name|chan
operator|<<
literal|3
operator|)
argument_list|,
operator|(
literal|1ull
operator|<<
literal|63
operator|)
operator||
operator|(
name|vnic
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_CHAN_0_255_RX_CFG
operator||
operator|(
name|chan
operator|<<
literal|3
operator|)
argument_list|,
operator|(
operator|(
name|u64
operator|)
name|cfg
operator|->
name|cpi_alg
operator|<<
literal|62
operator|)
operator||
operator|(
name|cpi_base
operator|<<
literal|48
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|cpi_alg
operator|==
name|CPI_ALG_NONE
condition|)
name|cpi_count
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cfg
operator|->
name|cpi_alg
operator|==
name|CPI_ALG_VLAN
condition|)
comment|/* 3 bits of PCP */
name|cpi_count
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|cfg
operator|->
name|cpi_alg
operator|==
name|CPI_ALG_VLAN16
condition|)
comment|/* 3 bits PCP + DEI */
name|cpi_count
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|cfg
operator|->
name|cpi_alg
operator|==
name|CPI_ALG_DIFF
condition|)
comment|/* 6bits DSCP */
name|cpi_count
operator|=
name|NIC_MAX_CPI_PER_LMAC
expr_stmt|;
comment|/* RSS Qset, Qidx mapping */
name|qset
operator|=
name|cfg
operator|->
name|vf_id
expr_stmt|;
name|rssi
operator|=
name|rssi_base
expr_stmt|;
for|for
control|(
init|;
name|rssi
operator|<
operator|(
name|rssi_base
operator|+
name|cfg
operator|->
name|rq_cnt
operator|)
condition|;
name|rssi
operator|++
control|)
block|{
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_RSSI_0_4097_RQ
operator||
operator|(
name|rssi
operator|<<
literal|3
operator|)
argument_list|,
operator|(
name|qset
operator|<<
literal|3
operator|)
operator||
name|rq_idx
argument_list|)
expr_stmt|;
name|rq_idx
operator|++
expr_stmt|;
block|}
name|rssi
operator|=
literal|0
expr_stmt|;
name|cpi
operator|=
name|cpi_base
expr_stmt|;
for|for
control|(
init|;
name|cpi
operator|<
operator|(
name|cpi_base
operator|+
name|cpi_count
operator|)
condition|;
name|cpi
operator|++
control|)
block|{
comment|/* Determine port to channel adder */
if|if
condition|(
name|cfg
operator|->
name|cpi_alg
operator|!=
name|CPI_ALG_DIFF
condition|)
name|padd
operator|=
name|cpi
operator|%
name|cpi_count
expr_stmt|;
else|else
name|padd
operator|=
name|cpi
operator|%
literal|8
expr_stmt|;
comment|/* 3 bits CS out of 6bits DSCP */
comment|/* Leave RSS_SIZE as '0' to disable RSS */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_CPI_0_2047_CFG
operator||
operator|(
name|cpi
operator|<<
literal|3
operator|)
argument_list|,
operator|(
name|vnic
operator|<<
literal|24
operator|)
operator||
operator|(
name|padd
operator|<<
literal|16
operator|)
operator||
operator|(
name|rssi_base
operator|+
name|rssi
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rssi
operator|+
literal|1
operator|)
operator|>=
name|cfg
operator|->
name|rq_cnt
condition|)
continue|continue;
if|if
condition|(
name|cfg
operator|->
name|cpi_alg
operator|==
name|CPI_ALG_VLAN
condition|)
name|rssi
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|cfg
operator|->
name|cpi_alg
operator|==
name|CPI_ALG_VLAN16
condition|)
name|rssi
operator|=
operator|(
operator|(
name|cpi
operator|-
name|cpi_base
operator|)
operator|&
literal|0xe
operator|)
operator|>>
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cfg
operator|->
name|cpi_alg
operator|==
name|CPI_ALG_DIFF
condition|)
name|rssi
operator|=
operator|(
operator|(
name|cpi
operator|-
name|cpi_base
operator|)
operator|&
literal|0x38
operator|)
operator|>>
literal|3
expr_stmt|;
block|}
name|nic
operator|->
name|cpi_base
index|[
name|cfg
operator|->
name|vf_id
index|]
operator|=
name|cpi_base
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VNIC_RSS_SUPPORT
end_ifdef

begin_comment
comment|/* Responsds to VF with its RSS indirection table size */
end_comment

begin_function
specifier|static
name|void
name|nic_send_rss_size
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|vf
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|u64
modifier|*
name|msg
decl_stmt|;
name|msg
operator|=
operator|(
name|u64
operator|*
operator|)
operator|&
name|mbx
expr_stmt|;
name|mbx
operator|.
name|rss_size
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_RSS_SIZE
expr_stmt|;
name|mbx
operator|.
name|rss_size
operator|.
name|ind_tbl_size
operator|=
name|nic
operator|->
name|rss_ind_tbl_size
expr_stmt|;
name|nic_send_msg_to_vf
argument_list|(
name|nic
argument_list|,
name|vf
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Receive side scaling configuration  * configure:  * - RSS index  * - indir table i.e hash::RQ mapping  * - no of hash bits to consider  */
end_comment

begin_function
specifier|static
name|void
name|nic_config_rss
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|struct
name|rss_cfg_msg
modifier|*
name|cfg
parameter_list|)
block|{
name|u8
name|qset
decl_stmt|,
name|idx
init|=
literal|0
decl_stmt|;
name|u64
name|cpi_cfg
decl_stmt|,
name|cpi_base
decl_stmt|,
name|rssi_base
decl_stmt|,
name|rssi
decl_stmt|;
name|cpi_base
operator|=
name|nic
operator|->
name|cpi_base
index|[
name|cfg
operator|->
name|vf_id
index|]
expr_stmt|;
name|cpi_cfg
operator|=
name|nic_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_PF_CPI_0_2047_CFG
operator||
operator|(
name|cpi_base
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|rssi_base
operator|=
operator|(
name|cpi_cfg
operator|&
literal|0x0FFF
operator|)
operator|+
name|cfg
operator|->
name|tbl_offset
expr_stmt|;
name|rssi
operator|=
name|rssi_base
expr_stmt|;
name|qset
operator|=
name|cfg
operator|->
name|vf_id
expr_stmt|;
for|for
control|(
init|;
name|rssi
operator|<
operator|(
name|rssi_base
operator|+
name|cfg
operator|->
name|tbl_len
operator|)
condition|;
name|rssi
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
name|u8
name|svf
init|=
name|cfg
operator|->
name|ind_tbl
index|[
name|idx
index|]
operator|>>
literal|3
decl_stmt|;
if|if
condition|(
name|svf
condition|)
name|qset
operator|=
name|nic
operator|->
name|vf_sqs
index|[
name|cfg
operator|->
name|vf_id
index|]
index|[
name|svf
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|qset
operator|=
name|cfg
operator|->
name|vf_id
expr_stmt|;
endif|#
directive|endif
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_RSSI_0_4097_RQ
operator||
operator|(
name|rssi
operator|<<
literal|3
operator|)
argument_list|,
operator|(
name|qset
operator|<<
literal|3
operator|)
operator||
operator|(
name|cfg
operator|->
name|ind_tbl
index|[
name|idx
index|]
operator|&
literal|0x7
operator|)
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
name|cpi_cfg
operator|&=
operator|~
operator|(
literal|0xFULL
operator|<<
literal|20
operator|)
expr_stmt|;
name|cpi_cfg
operator||=
operator|(
name|cfg
operator|->
name|hash_bits
operator|<<
literal|20
operator|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_CPI_0_2047_CFG
operator||
operator|(
name|cpi_base
operator|<<
literal|3
operator|)
argument_list|,
name|cpi_cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 4 level transmit side scheduler configutation  * for TNS bypass mode  *  * Sample configuration for SQ0  * VNIC0-SQ0 -> TL4(0)   -> TL3[0]   -> TL2[0]  -> TL1[0] -> BGX0  * VNIC1-SQ0 -> TL4(8)   -> TL3[2]   -> TL2[0]  -> TL1[0] -> BGX0  * VNIC2-SQ0 -> TL4(16)  -> TL3[4]   -> TL2[1]  -> TL1[0] -> BGX0  * VNIC3-SQ0 -> TL4(24)  -> TL3[6]   -> TL2[1]  -> TL1[0] -> BGX0  * VNIC4-SQ0 -> TL4(512) -> TL3[128] -> TL2[32] -> TL1[1] -> BGX1  * VNIC5-SQ0 -> TL4(520) -> TL3[130] -> TL2[32] -> TL1[1] -> BGX1  * VNIC6-SQ0 -> TL4(528) -> TL3[132] -> TL2[33] -> TL1[1] -> BGX1  * VNIC7-SQ0 -> TL4(536) -> TL3[134] -> TL2[33] -> TL1[1] -> BGX1  */
end_comment

begin_function
specifier|static
name|void
name|nic_tx_channel_cfg
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|u8
name|vnic
parameter_list|,
name|struct
name|sq_cfg_msg
modifier|*
name|sq
parameter_list|)
block|{
name|u32
name|bgx
decl_stmt|,
name|lmac
decl_stmt|,
name|chan
decl_stmt|;
name|u32
name|tl2
decl_stmt|,
name|tl3
decl_stmt|,
name|tl4
decl_stmt|;
name|u32
name|rr_quantum
decl_stmt|;
name|u8
name|sq_idx
init|=
name|sq
operator|->
name|sq_num
decl_stmt|;
name|u8
name|pqs_vnic
decl_stmt|;
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
if|if
condition|(
name|sq
operator|->
name|sqs_mode
condition|)
name|pqs_vnic
operator|=
name|nic
operator|->
name|pqs_vf
index|[
name|vnic
index|]
expr_stmt|;
else|else
endif|#
directive|endif
name|pqs_vnic
operator|=
name|vnic
expr_stmt|;
name|bgx
operator|=
name|NIC_GET_BGX_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|pqs_vnic
index|]
argument_list|)
expr_stmt|;
name|lmac
operator|=
name|NIC_GET_LMAC_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|pqs_vnic
index|]
argument_list|)
expr_stmt|;
comment|/* 24 bytes for FCS, IPG and preamble */
name|rr_quantum
operator|=
operator|(
operator|(
name|NIC_HW_MAX_FRS
operator|+
literal|24
operator|)
operator|/
literal|4
operator|)
expr_stmt|;
name|tl4
operator|=
operator|(
name|lmac
operator|*
name|NIC_TL4_PER_LMAC
operator|)
operator|+
operator|(
name|bgx
operator|*
name|NIC_TL4_PER_BGX
operator|)
expr_stmt|;
name|tl4
operator|+=
name|sq_idx
expr_stmt|;
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
if|if
condition|(
name|sq
operator|->
name|sqs_mode
condition|)
name|tl4
operator|+=
name|vnic
operator|*
literal|8
expr_stmt|;
endif|#
directive|endif
name|tl3
operator|=
name|tl4
operator|/
operator|(
name|NIC_MAX_TL4
operator|/
name|NIC_MAX_TL3
operator|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_QSET_0_127_SQ_0_7_CFG2
operator||
operator|(
operator|(
name|u64
operator|)
name|vnic
operator|<<
name|NIC_QS_ID_SHIFT
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|sq_idx
operator|<<
name|NIC_Q_NUM_SHIFT
operator|)
argument_list|,
name|tl4
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_TL4_0_1023_CFG
operator||
operator|(
name|tl4
operator|<<
literal|3
operator|)
argument_list|,
operator|(
operator|(
name|u64
operator|)
name|vnic
operator|<<
literal|27
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|sq_idx
operator|<<
literal|24
operator|)
operator||
name|rr_quantum
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_TL3_0_255_CFG
operator||
operator|(
name|tl3
operator|<<
literal|3
operator|)
argument_list|,
name|rr_quantum
argument_list|)
expr_stmt|;
name|chan
operator|=
operator|(
name|lmac
operator|*
name|MAX_BGX_CHANS_PER_LMAC
operator|)
operator|+
operator|(
name|bgx
operator|*
name|NIC_CHANS_PER_INF
operator|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_TL3_0_255_CHAN
operator||
operator|(
name|tl3
operator|<<
literal|3
operator|)
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* Enable backpressure on the channel */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_CHAN_0_255_TX_CFG
operator||
operator|(
name|chan
operator|<<
literal|3
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tl2
operator|=
name|tl3
operator|>>
literal|2
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_TL3A_0_63_CFG
operator||
operator|(
name|tl2
operator|<<
literal|3
operator|)
argument_list|,
name|tl2
argument_list|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_TL2_0_63_CFG
operator||
operator|(
name|tl2
operator|<<
literal|3
operator|)
argument_list|,
name|rr_quantum
argument_list|)
expr_stmt|;
comment|/* No priorities as of now */
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|NIC_PF_TL2_0_63_PRI
operator||
operator|(
name|tl2
operator|<<
literal|3
operator|)
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
end_ifdef

begin_comment
comment|/* Send primary nicvf pointer to secondary QS's VF */
end_comment

begin_function
specifier|static
name|void
name|nic_send_pnicvf
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|sqs
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|mbx
operator|.
name|nicvf
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_PNICVF_PTR
expr_stmt|;
name|mbx
operator|.
name|nicvf
operator|.
name|nicvf
operator|=
name|nic
operator|->
name|nicvf
index|[
name|nic
operator|->
name|pqs_vf
index|[
name|sqs
index|]
index|]
expr_stmt|;
name|nic_send_msg_to_vf
argument_list|(
name|nic
argument_list|,
name|sqs
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send SQS's nicvf pointer to primary QS's VF */
end_comment

begin_function
specifier|static
name|void
name|nic_send_snicvf
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|struct
name|nicvf_ptr
modifier|*
name|nicvf
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|int
name|sqs_id
init|=
name|nic
operator|->
name|vf_sqs
index|[
name|nicvf
operator|->
name|vf_id
index|]
index|[
name|nicvf
operator|->
name|sqs_id
index|]
decl_stmt|;
name|mbx
operator|.
name|nicvf
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_SNICVF_PTR
expr_stmt|;
name|mbx
operator|.
name|nicvf
operator|.
name|sqs_id
operator|=
name|nicvf
operator|->
name|sqs_id
expr_stmt|;
name|mbx
operator|.
name|nicvf
operator|.
name|nicvf
operator|=
name|nic
operator|->
name|nicvf
index|[
name|sqs_id
index|]
expr_stmt|;
name|nic_send_msg_to_vf
argument_list|(
name|nic
argument_list|,
name|nicvf
operator|->
name|vf_id
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find next available Qset that can be assigned as a  * secondary Qset to a VF.  */
end_comment

begin_function
specifier|static
name|int
name|nic_nxt_avail_sqs
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|sqs
decl_stmt|;
for|for
control|(
name|sqs
operator|=
literal|0
init|;
name|sqs
operator|<
name|nic
operator|->
name|num_sqs_en
condition|;
name|sqs
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|nic
operator|->
name|sqs_used
index|[
name|sqs
index|]
condition|)
name|nic
operator|->
name|sqs_used
index|[
name|sqs
index|]
operator|=
name|true
expr_stmt|;
else|else
continue|continue;
return|return
name|sqs
operator|+
name|nic
operator|->
name|num_vf_en
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Allocate additional Qsets for requested VF */
end_comment

begin_function
specifier|static
name|void
name|nic_alloc_sqs
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|struct
name|sqs_alloc
modifier|*
name|sqs
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|alloc_qs
init|=
literal|0
decl_stmt|;
name|int
name|sqs_id
decl_stmt|;
if|if
condition|(
operator|!
name|nic
operator|->
name|num_sqs_en
condition|)
goto|goto
name|send_mbox
goto|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|sqs
operator|->
name|qs_count
condition|;
name|idx
operator|++
control|)
block|{
name|sqs_id
operator|=
name|nic_nxt_avail_sqs
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqs_id
operator|<
literal|0
condition|)
break|break;
name|nic
operator|->
name|vf_sqs
index|[
name|sqs
operator|->
name|vf_id
index|]
index|[
name|idx
index|]
operator|=
name|sqs_id
expr_stmt|;
name|nic
operator|->
name|pqs_vf
index|[
name|sqs_id
index|]
operator|=
name|sqs
operator|->
name|vf_id
expr_stmt|;
name|alloc_qs
operator|++
expr_stmt|;
block|}
name|send_mbox
label|:
name|mbx
operator|.
name|sqs_alloc
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_ALLOC_SQS
expr_stmt|;
name|mbx
operator|.
name|sqs_alloc
operator|.
name|vf_id
operator|=
name|sqs
operator|->
name|vf_id
expr_stmt|;
name|mbx
operator|.
name|sqs_alloc
operator|.
name|qs_count
operator|=
name|alloc_qs
expr_stmt|;
name|nic_send_msg_to_vf
argument_list|(
name|nic
argument_list|,
name|sqs
operator|->
name|vf_id
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|nic_config_loopback
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|struct
name|set_loopback
modifier|*
name|lbk
parameter_list|)
block|{
name|int
name|bgx_idx
decl_stmt|,
name|lmac_idx
decl_stmt|;
if|if
condition|(
name|lbk
operator|->
name|vf_id
operator|>
name|MAX_LMAC
condition|)
return|return
operator|-
literal|1
return|;
name|bgx_idx
operator|=
name|NIC_GET_BGX_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|lbk
operator|->
name|vf_id
index|]
argument_list|)
expr_stmt|;
name|lmac_idx
operator|=
name|NIC_GET_LMAC_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|lbk
operator|->
name|vf_id
index|]
argument_list|)
expr_stmt|;
name|bgx_lmac_internal_loopback
argument_list|(
name|nic
operator|->
name|node
argument_list|,
name|bgx_idx
argument_list|,
name|lmac_idx
argument_list|,
name|lbk
operator|->
name|enable
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Interrupt handler to handle mailbox messages from VFs */
end_comment

begin_function
specifier|static
name|void
name|nic_handle_mbx_intr
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|vf
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|u64
modifier|*
name|mbx_data
decl_stmt|;
name|u64
name|mbx_addr
decl_stmt|;
name|u64
name|reg_addr
decl_stmt|;
name|u64
name|cfg
decl_stmt|;
name|int
name|bgx
decl_stmt|,
name|lmac
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|nic
operator|->
name|mbx_lock
index|[
name|vf
index|]
operator|=
name|true
expr_stmt|;
name|mbx_addr
operator|=
name|nic_get_mbx_addr
argument_list|(
name|vf
argument_list|)
expr_stmt|;
name|mbx_data
operator|=
operator|(
name|u64
operator|*
operator|)
operator|&
name|mbx
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NIC_PF_VF_MAILBOX_SIZE
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|mbx_data
operator|=
name|nic_reg_read
argument_list|(
name|nic
argument_list|,
name|mbx_addr
argument_list|)
expr_stmt|;
name|mbx_data
operator|++
expr_stmt|;
name|mbx_addr
operator|+=
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
expr_stmt|;
block|}
name|dev_dbg
argument_list|(
operator|&
name|nic
operator|->
name|pdev
operator|->
name|dev
argument_list|,
literal|"%s: Mailbox msg %d from VF%d\n"
argument_list|,
name|__func__
argument_list|,
name|mbx
operator|.
name|msg
operator|.
name|msg
argument_list|,
name|vf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mbx
operator|.
name|msg
operator|.
name|msg
condition|)
block|{
case|case
name|NIC_MBOX_MSG_READY
case|:
name|nic_mbx_send_ready
argument_list|(
name|nic
argument_list|,
name|vf
argument_list|)
expr_stmt|;
if|if
condition|(
name|vf
operator|<
name|MAX_LMAC
condition|)
block|{
name|nic
operator|->
name|link
index|[
name|vf
index|]
operator|=
literal|0
expr_stmt|;
name|nic
operator|->
name|duplex
index|[
name|vf
index|]
operator|=
literal|0
expr_stmt|;
name|nic
operator|->
name|speed
index|[
name|vf
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_QS_CFG
case|:
name|reg_addr
operator|=
name|NIC_PF_QSET_0_127_CFG
operator||
operator|(
name|mbx
operator|.
name|qs
operator|.
name|num
operator|<<
name|NIC_QS_ID_SHIFT
operator|)
expr_stmt|;
name|cfg
operator|=
name|mbx
operator|.
name|qs
operator|.
name|cfg
expr_stmt|;
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
comment|/* Check if its a secondary Qset */
if|if
condition|(
name|vf
operator|>=
name|nic
operator|->
name|num_vf_en
condition|)
block|{
name|cfg
operator|=
name|cfg
operator|&
operator|(
operator|~
literal|0x7FULL
operator|)
expr_stmt|;
comment|/* Assign this Qset to primary Qset's VF */
name|cfg
operator||=
name|nic
operator|->
name|pqs_vf
index|[
name|vf
index|]
expr_stmt|;
block|}
endif|#
directive|endif
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|reg_addr
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_RQ_CFG
case|:
name|reg_addr
operator|=
name|NIC_PF_QSET_0_127_RQ_0_7_CFG
operator||
operator|(
name|mbx
operator|.
name|rq
operator|.
name|qs_num
operator|<<
name|NIC_QS_ID_SHIFT
operator|)
operator||
operator|(
name|mbx
operator|.
name|rq
operator|.
name|rq_num
operator|<<
name|NIC_Q_NUM_SHIFT
operator|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|reg_addr
argument_list|,
name|mbx
operator|.
name|rq
operator|.
name|cfg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_RQ_BP_CFG
case|:
name|reg_addr
operator|=
name|NIC_PF_QSET_0_127_RQ_0_7_BP_CFG
operator||
operator|(
name|mbx
operator|.
name|rq
operator|.
name|qs_num
operator|<<
name|NIC_QS_ID_SHIFT
operator|)
operator||
operator|(
name|mbx
operator|.
name|rq
operator|.
name|rq_num
operator|<<
name|NIC_Q_NUM_SHIFT
operator|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|reg_addr
argument_list|,
name|mbx
operator|.
name|rq
operator|.
name|cfg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_RQ_SW_SYNC
case|:
name|ret
operator|=
name|nic_rcv_queue_sw_sync
argument_list|(
name|nic
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_RQ_DROP_CFG
case|:
name|reg_addr
operator|=
name|NIC_PF_QSET_0_127_RQ_0_7_DROP_CFG
operator||
operator|(
name|mbx
operator|.
name|rq
operator|.
name|qs_num
operator|<<
name|NIC_QS_ID_SHIFT
operator|)
operator||
operator|(
name|mbx
operator|.
name|rq
operator|.
name|rq_num
operator|<<
name|NIC_Q_NUM_SHIFT
operator|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|reg_addr
argument_list|,
name|mbx
operator|.
name|rq
operator|.
name|cfg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_SQ_CFG
case|:
name|reg_addr
operator|=
name|NIC_PF_QSET_0_127_SQ_0_7_CFG
operator||
operator|(
name|mbx
operator|.
name|sq
operator|.
name|qs_num
operator|<<
name|NIC_QS_ID_SHIFT
operator|)
operator||
operator|(
name|mbx
operator|.
name|sq
operator|.
name|sq_num
operator|<<
name|NIC_Q_NUM_SHIFT
operator|)
expr_stmt|;
name|nic_reg_write
argument_list|(
name|nic
argument_list|,
name|reg_addr
argument_list|,
name|mbx
operator|.
name|sq
operator|.
name|cfg
argument_list|)
expr_stmt|;
name|nic_tx_channel_cfg
argument_list|(
name|nic
argument_list|,
name|mbx
operator|.
name|qs
operator|.
name|num
argument_list|,
operator|&
name|mbx
operator|.
name|sq
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_SET_MAC
case|:
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
if|if
condition|(
name|vf
operator|>=
name|nic
operator|->
name|num_vf_en
condition|)
break|break;
endif|#
directive|endif
name|lmac
operator|=
name|mbx
operator|.
name|mac
operator|.
name|vf_id
expr_stmt|;
name|bgx
operator|=
name|NIC_GET_BGX_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|lmac
index|]
argument_list|)
expr_stmt|;
name|lmac
operator|=
name|NIC_GET_LMAC_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|lmac
index|]
argument_list|)
expr_stmt|;
name|bgx_set_lmac_mac
argument_list|(
name|nic
operator|->
name|node
argument_list|,
name|bgx
argument_list|,
name|lmac
argument_list|,
name|mbx
operator|.
name|mac
operator|.
name|mac_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_SET_MAX_FRS
case|:
name|ret
operator|=
name|nic_update_hw_frs
argument_list|(
name|nic
argument_list|,
name|mbx
operator|.
name|frs
operator|.
name|max_frs
argument_list|,
name|mbx
operator|.
name|frs
operator|.
name|vf_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_CPI_CFG
case|:
name|nic_config_cpi
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
operator|.
name|cpi_cfg
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|VNIC_RSS_SUPPORT
case|case
name|NIC_MBOX_MSG_RSS_SIZE
case|:
name|nic_send_rss_size
argument_list|(
name|nic
argument_list|,
name|vf
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
case|case
name|NIC_MBOX_MSG_RSS_CFG
case|:
case|case
name|NIC_MBOX_MSG_RSS_CFG_CONT
case|:
name|nic_config_rss
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
operator|.
name|rss_cfg
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|NIC_MBOX_MSG_CFG_DONE
case|:
comment|/* Last message of VF config msg sequence */
name|nic
operator|->
name|vf_enabled
index|[
name|vf
index|]
operator|=
name|true
expr_stmt|;
goto|goto
name|unlock
goto|;
case|case
name|NIC_MBOX_MSG_SHUTDOWN
case|:
comment|/* First msg in VF teardown sequence */
name|nic
operator|->
name|vf_enabled
index|[
name|vf
index|]
operator|=
name|false
expr_stmt|;
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
if|if
condition|(
name|vf
operator|>=
name|nic
operator|->
name|num_vf_en
condition|)
name|nic
operator|->
name|sqs_used
index|[
name|vf
operator|-
name|nic
operator|->
name|num_vf_en
index|]
operator|=
name|false
expr_stmt|;
name|nic
operator|->
name|pqs_vf
index|[
name|vf
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
case|case
name|NIC_MBOX_MSG_ALLOC_SQS
case|:
name|nic_alloc_sqs
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
operator|.
name|sqs_alloc
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
case|case
name|NIC_MBOX_MSG_NICVF_PTR
case|:
name|nic
operator|->
name|nicvf
index|[
name|vf
index|]
operator|=
name|mbx
operator|.
name|nicvf
operator|.
name|nicvf
expr_stmt|;
break|break;
case|case
name|NIC_MBOX_MSG_PNICVF_PTR
case|:
name|nic_send_pnicvf
argument_list|(
name|nic
argument_list|,
name|vf
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
case|case
name|NIC_MBOX_MSG_SNICVF_PTR
case|:
name|nic_send_snicvf
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
operator|.
name|nicvf
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
endif|#
directive|endif
case|case
name|NIC_MBOX_MSG_BGX_STATS
case|:
name|nic_get_bgx_stats
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
operator|.
name|bgx_stats
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
case|case
name|NIC_MBOX_MSG_LOOPBACK
case|:
name|ret
operator|=
name|nic_config_loopback
argument_list|(
name|nic
argument_list|,
operator|&
name|mbx
operator|.
name|lbk
argument_list|)
expr_stmt|;
break|break;
default|default:
name|dev_err
argument_list|(
operator|&
name|nic
operator|->
name|pdev
operator|->
name|dev
argument_list|,
literal|"Invalid msg from VF%d, msg 0x%x\n"
argument_list|,
name|vf
argument_list|,
name|mbx
operator|.
name|msg
operator|.
name|msg
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ret
condition|)
name|nic_mbx_send_ack
argument_list|(
name|nic
argument_list|,
name|vf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mbx
operator|.
name|msg
operator|.
name|msg
operator|!=
name|NIC_MBOX_MSG_READY
condition|)
name|nic_mbx_send_nack
argument_list|(
name|nic
argument_list|,
name|vf
argument_list|)
expr_stmt|;
name|unlock
label|:
name|nic
operator|->
name|mbx_lock
index|[
name|vf
index|]
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nic_mbx_intr_handler
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|mbx
parameter_list|)
block|{
name|u64
name|intr
decl_stmt|;
name|u8
name|vf
decl_stmt|,
name|vf_per_mbx_reg
init|=
literal|64
decl_stmt|;
name|intr
operator|=
name|nic_reg_read
argument_list|(
name|nic
argument_list|,
name|NIC_PF_MAILBOX_INT
operator|+
operator|(
name|mbx
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|dev_dbg
argument_list|(
operator|&
name|nic
operator|->
name|pdev
operator|->
name|dev
argument_list|,
literal|"PF interrupt Mbox%d 0x%llx\n"
argument_list|,
name|mbx
argument_list|,
name|intr
argument_list|)
expr_stmt|;
for|for
control|(
name|vf
operator|=
literal|0
init|;
name|vf
operator|<
name|vf_per_mbx_reg
condition|;
name|vf
operator|++
control|)
block|{
if|if
condition|(
name|intr
operator|&
operator|(
literal|1ULL
operator|<<
name|vf
operator|)
condition|)
block|{
name|dev_dbg
argument_list|(
operator|&
name|nic
operator|->
name|pdev
operator|->
name|dev
argument_list|,
literal|"Intr from VF %d\n"
argument_list|,
name|vf
operator|+
operator|(
name|mbx
operator|*
name|vf_per_mbx_reg
operator|)
argument_list|)
expr_stmt|;
name|nic_handle_mbx_intr
argument_list|(
name|nic
argument_list|,
name|vf
operator|+
operator|(
name|mbx
operator|*
name|vf_per_mbx_reg
operator|)
argument_list|)
expr_stmt|;
name|nic_clear_mbx_intr
argument_list|(
name|nic
argument_list|,
name|vf
argument_list|,
name|mbx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|irqreturn_t
name|nic_mbx0_intr_handler
parameter_list|(
name|int
name|irq
parameter_list|,
name|void
modifier|*
name|nic_irq
parameter_list|)
block|{
name|struct
name|nicpf
modifier|*
name|nic
init|=
operator|(
expr|struct
name|nicpf
operator|*
operator|)
name|nic_irq
decl_stmt|;
name|nic_mbx_intr_handler
argument_list|(
name|nic
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|IRQ_HANDLED
return|;
block|}
end_function

begin_function
specifier|static
name|irqreturn_t
name|nic_mbx1_intr_handler
parameter_list|(
name|int
name|irq
parameter_list|,
name|void
modifier|*
name|nic_irq
parameter_list|)
block|{
name|struct
name|nicpf
modifier|*
name|nic
init|=
operator|(
expr|struct
name|nicpf
operator|*
operator|)
name|nic_irq
decl_stmt|;
name|nic_mbx_intr_handler
argument_list|(
name|nic
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|IRQ_HANDLED
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nic_enable_msix
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|nic
operator|->
name|num_vec
operator|=
name|NIC_PF_MSIX_VECTORS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nic
operator|->
name|num_vec
condition|;
name|i
operator|++
control|)
name|nic
operator|->
name|msix_entries
index|[
name|i
index|]
operator|.
name|entry
operator|=
name|i
expr_stmt|;
name|ret
operator|=
name|pci_enable_msix
argument_list|(
name|nic
operator|->
name|pdev
argument_list|,
name|nic
operator|->
name|msix_entries
argument_list|,
name|nic
operator|->
name|num_vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|nic
operator|->
name|pdev
operator|->
name|dev
argument_list|,
literal|"Request for #%d msix vectors failed\n"
argument_list|,
name|nic
operator|->
name|num_vec
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|nic
operator|->
name|msix_enabled
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nic_disable_msix
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
if|if
condition|(
name|nic
operator|->
name|msix_enabled
condition|)
block|{
name|pci_disable_msix
argument_list|(
name|nic
operator|->
name|pdev
argument_list|)
expr_stmt|;
name|nic
operator|->
name|msix_enabled
operator|=
literal|0
expr_stmt|;
name|nic
operator|->
name|num_vec
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nic_free_all_interrupts
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|irq
decl_stmt|;
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
name|nic
operator|->
name|num_vec
condition|;
name|irq
operator|++
control|)
block|{
if|if
condition|(
name|nic
operator|->
name|irq_allocated
index|[
name|irq
index|]
condition|)
name|free_irq
argument_list|(
name|nic
operator|->
name|msix_entries
index|[
name|irq
index|]
operator|.
name|vector
argument_list|,
name|nic
argument_list|)
expr_stmt|;
name|nic
operator|->
name|irq_allocated
index|[
name|irq
index|]
operator|=
name|false
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nic_register_interrupts
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* Enable MSI-X */
name|ret
operator|=
name|nic_enable_msix
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* Register mailbox interrupt handlers */
name|ret
operator|=
name|request_irq
argument_list|(
name|nic
operator|->
name|msix_entries
index|[
name|NIC_PF_INTR_ID_MBOX0
index|]
operator|.
name|vector
argument_list|,
name|nic_mbx0_intr_handler
argument_list|,
literal|0
argument_list|,
literal|"NIC Mbox0"
argument_list|,
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|fail
goto|;
name|nic
operator|->
name|irq_allocated
index|[
name|NIC_PF_INTR_ID_MBOX0
index|]
operator|=
name|true
expr_stmt|;
name|ret
operator|=
name|request_irq
argument_list|(
name|nic
operator|->
name|msix_entries
index|[
name|NIC_PF_INTR_ID_MBOX1
index|]
operator|.
name|vector
argument_list|,
name|nic_mbx1_intr_handler
argument_list|,
literal|0
argument_list|,
literal|"NIC Mbox1"
argument_list|,
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|fail
goto|;
name|nic
operator|->
name|irq_allocated
index|[
name|NIC_PF_INTR_ID_MBOX1
index|]
operator|=
name|true
expr_stmt|;
comment|/* Enable mailbox interrupt */
name|nic_enable_mbx_intr
argument_list|(
name|nic
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|dev_err
argument_list|(
operator|&
name|nic
operator|->
name|pdev
operator|->
name|dev
argument_list|,
literal|"Request irq failed\n"
argument_list|)
expr_stmt|;
name|nic_free_all_interrupts
argument_list|(
name|nic
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nic_unregister_interrupts
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
name|nic_free_all_interrupts
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|nic_disable_msix
argument_list|(
name|nic
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
end_ifdef

begin_function
name|int
name|nic_num_sqs_en
parameter_list|(
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|,
name|int
name|vf_en
parameter_list|)
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|,
name|sqs_per_vf
init|=
name|MAX_SQS_PER_VF_SINGLE_NODE
decl_stmt|;
name|u16
name|total_vf
decl_stmt|;
comment|/* Check if its a multi-node environment */
if|if
condition|(
name|nr_node_ids
operator|>
literal|1
condition|)
name|sqs_per_vf
operator|=
name|MAX_SQS_PER_VF
expr_stmt|;
name|pos
operator|=
name|pci_find_ext_capability
argument_list|(
name|nic
operator|->
name|pdev
argument_list|,
name|PCI_EXT_CAP_ID_SRIOV
argument_list|)
expr_stmt|;
name|pci_read_config_word
argument_list|(
name|nic
operator|->
name|pdev
argument_list|,
operator|(
name|pos
operator|+
name|PCI_SRIOV_TOTAL_VF
operator|)
argument_list|,
operator|&
name|total_vf
argument_list|)
expr_stmt|;
return|return
name|min
argument_list|(
name|total_vf
operator|-
name|vf_en
argument_list|,
name|vf_en
operator|*
name|sqs_per_vf
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|nic_sriov_configure
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|num_vfs_requested
parameter_list|)
block|{
name|struct
name|nicpf
modifier|*
name|nic
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|int
name|vf_en
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|nic
operator|->
name|num_vf_en
operator|==
name|num_vfs_requested
condition|)
return|return
name|num_vfs_requested
return|;
if|if
condition|(
name|nic
operator|->
name|flags
operator|&
name|NIC_SRIOV_ENABLED
condition|)
block|{
name|nic
operator|->
name|flags
operator|&=
operator|~
name|NIC_SRIOV_ENABLED
expr_stmt|;
block|}
name|nic
operator|->
name|num_vf_en
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|num_vfs_requested
operator|>
name|MAX_NUM_VFS_SUPPORTED
operator|||
name|num_vfs_requested
operator|<
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|num_vfs_requested
condition|)
block|{
name|vf_en
operator|=
name|num_vfs_requested
expr_stmt|;
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
name|nic
operator|->
name|num_sqs_en
operator|=
name|nic_num_sqs_en
argument_list|(
name|nic
argument_list|,
name|num_vfs_requested
argument_list|)
expr_stmt|;
name|vf_en
operator|+=
name|nic
operator|->
name|num_sqs_en
expr_stmt|;
endif|#
directive|endif
name|nic
operator|->
name|num_vf_en
operator|=
name|num_vfs_requested
expr_stmt|;
name|nic
operator|->
name|flags
operator||=
name|NIC_SRIOV_ENABLED
expr_stmt|;
block|}
return|return
name|num_vfs_requested
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nic_sriov_init
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|struct
name|nicpf
modifier|*
name|nic
parameter_list|)
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|vf_en
decl_stmt|;
name|int
name|err
decl_stmt|;
name|u16
name|total_vf_cnt
decl_stmt|;
name|pos
operator|=
name|pci_find_ext_capability
argument_list|(
name|pdev
argument_list|,
name|PCI_EXT_CAP_ID_SRIOV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pos
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"SRIOV capability is not found in PCIe config space\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
name|pci_read_config_word
argument_list|(
name|pdev
argument_list|,
operator|(
name|pos
operator|+
name|PCI_SRIOV_TOTAL_VF
operator|)
argument_list|,
operator|&
name|total_vf_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_vf_cnt
operator|<
name|nic
operator|->
name|num_vf_en
condition|)
name|nic
operator|->
name|num_vf_en
operator|=
name|total_vf_cnt
expr_stmt|;
if|if
condition|(
operator|!
name|total_vf_cnt
condition|)
return|return
literal|0
return|;
name|vf_en
operator|=
name|nic
operator|->
name|num_vf_en
expr_stmt|;
ifdef|#
directive|ifdef
name|VNIC_MULTI_QSET_SUPPORT
name|nic
operator|->
name|num_sqs_en
operator|=
name|nic_num_sqs_en
argument_list|(
name|nic
argument_list|,
name|nic
operator|->
name|num_vf_en
argument_list|)
expr_stmt|;
name|vf_en
operator|+=
name|nic
operator|->
name|num_sqs_en
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"SRIOV enable failed, num VF is %d\n"
argument_list|,
name|vf_en
argument_list|)
expr_stmt|;
name|nic
operator|->
name|num_vf_en
operator|=
literal|0
expr_stmt|;
return|return
name|err
return|;
block|}
name|dev_info
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"SRIOV enabled, number of VF available %d\n"
argument_list|,
name|vf_en
argument_list|)
expr_stmt|;
name|nic
operator|->
name|flags
operator||=
name|NIC_SRIOV_ENABLED
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Poll for BGX LMAC link status and update corresponding VF  * if there is a change, valid only if internal L2 switch  * is not present otherwise VF link is always treated as up  */
end_comment

begin_function
specifier|static
name|void
name|nic_poll_for_link
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
block|{
name|union
name|nic_mbx
name|mbx
init|=
block|{}
decl_stmt|;
name|struct
name|nicpf
modifier|*
name|nic
decl_stmt|;
name|struct
name|bgx_link_status
name|link
decl_stmt|;
name|u8
name|vf
decl_stmt|,
name|bgx
decl_stmt|,
name|lmac
decl_stmt|;
name|nic
operator|=
name|container_of
argument_list|(
name|work
argument_list|,
expr|struct
name|nicpf
argument_list|,
name|dwork
operator|.
name|work
argument_list|)
expr_stmt|;
name|mbx
operator|.
name|link_status
operator|.
name|msg
operator|=
name|NIC_MBOX_MSG_BGX_LINK_CHANGE
expr_stmt|;
for|for
control|(
name|vf
operator|=
literal|0
init|;
name|vf
operator|<
name|nic
operator|->
name|num_vf_en
condition|;
name|vf
operator|++
control|)
block|{
comment|/* Poll only if VF is UP */
if|if
condition|(
operator|!
name|nic
operator|->
name|vf_enabled
index|[
name|vf
index|]
condition|)
continue|continue;
comment|/* Get BGX, LMAC indices for the VF */
name|bgx
operator|=
name|NIC_GET_BGX_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|vf
index|]
argument_list|)
expr_stmt|;
name|lmac
operator|=
name|NIC_GET_LMAC_FROM_VF_LMAC_MAP
argument_list|(
name|nic
operator|->
name|vf_lmac_map
index|[
name|vf
index|]
argument_list|)
expr_stmt|;
comment|/* Get interface link status */
name|bgx_get_lmac_link_state
argument_list|(
name|nic
operator|->
name|node
argument_list|,
name|bgx
argument_list|,
name|lmac
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
comment|/* Inform VF only if link status changed */
if|if
condition|(
name|nic
operator|->
name|link
index|[
name|vf
index|]
operator|==
name|link
operator|.
name|link_up
condition|)
continue|continue;
if|if
condition|(
operator|!
name|nic
operator|->
name|mbx_lock
index|[
name|vf
index|]
condition|)
block|{
name|nic
operator|->
name|link
index|[
name|vf
index|]
operator|=
name|link
operator|.
name|link_up
expr_stmt|;
name|nic
operator|->
name|duplex
index|[
name|vf
index|]
operator|=
name|link
operator|.
name|duplex
expr_stmt|;
name|nic
operator|->
name|speed
index|[
name|vf
index|]
operator|=
name|link
operator|.
name|speed
expr_stmt|;
comment|/* Send a mbox message to VF with current link status */
name|mbx
operator|.
name|link_status
operator|.
name|link_up
operator|=
name|link
operator|.
name|link_up
expr_stmt|;
name|mbx
operator|.
name|link_status
operator|.
name|duplex
operator|=
name|link
operator|.
name|duplex
expr_stmt|;
name|mbx
operator|.
name|link_status
operator|.
name|speed
operator|=
name|link
operator|.
name|speed
expr_stmt|;
name|nic_send_msg_to_vf
argument_list|(
name|nic
argument_list|,
name|vf
argument_list|,
operator|&
name|mbx
argument_list|)
expr_stmt|;
block|}
block|}
name|queue_delayed_work
argument_list|(
name|nic
operator|->
name|check_link
argument_list|,
operator|&
name|nic
operator|->
name|dwork
argument_list|,
name|HZ
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nic_probe
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
specifier|const
name|struct
name|pci_device_id
modifier|*
name|ent
parameter_list|)
block|{
name|struct
name|device
modifier|*
name|dev
init|=
operator|&
name|pdev
operator|->
name|dev
decl_stmt|;
name|struct
name|nicpf
modifier|*
name|nic
decl_stmt|;
name|int
name|err
decl_stmt|;
name|BUILD_BUG_ON
argument_list|(
sizeof|sizeof
argument_list|(
expr|union
name|nic_mbx
argument_list|)
operator|>
literal|16
argument_list|)
expr_stmt|;
name|nic
operator|=
name|devm_kzalloc
argument_list|(
name|dev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nic
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nic
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|nic
argument_list|)
expr_stmt|;
name|nic
operator|->
name|pdev
operator|=
name|pdev
expr_stmt|;
name|err
operator|=
name|pci_enable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to enable PCI device\n"
argument_list|)
expr_stmt|;
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|pci_request_regions
argument_list|(
name|pdev
argument_list|,
name|DRV_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
name|dev
argument_list|,
literal|"PCI request regions failed 0x%x\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_disable_device
goto|;
block|}
name|err
operator|=
name|pci_set_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|48
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
name|dev
argument_list|,
literal|"Unable to get usable DMA configuration\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_release_regions
goto|;
block|}
name|err
operator|=
name|pci_set_consistent_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|48
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
name|dev
argument_list|,
literal|"Unable to get 48-bit DMA for consistent allocations\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_release_regions
goto|;
block|}
comment|/* MAP PF's configuration registers */
name|nic
operator|->
name|reg_base
operator|=
name|pcim_iomap
argument_list|(
name|pdev
argument_list|,
name|PCI_CFG_REG_BAR_NUM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nic
operator|->
name|reg_base
condition|)
block|{
name|dev_err
argument_list|(
name|dev
argument_list|,
literal|"Cannot map config register space, aborting\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_release_regions
goto|;
block|}
name|pci_read_config_byte
argument_list|(
name|pdev
argument_list|,
name|PCI_REVISION_ID
argument_list|,
operator|&
name|nic
operator|->
name|rev_id
argument_list|)
expr_stmt|;
name|nic
operator|->
name|node
operator|=
name|nic_get_node_id
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
comment|/* By default set NIC in TNS bypass mode */
name|nic
operator|->
name|flags
operator|&=
operator|~
name|NIC_TNS_ENABLED
expr_stmt|;
name|nic_set_lmac_vf_mapping
argument_list|(
name|nic
argument_list|)
expr_stmt|;
comment|/* Initialize hardware */
name|nic_init_hw
argument_list|(
name|nic
argument_list|)
expr_stmt|;
comment|/* Set RSS TBL size for each VF */
name|nic
operator|->
name|rss_ind_tbl_size
operator|=
name|NIC_MAX_RSS_IDR_TBL_SIZE
expr_stmt|;
comment|/* Register interrupts */
name|err
operator|=
name|nic_register_interrupts
argument_list|(
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_release_regions
goto|;
comment|/* Configure SRIOV */
name|err
operator|=
name|nic_sriov_init
argument_list|(
name|pdev
argument_list|,
name|nic
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_unregister_interrupts
goto|;
if|if
condition|(
name|nic
operator|->
name|flags
operator|&
name|NIC_TNS_ENABLED
condition|)
return|return
literal|0
return|;
comment|/* Register a physical link status poll fn() */
name|nic
operator|->
name|check_link
operator|=
name|alloc_workqueue
argument_list|(
literal|"check_link_status"
argument_list|,
name|WQ_UNBOUND
operator||
name|WQ_MEM_RECLAIM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nic
operator|->
name|check_link
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_disable_sriov
goto|;
block|}
name|INIT_DELAYED_WORK
argument_list|(
operator|&
name|nic
operator|->
name|dwork
argument_list|,
name|nic_poll_for_link
argument_list|)
expr_stmt|;
name|queue_delayed_work
argument_list|(
name|nic
operator|->
name|check_link
argument_list|,
operator|&
name|nic
operator|->
name|dwork
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_disable_sriov
label|:
name|err_unregister_interrupts
label|:
name|nic_unregister_interrupts
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|err_release_regions
label|:
name|pci_release_regions
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|err_disable_device
label|:
name|pci_disable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nic_remove
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|struct
name|nicpf
modifier|*
name|nic
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
if|if
condition|(
name|nic
operator|->
name|check_link
condition|)
block|{
comment|/* Destroy work Queue */
name|cancel_delayed_work
argument_list|(
operator|&
name|nic
operator|->
name|dwork
argument_list|)
expr_stmt|;
name|flush_workqueue
argument_list|(
name|nic
operator|->
name|check_link
argument_list|)
expr_stmt|;
name|destroy_workqueue
argument_list|(
name|nic
operator|->
name|check_link
argument_list|)
expr_stmt|;
block|}
name|nic_unregister_interrupts
argument_list|(
name|nic
argument_list|)
expr_stmt|;
name|pci_release_regions
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|pci_disable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|pci_driver
name|nic_driver
init|=
block|{
operator|.
name|name
operator|=
name|DRV_NAME
block|,
operator|.
name|id_table
operator|=
name|nic_id_table
block|,
operator|.
name|probe
operator|=
name|nic_probe
block|,
operator|.
name|remove
operator|=
name|nic_remove
block|,
operator|.
name|sriov_configure
operator|=
name|nic_sriov_configure
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|__init
name|nic_init_module
parameter_list|(
name|void
parameter_list|)
block|{
name|pr_info
argument_list|(
literal|"%s, ver %s\n"
argument_list|,
name|DRV_NAME
argument_list|,
name|DRV_VERSION
argument_list|)
expr_stmt|;
return|return
name|pci_register_driver
argument_list|(
operator|&
name|nic_driver
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__exit
name|nic_cleanup_module
parameter_list|(
name|void
parameter_list|)
block|{
name|pci_unregister_driver
argument_list|(
operator|&
name|nic_driver
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|module_init
argument_list|(
name|nic_init_module
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_exit
argument_list|(
name|nic_cleanup_module
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

