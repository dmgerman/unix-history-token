begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Landon Fuller<landon@landonf.org>  * Copyright (c) 2017 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by Landon Fuller  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Broadcom BHND PCI/PCIe-Gen1 PCI-Host Bridge.  *   * This driver handles all interactions with PCI bridge cores operating in  * endpoint mode.  *   * Host-level PCI operations are handled at the bhndb bridge level by the  * bhndb_pci driver.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhnd.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/chipc/chipc.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/chipc/chipcreg.h>
end_include

begin_include
include|#
directive|include
file|"bhnd_pcireg.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_pci_hostbvar.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bhnd_device_quirk
name|bhnd_pci_quirks
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bhnd_device_quirk
name|bhnd_pcie_quirks
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Device driver work-around variations */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|BHND_PCI_WAR_ATTACH
block|,
comment|/**< apply attach workarounds */
name|BHND_PCI_WAR_RESUME
block|,
comment|/**< apply resume workarounds */
name|BHND_PCI_WAR_SUSPEND
block|,
comment|/**< apply suspend workarounds */
name|BHND_PCI_WAR_DETACH
comment|/**< apply detach workarounds */
block|}
name|bhnd_pci_war_state
typedef|;
end_typedef

begin_function_decl
specifier|static
name|int
name|bhnd_pci_wars_early_once
parameter_list|(
name|struct
name|bhnd_pcihb_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_pci_wars_hwup
parameter_list|(
name|struct
name|bhnd_pcihb_softc
modifier|*
name|sc
parameter_list|,
name|bhnd_pci_war_state
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_pci_wars_hwdown
parameter_list|(
name|struct
name|bhnd_pcihb_softc
modifier|*
name|sc
parameter_list|,
name|bhnd_pci_war_state
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * device/quirk tables  */
end_comment

begin_define
define|#
directive|define
name|BHND_PCI_DEV
parameter_list|(
name|_core
parameter_list|,
name|_quirks
parameter_list|)
define|\
value|BHND_DEVICE(BCM, _core, NULL, _quirks, BHND_DF_HOSTB)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bhnd_device
name|bhnd_pci_devs
index|[]
init|=
block|{
name|BHND_PCI_DEV
argument_list|(
name|PCI
argument_list|,
name|bhnd_pci_quirks
argument_list|)
block|,
name|BHND_PCI_DEV
argument_list|(
name|PCIE
argument_list|,
name|bhnd_pcie_quirks
argument_list|)
block|,
name|BHND_DEVICE_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bhnd_device_quirk
name|bhnd_pci_quirks
index|[]
init|=
block|{
comment|/* core revision quirks */
name|BHND_CORE_QUIRK
argument_list|(
name|HWREV_ANY
argument_list|,
name|BHND_PCI_QUIRK_SBTOPCI2_PREF_BURST
argument_list|)
block|,
name|BHND_CORE_QUIRK
argument_list|(
name|HWREV_GTE
argument_list|(
literal|11
argument_list|)
argument_list|,
name|BHND_PCI_QUIRK_SBTOPCI2_READMULTI
operator||
name|BHND_PCI_QUIRK_CLKRUN_DSBL
argument_list|)
block|,
comment|/* BCM4321CB2 boards that require 960ns latency timer override */
name|BHND_BOARD_QUIRK
argument_list|(
name|BCM4321CB2
argument_list|,
name|BHND_PCI_QUIRK_960NS_LATTIM_OVR
argument_list|)
block|,
name|BHND_BOARD_QUIRK
argument_list|(
name|BCM4321CB2_AG
argument_list|,
name|BHND_PCI_QUIRK_960NS_LATTIM_OVR
argument_list|)
block|,
name|BHND_DEVICE_QUIRK_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bhnd_device_quirk
name|bhnd_pcie_quirks
index|[]
init|=
block|{
comment|/* core revision quirks */
name|BHND_CORE_QUIRK
argument_list|(
name|HWREV_EQ
argument_list|(
literal|0
argument_list|)
argument_list|,
name|BHND_PCIE_QUIRK_SDR9_L0s_HANG
argument_list|)
block|,
name|BHND_CORE_QUIRK
argument_list|(
name|HWREV_RANGE
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|BHND_PCIE_QUIRK_UR_STATUS_FIX
argument_list|)
block|,
name|BHND_CORE_QUIRK
argument_list|(
name|HWREV_EQ
argument_list|(
literal|1
argument_list|)
argument_list|,
name|BHND_PCIE_QUIRK_PCIPM_REQEN
argument_list|)
block|,
name|BHND_CORE_QUIRK
argument_list|(
name|HWREV_RANGE
argument_list|(
literal|3
argument_list|,
literal|5
argument_list|)
argument_list|,
name|BHND_PCIE_QUIRK_ASPM_OVR
operator||
name|BHND_PCIE_QUIRK_SDR9_POLARITY
operator||
name|BHND_PCIE_QUIRK_SDR9_NO_FREQRETRY
argument_list|)
block|,
name|BHND_CORE_QUIRK
argument_list|(
name|HWREV_LTE
argument_list|(
literal|6
argument_list|)
argument_list|,
name|BHND_PCIE_QUIRK_L1_IDLE_THRESH
argument_list|)
block|,
name|BHND_CORE_QUIRK
argument_list|(
name|HWREV_GTE
argument_list|(
literal|6
argument_list|)
argument_list|,
name|BHND_PCIE_QUIRK_SPROM_L23_PCI_RESET
argument_list|)
block|,
name|BHND_CORE_QUIRK
argument_list|(
name|HWREV_EQ
argument_list|(
literal|7
argument_list|)
argument_list|,
name|BHND_PCIE_QUIRK_SERDES_NOPLLDOWN
argument_list|)
block|,
name|BHND_CORE_QUIRK
argument_list|(
name|HWREV_GTE
argument_list|(
literal|8
argument_list|)
argument_list|,
name|BHND_PCIE_QUIRK_L1_TIMER_PERF
argument_list|)
block|,
name|BHND_CORE_QUIRK
argument_list|(
name|HWREV_LTE
argument_list|(
literal|17
argument_list|)
argument_list|,
name|BHND_PCIE_QUIRK_MAX_MRRS_128
argument_list|)
block|,
comment|/* Apple boards on which BHND_BFL2_PCIEWAR_OVR should be assumed 	 * to be set. */
block|{
block|{
name|BHND_MATCH_BOARD_VENDOR
argument_list|(
name|PCI_VENDOR_APPLE
argument_list|)
block|,
name|BHND_MATCH_BOARD_REV
argument_list|(
name|HWREV_LTE
argument_list|(
literal|0x71
argument_list|)
argument_list|)
block|,
name|BHND_MATCH_SROMREV
argument_list|(
argument|EQ(
literal|4
argument|)
argument_list|)
block|}
block|,
name|BHND_PCIE_QUIRK_BFL2_PCIEWAR_EN
block|}
block|,
comment|/* Apple BCM4322 boards that require 700mV SerDes TX drive strength. */
block|{
block|{
name|BHND_MATCH_CHIP_ID
argument_list|(
name|BCM4322
argument_list|)
block|,
name|BHND_MATCH_BOARD
argument_list|(
name|PCI_VENDOR_APPLE
argument_list|,
name|BCM94322X9
argument_list|)
block|, }
block|,
name|BHND_PCIE_QUIRK_SERDES_TXDRV_700MV
block|}
block|,
comment|/* Apple BCM4331 board-specific quirks */
define|#
directive|define
name|BHND_A4331_QUIRK
parameter_list|(
name|_board
parameter_list|,
modifier|...
parameter_list|)
define|\
value|{{ BHND_MATCH_CHIP_ID(BCM4331),		\ 	    BHND_MATCH_BOARD(PCI_VENDOR_APPLE, _board) }, __VA_ARGS__ }
name|BHND_A4331_QUIRK
argument_list|(
name|BCM94331X19
argument_list|,
name|BHND_PCIE_QUIRK_SERDES_TXDRV_MAX
operator||
name|BHND_PCIE_QUIRK_DEFAULT_MRRS_512
argument_list|)
block|,
name|BHND_A4331_QUIRK
argument_list|(
name|BCM94331X28
argument_list|,
name|BHND_PCIE_QUIRK_SERDES_TXDRV_MAX
operator||
name|BHND_PCIE_QUIRK_DEFAULT_MRRS_512
argument_list|)
block|,
name|BHND_A4331_QUIRK
argument_list|(
name|BCM94331X28B
argument_list|,
name|BHND_PCIE_QUIRK_DEFAULT_MRRS_512
argument_list|)
block|,
name|BHND_A4331_QUIRK
argument_list|(
name|BCM94331X29B
argument_list|,
name|BHND_PCIE_QUIRK_SERDES_TXDRV_MAX
operator||
name|BHND_PCIE_QUIRK_DEFAULT_MRRS_512
argument_list|)
block|,
name|BHND_A4331_QUIRK
argument_list|(
name|BCM94331X19C
argument_list|,
name|BHND_PCIE_QUIRK_SERDES_TXDRV_MAX
operator||
name|BHND_PCIE_QUIRK_DEFAULT_MRRS_512
argument_list|)
block|,
name|BHND_A4331_QUIRK
argument_list|(
name|BCM94331X29D
argument_list|,
name|BHND_PCIE_QUIRK_DEFAULT_MRRS_512
argument_list|)
block|,
name|BHND_A4331_QUIRK
argument_list|(
name|BCM94331X33
argument_list|,
name|BHND_PCIE_QUIRK_DEFAULT_MRRS_512
argument_list|)
block|,
undef|#
directive|undef
name|BHND_A4331_QUIRK
name|BHND_DEVICE_QUIRK_END
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BHND_PCI_SOFTC
parameter_list|(
name|_sc
parameter_list|)
value|(&((_sc)->common))
end_define

begin_define
define|#
directive|define
name|BHND_PCI_READ_2
parameter_list|(
name|_sc
parameter_list|,
name|_reg
parameter_list|)
define|\
value|bhnd_bus_read_2(BHND_PCI_SOFTC(_sc)->mem_res, (_reg))
end_define

begin_define
define|#
directive|define
name|BHND_PCI_READ_4
parameter_list|(
name|_sc
parameter_list|,
name|_reg
parameter_list|)
define|\
value|bhnd_bus_read_4(BHND_PCI_SOFTC(_sc)->mem_res, (_reg))
end_define

begin_define
define|#
directive|define
name|BHND_PCI_WRITE_2
parameter_list|(
name|_sc
parameter_list|,
name|_reg
parameter_list|,
name|_val
parameter_list|)
define|\
value|bhnd_bus_write_2(BHND_PCI_SOFTC(_sc)->mem_res, (_reg), (_val))
end_define

begin_define
define|#
directive|define
name|BHND_PCI_WRITE_4
parameter_list|(
name|_sc
parameter_list|,
name|_reg
parameter_list|,
name|_val
parameter_list|)
define|\
value|bhnd_bus_write_4(BHND_PCI_SOFTC(_sc)->mem_res, (_reg), (_val))
end_define

begin_define
define|#
directive|define
name|BHND_PCI_PROTO_READ_4
parameter_list|(
name|_sc
parameter_list|,
name|_reg
parameter_list|)
define|\
value|bhnd_pcie_read_proto_reg(BHND_PCI_SOFTC(_sc), (_reg))
end_define

begin_define
define|#
directive|define
name|BHND_PCI_PROTO_WRITE_4
parameter_list|(
name|_sc
parameter_list|,
name|_reg
parameter_list|,
name|_val
parameter_list|)
define|\
value|bhnd_pcie_write_proto_reg(BHND_PCI_SOFTC(_sc), (_reg), (_val))
end_define

begin_define
define|#
directive|define
name|BHND_PCI_MDIO_READ
parameter_list|(
name|_sc
parameter_list|,
name|_phy
parameter_list|,
name|_reg
parameter_list|)
define|\
value|bhnd_pcie_mdio_read(BHND_PCI_SOFTC(_sc), (_phy), (_reg))
end_define

begin_define
define|#
directive|define
name|BHND_PCI_MDIO_WRITE
parameter_list|(
name|_sc
parameter_list|,
name|_phy
parameter_list|,
name|_reg
parameter_list|,
name|_val
parameter_list|)
define|\
value|bhnd_pcie_mdio_write(BHND_PCI_SOFTC(_sc), (_phy), (_reg), (_val))
end_define

begin_define
define|#
directive|define
name|BHND_PCI_MDIO_READ_EXT
parameter_list|(
name|_sc
parameter_list|,
name|_phy
parameter_list|,
name|_devaddr
parameter_list|,
name|_reg
parameter_list|)
define|\
value|bhnd_pcie_mdio_read_ext(BHND_PCI_SOFTC(_sc), (_phy), (_devaddr), (_reg))
end_define

begin_define
define|#
directive|define
name|BHND_PCI_MDIO_WRITE_EXT
parameter_list|(
name|_sc
parameter_list|,
name|_phy
parameter_list|,
name|_devaddr
parameter_list|,
name|_reg
parameter_list|,
name|_val
parameter_list|)
define|\
value|bhnd_pcie_mdio_write_ext(BHND_PCI_SOFTC(_sc), (_phy),		\ 	    (_devaddr), (_reg), (_val))
end_define

begin_define
define|#
directive|define
name|BPCI_REG_SET
parameter_list|(
name|_regv
parameter_list|,
name|_attr
parameter_list|,
name|_val
parameter_list|)
define|\
value|BHND_PCI_REG_SET((_regv), BHND_ ## _attr, (_val))
end_define

begin_define
define|#
directive|define
name|BPCI_REG_GET
parameter_list|(
name|_regv
parameter_list|,
name|_attr
parameter_list|)
define|\
value|BHND_PCI_REG_GET((_regv), BHND_ ## _attr)
end_define

begin_define
define|#
directive|define
name|BPCI_CMN_REG_SET
parameter_list|(
name|_regv
parameter_list|,
name|_attr
parameter_list|,
name|_val
parameter_list|)
define|\
value|BHND_PCI_CMN_REG_SET(BHND_PCI_SOFTC(_sc)->regfmt, (_regv),	\ 	    BHND_ ## _attr, (_val))
end_define

begin_define
define|#
directive|define
name|BPCI_CMN_REG_GET
parameter_list|(
name|_regv
parameter_list|,
name|_attr
parameter_list|)
define|\
value|BHND_PCI_CMN_REG_GET(BHND_PCI_SOFTC(_sc)->regfmt, (_regv),	\ 	    BHND_ ## _attr)
end_define

begin_function
specifier|static
name|int
name|bhnd_pci_hostb_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhnd_pcihb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|quirks
operator|=
name|bhnd_device_quirks
argument_list|(
name|dev
argument_list|,
name|bhnd_pci_devs
argument_list|,
sizeof|sizeof
argument_list|(
name|bhnd_pci_devs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the host PCI bridge device */
name|sc
operator|->
name|pci_dev
operator|=
name|bhnd_find_bridge_root
argument_list|(
name|dev
argument_list|,
name|devclass_find
argument_list|(
literal|"pci"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pci_dev
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"parent pci bridge device not found\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Common setup */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_pci_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Apply early single-shot work-arounds */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_pci_wars_early_once
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
comment|/* Apply attach/resume work-arounds */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_pci_wars_hwup
argument_list|(
name|sc
argument_list|,
name|BHND_PCI_WAR_ATTACH
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
name|bhnd_pci_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_pci_hostb_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhnd_pcihb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Apply suspend/detach work-arounds */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_pci_wars_hwdown
argument_list|(
name|sc
argument_list|,
name|BHND_PCI_WAR_DETACH
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|bhnd_pci_generic_detach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_pci_hostb_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhnd_pcihb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Apply suspend/detach work-arounds */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_pci_wars_hwdown
argument_list|(
name|sc
argument_list|,
name|BHND_PCI_WAR_SUSPEND
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|bhnd_pci_generic_suspend
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_pci_hostb_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhnd_pcihb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_pci_generic_resume
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Apply attach/resume work-arounds */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_pci_wars_hwup
argument_list|(
name|sc
argument_list|,
name|BHND_PCI_WAR_RESUME
argument_list|)
operator|)
condition|)
block|{
name|bhnd_pci_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Apply any hardware work-arounds that must be executed exactly once, early in  * the attach process.  *   * This must be called after core enumeration and discovery of all applicable  * quirks, but prior to probe/attach of any cores, parsing of  * SPROM, etc.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_pci_wars_early_once
parameter_list|(
name|struct
name|bhnd_pcihb_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Set PCI latency timer */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCI_QUIRK_960NS_LATTIM_OVR
condition|)
block|{
name|pci_write_config
argument_list|(
name|sc
operator|->
name|pci_dev
argument_list|,
name|PCIR_LATTIMER
argument_list|,
literal|0x20
comment|/* 960ns */
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Determine whether ASPM/CLKREQ should be forced on, or forced off. */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCIE_QUIRK_ASPM_OVR
condition|)
block|{
name|struct
name|bhnd_board_info
name|board
decl_stmt|;
name|bool
name|aspm_en
decl_stmt|;
comment|/* Fetch board info */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_read_board_info
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|board
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Check board flags */
name|aspm_en
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|board
operator|.
name|board_flags2
operator|&
name|BHND_BFL2_PCIEWAR_OVR
condition|)
name|aspm_en
operator|=
name|false
expr_stmt|;
comment|/* Early Apple devices did not (but should have) set 		 * BHND_BFL2_PCIEWAR_OVR in SPROM. */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCIE_QUIRK_BFL2_PCIEWAR_EN
condition|)
name|aspm_en
operator|=
name|false
expr_stmt|;
name|sc
operator|->
name|aspm_quirk_override
operator|.
name|aspm_en
operator|=
name|aspm_en
expr_stmt|;
block|}
comment|/* Determine correct polarity by observing the attach-time PCIe PHY 	 * link status. This is used later to reset/force the SerDes 	 * polarity */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCIE_QUIRK_SDR9_POLARITY
condition|)
block|{
name|uint32_t
name|st
decl_stmt|;
name|bool
name|inv
decl_stmt|;
name|st
operator|=
name|BHND_PCI_PROTO_READ_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_PLP_STATUSREG
argument_list|)
expr_stmt|;
name|inv
operator|=
operator|(
operator|(
name|st
operator|&
name|BHND_PCIE_PLP_POLARITY_INV
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|sc
operator|->
name|sdr9_quirk_polarity
operator|.
name|inv
operator|=
name|inv
expr_stmt|;
block|}
comment|/* Override maximum read request size */
if|if
condition|(
name|bhnd_get_class
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|==
name|BHND_DEVCLASS_PCIE
condition|)
block|{
name|int
name|msize
decl_stmt|;
name|msize
operator|=
literal|128
expr_stmt|;
comment|/* compatible with all PCIe-G1 core revisions */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCIE_QUIRK_DEFAULT_MRRS_512
condition|)
name|msize
operator|=
literal|512
expr_stmt|;
if|if
condition|(
name|pci_set_max_read_req
argument_list|(
name|sc
operator|->
name|pci_dev
argument_list|,
name|msize
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"set mrrs on non-PCIe device"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Apply any hardware workarounds that are required upon attach or resume  * of the bridge device.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_pci_wars_hwup
parameter_list|(
name|struct
name|bhnd_pcihb_softc
modifier|*
name|sc
parameter_list|,
name|bhnd_pci_war_state
name|state
parameter_list|)
block|{
comment|/* Note that the order here matters; these work-arounds 	 * should not be re-ordered without careful review of their 	 * interdependencies */
comment|/* Enable PCI prefetch/burst/readmulti flags */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCI_QUIRK_SBTOPCI2_PREF_BURST
operator|||
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCI_QUIRK_SBTOPCI2_READMULTI
condition|)
block|{
name|uint32_t
name|sbp2
decl_stmt|;
name|sbp2
operator|=
name|BHND_PCI_READ_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCI_SBTOPCI2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCI_QUIRK_SBTOPCI2_PREF_BURST
condition|)
name|sbp2
operator||=
operator|(
name|BHND_PCI_SBTOPCI_PREF
operator||
name|BHND_PCI_SBTOPCI_BURST
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCI_QUIRK_SBTOPCI2_READMULTI
condition|)
name|sbp2
operator||=
name|BHND_PCI_SBTOPCI_RC_READMULTI
expr_stmt|;
name|BHND_PCI_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCI_SBTOPCI2
argument_list|,
name|sbp2
argument_list|)
expr_stmt|;
block|}
comment|/* Disable PCI CLKRUN# */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCI_QUIRK_CLKRUN_DSBL
condition|)
block|{
name|uint32_t
name|ctl
decl_stmt|;
name|ctl
operator|=
name|BHND_PCI_READ_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCI_CLKRUN_CTL
argument_list|)
expr_stmt|;
name|ctl
operator||=
name|BHND_PCI_CLKRUN_DSBL
expr_stmt|;
name|BHND_PCI_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCI_CLKRUN_CTL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
block|}
comment|/* Enable TLP unmatched address handling work-around */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCIE_QUIRK_UR_STATUS_FIX
condition|)
block|{
name|uint32_t
name|wrs
decl_stmt|;
name|wrs
operator|=
name|BHND_PCI_PROTO_READ_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_TLP_WORKAROUNDSREG
argument_list|)
expr_stmt|;
name|wrs
operator||=
name|BHND_PCIE_TLP_WORKAROUND_URBIT
expr_stmt|;
name|BHND_PCI_PROTO_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_TLP_WORKAROUNDSREG
argument_list|,
name|wrs
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust SerDes CDR tuning to ensure that CDR is stable before sending 	 * data during L0s to L0 exit transitions. */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCIE_QUIRK_SDR9_L0s_HANG
condition|)
block|{
name|uint16_t
name|sdv
decl_stmt|;
comment|/* Set RX track/acquire timers to 2.064us/40.96us */
name|sdv
operator|=
name|BPCI_REG_SET
argument_list|(
literal|0
argument_list|,
name|PCIE_SDR9_RX_TIMER1_LKTRK
argument_list|,
operator|(
literal|2064
operator|/
literal|16
operator|)
argument_list|)
expr_stmt|;
name|sdv
operator|=
name|BPCI_REG_SET
argument_list|(
name|sdv
argument_list|,
name|PCIE_SDR9_RX_TIMER1_LKACQ
argument_list|,
operator|(
literal|40960
operator|/
literal|1024
operator|)
argument_list|)
expr_stmt|;
name|BHND_PCI_MDIO_WRITE
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_PHY_SDR9_TXRX
argument_list|,
name|BHND_PCIE_SDR9_RX_TIMER1
argument_list|,
name|sdv
argument_list|)
expr_stmt|;
comment|/* Apply CDR frequency workaround */
name|sdv
operator|=
name|BHND_PCIE_SDR9_RX_CDR_FREQ_OVR_EN
expr_stmt|;
name|sdv
operator|=
name|BPCI_REG_SET
argument_list|(
name|sdv
argument_list|,
name|PCIE_SDR9_RX_CDR_FREQ_OVR
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|BHND_PCI_MDIO_WRITE
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_PHY_SDR9_TXRX
argument_list|,
name|BHND_PCIE_SDR9_RX_CDR
argument_list|,
name|sdv
argument_list|)
expr_stmt|;
comment|/* Apply CDR BW tunings */
name|sdv
operator|=
literal|0
expr_stmt|;
name|sdv
operator|=
name|BPCI_REG_SET
argument_list|(
name|sdv
argument_list|,
name|PCIE_SDR9_RX_CDRBW_INTGTRK
argument_list|,
literal|0x2
argument_list|)
expr_stmt|;
name|sdv
operator|=
name|BPCI_REG_SET
argument_list|(
name|sdv
argument_list|,
name|PCIE_SDR9_RX_CDRBW_INTGACQ
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|sdv
operator|=
name|BPCI_REG_SET
argument_list|(
name|sdv
argument_list|,
name|PCIE_SDR9_RX_CDRBW_PROPTRK
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
name|sdv
operator|=
name|BPCI_REG_SET
argument_list|(
name|sdv
argument_list|,
name|PCIE_SDR9_RX_CDRBW_PROPACQ
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
name|BHND_PCI_MDIO_WRITE
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_PHY_SDR9_TXRX
argument_list|,
name|BHND_PCIE_SDR9_RX_CDRBW
argument_list|,
name|sdv
argument_list|)
expr_stmt|;
block|}
comment|/* Force correct SerDes polarity */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCIE_QUIRK_SDR9_POLARITY
condition|)
block|{
name|uint16_t
name|rxctl
decl_stmt|;
name|rxctl
operator|=
name|BHND_PCI_MDIO_READ
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_PHY_SDR9_TXRX
argument_list|,
name|BHND_PCIE_SDR9_RX_CTRL
argument_list|)
expr_stmt|;
name|rxctl
operator||=
name|BHND_PCIE_SDR9_RX_CTRL_FORCE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sdr9_quirk_polarity
operator|.
name|inv
condition|)
name|rxctl
operator||=
name|BHND_PCIE_SDR9_RX_CTRL_POLARITY_INV
expr_stmt|;
else|else
name|rxctl
operator|&=
operator|~
name|BHND_PCIE_SDR9_RX_CTRL_POLARITY_INV
expr_stmt|;
name|BHND_PCI_MDIO_WRITE
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_PHY_SDR9_TXRX
argument_list|,
name|BHND_PCIE_SDR9_RX_CTRL
argument_list|,
name|rxctl
argument_list|)
expr_stmt|;
block|}
comment|/* Disable startup retry on PLL frequency detection failure */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCIE_QUIRK_SDR9_NO_FREQRETRY
condition|)
block|{
name|uint16_t
name|pctl
decl_stmt|;
name|pctl
operator|=
name|BHND_PCI_MDIO_READ
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_PHY_SDR9_PLL
argument_list|,
name|BHND_PCIE_SDR9_PLL_CTRL
argument_list|)
expr_stmt|;
name|pctl
operator|&=
operator|~
name|BHND_PCIE_SDR9_PLL_CTRL_FREQDET_EN
expr_stmt|;
name|BHND_PCI_MDIO_WRITE
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_PHY_SDR9_PLL
argument_list|,
name|BHND_PCIE_SDR9_PLL_CTRL
argument_list|,
name|pctl
argument_list|)
expr_stmt|;
block|}
comment|/* Explicitly enable PCI-PM */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCIE_QUIRK_PCIPM_REQEN
condition|)
block|{
name|uint32_t
name|lcreg
decl_stmt|;
name|lcreg
operator|=
name|BHND_PCI_PROTO_READ_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_DLLP_LCREG
argument_list|)
expr_stmt|;
name|lcreg
operator||=
name|BHND_PCIE_DLLP_LCREG_PCIPM_EN
expr_stmt|;
name|BHND_PCI_PROTO_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_DLLP_LCREG
argument_list|,
name|lcreg
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust L1 timer to fix slow L1->L0 transitions */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCIE_QUIRK_L1_IDLE_THRESH
condition|)
block|{
name|uint32_t
name|pmt
decl_stmt|;
name|pmt
operator|=
name|BHND_PCI_PROTO_READ_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_DLLP_PMTHRESHREG
argument_list|)
expr_stmt|;
name|pmt
operator|=
name|BPCI_REG_SET
argument_list|(
name|pmt
argument_list|,
name|PCIE_L1THRESHOLDTIME
argument_list|,
name|BHND_PCIE_L1THRESHOLD_WARVAL
argument_list|)
expr_stmt|;
name|BHND_PCI_PROTO_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_DLLP_PMTHRESHREG
argument_list|,
name|pmt
argument_list|)
expr_stmt|;
block|}
comment|/* Extend L1 timer for better performance. 	 * TODO: We could enable/disable this on demand for better power 	 * savings if we tie this to HT clock request handling */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCIE_QUIRK_L1_TIMER_PERF
condition|)
block|{
name|uint32_t
name|pmt
decl_stmt|;
name|pmt
operator|=
name|BHND_PCI_PROTO_READ_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_DLLP_PMTHRESHREG
argument_list|)
expr_stmt|;
name|pmt
operator||=
name|BHND_PCIE_ASPMTIMER_EXTEND
expr_stmt|;
name|BHND_PCI_PROTO_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_DLLP_PMTHRESHREG
argument_list|,
name|pmt
argument_list|)
expr_stmt|;
block|}
comment|/* Override ASPM/ECPM settings in SPROM shadow and PCIER_LINK_CTL */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCIE_QUIRK_ASPM_OVR
condition|)
block|{
name|bus_size_t
name|reg
decl_stmt|;
name|uint16_t
name|cfg
decl_stmt|;
comment|/* Set ASPM L1/L0s flags in SPROM shadow */
name|reg
operator|=
name|BHND_PCIE_SPROM_SHADOW
operator|+
name|BHND_PCIE_SRSH_ASPM_OFFSET
expr_stmt|;
name|cfg
operator|=
name|BHND_PCI_READ_2
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aspm_quirk_override
operator|.
name|aspm_en
condition|)
name|cfg
operator||=
name|BHND_PCIE_SRSH_ASPM_ENB
expr_stmt|;
else|else
name|cfg
operator|&=
operator|~
name|BHND_PCIE_SRSH_ASPM_ENB
expr_stmt|;
name|BHND_PCI_WRITE_2
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
comment|/* Set ASPM/ECPM (CLKREQ) flags in PCIe link control register */
name|cfg
operator|=
name|pcie_read_config
argument_list|(
name|sc
operator|->
name|pci_dev
argument_list|,
name|PCIER_LINK_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aspm_quirk_override
operator|.
name|aspm_en
condition|)
name|cfg
operator||=
name|PCIEM_LINK_CTL_ASPMC
expr_stmt|;
else|else
name|cfg
operator|&=
operator|~
name|PCIEM_LINK_CTL_ASPMC
expr_stmt|;
name|cfg
operator|&=
operator|~
name|PCIEM_LINK_CTL_ECPM
expr_stmt|;
comment|/* CLKREQ# */
name|pcie_write_config
argument_list|(
name|sc
operator|->
name|pci_dev
argument_list|,
name|PCIER_LINK_CTL
argument_list|,
name|cfg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Set CLKREQ (ECPM) flags in SPROM shadow */
name|reg
operator|=
name|BHND_PCIE_SPROM_SHADOW
operator|+
name|BHND_PCIE_SRSH_CLKREQ_OFFSET_R5
expr_stmt|;
name|cfg
operator|=
name|BHND_PCI_READ_2
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aspm_quirk_override
operator|.
name|aspm_en
condition|)
name|cfg
operator||=
name|BHND_PCIE_SRSH_CLKREQ_ENB
expr_stmt|;
else|else
name|cfg
operator|&=
operator|~
name|BHND_PCIE_SRSH_CLKREQ_ENB
expr_stmt|;
name|BHND_PCI_WRITE_2
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
block|}
comment|/* Enable L23READY_EXIT_NOPRST if not already set in SPROM. */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCIE_QUIRK_SPROM_L23_PCI_RESET
condition|)
block|{
name|bus_size_t
name|reg
decl_stmt|;
name|uint16_t
name|cfg
decl_stmt|;
comment|/* Fetch the misc cfg flags from SPROM */
name|reg
operator|=
name|BHND_PCIE_SPROM_SHADOW
operator|+
name|BHND_PCIE_SRSH_PCIE_MISC_CONFIG
expr_stmt|;
name|cfg
operator|=
name|BHND_PCI_READ_2
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Write EXIT_NOPRST flag if not already set in SPROM */
if|if
condition|(
operator|!
operator|(
name|cfg
operator|&
name|BHND_PCIE_SRSH_L23READY_EXIT_NOPRST
operator|)
condition|)
block|{
name|cfg
operator||=
name|BHND_PCIE_SRSH_L23READY_EXIT_NOPRST
expr_stmt|;
name|BHND_PCI_WRITE_2
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Disable SerDes PLL down */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCIE_QUIRK_SERDES_NOPLLDOWN
condition|)
block|{
name|device_t
name|bhnd
decl_stmt|,
name|chipc
decl_stmt|;
name|bus_size_t
name|reg
decl_stmt|;
name|bhnd
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|chipc
operator|=
name|bhnd_bus_find_child
argument_list|(
name|bhnd
argument_list|,
name|BHND_DEVCLASS_CC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|chipc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"missing chipcommon device"
operator|)
argument_list|)
expr_stmt|;
comment|/* Write SerDes PLL disable flag to the ChipCommon core */
name|BHND_CHIPC_WRITE_CHIPCTRL
argument_list|(
name|chipc
argument_list|,
name|CHIPCTRL_4321_PLL_DOWN
argument_list|,
name|CHIPCTRL_4321_PLL_DOWN
argument_list|)
expr_stmt|;
comment|/* Clear SPROM shadow backdoor register */
name|reg
operator|=
name|BHND_PCIE_SPROM_SHADOW
operator|+
name|BHND_PCIE_SRSH_BD_OFFSET
expr_stmt|;
name|BHND_PCI_WRITE_2
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust TX drive strength and pre-emphasis coefficient */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCIE_QUIRK_SERDES_TXDRV_ADJUST
condition|)
block|{
name|uint16_t
name|txdrv
decl_stmt|;
comment|/* Fetch current TX driver parameters */
name|txdrv
operator|=
name|BHND_PCI_MDIO_READ_EXT
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_PHYADDR_SD
argument_list|,
name|BHND_PCIE_SD_REGS_TX0
argument_list|,
name|BHND_PCIE_SD_TX_DRIVER
argument_list|)
expr_stmt|;
comment|/* Set 700mV drive strength */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCIE_QUIRK_SERDES_TXDRV_700MV
condition|)
block|{
name|txdrv
operator|=
name|BPCI_REG_SET
argument_list|(
name|txdrv
argument_list|,
name|PCIE_SD_TX_DRIVER_P2_COEFF
argument_list|,
name|BHND_PCIE_APPLE_TX_P2_COEFF_700MV
argument_list|)
expr_stmt|;
name|txdrv
operator|=
name|BPCI_REG_SET
argument_list|(
name|txdrv
argument_list|,
name|PCIE_SD_TX_DRIVER_IDRIVER
argument_list|,
name|BHND_PCIE_APPLE_TX_IDRIVER_700MV
argument_list|)
expr_stmt|;
block|}
comment|/* ... or, set max drive strength */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCIE_QUIRK_SERDES_TXDRV_MAX
condition|)
block|{
name|txdrv
operator|=
name|BPCI_REG_SET
argument_list|(
name|txdrv
argument_list|,
name|PCIE_SD_TX_DRIVER_P2_COEFF
argument_list|,
name|BHND_PCIE_APPLE_TX_P2_COEFF_MAX
argument_list|)
expr_stmt|;
name|txdrv
operator|=
name|BPCI_REG_SET
argument_list|(
name|txdrv
argument_list|,
name|PCIE_SD_TX_DRIVER_IDRIVER
argument_list|,
name|BHND_PCIE_APPLE_TX_IDRIVER_MAX
argument_list|)
expr_stmt|;
block|}
name|BHND_PCI_MDIO_WRITE_EXT
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_PHYADDR_SD
argument_list|,
name|BHND_PCIE_SD_REGS_TX0
argument_list|,
name|BHND_PCIE_SD_TX_DRIVER
argument_list|,
name|txdrv
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Apply any hardware workarounds that are required upon detach or suspend  * of the bridge device.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_pci_wars_hwdown
parameter_list|(
name|struct
name|bhnd_pcihb_softc
modifier|*
name|sc
parameter_list|,
name|bhnd_pci_war_state
name|state
parameter_list|)
block|{
comment|/* Reduce L1 timer for better power savings. 	 * TODO: We could enable/disable this on demand for better power 	 * savings if we tie this to HT clock request handling */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCIE_QUIRK_L1_TIMER_PERF
condition|)
block|{
name|uint32_t
name|pmt
decl_stmt|;
name|pmt
operator|=
name|BHND_PCI_PROTO_READ_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_DLLP_PMTHRESHREG
argument_list|)
expr_stmt|;
name|pmt
operator|&=
operator|~
name|BHND_PCIE_ASPMTIMER_EXTEND
expr_stmt|;
name|BHND_PCI_PROTO_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_DLLP_PMTHRESHREG
argument_list|,
name|pmt
argument_list|)
expr_stmt|;
block|}
comment|/* Enable CLKREQ (ECPM). If suspending, also disable ASPM L1 entry */
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|BHND_PCIE_QUIRK_ASPM_OVR
condition|)
block|{
name|uint16_t
name|lcreg
decl_stmt|;
name|lcreg
operator|=
name|pcie_read_config
argument_list|(
name|sc
operator|->
name|pci_dev
argument_list|,
name|PCIER_LINK_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|lcreg
operator||=
name|PCIEM_LINK_CTL_ECPM
expr_stmt|;
comment|/* CLKREQ# */
if|if
condition|(
name|state
operator|==
name|BHND_PCI_WAR_SUSPEND
condition|)
name|lcreg
operator|&=
operator|~
name|PCIEM_LINK_CTL_ASPMC_L1
expr_stmt|;
name|pcie_write_config
argument_list|(
name|sc
operator|->
name|pci_dev
argument_list|,
name|PCIER_LINK_CTL
argument_list|,
name|lcreg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|bhnd_pci_hostb_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|bhnd_pci_hostb_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bhnd_pci_hostb_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bhnd_pci_hostb_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bhnd_pci_hostb_resume
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_1
argument_list|(
name|bhnd_hostb
argument_list|,
name|bhnd_pci_hostb_driver
argument_list|,
name|bhnd_pci_hostb_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bhnd_pcihb_softc
argument_list|)
argument_list|,
name|bhnd_pci_driver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|bhnd_pci_hostb
argument_list|,
name|bhnd
argument_list|,
name|bhnd_pci_hostb_driver
argument_list|,
name|bhnd_hostb_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|bhnd_pci_hostb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bhnd_pci_hostb
argument_list|,
name|bhnd
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bhnd_pci_hostb
argument_list|,
name|bhnd_pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

