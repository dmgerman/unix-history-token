begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Landon Fuller<landon@landonf.org>  * Copyright (c) 2016 Michael Zhilin<mizhka@gmail.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Broadcom ChipCommon driver.  *   * With the exception of some very early chipsets, the ChipCommon core  * has been included in all HND SoCs and chipsets based on the siba(4)   * and bcma(4) interconnects, providing a common interface to chipset   * identification, bus enumeration, UARTs, clocks, watchdog interrupts, GPIO,   * flash, etc.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhnd.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhndvar.h>
end_include

begin_include
include|#
directive|include
file|"chipcreg.h"
end_include

begin_include
include|#
directive|include
file|"chipcvar.h"
end_include

begin_include
include|#
directive|include
file|"chipc_private.h"
end_include

begin_decl_stmt
name|devclass_t
name|bhnd_chipc_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< bhnd(4) chipcommon device class */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bhnd_device_quirk
name|chipc_quirks
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Supported device identifiers */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bhnd_device
name|chipc_devices
index|[]
init|=
block|{
name|BHND_DEVICE
argument_list|(
name|CC
argument_list|,
name|NULL
argument_list|,
name|chipc_quirks
argument_list|)
block|,
name|BHND_DEVICE_END
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Device quirks table */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bhnd_device_quirk
name|chipc_quirks
index|[]
init|=
block|{
comment|/* core revision quirks */
name|BHND_CORE_QUIRK
argument_list|(
name|HWREV_GTE
argument_list|(
literal|32
argument_list|)
argument_list|,
name|CHIPC_QUIRK_SUPPORTS_SPROM
argument_list|)
block|,
name|BHND_CORE_QUIRK
argument_list|(
name|HWREV_GTE
argument_list|(
literal|35
argument_list|)
argument_list|,
name|CHIPC_QUIRK_SUPPORTS_CAP_EXT
argument_list|)
block|,
name|BHND_CORE_QUIRK
argument_list|(
name|HWREV_GTE
argument_list|(
literal|49
argument_list|)
argument_list|,
name|CHIPC_QUIRK_IPX_OTPLAYOUT_SIZE
argument_list|)
block|,
comment|/* 4706 variant quirks */
name|BHND_CORE_QUIRK
argument_list|(
name|HWREV_EQ
argument_list|(
literal|38
argument_list|)
argument_list|,
name|CHIPC_QUIRK_4706_NFLASH
argument_list|)
block|,
comment|/* BCM5357? */
name|BHND_CHIP_QUIRK
argument_list|(
literal|4706
argument_list|,
name|HWREV_ANY
argument_list|,
name|CHIPC_QUIRK_4706_NFLASH
argument_list|)
block|,
comment|/* 4331 quirks*/
name|BHND_CHIP_QUIRK
argument_list|(
literal|4331
argument_list|,
name|HWREV_ANY
argument_list|,
name|CHIPC_QUIRK_4331_EXTPA_MUX_SPROM
argument_list|)
block|,
name|BHND_PKG_QUIRK
argument_list|(
literal|4331
argument_list|,
name|TN
argument_list|,
name|CHIPC_QUIRK_4331_GPIO2_5_MUX_SPROM
argument_list|)
block|,
name|BHND_PKG_QUIRK
argument_list|(
literal|4331
argument_list|,
name|TNA0
argument_list|,
name|CHIPC_QUIRK_4331_GPIO2_5_MUX_SPROM
argument_list|)
block|,
name|BHND_PKG_QUIRK
argument_list|(
literal|4331
argument_list|,
name|TT
argument_list|,
name|CHIPC_QUIRK_4331_EXTPA2_MUX_SPROM
argument_list|)
block|,
comment|/* 4360 quirks */
name|BHND_CHIP_QUIRK
argument_list|(
literal|4352
argument_list|,
name|HWREV_LTE
argument_list|(
literal|2
argument_list|)
argument_list|,
name|CHIPC_QUIRK_4360_FEM_MUX_SPROM
argument_list|)
block|,
name|BHND_CHIP_QUIRK
argument_list|(
literal|43460
argument_list|,
name|HWREV_LTE
argument_list|(
literal|2
argument_list|)
argument_list|,
name|CHIPC_QUIRK_4360_FEM_MUX_SPROM
argument_list|)
block|,
name|BHND_CHIP_QUIRK
argument_list|(
literal|43462
argument_list|,
name|HWREV_LTE
argument_list|(
literal|2
argument_list|)
argument_list|,
name|CHIPC_QUIRK_4360_FEM_MUX_SPROM
argument_list|)
block|,
name|BHND_CHIP_QUIRK
argument_list|(
literal|43602
argument_list|,
name|HWREV_LTE
argument_list|(
literal|2
argument_list|)
argument_list|,
name|CHIPC_QUIRK_4360_FEM_MUX_SPROM
argument_list|)
block|,
name|BHND_DEVICE_QUIRK_END
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
specifier|const
struct|struct
name|chipc_hint
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|rman_res_t
name|base
decl_stmt|;
comment|/* relative to parent resource */
name|rman_res_t
name|size
decl_stmt|;
name|u_int
name|port
decl_stmt|;
comment|/* ignored if SYS_RES_IRQ */
name|u_int
name|region
decl_stmt|;
block|}
name|chipc_hints
index|[]
init|=
block|{
comment|// FIXME: cfg/spi port1.1 mapping on siba(4) SoCs
comment|/* device	unit	type		rid	base			size			port,region */
block|{
literal|"bhnd_nvram"
block|,
literal|0
block|,
name|SYS_RES_MEMORY
block|,
literal|0
block|,
name|CHIPC_SPROM_OTP
block|,
name|CHIPC_SPROM_OTP_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"uart"
block|,
literal|0
block|,
name|SYS_RES_MEMORY
block|,
literal|0
block|,
name|CHIPC_UART0_BASE
block|,
name|CHIPC_UART_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"uart"
block|,
literal|0
block|,
name|SYS_RES_IRQ
block|,
literal|0
block|,
literal|0
block|,
name|RM_MAX_END
block|}
block|,
block|{
literal|"uart"
block|,
literal|1
block|,
name|SYS_RES_MEMORY
block|,
literal|0
block|,
name|CHIPC_UART1_BASE
block|,
name|CHIPC_UART_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"uart"
block|,
literal|1
block|,
name|SYS_RES_IRQ
block|,
literal|0
block|,
literal|0
block|,
name|RM_MAX_END
block|}
block|,
block|{
literal|"spi"
block|,
literal|0
block|,
name|SYS_RES_MEMORY
block|,
literal|0
block|,
literal|0
block|,
name|RM_MAX_END
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"spi"
block|,
literal|0
block|,
name|SYS_RES_MEMORY
block|,
literal|1
block|,
name|CHIPC_SFLASH_BASE
block|,
name|CHIPC_SFLASH_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"cfi"
block|,
literal|0
block|,
name|SYS_RES_MEMORY
block|,
literal|0
block|,
literal|0
block|,
name|RM_MAX_END
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"cfi"
block|,
literal|0
block|,
name|SYS_RES_MEMORY
block|,
literal|1
block|,
name|CHIPC_SFLASH_BASE
block|,
name|CHIPC_SFLASH_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|}
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|chipc_try_activate_resource
parameter_list|(
name|struct
name|chipc_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|bool
name|req_direct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|chipc_read_caps
parameter_list|(
name|struct
name|chipc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|chipc_caps
modifier|*
name|caps
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bhnd_nvram_src_t
name|chipc_nvram_identify
parameter_list|(
name|struct
name|chipc_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|chipc_should_enable_sprom
parameter_list|(
name|struct
name|chipc_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|chipc_init_rman
parameter_list|(
name|struct
name|chipc_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chipc_free_rman
parameter_list|(
name|struct
name|chipc_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|rman
modifier|*
name|chipc_get_rman
parameter_list|(
name|struct
name|chipc_softc
modifier|*
name|sc
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* quirk and capability flag convenience macros */
end_comment

begin_define
define|#
directive|define
name|CHIPC_QUIRK
parameter_list|(
name|_sc
parameter_list|,
name|_name
parameter_list|)
define|\
value|((_sc)->quirks& CHIPC_QUIRK_ ## _name)
end_define

begin_define
define|#
directive|define
name|CHIPC_CAP
parameter_list|(
name|_sc
parameter_list|,
name|_name
parameter_list|)
define|\
value|((_sc)->caps._name)
end_define

begin_define
define|#
directive|define
name|CHIPC_ASSERT_QUIRK
parameter_list|(
name|_sc
parameter_list|,
name|name
parameter_list|)
define|\
value|KASSERT(CHIPC_QUIRK((_sc), name), ("quirk " __STRING(_name) " not set"))
end_define

begin_define
define|#
directive|define
name|CHIPC_ASSERT_CAP
parameter_list|(
name|_sc
parameter_list|,
name|name
parameter_list|)
define|\
value|KASSERT(CHIPC_CAP((_sc), name), ("capability " __STRING(_name) " not set"))
end_define

begin_function
specifier|static
name|int
name|chipc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_device
modifier|*
name|id
decl_stmt|;
name|id
operator|=
name|bhnd_device_lookup
argument_list|(
name|dev
argument_list|,
name|chipc_devices
argument_list|,
sizeof|sizeof
argument_list|(
name|chipc_devices
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bhnd_set_default_core_desc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chipc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|chipc_softc
modifier|*
name|sc
decl_stmt|;
name|bhnd_addr_t
name|enum_addr
decl_stmt|;
name|uint32_t
name|ccid_reg
decl_stmt|;
name|uint8_t
name|chip_type
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|quirks
operator|=
name|bhnd_device_quirks
argument_list|(
name|dev
argument_list|,
name|chipc_devices
argument_list|,
sizeof|sizeof
argument_list|(
name|chipc_devices
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sprom_refcnt
operator|=
literal|0
expr_stmt|;
name|CHIPC_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mem_regions
argument_list|)
expr_stmt|;
comment|/* Set up resource management */
if|if
condition|(
operator|(
name|error
operator|=
name|chipc_init_rman
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to initialize chipc resource state: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* Allocate the region containing our core registers */
if|if
condition|(
operator|(
name|sc
operator|->
name|core_region
operator|=
name|chipc_find_region_by_rid
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|error
operator|=
name|chipc_retain_region
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|core_region
argument_list|,
name|RF_ALLOCATED
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|sc
operator|->
name|core_region
operator|=
name|NULL
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
else|else
block|{
name|sc
operator|->
name|core
operator|=
name|sc
operator|->
name|core_region
operator|->
name|cr_res
expr_stmt|;
block|}
comment|/* Fetch our chipset identification data */
name|ccid_reg
operator|=
name|bhnd_bus_read_4
argument_list|(
name|sc
operator|->
name|core
argument_list|,
name|CHIPC_ID
argument_list|)
expr_stmt|;
name|chip_type
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|ccid_reg
argument_list|,
name|CHIPC_ID_BUS
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|chip_type
condition|)
block|{
case|case
name|BHND_CHIPTYPE_SIBA
case|:
comment|/* enumeration space starts at the ChipCommon register base. */
name|enum_addr
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|core
operator|->
name|res
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_CHIPTYPE_BCMA
case|:
case|case
name|BHND_CHIPTYPE_BCMA_ALT
case|:
name|enum_addr
operator|=
name|bhnd_bus_read_4
argument_list|(
name|sc
operator|->
name|core
argument_list|,
name|CHIPC_EROMPTR
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unsupported chip type %hhu\n"
argument_list|,
name|chip_type
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|sc
operator|->
name|ccid
operator|=
name|bhnd_parse_chipid
argument_list|(
name|ccid_reg
argument_list|,
name|enum_addr
argument_list|)
expr_stmt|;
comment|/* Fetch and parse capability register(s) */
if|if
condition|(
operator|(
name|error
operator|=
name|chipc_read_caps
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|caps
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|bootverbose
condition|)
name|chipc_print_caps
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|caps
argument_list|)
expr_stmt|;
comment|/* Identify NVRAM source */
name|sc
operator|->
name|nvram_src
operator|=
name|chipc_nvram_identify
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Probe and attach children */
name|bus_generic_probe
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
if|if
condition|(
name|sc
operator|->
name|core_region
operator|!=
name|NULL
condition|)
block|{
name|chipc_release_region
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|core_region
argument_list|,
name|RF_ALLOCATED
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
name|chipc_free_rman
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CHIPC_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chipc_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|chipc_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|chipc_release_region
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|core_region
argument_list|,
name|RF_ALLOCATED
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
name|chipc_free_rman
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bhnd_sprom_fini
argument_list|(
operator|&
name|sc
operator|->
name|sprom
argument_list|)
expr_stmt|;
name|CHIPC_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read and parse chipc capabilities */
end_comment

begin_function
specifier|static
name|int
name|chipc_read_caps
parameter_list|(
name|struct
name|chipc_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|chipc_caps
modifier|*
name|caps
parameter_list|)
block|{
name|uint32_t
name|cap_reg
decl_stmt|;
name|uint32_t
name|cap_ext_reg
decl_stmt|;
name|uint32_t
name|regval
decl_stmt|;
comment|/* Fetch cap registers */
name|cap_reg
operator|=
name|bhnd_bus_read_4
argument_list|(
name|sc
operator|->
name|core
argument_list|,
name|CHIPC_CAPABILITIES
argument_list|)
expr_stmt|;
name|cap_ext_reg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CHIPC_QUIRK
argument_list|(
name|sc
argument_list|,
name|SUPPORTS_CAP_EXT
argument_list|)
condition|)
name|cap_ext_reg
operator|=
name|bhnd_bus_read_4
argument_list|(
name|sc
operator|->
name|core
argument_list|,
name|CHIPC_CAPABILITIES_EXT
argument_list|)
expr_stmt|;
comment|/* Extract values */
name|caps
operator|->
name|num_uarts
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|cap_reg
argument_list|,
name|CHIPC_CAP_NUM_UART
argument_list|)
expr_stmt|;
name|caps
operator|->
name|mipseb
operator|=
name|CHIPC_GET_FLAG
argument_list|(
name|cap_reg
argument_list|,
name|CHIPC_CAP_MIPSEB
argument_list|)
expr_stmt|;
name|caps
operator|->
name|uart_gpio
operator|=
name|CHIPC_GET_FLAG
argument_list|(
name|cap_reg
argument_list|,
name|CHIPC_CAP_UARTGPIO
argument_list|)
expr_stmt|;
name|caps
operator|->
name|uart_clock
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|cap_reg
argument_list|,
name|CHIPC_CAP_UCLKSEL
argument_list|)
expr_stmt|;
name|caps
operator|->
name|extbus_type
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|cap_reg
argument_list|,
name|CHIPC_CAP_EXTBUS
argument_list|)
expr_stmt|;
name|caps
operator|->
name|power_control
operator|=
name|CHIPC_GET_FLAG
argument_list|(
name|cap_reg
argument_list|,
name|CHIPC_CAP_PWR_CTL
argument_list|)
expr_stmt|;
name|caps
operator|->
name|jtag_master
operator|=
name|CHIPC_GET_FLAG
argument_list|(
name|cap_reg
argument_list|,
name|CHIPC_CAP_JTAGP
argument_list|)
expr_stmt|;
name|caps
operator|->
name|pll_type
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|cap_reg
argument_list|,
name|CHIPC_CAP_PLL
argument_list|)
expr_stmt|;
name|caps
operator|->
name|backplane_64
operator|=
name|CHIPC_GET_FLAG
argument_list|(
name|cap_reg
argument_list|,
name|CHIPC_CAP_BKPLN64
argument_list|)
expr_stmt|;
name|caps
operator|->
name|boot_rom
operator|=
name|CHIPC_GET_FLAG
argument_list|(
name|cap_reg
argument_list|,
name|CHIPC_CAP_ROM
argument_list|)
expr_stmt|;
name|caps
operator|->
name|pmu
operator|=
name|CHIPC_GET_FLAG
argument_list|(
name|cap_reg
argument_list|,
name|CHIPC_CAP_PMU
argument_list|)
expr_stmt|;
name|caps
operator|->
name|eci
operator|=
name|CHIPC_GET_FLAG
argument_list|(
name|cap_reg
argument_list|,
name|CHIPC_CAP_ECI
argument_list|)
expr_stmt|;
name|caps
operator|->
name|sprom
operator|=
name|CHIPC_GET_FLAG
argument_list|(
name|cap_reg
argument_list|,
name|CHIPC_CAP_SPROM
argument_list|)
expr_stmt|;
name|caps
operator|->
name|otp_size
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|cap_reg
argument_list|,
name|CHIPC_CAP_OTP_SIZE
argument_list|)
expr_stmt|;
name|caps
operator|->
name|seci
operator|=
name|CHIPC_GET_FLAG
argument_list|(
name|cap_ext_reg
argument_list|,
name|CHIPC_CAP2_SECI
argument_list|)
expr_stmt|;
name|caps
operator|->
name|gsio
operator|=
name|CHIPC_GET_FLAG
argument_list|(
name|cap_ext_reg
argument_list|,
name|CHIPC_CAP2_GSIO
argument_list|)
expr_stmt|;
name|caps
operator|->
name|aob
operator|=
name|CHIPC_GET_FLAG
argument_list|(
name|cap_ext_reg
argument_list|,
name|CHIPC_CAP2_AOB
argument_list|)
expr_stmt|;
comment|/* Fetch OTP size for later IPX controller revisions */
if|if
condition|(
name|CHIPC_QUIRK
argument_list|(
name|sc
argument_list|,
name|IPX_OTPLAYOUT_SIZE
argument_list|)
condition|)
block|{
name|regval
operator|=
name|bhnd_bus_read_4
argument_list|(
name|sc
operator|->
name|core
argument_list|,
name|CHIPC_OTPLAYOUT
argument_list|)
expr_stmt|;
name|caps
operator|->
name|otp_size
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|regval
argument_list|,
name|CHIPC_OTPL_SIZE
argument_list|)
expr_stmt|;
block|}
comment|/* Determine flash type and parameters */
name|caps
operator|->
name|cfi_width
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|CHIPC_GET_BITS
argument_list|(
name|cap_reg
argument_list|,
name|CHIPC_CAP_FLASH
argument_list|)
condition|)
block|{
case|case
name|CHIPC_CAP_SFLASH_ST
case|:
name|caps
operator|->
name|flash_type
operator|=
name|CHIPC_SFLASH_ST
expr_stmt|;
break|break;
case|case
name|CHIPC_CAP_SFLASH_AT
case|:
name|caps
operator|->
name|flash_type
operator|=
name|CHIPC_SFLASH_AT
expr_stmt|;
break|break;
case|case
name|CHIPC_CAP_NFLASH
case|:
name|caps
operator|->
name|flash_type
operator|=
name|CHIPC_NFLASH
expr_stmt|;
break|break;
case|case
name|CHIPC_CAP_PFLASH
case|:
name|caps
operator|->
name|flash_type
operator|=
name|CHIPC_PFLASH_CFI
expr_stmt|;
comment|/* determine cfi width */
name|regval
operator|=
name|bhnd_bus_read_4
argument_list|(
name|sc
operator|->
name|core
argument_list|,
name|CHIPC_FLASH_CFG
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIPC_GET_FLAG
argument_list|(
name|regval
argument_list|,
name|CHIPC_FLASH_CFG_DS
argument_list|)
condition|)
name|caps
operator|->
name|cfi_width
operator|=
literal|2
expr_stmt|;
else|else
name|caps
operator|->
name|cfi_width
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CHIPC_CAP_FLASH_NONE
case|:
name|caps
operator|->
name|flash_type
operator|=
name|CHIPC_FLASH_NONE
expr_stmt|;
break|break;
block|}
comment|/* Handle 4706_NFLASH fallback */
if|if
condition|(
name|CHIPC_QUIRK
argument_list|(
name|sc
argument_list|,
literal|4706_NFLASH
argument_list|)
operator|&&
name|CHIPC_GET_FLAG
argument_list|(
name|cap_reg
argument_list|,
name|CHIPC_CAP_4706_NFLASH
argument_list|)
condition|)
block|{
name|caps
operator|->
name|flash_type
operator|=
name|CHIPC_NFLASH_4706
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Determine the NVRAM data source for this device.  *  * @param sc chipc driver state.  */
end_comment

begin_function
specifier|static
name|bhnd_nvram_src_t
name|chipc_nvram_identify
parameter_list|(
name|struct
name|chipc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|srom_ctrl
decl_stmt|;
comment|/* Very early devices vend SPROM/OTP/CIS (if at all) via the 	 * host bridge interface instead of ChipCommon. */
if|if
condition|(
operator|!
name|CHIPC_QUIRK
argument_list|(
name|sc
argument_list|,
name|SUPPORTS_SPROM
argument_list|)
condition|)
return|return
operator|(
name|BHND_NVRAM_SRC_UNKNOWN
operator|)
return|;
comment|/* 	 * Later chipset revisions standardized the SPROM capability flags and 	 * register interfaces. 	 *  	 * We check for hardware presence in order of precedence. For example, 	 * SPROM is is always used in preference to internal OTP if found. 	 */
if|if
condition|(
name|CHIPC_CAP
argument_list|(
name|sc
argument_list|,
name|sprom
argument_list|)
condition|)
block|{
name|srom_ctrl
operator|=
name|bhnd_bus_read_4
argument_list|(
name|sc
operator|->
name|core
argument_list|,
name|CHIPC_SPROM_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|srom_ctrl
operator|&
name|CHIPC_SRC_PRESENT
condition|)
return|return
operator|(
name|BHND_NVRAM_SRC_SPROM
operator|)
return|;
block|}
comment|/* Check for OTP */
if|if
condition|(
name|CHIPC_CAP
argument_list|(
name|sc
argument_list|,
name|otp_size
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|BHND_NVRAM_SRC_OTP
operator|)
return|;
comment|/* Check for flash */
if|if
condition|(
name|CHIPC_CAP
argument_list|(
name|sc
argument_list|,
name|flash_type
argument_list|)
operator|!=
name|CHIPC_FLASH_NONE
condition|)
return|return
operator|(
name|BHND_NVRAM_SRC_FLASH
operator|)
return|;
comment|/* No NVRAM hardware capability declared */
return|return
operator|(
name|BHND_NVRAM_SRC_UNKNOWN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chipc_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chipc_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|bus_generic_resume
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|chipc_probe_nomatch
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|device_get_name
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
literal|"unknown device"
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"<%s> at"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rl
operator|=
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|!=
name|NULL
condition|)
block|{
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"mem"
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|"%#jx"
argument_list|)
expr_stmt|;
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"irq"
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|"%jd"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" (no driver attached)\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|chipc_print_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|rl
operator|=
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"mem"
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|"%#jx"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"irq"
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|"%jd"
argument_list|)
expr_stmt|;
block|}
name|retval
operator|+=
name|bus_print_child_domain
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chipc_child_pnpinfo_str
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
if|if
condition|(
name|buflen
operator|==
literal|0
condition|)
return|return
operator|(
name|EOVERFLOW
operator|)
return|;
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chipc_child_location_str
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
if|if
condition|(
name|buflen
operator|==
literal|0
condition|)
return|return
operator|(
name|EOVERFLOW
operator|)
return|;
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|device_t
name|chipc_add_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|order
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|chipc_devinfo
modifier|*
name|dinfo
decl_stmt|;
specifier|const
name|struct
name|chipc_hint
modifier|*
name|hint
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|int
name|error
decl_stmt|;
name|child
operator|=
name|device_add_child_ordered
argument_list|(
name|dev
argument_list|,
name|order
argument_list|,
name|name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dinfo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|chipc_devinfo
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|==
name|NULL
condition|)
block|{
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|resource_list_init
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
comment|/* Hint matching requires a device name */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
name|child
operator|)
return|;
comment|/* Use hint table to set child resources */
for|for
control|(
name|hint
operator|=
name|chipc_hints
init|;
name|hint
operator|->
name|name
operator|!=
name|NULL
condition|;
name|hint
operator|++
control|)
block|{
name|bhnd_addr_t
name|region_addr
decl_stmt|;
name|bhnd_size_t
name|region_size
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hint
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
switch|switch
condition|(
name|hint
operator|->
name|type
condition|)
block|{
case|case
name|SYS_RES_IRQ
case|:
comment|/* Add child resource */
name|error
operator|=
name|bus_set_resource
argument_list|(
name|child
argument_list|,
name|hint
operator|->
name|type
argument_list|,
name|hint
operator|->
name|rid
argument_list|,
name|hint
operator|->
name|base
argument_list|,
name|hint
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_set_resource() failed for %s: %d\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
break|break;
case|case
name|SYS_RES_MEMORY
case|:
comment|/* Fetch region address and size */
name|error
operator|=
name|bhnd_get_region_addr
argument_list|(
name|dev
argument_list|,
name|BHND_PORT_DEVICE
argument_list|,
name|hint
operator|->
name|port
argument_list|,
name|hint
operator|->
name|region
argument_list|,
operator|&
name|region_addr
argument_list|,
operator|&
name|region_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"lookup of %s%u.%u failed: %d\n"
argument_list|,
name|bhnd_port_type_name
argument_list|(
name|BHND_PORT_DEVICE
argument_list|)
argument_list|,
name|hint
operator|->
name|port
argument_list|,
name|hint
operator|->
name|region
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* Verify requested range is mappable */
if|if
condition|(
name|hint
operator|->
name|base
operator|>
name|region_size
operator|||
name|hint
operator|->
name|size
operator|>
name|region_size
operator|||
name|region_size
operator|-
name|hint
operator|->
name|base
operator|<
name|hint
operator|->
name|size
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s%u.%u region cannot map requested range "
literal|"%#jx+%#jx\n"
argument_list|,
name|bhnd_port_type_name
argument_list|(
name|BHND_PORT_DEVICE
argument_list|)
argument_list|,
name|hint
operator|->
name|port
argument_list|,
name|hint
operator|->
name|region
argument_list|,
name|hint
operator|->
name|base
argument_list|,
name|hint
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* Add child resource */
name|error
operator|=
name|bus_set_resource
argument_list|(
name|child
argument_list|,
name|hint
operator|->
name|type
argument_list|,
name|hint
operator|->
name|rid
argument_list|,
name|region_addr
operator|+
name|hint
operator|->
name|base
argument_list|,
name|hint
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_set_resource() failed for %s: %d\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
break|break;
default|default:
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"unknown hint resource type: %d\n"
argument_list|,
name|hint
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|child
operator|)
return|;
name|failed
label|:
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|chipc_child_deleted
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|chipc_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|dinfo
operator|!=
name|NULL
condition|)
block|{
name|resource_list_free
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dinfo
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource_list
modifier|*
name|chipc_get_resource_list
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|chipc_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
return|return
operator|(
operator|&
name|dinfo
operator|->
name|resources
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate region records for the given port, and add the port's memory  * range to the mem_rman */
end_comment

begin_function
specifier|static
name|int
name|chipc_rman_init_regions
parameter_list|(
name|struct
name|chipc_softc
modifier|*
name|sc
parameter_list|,
name|bhnd_port_type
name|type
parameter_list|,
name|u_int
name|port
parameter_list|)
block|{
name|struct
name|chipc_region
modifier|*
name|cr
decl_stmt|;
name|rman_res_t
name|start
decl_stmt|,
name|end
decl_stmt|;
name|u_int
name|num_regions
decl_stmt|;
name|int
name|error
decl_stmt|;
name|num_regions
operator|=
name|bhnd_get_region_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|port
argument_list|,
name|port
argument_list|)
expr_stmt|;
for|for
control|(
name|u_int
name|region
init|=
literal|0
init|;
name|region
operator|<
name|num_regions
condition|;
name|region
operator|++
control|)
block|{
comment|/* Allocate new region record */
name|cr
operator|=
name|chipc_alloc_region
argument_list|(
name|sc
argument_list|,
name|type
argument_list|,
name|port
argument_list|,
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Can't manage regions that cannot be allocated */
if|if
condition|(
name|cr
operator|->
name|cr_rid
operator|<
literal|0
condition|)
block|{
name|BHND_DEBUG_DEV
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"no rid for chipc region "
literal|"%s%u.%u"
argument_list|,
name|bhnd_port_type_name
argument_list|(
name|type
argument_list|)
argument_list|,
name|port
argument_list|,
name|region
argument_list|)
expr_stmt|;
name|chipc_free_region
argument_list|(
name|sc
argument_list|,
name|cr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Add to rman's managed range */
name|start
operator|=
name|cr
operator|->
name|cr_addr
expr_stmt|;
name|end
operator|=
name|cr
operator|->
name|cr_end
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|rman_manage_region
argument_list|(
operator|&
name|sc
operator|->
name|mem_rman
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
operator|)
condition|)
block|{
name|chipc_free_region
argument_list|(
name|sc
argument_list|,
name|cr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Add to region list */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|mem_regions
argument_list|,
name|cr
argument_list|,
name|cr_link
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize memory state for all chipc port regions */
end_comment

begin_function
specifier|static
name|int
name|chipc_init_rman
parameter_list|(
name|struct
name|chipc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|num_ports
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Port types for which we'll register chipc_region mappings */
name|bhnd_port_type
name|types
index|[]
init|=
block|{
name|BHND_PORT_DEVICE
block|}
decl_stmt|;
comment|/* Initialize resource manager */
name|sc
operator|->
name|mem_rman
operator|.
name|rm_start
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mem_rman
operator|.
name|rm_end
operator|=
name|BUS_SPACE_MAXADDR
expr_stmt|;
name|sc
operator|->
name|mem_rman
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|sc
operator|->
name|mem_rman
operator|.
name|rm_descr
operator|=
literal|"ChipCommon Device Memory"
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|rman_init
argument_list|(
operator|&
name|sc
operator|->
name|mem_rman
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not initialize mem_rman: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Populate per-port-region state */
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|types
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|num_ports
operator|=
name|bhnd_get_port_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|u_int
name|port
init|=
literal|0
init|;
name|port
operator|<
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|error
operator|=
name|chipc_rman_init_regions
argument_list|(
name|sc
argument_list|,
name|types
index|[
name|i
index|]
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"region init failed for %s%u: %d\n"
argument_list|,
name|bhnd_port_type_name
argument_list|(
name|types
index|[
name|i
index|]
argument_list|)
argument_list|,
name|port
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
name|chipc_free_rman
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free memory management state */
end_comment

begin_function
specifier|static
name|void
name|chipc_free_rman
parameter_list|(
name|struct
name|chipc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|chipc_region
modifier|*
name|cr
decl_stmt|,
modifier|*
name|cr_next
decl_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|cr
argument_list|,
argument|&sc->mem_regions
argument_list|,
argument|cr_link
argument_list|,
argument|cr_next
argument_list|)
name|chipc_free_region
argument_list|(
name|sc
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|rman_fini
argument_list|(
operator|&
name|sc
operator|->
name|mem_rman
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Return the rman instance for a given resource @p type, if any.  *   * @param sc The chipc device state.  * @param type The resource type (e.g. SYS_RES_MEMORY, SYS_RES_IRQ, ...)  */
end_comment

begin_function
specifier|static
name|struct
name|rman
modifier|*
name|chipc_get_rman
parameter_list|(
name|struct
name|chipc_softc
modifier|*
name|sc
parameter_list|,
name|int
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_MEMORY
case|:
return|return
operator|(
operator|&
name|sc
operator|->
name|mem_rman
operator|)
return|;
case|case
name|SYS_RES_IRQ
case|:
comment|/* IRQs can be used with RF_SHAREABLE, so we don't perform 		 * any local proxying of resource requests. */
return|return
operator|(
name|NULL
operator|)
return|;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|chipc_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|chipc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|chipc_region
modifier|*
name|cr
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|struct
name|resource
modifier|*
name|rv
decl_stmt|;
name|struct
name|rman
modifier|*
name|rm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bool
name|passthrough
decl_stmt|,
name|isdefault
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|passthrough
operator|=
operator|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
operator|)
expr_stmt|;
name|isdefault
operator|=
name|RMAN_IS_DEFAULT_RANGE
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|rle
operator|=
name|NULL
expr_stmt|;
comment|/* Fetch the resource manager, delegate request if necessary */
name|rm
operator|=
name|chipc_get_rman
argument_list|(
name|sc
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|==
name|NULL
condition|)
block|{
comment|/* Requested resource type is delegated to our parent */
name|rv
operator|=
name|bus_generic_rl_alloc_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
comment|/* Populate defaults */
if|if
condition|(
operator|!
name|passthrough
operator|&&
name|isdefault
condition|)
block|{
comment|/* Fetch the resource list entry. */
name|rle
operator|=
name|resource_list_find
argument_list|(
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"default resource %#x type %d for child %s "
literal|"not found\n"
argument_list|,
operator|*
name|rid
argument_list|,
name|type
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|rle
operator|->
name|res
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"resource entry %#x type %d for child %s is busy\n"
argument_list|,
operator|*
name|rid
argument_list|,
name|type
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|start
operator|=
name|rle
operator|->
name|start
expr_stmt|;
name|end
operator|=
name|rle
operator|->
name|end
expr_stmt|;
name|count
operator|=
name|ulmax
argument_list|(
name|count
argument_list|,
name|rle
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
comment|/* Locate a mapping region */
if|if
condition|(
operator|(
name|cr
operator|=
name|chipc_find_region
argument_list|(
name|sc
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Resource requests outside our shared port regions can be 		 * delegated to our parent. */
name|rv
operator|=
name|bus_generic_rl_alloc_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
comment|/* Try to retain a region reference */
if|if
condition|(
operator|(
name|error
operator|=
name|chipc_retain_region
argument_list|(
name|sc
argument_list|,
name|cr
argument_list|,
name|RF_ALLOCATED
argument_list|)
operator|)
condition|)
block|{
name|CHIPC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Make our rman reservation */
name|rv
operator|=
name|rman_reserve_resource
argument_list|(
name|rm
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
operator|&
operator|~
name|RF_ACTIVE
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|NULL
condition|)
block|{
name|chipc_release_region
argument_list|(
name|sc
argument_list|,
name|cr
argument_list|,
name|RF_ALLOCATED
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|rman_set_rid
argument_list|(
name|rv
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
comment|/* Activate */
if|if
condition|(
name|flags
operator|&
name|RF_ACTIVE
condition|)
block|{
name|error
operator|=
name|bus_activate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|rv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to activate entry %#x type %d for "
literal|"child %s: %d\n"
argument_list|,
operator|*
name|rid
argument_list|,
name|type
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|chipc_release_region
argument_list|(
name|sc
argument_list|,
name|cr
argument_list|,
name|RF_ALLOCATED
argument_list|)
expr_stmt|;
name|rman_release_resource
argument_list|(
name|rv
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* Update child's resource list entry */
if|if
condition|(
name|rle
operator|!=
name|NULL
condition|)
block|{
name|rle
operator|->
name|res
operator|=
name|rv
expr_stmt|;
name|rle
operator|->
name|start
operator|=
name|rman_get_start
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|rle
operator|->
name|end
operator|=
name|rman_get_end
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|rle
operator|->
name|count
operator|=
name|rman_get_size
argument_list|(
name|rv
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chipc_release_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|chipc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|chipc_region
modifier|*
name|cr
decl_stmt|;
name|struct
name|rman
modifier|*
name|rm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Handled by parent bus? */
name|rm
operator|=
name|chipc_get_rman
argument_list|(
name|sc
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|==
name|NULL
operator|||
operator|!
name|rman_is_region_manager
argument_list|(
name|r
argument_list|,
name|rm
argument_list|)
condition|)
block|{
return|return
operator|(
name|bus_generic_rl_release_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
block|}
comment|/* Locate the mapping region */
name|cr
operator|=
name|chipc_find_region
argument_list|(
name|sc
argument_list|,
name|rman_get_start
argument_list|(
name|r
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Deactivate resources */
if|if
condition|(
name|rman_get_flags
argument_list|(
name|r
argument_list|)
operator|&
name|RF_ACTIVE
condition|)
block|{
name|error
operator|=
name|BUS_DEACTIVATE_RESOURCE
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|rman_release_resource
argument_list|(
name|r
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Drop allocation reference */
name|chipc_release_region
argument_list|(
name|sc
argument_list|,
name|cr
argument_list|,
name|RF_ALLOCATED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chipc_adjust_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|)
block|{
name|struct
name|chipc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|chipc_region
modifier|*
name|cr
decl_stmt|;
name|struct
name|rman
modifier|*
name|rm
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Handled by parent bus? */
name|rm
operator|=
name|chipc_get_rman
argument_list|(
name|sc
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|==
name|NULL
operator|||
operator|!
name|rman_is_region_manager
argument_list|(
name|r
argument_list|,
name|rm
argument_list|)
condition|)
block|{
return|return
operator|(
name|bus_generic_adjust_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|r
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
operator|)
return|;
block|}
comment|/* The range is limited to the existing region mapping */
name|cr
operator|=
name|chipc_find_region
argument_list|(
name|sc
argument_list|,
name|rman_get_start
argument_list|(
name|r
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|end
operator|<=
name|start
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|start
operator|<
name|cr
operator|->
name|cr_addr
operator|||
name|end
operator|>
name|cr
operator|->
name|cr_end
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Range falls within the existing region */
return|return
operator|(
name|rman_adjust_resource
argument_list|(
name|r
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Retain an RF_ACTIVE reference to the region mapping @p r, and  * configure @p r with its subregion values.  *  * @param sc Driver instance state.  * @param child Requesting child device.  * @param type resource type of @p r.  * @param rid resource id of @p r  * @param r resource to be activated.  * @param req_direct If true, failure to allocate a direct bhnd resource  * will be treated as an error. If false, the resource will not be marked  * as RF_ACTIVE if bhnd direct resource allocation fails.  */
end_comment

begin_function
specifier|static
name|int
name|chipc_try_activate_resource
parameter_list|(
name|struct
name|chipc_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|bool
name|req_direct
parameter_list|)
block|{
name|struct
name|rman
modifier|*
name|rm
decl_stmt|;
name|struct
name|chipc_region
modifier|*
name|cr
decl_stmt|;
name|bhnd_size_t
name|cr_offset
decl_stmt|;
name|rman_res_t
name|r_start
decl_stmt|,
name|r_end
decl_stmt|,
name|r_size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|rm
operator|=
name|chipc_get_rman
argument_list|(
name|sc
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|==
name|NULL
operator|||
operator|!
name|rman_is_region_manager
argument_list|(
name|r
argument_list|,
name|rm
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|r_start
operator|=
name|rman_get_start
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r_end
operator|=
name|rman_get_end
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r_size
operator|=
name|rman_get_size
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* Find the corresponding chipc region */
name|cr
operator|=
name|chipc_find_region
argument_list|(
name|sc
argument_list|,
name|r_start
argument_list|,
name|r_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Calculate subregion offset within the chipc region */
name|cr_offset
operator|=
name|r_start
operator|-
name|cr
operator|->
name|cr_addr
expr_stmt|;
comment|/* Retain (and activate, if necessary) the chipc region */
if|if
condition|(
operator|(
name|error
operator|=
name|chipc_retain_region
argument_list|(
name|sc
argument_list|,
name|cr
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Configure child resource with its subregion values. */
if|if
condition|(
name|cr
operator|->
name|cr_res
operator|->
name|direct
condition|)
block|{
name|error
operator|=
name|chipc_init_child_resource
argument_list|(
name|r
argument_list|,
name|cr
operator|->
name|cr_res
operator|->
name|res
argument_list|,
name|cr_offset
argument_list|,
name|r_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Mark active */
if|if
condition|(
operator|(
name|error
operator|=
name|rman_activate_resource
argument_list|(
name|r
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
block|}
elseif|else
if|if
condition|(
name|req_direct
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|cleanup
label|:
name|chipc_release_region
argument_list|(
name|sc
argument_list|,
name|cr
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chipc_activate_bhnd_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|bhnd_resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|chipc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|rman
modifier|*
name|rm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Delegate non-locally managed resources to parent */
name|rm
operator|=
name|chipc_get_rman
argument_list|(
name|sc
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|==
name|NULL
operator|||
operator|!
name|rman_is_region_manager
argument_list|(
name|r
operator|->
name|res
argument_list|,
name|rm
argument_list|)
condition|)
block|{
return|return
operator|(
name|bhnd_bus_generic_activate_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
block|}
comment|/* Try activating the chipc region resource */
name|error
operator|=
name|chipc_try_activate_resource
argument_list|(
name|sc
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
operator|->
name|res
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Mark the child resource as direct according to the returned resource 	 * state */
if|if
condition|(
name|rman_get_flags
argument_list|(
name|r
operator|->
name|res
argument_list|)
operator|&
name|RF_ACTIVE
condition|)
name|r
operator|->
name|direct
operator|=
name|true
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chipc_activate_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|chipc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|rman
modifier|*
name|rm
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Delegate non-locally managed resources to parent */
name|rm
operator|=
name|chipc_get_rman
argument_list|(
name|sc
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|==
name|NULL
operator|||
operator|!
name|rman_is_region_manager
argument_list|(
name|r
argument_list|,
name|rm
argument_list|)
condition|)
block|{
return|return
operator|(
name|bus_generic_activate_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
block|}
comment|/* Try activating the chipc region-based resource */
return|return
operator|(
name|chipc_try_activate_resource
argument_list|(
name|sc
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|,
name|true
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhndb(4) implementation of BUS_DEACTIVATE_RESOURCE().  */
end_comment

begin_function
specifier|static
name|int
name|chipc_deactivate_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|chipc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|chipc_region
modifier|*
name|cr
decl_stmt|;
name|struct
name|rman
modifier|*
name|rm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Handled by parent bus? */
name|rm
operator|=
name|chipc_get_rman
argument_list|(
name|sc
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|==
name|NULL
operator|||
operator|!
name|rman_is_region_manager
argument_list|(
name|r
argument_list|,
name|rm
argument_list|)
condition|)
block|{
return|return
operator|(
name|bus_generic_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
block|}
comment|/* Find the corresponding chipc region */
name|cr
operator|=
name|chipc_find_region
argument_list|(
name|sc
argument_list|,
name|rman_get_start
argument_list|(
name|r
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Mark inactive */
if|if
condition|(
operator|(
name|error
operator|=
name|rman_deactivate_resource
argument_list|(
name|r
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Drop associated RF_ACTIVE reference */
name|chipc_release_region
argument_list|(
name|sc
argument_list|,
name|cr
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Examine bus state and make a best effort determination of whether it's  * likely safe to enable the muxed SPROM pins.  *   * On devices that do not use SPROM pin muxing, always returns true.  *   * @param sc chipc driver state.  */
end_comment

begin_function
specifier|static
name|bool
name|chipc_should_enable_sprom
parameter_list|(
name|struct
name|chipc_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
modifier|*
name|devs
decl_stmt|;
name|device_t
name|hostb
decl_stmt|;
name|device_t
name|parent
decl_stmt|;
name|int
name|devcount
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bool
name|result
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* for newbus */
comment|/* Nothing to do? */
if|if
condition|(
operator|!
name|CHIPC_QUIRK
argument_list|(
name|sc
argument_list|,
name|MUX_SPROM
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|parent
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|hostb
operator|=
name|bhnd_find_hostb_device
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|device_get_children
argument_list|(
name|parent
argument_list|,
operator|&
name|devs
argument_list|,
operator|&
name|devcount
argument_list|)
operator|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Reject any active devices other than ChipCommon, or the 	 * host bridge (if any). */
name|result
operator|=
name|true
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|devcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|devs
index|[
name|i
index|]
operator|==
name|hostb
operator|||
name|devs
index|[
name|i
index|]
operator|==
name|sc
operator|->
name|dev
condition|)
continue|continue;
if|if
condition|(
operator|!
name|device_is_attached
argument_list|(
name|devs
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|device_is_suspended
argument_list|(
name|devs
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
comment|/* Active device; assume SPROM is busy */
name|result
operator|=
name|false
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|devs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * If required by this device, enable access to the SPROM.  *   * @param sc chipc driver state.  */
end_comment

begin_function
specifier|static
name|int
name|chipc_enable_sprom_pins
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|chipc_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|cctrl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Nothing to do? */
if|if
condition|(
operator|!
name|CHIPC_QUIRK
argument_list|(
name|sc
argument_list|,
name|MUX_SPROM
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Make sure we're holding Giant for newbus */
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|CHIPC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Already enabled? */
if|if
condition|(
name|sc
operator|->
name|sprom_refcnt
operator|>=
literal|1
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
comment|/* Check whether bus is busy */
if|if
condition|(
operator|!
name|chipc_should_enable_sprom
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
name|cctrl
operator|=
name|bhnd_bus_read_4
argument_list|(
name|sc
operator|->
name|core
argument_list|,
name|CHIPC_CHIPCTRL
argument_list|)
expr_stmt|;
comment|/* 4331 devices */
if|if
condition|(
name|CHIPC_QUIRK
argument_list|(
name|sc
argument_list|,
literal|4331_EXTPA_MUX_SPROM
argument_list|)
condition|)
block|{
name|cctrl
operator|&=
operator|~
name|CHIPC_CCTRL4331_EXTPA_EN
expr_stmt|;
if|if
condition|(
name|CHIPC_QUIRK
argument_list|(
name|sc
argument_list|,
literal|4331_GPIO2_5_MUX_SPROM
argument_list|)
condition|)
name|cctrl
operator|&=
operator|~
name|CHIPC_CCTRL4331_EXTPA_ON_GPIO2_5
expr_stmt|;
if|if
condition|(
name|CHIPC_QUIRK
argument_list|(
name|sc
argument_list|,
literal|4331_EXTPA2_MUX_SPROM
argument_list|)
condition|)
name|cctrl
operator|&=
operator|~
name|CHIPC_CCTRL4331_EXTPA_EN2
expr_stmt|;
name|bhnd_bus_write_4
argument_list|(
name|sc
operator|->
name|core
argument_list|,
name|CHIPC_CHIPCTRL
argument_list|,
name|cctrl
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
comment|/* 4360 devices */
if|if
condition|(
name|CHIPC_QUIRK
argument_list|(
name|sc
argument_list|,
literal|4360_FEM_MUX_SPROM
argument_list|)
condition|)
block|{
comment|/* Unimplemented */
block|}
comment|/* Refuse to proceed on unsupported devices with muxed SPROM pins */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"muxed sprom lines on unrecognized device\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
name|finished
label|:
comment|/* Bump the reference count */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|sc
operator|->
name|sprom_refcnt
operator|++
expr_stmt|;
name|CHIPC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * If required by this device, revert any GPIO/pin configuration applied  * to allow SPROM access.  *   * @param sc chipc driver state.  */
end_comment

begin_function
specifier|static
name|void
name|chipc_disable_sprom_pins
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|chipc_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|cctrl
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Nothing to do? */
if|if
condition|(
operator|!
name|CHIPC_QUIRK
argument_list|(
name|sc
argument_list|,
name|MUX_SPROM
argument_list|)
condition|)
return|return;
name|CHIPC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check reference count, skip disable if in-use. */
name|KASSERT
argument_list|(
name|sc
operator|->
name|sprom_refcnt
operator|>
literal|0
argument_list|,
operator|(
literal|"sprom refcnt overrelease"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sprom_refcnt
operator|--
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sprom_refcnt
operator|>
literal|0
condition|)
goto|goto
name|finished
goto|;
name|cctrl
operator|=
name|bhnd_bus_read_4
argument_list|(
name|sc
operator|->
name|core
argument_list|,
name|CHIPC_CHIPCTRL
argument_list|)
expr_stmt|;
comment|/* 4331 devices */
if|if
condition|(
name|CHIPC_QUIRK
argument_list|(
name|sc
argument_list|,
literal|4331_EXTPA_MUX_SPROM
argument_list|)
condition|)
block|{
name|cctrl
operator||=
name|CHIPC_CCTRL4331_EXTPA_EN
expr_stmt|;
if|if
condition|(
name|CHIPC_QUIRK
argument_list|(
name|sc
argument_list|,
literal|4331_GPIO2_5_MUX_SPROM
argument_list|)
condition|)
name|cctrl
operator||=
name|CHIPC_CCTRL4331_EXTPA_ON_GPIO2_5
expr_stmt|;
if|if
condition|(
name|CHIPC_QUIRK
argument_list|(
name|sc
argument_list|,
literal|4331_EXTPA2_MUX_SPROM
argument_list|)
condition|)
name|cctrl
operator||=
name|CHIPC_CCTRL4331_EXTPA_EN2
expr_stmt|;
name|bhnd_bus_write_4
argument_list|(
name|sc
operator|->
name|core
argument_list|,
name|CHIPC_CHIPCTRL
argument_list|,
name|cctrl
argument_list|)
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
comment|/* 4360 devices */
if|if
condition|(
name|CHIPC_QUIRK
argument_list|(
name|sc
argument_list|,
literal|4360_FEM_MUX_SPROM
argument_list|)
condition|)
block|{
comment|/* Unimplemented */
block|}
name|finished
label|:
name|CHIPC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bhnd_nvram_src_t
name|chipc_nvram_src
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|chipc_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|sc
operator|->
name|nvram_src
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|chipc_write_chipctrl
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint32_t
name|value
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
name|struct
name|chipc_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|cctrl
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|CHIPC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cctrl
operator|=
name|bhnd_bus_read_4
argument_list|(
name|sc
operator|->
name|core
argument_list|,
name|CHIPC_CHIPCTRL
argument_list|)
expr_stmt|;
name|cctrl
operator|=
operator|(
name|cctrl
operator|&
operator|~
name|mask
operator|)
operator||
operator|(
name|value
operator||
name|mask
operator|)
expr_stmt|;
name|bhnd_bus_write_4
argument_list|(
name|sc
operator|->
name|core
argument_list|,
name|CHIPC_CHIPCTRL
argument_list|,
name|cctrl
argument_list|)
expr_stmt|;
name|CHIPC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|chipc_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|chipc_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|chipc_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|chipc_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|chipc_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|chipc_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_probe_nomatch
argument_list|,
name|chipc_probe_nomatch
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|chipc_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_pnpinfo_str
argument_list|,
name|chipc_child_pnpinfo_str
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_location_str
argument_list|,
name|chipc_child_location_str
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_add_child
argument_list|,
name|chipc_add_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_deleted
argument_list|,
name|chipc_child_deleted
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_set_resource
argument_list|,
name|bus_generic_rl_set_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource
argument_list|,
name|bus_generic_rl_get_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_delete_resource
argument_list|,
name|bus_generic_rl_delete_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|chipc_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|chipc_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_adjust_resource
argument_list|,
name|chipc_adjust_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|chipc_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|chipc_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource_list
argument_list|,
name|chipc_get_resource_list
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|bus_generic_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|bus_generic_teardown_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_config_intr
argument_list|,
name|bus_generic_config_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_bind_intr
argument_list|,
name|bus_generic_bind_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_describe_intr
argument_list|,
name|bus_generic_describe_intr
argument_list|)
block|,
comment|/* BHND bus inteface */
name|DEVMETHOD
argument_list|(
name|bhnd_bus_activate_resource
argument_list|,
name|chipc_activate_bhnd_resource
argument_list|)
block|,
comment|/* ChipCommon interface */
name|DEVMETHOD
argument_list|(
name|bhnd_chipc_nvram_src
argument_list|,
name|chipc_nvram_src
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_chipc_write_chipctrl
argument_list|,
name|chipc_write_chipctrl
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_chipc_enable_sprom
argument_list|,
name|chipc_enable_sprom_pins
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_chipc_disable_sprom
argument_list|,
name|chipc_disable_sprom_pins
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|bhnd_chipc
argument_list|,
name|chipc_driver
argument_list|,
name|chipc_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|chipc_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|bhnd_chipc
argument_list|,
name|bhnd
argument_list|,
name|chipc_driver
argument_list|,
name|bhnd_chipc_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bhnd_chipc
argument_list|,
name|bhnd
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|bhnd_chipc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

