begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Landon Fuller<landonf@FreeBSD.org>  * Copyright (c) 2010, Broadcom Corporation.  * All rights reserved.  *   * This file is derived from the siutils.c source distributed with the  * Asus RT-N16 firmware source code release.  *   * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY  * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $Id: siutils.c,v 1.821.2.48 2011-02-11 20:59:28 Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhnd.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhndb/bhndb_pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/chipc/chipc.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/chipc/chipcreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/pmu/bhnd_pmuvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/pmu/bhnd_pmureg.h>
end_include

begin_include
include|#
directive|include
file|"bhnd_chipc_if.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_pwrctl_private.h"
end_include

begin_function_decl
specifier|static
name|uint32_t
name|bhnd_pwrctl_factor6
parameter_list|(
name|uint32_t
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Return the factor value corresponding to a given N3M clock control magic  * field value (CHIPC_F6_*).  */
end_comment

begin_function
specifier|static
name|uint32_t
name|bhnd_pwrctl_factor6
parameter_list|(
name|uint32_t
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|x
condition|)
block|{
case|case
name|CHIPC_F6_2
case|:
return|return
operator|(
literal|2
operator|)
return|;
case|case
name|CHIPC_F6_3
case|:
return|return
operator|(
literal|3
operator|)
return|;
case|case
name|CHIPC_F6_4
case|:
return|return
operator|(
literal|4
operator|)
return|;
case|case
name|CHIPC_F6_5
case|:
return|return
operator|(
literal|5
operator|)
return|;
case|case
name|CHIPC_F6_6
case|:
return|return
operator|(
literal|6
operator|)
return|;
case|case
name|CHIPC_F6_7
case|:
return|return
operator|(
literal|7
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Return the backplane clock's chipc 'M' register offset for a given PLL type,  * or 0 if a fixed clock speed should be used.  *  * @param cid Chip identification.  * @param pll_type PLL type (CHIPC_PLL_TYPE*)  * @param[out] fixed_hz If 0 is returned, will be set to the fixed clock  * speed for this device.  */
end_comment

begin_function
name|bus_size_t
name|bhnd_pwrctl_si_clkreg_m
parameter_list|(
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|cid
parameter_list|,
name|uint8_t
name|pll_type
parameter_list|,
name|uint32_t
modifier|*
name|fixed_hz
parameter_list|)
block|{
switch|switch
condition|(
name|pll_type
condition|)
block|{
case|case
name|CHIPC_PLL_TYPE6
case|:
return|return
operator|(
name|CHIPC_CLKC_M3
operator|)
return|;
case|case
name|CHIPC_PLL_TYPE3
case|:
return|return
operator|(
name|CHIPC_CLKC_M2
operator|)
return|;
default|default:
return|return
operator|(
name|CHIPC_CLKC_SB
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Calculate the backplane clock speed (in Hz) for a given a set of clock  * control values.  *   * @param cid Chip identification.  * @param pll_type PLL type (CHIPC_PLL_TYPE*)  * @param n clock control N register value.  * @param m clock control M register value.  */
end_comment

begin_function
name|uint32_t
name|bhnd_pwrctl_si_clock_rate
parameter_list|(
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|cid
parameter_list|,
name|uint32_t
name|pll_type
parameter_list|,
name|uint32_t
name|n
parameter_list|,
name|uint32_t
name|m
parameter_list|)
block|{
name|uint32_t
name|rate
decl_stmt|;
name|KASSERT
argument_list|(
name|bhnd_pwrctl_si_clkreg_m
argument_list|(
name|cid
argument_list|,
name|pll_type
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"can't compute clock rate on fixed clock"
operator|)
argument_list|)
expr_stmt|;
name|rate
operator|=
name|bhnd_pwrctl_clock_rate
argument_list|(
name|pll_type
argument_list|,
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|pll_type
operator|==
name|CHIPC_PLL_TYPE3
condition|)
name|rate
operator|/=
literal|2
expr_stmt|;
return|return
operator|(
name|rate
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the CPU clock's chipc 'M' register offset for a given PLL type,  * or 0 if a fixed clock speed should be used.  *   * @param cid Chip identification.  * @param pll_type PLL type (CHIPC_PLL_TYPE*)  * @param[out] fixed_hz If 0 is returned, will be set to the fixed clock  * speed for this device.  */
end_comment

begin_function
name|bus_size_t
name|bhnd_pwrctl_cpu_clkreg_m
parameter_list|(
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|cid
parameter_list|,
name|uint8_t
name|pll_type
parameter_list|,
name|uint32_t
modifier|*
name|fixed_hz
parameter_list|)
block|{
switch|switch
condition|(
name|pll_type
condition|)
block|{
case|case
name|CHIPC_PLL_TYPE2
case|:
case|case
name|CHIPC_PLL_TYPE4
case|:
case|case
name|CHIPC_PLL_TYPE6
case|:
case|case
name|CHIPC_PLL_TYPE7
case|:
return|return
operator|(
name|CHIPC_CLKC_M3
operator|)
return|;
case|case
name|CHIPC_PLL_TYPE5
case|:
comment|/* fixed 200MHz */
if|if
condition|(
name|fixed_hz
operator|!=
name|NULL
condition|)
operator|*
name|fixed_hz
operator|=
literal|200
operator|*
literal|1000
operator|*
literal|1000
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CHIPC_PLL_TYPE3
case|:
if|if
condition|(
name|cid
operator|->
name|chip_id
operator|==
name|BHND_CHIPID_BCM5365
condition|)
block|{
comment|/* fixed 200MHz */
if|if
condition|(
name|fixed_hz
operator|!=
name|NULL
condition|)
operator|*
name|fixed_hz
operator|=
literal|200
operator|*
literal|1000
operator|*
literal|1000
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|CHIPC_CLKC_M2
operator|)
return|;
default|default:
return|return
operator|(
name|CHIPC_CLKC_SB
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Calculate the CPU clock speed (in Hz) for a given a set of clock control  * values.  *   * @param cid Chip identification.  * @param pll_type PLL type (CHIPC_PLL_TYPE*)  * @param n clock control N register value.  * @param m clock control M register value.  */
end_comment

begin_function
name|uint32_t
name|bhnd_pwrctl_cpu_clock_rate
parameter_list|(
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|cid
parameter_list|,
name|uint32_t
name|pll_type
parameter_list|,
name|uint32_t
name|n
parameter_list|,
name|uint32_t
name|m
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|bhnd_pwrctl_cpu_clkreg_m
argument_list|(
name|cid
argument_list|,
name|pll_type
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"can't compute clock rate on fixed clock"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bhnd_pwrctl_clock_rate
argument_list|(
name|pll_type
argument_list|,
name|n
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Calculate the clock speed (in Hz) for a given a set of clockcontrol  * values.  *   * @param pll_type PLL type (CHIPC_PLL_TYPE*)  * @param n clock control N register value.  * @param m clock control M register value.  */
end_comment

begin_function
name|uint32_t
name|bhnd_pwrctl_clock_rate
parameter_list|(
name|uint32_t
name|pll_type
parameter_list|,
name|uint32_t
name|n
parameter_list|,
name|uint32_t
name|m
parameter_list|)
block|{
name|uint32_t
name|clk_base
decl_stmt|;
name|uint32_t
name|n1
decl_stmt|,
name|n2
decl_stmt|,
name|clock
decl_stmt|,
name|m1
decl_stmt|,
name|m2
decl_stmt|,
name|m3
decl_stmt|,
name|mc
decl_stmt|;
name|n1
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|n
argument_list|,
name|CHIPC_CN_N1
argument_list|)
expr_stmt|;
name|n2
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|n
argument_list|,
name|CHIPC_CN_N2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pll_type
condition|)
block|{
case|case
name|CHIPC_PLL_TYPE1
case|:
case|case
name|CHIPC_PLL_TYPE3
case|:
case|case
name|CHIPC_PLL_TYPE4
case|:
case|case
name|CHIPC_PLL_TYPE7
case|:
name|n1
operator|=
name|bhnd_pwrctl_factor6
argument_list|(
name|n1
argument_list|)
expr_stmt|;
name|n2
operator|+=
name|CHIPC_F5_BIAS
expr_stmt|;
break|break;
case|case
name|CHIPC_PLL_TYPE2
case|:
name|n1
operator|+=
name|CHIPC_T2_BIAS
expr_stmt|;
name|n2
operator|+=
name|CHIPC_T2_BIAS
expr_stmt|;
name|KASSERT
argument_list|(
name|n1
operator|>=
literal|2
operator|&&
name|n1
operator|<=
literal|7
argument_list|,
operator|(
literal|"invalid n1 value"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|n2
operator|>=
literal|5
operator|&&
name|n2
operator|<=
literal|23
argument_list|,
operator|(
literal|"invalid n2 value"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHIPC_PLL_TYPE5
case|:
return|return
operator|(
literal|100000000
operator|)
return|;
case|case
name|CHIPC_PLL_TYPE6
case|:
if|if
condition|(
name|m
operator|&
name|CHIPC_T6_MMASK
condition|)
return|return
operator|(
name|CHIPC_T6_M1
operator|)
return|;
else|else
return|return
operator|(
name|CHIPC_T6_M0
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"unsupported PLL type %u\n"
argument_list|,
name|pll_type
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* PLL types 3 and 7 use BASE2 (25Mhz) */
if|if
condition|(
name|pll_type
operator|==
name|CHIPC_PLL_TYPE3
operator|||
name|pll_type
operator|==
name|CHIPC_PLL_TYPE7
condition|)
block|{
name|clk_base
operator|=
name|CHIPC_CLOCK_BASE2
expr_stmt|;
block|}
else|else
block|{
name|clk_base
operator|=
name|CHIPC_CLOCK_BASE1
expr_stmt|;
block|}
name|clock
operator|=
name|clk_base
operator|*
name|n1
operator|*
name|n2
expr_stmt|;
if|if
condition|(
name|clock
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m1
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|m
argument_list|,
name|CHIPC_M1
argument_list|)
expr_stmt|;
name|m2
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|m
argument_list|,
name|CHIPC_M2
argument_list|)
expr_stmt|;
name|m3
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|m
argument_list|,
name|CHIPC_M3
argument_list|)
expr_stmt|;
name|mc
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|m
argument_list|,
name|CHIPC_MC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pll_type
condition|)
block|{
case|case
name|CHIPC_PLL_TYPE1
case|:
case|case
name|CHIPC_PLL_TYPE3
case|:
case|case
name|CHIPC_PLL_TYPE4
case|:
case|case
name|CHIPC_PLL_TYPE7
case|:
name|m1
operator|=
name|bhnd_pwrctl_factor6
argument_list|(
name|m1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pll_type
operator|==
name|CHIPC_PLL_TYPE1
operator|||
name|pll_type
operator|==
name|CHIPC_PLL_TYPE3
condition|)
name|m2
operator|+=
name|CHIPC_F5_BIAS
expr_stmt|;
else|else
name|m2
operator|=
name|bhnd_pwrctl_factor6
argument_list|(
name|m2
argument_list|)
expr_stmt|;
name|m3
operator|=
name|bhnd_pwrctl_factor6
argument_list|(
name|m3
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mc
condition|)
block|{
case|case
name|CHIPC_MC_BYPASS
case|:
return|return
operator|(
name|clock
operator|)
return|;
case|case
name|CHIPC_MC_M1
case|:
return|return
operator|(
name|clock
operator|/
name|m1
operator|)
return|;
case|case
name|CHIPC_MC_M1M2
case|:
return|return
operator|(
name|clock
operator|/
operator|(
name|m1
operator|*
name|m2
operator|)
operator|)
return|;
case|case
name|CHIPC_MC_M1M2M3
case|:
return|return
operator|(
name|clock
operator|/
operator|(
name|m1
operator|*
name|m2
operator|*
name|m3
operator|)
operator|)
return|;
case|case
name|CHIPC_MC_M1M3
case|:
return|return
operator|(
name|clock
operator|/
operator|(
name|m1
operator|*
name|m3
operator|)
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"unsupported pwrctl mc %#x\n"
argument_list|,
name|mc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|CHIPC_PLL_TYPE2
case|:
name|m1
operator|+=
name|CHIPC_T2_BIAS
expr_stmt|;
name|m2
operator|+=
name|CHIPC_T2M2_BIAS
expr_stmt|;
name|m3
operator|+=
name|CHIPC_T2_BIAS
expr_stmt|;
name|KASSERT
argument_list|(
name|m1
operator|>=
literal|2
operator|&&
name|m1
operator|<=
literal|7
argument_list|,
operator|(
literal|"invalid m1 value"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m2
operator|>=
literal|3
operator|&&
name|m2
operator|<=
literal|10
argument_list|,
operator|(
literal|"invalid m2 value"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m3
operator|>=
literal|2
operator|&&
name|m3
operator|<=
literal|7
argument_list|,
operator|(
literal|"invalid m3 value"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mc
operator|&
name|CHIPC_T2MC_M1BYP
operator|)
operator|==
literal|0
condition|)
name|clock
operator|/=
name|m1
expr_stmt|;
if|if
condition|(
operator|(
name|mc
operator|&
name|CHIPC_T2MC_M2BYP
operator|)
operator|==
literal|0
condition|)
name|clock
operator|/=
name|m2
expr_stmt|;
if|if
condition|(
operator|(
name|mc
operator|&
name|CHIPC_T2MC_M3BYP
operator|)
operator|==
literal|0
condition|)
name|clock
operator|/=
name|m3
expr_stmt|;
return|return
operator|(
name|clock
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"unhandled PLL type %u\n"
argument_list|,
name|pll_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Return the backplane clock speed in Hz.  *   * @param sc driver instance state.  */
end_comment

begin_function
name|uint32_t
name|bhnd_pwrctl_getclk_speed
parameter_list|(
name|struct
name|bhnd_pwrctl_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|cid
decl_stmt|;
name|struct
name|chipc_caps
modifier|*
name|ccaps
decl_stmt|;
name|bus_size_t
name|creg
decl_stmt|;
name|uint32_t
name|n
decl_stmt|,
name|m
decl_stmt|;
name|uint32_t
name|rate
decl_stmt|;
name|PWRCTL_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|cid
operator|=
name|bhnd_get_chipid
argument_list|(
name|sc
operator|->
name|chipc_dev
argument_list|)
expr_stmt|;
name|ccaps
operator|=
name|BHND_CHIPC_GET_CAPS
argument_list|(
name|sc
operator|->
name|chipc_dev
argument_list|)
expr_stmt|;
name|n
operator|=
name|bhnd_bus_read_4
argument_list|(
name|sc
operator|->
name|res
argument_list|,
name|CHIPC_CLKC_N
argument_list|)
expr_stmt|;
comment|/* Get M register offset */
name|creg
operator|=
name|bhnd_pwrctl_si_clkreg_m
argument_list|(
name|cid
argument_list|,
name|ccaps
operator|->
name|pll_type
argument_list|,
operator|&
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|creg
operator|==
literal|0
condition|)
comment|/* fixed rate */
return|return
operator|(
name|rate
operator|)
return|;
comment|/* calculate rate */
name|m
operator|=
name|bhnd_bus_read_4
argument_list|(
name|sc
operator|->
name|res
argument_list|,
name|creg
argument_list|)
expr_stmt|;
return|return
operator|(
name|bhnd_pwrctl_si_clock_rate
argument_list|(
name|cid
argument_list|,
name|ccaps
operator|->
name|pll_type
argument_list|,
name|n
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return the slow clock source */
end_comment

begin_function
specifier|static
name|bhnd_clksrc
name|bhnd_pwrctl_slowclk_src
parameter_list|(
name|struct
name|bhnd_pwrctl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|clkreg
decl_stmt|;
name|uint32_t
name|clksrc
decl_stmt|;
comment|/* Fetch clock source */
if|if
condition|(
name|PWRCTL_QUIRK
argument_list|(
name|sc
argument_list|,
name|PCICLK_CTL
argument_list|)
condition|)
block|{
return|return
operator|(
name|bhnd_pwrctl_get_clksrc
argument_list|(
name|sc
operator|->
name|chipc_dev
argument_list|,
name|BHND_CLOCK_ILP
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|PWRCTL_QUIRK
argument_list|(
name|sc
argument_list|,
name|SLOWCLK_CTL
argument_list|)
condition|)
block|{
name|clkreg
operator|=
name|bhnd_bus_read_4
argument_list|(
name|sc
operator|->
name|res
argument_list|,
name|CHIPC_PLL_SLOWCLK_CTL
argument_list|)
expr_stmt|;
name|clksrc
operator|=
name|clkreg
operator|&
name|CHIPC_SCC_SS_MASK
expr_stmt|;
block|}
else|else
block|{
comment|/* Instaclock */
name|clksrc
operator|=
name|CHIPC_SCC_SS_XTAL
expr_stmt|;
block|}
comment|/* Map to bhnd_clksrc */
switch|switch
condition|(
name|clksrc
condition|)
block|{
case|case
name|CHIPC_SCC_SS_PCI
case|:
return|return
operator|(
name|BHND_CLKSRC_PCI
operator|)
return|;
case|case
name|CHIPC_SCC_SS_LPO
case|:
return|return
operator|(
name|BHND_CLKSRC_LPO
operator|)
return|;
case|case
name|CHIPC_SCC_SS_XTAL
case|:
return|return
operator|(
name|BHND_CLKSRC_XTAL
operator|)
return|;
default|default:
return|return
operator|(
name|BHND_CLKSRC_UNKNOWN
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* return the ILP (slowclock) min or max frequency */
end_comment

begin_function
specifier|static
name|uint32_t
name|bhnd_pwrctl_slowclk_freq
parameter_list|(
name|struct
name|bhnd_pwrctl_softc
modifier|*
name|sc
parameter_list|,
name|bool
name|max_freq
parameter_list|)
block|{
name|bhnd_clksrc
name|slowclk
decl_stmt|;
name|uint32_t
name|div
decl_stmt|;
name|uint32_t
name|hz
decl_stmt|;
name|slowclk
operator|=
name|bhnd_pwrctl_slowclk_src
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Determine clock divisor */
if|if
condition|(
name|PWRCTL_QUIRK
argument_list|(
name|sc
argument_list|,
name|PCICLK_CTL
argument_list|)
condition|)
block|{
if|if
condition|(
name|slowclk
operator|==
name|BHND_CLKSRC_PCI
condition|)
name|div
operator|=
literal|64
expr_stmt|;
else|else
name|div
operator|=
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PWRCTL_QUIRK
argument_list|(
name|sc
argument_list|,
name|SLOWCLK_CTL
argument_list|)
condition|)
block|{
name|div
operator|=
name|bhnd_bus_read_4
argument_list|(
name|sc
operator|->
name|res
argument_list|,
name|CHIPC_PLL_SLOWCLK_CTL
argument_list|)
expr_stmt|;
name|div
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|div
argument_list|,
name|CHIPC_SCC_CD
argument_list|)
expr_stmt|;
name|div
operator|=
literal|4
operator|*
operator|(
name|div
operator|+
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PWRCTL_QUIRK
argument_list|(
name|sc
argument_list|,
name|INSTACLK_CTL
argument_list|)
condition|)
block|{
if|if
condition|(
name|max_freq
condition|)
block|{
name|div
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|div
operator|=
name|bhnd_bus_read_4
argument_list|(
name|sc
operator|->
name|res
argument_list|,
name|CHIPC_SYS_CLK_CTL
argument_list|)
expr_stmt|;
name|div
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|div
argument_list|,
name|CHIPC_SYCC_CD
argument_list|)
expr_stmt|;
name|div
operator|=
literal|4
operator|*
operator|(
name|div
operator|+
literal|1
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unknown device type\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Determine clock frequency */
switch|switch
condition|(
name|slowclk
condition|)
block|{
case|case
name|BHND_CLKSRC_LPO
case|:
name|hz
operator|=
name|max_freq
condition|?
name|CHIPC_LPOMAXFREQ
else|:
name|CHIPC_LPOMINFREQ
expr_stmt|;
break|break;
case|case
name|BHND_CLKSRC_XTAL
case|:
name|hz
operator|=
name|max_freq
condition|?
name|CHIPC_XTALMAXFREQ
else|:
name|CHIPC_XTALMINFREQ
expr_stmt|;
break|break;
case|case
name|BHND_CLKSRC_PCI
case|:
name|hz
operator|=
name|max_freq
condition|?
name|CHIPC_PCIMAXFREQ
else|:
name|CHIPC_PCIMINFREQ
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unknown slowclk source %#x\n"
argument_list|,
name|slowclk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|hz
operator|/
name|div
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize power control registers.  */
end_comment

begin_function
name|int
name|bhnd_pwrctl_init
parameter_list|(
name|struct
name|bhnd_pwrctl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|clkctl
decl_stmt|;
name|uint32_t
name|pll_delay
decl_stmt|,
name|slowclk
decl_stmt|,
name|slowmaxfreq
decl_stmt|;
name|uint32_t
name|pll_on_delay
decl_stmt|,
name|fref_sel_delay
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pll_delay
operator|=
name|CHIPC_PLL_DELAY
expr_stmt|;
comment|/* set all Instaclk chip ILP to 1 MHz */
if|if
condition|(
name|PWRCTL_QUIRK
argument_list|(
name|sc
argument_list|,
name|INSTACLK_CTL
argument_list|)
condition|)
block|{
name|clkctl
operator|=
operator|(
name|CHIPC_ILP_DIV_1MHZ
operator|<<
name|CHIPC_SYCC_CD_SHIFT
operator|)
expr_stmt|;
name|clkctl
operator|&=
name|CHIPC_SYCC_CD_MASK
expr_stmt|;
name|bhnd_bus_write_4
argument_list|(
name|sc
operator|->
name|res
argument_list|,
name|CHIPC_SYS_CLK_CTL
argument_list|,
name|clkctl
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * Initialize PLL/FREF delays. 	 *  	 * If the slow clock is not sourced by the xtal, include the 	 * delay required to bring it up. 	 */
name|slowclk
operator|=
name|bhnd_pwrctl_slowclk_src
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|slowclk
operator|!=
name|CHIPC_SCC_SS_XTAL
condition|)
name|pll_delay
operator|+=
name|CHIPC_XTAL_ON_DELAY
expr_stmt|;
comment|/* Starting with 4318 it is ILP that is used for the delays */
if|if
condition|(
name|PWRCTL_QUIRK
argument_list|(
name|sc
argument_list|,
name|INSTACLK_CTL
argument_list|)
condition|)
name|slowmaxfreq
operator|=
name|bhnd_pwrctl_slowclk_freq
argument_list|(
name|sc
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|slowmaxfreq
operator|=
name|bhnd_pwrctl_slowclk_freq
argument_list|(
name|sc
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|pll_on_delay
operator|=
operator|(
operator|(
name|slowmaxfreq
operator|*
name|pll_delay
operator|)
operator|+
literal|999999
operator|)
operator|/
literal|1000000
expr_stmt|;
name|fref_sel_delay
operator|=
operator|(
operator|(
name|slowmaxfreq
operator|*
name|CHIPC_FREF_DELAY
operator|)
operator|+
literal|999999
operator|)
operator|/
literal|1000000
expr_stmt|;
name|bhnd_bus_write_4
argument_list|(
name|sc
operator|->
name|res
argument_list|,
name|CHIPC_PLL_ON_DELAY
argument_list|,
name|pll_on_delay
argument_list|)
expr_stmt|;
name|bhnd_bus_write_4
argument_list|(
name|sc
operator|->
name|res
argument_list|,
name|CHIPC_PLL_FREFSEL_DELAY
argument_list|,
name|fref_sel_delay
argument_list|)
expr_stmt|;
comment|/* If required, force HT */
if|if
condition|(
name|PWRCTL_QUIRK
argument_list|(
name|sc
argument_list|,
name|FORCE_HT
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_pwrctl_setclk
argument_list|(
name|sc
argument_list|,
name|BHND_CLOCK_HT
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return the value suitable for writing to the dot11 core  * FAST_PWRUP_DELAY register */
end_comment

begin_function
name|uint16_t
name|bhnd_pwrctl_fast_pwrup_delay
parameter_list|(
name|struct
name|bhnd_pwrctl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|pll_on_delay
decl_stmt|,
name|slowminfreq
decl_stmt|;
name|uint16_t
name|fpdelay
decl_stmt|;
name|fpdelay
operator|=
literal|0
expr_stmt|;
name|slowminfreq
operator|=
name|bhnd_pwrctl_slowclk_freq
argument_list|(
name|sc
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pll_on_delay
operator|=
name|bhnd_bus_read_4
argument_list|(
name|sc
operator|->
name|res
argument_list|,
name|CHIPC_PLL_ON_DELAY
argument_list|)
operator|+
literal|2
expr_stmt|;
name|pll_on_delay
operator|*=
literal|1000000
expr_stmt|;
name|pll_on_delay
operator|+=
operator|(
name|slowminfreq
operator|-
literal|1
operator|)
expr_stmt|;
name|fpdelay
operator|=
name|pll_on_delay
operator|/
name|slowminfreq
expr_stmt|;
return|return
operator|(
name|fpdelay
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Distribute @p clock on backplane.  *   * @param sc Driver instance state.  * @param clock Clock to enable.  *   * @retval 0 success  * @retval ENODEV If @p clock is unsupported, or if the device does not  * 		  support dynamic clock control.  */
end_comment

begin_function
name|int
name|bhnd_pwrctl_setclk
parameter_list|(
name|struct
name|bhnd_pwrctl_softc
modifier|*
name|sc
parameter_list|,
name|bhnd_clock
name|clock
parameter_list|)
block|{
name|uint32_t
name|scc
decl_stmt|;
name|PWRCTL_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Is dynamic clock control supported? */
if|if
condition|(
name|PWRCTL_QUIRK
argument_list|(
name|sc
argument_list|,
name|FIXED_CLK
argument_list|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Chips with ccrev 10 are EOL and they don't have SYCC_HR used below */
if|if
condition|(
name|bhnd_get_hwrev
argument_list|(
name|sc
operator|->
name|chipc_dev
argument_list|)
operator|==
literal|10
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
name|PWRCTL_QUIRK
argument_list|(
name|sc
argument_list|,
name|SLOWCLK_CTL
argument_list|)
condition|)
name|scc
operator|=
name|bhnd_bus_read_4
argument_list|(
name|sc
operator|->
name|res
argument_list|,
name|CHIPC_PLL_SLOWCLK_CTL
argument_list|)
expr_stmt|;
else|else
name|scc
operator|=
name|bhnd_bus_read_4
argument_list|(
name|sc
operator|->
name|res
argument_list|,
name|CHIPC_SYS_CLK_CTL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|clock
condition|)
block|{
case|case
name|BHND_CLOCK_HT
case|:
comment|/* fast (pll) clock */
if|if
condition|(
name|PWRCTL_QUIRK
argument_list|(
name|sc
argument_list|,
name|SLOWCLK_CTL
argument_list|)
condition|)
block|{
name|scc
operator|&=
operator|~
operator|(
name|CHIPC_SCC_XC
operator||
name|CHIPC_SCC_FS
operator||
name|CHIPC_SCC_IP
operator|)
expr_stmt|;
name|scc
operator||=
name|CHIPC_SCC_IP
expr_stmt|;
comment|/* force xtal back on before clearing SCC_DYN_XTAL.. */
name|bhnd_pwrctl_ungate_clock
argument_list|(
name|sc
operator|->
name|chipc_dev
argument_list|,
name|BHND_CLOCK_HT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PWRCTL_QUIRK
argument_list|(
name|sc
argument_list|,
name|INSTACLK_CTL
argument_list|)
condition|)
block|{
name|scc
operator||=
name|CHIPC_SYCC_HR
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
if|if
condition|(
name|PWRCTL_QUIRK
argument_list|(
name|sc
argument_list|,
name|SLOWCLK_CTL
argument_list|)
condition|)
name|bhnd_bus_write_4
argument_list|(
name|sc
operator|->
name|res
argument_list|,
name|CHIPC_PLL_SLOWCLK_CTL
argument_list|,
name|scc
argument_list|)
expr_stmt|;
else|else
name|bhnd_bus_write_4
argument_list|(
name|sc
operator|->
name|res
argument_list|,
name|CHIPC_SYS_CLK_CTL
argument_list|,
name|scc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|CHIPC_PLL_DELAY
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_CLOCK_DYN
case|:
comment|/* enable dynamic clock control */
if|if
condition|(
name|PWRCTL_QUIRK
argument_list|(
name|sc
argument_list|,
name|SLOWCLK_CTL
argument_list|)
condition|)
block|{
name|scc
operator|&=
operator|~
operator|(
name|CHIPC_SCC_FS
operator||
name|CHIPC_SCC_IP
operator||
name|CHIPC_SCC_XC
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|scc
operator|&
name|CHIPC_SCC_SS_MASK
operator|)
operator|!=
name|CHIPC_SCC_SS_XTAL
condition|)
name|scc
operator||=
name|CHIPC_SCC_XC
expr_stmt|;
name|bhnd_bus_write_4
argument_list|(
name|sc
operator|->
name|res
argument_list|,
name|CHIPC_PLL_SLOWCLK_CTL
argument_list|,
name|scc
argument_list|)
expr_stmt|;
comment|/* for dynamic control, we have to release our xtal_pu 			 * "force on" */
if|if
condition|(
name|scc
operator|&
name|CHIPC_SCC_XC
condition|)
block|{
name|bhnd_pwrctl_gate_clock
argument_list|(
name|sc
operator|->
name|chipc_dev
argument_list|,
name|BHND_CLOCK_HT
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|PWRCTL_QUIRK
argument_list|(
name|sc
argument_list|,
name|INSTACLK_CTL
argument_list|)
condition|)
block|{
comment|/* Instaclock */
name|scc
operator|&=
operator|~
name|CHIPC_SYCC_HR
expr_stmt|;
name|bhnd_bus_write_4
argument_list|(
name|sc
operator|->
name|res
argument_list|,
name|CHIPC_SYS_CLK_CTL
argument_list|,
name|scc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
break|break;
default|default:
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

