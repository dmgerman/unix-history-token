begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Landon Fuller<landonf@FreeBSD.org>  * Copyright (c) 2010 Broadcom Corporation.  * Copyright (c) 2017 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by Landon Fuller  * under sponsorship from the FreeBSD Foundation.  *   * Portions of this file were derived from the siutils.c source distributed with  * the Asus RT-N16 firmware source code release.  *   * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY  * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $Id: siutils.c,v 1.821.2.48 2011-02-11 20:59:28 Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhnd.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/chipc/chipcreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/chipc/chipcvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/pmu/bhnd_pmuvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/pmu/bhnd_pmureg.h>
end_include

begin_include
include|#
directive|include
file|"bhnd_chipc_if.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_pwrctl_if.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_pwrctl_hostb_if.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_pwrctl_private.h"
end_include

begin_comment
comment|/*  * ChipCommon Power Control.  *   * Provides a runtime interface to device clocking and power management on  * legacy non-PMU chipsets.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|BHND_PWRCTL_WAR_UP
block|,
comment|/**< apply attach/resume workarounds */
name|BHND_PWRCTL_WAR_RUN
block|,
comment|/**< apply running workarounds */
name|BHND_PWRCTL_WAR_DOWN
block|,
comment|/**< apply detach/suspend workarounds */
block|}
name|bhnd_pwrctl_wars
typedef|;
end_typedef

begin_function_decl
specifier|static
name|int
name|bhnd_pwrctl_updateclk
parameter_list|(
name|struct
name|bhnd_pwrctl_softc
modifier|*
name|sc
parameter_list|,
name|bhnd_pwrctl_wars
name|wars
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|bhnd_device_quirk
name|pwrctl_quirks
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Supported parent core device identifiers */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bhnd_device
name|pwrctl_devices
index|[]
init|=
block|{
name|BHND_DEVICE
argument_list|(
name|BCM
argument_list|,
name|CC
argument_list|,
literal|"ChipCommon Power Control"
argument_list|,
name|pwrctl_quirks
argument_list|)
block|,
name|BHND_DEVICE_END
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Device quirks table */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bhnd_device_quirk
name|pwrctl_quirks
index|[]
init|=
block|{
name|BHND_CORE_QUIRK
argument_list|(
name|HWREV_LTE
argument_list|(
literal|5
argument_list|)
argument_list|,
name|PWRCTL_QUIRK_PCICLK_CTL
argument_list|)
block|,
name|BHND_CORE_QUIRK
argument_list|(
name|HWREV_RANGE
argument_list|(
literal|6
argument_list|,
literal|9
argument_list|)
argument_list|,
name|PWRCTL_QUIRK_SLOWCLK_CTL
argument_list|)
block|,
name|BHND_CORE_QUIRK
argument_list|(
name|HWREV_RANGE
argument_list|(
literal|10
argument_list|,
literal|19
argument_list|)
argument_list|,
name|PWRCTL_QUIRK_INSTACLK_CTL
argument_list|)
block|,
name|BHND_DEVICE_QUIRK_END
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|bhnd_pwrctl_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_device
modifier|*
name|id
decl_stmt|;
name|struct
name|chipc_caps
modifier|*
name|ccaps
decl_stmt|;
name|device_t
name|chipc
decl_stmt|;
comment|/* Look for compatible chipc parent */
name|chipc
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_devclass
argument_list|(
name|chipc
argument_list|)
operator|!=
name|devclass_find
argument_list|(
literal|"bhnd_chipc"
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|device_get_driver
argument_list|(
name|chipc
argument_list|)
operator|!=
operator|&
name|bhnd_chipc_driver
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Verify chipc capability flags */
name|ccaps
operator|=
name|BHND_CHIPC_GET_CAPS
argument_list|(
name|chipc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccaps
operator|->
name|pmu
operator|||
operator|!
name|ccaps
operator|->
name|pwr_ctrl
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Check for chipc device match */
name|id
operator|=
name|bhnd_device_lookup
argument_list|(
name|chipc
argument_list|,
name|pwrctl_devices
argument_list|,
sizeof|sizeof
argument_list|(
name|pwrctl_devices
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|id
operator|->
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_NOWILDCARD
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_pwrctl_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhnd_pwrctl_softc
modifier|*
name|sc
decl_stmt|;
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|cid
decl_stmt|;
name|struct
name|chipc_softc
modifier|*
name|chipc_sc
decl_stmt|;
name|bhnd_devclass_t
name|hostb_class
decl_stmt|;
name|device_t
name|hostb_dev
decl_stmt|;
name|device_t
name|bus
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|chipc_dev
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|quirks
operator|=
name|bhnd_device_quirks
argument_list|(
name|sc
operator|->
name|chipc_dev
argument_list|,
name|pwrctl_devices
argument_list|,
sizeof|sizeof
argument_list|(
name|pwrctl_devices
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|chipc_dev
argument_list|)
expr_stmt|;
comment|/* On devices that lack a slow clock source, HT must always be 	 * enabled. */
name|hostb_class
operator|=
name|BHND_DEVCLASS_INVALID
expr_stmt|;
name|hostb_dev
operator|=
name|bhnd_bus_find_hostb_device
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|chipc_dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostb_dev
operator|!=
name|NULL
condition|)
name|hostb_class
operator|=
name|bhnd_get_class
argument_list|(
name|hostb_dev
argument_list|)
expr_stmt|;
name|cid
operator|=
name|bhnd_get_chipid
argument_list|(
name|sc
operator|->
name|chipc_dev
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cid
operator|->
name|chip_id
condition|)
block|{
case|case
name|BHND_CHIPID_BCM4311
case|:
if|if
condition|(
name|cid
operator|->
name|chip_rev
operator|<=
literal|1
operator|&&
name|hostb_class
operator|==
name|BHND_DEVCLASS_PCI
condition|)
name|sc
operator|->
name|quirks
operator||=
name|PWRCTL_QUIRK_FORCE_HT
expr_stmt|;
break|break;
case|case
name|BHND_CHIPID_BCM4321
case|:
if|if
condition|(
name|hostb_class
operator|==
name|BHND_DEVCLASS_PCIE
operator|||
name|hostb_class
operator|==
name|BHND_DEVCLASS_PCI
condition|)
name|sc
operator|->
name|quirks
operator||=
name|PWRCTL_QUIRK_FORCE_HT
expr_stmt|;
break|break;
case|case
name|BHND_CHIPID_BCM4716
case|:
if|if
condition|(
name|hostb_class
operator|==
name|BHND_DEVCLASS_PCIE
condition|)
name|sc
operator|->
name|quirks
operator||=
name|PWRCTL_QUIRK_FORCE_HT
expr_stmt|;
break|break;
block|}
comment|/* Fetch core register block from ChipCommon parent */
name|chipc_sc
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|chipc_dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|res
operator|=
name|chipc_sc
operator|->
name|core
expr_stmt|;
name|PWRCTL_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|clkres_list
argument_list|)
expr_stmt|;
comment|/* Initialize power control */
name|PWRCTL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_pwrctl_init
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
block|{
name|PWRCTL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Apply default clock transitions */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_pwrctl_updateclk
argument_list|(
name|sc
argument_list|,
name|BHND_PWRCTL_WAR_UP
argument_list|)
operator|)
condition|)
block|{
name|PWRCTL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|PWRCTL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Register as the bus PWRCTL provider */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_register_provider
argument_list|(
name|dev
argument_list|,
name|BHND_SERVICE_PWRCTL
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to register PWRCTL with bus : "
literal|"%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|cleanup
label|:
name|PWRCTL_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_pwrctl_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhnd_pwrctl_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bhnd_pwrctl_clkres
modifier|*
name|clkres
decl_stmt|,
modifier|*
name|crnext
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_deregister_provider
argument_list|(
name|dev
argument_list|,
name|BHND_SERVICE_ANY
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|PWRCTL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_pwrctl_setclk
argument_list|(
name|sc
argument_list|,
name|BHND_CLOCK_DYN
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|PWRCTL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|clkres
argument_list|,
argument|&sc->clkres_list
argument_list|,
argument|cr_link
argument_list|,
argument|crnext
argument_list|)
name|free
argument_list|(
name|clkres
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|PWRCTL_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_pwrctl_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhnd_pwrctl_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Update clock state */
name|PWRCTL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|bhnd_pwrctl_updateclk
argument_list|(
name|sc
argument_list|,
name|BHND_PWRCTL_WAR_DOWN
argument_list|)
expr_stmt|;
name|PWRCTL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_pwrctl_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhnd_pwrctl_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|PWRCTL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Re-initialize power control registers */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_pwrctl_init
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"PWRCTL init failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Restore clock state */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_pwrctl_updateclk
argument_list|(
name|sc
argument_list|,
name|BHND_PWRCTL_WAR_UP
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"clock state restore failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|cleanup
label|:
name|PWRCTL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_pwrctl_get_clock_latency
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|bhnd_clock
name|clock
parameter_list|,
name|u_int
modifier|*
name|latency
parameter_list|)
block|{
name|struct
name|bhnd_pwrctl_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|clock
condition|)
block|{
case|case
name|BHND_CLOCK_HT
case|:
name|PWRCTL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|*
name|latency
operator|=
name|bhnd_pwrctl_fast_pwrup_delay
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|PWRCTL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_pwrctl_get_clock_freq
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|bhnd_clock
name|clock
parameter_list|,
name|u_int
modifier|*
name|freq
parameter_list|)
block|{
name|struct
name|bhnd_pwrctl_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|clock
condition|)
block|{
case|case
name|BHND_CLOCK_ALP
case|:
name|BPMU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|*
name|freq
operator|=
name|bhnd_pwrctl_getclk_speed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BPMU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|BHND_CLOCK_HT
case|:
case|case
name|BHND_CLOCK_ILP
case|:
case|case
name|BHND_CLOCK_DYN
case|:
default|default:
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Find the clock reservation associated with @p owner, if any.  *   * @param sc Driver instance state.  * @param owner The owning device.  */
end_comment

begin_function
specifier|static
name|struct
name|bhnd_pwrctl_clkres
modifier|*
name|bhnd_pwrctl_find_res
parameter_list|(
name|struct
name|bhnd_pwrctl_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|owner
parameter_list|)
block|{
name|struct
name|bhnd_pwrctl_clkres
modifier|*
name|clkres
decl_stmt|;
name|PWRCTL_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|clkres
argument_list|,
argument|&sc->clkres_list
argument_list|,
argument|cr_link
argument_list|)
block|{
if|if
condition|(
name|clkres
operator|->
name|owner
operator|==
name|owner
condition|)
return|return
operator|(
name|clkres
operator|)
return|;
block|}
comment|/* not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Enumerate all active clock requests, compute the minimum required clock,  * and issue any required clock transition.  *   * @param sc Driver instance state.  * @param wars Work-around state.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_pwrctl_updateclk
parameter_list|(
name|struct
name|bhnd_pwrctl_softc
modifier|*
name|sc
parameter_list|,
name|bhnd_pwrctl_wars
name|wars
parameter_list|)
block|{
name|struct
name|bhnd_pwrctl_clkres
modifier|*
name|clkres
decl_stmt|;
name|bhnd_clock
name|clock
decl_stmt|;
name|PWRCTL_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Default clock target */
name|clock
operator|=
name|BHND_CLOCK_DYN
expr_stmt|;
comment|/* Apply quirk-specific overrides to the clock target */
switch|switch
condition|(
name|wars
condition|)
block|{
case|case
name|BHND_PWRCTL_WAR_UP
case|:
comment|/* Force HT clock */
if|if
condition|(
name|PWRCTL_QUIRK
argument_list|(
name|sc
argument_list|,
name|FORCE_HT
argument_list|)
condition|)
name|clock
operator|=
name|BHND_CLOCK_HT
expr_stmt|;
break|break;
case|case
name|BHND_PWRCTL_WAR_RUN
case|:
comment|/* Cannot transition clock if FORCE_HT */
if|if
condition|(
name|PWRCTL_QUIRK
argument_list|(
name|sc
argument_list|,
name|FORCE_HT
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|BHND_PWRCTL_WAR_DOWN
case|:
comment|/* Leave default clock unmodified to permit 		 * transition back to BHND_CLOCK_DYN on FORCE_HT devices. */
break|break;
block|}
comment|/* Determine required clock */
name|STAILQ_FOREACH
argument_list|(
argument|clkres
argument_list|,
argument|&sc->clkres_list
argument_list|,
argument|cr_link
argument_list|)
name|clock
operator|=
name|bhnd_clock_max
argument_list|(
name|clock
argument_list|,
name|clkres
operator|->
name|clock
argument_list|)
expr_stmt|;
comment|/* Map to supported clock setting */
switch|switch
condition|(
name|clock
condition|)
block|{
case|case
name|BHND_CLOCK_DYN
case|:
case|case
name|BHND_CLOCK_ILP
case|:
name|clock
operator|=
name|BHND_CLOCK_DYN
expr_stmt|;
break|break;
case|case
name|BHND_CLOCK_ALP
case|:
comment|/* In theory FORCE_ALP is supported by the hardware, but 		 * there are currently no known use-cases for it; mapping 		 * to HT is still valid, and allows us to punt on determing 		 * where FORCE_ALP is supported and functional */
name|clock
operator|=
name|BHND_CLOCK_HT
expr_stmt|;
break|break;
case|case
name|BHND_CLOCK_HT
case|:
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unknown clock: %#x\n"
argument_list|,
name|clock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* Issue transition */
return|return
operator|(
name|bhnd_pwrctl_setclk
argument_list|(
name|sc
argument_list|,
name|clock
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* BHND_PWRCTL_REQUEST_CLOCK() */
end_comment

begin_function
specifier|static
name|int
name|bhnd_pwrctl_request_clock
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|bhnd_clock
name|clock
parameter_list|)
block|{
name|struct
name|bhnd_pwrctl_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bhnd_pwrctl_clkres
modifier|*
name|clkres
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|PWRCTL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|clkres
operator|=
name|bhnd_pwrctl_find_res
argument_list|(
name|sc
argument_list|,
name|child
argument_list|)
expr_stmt|;
comment|/* BHND_CLOCK_DYN discards the clock reservation entirely */
if|if
condition|(
name|clock
operator|==
name|BHND_CLOCK_DYN
condition|)
block|{
comment|/* nothing to clean up? */
if|if
condition|(
name|clkres
operator|==
name|NULL
condition|)
block|{
name|PWRCTL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* drop reservation and apply clock transition */
name|STAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|clkres_list
argument_list|,
name|clkres
argument_list|,
name|bhnd_pwrctl_clkres
argument_list|,
name|cr_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_pwrctl_updateclk
argument_list|(
name|sc
argument_list|,
name|BHND_PWRCTL_WAR_RUN
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"clock transition failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* restore reservation */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|clkres_list
argument_list|,
name|clkres
argument_list|,
name|cr_link
argument_list|)
expr_stmt|;
name|PWRCTL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* deallocate orphaned reservation */
name|free
argument_list|(
name|clkres
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|PWRCTL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* create (or update) reservation */
if|if
condition|(
name|clkres
operator|==
name|NULL
condition|)
block|{
name|clkres
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bhnd_pwrctl_clkres
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|clkres
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|clkres
operator|->
name|owner
operator|=
name|child
expr_stmt|;
name|clkres
operator|->
name|clock
operator|=
name|clock
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|clkres_list
argument_list|,
name|clkres
argument_list|,
name|cr_link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|clkres
operator|->
name|owner
operator|==
name|child
argument_list|,
operator|(
literal|"invalid owner"
operator|)
argument_list|)
expr_stmt|;
name|clkres
operator|->
name|clock
operator|=
name|clock
expr_stmt|;
block|}
comment|/* apply clock transition */
name|error
operator|=
name|bhnd_pwrctl_updateclk
argument_list|(
name|sc
argument_list|,
name|BHND_PWRCTL_WAR_RUN
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|clkres_list
argument_list|,
name|clkres
argument_list|,
name|bhnd_pwrctl_clkres
argument_list|,
name|cr_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|clkres
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|PWRCTL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|bhnd_pwrctl_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|bhnd_pwrctl_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|bhnd_pwrctl_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bhnd_pwrctl_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bhnd_pwrctl_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bhnd_pwrctl_resume
argument_list|)
block|,
comment|/* BHND PWRCTL interface */
name|DEVMETHOD
argument_list|(
name|bhnd_pwrctl_request_clock
argument_list|,
name|bhnd_pwrctl_request_clock
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_pwrctl_get_clock_freq
argument_list|,
name|bhnd_pwrctl_get_clock_freq
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_pwrctl_get_clock_latency
argument_list|,
name|bhnd_pwrctl_get_clock_latency
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|bhnd_pwrctl
argument_list|,
name|bhnd_pwrctl_driver
argument_list|,
name|bhnd_pwrctl_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bhnd_pwrctl_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EARLY_DRIVER_MODULE
argument_list|(
name|bhnd_pwrctl
argument_list|,
name|bhnd_chipc
argument_list|,
name|bhnd_pwrctl_driver
argument_list|,
name|bhnd_pmu_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|BUS_PASS_TIMER
operator|+
name|BUS_PASS_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bhnd_pwrctl
argument_list|,
name|bhnd
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|bhnd_pwrctl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

