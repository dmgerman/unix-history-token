begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 Landon Fuller<landon@landonf.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|"bcma_eromreg.h"
end_include

begin_include
include|#
directive|include
file|"bcma_eromvar.h"
end_include

begin_comment
comment|/*  * BCMA Enumeration ROM (EROM) Table  *   * Provides auto-discovery of BCMA cores on Broadcom's HND SoC.  *   * The EROM core address can be found at BCMA_CC_EROM_ADDR within the  * ChipCommon registers. The table itself is comprised of 32-bit  * type-tagged entries, organized into an array of variable-length  * core descriptor records.  *   * The final core descriptor is followed by a 32-bit BCMA_EROM_TABLE_EOF (0xF)  * marker.  */
end_comment

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|erom_entry_type_name
parameter_list|(
name|uint8_t
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|erom_read32
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|uint32_t
modifier|*
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|erom_skip32
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|erom_skip_core
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|erom_skip_mport
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|erom_skip_sport_region
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|erom_seek_next
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|uint8_t
name|etype
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|EROM_LOG
parameter_list|(
name|erom
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
define|\
value|device_printf(erom->dev, "erom[0x%llx]: " fmt, \ 	    (unsigned long long) (erom->offset), ##__VA_ARGS__);
end_define

begin_comment
comment|/**  * Open an EROM table for reading.  *   * @param[out] erom On success, will be populated with a valid EROM  * read state.  * @param r An active resource mapping the EROM core.  * @param offset Offset of the EROM core within @p resource.  *  * @retval 0 success  * @retval non-zero if the erom table could not be opened.  */
end_comment

begin_function
name|int
name|bcma_erom_open
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|bus_size_t
name|offset
parameter_list|)
block|{
comment|/* Initialize the EROM reader */
name|erom
operator|->
name|dev
operator|=
name|rman_get_device
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|erom
operator|->
name|r
operator|=
name|r
expr_stmt|;
name|erom
operator|->
name|start
operator|=
name|offset
operator|+
name|BCMA_EROM_TABLE_START
expr_stmt|;
name|erom
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/** Return the type name for an EROM entry */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|erom_entry_type_name
parameter_list|(
name|uint8_t
name|entry
parameter_list|)
block|{
switch|switch
condition|(
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|ENTRY_TYPE
argument_list|)
condition|)
block|{
case|case
name|BCMA_EROM_ENTRY_TYPE_CORE
case|:
return|return
literal|"core"
return|;
case|case
name|BCMA_EROM_ENTRY_TYPE_MPORT
case|:
return|return
literal|"mport"
return|;
case|case
name|BCMA_EROM_ENTRY_TYPE_REGION
case|:
return|return
literal|"region"
return|;
default|default:
return|return
literal|"unknown"
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Return the current read position.  */
end_comment

begin_function
name|bus_size_t
name|bcma_erom_tell
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
block|{
return|return
operator|(
name|erom
operator|->
name|offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Seek to an absolute read position.  */
end_comment

begin_function
name|void
name|bcma_erom_seek
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|bus_size_t
name|offset
parameter_list|)
block|{
name|erom
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Read a 32-bit entry value from the EROM table without advancing the  * read position.  *   * @param erom EROM read state.  * @param entry Will contain the read result on success.  * @retval 0 success  * @retval ENOENT The end of the EROM table was reached.  * @retval non-zero The read could not be completed.  */
end_comment

begin_function
name|int
name|bcma_erom_peek32
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|uint32_t
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|erom
operator|->
name|offset
operator|>=
name|BCMA_EROM_TABLE_SIZE
condition|)
block|{
name|EROM_LOG
argument_list|(
name|erom
argument_list|,
literal|"BCMA EROM table missing terminating EOF\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|entry
operator|=
name|bus_read_4
argument_list|(
name|erom
operator|->
name|r
argument_list|,
name|erom
operator|->
name|start
operator|+
name|erom
operator|->
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read a 32-bit entry value from the EROM table.  *   * @param erom EROM read state.  * @param entry Will contain the read result on success.  * @retval 0 success  * @retval ENOENT The end of the EROM table was reached.  * @retval non-zero The read could not be completed.  */
end_comment

begin_function
specifier|static
name|int
name|erom_read32
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|uint32_t
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_peek32
argument_list|(
name|erom
argument_list|,
name|entry
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|erom
operator|->
name|offset
operator|+=
literal|4
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read and discard 32-bit entry value from the EROM table.  *   * @param erom EROM read state.  * @retval 0 success  * @retval ENOENT The end of the EROM table was reached.  * @retval non-zero The read could not be completed.  */
end_comment

begin_function
specifier|static
name|int
name|erom_skip32
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
block|{
name|uint32_t
name|entry
decl_stmt|;
return|return
name|erom_read32
argument_list|(
name|erom
argument_list|,
operator|&
name|entry
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read and discard a core descriptor from the EROM table.  *   * @param erom EROM read state.  * @retval 0 success  * @retval ENOENT The end of the EROM table was reached.  * @retval non-zero The read could not be completed.  */
end_comment

begin_function
specifier|static
name|int
name|erom_skip_core
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
block|{
name|struct
name|bcma_erom_core
name|core
decl_stmt|;
return|return
operator|(
name|bcma_erom_parse_core
argument_list|(
name|erom
argument_list|,
operator|&
name|core
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read and discard a master port descriptor from the EROM table.  *   * @param erom EROM read state.  * @retval 0 success  * @retval ENOENT The end of the EROM table was reached.  * @retval non-zero The read could not be completed.  */
end_comment

begin_function
specifier|static
name|int
name|erom_skip_mport
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
block|{
name|struct
name|bcma_erom_mport
name|mp
decl_stmt|;
return|return
operator|(
name|bcma_erom_parse_mport
argument_list|(
name|erom
argument_list|,
operator|&
name|mp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read and discard a port region descriptor from the EROM table.  *   * @param erom EROM read state.  * @retval 0 success  * @retval ENOENT The end of the EROM table was reached.  * @retval non-zero The read could not be completed.  */
end_comment

begin_function
specifier|static
name|int
name|erom_skip_sport_region
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
block|{
name|struct
name|bcma_erom_sport_region
name|r
decl_stmt|;
return|return
operator|(
name|bcma_erom_parse_sport_region
argument_list|(
name|erom
argument_list|,
operator|&
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Seek to the next entry matching the given EROM entry type.  *   * @param erom EROM read state.  * @param etype  One of BCMA_EROM_ENTRY_TYPE_CORE,  * BCMA_EROM_ENTRY_TYPE_MPORT, or BCMA_EROM_ENTRY_TYPE_REGION.  * @retval 0 success  * @retval ENOENT The end of the EROM table was reached.  * @retval non-zero Reading or parsing the descriptor failed.  */
end_comment

begin_function
specifier|static
name|int
name|erom_seek_next
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|uint8_t
name|etype
parameter_list|)
block|{
name|uint32_t
name|entry
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Iterate until we hit an entry matching the requested type. */
while|while
condition|(
operator|!
operator|(
name|error
operator|=
name|bcma_erom_peek32
argument_list|(
name|erom
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
block|{
comment|/* Handle EOF */
if|if
condition|(
name|entry
operator|==
name|BCMA_EROM_TABLE_EOF
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Invalid entry */
if|if
condition|(
operator|!
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|ENTRY_ISVALID
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Entry type matches? */
if|if
condition|(
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|ENTRY_TYPE
argument_list|)
operator|==
name|etype
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Skip non-matching entry types. */
switch|switch
condition|(
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|ENTRY_TYPE
argument_list|)
condition|)
block|{
case|case
name|BCMA_EROM_ENTRY_TYPE_CORE
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|erom_skip_core
argument_list|(
name|erom
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|BCMA_EROM_ENTRY_TYPE_MPORT
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|erom_skip_mport
argument_list|(
name|erom
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|BCMA_EROM_ENTRY_TYPE_REGION
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|erom_skip_sport_region
argument_list|(
name|erom
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
default|default:
comment|/* Unknown entry type! */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the read position to the start of the EROM table.  *   * @param erom EROM read state.  */
end_comment

begin_function
name|void
name|bcma_erom_reset
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
block|{
name|erom
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Seek to the requested core entry.  *   * @param erom EROM read state.  * @param core_index Index of the core to seek to.  * @retval 0 success  * @retval ENOENT The end of the EROM table was reached before @p index was  * found.  * @retval non-zero Reading or parsing failed.  */
end_comment

begin_function
name|int
name|bcma_erom_seek_core_index
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|u_int
name|core_index
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Start search at top of EROM */
name|bcma_erom_reset
argument_list|(
name|erom
argument_list|)
expr_stmt|;
comment|/* Skip core descriptors till we hit the requested entry */
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|core_index
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bcma_erom_core
name|core
decl_stmt|;
comment|/* Read past the core descriptor */
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_parse_core
argument_list|(
name|erom
argument_list|,
operator|&
name|core
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Seek to the next readable core entry */
name|error
operator|=
name|erom_seek_next
argument_list|(
name|erom
argument_list|,
name|BCMA_EROM_ENTRY_TYPE_CORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read the next core descriptor from the EROM table.  *   * @param erom EROM read state.  * @param[out] core On success, will be populated with the parsed core  * descriptor data.  * @retval 0 success  * @retval ENOENT The end of the EROM table was reached.  * @retval non-zero Reading or parsing the core descriptor failed.  */
end_comment

begin_function
name|int
name|bcma_erom_parse_core
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|struct
name|bcma_erom_core
modifier|*
name|core
parameter_list|)
block|{
name|uint32_t
name|entry
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Parse CoreDescA */
if|if
condition|(
operator|(
name|error
operator|=
name|erom_read32
argument_list|(
name|erom
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Handle EOF */
if|if
condition|(
name|entry
operator|==
name|BCMA_EROM_TABLE_EOF
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
operator|!
name|BCMA_EROM_ENTRY_IS
argument_list|(
name|entry
argument_list|,
name|CORE
argument_list|)
condition|)
block|{
name|EROM_LOG
argument_list|(
name|erom
argument_list|,
literal|"Unexpected EROM entry 0x%x (type=%s)\n"
argument_list|,
name|entry
argument_list|,
name|erom_entry_type_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|core
operator|->
name|vendor
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREA_DESIGNER
argument_list|)
expr_stmt|;
name|core
operator|->
name|device
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREA_ID
argument_list|)
expr_stmt|;
comment|/* Parse CoreDescB */
if|if
condition|(
operator|(
name|error
operator|=
name|erom_read32
argument_list|(
name|erom
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|BCMA_EROM_ENTRY_IS
argument_list|(
name|entry
argument_list|,
name|CORE
argument_list|)
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|core
operator|->
name|rev
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREB_REV
argument_list|)
expr_stmt|;
name|core
operator|->
name|num_mport
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREB_NUM_MP
argument_list|)
expr_stmt|;
name|core
operator|->
name|num_dport
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREB_NUM_DP
argument_list|)
expr_stmt|;
name|core
operator|->
name|num_mwrap
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREB_NUM_WMP
argument_list|)
expr_stmt|;
name|core
operator|->
name|num_swrap
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREB_NUM_WSP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read the next master port descriptor from the EROM table.  *   * @param erom EROM read state.  * @param[out] mport On success, will be populated with the parsed  * descriptor data.  * @retval 0 success  * @retval non-zero Reading or parsing the descriptor failed.  */
end_comment

begin_function
name|int
name|bcma_erom_parse_mport
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|struct
name|bcma_erom_mport
modifier|*
name|mport
parameter_list|)
block|{
name|uint32_t
name|entry
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Parse the master port descriptor */
if|if
condition|(
operator|(
name|error
operator|=
name|erom_read32
argument_list|(
name|erom
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|BCMA_EROM_ENTRY_IS
argument_list|(
name|entry
argument_list|,
name|MPORT
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mport
operator|->
name|port_vid
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|MPORT_ID
argument_list|)
expr_stmt|;
name|mport
operator|->
name|port_num
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|MPORT_NUM
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read the next slave port region descriptor from the EROM table.  *   * @param erom EROM read state.  * @param[out] mport On success, will be populated with the parsed  * descriptor data.  * @retval 0 success  * @retval ENOENT The end of the region descriptor table was reached.  * @retval non-zero Reading or parsing the descriptor failed.  */
end_comment

begin_function
name|int
name|bcma_erom_parse_sport_region
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|struct
name|bcma_erom_sport_region
modifier|*
name|region
parameter_list|)
block|{
name|uint32_t
name|entry
decl_stmt|;
name|uint8_t
name|size_type
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Peek at the region descriptor */
if|if
condition|(
name|bcma_erom_peek32
argument_list|(
name|erom
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* A non-region entry signals the end of the region table */
if|if
condition|(
operator|!
name|BCMA_EROM_ENTRY_IS
argument_list|(
name|entry
argument_list|,
name|REGION
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
else|else
block|{
name|erom_skip32
argument_list|(
name|erom
argument_list|)
expr_stmt|;
block|}
name|region
operator|->
name|base_addr
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_BASE
argument_list|)
expr_stmt|;
name|region
operator|->
name|region_type
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_TYPE
argument_list|)
expr_stmt|;
name|region
operator|->
name|region_port
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_PORT
argument_list|)
expr_stmt|;
name|size_type
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_SIZE
argument_list|)
expr_stmt|;
comment|/* If region address is 64-bit, fetch the high bits. */
if|if
condition|(
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_64BIT
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|erom_read32
argument_list|(
name|erom
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|region
operator|->
name|base_addr
operator||=
operator|(
operator|(
name|bhnd_addr_t
operator|)
name|entry
operator|<<
literal|32
operator|)
expr_stmt|;
block|}
comment|/* Parse the region size; it's either encoded as the binary logarithm 	 * of the number of 4K pages (i.e. log2 n), or its encoded as a 	 * 32-bit/64-bit literal value directly following the current entry. */
if|if
condition|(
name|size_type
operator|==
name|BCMA_EROM_REGION_SIZE_OTHER
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|erom_read32
argument_list|(
name|erom
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|region
operator|->
name|size
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|RSIZE_VAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|RSIZE_64BIT
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|erom_read32
argument_list|(
name|erom
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|region
operator|->
name|size
operator||=
operator|(
operator|(
name|bhnd_size_t
operator|)
name|entry
operator|<<
literal|32
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|region
operator|->
name|size
operator|=
name|BCMA_EROM_REGION_SIZE_BASE
operator|<<
name|size_type
expr_stmt|;
block|}
comment|/* Verify that addr+size does not overflow. */
if|if
condition|(
name|region
operator|->
name|size
operator|!=
literal|0
operator|&&
name|BHND_ADDR_MAX
operator|-
operator|(
name|region
operator|->
name|size
operator|-
literal|1
operator|)
operator|<
name|region
operator|->
name|base_addr
condition|)
block|{
name|EROM_LOG
argument_list|(
name|erom
argument_list|,
literal|"%s%u: invalid address map %llx:%llx\n"
argument_list|,
name|erom_entry_type_name
argument_list|(
name|region
operator|->
name|region_type
argument_list|)
argument_list|,
name|region
operator|->
name|region_port
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|region
operator|->
name|base_addr
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|region
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Parse all cores descriptors from @p erom and return the array  * in @p cores and the count in @p num_cores. The current EROM read position  * is left unmodified.  *   * The memory allocated for the table should be freed using  * `free(*cores, M_BHND)`. @p cores and @p num_cores are not changed  * when an error is returned.  *   * @param erom EROM read state.  * @param[out] cores the table of parsed core descriptors.  * @param[out] num_cores the number of core records in @p cores.  */
end_comment

begin_function
name|int
name|bcma_erom_get_core_info
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
modifier|*
name|cores
parameter_list|,
name|u_int
modifier|*
name|num_cores
parameter_list|)
block|{
name|struct
name|bhnd_core_info
modifier|*
name|buffer
decl_stmt|;
name|bus_size_t
name|initial_offset
decl_stmt|;
name|u_int
name|count
decl_stmt|;
name|int
name|error
decl_stmt|;
name|buffer
operator|=
name|NULL
expr_stmt|;
name|initial_offset
operator|=
name|bcma_erom_tell
argument_list|(
name|erom
argument_list|)
expr_stmt|;
comment|/* Determine the core count */
name|bcma_erom_reset
argument_list|(
name|erom
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|error
operator|=
literal|0
init|;
operator|!
name|error
condition|;
name|count
operator|++
control|)
block|{
name|struct
name|bcma_erom_core
name|core
decl_stmt|;
comment|/* Seek to the first readable core entry */
name|error
operator|=
name|erom_seek_next
argument_list|(
name|erom
argument_list|,
name|BCMA_EROM_ENTRY_TYPE_CORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
break|break;
elseif|else
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Read past the core descriptor */
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_parse_core
argument_list|(
name|erom
argument_list|,
operator|&
name|core
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
block|}
comment|/* Allocate our output buffer */
name|buffer
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bhnd_core_info
argument_list|)
operator|*
name|count
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Parse all core descriptors */
name|bcma_erom_reset
argument_list|(
name|erom
argument_list|)
expr_stmt|;
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bcma_erom_core
name|core
decl_stmt|;
comment|/* Parse the core */
name|error
operator|=
name|erom_seek_next
argument_list|(
name|erom
argument_list|,
name|BCMA_EROM_ENTRY_TYPE_CORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
name|error
operator|=
name|bcma_erom_parse_core
argument_list|(
name|erom
argument_list|,
operator|&
name|core
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Convert to a bhnd info record */
name|buffer
index|[
name|i
index|]
operator|.
name|vendor
operator|=
name|core
operator|.
name|vendor
expr_stmt|;
name|buffer
index|[
name|i
index|]
operator|.
name|device
operator|=
name|core
operator|.
name|device
expr_stmt|;
name|buffer
index|[
name|i
index|]
operator|.
name|hwrev
operator|=
name|core
operator|.
name|rev
expr_stmt|;
name|buffer
index|[
name|i
index|]
operator|.
name|core_idx
operator|=
name|i
expr_stmt|;
name|buffer
index|[
name|i
index|]
operator|.
name|unit
operator|=
literal|0
expr_stmt|;
comment|/* Determine the unit number */
for|for
control|(
name|u_int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|.
name|vendor
operator|==
name|buffer
index|[
name|j
index|]
operator|.
name|vendor
operator|&&
name|buffer
index|[
name|i
index|]
operator|.
name|device
operator|==
name|buffer
index|[
name|j
index|]
operator|.
name|device
condition|)
name|buffer
index|[
name|i
index|]
operator|.
name|unit
operator|++
expr_stmt|;
block|}
block|}
name|cleanup
label|:
if|if
condition|(
operator|!
name|error
condition|)
block|{
operator|*
name|cores
operator|=
name|buffer
expr_stmt|;
operator|*
name|num_cores
operator|=
name|count
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|buffer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buffer
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the initial position */
name|bcma_erom_seek
argument_list|(
name|erom
argument_list|,
name|initial_offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Register all MMIO region descriptors for the given slave port.  *   * @param erom EROM read state.  * @param corecfg Core info to be populated with the scanned port regions.  * @param port_num Port index for which regions will be parsed.  * @param region_type The region type to be parsed.  * @param[out] offset The offset at which to perform parsing. On success, this  * will be updated to point to the next EROM table entry.  */
end_comment

begin_function
specifier|static
name|int
name|erom_corecfg_fill_port_regions
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|struct
name|bcma_corecfg
modifier|*
name|corecfg
parameter_list|,
name|bcma_pid_t
name|port_num
parameter_list|,
name|uint8_t
name|region_type
parameter_list|)
block|{
name|struct
name|bcma_sport
modifier|*
name|sport
decl_stmt|;
name|struct
name|bcma_sport_list
modifier|*
name|sports
decl_stmt|;
name|bus_size_t
name|entry_offset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bhnd_port_type
name|port_type
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Determine the port type for this region type. */
switch|switch
condition|(
name|region_type
condition|)
block|{
case|case
name|BCMA_EROM_REGION_TYPE_DEVICE
case|:
name|port_type
operator|=
name|BHND_PORT_DEVICE
expr_stmt|;
break|break;
case|case
name|BCMA_EROM_REGION_TYPE_BRIDGE
case|:
name|port_type
operator|=
name|BHND_PORT_BRIDGE
expr_stmt|;
break|break;
case|case
name|BCMA_EROM_REGION_TYPE_MWRAP
case|:
case|case
name|BCMA_EROM_REGION_TYPE_SWRAP
case|:
name|port_type
operator|=
name|BHND_PORT_AGENT
expr_stmt|;
break|break;
default|default:
name|EROM_LOG
argument_list|(
name|erom
argument_list|,
literal|"unsupported region type %hhx\n"
argument_list|,
name|region_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Fetch the list to be populated */
name|sports
operator|=
name|bcma_corecfg_get_port_list
argument_list|(
name|corecfg
argument_list|,
name|port_type
argument_list|)
expr_stmt|;
comment|/* Allocate a new port descriptor */
name|sport
operator|=
name|bcma_alloc_sport
argument_list|(
name|port_num
argument_list|,
name|port_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|sport
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Read all address regions defined for this port */
for|for
control|(
name|bcma_rmid_t
name|region_num
init|=
literal|0
init|;
condition|;
name|region_num
operator|++
control|)
block|{
name|struct
name|bcma_map
modifier|*
name|map
decl_stmt|;
name|struct
name|bcma_erom_sport_region
name|spr
decl_stmt|;
comment|/* No valid port definition should come anywhere near 		 * BCMA_RMID_MAX. */
if|if
condition|(
name|region_num
operator|==
name|BCMA_RMID_MAX
condition|)
block|{
name|EROM_LOG
argument_list|(
name|erom
argument_list|,
literal|"core%u %s%u: region count reached "
literal|"upper limit of %u\n"
argument_list|,
name|corecfg
operator|->
name|core_info
operator|.
name|core_idx
argument_list|,
name|bhnd_port_type_name
argument_list|(
name|port_type
argument_list|)
argument_list|,
name|port_num
argument_list|,
name|BCMA_RMID_MAX
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Parse the next region entry. */
name|entry_offset
operator|=
name|bcma_erom_tell
argument_list|(
name|erom
argument_list|)
expr_stmt|;
name|error
operator|=
name|bcma_erom_parse_sport_region
argument_list|(
name|erom
argument_list|,
operator|&
name|spr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
block|{
name|EROM_LOG
argument_list|(
name|erom
argument_list|,
literal|"core%u %s%u.%u: invalid slave port "
literal|"address region\n"
argument_list|,
name|corecfg
operator|->
name|core_info
operator|.
name|core_idx
argument_list|,
name|bhnd_port_type_name
argument_list|(
name|port_type
argument_list|)
argument_list|,
name|port_num
argument_list|,
name|region_num
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* ENOENT signals no further region entries */
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
block|{
comment|/* No further entries */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* A region or type mismatch also signals no further region 		 * entries */
if|if
condition|(
name|spr
operator|.
name|region_port
operator|!=
name|port_num
operator|||
name|spr
operator|.
name|region_type
operator|!=
name|region_type
condition|)
block|{
comment|/* We don't want to consume this entry */
name|bcma_erom_seek
argument_list|(
name|erom
argument_list|,
name|entry_offset
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 		 * Create the map entry.  		 */
name|map
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bcma_map
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|map
operator|->
name|m_region_num
operator|=
name|region_num
expr_stmt|;
name|map
operator|->
name|m_base
operator|=
name|spr
operator|.
name|base_addr
expr_stmt|;
name|map
operator|->
name|m_size
operator|=
name|spr
operator|.
name|size
expr_stmt|;
name|map
operator|->
name|m_rid
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Add the region map to the port */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sport
operator|->
name|sp_maps
argument_list|,
name|map
argument_list|,
name|m_link
argument_list|)
expr_stmt|;
name|sport
operator|->
name|sp_num_maps
operator|++
expr_stmt|;
block|}
name|cleanup
label|:
comment|/* Append the new port descriptor on success, or deallocate the 	 * partially parsed descriptor on failure. */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
name|sports
argument_list|,
name|sport
argument_list|,
name|sp_link
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sport
operator|!=
name|NULL
condition|)
block|{
name|bcma_free_sport
argument_list|(
name|sport
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/**  * Parse the next core entry from the EROM table and produce a bcma_corecfg  * to be owned by the caller.  *   * @param erom EROM read state.  * @param[out] result On success, the core's device info. The caller inherits  * ownership of this allocation.  *   * @return If successful, returns 0. If the end of the EROM table is hit,  * ENOENT will be returned. On error, returns a non-zero error value.  */
end_comment

begin_function
name|int
name|bcma_erom_parse_corecfg
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|struct
name|bcma_corecfg
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|bcma_corecfg
modifier|*
name|cfg
decl_stmt|;
name|struct
name|bcma_erom_core
name|core
decl_stmt|;
name|uint8_t
name|first_region_type
decl_stmt|;
name|bus_size_t
name|initial_offset
decl_stmt|;
name|u_int
name|core_index
decl_stmt|;
name|int
name|core_unit
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cfg
operator|=
name|NULL
expr_stmt|;
name|initial_offset
operator|=
name|bcma_erom_tell
argument_list|(
name|erom
argument_list|)
expr_stmt|;
comment|/* Parse the next core entry */
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_parse_core
argument_list|(
name|erom
argument_list|,
operator|&
name|core
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Determine the core's index and unit numbers */
name|bcma_erom_reset
argument_list|(
name|erom
argument_list|)
expr_stmt|;
name|core_unit
operator|=
literal|0
expr_stmt|;
name|core_index
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|bcma_erom_tell
argument_list|(
name|erom
argument_list|)
operator|!=
name|initial_offset
condition|;
name|core_index
operator|++
control|)
block|{
name|struct
name|bcma_erom_core
name|prev_core
decl_stmt|;
comment|/* Parse next core */
if|if
condition|(
operator|(
name|error
operator|=
name|erom_seek_next
argument_list|(
name|erom
argument_list|,
name|BCMA_EROM_ENTRY_TYPE_CORE
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_parse_core
argument_list|(
name|erom
argument_list|,
operator|&
name|prev_core
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Is earlier unit? */
if|if
condition|(
name|core
operator|.
name|vendor
operator|==
name|prev_core
operator|.
name|vendor
operator|&&
name|core
operator|.
name|device
operator|==
name|prev_core
operator|.
name|device
condition|)
block|{
name|core_unit
operator|++
expr_stmt|;
block|}
comment|/* Seek to next core */
if|if
condition|(
operator|(
name|error
operator|=
name|erom_seek_next
argument_list|(
name|erom
argument_list|,
name|BCMA_EROM_ENTRY_TYPE_CORE
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* We already parsed the core descriptor */
if|if
condition|(
operator|(
name|error
operator|=
name|erom_skip_core
argument_list|(
name|erom
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Allocate our corecfg */
name|cfg
operator|=
name|bcma_alloc_corecfg
argument_list|(
name|core_index
argument_list|,
name|core_unit
argument_list|,
name|core
operator|.
name|vendor
argument_list|,
name|core
operator|.
name|device
argument_list|,
name|core
operator|.
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* These are 5-bit values in the EROM table, and should never be able 	 * to overflow BCMA_PID_MAX. */
name|KASSERT
argument_list|(
name|core
operator|.
name|num_mport
operator|<=
name|BCMA_PID_MAX
argument_list|,
operator|(
literal|"unsupported mport count"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|core
operator|.
name|num_dport
operator|<=
name|BCMA_PID_MAX
argument_list|,
operator|(
literal|"unsupported dport count"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|core
operator|.
name|num_mwrap
operator|+
name|core
operator|.
name|num_swrap
operator|<=
name|BCMA_PID_MAX
argument_list|,
operator|(
literal|"unsupported wport count"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|EROM_LOG
argument_list|(
name|erom
argument_list|,
literal|"core%u: %s %s (cid=%hx, rev=%hu, unit=%d)\n"
argument_list|,
name|core_index
argument_list|,
name|bhnd_vendor_name
argument_list|(
name|core
operator|.
name|vendor
argument_list|)
argument_list|,
name|bhnd_find_core_name
argument_list|(
name|core
operator|.
name|vendor
argument_list|,
name|core
operator|.
name|device
argument_list|)
argument_list|,
name|core
operator|.
name|device
argument_list|,
name|core
operator|.
name|rev
argument_list|,
name|core_unit
argument_list|)
expr_stmt|;
block|}
name|cfg
operator|->
name|num_master_ports
operator|=
name|core
operator|.
name|num_mport
expr_stmt|;
name|cfg
operator|->
name|num_dev_ports
operator|=
literal|0
expr_stmt|;
comment|/* determined below */
name|cfg
operator|->
name|num_bridge_ports
operator|=
literal|0
expr_stmt|;
comment|/* determined blow */
name|cfg
operator|->
name|num_wrapper_ports
operator|=
name|core
operator|.
name|num_mwrap
operator|+
name|core
operator|.
name|num_swrap
expr_stmt|;
comment|/* Parse Master Port Descriptors */
for|for
control|(
name|uint8_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|core
operator|.
name|num_mport
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bcma_mport
modifier|*
name|mport
decl_stmt|;
name|struct
name|bcma_erom_mport
name|mpd
decl_stmt|;
comment|/* Parse the master port descriptor */
name|error
operator|=
name|bcma_erom_parse_mport
argument_list|(
name|erom
argument_list|,
operator|&
name|mpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
comment|/* Initialize a new bus mport structure */
name|mport
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bcma_mport
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mport
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|mport
operator|->
name|mp_vid
operator|=
name|mpd
operator|.
name|port_vid
expr_stmt|;
name|mport
operator|->
name|mp_num
operator|=
name|mpd
operator|.
name|port_num
expr_stmt|;
comment|/* Update dinfo */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cfg
operator|->
name|master_ports
argument_list|,
name|mport
argument_list|,
name|mp_link
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Determine whether this is a bridge device; if so, we can 	 * expect the first sequence of address region descriptors to 	 * be of EROM_REGION_TYPE_BRIDGE instead of 	 * BCMA_EROM_REGION_TYPE_DEVICE. 	 *  	 * It's unclear whether this is the correct mechanism by which we 	 * should detect/handle bridge devices, but this approach matches 	 * that of (some of) Broadcom's published drivers. 	 */
if|if
condition|(
name|core
operator|.
name|num_dport
operator|>
literal|0
condition|)
block|{
name|uint32_t
name|entry
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_peek32
argument_list|(
name|erom
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|BCMA_EROM_ENTRY_IS
argument_list|(
name|entry
argument_list|,
name|REGION
argument_list|)
operator|&&
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_TYPE
argument_list|)
operator|==
name|BCMA_EROM_REGION_TYPE_BRIDGE
condition|)
block|{
name|first_region_type
operator|=
name|BCMA_EROM_REGION_TYPE_BRIDGE
expr_stmt|;
name|cfg
operator|->
name|num_dev_ports
operator|=
literal|0
expr_stmt|;
name|cfg
operator|->
name|num_bridge_ports
operator|=
name|core
operator|.
name|num_dport
expr_stmt|;
block|}
else|else
block|{
name|first_region_type
operator|=
name|BCMA_EROM_REGION_TYPE_DEVICE
expr_stmt|;
name|cfg
operator|->
name|num_dev_ports
operator|=
name|core
operator|.
name|num_dport
expr_stmt|;
name|cfg
operator|->
name|num_bridge_ports
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Device/bridge port descriptors */
for|for
control|(
name|uint8_t
name|sp_num
init|=
literal|0
init|;
name|sp_num
operator|<
name|core
operator|.
name|num_dport
condition|;
name|sp_num
operator|++
control|)
block|{
name|error
operator|=
name|erom_corecfg_fill_port_regions
argument_list|(
name|erom
argument_list|,
name|cfg
argument_list|,
name|sp_num
argument_list|,
name|first_region_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
block|}
comment|/* Wrapper (aka device management) descriptors (for master ports). */
for|for
control|(
name|uint8_t
name|sp_num
init|=
literal|0
init|;
name|sp_num
operator|<
name|core
operator|.
name|num_mwrap
condition|;
name|sp_num
operator|++
control|)
block|{
name|error
operator|=
name|erom_corecfg_fill_port_regions
argument_list|(
name|erom
argument_list|,
name|cfg
argument_list|,
name|sp_num
argument_list|,
name|BCMA_EROM_REGION_TYPE_MWRAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
block|}
comment|/* Wrapper (aka device management) descriptors (for slave ports). */
for|for
control|(
name|uint8_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|core
operator|.
name|num_swrap
condition|;
name|i
operator|++
control|)
block|{
comment|/* Slave wrapper ports are not numbered distinctly from master 		 * wrapper ports. */
comment|/*  		 * Broadcom DDR1/DDR2 Memory Controller 		 * (cid=82e, rev=1, unit=0, d/mw/sw = 2/0/1 ) -> 		 * bhnd0: erom[0xdc]: core6 agent0.0: mismatch got: 0x1 (0x2) 		 * 		 * ARM BP135 AMBA3 AXI to APB Bridge 		 * (cid=135, rev=0, unit=0, d/mw/sw = 1/0/1 ) -> 		 * bhnd0: erom[0x124]: core9 agent1.0: mismatch got: 0x0 (0x2) 		 * 		 * core.num_mwrap 		 * ===> 		 * (core.num_mwrap> 0) ? 		 *           core.num_mwrap : 		 *           ((core.vendor == BHND_MFGID_BCM) ? 1 : 0) 		 */
name|uint8_t
name|sp_num
decl_stmt|;
name|sp_num
operator|=
operator|(
name|core
operator|.
name|num_mwrap
operator|>
literal|0
operator|)
condition|?
name|core
operator|.
name|num_mwrap
else|:
operator|(
operator|(
name|core
operator|.
name|vendor
operator|==
name|BHND_MFGID_BCM
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
name|i
expr_stmt|;
name|error
operator|=
name|erom_corecfg_fill_port_regions
argument_list|(
name|erom
argument_list|,
name|cfg
argument_list|,
name|sp_num
argument_list|,
name|BCMA_EROM_REGION_TYPE_SWRAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
block|}
operator|*
name|result
operator|=
name|cfg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
if|if
condition|(
name|cfg
operator|!=
name|NULL
condition|)
name|bcma_free_corecfg
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

end_unit

