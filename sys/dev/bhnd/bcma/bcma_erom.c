begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2017 Landon Fuller<landonf@landonf.org>  * Copyright (c) 2017 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by Landon Fuller  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/chipc/chipcreg.h>
end_include

begin_include
include|#
directive|include
file|"bcma_eromreg.h"
end_include

begin_include
include|#
directive|include
file|"bcma_eromvar.h"
end_include

begin_comment
comment|/*  * BCMA Enumeration ROM (EROM) Table  *   * Provides auto-discovery of BCMA cores on Broadcom's HND SoC.  *   * The EROM core address can be found at BCMA_CC_EROM_ADDR within the  * ChipCommon registers. The table itself is comprised of 32-bit  * type-tagged entries, organized into an array of variable-length  * core descriptor records.  *   * The final core descriptor is followed by a 32-bit BCMA_EROM_TABLE_EOF (0xF)  * marker.  */
end_comment

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|bcma_erom_entry_type_name
parameter_list|(
name|uint8_t
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bcma_erom_read32
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|uint32_t
modifier|*
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bcma_erom_skip32
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bcma_erom_skip_core
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bcma_erom_skip_mport
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bcma_erom_skip_sport_region
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bcma_erom_seek_next
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|uint8_t
name|etype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bcma_erom_region_to_port_type
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|uint8_t
name|region_type
parameter_list|,
name|bhnd_port_type
modifier|*
name|port_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bcma_erom_peek32
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|uint32_t
modifier|*
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bus_size_t
name|bcma_erom_tell
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bcma_erom_seek
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|bus_size_t
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bcma_erom_reset
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bcma_erom_seek_matching_core
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|bhnd_core_match
modifier|*
name|desc
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|core
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bcma_erom_parse_core
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|struct
name|bcma_erom_core
modifier|*
name|core
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bcma_erom_parse_mport
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|struct
name|bcma_erom_mport
modifier|*
name|mport
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bcma_erom_parse_sport_region
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|struct
name|bcma_erom_sport_region
modifier|*
name|region
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bcma_erom_to_core_info
parameter_list|(
specifier|const
name|struct
name|bcma_erom_core
modifier|*
name|core
parameter_list|,
name|u_int
name|core_idx
parameter_list|,
name|int
name|core_unit
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * BCMA EROM per-instance state.  */
end_comment

begin_struct
struct|struct
name|bcma_erom
block|{
name|struct
name|bhnd_erom
name|obj
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
comment|/**< parent device, or NULL if none. */
name|struct
name|bhnd_erom_io
modifier|*
name|eio
decl_stmt|;
comment|/**< bus I/O callbacks */
name|bhnd_size_t
name|offset
decl_stmt|;
comment|/**< current read offset */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|EROM_LOG
parameter_list|(
name|erom
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {			\ 	printf("%s erom[0x%llx]: " fmt, __FUNCTION__,		\ 	    (unsigned long long)(erom->offset), ##__VA_ARGS__);	\ } while(0)
end_define

begin_comment
comment|/** Return the type name for an EROM entry */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|bcma_erom_entry_type_name
parameter_list|(
name|uint8_t
name|entry
parameter_list|)
block|{
switch|switch
condition|(
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|ENTRY_TYPE
argument_list|)
condition|)
block|{
case|case
name|BCMA_EROM_ENTRY_TYPE_CORE
case|:
return|return
literal|"core"
return|;
case|case
name|BCMA_EROM_ENTRY_TYPE_MPORT
case|:
return|return
literal|"mport"
return|;
case|case
name|BCMA_EROM_ENTRY_TYPE_REGION
case|:
return|return
literal|"region"
return|;
default|default:
return|return
literal|"unknown"
return|;
block|}
block|}
end_function

begin_comment
comment|/* BCMA implementation of BHND_EROM_INIT() */
end_comment

begin_function
specifier|static
name|int
name|bcma_erom_init
parameter_list|(
name|bhnd_erom_t
modifier|*
name|erom
parameter_list|,
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|cid
parameter_list|,
name|struct
name|bhnd_erom_io
modifier|*
name|eio
parameter_list|)
block|{
name|struct
name|bcma_erom
modifier|*
name|sc
decl_stmt|;
name|bhnd_addr_t
name|table_addr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|bcma_erom
operator|*
operator|)
name|erom
expr_stmt|;
name|sc
operator|->
name|eio
operator|=
name|eio
expr_stmt|;
name|sc
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Determine erom table address */
if|if
condition|(
name|BHND_ADDR_MAX
operator|-
name|BCMA_EROM_TABLE_START
operator|<
name|cid
operator|->
name|enum_addr
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* would overflow */
name|table_addr
operator|=
name|cid
operator|->
name|enum_addr
operator|+
name|BCMA_EROM_TABLE_START
expr_stmt|;
comment|/* Try to map the erom table */
name|error
operator|=
name|bhnd_erom_io_map
argument_list|(
name|sc
operator|->
name|eio
argument_list|,
name|table_addr
argument_list|,
name|BCMA_EROM_TABLE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* BCMA implementation of BHND_EROM_PROBE() */
end_comment

begin_function
specifier|static
name|int
name|bcma_erom_probe
parameter_list|(
name|bhnd_erom_class_t
modifier|*
name|cls
parameter_list|,
name|struct
name|bhnd_erom_io
modifier|*
name|eio
parameter_list|,
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|hint
parameter_list|,
name|struct
name|bhnd_chipid
modifier|*
name|cid
parameter_list|)
block|{
name|uint32_t
name|idreg
decl_stmt|,
name|eromptr
decl_stmt|;
comment|/* Hints aren't supported; all BCMA devices have a ChipCommon 	 * core */
if|if
condition|(
name|hint
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Confirm CHIPC_EROMPTR availability */
name|idreg
operator|=
name|bhnd_erom_io_read
argument_list|(
name|eio
argument_list|,
name|CHIPC_ID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BHND_CHIPTYPE_HAS_EROM
argument_list|(
name|CHIPC_GET_BITS
argument_list|(
name|idreg
argument_list|,
name|CHIPC_ID_BUS
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Fetch EROM address */
name|eromptr
operator|=
name|bhnd_erom_io_read
argument_list|(
name|eio
argument_list|,
name|CHIPC_EROMPTR
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Parse chip identifier */
operator|*
name|cid
operator|=
name|bhnd_parse_chipid
argument_list|(
name|idreg
argument_list|,
name|eromptr
argument_list|)
expr_stmt|;
comment|/* Verify chip type */
switch|switch
condition|(
name|cid
operator|->
name|chip_type
condition|)
block|{
case|case
name|BHND_CHIPTYPE_BCMA
case|:
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
case|case
name|BHND_CHIPTYPE_BCMA_ALT
case|:
case|case
name|BHND_CHIPTYPE_UBUS
case|:
return|return
operator|(
name|BUS_PROBE_GENERIC
operator|)
return|;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bcma_erom_fini
parameter_list|(
name|bhnd_erom_t
modifier|*
name|erom
parameter_list|)
block|{
name|struct
name|bcma_erom
modifier|*
name|sc
init|=
operator|(
expr|struct
name|bcma_erom
operator|*
operator|)
name|erom
decl_stmt|;
name|bhnd_erom_io_fini
argument_list|(
name|sc
operator|->
name|eio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcma_erom_lookup_core
parameter_list|(
name|bhnd_erom_t
modifier|*
name|erom
parameter_list|,
specifier|const
name|struct
name|bhnd_core_match
modifier|*
name|desc
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|core
parameter_list|)
block|{
name|struct
name|bcma_erom
modifier|*
name|sc
init|=
operator|(
expr|struct
name|bcma_erom
operator|*
operator|)
name|erom
decl_stmt|;
comment|/* Search for the first matching core */
return|return
operator|(
name|bcma_erom_seek_matching_core
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|core
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcma_erom_lookup_core_addr
parameter_list|(
name|bhnd_erom_t
modifier|*
name|erom
parameter_list|,
specifier|const
name|struct
name|bhnd_core_match
modifier|*
name|desc
parameter_list|,
name|bhnd_port_type
name|port_type
parameter_list|,
name|u_int
name|port_num
parameter_list|,
name|u_int
name|region_num
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|core
parameter_list|,
name|bhnd_addr_t
modifier|*
name|addr
parameter_list|,
name|bhnd_size_t
modifier|*
name|size
parameter_list|)
block|{
name|struct
name|bcma_erom
modifier|*
name|sc
decl_stmt|;
name|struct
name|bcma_erom_core
name|ec
decl_stmt|;
name|uint32_t
name|entry
decl_stmt|;
name|uint8_t
name|region_port
decl_stmt|,
name|region_type
decl_stmt|;
name|bool
name|found
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|bcma_erom
operator|*
operator|)
name|erom
expr_stmt|;
comment|/* Seek to the first matching core and provide the core info 	 * to the caller */
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_seek_matching_core
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|core
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_parse_core
argument_list|(
name|sc
argument_list|,
operator|&
name|ec
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Skip master ports */
for|for
control|(
name|u_long
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ec
operator|.
name|num_mport
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_skip_mport
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Seek to the region block for the given port type */
name|found
operator|=
name|false
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|bhnd_port_type
name|p_type
decl_stmt|;
name|uint8_t
name|r_type
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_peek32
argument_list|(
name|sc
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|BCMA_EROM_ENTRY_IS
argument_list|(
name|entry
argument_list|,
name|REGION
argument_list|)
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Expected region type? */
name|r_type
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_TYPE
argument_list|)
expr_stmt|;
name|error
operator|=
name|bcma_erom_region_to_port_type
argument_list|(
name|sc
argument_list|,
name|r_type
argument_list|,
operator|&
name|p_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|p_type
operator|==
name|port_type
condition|)
block|{
name|found
operator|=
name|true
expr_stmt|;
break|break;
block|}
comment|/* Skip to next entry */
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_skip_sport_region
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Found the appropriate port type block; now find the region records 	 * for the given port number */
name|found
operator|=
name|false
expr_stmt|;
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|port_num
condition|;
name|i
operator|++
control|)
block|{
name|bhnd_port_type
name|p_type
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_peek32
argument_list|(
name|sc
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|BCMA_EROM_ENTRY_IS
argument_list|(
name|entry
argument_list|,
name|REGION
argument_list|)
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Fetch the type/port of the first region entry */
name|region_type
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_TYPE
argument_list|)
expr_stmt|;
name|region_port
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_PORT
argument_list|)
expr_stmt|;
comment|/* Have we found the region entries for the desired port? */
if|if
condition|(
name|i
operator|==
name|port_num
condition|)
block|{
name|error
operator|=
name|bcma_erom_region_to_port_type
argument_list|(
name|sc
argument_list|,
name|region_type
argument_list|,
operator|&
name|p_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|p_type
operator|==
name|port_type
condition|)
name|found
operator|=
name|true
expr_stmt|;
break|break;
block|}
comment|/* Otherwise, seek to next block of region records */
while|while
condition|(
literal|1
condition|)
block|{
name|uint8_t
name|next_type
decl_stmt|,
name|next_port
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_skip_sport_region
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_peek32
argument_list|(
name|sc
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|BCMA_EROM_ENTRY_IS
argument_list|(
name|entry
argument_list|,
name|REGION
argument_list|)
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|next_type
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_TYPE
argument_list|)
expr_stmt|;
name|next_port
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_type
operator|!=
name|region_type
operator|||
name|next_port
operator|!=
name|region_port
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Finally, search for the requested region number */
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|region_num
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bcma_erom_sport_region
name|region
decl_stmt|;
name|uint8_t
name|next_port
decl_stmt|,
name|next_type
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_peek32
argument_list|(
name|sc
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|BCMA_EROM_ENTRY_IS
argument_list|(
name|entry
argument_list|,
name|REGION
argument_list|)
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Check for the end of the region block */
name|next_type
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_TYPE
argument_list|)
expr_stmt|;
name|next_port
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_type
operator|!=
name|region_type
operator|||
name|next_port
operator|!=
name|region_port
condition|)
break|break;
comment|/* Parse the region */
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_parse_sport_region
argument_list|(
name|sc
argument_list|,
operator|&
name|region
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Is this our target region_num? */
if|if
condition|(
name|i
operator|==
name|region_num
condition|)
block|{
comment|/* Found */
operator|*
name|addr
operator|=
name|region
operator|.
name|base_addr
expr_stmt|;
operator|*
name|size
operator|=
name|region
operator|.
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* Not found */
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|int
name|bcma_erom_get_core_table
parameter_list|(
name|bhnd_erom_t
modifier|*
name|erom
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
modifier|*
name|cores
parameter_list|,
name|u_int
modifier|*
name|num_cores
parameter_list|)
block|{
name|struct
name|bcma_erom
modifier|*
name|sc
decl_stmt|;
name|struct
name|bhnd_core_info
modifier|*
name|buffer
decl_stmt|;
name|bus_size_t
name|initial_offset
decl_stmt|;
name|u_int
name|count
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|bcma_erom
operator|*
operator|)
name|erom
expr_stmt|;
name|buffer
operator|=
name|NULL
expr_stmt|;
name|initial_offset
operator|=
name|bcma_erom_tell
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Determine the core count */
name|bcma_erom_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|error
operator|=
literal|0
init|;
operator|!
name|error
condition|;
name|count
operator|++
control|)
block|{
name|struct
name|bcma_erom_core
name|core
decl_stmt|;
comment|/* Seek to the first readable core entry */
name|error
operator|=
name|bcma_erom_seek_next
argument_list|(
name|sc
argument_list|,
name|BCMA_EROM_ENTRY_TYPE_CORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
break|break;
elseif|else
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Read past the core descriptor */
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_parse_core
argument_list|(
name|sc
argument_list|,
operator|&
name|core
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
block|}
comment|/* Allocate our output buffer */
name|buffer
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bhnd_core_info
argument_list|)
operator|*
name|count
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Parse all core descriptors */
name|bcma_erom_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bcma_erom_core
name|core
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* Parse the core */
name|error
operator|=
name|bcma_erom_seek_next
argument_list|(
name|sc
argument_list|,
name|BCMA_EROM_ENTRY_TYPE_CORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
name|error
operator|=
name|bcma_erom_parse_core
argument_list|(
name|sc
argument_list|,
operator|&
name|core
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Determine the unit number */
name|unit
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|u_int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|.
name|vendor
operator|==
name|buffer
index|[
name|j
index|]
operator|.
name|vendor
operator|&&
name|buffer
index|[
name|i
index|]
operator|.
name|device
operator|==
name|buffer
index|[
name|j
index|]
operator|.
name|device
condition|)
name|unit
operator|++
expr_stmt|;
block|}
comment|/* Convert to a bhnd info record */
name|bcma_erom_to_core_info
argument_list|(
operator|&
name|core
argument_list|,
name|i
argument_list|,
name|unit
argument_list|,
operator|&
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
if|if
condition|(
operator|!
name|error
condition|)
block|{
operator|*
name|cores
operator|=
name|buffer
expr_stmt|;
operator|*
name|num_cores
operator|=
name|count
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|buffer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buffer
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the initial position */
name|bcma_erom_seek
argument_list|(
name|sc
argument_list|,
name|initial_offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bcma_erom_free_core_table
parameter_list|(
name|bhnd_erom_t
modifier|*
name|erom
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|cores
parameter_list|)
block|{
name|free
argument_list|(
name|cores
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Return the current read position.  */
end_comment

begin_function
specifier|static
name|bus_size_t
name|bcma_erom_tell
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
block|{
return|return
operator|(
name|erom
operator|->
name|offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Seek to an absolute read position.  */
end_comment

begin_function
specifier|static
name|void
name|bcma_erom_seek
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|bus_size_t
name|offset
parameter_list|)
block|{
name|erom
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Read a 32-bit entry value from the EROM table without advancing the  * read position.  *   * @param erom EROM read state.  * @param entry Will contain the read result on success.  * @retval 0 success  * @retval ENOENT The end of the EROM table was reached.  * @retval non-zero The read could not be completed.  */
end_comment

begin_function
specifier|static
name|int
name|bcma_erom_peek32
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|uint32_t
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|erom
operator|->
name|offset
operator|>=
operator|(
name|BCMA_EROM_TABLE_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
condition|)
block|{
name|EROM_LOG
argument_list|(
name|erom
argument_list|,
literal|"BCMA EROM table missing terminating EOF\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|entry
operator|=
name|bhnd_erom_io_read
argument_list|(
name|erom
operator|->
name|eio
argument_list|,
name|erom
operator|->
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read a 32-bit entry value from the EROM table.  *   * @param erom EROM read state.  * @param entry Will contain the read result on success.  * @retval 0 success  * @retval ENOENT The end of the EROM table was reached.  * @retval non-zero The read could not be completed.  */
end_comment

begin_function
specifier|static
name|int
name|bcma_erom_read32
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|uint32_t
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_peek32
argument_list|(
name|erom
argument_list|,
name|entry
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|erom
operator|->
name|offset
operator|+=
literal|4
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read and discard 32-bit entry value from the EROM table.  *   * @param erom EROM read state.  * @retval 0 success  * @retval ENOENT The end of the EROM table was reached.  * @retval non-zero The read could not be completed.  */
end_comment

begin_function
specifier|static
name|int
name|bcma_erom_skip32
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
block|{
name|uint32_t
name|entry
decl_stmt|;
return|return
name|bcma_erom_read32
argument_list|(
name|erom
argument_list|,
operator|&
name|entry
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read and discard a core descriptor from the EROM table.  *   * @param erom EROM read state.  * @retval 0 success  * @retval ENOENT The end of the EROM table was reached.  * @retval non-zero The read could not be completed.  */
end_comment

begin_function
specifier|static
name|int
name|bcma_erom_skip_core
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
block|{
name|struct
name|bcma_erom_core
name|core
decl_stmt|;
return|return
operator|(
name|bcma_erom_parse_core
argument_list|(
name|erom
argument_list|,
operator|&
name|core
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read and discard a master port descriptor from the EROM table.  *   * @param erom EROM read state.  * @retval 0 success  * @retval ENOENT The end of the EROM table was reached.  * @retval non-zero The read could not be completed.  */
end_comment

begin_function
specifier|static
name|int
name|bcma_erom_skip_mport
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
block|{
name|struct
name|bcma_erom_mport
name|mp
decl_stmt|;
return|return
operator|(
name|bcma_erom_parse_mport
argument_list|(
name|erom
argument_list|,
operator|&
name|mp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read and discard a port region descriptor from the EROM table.  *   * @param erom EROM read state.  * @retval 0 success  * @retval ENOENT The end of the EROM table was reached.  * @retval non-zero The read could not be completed.  */
end_comment

begin_function
specifier|static
name|int
name|bcma_erom_skip_sport_region
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
block|{
name|struct
name|bcma_erom_sport_region
name|r
decl_stmt|;
return|return
operator|(
name|bcma_erom_parse_sport_region
argument_list|(
name|erom
argument_list|,
operator|&
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Seek to the next entry matching the given EROM entry type.  *   * @param erom EROM read state.  * @param etype  One of BCMA_EROM_ENTRY_TYPE_CORE,  * BCMA_EROM_ENTRY_TYPE_MPORT, or BCMA_EROM_ENTRY_TYPE_REGION.  * @retval 0 success  * @retval ENOENT The end of the EROM table was reached.  * @retval non-zero Reading or parsing the descriptor failed.  */
end_comment

begin_function
specifier|static
name|int
name|bcma_erom_seek_next
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|uint8_t
name|etype
parameter_list|)
block|{
name|uint32_t
name|entry
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Iterate until we hit an entry matching the requested type. */
while|while
condition|(
operator|!
operator|(
name|error
operator|=
name|bcma_erom_peek32
argument_list|(
name|erom
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
block|{
comment|/* Handle EOF */
if|if
condition|(
name|entry
operator|==
name|BCMA_EROM_TABLE_EOF
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Invalid entry */
if|if
condition|(
operator|!
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|ENTRY_ISVALID
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Entry type matches? */
if|if
condition|(
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|ENTRY_TYPE
argument_list|)
operator|==
name|etype
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Skip non-matching entry types. */
switch|switch
condition|(
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|ENTRY_TYPE
argument_list|)
condition|)
block|{
case|case
name|BCMA_EROM_ENTRY_TYPE_CORE
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_skip_core
argument_list|(
name|erom
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|BCMA_EROM_ENTRY_TYPE_MPORT
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_skip_mport
argument_list|(
name|erom
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|BCMA_EROM_ENTRY_TYPE_REGION
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_skip_sport_region
argument_list|(
name|erom
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
default|default:
comment|/* Unknown entry type! */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the read position to the start of the EROM table.  *   * @param erom EROM read state.  */
end_comment

begin_function
specifier|static
name|void
name|bcma_erom_reset
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|)
block|{
name|erom
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Seek to the first core entry matching @p desc.  *   * @param erom EROM read state.  * @param desc The core match descriptor.  * @param[out] core On success, the matching core info. If the core info  * is not desired, a NULL pointer may be provided.  * @retval 0 success  * @retval ENOENT The end of the EROM table was reached before @p index was  * found.  * @retval non-zero Reading or parsing failed.  */
end_comment

begin_function
specifier|static
name|int
name|bcma_erom_seek_matching_core
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|bhnd_core_match
modifier|*
name|desc
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|core
parameter_list|)
block|{
name|struct
name|bhnd_core_match
name|imatch
decl_stmt|;
name|bus_size_t
name|core_offset
decl_stmt|,
name|next_offset
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Seek to table start. */
name|bcma_erom_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* We can't determine a core's unit number during the initial scan. */
name|imatch
operator|=
operator|*
name|desc
expr_stmt|;
name|imatch
operator|.
name|m
operator|.
name|match
operator|.
name|core_unit
operator|=
literal|0
expr_stmt|;
comment|/* Locate the first matching core */
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|UINT_MAX
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bcma_erom_core
name|ec
decl_stmt|;
name|struct
name|bhnd_core_info
name|ci
decl_stmt|;
comment|/* Seek to the next core */
name|error
operator|=
name|bcma_erom_seek_next
argument_list|(
name|sc
argument_list|,
name|BCMA_EROM_ENTRY_TYPE_CORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Save the core offset */
name|core_offset
operator|=
name|bcma_erom_tell
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Parse the core */
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_parse_core
argument_list|(
name|sc
argument_list|,
operator|&
name|ec
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bcma_erom_to_core_info
argument_list|(
operator|&
name|ec
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
operator|&
name|ci
argument_list|)
expr_stmt|;
comment|/* Check for initial match */
if|if
condition|(
operator|!
name|bhnd_core_matches
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|imatch
argument_list|)
condition|)
continue|continue;
comment|/* Re-scan preceding cores to determine the unit number. */
name|next_offset
operator|=
name|bcma_erom_tell
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bcma_erom_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|u_int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
comment|/* Parse the core */
name|error
operator|=
name|bcma_erom_seek_next
argument_list|(
name|sc
argument_list|,
name|BCMA_EROM_ENTRY_TYPE_CORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_parse_core
argument_list|(
name|sc
argument_list|,
operator|&
name|ec
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Bump the unit number? */
if|if
condition|(
name|ec
operator|.
name|vendor
operator|==
name|ci
operator|.
name|vendor
operator|&&
name|ec
operator|.
name|device
operator|==
name|ci
operator|.
name|device
condition|)
name|ci
operator|.
name|unit
operator|++
expr_stmt|;
block|}
comment|/* Check for full match against now-valid unit number */
if|if
condition|(
operator|!
name|bhnd_core_matches
argument_list|(
operator|&
name|ci
argument_list|,
name|desc
argument_list|)
condition|)
block|{
comment|/* Reposition to allow reading the next core */
name|bcma_erom_seek
argument_list|(
name|sc
argument_list|,
name|next_offset
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Found; seek to the core's initial offset and provide 		 * the core info to the caller */
name|bcma_erom_seek
argument_list|(
name|sc
argument_list|,
name|core_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|core
operator|!=
name|NULL
condition|)
operator|*
name|core
operator|=
name|ci
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Not found, or a parse error occured */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read the next core descriptor from the EROM table.  *   * @param erom EROM read state.  * @param[out] core On success, will be populated with the parsed core  * descriptor data.  * @retval 0 success  * @retval ENOENT The end of the EROM table was reached.  * @retval non-zero Reading or parsing the core descriptor failed.  */
end_comment

begin_function
specifier|static
name|int
name|bcma_erom_parse_core
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|struct
name|bcma_erom_core
modifier|*
name|core
parameter_list|)
block|{
name|uint32_t
name|entry
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Parse CoreDescA */
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_read32
argument_list|(
name|erom
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Handle EOF */
if|if
condition|(
name|entry
operator|==
name|BCMA_EROM_TABLE_EOF
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
operator|!
name|BCMA_EROM_ENTRY_IS
argument_list|(
name|entry
argument_list|,
name|CORE
argument_list|)
condition|)
block|{
name|EROM_LOG
argument_list|(
name|erom
argument_list|,
literal|"Unexpected EROM entry 0x%x (type=%s)\n"
argument_list|,
name|entry
argument_list|,
name|bcma_erom_entry_type_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|core
operator|->
name|vendor
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREA_DESIGNER
argument_list|)
expr_stmt|;
name|core
operator|->
name|device
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREA_ID
argument_list|)
expr_stmt|;
comment|/* Parse CoreDescB */
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_read32
argument_list|(
name|erom
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|BCMA_EROM_ENTRY_IS
argument_list|(
name|entry
argument_list|,
name|CORE
argument_list|)
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|core
operator|->
name|rev
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREB_REV
argument_list|)
expr_stmt|;
name|core
operator|->
name|num_mport
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREB_NUM_MP
argument_list|)
expr_stmt|;
name|core
operator|->
name|num_dport
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREB_NUM_DP
argument_list|)
expr_stmt|;
name|core
operator|->
name|num_mwrap
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREB_NUM_WMP
argument_list|)
expr_stmt|;
name|core
operator|->
name|num_swrap
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREB_NUM_WSP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read the next master port descriptor from the EROM table.  *   * @param erom EROM read state.  * @param[out] mport On success, will be populated with the parsed  * descriptor data.  * @retval 0 success  * @retval non-zero Reading or parsing the descriptor failed.  */
end_comment

begin_function
specifier|static
name|int
name|bcma_erom_parse_mport
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|struct
name|bcma_erom_mport
modifier|*
name|mport
parameter_list|)
block|{
name|uint32_t
name|entry
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Parse the master port descriptor */
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_read32
argument_list|(
name|erom
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|BCMA_EROM_ENTRY_IS
argument_list|(
name|entry
argument_list|,
name|MPORT
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mport
operator|->
name|port_vid
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|MPORT_ID
argument_list|)
expr_stmt|;
name|mport
operator|->
name|port_num
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|MPORT_NUM
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read the next slave port region descriptor from the EROM table.  *   * @param erom EROM read state.  * @param[out] mport On success, will be populated with the parsed  * descriptor data.  * @retval 0 success  * @retval ENOENT The end of the region descriptor table was reached.  * @retval non-zero Reading or parsing the descriptor failed.  */
end_comment

begin_function
specifier|static
name|int
name|bcma_erom_parse_sport_region
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|struct
name|bcma_erom_sport_region
modifier|*
name|region
parameter_list|)
block|{
name|uint32_t
name|entry
decl_stmt|;
name|uint8_t
name|size_type
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Peek at the region descriptor */
if|if
condition|(
name|bcma_erom_peek32
argument_list|(
name|erom
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* A non-region entry signals the end of the region table */
if|if
condition|(
operator|!
name|BCMA_EROM_ENTRY_IS
argument_list|(
name|entry
argument_list|,
name|REGION
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
else|else
block|{
name|bcma_erom_skip32
argument_list|(
name|erom
argument_list|)
expr_stmt|;
block|}
name|region
operator|->
name|base_addr
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_BASE
argument_list|)
expr_stmt|;
name|region
operator|->
name|region_type
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_TYPE
argument_list|)
expr_stmt|;
name|region
operator|->
name|region_port
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_PORT
argument_list|)
expr_stmt|;
name|size_type
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_SIZE
argument_list|)
expr_stmt|;
comment|/* If region address is 64-bit, fetch the high bits. */
if|if
condition|(
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_64BIT
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_read32
argument_list|(
name|erom
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|region
operator|->
name|base_addr
operator||=
operator|(
operator|(
name|bhnd_addr_t
operator|)
name|entry
operator|<<
literal|32
operator|)
expr_stmt|;
block|}
comment|/* Parse the region size; it's either encoded as the binary logarithm 	 * of the number of 4K pages (i.e. log2 n), or its encoded as a 	 * 32-bit/64-bit literal value directly following the current entry. */
if|if
condition|(
name|size_type
operator|==
name|BCMA_EROM_REGION_SIZE_OTHER
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_read32
argument_list|(
name|erom
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|region
operator|->
name|size
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|RSIZE_VAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|RSIZE_64BIT
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_read32
argument_list|(
name|erom
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|region
operator|->
name|size
operator||=
operator|(
operator|(
name|bhnd_size_t
operator|)
name|entry
operator|<<
literal|32
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|region
operator|->
name|size
operator|=
name|BCMA_EROM_REGION_SIZE_BASE
operator|<<
name|size_type
expr_stmt|;
block|}
comment|/* Verify that addr+size does not overflow. */
if|if
condition|(
name|region
operator|->
name|size
operator|!=
literal|0
operator|&&
name|BHND_ADDR_MAX
operator|-
operator|(
name|region
operator|->
name|size
operator|-
literal|1
operator|)
operator|<
name|region
operator|->
name|base_addr
condition|)
block|{
name|EROM_LOG
argument_list|(
name|erom
argument_list|,
literal|"%s%u: invalid address map %llx:%llx\n"
argument_list|,
name|bcma_erom_entry_type_name
argument_list|(
name|region
operator|->
name|region_type
argument_list|)
argument_list|,
name|region
operator|->
name|region_port
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|region
operator|->
name|base_addr
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|region
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Convert a bcma_erom_core record to its bhnd_core_info representation.  *   * @param core EROM core record to convert.  * @param core_idx The core index of @p core.  * @param core_unit The core unit of @p core.  * @param[out] info The populated bhnd_core_info representation.  */
end_comment

begin_function
specifier|static
name|void
name|bcma_erom_to_core_info
parameter_list|(
specifier|const
name|struct
name|bcma_erom_core
modifier|*
name|core
parameter_list|,
name|u_int
name|core_idx
parameter_list|,
name|int
name|core_unit
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|info
parameter_list|)
block|{
name|info
operator|->
name|vendor
operator|=
name|core
operator|->
name|vendor
expr_stmt|;
name|info
operator|->
name|device
operator|=
name|core
operator|->
name|device
expr_stmt|;
name|info
operator|->
name|hwrev
operator|=
name|core
operator|->
name|rev
expr_stmt|;
name|info
operator|->
name|core_idx
operator|=
name|core_idx
expr_stmt|;
name|info
operator|->
name|unit
operator|=
name|core_unit
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Map an EROM region type to its corresponding port type.  *   * @param region_type Region type value.  * @param[out] port_type On success, the corresponding port type.  */
end_comment

begin_function
specifier|static
name|int
name|bcma_erom_region_to_port_type
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|uint8_t
name|region_type
parameter_list|,
name|bhnd_port_type
modifier|*
name|port_type
parameter_list|)
block|{
switch|switch
condition|(
name|region_type
condition|)
block|{
case|case
name|BCMA_EROM_REGION_TYPE_DEVICE
case|:
operator|*
name|port_type
operator|=
name|BHND_PORT_DEVICE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|BCMA_EROM_REGION_TYPE_BRIDGE
case|:
operator|*
name|port_type
operator|=
name|BHND_PORT_BRIDGE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|BCMA_EROM_REGION_TYPE_MWRAP
case|:
case|case
name|BCMA_EROM_REGION_TYPE_SWRAP
case|:
operator|*
name|port_type
operator|=
name|BHND_PORT_AGENT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|EROM_LOG
argument_list|(
name|erom
argument_list|,
literal|"unsupported region type %hhx\n"
argument_list|,
name|region_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Register all MMIO region descriptors for the given slave port.  *   * @param erom EROM read state.  * @param corecfg Core info to be populated with the scanned port regions.  * @param port_num Port index for which regions will be parsed.  * @param region_type The region type to be parsed.  * @param[out] offset The offset at which to perform parsing. On success, this  * will be updated to point to the next EROM table entry.  */
end_comment

begin_function
specifier|static
name|int
name|bcma_erom_corecfg_fill_port_regions
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|struct
name|bcma_corecfg
modifier|*
name|corecfg
parameter_list|,
name|bcma_pid_t
name|port_num
parameter_list|,
name|uint8_t
name|region_type
parameter_list|)
block|{
name|struct
name|bcma_sport
modifier|*
name|sport
decl_stmt|;
name|struct
name|bcma_sport_list
modifier|*
name|sports
decl_stmt|;
name|bus_size_t
name|entry_offset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bhnd_port_type
name|port_type
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Determine the port type for this region type. */
name|error
operator|=
name|bcma_erom_region_to_port_type
argument_list|(
name|erom
argument_list|,
name|region_type
argument_list|,
operator|&
name|port_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Fetch the list to be populated */
name|sports
operator|=
name|bcma_corecfg_get_port_list
argument_list|(
name|corecfg
argument_list|,
name|port_type
argument_list|)
expr_stmt|;
comment|/* Allocate a new port descriptor */
name|sport
operator|=
name|bcma_alloc_sport
argument_list|(
name|port_num
argument_list|,
name|port_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|sport
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Read all address regions defined for this port */
for|for
control|(
name|bcma_rmid_t
name|region_num
init|=
literal|0
init|;
condition|;
name|region_num
operator|++
control|)
block|{
name|struct
name|bcma_map
modifier|*
name|map
decl_stmt|;
name|struct
name|bcma_erom_sport_region
name|spr
decl_stmt|;
comment|/* No valid port definition should come anywhere near 		 * BCMA_RMID_MAX. */
if|if
condition|(
name|region_num
operator|==
name|BCMA_RMID_MAX
condition|)
block|{
name|EROM_LOG
argument_list|(
name|erom
argument_list|,
literal|"core%u %s%u: region count reached "
literal|"upper limit of %u\n"
argument_list|,
name|corecfg
operator|->
name|core_info
operator|.
name|core_idx
argument_list|,
name|bhnd_port_type_name
argument_list|(
name|port_type
argument_list|)
argument_list|,
name|port_num
argument_list|,
name|BCMA_RMID_MAX
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Parse the next region entry. */
name|entry_offset
operator|=
name|bcma_erom_tell
argument_list|(
name|erom
argument_list|)
expr_stmt|;
name|error
operator|=
name|bcma_erom_parse_sport_region
argument_list|(
name|erom
argument_list|,
operator|&
name|spr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
block|{
name|EROM_LOG
argument_list|(
name|erom
argument_list|,
literal|"core%u %s%u.%u: invalid slave port "
literal|"address region\n"
argument_list|,
name|corecfg
operator|->
name|core_info
operator|.
name|core_idx
argument_list|,
name|bhnd_port_type_name
argument_list|(
name|port_type
argument_list|)
argument_list|,
name|port_num
argument_list|,
name|region_num
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* ENOENT signals no further region entries */
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
block|{
comment|/* No further entries */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* A region or type mismatch also signals no further region 		 * entries */
if|if
condition|(
name|spr
operator|.
name|region_port
operator|!=
name|port_num
operator|||
name|spr
operator|.
name|region_type
operator|!=
name|region_type
condition|)
block|{
comment|/* We don't want to consume this entry */
name|bcma_erom_seek
argument_list|(
name|erom
argument_list|,
name|entry_offset
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 		 * Create the map entry.  		 */
name|map
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bcma_map
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|map
operator|->
name|m_region_num
operator|=
name|region_num
expr_stmt|;
name|map
operator|->
name|m_base
operator|=
name|spr
operator|.
name|base_addr
expr_stmt|;
name|map
operator|->
name|m_size
operator|=
name|spr
operator|.
name|size
expr_stmt|;
name|map
operator|->
name|m_rid
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Add the region map to the port */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sport
operator|->
name|sp_maps
argument_list|,
name|map
argument_list|,
name|m_link
argument_list|)
expr_stmt|;
name|sport
operator|->
name|sp_num_maps
operator|++
expr_stmt|;
block|}
name|cleanup
label|:
comment|/* Append the new port descriptor on success, or deallocate the 	 * partially parsed descriptor on failure. */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
name|sports
argument_list|,
name|sport
argument_list|,
name|sp_link
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sport
operator|!=
name|NULL
condition|)
block|{
name|bcma_free_sport
argument_list|(
name|sport
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/**  * Parse the next core entry from the EROM table and produce a bcma_corecfg  * to be owned by the caller.  *   * @param erom A bcma EROM instance.  * @param[out] result On success, the core's device info. The caller inherits  * ownership of this allocation.  *   * @return If successful, returns 0. If the end of the EROM table is hit,  * ENOENT will be returned. On error, returns a non-zero error value.  */
end_comment

begin_function
name|int
name|bcma_erom_next_corecfg
parameter_list|(
name|struct
name|bcma_erom
modifier|*
name|erom
parameter_list|,
name|struct
name|bcma_corecfg
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|bcma_corecfg
modifier|*
name|cfg
decl_stmt|;
name|struct
name|bcma_erom_core
name|core
decl_stmt|;
name|uint8_t
name|first_region_type
decl_stmt|;
name|bus_size_t
name|initial_offset
decl_stmt|;
name|u_int
name|core_index
decl_stmt|;
name|int
name|core_unit
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cfg
operator|=
name|NULL
expr_stmt|;
name|initial_offset
operator|=
name|bcma_erom_tell
argument_list|(
name|erom
argument_list|)
expr_stmt|;
comment|/* Parse the next core entry */
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_parse_core
argument_list|(
name|erom
argument_list|,
operator|&
name|core
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Determine the core's index and unit numbers */
name|bcma_erom_reset
argument_list|(
name|erom
argument_list|)
expr_stmt|;
name|core_unit
operator|=
literal|0
expr_stmt|;
name|core_index
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|bcma_erom_tell
argument_list|(
name|erom
argument_list|)
operator|!=
name|initial_offset
condition|;
name|core_index
operator|++
control|)
block|{
name|struct
name|bcma_erom_core
name|prev_core
decl_stmt|;
comment|/* Parse next core */
name|error
operator|=
name|bcma_erom_seek_next
argument_list|(
name|erom
argument_list|,
name|BCMA_EROM_ENTRY_TYPE_CORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_parse_core
argument_list|(
name|erom
argument_list|,
operator|&
name|prev_core
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Is earlier unit? */
if|if
condition|(
name|core
operator|.
name|vendor
operator|==
name|prev_core
operator|.
name|vendor
operator|&&
name|core
operator|.
name|device
operator|==
name|prev_core
operator|.
name|device
condition|)
block|{
name|core_unit
operator|++
expr_stmt|;
block|}
comment|/* Seek to next core */
name|error
operator|=
name|bcma_erom_seek_next
argument_list|(
name|erom
argument_list|,
name|BCMA_EROM_ENTRY_TYPE_CORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* We already parsed the core descriptor */
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_skip_core
argument_list|(
name|erom
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Allocate our corecfg */
name|cfg
operator|=
name|bcma_alloc_corecfg
argument_list|(
name|core_index
argument_list|,
name|core_unit
argument_list|,
name|core
operator|.
name|vendor
argument_list|,
name|core
operator|.
name|device
argument_list|,
name|core
operator|.
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* These are 5-bit values in the EROM table, and should never be able 	 * to overflow BCMA_PID_MAX. */
name|KASSERT
argument_list|(
name|core
operator|.
name|num_mport
operator|<=
name|BCMA_PID_MAX
argument_list|,
operator|(
literal|"unsupported mport count"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|core
operator|.
name|num_dport
operator|<=
name|BCMA_PID_MAX
argument_list|,
operator|(
literal|"unsupported dport count"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|core
operator|.
name|num_mwrap
operator|+
name|core
operator|.
name|num_swrap
operator|<=
name|BCMA_PID_MAX
argument_list|,
operator|(
literal|"unsupported wport count"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|EROM_LOG
argument_list|(
name|erom
argument_list|,
literal|"core%u: %s %s (cid=%hx, rev=%hu, unit=%d)\n"
argument_list|,
name|core_index
argument_list|,
name|bhnd_vendor_name
argument_list|(
name|core
operator|.
name|vendor
argument_list|)
argument_list|,
name|bhnd_find_core_name
argument_list|(
name|core
operator|.
name|vendor
argument_list|,
name|core
operator|.
name|device
argument_list|)
argument_list|,
name|core
operator|.
name|device
argument_list|,
name|core
operator|.
name|rev
argument_list|,
name|core_unit
argument_list|)
expr_stmt|;
block|}
name|cfg
operator|->
name|num_master_ports
operator|=
name|core
operator|.
name|num_mport
expr_stmt|;
name|cfg
operator|->
name|num_dev_ports
operator|=
literal|0
expr_stmt|;
comment|/* determined below */
name|cfg
operator|->
name|num_bridge_ports
operator|=
literal|0
expr_stmt|;
comment|/* determined blow */
name|cfg
operator|->
name|num_wrapper_ports
operator|=
name|core
operator|.
name|num_mwrap
operator|+
name|core
operator|.
name|num_swrap
expr_stmt|;
comment|/* Parse Master Port Descriptors */
for|for
control|(
name|uint8_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|core
operator|.
name|num_mport
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bcma_mport
modifier|*
name|mport
decl_stmt|;
name|struct
name|bcma_erom_mport
name|mpd
decl_stmt|;
comment|/* Parse the master port descriptor */
name|error
operator|=
name|bcma_erom_parse_mport
argument_list|(
name|erom
argument_list|,
operator|&
name|mpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
comment|/* Initialize a new bus mport structure */
name|mport
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bcma_mport
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mport
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|mport
operator|->
name|mp_vid
operator|=
name|mpd
operator|.
name|port_vid
expr_stmt|;
name|mport
operator|->
name|mp_num
operator|=
name|mpd
operator|.
name|port_num
expr_stmt|;
comment|/* Update dinfo */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cfg
operator|->
name|master_ports
argument_list|,
name|mport
argument_list|,
name|mp_link
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Determine whether this is a bridge device; if so, we can 	 * expect the first sequence of address region descriptors to 	 * be of EROM_REGION_TYPE_BRIDGE instead of 	 * BCMA_EROM_REGION_TYPE_DEVICE. 	 *  	 * It's unclear whether this is the correct mechanism by which we 	 * should detect/handle bridge devices, but this approach matches 	 * that of (some of) Broadcom's published drivers. 	 */
if|if
condition|(
name|core
operator|.
name|num_dport
operator|>
literal|0
condition|)
block|{
name|uint32_t
name|entry
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_peek32
argument_list|(
name|erom
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|BCMA_EROM_ENTRY_IS
argument_list|(
name|entry
argument_list|,
name|REGION
argument_list|)
operator|&&
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_TYPE
argument_list|)
operator|==
name|BCMA_EROM_REGION_TYPE_BRIDGE
condition|)
block|{
name|first_region_type
operator|=
name|BCMA_EROM_REGION_TYPE_BRIDGE
expr_stmt|;
name|cfg
operator|->
name|num_dev_ports
operator|=
literal|0
expr_stmt|;
name|cfg
operator|->
name|num_bridge_ports
operator|=
name|core
operator|.
name|num_dport
expr_stmt|;
block|}
else|else
block|{
name|first_region_type
operator|=
name|BCMA_EROM_REGION_TYPE_DEVICE
expr_stmt|;
name|cfg
operator|->
name|num_dev_ports
operator|=
name|core
operator|.
name|num_dport
expr_stmt|;
name|cfg
operator|->
name|num_bridge_ports
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Device/bridge port descriptors */
for|for
control|(
name|uint8_t
name|sp_num
init|=
literal|0
init|;
name|sp_num
operator|<
name|core
operator|.
name|num_dport
condition|;
name|sp_num
operator|++
control|)
block|{
name|error
operator|=
name|bcma_erom_corecfg_fill_port_regions
argument_list|(
name|erom
argument_list|,
name|cfg
argument_list|,
name|sp_num
argument_list|,
name|first_region_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
block|}
comment|/* Wrapper (aka device management) descriptors (for master ports). */
for|for
control|(
name|uint8_t
name|sp_num
init|=
literal|0
init|;
name|sp_num
operator|<
name|core
operator|.
name|num_mwrap
condition|;
name|sp_num
operator|++
control|)
block|{
name|error
operator|=
name|bcma_erom_corecfg_fill_port_regions
argument_list|(
name|erom
argument_list|,
name|cfg
argument_list|,
name|sp_num
argument_list|,
name|BCMA_EROM_REGION_TYPE_MWRAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
block|}
comment|/* Wrapper (aka device management) descriptors (for slave ports). */
for|for
control|(
name|uint8_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|core
operator|.
name|num_swrap
condition|;
name|i
operator|++
control|)
block|{
comment|/* Slave wrapper ports are not numbered distinctly from master 		 * wrapper ports. */
comment|/*  		 * Broadcom DDR1/DDR2 Memory Controller 		 * (cid=82e, rev=1, unit=0, d/mw/sw = 2/0/1 ) -> 		 * bhnd0: erom[0xdc]: core6 agent0.0: mismatch got: 0x1 (0x2) 		 * 		 * ARM BP135 AMBA3 AXI to APB Bridge 		 * (cid=135, rev=0, unit=0, d/mw/sw = 1/0/1 ) -> 		 * bhnd0: erom[0x124]: core9 agent1.0: mismatch got: 0x0 (0x2) 		 * 		 * core.num_mwrap 		 * ===> 		 * (core.num_mwrap> 0) ? 		 *           core.num_mwrap : 		 *           ((core.vendor == BHND_MFGID_BCM) ? 1 : 0) 		 */
name|uint8_t
name|sp_num
decl_stmt|;
name|sp_num
operator|=
operator|(
name|core
operator|.
name|num_mwrap
operator|>
literal|0
operator|)
condition|?
name|core
operator|.
name|num_mwrap
else|:
operator|(
operator|(
name|core
operator|.
name|vendor
operator|==
name|BHND_MFGID_BCM
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
name|i
expr_stmt|;
name|error
operator|=
name|bcma_erom_corecfg_fill_port_regions
argument_list|(
name|erom
argument_list|,
name|cfg
argument_list|,
name|sp_num
argument_list|,
name|BCMA_EROM_REGION_TYPE_SWRAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
block|}
comment|/* 	 * Seek to the next core entry (if any), skipping any dangling/invalid 	 * region entries. 	 *  	 * On the BCM4706, the EROM entry for the memory controller core 	 * (0x4bf/0x52E) contains a dangling/unused slave wrapper port region 	 * descriptor. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_seek_next
argument_list|(
name|erom
argument_list|,
name|BCMA_EROM_ENTRY_TYPE_CORE
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
goto|goto
name|failed
goto|;
block|}
operator|*
name|result
operator|=
name|cfg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
if|if
condition|(
name|cfg
operator|!=
name|NULL
condition|)
name|bcma_free_corecfg
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcma_erom_dump
parameter_list|(
name|bhnd_erom_t
modifier|*
name|erom
parameter_list|)
block|{
name|struct
name|bcma_erom
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|entry
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|bcma_erom
operator|*
operator|)
name|erom
expr_stmt|;
name|bcma_erom_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|error
operator|=
name|bcma_erom_read32
argument_list|(
name|sc
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
block|{
comment|/* Handle EOF */
if|if
condition|(
name|entry
operator|==
name|BCMA_EROM_TABLE_EOF
condition|)
block|{
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"EOF\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Invalid entry */
if|if
condition|(
operator|!
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|ENTRY_ISVALID
argument_list|)
condition|)
block|{
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"invalid EROM entry %#x\n"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
switch|switch
condition|(
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|ENTRY_TYPE
argument_list|)
condition|)
block|{
case|case
name|BCMA_EROM_ENTRY_TYPE_CORE
case|:
block|{
comment|/* CoreDescA */
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"coreA (0x%x)\n"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"\tdesigner:\t0x%x\n"
argument_list|,
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREA_DESIGNER
argument_list|)
argument_list|)
expr_stmt|;
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"\tid:\t\t0x%x\n"
argument_list|,
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREA_ID
argument_list|)
argument_list|)
expr_stmt|;
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"\tclass:\t\t0x%x\n"
argument_list|,
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREA_CLASS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* CoreDescB */
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_read32
argument_list|(
name|sc
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
block|{
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"error reading CoreDescB: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|BCMA_EROM_ENTRY_IS
argument_list|(
name|entry
argument_list|,
name|CORE
argument_list|)
condition|)
block|{
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"invalid core descriptor; found "
literal|"unexpected entry %#x (type=%s)\n"
argument_list|,
name|entry
argument_list|,
name|bcma_erom_entry_type_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"coreB (0x%x)\n"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"\trev:\t0x%x\n"
argument_list|,
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREB_REV
argument_list|)
argument_list|)
expr_stmt|;
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"\tnummp:\t0x%x\n"
argument_list|,
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREB_NUM_MP
argument_list|)
argument_list|)
expr_stmt|;
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"\tnumdp:\t0x%x\n"
argument_list|,
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREB_NUM_DP
argument_list|)
argument_list|)
expr_stmt|;
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"\tnumwmp:\t0x%x\n"
argument_list|,
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREB_NUM_WMP
argument_list|)
argument_list|)
expr_stmt|;
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"\tnumwsp:\t0x%x\n"
argument_list|,
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|COREB_NUM_WMP
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|BCMA_EROM_ENTRY_TYPE_MPORT
case|:
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"\tmport 0x%x\n"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"\t\tport:\t0x%x\n"
argument_list|,
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|MPORT_NUM
argument_list|)
argument_list|)
expr_stmt|;
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"\t\tid:\t\t0x%x\n"
argument_list|,
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|MPORT_ID
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BCMA_EROM_ENTRY_TYPE_REGION
case|:
block|{
name|bool
name|addr64
decl_stmt|;
name|uint8_t
name|size_type
decl_stmt|;
name|addr64
operator|=
operator|(
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_64BIT
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|size_type
operator|=
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_SIZE
argument_list|)
expr_stmt|;
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"\tregion 0x%x:\n"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"\t\t%s:\t0x%x\n"
argument_list|,
name|addr64
condition|?
literal|"baselo"
else|:
literal|"base"
argument_list|,
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_BASE
argument_list|)
argument_list|)
expr_stmt|;
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"\t\tport:\t0x%x\n"
argument_list|,
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_PORT
argument_list|)
argument_list|)
expr_stmt|;
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"\t\ttype:\t0x%x\n"
argument_list|,
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|REGION_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"\t\tsztype:\t0x%hhx\n"
argument_list|,
name|size_type
argument_list|)
expr_stmt|;
comment|/* Read the base address high bits */
if|if
condition|(
name|addr64
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_read32
argument_list|(
name|sc
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
block|{
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"error reading region "
literal|"base address high bits %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"\t\tbasehi:\t0x%x\n"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/* Read extended size descriptor */
if|if
condition|(
name|size_type
operator|==
name|BCMA_EROM_REGION_SIZE_OTHER
condition|)
block|{
name|bool
name|size64
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bcma_erom_read32
argument_list|(
name|sc
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
block|{
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"error reading region "
literal|"size descriptor %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|RSIZE_64BIT
argument_list|)
condition|)
name|size64
operator|=
name|true
expr_stmt|;
else|else
name|size64
operator|=
name|false
expr_stmt|;
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"\t\t%s:\t0x%x\n"
argument_list|,
name|size64
condition|?
literal|"sizelo"
else|:
literal|"size"
argument_list|,
name|BCMA_EROM_GET_ATTR
argument_list|(
name|entry
argument_list|,
name|RSIZE_VAL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size64
condition|)
block|{
name|error
operator|=
name|bcma_erom_read32
argument_list|(
name|sc
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"error reading "
literal|"region size high bits: "
literal|"%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"\t\tsizehi:\t0x%x\n"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
default|default:
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"unknown EROM entry 0x%x (type=%s)\n"
argument_list|,
name|entry
argument_list|,
name|bcma_erom_entry_type_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"BCMA EROM table missing terminating EOF\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|error
condition|)
name|EROM_LOG
argument_list|(
name|sc
argument_list|,
literal|"EROM read failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|bcma_erom_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|bhnd_erom_probe
argument_list|,
name|bcma_erom_probe
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|bhnd_erom_init
argument_list|,
name|bcma_erom_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|bhnd_erom_fini
argument_list|,
name|bcma_erom_fini
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|bhnd_erom_get_core_table
argument_list|,
name|bcma_erom_get_core_table
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|bhnd_erom_free_core_table
argument_list|,
name|bcma_erom_free_core_table
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|bhnd_erom_lookup_core
argument_list|,
name|bcma_erom_lookup_core
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|bhnd_erom_lookup_core_addr
argument_list|,
name|bcma_erom_lookup_core_addr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|bhnd_erom_dump
argument_list|,
name|bcma_erom_dump
argument_list|)
block|,
name|KOBJMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|BHND_EROM_DEFINE_CLASS
argument_list|(
name|bcma_erom
argument_list|,
name|bcma_erom_parser
argument_list|,
name|bcma_erom_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bcma_erom
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

