begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Landon Fuller<landonf@FreeBSD.org>  * Copyright (c) 2017 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by Landon Fuller  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Broadcom Home Networking Division (HND) Bus Driver.  *   * The Broadcom HND family of devices consists of both SoCs and host-connected  * networking chipsets containing a common family of Broadcom IP cores,  * including an integrated MIPS and/or ARM cores.  *   * HND devices expose a nearly identical interface whether accessible over a   * native SoC interconnect, or when connected via a host interface such as   * PCIe. As a result, the majority of hardware support code should be re-usable   * across host drivers for HND networking chipsets, as well as FreeBSD support   * for Broadcom MIPS/ARM HND SoCs.  *   * Earlier HND models used the siba(4) on-chip interconnect, while later models  * use bcma(4); the programming model is almost entirely independent  * of the actual underlying interconect.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/chipc/chipcvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/pmu/bhnd_pmu.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/pmu/bhnd_pmureg.h>
end_include

begin_include
include|#
directive|include
file|"bhnd_chipc_if.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_if.h"
end_include

begin_include
include|#
directive|include
file|"bhnd.h"
end_include

begin_include
include|#
directive|include
file|"bhndvar.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_private.h"
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_BHND
argument_list|,
literal|"bhnd"
argument_list|,
literal|"bhnd bus data structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * bhnd_generic_probe_nomatch() reporting configuration.  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|bhnd_nomatch
block|{
name|uint16_t
name|vendor
decl_stmt|;
comment|/**< core designer */
name|uint16_t
name|device
decl_stmt|;
comment|/**< core id */
name|bool
name|if_verbose
decl_stmt|;
comment|/**< print when bootverbose is set. */
block|}
name|bhnd_nomatch_table
index|[]
init|=
block|{
block|{
name|BHND_MFGID_ARM
block|,
name|BHND_COREID_OOB_ROUTER
block|,
name|true
block|}
block|,
block|{
name|BHND_MFGID_ARM
block|,
name|BHND_COREID_EROM
block|,
name|true
block|}
block|,
block|{
name|BHND_MFGID_ARM
block|,
name|BHND_COREID_PL301
block|,
name|true
block|}
block|,
block|{
name|BHND_MFGID_ARM
block|,
name|BHND_COREID_APB_BRIDGE
block|,
name|true
block|}
block|,
block|{
name|BHND_MFGID_ARM
block|,
name|BHND_COREID_AXI_UNMAPPED
block|,
name|false
block|}
block|,
block|{
name|BHND_MFGID_INVALID
block|,
name|BHND_COREID_INVALID
block|,
name|false
block|}
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|bhnd_delete_children
parameter_list|(
name|struct
name|bhnd_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of DEVICE_ATTACH().  *  * This implementation calls device_probe_and_attach() for each of the device's  * children, in bhnd probe order.  */
end_comment

begin_function
name|int
name|bhnd_generic_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhnd_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/* Probe and attach all children */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_bus_probe_children
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
block|{
name|bhnd_delete_children
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Detach and delete all children, in reverse of their attach order.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_delete_children
parameter_list|(
name|struct
name|bhnd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
modifier|*
name|devs
decl_stmt|;
name|int
name|ndevs
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Fetch children in detach order */
name|error
operator|=
name|bhnd_bus_get_children
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|devs
argument_list|,
operator|&
name|ndevs
argument_list|,
name|BHND_DEVICE_ORDER_DETACH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Perform detach */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ndevs
condition|;
name|i
operator|++
control|)
block|{
name|device_t
name|child
init|=
name|devs
index|[
name|i
index|]
decl_stmt|;
comment|/* Terminate on first error */
if|if
condition|(
operator|(
name|error
operator|=
name|device_delete_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|child
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|cleanup
label|:
name|bhnd_bus_free_children
argument_list|(
name|devs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of DEVICE_DETACH().  *  * This implementation calls device_detach() for each of the device's  * children, in reverse bhnd probe order, terminating if any call to  * device_detach() fails.  */
end_comment

begin_function
name|int
name|bhnd_generic_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhnd_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_delete_children
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of DEVICE_SHUTDOWN().  *   * This implementation calls device_shutdown() for each of the device's  * children, in reverse bhnd probe order, terminating if any call to  * device_shutdown() fails.  */
end_comment

begin_function
name|int
name|bhnd_generic_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
modifier|*
name|devs
decl_stmt|;
name|int
name|ndevs
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Fetch children in detach order */
name|error
operator|=
name|bhnd_bus_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devs
argument_list|,
operator|&
name|ndevs
argument_list|,
name|BHND_DEVICE_ORDER_DETACH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Perform shutdown */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ndevs
condition|;
name|i
operator|++
control|)
block|{
name|device_t
name|child
init|=
name|devs
index|[
name|i
index|]
decl_stmt|;
comment|/* Terminate on first error */
if|if
condition|(
operator|(
name|error
operator|=
name|device_shutdown
argument_list|(
name|child
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|cleanup
label|:
name|bhnd_bus_free_children
argument_list|(
name|devs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of DEVICE_RESUME().  *  * This implementation calls BUS_RESUME_CHILD() for each of the device's  * children in bhnd probe order, terminating if any call to BUS_RESUME_CHILD()  * fails.  */
end_comment

begin_function
name|int
name|bhnd_generic_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
modifier|*
name|devs
decl_stmt|;
name|int
name|ndevs
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Fetch children in attach order */
name|error
operator|=
name|bhnd_bus_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devs
argument_list|,
operator|&
name|ndevs
argument_list|,
name|BHND_DEVICE_ORDER_ATTACH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Perform resume */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ndevs
condition|;
name|i
operator|++
control|)
block|{
name|device_t
name|child
init|=
name|devs
index|[
name|i
index|]
decl_stmt|;
comment|/* Terminate on first error */
if|if
condition|(
operator|(
name|error
operator|=
name|BUS_RESUME_CHILD
argument_list|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
argument_list|,
name|child
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|cleanup
label|:
name|bhnd_bus_free_children
argument_list|(
name|devs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of DEVICE_SUSPEND().  *  * This implementation calls BUS_SUSPEND_CHILD() for each of the device's  * children in reverse bhnd probe order. If any call to BUS_SUSPEND_CHILD()  * fails, the suspend operation is terminated and any devices that were  * suspended are resumed immediately by calling their BUS_RESUME_CHILD()  * methods.  */
end_comment

begin_function
name|int
name|bhnd_generic_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
modifier|*
name|devs
decl_stmt|;
name|int
name|ndevs
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Fetch children in detach order */
name|error
operator|=
name|bhnd_bus_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devs
argument_list|,
operator|&
name|ndevs
argument_list|,
name|BHND_DEVICE_ORDER_DETACH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Perform suspend */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ndevs
condition|;
name|i
operator|++
control|)
block|{
name|device_t
name|child
init|=
name|devs
index|[
name|i
index|]
decl_stmt|;
name|error
operator|=
name|BUS_SUSPEND_CHILD
argument_list|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
argument_list|,
name|child
argument_list|)
expr_stmt|;
comment|/* On error, resume suspended devices and then terminate */
if|if
condition|(
name|error
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|BUS_RESUME_CHILD
argument_list|(
name|device_get_parent
argument_list|(
name|devs
index|[
name|j
index|]
argument_list|)
argument_list|,
name|devs
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
goto|goto
name|cleanup
goto|;
block|}
block|}
name|cleanup
label|:
name|bhnd_bus_free_children
argument_list|(
name|devs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of BHND_BUS_GET_PROBE_ORDER().  *  * This implementation determines probe ordering based on the device's class  * and other properties, including whether the device is serving as a host  * bridge.  */
end_comment

begin_function
name|int
name|bhnd_generic_get_probe_order
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
switch|switch
condition|(
name|bhnd_get_class
argument_list|(
name|child
argument_list|)
condition|)
block|{
case|case
name|BHND_DEVCLASS_CC
case|:
comment|/* Must be early enough to provide NVRAM access to the 		 * host bridge */
return|return
operator|(
name|BHND_PROBE_ROOT
operator|+
name|BHND_PROBE_ORDER_FIRST
operator|)
return|;
case|case
name|BHND_DEVCLASS_CC_B
case|:
comment|/* fall through */
case|case
name|BHND_DEVCLASS_PMU
case|:
return|return
operator|(
name|BHND_PROBE_BUS
operator|+
name|BHND_PROBE_ORDER_EARLY
operator|)
return|;
case|case
name|BHND_DEVCLASS_SOC_ROUTER
case|:
return|return
operator|(
name|BHND_PROBE_BUS
operator|+
name|BHND_PROBE_ORDER_LATE
operator|)
return|;
case|case
name|BHND_DEVCLASS_SOC_BRIDGE
case|:
return|return
operator|(
name|BHND_PROBE_BUS
operator|+
name|BHND_PROBE_ORDER_LAST
operator|)
return|;
case|case
name|BHND_DEVCLASS_CPU
case|:
return|return
operator|(
name|BHND_PROBE_CPU
operator|+
name|BHND_PROBE_ORDER_FIRST
operator|)
return|;
case|case
name|BHND_DEVCLASS_RAM
case|:
comment|/* fall through */
case|case
name|BHND_DEVCLASS_MEMC
case|:
return|return
operator|(
name|BHND_PROBE_CPU
operator|+
name|BHND_PROBE_ORDER_EARLY
operator|)
return|;
case|case
name|BHND_DEVCLASS_NVRAM
case|:
return|return
operator|(
name|BHND_PROBE_RESOURCE
operator|+
name|BHND_PROBE_ORDER_EARLY
operator|)
return|;
case|case
name|BHND_DEVCLASS_PCI
case|:
case|case
name|BHND_DEVCLASS_PCIE
case|:
case|case
name|BHND_DEVCLASS_PCCARD
case|:
case|case
name|BHND_DEVCLASS_ENET
case|:
case|case
name|BHND_DEVCLASS_ENET_MAC
case|:
case|case
name|BHND_DEVCLASS_ENET_PHY
case|:
case|case
name|BHND_DEVCLASS_WLAN
case|:
case|case
name|BHND_DEVCLASS_WLAN_MAC
case|:
case|case
name|BHND_DEVCLASS_WLAN_PHY
case|:
case|case
name|BHND_DEVCLASS_EROM
case|:
case|case
name|BHND_DEVCLASS_OTHER
case|:
case|case
name|BHND_DEVCLASS_INVALID
case|:
if|if
condition|(
name|bhnd_bus_find_hostb_device
argument_list|(
name|dev
argument_list|)
operator|==
name|child
condition|)
return|return
operator|(
name|BHND_PROBE_ROOT
operator|+
name|BHND_PROBE_ORDER_EARLY
operator|)
return|;
return|return
operator|(
name|BHND_PROBE_DEFAULT
operator|)
return|;
default|default:
return|return
operator|(
name|BHND_PROBE_DEFAULT
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of BHND_BUS_ALLOC_PMU().  */
end_comment

begin_function
name|int
name|bhnd_generic_alloc_pmu
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|bhnd_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bhnd_resource
modifier|*
name|br
decl_stmt|;
name|struct
name|bhnd_core_pmu_info
modifier|*
name|pm
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|device_t
name|pmu_dev
decl_stmt|;
name|bhnd_addr_t
name|r_addr
decl_stmt|;
name|bhnd_size_t
name|r_size
decl_stmt|;
name|bus_size_t
name|pmu_regs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
comment|/* for newbus */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pm
operator|=
name|bhnd_get_pmu_info
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|pmu_regs
operator|=
name|BHND_CLK_CTL_ST
expr_stmt|;
comment|/* already allocated? */
if|if
condition|(
name|pm
operator|!=
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"duplicate PMU allocation for %s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Determine address+size of the core's PMU register block */
name|error
operator|=
name|bhnd_get_region_addr
argument_list|(
name|child
argument_list|,
name|BHND_PORT_DEVICE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|r_addr
argument_list|,
operator|&
name|r_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"error fetching register block info for "
literal|"%s: %d\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|r_size
operator|<
operator|(
name|pmu_regs
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"pmu offset %#jx would overrun %s "
literal|"register block\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|pmu_regs
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* Locate actual resource containing the core's register block */
if|if
condition|(
operator|(
name|rl
operator|=
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"NULL resource list returned for %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|rle
operator|=
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot locate core register resource "
literal|"for %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|rle
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"core register resource unallocated for "
literal|"%s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|r_addr
operator|+
name|pmu_regs
operator|<
name|rman_get_start
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|||
name|r_addr
operator|+
name|pmu_regs
operator|>=
name|rman_get_end
argument_list|(
name|rle
operator|->
name|res
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"core register resource does not map PMU "
literal|"registers at %#jx\n for %s\n"
argument_list|,
name|r_addr
operator|+
name|pmu_regs
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Adjust PMU register offset relative to the actual start address 	 * of the core's register block allocation. 	 *  	 * XXX: The saved offset will be invalid if bus_adjust_resource is 	 * used to modify the resource's start address. 	 */
if|if
condition|(
name|rman_get_start
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|>
name|r_addr
condition|)
name|pmu_regs
operator|-=
name|rman_get_start
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|-
name|r_addr
expr_stmt|;
else|else
name|pmu_regs
operator|-=
name|r_addr
operator|-
name|rman_get_start
argument_list|(
name|rle
operator|->
name|res
argument_list|)
expr_stmt|;
comment|/* Retain PMU reference on behalf of our caller */
name|pmu_dev
operator|=
name|bhnd_retain_provider
argument_list|(
name|child
argument_list|,
name|BHND_SERVICE_PMU
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmu_dev
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"pmu unavailable; cannot allocate request state\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Allocate and initialize PMU info */
name|br
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bhnd_resource
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|br
operator|==
name|NULL
condition|)
block|{
name|bhnd_release_provider
argument_list|(
name|child
argument_list|,
name|pmu_dev
argument_list|,
name|BHND_SERVICE_PMU
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|br
operator|->
name|res
operator|=
name|rle
operator|->
name|res
expr_stmt|;
name|br
operator|->
name|direct
operator|=
operator|(
operator|(
name|rman_get_flags
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|&
name|RF_ACTIVE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|pm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pm
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|==
name|NULL
condition|)
block|{
name|bhnd_release_provider
argument_list|(
name|child
argument_list|,
name|pmu_dev
argument_list|,
name|BHND_SERVICE_PMU
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|br
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|pm
operator|->
name|pm_dev
operator|=
name|child
expr_stmt|;
name|pm
operator|->
name|pm_res
operator|=
name|br
expr_stmt|;
name|pm
operator|->
name|pm_regs
operator|=
name|pmu_regs
expr_stmt|;
name|pm
operator|->
name|pm_pmu
operator|=
name|pmu_dev
expr_stmt|;
name|bhnd_set_pmu_info
argument_list|(
name|child
argument_list|,
name|pm
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of BHND_BUS_RELEASE_PMU().  */
end_comment

begin_function
name|int
name|bhnd_generic_release_pmu
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|bhnd_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bhnd_core_pmu_info
modifier|*
name|pm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
comment|/* for newbus */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* dispatch release request */
name|pm
operator|=
name|bhnd_get_pmu_info
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmu over-release for %s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|BHND_PMU_CORE_RELEASE
argument_list|(
name|pm
operator|->
name|pm_pmu
argument_list|,
name|pm
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* free PMU info */
name|bhnd_set_pmu_info
argument_list|(
name|child
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bhnd_release_provider
argument_list|(
name|pm
operator|->
name|pm_dev
argument_list|,
name|pm
operator|->
name|pm_pmu
argument_list|,
name|BHND_SERVICE_PMU
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pm
operator|->
name|pm_res
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pm
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of BHND_BUS_REQUEST_CLOCK().  */
end_comment

begin_function
name|int
name|bhnd_generic_request_clock
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|bhnd_clock
name|clock
parameter_list|)
block|{
name|struct
name|bhnd_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bhnd_core_pmu_info
modifier|*
name|pm
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pm
operator|=
name|bhnd_get_pmu_info
argument_list|(
name|child
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"no active PMU request state"
argument_list|)
expr_stmt|;
comment|/* dispatch request to PMU */
return|return
operator|(
name|BHND_PMU_CORE_REQ_CLOCK
argument_list|(
name|pm
operator|->
name|pm_pmu
argument_list|,
name|pm
argument_list|,
name|clock
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of BHND_BUS_ENABLE_CLOCKS().  */
end_comment

begin_function
name|int
name|bhnd_generic_enable_clocks
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|uint32_t
name|clocks
parameter_list|)
block|{
name|struct
name|bhnd_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bhnd_core_pmu_info
modifier|*
name|pm
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pm
operator|=
name|bhnd_get_pmu_info
argument_list|(
name|child
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"no active PMU request state"
argument_list|)
expr_stmt|;
comment|/* dispatch request to PMU */
return|return
operator|(
name|BHND_PMU_CORE_EN_CLOCKS
argument_list|(
name|pm
operator|->
name|pm_pmu
argument_list|,
name|pm
argument_list|,
name|clocks
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of BHND_BUS_REQUEST_EXT_RSRC().  */
end_comment

begin_function
name|int
name|bhnd_generic_request_ext_rsrc
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|u_int
name|rsrc
parameter_list|)
block|{
name|struct
name|bhnd_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bhnd_core_pmu_info
modifier|*
name|pm
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pm
operator|=
name|bhnd_get_pmu_info
argument_list|(
name|child
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"no active PMU request state"
argument_list|)
expr_stmt|;
comment|/* dispatch request to PMU */
return|return
operator|(
name|BHND_PMU_CORE_REQ_EXT_RSRC
argument_list|(
name|pm
operator|->
name|pm_pmu
argument_list|,
name|pm
argument_list|,
name|rsrc
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of BHND_BUS_RELEASE_EXT_RSRC().  */
end_comment

begin_function
name|int
name|bhnd_generic_release_ext_rsrc
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|u_int
name|rsrc
parameter_list|)
block|{
name|struct
name|bhnd_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bhnd_core_pmu_info
modifier|*
name|pm
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pm
operator|=
name|bhnd_get_pmu_info
argument_list|(
name|child
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"no active PMU request state"
argument_list|)
expr_stmt|;
comment|/* dispatch request to PMU */
return|return
operator|(
name|BHND_PMU_CORE_RELEASE_EXT_RSRC
argument_list|(
name|pm
operator|->
name|pm_pmu
argument_list|,
name|pm
argument_list|,
name|rsrc
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of BHND_BUS_IS_REGION_VALID().  *   * This implementation assumes that port and region numbers are 0-indexed and  * are allocated non-sparsely, using BHND_BUS_GET_PORT_COUNT() and  * BHND_BUS_GET_REGION_COUNT() to determine if @p port and @p region fall  * within the defined range.  */
end_comment

begin_function
specifier|static
name|bool
name|bhnd_generic_is_region_valid
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|bhnd_port_type
name|type
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|region
parameter_list|)
block|{
if|if
condition|(
name|port
operator|>=
name|bhnd_get_port_count
argument_list|(
name|child
argument_list|,
name|type
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|region
operator|>=
name|bhnd_get_region_count
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
name|port
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of BHND_BUS_GET_NVRAM_VAR().  *   * This implementation searches @p dev for a registered NVRAM child device.  *   * If no NVRAM device is registered with @p dev, the request is delegated to  * the BHND_BUS_GET_NVRAM_VAR() method on the parent of @p dev.  */
end_comment

begin_function
name|int
name|bhnd_generic_get_nvram_var
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|bhnd_nvram_type
name|type
parameter_list|)
block|{
name|struct
name|bhnd_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|nvram
decl_stmt|,
name|parent
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* If a NVRAM device is available, consult it first */
name|nvram
operator|=
name|bhnd_retain_provider
argument_list|(
name|child
argument_list|,
name|BHND_SERVICE_NVRAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvram
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|BHND_NVRAM_GETVAR
argument_list|(
name|nvram
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|bhnd_release_provider
argument_list|(
name|child
argument_list|,
name|nvram
argument_list|,
name|BHND_SERVICE_NVRAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Otherwise, try to delegate to parent */
if|if
condition|(
operator|(
name|parent
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
return|return
operator|(
name|BHND_BUS_GET_NVRAM_VAR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of BUS_PRINT_CHILD().  *   * This implementation requests the device's struct resource_list via  * BUS_GET_RESOURCE_LIST.  */
end_comment

begin_function
name|int
name|bhnd_generic_print_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|rl
operator|=
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"mem"
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|"%#jx"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"irq"
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|"%#jd"
argument_list|)
expr_stmt|;
block|}
name|retval
operator|+=
name|printf
argument_list|(
literal|" at core %u"
argument_list|,
name|bhnd_get_core_index
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_domain
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of BUS_PROBE_NOMATCH().  *   * This implementation requests the device's struct resource_list via  * BUS_GET_RESOURCE_LIST.  */
end_comment

begin_function
name|void
name|bhnd_generic_probe_nomatch
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
specifier|const
name|struct
name|bhnd_nomatch
modifier|*
name|nm
decl_stmt|;
name|bool
name|report
decl_stmt|;
comment|/* Fetch reporting configuration for this device */
name|report
operator|=
name|true
expr_stmt|;
for|for
control|(
name|nm
operator|=
name|bhnd_nomatch_table
init|;
name|nm
operator|->
name|device
operator|!=
name|BHND_COREID_INVALID
condition|;
name|nm
operator|++
control|)
block|{
if|if
condition|(
name|nm
operator|->
name|vendor
operator|!=
name|bhnd_get_vendor
argument_list|(
name|child
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|nm
operator|->
name|device
operator|!=
name|bhnd_get_device
argument_list|(
name|child
argument_list|)
condition|)
continue|continue;
name|report
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|&&
name|nm
operator|->
name|if_verbose
condition|)
name|report
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|report
condition|)
return|return;
comment|/* Print the non-matched device info */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"<%s %s>"
argument_list|,
name|bhnd_get_vendor_name
argument_list|(
name|child
argument_list|)
argument_list|,
name|bhnd_get_device_name
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|rl
operator|=
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|!=
name|NULL
condition|)
block|{
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"mem"
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|"%#jx"
argument_list|)
expr_stmt|;
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"irq"
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|"%#jd"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" at core %u (no driver attached)\n"
argument_list|,
name|bhnd_get_core_index
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Default implementation of BUS_CHILD_PNPINFO_STR().  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_child_pnpinfo_str
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
block|{
return|return
operator|(
name|BUS_CHILD_PNPINFO_STR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"vendor=0x%hx device=0x%hx rev=0x%hhx"
argument_list|,
name|bhnd_get_vendor
argument_list|(
name|child
argument_list|)
argument_list|,
name|bhnd_get_device
argument_list|(
name|child
argument_list|)
argument_list|,
name|bhnd_get_hwrev
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default implementation of BUS_CHILD_LOCATION_STR().  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_child_location_str
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|bhnd_addr_t
name|addr
decl_stmt|;
name|bhnd_size_t
name|size
decl_stmt|;
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
block|{
return|return
operator|(
name|BUS_CHILD_LOCATION_STR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|bhnd_get_region_addr
argument_list|(
name|child
argument_list|,
name|BHND_PORT_DEVICE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|size
argument_list|)
condition|)
block|{
comment|/* No device default port/region */
if|if
condition|(
name|buflen
operator|>
literal|0
condition|)
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"port0.0=0x%llx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of BUS_CHILD_DELETED().  *   * This implementation manages internal bhnd(4) state, and must be called  * by subclassing drivers.  */
end_comment

begin_function
name|void
name|bhnd_generic_child_deleted
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|bhnd_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Free device info */
if|if
condition|(
name|bhnd_get_pmu_info
argument_list|(
name|child
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Releasing PMU requests automatically would be nice, 		 * but we can't reference per-core PMU register 		 * resource after driver detach */
name|panic
argument_list|(
literal|"%s leaked device pmu state\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BUS_SUSPEND_CHILD().  *  * TODO: Power management  *   * If @p child is not a direct child of @p dev, suspension is delegated to  * the @p dev parent.  */
end_comment

begin_function
name|int
name|bhnd_generic_suspend_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
name|BUS_SUSPEND_CHILD
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
name|bus_generic_suspend_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BUS_RESUME_CHILD().  *  * TODO: Power management  *   * If @p child is not a direct child of @p dev, suspension is delegated to  * the @p dev parent.  */
end_comment

begin_function
name|int
name|bhnd_generic_resume_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
name|BUS_RESUME_CHILD
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
name|bus_generic_resume_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of BUS_SETUP_INTR().  *  * This implementation of BUS_SETUP_INTR() will delegate interrupt setup  * to the parent of @p dev, if any.  */
end_comment

begin_function
name|int
name|bhnd_generic_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_filter_t
modifier|*
name|filter
parameter_list|,
name|driver_intr_t
modifier|*
name|intr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
return|return
operator|(
name|bus_generic_setup_intr
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|irq
argument_list|,
name|flags
argument_list|,
name|filter
argument_list|,
name|intr
argument_list|,
name|arg
argument_list|,
name|cookiep
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delegate all indirect I/O to the parent device. When inherited by  * non-bridged bus implementations, resources will never be marked as  * indirect, and these methods will never be called.  */
end_comment

begin_define
define|#
directive|define
name|BHND_IO_READ
parameter_list|(
name|_type
parameter_list|,
name|_name
parameter_list|,
name|_method
parameter_list|)
define|\
value|static _type								\ bhnd_read_ ## _name (device_t dev, device_t child,			\     struct bhnd_resource *r, bus_size_t offset)				\ {									\ 	return (BHND_BUS_READ_ ## _method(				\ 		    device_get_parent(dev), child, r, offset));		\ }
end_define

begin_define
define|#
directive|define
name|BHND_IO_WRITE
parameter_list|(
name|_type
parameter_list|,
name|_name
parameter_list|,
name|_method
parameter_list|)
define|\
value|static void								\ bhnd_write_ ## _name (device_t dev, device_t child,			\     struct bhnd_resource *r, bus_size_t offset, _type value)		\ {									\ 	return (BHND_BUS_WRITE_ ## _method(				\ 		    device_get_parent(dev), child, r, offset,		\ 		    value));	\ }
end_define

begin_define
define|#
directive|define
name|BHND_IO_MISC
parameter_list|(
name|_type
parameter_list|,
name|_op
parameter_list|,
name|_method
parameter_list|)
define|\
value|static void								\ bhnd_ ## _op (device_t dev, device_t child,				\     struct bhnd_resource *r, bus_size_t offset, _type datap,		\     bus_size_t count)							\ {									\ 	BHND_BUS_ ## _method(device_get_parent(dev), child, r,		\ 	    offset, datap, count);					\ }
end_define

begin_define
define|#
directive|define
name|BHND_IO_METHODS
parameter_list|(
name|_type
parameter_list|,
name|_size
parameter_list|)
define|\
value|BHND_IO_READ(_type, _size, _size)				\ 	BHND_IO_WRITE(_type, _size, _size)				\ 									\ 	BHND_IO_READ(_type, stream_ ## _size, STREAM_ ## _size)		\ 	BHND_IO_WRITE(_type, stream_ ## _size, STREAM_ ## _size)	\ 									\ 	BHND_IO_MISC(_type*, read_multi_ ## _size,			\ 	    READ_MULTI_ ## _size)					\ 	BHND_IO_MISC(_type*, write_multi_ ## _size,			\ 	    WRITE_MULTI_ ## _size)					\ 									\ 	BHND_IO_MISC(_type*, read_multi_stream_ ## _size,		\ 	   READ_MULTI_STREAM_ ## _size)					\ 	BHND_IO_MISC(_type*, write_multi_stream_ ## _size,		\ 	   WRITE_MULTI_STREAM_ ## _size)				\ 									\ 	BHND_IO_MISC(_type, set_multi_ ## _size, SET_MULTI_ ## _size)	\ 	BHND_IO_MISC(_type, set_region_ ## _size, SET_REGION_ ## _size)	\ 									\ 	BHND_IO_MISC(_type*, read_region_ ## _size,			\ 	    READ_REGION_ ## _size)					\ 	BHND_IO_MISC(_type*, write_region_ ## _size,			\ 	    WRITE_REGION_ ## _size)					\ 									\ 	BHND_IO_MISC(_type*, read_region_stream_ ## _size,		\ 	    READ_REGION_STREAM_ ## _size)				\ 	BHND_IO_MISC(_type*, write_region_stream_ ## _size,		\ 	    WRITE_REGION_STREAM_ ## _size)				\  BHND_IO_METHODS(uint8_t, 1);
end_define

begin_expr_stmt
name|BHND_IO_METHODS
argument_list|(
name|uint16_t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BHND_IO_METHODS
argument_list|(
name|uint32_t
argument_list|,
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|bhnd_barrier
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|bhnd_resource
modifier|*
name|r
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|bus_size_t
name|length
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|BHND_BUS_BARRIER
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|r
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|bhnd_methods
index|[]
init|=
block|{
comment|/* Device interface */
block|\
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|bhnd_generic_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bhnd_generic_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bhnd_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bhnd_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bhnd_generic_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_child_deleted
argument_list|,
name|bhnd_generic_child_deleted
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_probe_nomatch
argument_list|,
name|bhnd_generic_probe_nomatch
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bhnd_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_pnpinfo_str
argument_list|,
name|bhnd_child_pnpinfo_str
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_location_str
argument_list|,
name|bhnd_child_location_str
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_suspend_child
argument_list|,
name|bhnd_generic_suspend_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_resume_child
argument_list|,
name|bhnd_generic_resume_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_set_resource
argument_list|,
name|bus_generic_rl_set_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource
argument_list|,
name|bus_generic_rl_get_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_delete_resource
argument_list|,
name|bus_generic_rl_delete_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|bus_generic_rl_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_adjust_resource
argument_list|,
name|bus_generic_adjust_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|bus_generic_rl_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bus_generic_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|bus_generic_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|bhnd_generic_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|bus_generic_teardown_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_config_intr
argument_list|,
name|bus_generic_config_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_bind_intr
argument_list|,
name|bus_generic_bind_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_describe_intr
argument_list|,
name|bus_generic_describe_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_dma_tag
argument_list|,
name|bus_generic_get_dma_tag
argument_list|)
block|,
comment|/* BHND interface */
name|DEVMETHOD
argument_list|(
name|bhnd_bus_get_chipid
argument_list|,
name|bhnd_bus_generic_get_chipid
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_is_hw_disabled
argument_list|,
name|bhnd_bus_generic_is_hw_disabled
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_board_info
argument_list|,
name|bhnd_bus_generic_read_board_info
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_get_probe_order
argument_list|,
name|bhnd_generic_get_probe_order
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_alloc_pmu
argument_list|,
name|bhnd_generic_alloc_pmu
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_release_pmu
argument_list|,
name|bhnd_generic_release_pmu
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_request_clock
argument_list|,
name|bhnd_generic_request_clock
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_enable_clocks
argument_list|,
name|bhnd_generic_enable_clocks
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_request_ext_rsrc
argument_list|,
name|bhnd_generic_request_ext_rsrc
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_release_ext_rsrc
argument_list|,
name|bhnd_generic_release_ext_rsrc
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_is_region_valid
argument_list|,
name|bhnd_generic_is_region_valid
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_get_nvram_var
argument_list|,
name|bhnd_generic_get_nvram_var
argument_list|)
block|,
comment|/* BHND interface (bus I/O) */
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_1
argument_list|,
name|bhnd_read_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_2
argument_list|,
name|bhnd_read_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_4
argument_list|,
name|bhnd_read_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_1
argument_list|,
name|bhnd_write_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_2
argument_list|,
name|bhnd_write_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_4
argument_list|,
name|bhnd_write_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_stream_1
argument_list|,
name|bhnd_read_stream_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_stream_2
argument_list|,
name|bhnd_read_stream_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_stream_4
argument_list|,
name|bhnd_read_stream_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_stream_1
argument_list|,
name|bhnd_write_stream_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_stream_2
argument_list|,
name|bhnd_write_stream_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_stream_4
argument_list|,
name|bhnd_write_stream_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_multi_1
argument_list|,
name|bhnd_read_multi_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_multi_2
argument_list|,
name|bhnd_read_multi_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_multi_4
argument_list|,
name|bhnd_read_multi_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_multi_1
argument_list|,
name|bhnd_write_multi_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_multi_2
argument_list|,
name|bhnd_write_multi_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_multi_4
argument_list|,
name|bhnd_write_multi_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_multi_stream_1
argument_list|,
name|bhnd_read_multi_stream_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_multi_stream_2
argument_list|,
name|bhnd_read_multi_stream_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_multi_stream_4
argument_list|,
name|bhnd_read_multi_stream_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_multi_stream_1
argument_list|,
name|bhnd_write_multi_stream_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_multi_stream_2
argument_list|,
name|bhnd_write_multi_stream_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_multi_stream_4
argument_list|,
name|bhnd_write_multi_stream_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_set_multi_1
argument_list|,
name|bhnd_set_multi_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_set_multi_2
argument_list|,
name|bhnd_set_multi_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_set_multi_4
argument_list|,
name|bhnd_set_multi_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_set_region_1
argument_list|,
name|bhnd_set_region_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_set_region_2
argument_list|,
name|bhnd_set_region_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_set_region_4
argument_list|,
name|bhnd_set_region_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_region_1
argument_list|,
name|bhnd_read_region_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_region_2
argument_list|,
name|bhnd_read_region_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_region_4
argument_list|,
name|bhnd_read_region_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_region_1
argument_list|,
name|bhnd_write_region_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_region_2
argument_list|,
name|bhnd_write_region_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_region_4
argument_list|,
name|bhnd_write_region_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_region_stream_1
argument_list|,
name|bhnd_read_region_stream_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_region_stream_2
argument_list|,
name|bhnd_read_region_stream_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_region_stream_4
argument_list|,
name|bhnd_read_region_stream_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_region_stream_1
argument_list|,
name|bhnd_write_region_stream_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_region_stream_2
argument_list|,
name|bhnd_write_region_stream_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_region_stream_4
argument_list|,
name|bhnd_write_region_stream_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_barrier
argument_list|,
name|bhnd_barrier
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|bhnd_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< bhnd bus. */
end_comment

begin_decl_stmt
name|devclass_t
name|bhnd_hostb_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< bhnd bus host bridge. */
end_comment

begin_decl_stmt
name|devclass_t
name|bhnd_nvram_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< bhnd NVRAM device */
end_comment

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|bhnd
argument_list|,
name|bhnd_driver
argument_list|,
name|bhnd_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bhnd_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|bhnd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

