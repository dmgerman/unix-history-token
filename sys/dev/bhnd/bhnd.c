begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 Landon Fuller<landon@landonf.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Broadcom Home Networking Division (HND) Bus Driver.  *   * The Broadcom HND family of devices consists of both SoCs and host-connected  * networking chipsets containing a common family of Broadcom IP cores,  * including an integrated MIPS and/or ARM cores.  *   * HND devices expose a nearly identical interface whether accessible over a   * native SoC interconnect, or when connected via a host interface such as   * PCIe. As a result, the majority of hardware support code should be re-usable   * across host drivers for HND networking chipsets, as well as FreeBSD support   * for Broadcom MIPS/ARM HND SoCs.  *   * Earlier HND models used the siba(4) on-chip interconnect, while later models  * use bcma(4); the programming model is almost entirely independent  * of the actual underlying interconect.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/chipc/chipcvar.h>
end_include

begin_include
include|#
directive|include
file|"bhnd_chipc_if.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_if.h"
end_include

begin_include
include|#
directive|include
file|"bhnd.h"
end_include

begin_include
include|#
directive|include
file|"bhndvar.h"
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_BHND
argument_list|,
literal|"bhnd"
argument_list|,
literal|"bhnd bus data structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Bus pass at which all bus-required children must be available, and  * attachment may be finalized. */
end_comment

begin_define
define|#
directive|define
name|BHND_FINISH_ATTACH_PASS
value|BUS_PASS_DEFAULT
end_define

begin_comment
comment|/**  * bhnd_generic_probe_nomatch() reporting configuration.  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|bhnd_nomatch
block|{
name|uint16_t
name|vendor
decl_stmt|;
comment|/**< core designer */
name|uint16_t
name|device
decl_stmt|;
comment|/**< core id */
name|bool
name|if_verbose
decl_stmt|;
comment|/**< print when bootverbose is set. */
block|}
name|bhnd_nomatch_table
index|[]
init|=
block|{
block|{
name|BHND_MFGID_ARM
block|,
name|BHND_COREID_OOB_ROUTER
block|,
name|true
block|}
block|,
block|{
name|BHND_MFGID_ARM
block|,
name|BHND_COREID_EROM
block|,
name|true
block|}
block|,
block|{
name|BHND_MFGID_ARM
block|,
name|BHND_COREID_PL301
block|,
name|true
block|}
block|,
block|{
name|BHND_MFGID_ARM
block|,
name|BHND_COREID_APB_BRIDGE
block|,
name|true
block|}
block|,
block|{
name|BHND_MFGID_ARM
block|,
name|BHND_COREID_AXI_UNMAPPED
block|,
name|false
block|}
block|,
block|{
name|BHND_MFGID_INVALID
block|,
name|BHND_COREID_INVALID
block|,
name|false
block|}
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|bhnd_delete_children
parameter_list|(
name|struct
name|bhnd_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_finish_attach
parameter_list|(
name|struct
name|bhnd_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|device_t
name|bhnd_find_chipc
parameter_list|(
name|struct
name|bhnd_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|chipc_caps
modifier|*
name|bhnd_find_chipc_caps
parameter_list|(
name|struct
name|bhnd_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|device_t
name|bhnd_find_platform_dev
parameter_list|(
name|struct
name|bhnd_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|classname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|device_t
name|bhnd_find_pmu
parameter_list|(
name|struct
name|bhnd_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|device_t
name|bhnd_find_nvram
parameter_list|(
name|struct
name|bhnd_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_ascending_probe_order
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_descending_probe_order
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of DEVICE_ATTACH().  *  * This implementation calls device_probe_and_attach() for each of the device's  * children, in bhnd probe order.  */
end_comment

begin_function
name|int
name|bhnd_generic_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhnd_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
modifier|*
name|devs
decl_stmt|;
name|int
name|ndevs
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devs
argument_list|,
operator|&
name|ndevs
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Probe and attach all children */
name|qsort
argument_list|(
name|devs
argument_list|,
name|ndevs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|devs
argument_list|)
argument_list|,
name|compare_ascending_probe_order
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ndevs
condition|;
name|i
operator|++
control|)
block|{
name|device_t
name|child
init|=
name|devs
index|[
name|i
index|]
decl_stmt|;
name|device_probe_and_attach
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
comment|/* Try to finalize attachment */
if|if
condition|(
name|bus_current_pass
operator|>=
name|BHND_FINISH_ATTACH_PASS
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_finish_attach
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|cleanup
label|:
name|free
argument_list|(
name|devs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|bhnd_delete_children
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Detach and delete all children, in reverse of their attach order.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_delete_children
parameter_list|(
name|struct
name|bhnd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
modifier|*
name|devs
decl_stmt|;
name|int
name|ndevs
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|device_get_children
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|devs
argument_list|,
operator|&
name|ndevs
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Detach in the reverse of attach order */
name|qsort
argument_list|(
name|devs
argument_list|,
name|ndevs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|devs
argument_list|)
argument_list|,
name|compare_descending_probe_order
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ndevs
condition|;
name|i
operator|++
control|)
block|{
name|device_t
name|child
init|=
name|devs
index|[
name|i
index|]
decl_stmt|;
comment|/* Terminate on first error */
if|if
condition|(
operator|(
name|error
operator|=
name|device_delete_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|child
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|cleanup
label|:
name|free
argument_list|(
name|devs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of DEVICE_DETACH().  *  * This implementation calls device_detach() for each of the device's  * children, in reverse bhnd probe order, terminating if any call to  * device_detach() fails.  */
end_comment

begin_function
name|int
name|bhnd_generic_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhnd_softc
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
operator|!
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|bhnd_delete_children
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of DEVICE_SHUTDOWN().  *   * This implementation calls device_shutdown() for each of the device's  * children, in reverse bhnd probe order, terminating if any call to  * device_shutdown() fails.  */
end_comment

begin_function
name|int
name|bhnd_generic_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
modifier|*
name|devs
decl_stmt|;
name|int
name|ndevs
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devs
argument_list|,
operator|&
name|ndevs
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Shutdown in the reverse of attach order */
name|qsort
argument_list|(
name|devs
argument_list|,
name|ndevs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|devs
argument_list|)
argument_list|,
name|compare_descending_probe_order
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ndevs
condition|;
name|i
operator|++
control|)
block|{
name|device_t
name|child
init|=
name|devs
index|[
name|i
index|]
decl_stmt|;
comment|/* Terminate on first error */
if|if
condition|(
operator|(
name|error
operator|=
name|device_shutdown
argument_list|(
name|child
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|cleanup
label|:
name|free
argument_list|(
name|devs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of DEVICE_RESUME().  *  * This implementation calls BUS_RESUME_CHILD() for each of the device's  * children in bhnd probe order, terminating if any call to BUS_RESUME_CHILD()  * fails.  */
end_comment

begin_function
name|int
name|bhnd_generic_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
modifier|*
name|devs
decl_stmt|;
name|int
name|ndevs
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devs
argument_list|,
operator|&
name|ndevs
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|qsort
argument_list|(
name|devs
argument_list|,
name|ndevs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|devs
argument_list|)
argument_list|,
name|compare_ascending_probe_order
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ndevs
condition|;
name|i
operator|++
control|)
block|{
name|device_t
name|child
init|=
name|devs
index|[
name|i
index|]
decl_stmt|;
comment|/* Terminate on first error */
if|if
condition|(
operator|(
name|error
operator|=
name|BUS_RESUME_CHILD
argument_list|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
argument_list|,
name|child
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|cleanup
label|:
name|free
argument_list|(
name|devs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of DEVICE_SUSPEND().  *  * This implementation calls BUS_SUSPEND_CHILD() for each of the device's  * children in reverse bhnd probe order. If any call to BUS_SUSPEND_CHILD()  * fails, the suspend operation is terminated and any devices that were  * suspended are resumed immediately by calling their BUS_RESUME_CHILD()  * methods.  */
end_comment

begin_function
name|int
name|bhnd_generic_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
modifier|*
name|devs
decl_stmt|;
name|int
name|ndevs
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devs
argument_list|,
operator|&
name|ndevs
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Suspend in the reverse of attach order */
name|qsort
argument_list|(
name|devs
argument_list|,
name|ndevs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|devs
argument_list|)
argument_list|,
name|compare_descending_probe_order
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ndevs
condition|;
name|i
operator|++
control|)
block|{
name|device_t
name|child
init|=
name|devs
index|[
name|i
index|]
decl_stmt|;
name|error
operator|=
name|BUS_SUSPEND_CHILD
argument_list|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
argument_list|,
name|child
argument_list|)
expr_stmt|;
comment|/* On error, resume suspended devices and then terminate */
if|if
condition|(
name|error
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|BUS_RESUME_CHILD
argument_list|(
name|device_get_parent
argument_list|(
name|devs
index|[
name|j
index|]
argument_list|)
argument_list|,
name|devs
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
goto|goto
name|cleanup
goto|;
block|}
block|}
name|cleanup
label|:
name|free
argument_list|(
name|devs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bhnd_new_pass
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhnd_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Attach any permissible children */
name|bus_generic_new_pass
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Finalize attachment */
if|if
condition|(
operator|!
name|sc
operator|->
name|attach_done
operator|&&
name|bus_current_pass
operator|>=
name|BHND_FINISH_ATTACH_PASS
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_finish_attach
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"bhnd_finish_attach() failed: %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Finish any pending bus attachment operations.  *  * When attached as a SoC bus (as opposed to a bridged WiFi device), our  * platform devices may not be attached until later bus passes, necessitating  * delayed initialization on our part.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_finish_attach
parameter_list|(
name|struct
name|bhnd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|chipc_caps
modifier|*
name|ccaps
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
comment|/* newbus */
name|KASSERT
argument_list|(
name|bus_current_pass
operator|>=
name|BHND_FINISH_ATTACH_PASS
argument_list|,
operator|(
literal|"bhnd_finish_attach() called in pass %d"
operator|,
name|bus_current_pass
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|sc
operator|->
name|attach_done
argument_list|,
operator|(
literal|"duplicate call to bhnd_finish_attach()"
operator|)
argument_list|)
expr_stmt|;
comment|/* Locate chipc device */
if|if
condition|(
operator|(
name|sc
operator|->
name|chipc_dev
operator|=
name|bhnd_find_chipc
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"error: ChipCommon device not found\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ccaps
operator|=
name|BHND_CHIPC_GET_CAPS
argument_list|(
name|sc
operator|->
name|chipc_dev
argument_list|)
expr_stmt|;
comment|/* Look for NVRAM device */
if|if
condition|(
name|ccaps
operator|->
name|nvram_src
operator|!=
name|BHND_NVRAM_SRC_UNKNOWN
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|nvram_dev
operator|=
name|bhnd_find_nvram
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"warning: NVRAM %s device not found\n"
argument_list|,
name|bhnd_nvram_src_name
argument_list|(
name|ccaps
operator|->
name|nvram_src
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Look for a PMU  */
if|if
condition|(
name|ccaps
operator|->
name|pmu
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|pmu_dev
operator|=
name|bhnd_find_pmu
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"warning: PMU device not found\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mark attach as completed */
name|sc
operator|->
name|attach_done
operator|=
name|true
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Locate the ChipCommon core. */
end_comment

begin_function
specifier|static
name|device_t
name|bhnd_find_chipc
parameter_list|(
name|struct
name|bhnd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|chipc
decl_stmt|;
comment|/* Make sure we're holding Giant for newbus */
name|GIANT_REQUIRED
expr_stmt|;
comment|/* chipc_dev is initialized during attachment */
if|if
condition|(
name|sc
operator|->
name|attach_done
condition|)
block|{
if|if
condition|(
operator|(
name|chipc
operator|=
name|sc
operator|->
name|chipc_dev
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
goto|goto
name|found
goto|;
block|}
comment|/* Locate chipc core with a core unit of 0 */
name|chipc
operator|=
name|bhnd_find_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|BHND_DEVCLASS_CC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|chipc
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|found
label|:
if|if
condition|(
name|device_get_state
argument_list|(
name|chipc
argument_list|)
operator|<
name|DS_ATTACHING
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"chipc found, but did not attach\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|chipc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Locate the ChipCommon core and return the device capabilities  */
end_comment

begin_function
specifier|static
name|struct
name|chipc_caps
modifier|*
name|bhnd_find_chipc_caps
parameter_list|(
name|struct
name|bhnd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|chipc
decl_stmt|;
if|if
condition|(
operator|(
name|chipc
operator|=
name|bhnd_find_chipc
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"chipc unavailable; cannot fetch capabilities\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|BHND_CHIPC_GET_CAPS
argument_list|(
name|chipc
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find an attached platform device on @p dev, searching first for cores  * matching @p classname, and if not found, searching the children of the first  * bhnd_chipc device on the bus.  *   * @param sc Driver state.  * @param chipc Attached ChipCommon device.  * @param classname Device class to search for.  *   * @retval device_t A matching device.  * @retval NULL If no matching device is found.  */
end_comment

begin_function
specifier|static
name|device_t
name|bhnd_find_platform_dev
parameter_list|(
name|struct
name|bhnd_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|classname
parameter_list|)
block|{
name|device_t
name|chipc
decl_stmt|,
name|child
decl_stmt|;
comment|/* Make sure we're holding Giant for newbus */
name|GIANT_REQUIRED
expr_stmt|;
comment|/* Look for a directly-attached child */
name|child
operator|=
name|device_find_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|classname
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|!=
name|NULL
condition|)
goto|goto
name|found
goto|;
comment|/* Look for the first matching ChipCommon child */
if|if
condition|(
operator|(
name|chipc
operator|=
name|bhnd_find_chipc
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"chipc unavailable; cannot locate %s\n"
argument_list|,
name|classname
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|child
operator|=
name|device_find_child
argument_list|(
name|chipc
argument_list|,
name|classname
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|!=
name|NULL
condition|)
goto|goto
name|found
goto|;
comment|/* Look for a parent-attached device (e.g. nexus0 -> bhnd_nvram) */
name|child
operator|=
name|device_find_child
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|classname
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|found
label|:
if|if
condition|(
name|device_get_state
argument_list|(
name|child
argument_list|)
operator|<
name|DS_ATTACHING
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|child
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Locate the PMU device, if any */
end_comment

begin_function
specifier|static
name|device_t
name|bhnd_find_pmu
parameter_list|(
name|struct
name|bhnd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|chipc_caps
modifier|*
name|ccaps
decl_stmt|;
comment|/* Make sure we're holding Giant for newbus */
name|GIANT_REQUIRED
expr_stmt|;
comment|/* pmu_dev is initialized during attachment */
if|if
condition|(
name|sc
operator|->
name|attach_done
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|pmu_dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|device_get_state
argument_list|(
name|sc
operator|->
name|pmu_dev
argument_list|)
operator|<
name|DS_ATTACHING
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|sc
operator|->
name|pmu_dev
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccaps
operator|=
name|bhnd_find_chipc_caps
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|!
name|ccaps
operator|->
name|pmu
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|bhnd_find_platform_dev
argument_list|(
name|sc
argument_list|,
literal|"bhnd_pmu"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Locate the NVRAM device, if any */
end_comment

begin_function
specifier|static
name|device_t
name|bhnd_find_nvram
parameter_list|(
name|struct
name|bhnd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|chipc_caps
modifier|*
name|ccaps
decl_stmt|;
comment|/* Make sure we're holding Giant for newbus */
name|GIANT_REQUIRED
expr_stmt|;
comment|/* nvram_dev is initialized during attachment */
if|if
condition|(
name|sc
operator|->
name|attach_done
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|nvram_dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|device_get_state
argument_list|(
name|sc
operator|->
name|nvram_dev
argument_list|)
operator|<
name|DS_ATTACHING
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|sc
operator|->
name|nvram_dev
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccaps
operator|=
name|bhnd_find_chipc_caps
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ccaps
operator|->
name|nvram_src
operator|==
name|BHND_NVRAM_SRC_UNKNOWN
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|bhnd_find_platform_dev
argument_list|(
name|sc
argument_list|,
literal|"bhnd_nvram"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Ascending comparison of bhnd device's probe order.  */
end_comment

begin_function
specifier|static
name|int
name|compare_ascending_probe_order
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
name|device_t
name|ldev
decl_stmt|,
name|rdev
decl_stmt|;
name|int
name|lorder
decl_stmt|,
name|rorder
decl_stmt|;
name|ldev
operator|=
operator|(
operator|*
operator|(
specifier|const
name|device_t
operator|*
operator|)
name|lhs
operator|)
expr_stmt|;
name|rdev
operator|=
operator|(
operator|*
operator|(
specifier|const
name|device_t
operator|*
operator|)
name|rhs
operator|)
expr_stmt|;
name|lorder
operator|=
name|BHND_BUS_GET_PROBE_ORDER
argument_list|(
name|device_get_parent
argument_list|(
name|ldev
argument_list|)
argument_list|,
name|ldev
argument_list|)
expr_stmt|;
name|rorder
operator|=
name|BHND_BUS_GET_PROBE_ORDER
argument_list|(
name|device_get_parent
argument_list|(
name|rdev
argument_list|)
argument_list|,
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|lorder
operator|<
name|rorder
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|lorder
operator|>
name|rorder
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Descending comparison of bhnd device's probe order.  */
end_comment

begin_function
specifier|static
name|int
name|compare_descending_probe_order
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
return|return
operator|(
name|compare_ascending_probe_order
argument_list|(
name|rhs
argument_list|,
name|lhs
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of BHND_BUS_GET_PROBE_ORDER().  *  * This implementation determines probe ordering based on the device's class  * and other properties, including whether the device is serving as a host  * bridge.  */
end_comment

begin_function
name|int
name|bhnd_generic_get_probe_order
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
switch|switch
condition|(
name|bhnd_get_class
argument_list|(
name|child
argument_list|)
condition|)
block|{
case|case
name|BHND_DEVCLASS_CC
case|:
comment|/* Must be early enough to provide NVRAM access to the 		 * host bridge */
return|return
operator|(
name|BHND_PROBE_ROOT
operator|+
name|BHND_PROBE_ORDER_FIRST
operator|)
return|;
case|case
name|BHND_DEVCLASS_CC_B
case|:
comment|/* fall through */
case|case
name|BHND_DEVCLASS_PMU
case|:
return|return
operator|(
name|BHND_PROBE_BUS
operator|+
name|BHND_PROBE_ORDER_EARLY
operator|)
return|;
case|case
name|BHND_DEVCLASS_SOC_ROUTER
case|:
return|return
operator|(
name|BHND_PROBE_BUS
operator|+
name|BHND_PROBE_ORDER_LATE
operator|)
return|;
case|case
name|BHND_DEVCLASS_SOC_BRIDGE
case|:
return|return
operator|(
name|BHND_PROBE_BUS
operator|+
name|BHND_PROBE_ORDER_LAST
operator|)
return|;
case|case
name|BHND_DEVCLASS_CPU
case|:
return|return
operator|(
name|BHND_PROBE_CPU
operator|+
name|BHND_PROBE_ORDER_FIRST
operator|)
return|;
case|case
name|BHND_DEVCLASS_RAM
case|:
comment|/* fall through */
case|case
name|BHND_DEVCLASS_MEMC
case|:
return|return
operator|(
name|BHND_PROBE_CPU
operator|+
name|BHND_PROBE_ORDER_EARLY
operator|)
return|;
case|case
name|BHND_DEVCLASS_NVRAM
case|:
return|return
operator|(
name|BHND_PROBE_RESOURCE
operator|+
name|BHND_PROBE_ORDER_EARLY
operator|)
return|;
case|case
name|BHND_DEVCLASS_PCI
case|:
case|case
name|BHND_DEVCLASS_PCIE
case|:
case|case
name|BHND_DEVCLASS_PCCARD
case|:
case|case
name|BHND_DEVCLASS_ENET
case|:
case|case
name|BHND_DEVCLASS_ENET_MAC
case|:
case|case
name|BHND_DEVCLASS_ENET_PHY
case|:
case|case
name|BHND_DEVCLASS_WLAN
case|:
case|case
name|BHND_DEVCLASS_WLAN_MAC
case|:
case|case
name|BHND_DEVCLASS_WLAN_PHY
case|:
case|case
name|BHND_DEVCLASS_EROM
case|:
case|case
name|BHND_DEVCLASS_OTHER
case|:
case|case
name|BHND_DEVCLASS_INVALID
case|:
if|if
condition|(
name|bhnd_find_hostb_device
argument_list|(
name|dev
argument_list|)
operator|==
name|child
condition|)
return|return
operator|(
name|BHND_PROBE_ROOT
operator|+
name|BHND_PROBE_ORDER_EARLY
operator|)
return|;
return|return
operator|(
name|BHND_PROBE_DEFAULT
operator|)
return|;
default|default:
return|return
operator|(
name|BHND_PROBE_DEFAULT
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of BHND_BUS_IS_REGION_VALID().  *   * This implementation assumes that port and region numbers are 0-indexed and  * are allocated non-sparsely, using BHND_BUS_GET_PORT_COUNT() and  * BHND_BUS_GET_REGION_COUNT() to determine if @p port and @p region fall  * within the defined range.  */
end_comment

begin_function
specifier|static
name|bool
name|bhnd_generic_is_region_valid
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|bhnd_port_type
name|type
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|region
parameter_list|)
block|{
if|if
condition|(
name|port
operator|>=
name|bhnd_get_port_count
argument_list|(
name|child
argument_list|,
name|type
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|region
operator|>=
name|bhnd_get_region_count
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
name|port
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of BHND_BUS_GET_NVRAM_VAR().  *   * This implementation searches @p dev for a usable NVRAM child device.  *   * If no usable child device is found on @p dev, the request is delegated to  * the BHND_BUS_GET_NVRAM_VAR() method on the parent of @p dev.  */
end_comment

begin_function
name|int
name|bhnd_generic_get_nvram_var
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|bhnd_nvram_type
name|type
parameter_list|)
block|{
name|struct
name|bhnd_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|nvram
decl_stmt|,
name|parent
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* If a NVRAM device is available, consult it first */
if|if
condition|(
operator|(
name|nvram
operator|=
name|bhnd_find_nvram
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|BHND_NVRAM_GETVAR
argument_list|(
name|nvram
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|type
argument_list|)
return|;
comment|/* Otherwise, try to delegate to parent */
if|if
condition|(
operator|(
name|parent
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
return|return
operator|(
name|BHND_BUS_GET_NVRAM_VAR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of BUS_PRINT_CHILD().  *   * This implementation requests the device's struct resource_list via  * BUS_GET_RESOURCE_LIST.  */
end_comment

begin_function
name|int
name|bhnd_generic_print_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|rl
operator|=
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"mem"
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|"%#jx"
argument_list|)
expr_stmt|;
block|}
name|retval
operator|+=
name|printf
argument_list|(
literal|" at core %u"
argument_list|,
name|bhnd_get_core_index
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_domain
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of BUS_PROBE_NOMATCH().  *   * This implementation requests the device's struct resource_list via  * BUS_GET_RESOURCE_LIST.  */
end_comment

begin_function
name|void
name|bhnd_generic_probe_nomatch
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
specifier|const
name|struct
name|bhnd_nomatch
modifier|*
name|nm
decl_stmt|;
name|bool
name|report
decl_stmt|;
comment|/* Fetch reporting configuration for this device */
name|report
operator|=
name|true
expr_stmt|;
for|for
control|(
name|nm
operator|=
name|bhnd_nomatch_table
init|;
name|nm
operator|->
name|device
operator|!=
name|BHND_COREID_INVALID
condition|;
name|nm
operator|++
control|)
block|{
if|if
condition|(
name|nm
operator|->
name|vendor
operator|!=
name|bhnd_get_vendor
argument_list|(
name|child
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|nm
operator|->
name|device
operator|!=
name|bhnd_get_device
argument_list|(
name|child
argument_list|)
condition|)
continue|continue;
name|report
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|&&
name|nm
operator|->
name|if_verbose
condition|)
name|report
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|report
condition|)
return|return;
comment|/* Print the non-matched device info */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"<%s %s>"
argument_list|,
name|bhnd_get_vendor_name
argument_list|(
name|child
argument_list|)
argument_list|,
name|bhnd_get_device_name
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|rl
operator|=
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|!=
name|NULL
condition|)
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"mem"
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|"%#jx"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" at core %u (no driver attached)\n"
argument_list|,
name|bhnd_get_core_index
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Default implementation of BUS_CHILD_PNPINFO_STR().  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_child_pnpinfo_str
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
block|{
return|return
operator|(
name|BUS_CHILD_PNPINFO_STR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"vendor=0x%hx device=0x%hx rev=0x%hhx"
argument_list|,
name|bhnd_get_vendor
argument_list|(
name|child
argument_list|)
argument_list|,
name|bhnd_get_device
argument_list|(
name|child
argument_list|)
argument_list|,
name|bhnd_get_hwrev
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default implementation of BUS_CHILD_LOCATION_STR().  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_child_location_str
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|bhnd_addr_t
name|addr
decl_stmt|;
name|bhnd_size_t
name|size
decl_stmt|;
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
block|{
return|return
operator|(
name|BUS_CHILD_LOCATION_STR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|bhnd_get_region_addr
argument_list|(
name|child
argument_list|,
name|BHND_PORT_DEVICE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|size
argument_list|)
condition|)
block|{
comment|/* No device default port/region */
if|if
condition|(
name|buflen
operator|>
literal|0
condition|)
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"port0.0=0x%llx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of BUS_ADD_CHILD().  *   * This implementation manages internal bhnd(4) state, and must be called  * by subclassing drivers.  */
end_comment

begin_function
name|device_t
name|bhnd_generic_add_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|order
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|bhnd_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|child
operator|=
name|device_add_child_ordered
argument_list|(
name|dev
argument_list|,
name|order
argument_list|,
name|name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|dinfo
operator|=
name|BHND_BUS_ALLOC_DEVINFO
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
comment|/* Inform concrete bus driver. */
name|BHND_BUS_CHILD_ADDED
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|child
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhnd(4) bus driver implementation of BUS_CHILD_DELETED().  *   * This implementation manages internal bhnd(4) state, and must be called  * by subclassing drivers.  */
end_comment

begin_function
name|void
name|bhnd_generic_child_deleted
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|bhnd_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bhnd_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Free device info */
if|if
condition|(
operator|(
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|BHND_BUS_FREE_DEVINFO
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
comment|/* Clean up platform device references */
if|if
condition|(
name|sc
operator|->
name|chipc_dev
operator|==
name|child
condition|)
block|{
name|sc
operator|->
name|chipc_dev
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|nvram_dev
operator|==
name|child
condition|)
block|{
name|sc
operator|->
name|nvram_dev
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|pmu_dev
operator|==
name|child
condition|)
block|{
name|sc
operator|->
name|pmu_dev
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BUS_SUSPEND_CHILD().  *  * TODO: Power management  *   * If @p child is not a direct child of @p dev, suspension is delegated to  * the @p dev parent.  */
end_comment

begin_function
name|int
name|bhnd_generic_suspend_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
name|BUS_SUSPEND_CHILD
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
name|bus_generic_suspend_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BUS_RESUME_CHILD().  *  * TODO: Power management  *   * If @p child is not a direct child of @p dev, suspension is delegated to  * the @p dev parent.  */
end_comment

begin_function
name|int
name|bhnd_generic_resume_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
name|BUS_RESUME_CHILD
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
name|bus_generic_resume_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delegate all indirect I/O to the parent device. When inherited by  * non-bridged bus implementations, resources will never be marked as  * indirect, and these methods will never be called.  */
end_comment

begin_define
define|#
directive|define
name|BHND_IO_READ
parameter_list|(
name|_type
parameter_list|,
name|_name
parameter_list|,
name|_method
parameter_list|)
define|\
value|static _type								\ bhnd_read_ ## _name (device_t dev, device_t child,			\     struct bhnd_resource *r, bus_size_t offset)				\ {									\ 	return (BHND_BUS_READ_ ## _method(				\ 		    device_get_parent(dev), child, r, offset));		\ }
end_define

begin_define
define|#
directive|define
name|BHND_IO_WRITE
parameter_list|(
name|_type
parameter_list|,
name|_name
parameter_list|,
name|_method
parameter_list|)
define|\
value|static void								\ bhnd_write_ ## _name (device_t dev, device_t child,			\     struct bhnd_resource *r, bus_size_t offset, _type value)		\ {									\ 	return (BHND_BUS_WRITE_ ## _method(				\ 		    device_get_parent(dev), child, r, offset,		\ 		    value));	\ }
end_define

begin_define
define|#
directive|define
name|BHND_IO_MISC
parameter_list|(
name|_type
parameter_list|,
name|_op
parameter_list|,
name|_method
parameter_list|)
define|\
value|static void								\ bhnd_ ## _op (device_t dev, device_t child,				\     struct bhnd_resource *r, bus_size_t offset, _type datap,		\     bus_size_t count)							\ {									\ 	BHND_BUS_ ## _method(device_get_parent(dev), child, r,		\ 	    offset, datap, count);					\ }
end_define

begin_define
define|#
directive|define
name|BHND_IO_METHODS
parameter_list|(
name|_type
parameter_list|,
name|_size
parameter_list|)
define|\
value|BHND_IO_READ(_type, _size, _size)				\ 	BHND_IO_WRITE(_type, _size, _size)				\ 									\ 	BHND_IO_READ(_type, stream_ ## _size, STREAM_ ## _size)		\ 	BHND_IO_WRITE(_type, stream_ ## _size, STREAM_ ## _size)	\ 									\ 	BHND_IO_MISC(_type*, read_multi_ ## _size,			\ 	    READ_MULTI_ ## _size)					\ 	BHND_IO_MISC(_type*, write_multi_ ## _size,			\ 	    WRITE_MULTI_ ## _size)					\ 									\ 	BHND_IO_MISC(_type*, read_multi_stream_ ## _size,		\ 	   READ_MULTI_STREAM_ ## _size)					\ 	BHND_IO_MISC(_type*, write_multi_stream_ ## _size,		\ 	   WRITE_MULTI_STREAM_ ## _size)				\ 									\ 	BHND_IO_MISC(_type, set_multi_ ## _size, SET_MULTI_ ## _size)	\ 	BHND_IO_MISC(_type, set_region_ ## _size, SET_REGION_ ## _size)	\ 									\ 	BHND_IO_MISC(_type*, read_region_ ## _size,			\ 	    READ_REGION_ ## _size)					\ 	BHND_IO_MISC(_type*, write_region_ ## _size,			\ 	    WRITE_REGION_ ## _size)					\ 									\ 	BHND_IO_MISC(_type*, read_region_stream_ ## _size,		\ 	    READ_REGION_STREAM_ ## _size)				\ 	BHND_IO_MISC(_type*, write_region_stream_ ## _size,		\ 	    WRITE_REGION_STREAM_ ## _size)				\  BHND_IO_METHODS(uint8_t, 1);
end_define

begin_expr_stmt
name|BHND_IO_METHODS
argument_list|(
name|uint16_t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BHND_IO_METHODS
argument_list|(
name|uint32_t
argument_list|,
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|bhnd_barrier
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|bhnd_resource
modifier|*
name|r
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|bus_size_t
name|length
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|BHND_BUS_BARRIER
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|r
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|bhnd_methods
index|[]
init|=
block|{
comment|/* Device interface */
block|\
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|bhnd_generic_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bhnd_generic_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bhnd_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bhnd_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bhnd_generic_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_new_pass
argument_list|,
name|bhnd_new_pass
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_add_child
argument_list|,
name|bhnd_generic_add_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_deleted
argument_list|,
name|bhnd_generic_child_deleted
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_probe_nomatch
argument_list|,
name|bhnd_generic_probe_nomatch
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bhnd_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_pnpinfo_str
argument_list|,
name|bhnd_child_pnpinfo_str
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_location_str
argument_list|,
name|bhnd_child_location_str
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_suspend_child
argument_list|,
name|bhnd_generic_suspend_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_resume_child
argument_list|,
name|bhnd_generic_resume_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_set_resource
argument_list|,
name|bus_generic_rl_set_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource
argument_list|,
name|bus_generic_rl_get_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_delete_resource
argument_list|,
name|bus_generic_rl_delete_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|bus_generic_rl_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_adjust_resource
argument_list|,
name|bus_generic_adjust_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|bus_generic_rl_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bus_generic_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|bus_generic_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|bus_generic_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|bus_generic_teardown_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_config_intr
argument_list|,
name|bus_generic_config_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_bind_intr
argument_list|,
name|bus_generic_bind_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_describe_intr
argument_list|,
name|bus_generic_describe_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_dma_tag
argument_list|,
name|bus_generic_get_dma_tag
argument_list|)
block|,
comment|/* BHND interface */
name|DEVMETHOD
argument_list|(
name|bhnd_bus_get_chipid
argument_list|,
name|bhnd_bus_generic_get_chipid
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_get_probe_order
argument_list|,
name|bhnd_generic_get_probe_order
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_is_region_valid
argument_list|,
name|bhnd_generic_is_region_valid
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_is_hw_disabled
argument_list|,
name|bhnd_bus_generic_is_hw_disabled
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_get_nvram_var
argument_list|,
name|bhnd_generic_get_nvram_var
argument_list|)
block|,
comment|/* BHND interface (bus I/O) */
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_1
argument_list|,
name|bhnd_read_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_2
argument_list|,
name|bhnd_read_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_4
argument_list|,
name|bhnd_read_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_1
argument_list|,
name|bhnd_write_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_2
argument_list|,
name|bhnd_write_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_4
argument_list|,
name|bhnd_write_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_stream_1
argument_list|,
name|bhnd_read_stream_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_stream_2
argument_list|,
name|bhnd_read_stream_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_stream_4
argument_list|,
name|bhnd_read_stream_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_stream_1
argument_list|,
name|bhnd_write_stream_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_stream_2
argument_list|,
name|bhnd_write_stream_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_stream_4
argument_list|,
name|bhnd_write_stream_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_multi_1
argument_list|,
name|bhnd_read_multi_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_multi_2
argument_list|,
name|bhnd_read_multi_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_multi_4
argument_list|,
name|bhnd_read_multi_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_multi_1
argument_list|,
name|bhnd_write_multi_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_multi_2
argument_list|,
name|bhnd_write_multi_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_multi_4
argument_list|,
name|bhnd_write_multi_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_multi_stream_1
argument_list|,
name|bhnd_read_multi_stream_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_multi_stream_2
argument_list|,
name|bhnd_read_multi_stream_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_multi_stream_4
argument_list|,
name|bhnd_read_multi_stream_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_multi_stream_1
argument_list|,
name|bhnd_write_multi_stream_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_multi_stream_2
argument_list|,
name|bhnd_write_multi_stream_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_multi_stream_4
argument_list|,
name|bhnd_write_multi_stream_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_set_multi_1
argument_list|,
name|bhnd_set_multi_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_set_multi_2
argument_list|,
name|bhnd_set_multi_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_set_multi_4
argument_list|,
name|bhnd_set_multi_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_set_region_1
argument_list|,
name|bhnd_set_region_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_set_region_2
argument_list|,
name|bhnd_set_region_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_set_region_4
argument_list|,
name|bhnd_set_region_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_region_1
argument_list|,
name|bhnd_read_region_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_region_2
argument_list|,
name|bhnd_read_region_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_region_4
argument_list|,
name|bhnd_read_region_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_region_1
argument_list|,
name|bhnd_write_region_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_region_2
argument_list|,
name|bhnd_write_region_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_region_4
argument_list|,
name|bhnd_write_region_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_region_stream_1
argument_list|,
name|bhnd_read_region_stream_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_region_stream_2
argument_list|,
name|bhnd_read_region_stream_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_region_stream_4
argument_list|,
name|bhnd_read_region_stream_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_region_stream_1
argument_list|,
name|bhnd_write_region_stream_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_region_stream_2
argument_list|,
name|bhnd_write_region_stream_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_region_stream_4
argument_list|,
name|bhnd_write_region_stream_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_barrier
argument_list|,
name|bhnd_barrier
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|bhnd_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< bhnd bus. */
end_comment

begin_decl_stmt
name|devclass_t
name|bhnd_hostb_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< bhnd bus host bridge. */
end_comment

begin_decl_stmt
name|devclass_t
name|bhnd_nvram_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< bhnd NVRAM device */
end_comment

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|bhnd
argument_list|,
name|bhnd_driver
argument_list|,
name|bhnd_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bhnd_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|bhnd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

