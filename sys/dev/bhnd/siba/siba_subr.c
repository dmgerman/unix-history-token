begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 Landon Fuller<landon@landonf.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhndvar.h>
end_include

begin_include
include|#
directive|include
file|"sibareg.h"
end_include

begin_include
include|#
directive|include
file|"sibavar.h"
end_include

begin_comment
comment|/**  * Map a siba(4) OCP vendor code to its corresponding JEDEC JEP-106 vendor  * code.  *   * @param ocp_vendor An OCP vendor code.  * @return The BHND_MFGID constant corresponding to @p ocp_vendor, or  * BHND_MFGID_INVALID if the OCP vendor is unknown.  */
end_comment

begin_function
name|uint16_t
name|siba_get_bhnd_mfgid
parameter_list|(
name|uint16_t
name|ocp_vendor
parameter_list|)
block|{
switch|switch
condition|(
name|ocp_vendor
condition|)
block|{
case|case
name|OCP_VENDOR_BCM
case|:
return|return
operator|(
name|BHND_MFGID_BCM
operator|)
return|;
default|default:
return|return
operator|(
name|BHND_MFGID_INVALID
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Parse the SIBA_IDH_* fields from the per-core identification  * registers, returning a siba_core_id representation.  *   * @param idhigh The SIBA_R0_IDHIGH register.  * @param idlow The SIBA_R0_IDLOW register.   * @param core_id The core id (index) to include in the result.  * @param unit The unit number to include in the result.  */
end_comment

begin_function
name|struct
name|siba_core_id
name|siba_parse_core_id
parameter_list|(
name|uint32_t
name|idhigh
parameter_list|,
name|uint32_t
name|idlow
parameter_list|,
name|u_int
name|core_idx
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|uint16_t
name|ocp_vendor
decl_stmt|;
name|uint8_t
name|sonics_rev
decl_stmt|;
name|uint8_t
name|num_addrspace
decl_stmt|;
name|uint8_t
name|num_cfg
decl_stmt|;
name|ocp_vendor
operator|=
name|SIBA_REG_GET
argument_list|(
name|idhigh
argument_list|,
name|IDH_VENDOR
argument_list|)
expr_stmt|;
name|sonics_rev
operator|=
name|SIBA_REG_GET
argument_list|(
name|idlow
argument_list|,
name|IDL_SBREV
argument_list|)
expr_stmt|;
name|num_addrspace
operator|=
name|SIBA_REG_GET
argument_list|(
name|idlow
argument_list|,
name|IDL_NRADDR
argument_list|)
operator|+
literal|1
comment|/* + enum block */
expr_stmt|;
comment|/* Determine the number of sonics config register blocks */
name|num_cfg
operator|=
name|SIBA_CFG_NUM_2_2
expr_stmt|;
if|if
condition|(
name|sonics_rev
operator|>=
name|SIBA_IDL_SBREV_2_3
condition|)
name|num_cfg
operator|=
name|SIBA_CFG_NUM_2_3
expr_stmt|;
return|return
operator|(
expr|struct
name|siba_core_id
operator|)
block|{
operator|.
name|core_info
operator|=
block|{
operator|.
name|vendor
operator|=
name|siba_get_bhnd_mfgid
argument_list|(
name|ocp_vendor
argument_list|)
block|,
operator|.
name|device
operator|=
name|SIBA_REG_GET
argument_list|(
name|idhigh
argument_list|,
name|IDH_DEVICE
argument_list|)
block|,
operator|.
name|hwrev
operator|=
name|SIBA_IDH_CORE_REV
argument_list|(
name|idhigh
argument_list|)
block|,
operator|.
name|core_idx
operator|=
name|core_idx
block|,
operator|.
name|unit
operator|=
name|unit
block|}
block|,
operator|.
name|sonics_vendor
operator|=
name|ocp_vendor
block|,
operator|.
name|sonics_rev
operator|=
name|sonics_rev
block|,
operator|.
name|num_addrspace
operator|=
name|num_addrspace
block|,
operator|.
name|num_cfg_blocks
operator|=
name|num_cfg
block|}
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize new port descriptor.  *   * @param port_num Port number.  * @param port_type Port type.  */
end_comment

begin_function
specifier|static
name|void
name|siba_init_port
parameter_list|(
name|struct
name|siba_port
modifier|*
name|port
parameter_list|,
name|bhnd_port_type
name|port_type
parameter_list|,
name|u_int
name|port_num
parameter_list|)
block|{
name|port
operator|->
name|sp_num
operator|=
name|port_num
expr_stmt|;
name|port
operator|->
name|sp_type
operator|=
name|port_type
expr_stmt|;
name|port
operator|->
name|sp_num_addrs
operator|=
literal|0
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|port
operator|->
name|sp_addrs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Deallocate all resources associated with the given port descriptor.  *   * @param port Port descriptor to be deallocated.  */
end_comment

begin_function
specifier|static
name|void
name|siba_release_port
parameter_list|(
name|struct
name|siba_port
modifier|*
name|port
parameter_list|)
block|{
name|struct
name|siba_addrspace
modifier|*
name|as
decl_stmt|,
modifier|*
name|as_next
decl_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|as
argument_list|,
argument|&port->sp_addrs
argument_list|,
argument|sa_link
argument_list|,
argument|as_next
argument_list|)
block|{
name|free
argument_list|(
name|as
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Allocate and initialize new device info structure, copying the  * provided core id.  *   * @param dev The requesting bus device.  * @param core Device core info.  */
end_comment

begin_function
name|struct
name|siba_devinfo
modifier|*
name|siba_alloc_dinfo
parameter_list|(
name|device_t
name|bus
parameter_list|,
specifier|const
name|struct
name|siba_core_id
modifier|*
name|core_id
parameter_list|)
block|{
name|struct
name|siba_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dinfo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|siba_devinfo
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|dinfo
operator|->
name|core_id
operator|=
operator|*
name|core_id
expr_stmt|;
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|dinfo
operator|->
name|cfg
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|dinfo
operator|->
name|cfg
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|dinfo
operator|->
name|cfg_rid
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|siba_init_port
argument_list|(
operator|&
name|dinfo
operator|->
name|device_port
argument_list|,
name|BHND_PORT_DEVICE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|resource_list_init
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|)
expr_stmt|;
return|return
name|dinfo
return|;
block|}
end_function

begin_comment
comment|/**  * Return the @p dinfo port instance for @p type, or NULL.  *   * @param dinfo The siba device info.  * @param type The requested port type.  *   * @retval siba_port If @p port_type and @p port_num are defined on @p dinfo.  * @retval NULL If the requested port is not defined on @p dinfo.  */
end_comment

begin_function
name|struct
name|siba_port
modifier|*
name|siba_dinfo_get_port
parameter_list|(
name|struct
name|siba_devinfo
modifier|*
name|dinfo
parameter_list|,
name|bhnd_port_type
name|port_type
parameter_list|,
name|u_int
name|port_num
parameter_list|)
block|{
comment|/* We only define a single port for any given type. */
if|if
condition|(
name|port_num
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
switch|switch
condition|(
name|port_type
condition|)
block|{
case|case
name|BHND_PORT_DEVICE
case|:
return|return
operator|(
operator|&
name|dinfo
operator|->
name|device_port
operator|)
return|;
case|case
name|BHND_PORT_BRIDGE
case|:
return|return
operator|(
name|NULL
operator|)
return|;
case|case
name|BHND_PORT_AGENT
case|:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Find an address space with @p sid on @p port.  *   * @param port The port to search for a matching address space.  * @param sid The siba-assigned address space ID to search for.  */
end_comment

begin_function
name|struct
name|siba_addrspace
modifier|*
name|siba_find_port_addrspace
parameter_list|(
name|struct
name|siba_port
modifier|*
name|port
parameter_list|,
name|uint8_t
name|sid
parameter_list|)
block|{
name|struct
name|siba_addrspace
modifier|*
name|addrspace
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|addrspace
argument_list|,
argument|&port->sp_addrs
argument_list|,
argument|sa_link
argument_list|)
block|{
if|if
condition|(
name|addrspace
operator|->
name|sa_sid
operator|==
name|sid
condition|)
return|return
operator|(
name|addrspace
operator|)
return|;
block|}
comment|/* not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Append a new address space entry to @p port_num of type @p port_type  * in @p dinfo.  *   * The range will also be registered in @p dinfo resource list.  *   * @param dinfo The device info entry to update.  * @param port_type The port type.  * @param port_num The port number.  * @param region_num The region index number.  * @param sid The siba-assigned core-unique address space identifier.  * @param base The mapping's base address.  * @param size The mapping size.  * @param bus_reserved Number of bytes to reserve in @p size for bus use  * when registering the resource list entry. This is used to reserve bus  * access to the core's SIBA_CFG* register blocks.  *   * @retval 0 success  * @retval non-zero An error occurred appending the entry.  */
end_comment

begin_function
name|int
name|siba_append_dinfo_region
parameter_list|(
name|struct
name|siba_devinfo
modifier|*
name|dinfo
parameter_list|,
name|bhnd_port_type
name|port_type
parameter_list|,
name|u_int
name|port_num
parameter_list|,
name|u_int
name|region_num
parameter_list|,
name|uint8_t
name|sid
parameter_list|,
name|uint32_t
name|base
parameter_list|,
name|uint32_t
name|size
parameter_list|,
name|uint32_t
name|bus_reserved
parameter_list|)
block|{
name|struct
name|siba_addrspace
modifier|*
name|sa
decl_stmt|;
name|struct
name|siba_port
modifier|*
name|port
decl_stmt|;
comment|/* Verify that base + size will not overflow */
if|if
condition|(
name|UINT32_MAX
operator|-
name|size
operator|<
name|base
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
comment|/* Must not be 0-length */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Determine target port */
name|port
operator|=
name|siba_dinfo_get_port
argument_list|(
name|dinfo
argument_list|,
name|port_type
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Allocate new addrspace entry */
name|sa
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sa
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sa
operator|->
name|sa_base
operator|=
name|base
expr_stmt|;
name|sa
operator|->
name|sa_size
operator|=
name|size
expr_stmt|;
name|sa
operator|->
name|sa_sid
operator|=
name|sid
expr_stmt|;
name|sa
operator|->
name|sa_region_num
operator|=
name|region_num
expr_stmt|;
comment|/* Populate the resource list */
name|size
operator|-=
name|bus_reserved
expr_stmt|;
name|sa
operator|->
name|sa_rid
operator|=
name|resource_list_add_next
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|base
argument_list|,
name|base
operator|+
name|size
operator|-
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Append to target port */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|port
operator|->
name|sp_addrs
argument_list|,
name|sa
argument_list|,
name|sa_link
argument_list|)
expr_stmt|;
name|port
operator|->
name|sp_num_addrs
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Deallocate the given device info structure and any associated resources.  *   * @param dev The requesting bus device.  * @param dinfo Device info to be deallocated.  */
end_comment

begin_function
name|void
name|siba_free_dinfo
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|siba_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
name|siba_release_port
argument_list|(
operator|&
name|dinfo
operator|->
name|device_port
argument_list|)
expr_stmt|;
name|resource_list_free
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|)
expr_stmt|;
comment|/* Free all mapped configuration blocks */
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|dinfo
operator|->
name|cfg
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dinfo
operator|->
name|cfg
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|bhnd_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|dinfo
operator|->
name|cfg_rid
index|[
name|i
index|]
argument_list|,
name|dinfo
operator|->
name|cfg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|dinfo
operator|->
name|cfg_rid
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|dinfo
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Return the core-enumeration-relative offset for the @p addrspace  * SIBA_R0_ADMATCH* register.  *   * @param addrspace The address space index.  *   * @retval non-zero success  * @retval 0 the given @p addrspace index is not supported.  */
end_comment

begin_function
name|u_int
name|siba_admatch_offset
parameter_list|(
name|uint8_t
name|addrspace
parameter_list|)
block|{
switch|switch
condition|(
name|addrspace
condition|)
block|{
case|case
literal|0
case|:
return|return
name|SB0_REG_ABS
argument_list|(
name|SIBA_CFG0_ADMATCH0
argument_list|)
return|;
case|case
literal|1
case|:
return|return
name|SB0_REG_ABS
argument_list|(
name|SIBA_CFG0_ADMATCH1
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|SB0_REG_ABS
argument_list|(
name|SIBA_CFG0_ADMATCH2
argument_list|)
return|;
case|case
literal|3
case|:
return|return
name|SB0_REG_ABS
argument_list|(
name|SIBA_CFG0_ADMATCH3
argument_list|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Parse a SIBA_R0_ADMATCH* register.  *   * @param addrspace The address space index.  * @param am The address match register value to be parsed.  * @param[out] addr The parsed address.  * @param[out] size The parsed size.  *   * @retval 0 success  * @retval non-zero a parse error occured.  */
end_comment

begin_function
name|int
name|siba_parse_admatch
parameter_list|(
name|uint32_t
name|am
parameter_list|,
name|uint32_t
modifier|*
name|addr
parameter_list|,
name|uint32_t
modifier|*
name|size
parameter_list|)
block|{
name|u_int
name|am_type
decl_stmt|;
comment|/* Negative encoding is not supported. This is not used on any 	 * currently known devices*/
if|if
condition|(
name|am
operator|&
name|SIBA_AM_ADNEG
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Extract the base address and size */
name|am_type
operator|=
name|SIBA_REG_GET
argument_list|(
name|am
argument_list|,
name|AM_TYPE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|am_type
condition|)
block|{
case|case
literal|0
case|:
operator|*
name|addr
operator|=
name|am
operator|&
name|SIBA_AM_BASE0_MASK
expr_stmt|;
operator|*
name|size
operator|=
literal|1
operator|<<
operator|(
name|SIBA_REG_GET
argument_list|(
name|am
argument_list|,
name|AM_ADINT0
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
operator|*
name|addr
operator|=
name|am
operator|&
name|SIBA_AM_BASE1_MASK
expr_stmt|;
operator|*
name|size
operator|=
literal|1
operator|<<
operator|(
name|SIBA_REG_GET
argument_list|(
name|am
argument_list|,
name|AM_ADINT1
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|addr
operator|=
name|am
operator|&
name|SIBA_AM_BASE2_MASK
expr_stmt|;
operator|*
name|size
operator|=
literal|1
operator|<<
operator|(
name|SIBA_REG_GET
argument_list|(
name|am
argument_list|,
name|AM_ADINT2
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

