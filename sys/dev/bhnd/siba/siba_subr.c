begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 Landon Fuller<landon@landonf.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhndvar.h>
end_include

begin_include
include|#
directive|include
file|"sibareg.h"
end_include

begin_include
include|#
directive|include
file|"sibavar.h"
end_include

begin_comment
comment|/**  * Map a siba(4) OCP vendor code to its corresponding JEDEC JEP-106 vendor  * code.  *   * @param ocp_vendor An OCP vendor code.  * @return The BHND_MFGID constant corresponding to @p ocp_vendor, or  * BHND_MFGID_INVALID if the OCP vendor is unknown.  */
end_comment

begin_function
name|uint16_t
name|siba_get_bhnd_mfgid
parameter_list|(
name|uint16_t
name|ocp_vendor
parameter_list|)
block|{
switch|switch
condition|(
name|ocp_vendor
condition|)
block|{
case|case
name|OCP_VENDOR_BCM
case|:
return|return
operator|(
name|BHND_MFGID_BCM
operator|)
return|;
default|default:
return|return
operator|(
name|BHND_MFGID_INVALID
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Parse the SIBA_IDH_* fields from the per-core identification  * registers, returning a siba_core_id representation.  *   * @param idhigh The SIBA_R0_IDHIGH register.  * @param idlow The SIBA_R0_IDLOW register.   * @param core_id The core id (index) to include in the result.  * @param unit The unit number to include in the result.  */
end_comment

begin_function
name|struct
name|siba_core_id
name|siba_parse_core_id
parameter_list|(
name|uint32_t
name|idhigh
parameter_list|,
name|uint32_t
name|idlow
parameter_list|,
name|u_int
name|core_idx
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|uint16_t
name|ocp_vendor
decl_stmt|;
name|uint8_t
name|sonics_rev
decl_stmt|;
name|uint8_t
name|num_addrspace
decl_stmt|;
name|uint8_t
name|num_cfg
decl_stmt|;
name|ocp_vendor
operator|=
name|SIBA_REG_GET
argument_list|(
name|idhigh
argument_list|,
name|IDH_VENDOR
argument_list|)
expr_stmt|;
name|sonics_rev
operator|=
name|SIBA_REG_GET
argument_list|(
name|idlow
argument_list|,
name|IDL_SBREV
argument_list|)
expr_stmt|;
name|num_addrspace
operator|=
name|SIBA_REG_GET
argument_list|(
name|idlow
argument_list|,
name|IDL_NRADDR
argument_list|)
operator|+
literal|1
comment|/* + enum block */
expr_stmt|;
comment|/* Determine the number of sonics config register blocks */
name|num_cfg
operator|=
name|SIBA_CFG_NUM_2_2
expr_stmt|;
if|if
condition|(
name|sonics_rev
operator|>=
name|SIBA_IDL_SBREV_2_3
condition|)
name|num_cfg
operator|=
name|SIBA_CFG_NUM_2_3
expr_stmt|;
return|return
operator|(
expr|struct
name|siba_core_id
operator|)
block|{
operator|.
name|core_info
operator|=
block|{
operator|.
name|vendor
operator|=
name|siba_get_bhnd_mfgid
argument_list|(
name|ocp_vendor
argument_list|)
block|,
operator|.
name|device
operator|=
name|SIBA_REG_GET
argument_list|(
name|idhigh
argument_list|,
name|IDH_DEVICE
argument_list|)
block|,
operator|.
name|hwrev
operator|=
name|SIBA_IDH_CORE_REV
argument_list|(
name|idhigh
argument_list|)
block|,
operator|.
name|core_idx
operator|=
name|core_idx
block|,
operator|.
name|unit
operator|=
name|unit
block|}
block|,
operator|.
name|sonics_vendor
operator|=
name|ocp_vendor
block|,
operator|.
name|sonics_rev
operator|=
name|sonics_rev
block|,
operator|.
name|num_addrspace
operator|=
name|num_addrspace
block|,
operator|.
name|num_cfg_blocks
operator|=
name|num_cfg
block|}
return|;
block|}
end_function

begin_comment
comment|/**  * Allocate and return a new empty device info structure.  *   * @param bus The requesting bus device.  *   * @retval NULL if allocation failed.  */
end_comment

begin_function
name|struct
name|siba_devinfo
modifier|*
name|siba_alloc_dinfo
parameter_list|(
name|device_t
name|bus
parameter_list|)
block|{
name|struct
name|siba_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dinfo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|siba_devinfo
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|dinfo
operator|->
name|cfg
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|dinfo
operator|->
name|cfg
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|dinfo
operator|->
name|cfg_rid
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|resource_list_init
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|)
expr_stmt|;
return|return
name|dinfo
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize a device info structure previously allocated via  * siba_alloc_dinfo, copying the provided core id.  *   * @param dev The requesting bus device.  * @param dinfo The device info instance.  * @param core Device core info.  *   * @retval 0 success  * @retval non-zero initialization failed.  */
end_comment

begin_function
name|int
name|siba_init_dinfo
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|siba_devinfo
modifier|*
name|dinfo
parameter_list|,
specifier|const
name|struct
name|siba_core_id
modifier|*
name|core_id
parameter_list|)
block|{
name|dinfo
operator|->
name|core_id
operator|=
operator|*
name|core_id
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Map an addrspace index to its corresponding bhnd(4) port number.  *   * @param addrspace Address space index.  */
end_comment

begin_function
name|u_int
name|siba_addrspace_port
parameter_list|(
name|u_int
name|addrspace
parameter_list|)
block|{
comment|/* The first addrspace is always mapped to device0; the remainder 	 * are mapped to device1 */
if|if
condition|(
name|addrspace
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Map an addrspace index to its corresponding bhnd(4) region number.  *   * @param addrspace Address space index.  */
end_comment

begin_function
name|u_int
name|siba_addrspace_region
parameter_list|(
name|u_int
name|addrspace
parameter_list|)
block|{
comment|/* The first addrspace is always mapped to device0.0; the remainder 	 * are mapped to device1.0 + (n - 1) */
if|if
condition|(
name|addrspace
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|addrspace
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the number of bhnd(4) ports to advertise for the given  * @p num_addrspace.  *   * @param num_addrspace The number of siba address spaces.  */
end_comment

begin_function
name|u_int
name|siba_addrspace_port_count
parameter_list|(
name|u_int
name|num_addrspace
parameter_list|)
block|{
comment|/* 0, 1, or 2 ports */
return|return
name|min
argument_list|(
name|num_addrspace
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the number of bhnd(4) regions to advertise on @p port  * given the provided @p num_addrspace address space count.  *   * @param num_addrspace The number of core-mapped siba(4) Sonics/OCP address  * spaces.  */
end_comment

begin_function
name|u_int
name|siba_addrspace_region_count
parameter_list|(
name|u_int
name|num_addrspace
parameter_list|,
name|u_int
name|port
parameter_list|)
block|{
comment|/* The first address space, if any, is mapped to device0.0 */
if|if
condition|(
name|port
operator|==
literal|0
condition|)
return|return
operator|(
name|min
argument_list|(
name|num_addrspace
argument_list|,
literal|1
argument_list|)
operator|)
return|;
comment|/* All remaining address spaces are mapped to device0.(n - 1) */
if|if
condition|(
name|port
operator|==
literal|1
operator|&&
name|num_addrspace
operator|>=
literal|2
condition|)
return|return
operator|(
name|num_addrspace
operator|-
literal|1
operator|)
return|;
comment|/* No region mapping */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if @p port is defined given an address space count  * of @p num_addrspace, false otherwise.  *  * Refer to the siba_find_addrspace() function for information on siba's  * mapping of bhnd(4) port and region identifiers.  *   * @param num_addrspace The number of address spaces to verify the port against.  * @param type The bhnd(4) port type.  * @param port The bhnd(4) port number.  */
end_comment

begin_function
name|bool
name|siba_is_port_valid
parameter_list|(
name|u_int
name|num_addrspace
parameter_list|,
name|bhnd_port_type
name|type
parameter_list|,
name|u_int
name|port
parameter_list|)
block|{
comment|/* Only device ports are supported */
if|if
condition|(
name|type
operator|!=
name|BHND_PORT_DEVICE
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Verify the index against the port count */
if|if
condition|(
name|siba_addrspace_port_count
argument_list|(
name|num_addrspace
argument_list|)
operator|<=
name|port
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Map a bhnd(4) type/port/region triplet to its associated address space  * index, if any.  *   * For compatibility with bcma(4), we map address spaces to port/region  * identifiers as follows:  *   * 	[port]		[addrspace]  * 	device0.0	0  * 	device1.0	1  * 	device1.1	2  * 	device1.2	3  *   * The only supported port type is BHND_PORT_DEVICE.  *   * @param num_addrspace The number of available siba address spaces.  * @param type The bhnd(4) port type.  * @param port The bhnd(4) port number.  * @param region The bhnd(4) port region.  * @param addridx On success, the corresponding addrspace index.  *   * @retval 0 success  * @retval ENOENT if the given type/port/region cannot be mapped to a  * siba address space.  */
end_comment

begin_function
name|int
name|siba_addrspace_index
parameter_list|(
name|u_int
name|num_addrspace
parameter_list|,
name|bhnd_port_type
name|type
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|region
parameter_list|,
name|u_int
modifier|*
name|addridx
parameter_list|)
block|{
name|u_int
name|idx
decl_stmt|;
if|if
condition|(
operator|!
name|siba_is_port_valid
argument_list|(
name|num_addrspace
argument_list|,
name|type
argument_list|,
name|port
argument_list|)
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|port
operator|==
literal|0
condition|)
name|idx
operator|=
name|region
expr_stmt|;
elseif|else
if|if
condition|(
name|port
operator|==
literal|1
condition|)
name|idx
operator|=
name|region
operator|+
literal|1
expr_stmt|;
else|else
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|idx
operator|>=
name|num_addrspace
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Found */
operator|*
name|addridx
operator|=
name|idx
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Map an bhnd(4) type/port/region triplet to its associated address space  * entry, if any.  *  * The only supported port type is BHND_PORT_DEVICE.  *   * @param dinfo The device info to search for a matching address space.  * @param type The bhnd(4) port type.  * @param port The bhnd(4) port number.  * @param region The bhnd(4) port region.  */
end_comment

begin_function
name|struct
name|siba_addrspace
modifier|*
name|siba_find_addrspace
parameter_list|(
name|struct
name|siba_devinfo
modifier|*
name|dinfo
parameter_list|,
name|bhnd_port_type
name|type
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|region
parameter_list|)
block|{
name|u_int
name|addridx
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Map to addrspace index */
name|error
operator|=
name|siba_addrspace_index
argument_list|(
name|dinfo
operator|->
name|core_id
operator|.
name|num_addrspace
argument_list|,
name|type
argument_list|,
name|port
argument_list|,
name|region
argument_list|,
operator|&
name|addridx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Found */
if|if
condition|(
name|addridx
operator|>=
name|SIBA_MAX_ADDRSPACE
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|dinfo
operator|->
name|addrspace
index|[
name|addridx
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Append an address space entry to @p dinfo.  *   * @param dinfo The device info entry to update.  * @param addridx The address space index.  * @param base The mapping's base address.  * @param size The mapping size.  * @param bus_reserved Number of bytes to reserve in @p size for bus use  * when registering the resource list entry. This is used to reserve bus  * access to the core's SIBA_CFG* register blocks.  *   * @retval 0 success  * @retval non-zero An error occurred appending the entry.  */
end_comment

begin_function
name|int
name|siba_append_dinfo_region
parameter_list|(
name|struct
name|siba_devinfo
modifier|*
name|dinfo
parameter_list|,
name|uint8_t
name|addridx
parameter_list|,
name|uint32_t
name|base
parameter_list|,
name|uint32_t
name|size
parameter_list|,
name|uint32_t
name|bus_reserved
parameter_list|)
block|{
name|struct
name|siba_addrspace
modifier|*
name|sa
decl_stmt|;
name|rman_res_t
name|r_size
decl_stmt|;
comment|/* Verify that base + size will not overflow */
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|UINT32_MAX
operator|-
operator|(
name|size
operator|-
literal|1
operator|)
operator|<
name|base
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
comment|/* Verify that size - bus_reserved will not underflow */
if|if
condition|(
name|size
operator|<
name|bus_reserved
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
comment|/* Must not be 0-length */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Must not exceed addrspace array size */
if|if
condition|(
name|addridx
operator|>=
name|nitems
argument_list|(
name|dinfo
operator|->
name|addrspace
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Initialize new addrspace entry */
name|sa
operator|=
operator|&
name|dinfo
operator|->
name|addrspace
index|[
name|addridx
index|]
expr_stmt|;
name|sa
operator|->
name|sa_base
operator|=
name|base
expr_stmt|;
name|sa
operator|->
name|sa_size
operator|=
name|size
expr_stmt|;
name|sa
operator|->
name|sa_bus_reserved
operator|=
name|bus_reserved
expr_stmt|;
comment|/* Populate the resource list */
name|r_size
operator|=
name|size
operator|-
name|bus_reserved
expr_stmt|;
name|sa
operator|->
name|sa_rid
operator|=
name|resource_list_add_next
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|base
argument_list|,
name|base
operator|+
operator|(
name|r_size
operator|-
literal|1
operator|)
argument_list|,
name|r_size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Deallocate the given device info structure and any associated resources.  *   * @param dev The requesting bus device.  * @param dinfo Device info to be deallocated.  */
end_comment

begin_function
name|void
name|siba_free_dinfo
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|siba_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
name|resource_list_free
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|)
expr_stmt|;
comment|/* Free all mapped configuration blocks */
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|dinfo
operator|->
name|cfg
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dinfo
operator|->
name|cfg
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|bhnd_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|dinfo
operator|->
name|cfg_rid
index|[
name|i
index|]
argument_list|,
name|dinfo
operator|->
name|cfg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|dinfo
operator|->
name|cfg_rid
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|dinfo
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Return the core-enumeration-relative offset for the @p addrspace  * SIBA_R0_ADMATCH* register.  *   * @param addrspace The address space index.  *   * @retval non-zero success  * @retval 0 the given @p addrspace index is not supported.  */
end_comment

begin_function
name|u_int
name|siba_admatch_offset
parameter_list|(
name|uint8_t
name|addrspace
parameter_list|)
block|{
switch|switch
condition|(
name|addrspace
condition|)
block|{
case|case
literal|0
case|:
return|return
name|SB0_REG_ABS
argument_list|(
name|SIBA_CFG0_ADMATCH0
argument_list|)
return|;
case|case
literal|1
case|:
return|return
name|SB0_REG_ABS
argument_list|(
name|SIBA_CFG0_ADMATCH1
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|SB0_REG_ABS
argument_list|(
name|SIBA_CFG0_ADMATCH2
argument_list|)
return|;
case|case
literal|3
case|:
return|return
name|SB0_REG_ABS
argument_list|(
name|SIBA_CFG0_ADMATCH3
argument_list|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Parse a SIBA_R0_ADMATCH* register.  *   * @param addrspace The address space index.  * @param am The address match register value to be parsed.  * @param[out] addr The parsed address.  * @param[out] size The parsed size.  *   * @retval 0 success  * @retval non-zero a parse error occurred.  */
end_comment

begin_function
name|int
name|siba_parse_admatch
parameter_list|(
name|uint32_t
name|am
parameter_list|,
name|uint32_t
modifier|*
name|addr
parameter_list|,
name|uint32_t
modifier|*
name|size
parameter_list|)
block|{
name|u_int
name|am_type
decl_stmt|;
comment|/* Negative encoding is not supported. This is not used on any 	 * currently known devices*/
if|if
condition|(
name|am
operator|&
name|SIBA_AM_ADNEG
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Extract the base address and size */
name|am_type
operator|=
name|SIBA_REG_GET
argument_list|(
name|am
argument_list|,
name|AM_TYPE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|am_type
condition|)
block|{
case|case
literal|0
case|:
operator|*
name|addr
operator|=
name|am
operator|&
name|SIBA_AM_BASE0_MASK
expr_stmt|;
operator|*
name|size
operator|=
literal|1
operator|<<
operator|(
name|SIBA_REG_GET
argument_list|(
name|am
argument_list|,
name|AM_ADINT0
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
operator|*
name|addr
operator|=
name|am
operator|&
name|SIBA_AM_BASE1_MASK
expr_stmt|;
operator|*
name|size
operator|=
literal|1
operator|<<
operator|(
name|SIBA_REG_GET
argument_list|(
name|am
argument_list|,
name|AM_ADINT1
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|addr
operator|=
name|am
operator|&
name|SIBA_AM_BASE2_MASK
expr_stmt|;
operator|*
name|size
operator|=
literal|1
operator|<<
operator|(
name|SIBA_REG_GET
argument_list|(
name|am
argument_list|,
name|AM_ADINT2
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

