begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Landon Fuller<landon@landonf.org>  * Copyright (c) 2017 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by Landon Fuller  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhndvar.h>
end_include

begin_include
include|#
directive|include
file|"sibareg.h"
end_include

begin_include
include|#
directive|include
file|"sibavar.h"
end_include

begin_comment
comment|/**  * Map a siba(4) OCP vendor code to its corresponding JEDEC JEP-106 vendor  * code.  *   * @param ocp_vendor An OCP vendor code.  * @return The BHND_MFGID constant corresponding to @p ocp_vendor, or  * BHND_MFGID_INVALID if the OCP vendor is unknown.  */
end_comment

begin_function
name|uint16_t
name|siba_get_bhnd_mfgid
parameter_list|(
name|uint16_t
name|ocp_vendor
parameter_list|)
block|{
switch|switch
condition|(
name|ocp_vendor
condition|)
block|{
case|case
name|OCP_VENDOR_BCM
case|:
return|return
operator|(
name|BHND_MFGID_BCM
operator|)
return|;
default|default:
return|return
operator|(
name|BHND_MFGID_INVALID
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Parse the SIBA_IDH_* fields from the per-core identification  * registers, returning a siba_core_id representation.  *   * @param idhigh The SIBA_R0_IDHIGH register.  * @param idlow The SIBA_R0_IDLOW register.   * @param core_id The core id (index) to include in the result.  * @param unit The unit number to include in the result.  */
end_comment

begin_function
name|struct
name|siba_core_id
name|siba_parse_core_id
parameter_list|(
name|uint32_t
name|idhigh
parameter_list|,
name|uint32_t
name|idlow
parameter_list|,
name|u_int
name|core_idx
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|uint16_t
name|ocp_vendor
decl_stmt|;
name|uint8_t
name|sonics_rev
decl_stmt|;
name|uint8_t
name|num_addrspace
decl_stmt|;
name|uint8_t
name|num_cfg
decl_stmt|;
name|ocp_vendor
operator|=
name|SIBA_REG_GET
argument_list|(
name|idhigh
argument_list|,
name|IDH_VENDOR
argument_list|)
expr_stmt|;
name|sonics_rev
operator|=
name|SIBA_REG_GET
argument_list|(
name|idlow
argument_list|,
name|IDL_SBREV
argument_list|)
expr_stmt|;
name|num_addrspace
operator|=
name|SIBA_REG_GET
argument_list|(
name|idlow
argument_list|,
name|IDL_NRADDR
argument_list|)
operator|+
literal|1
comment|/* + enum block */
expr_stmt|;
comment|/* Determine the number of sonics config register blocks */
name|num_cfg
operator|=
name|SIBA_CFG_NUM_2_2
expr_stmt|;
if|if
condition|(
name|sonics_rev
operator|>=
name|SIBA_IDL_SBREV_2_3
condition|)
name|num_cfg
operator|=
name|SIBA_CFG_NUM_2_3
expr_stmt|;
return|return
operator|(
expr|struct
name|siba_core_id
operator|)
block|{
operator|.
name|core_info
operator|=
block|{
operator|.
name|vendor
operator|=
name|siba_get_bhnd_mfgid
argument_list|(
name|ocp_vendor
argument_list|)
block|,
operator|.
name|device
operator|=
name|SIBA_REG_GET
argument_list|(
name|idhigh
argument_list|,
name|IDH_DEVICE
argument_list|)
block|,
operator|.
name|hwrev
operator|=
name|SIBA_IDH_CORE_REV
argument_list|(
name|idhigh
argument_list|)
block|,
operator|.
name|core_idx
operator|=
name|core_idx
block|,
operator|.
name|unit
operator|=
name|unit
block|}
block|,
operator|.
name|sonics_vendor
operator|=
name|ocp_vendor
block|,
operator|.
name|sonics_rev
operator|=
name|sonics_rev
block|,
operator|.
name|num_addrspace
operator|=
name|num_addrspace
block|,
operator|.
name|num_cfg_blocks
operator|=
name|num_cfg
block|}
return|;
block|}
end_function

begin_comment
comment|/**  * Allocate and return a new empty device info structure.  *   * @param bus The requesting bus device.  *   * @retval NULL if allocation failed.  */
end_comment

begin_function
name|struct
name|siba_devinfo
modifier|*
name|siba_alloc_dinfo
parameter_list|(
name|device_t
name|bus
parameter_list|)
block|{
name|struct
name|siba_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dinfo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|siba_devinfo
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|dinfo
operator|->
name|cfg
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|dinfo
operator|->
name|cfg
index|[
name|i
index|]
operator|=
operator|(
operator|(
expr|struct
name|siba_cfg_block
operator|)
block|{
operator|.
name|cb_base
operator|=
literal|0
block|,
operator|.
name|cb_size
operator|=
literal|0
block|,
operator|.
name|cb_rid
operator|=
operator|-
literal|1
block|, 		}
operator|)
expr_stmt|;
name|dinfo
operator|->
name|cfg_res
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|dinfo
operator|->
name|cfg_rid
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|resource_list_init
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|intr_en
operator|=
name|false
expr_stmt|;
return|return
name|dinfo
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize a device info structure previously allocated via  * siba_alloc_dinfo, copying the provided core id.  *   * @param dev The requesting bus device.  * @param dinfo The device info instance.  * @param core Device core info.  *   * @retval 0 success  * @retval non-zero initialization failed.  */
end_comment

begin_function
name|int
name|siba_init_dinfo
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|siba_devinfo
modifier|*
name|dinfo
parameter_list|,
specifier|const
name|struct
name|siba_core_id
modifier|*
name|core_id
parameter_list|)
block|{
name|dinfo
operator|->
name|core_id
operator|=
operator|*
name|core_id
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Map an addrspace index to its corresponding bhnd(4) BHND_PORT_DEVICE port  * number.  *   * @param addrspace Address space index.  */
end_comment

begin_function
name|u_int
name|siba_addrspace_device_port
parameter_list|(
name|u_int
name|addrspace
parameter_list|)
block|{
comment|/* The first addrspace is always mapped to device0; the remainder 	 * are mapped to device1 */
if|if
condition|(
name|addrspace
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Map an addrspace index to its corresponding bhnd(4) BHND_PORT_DEVICE port  * region number.  *   * @param addrspace Address space index.  */
end_comment

begin_function
name|u_int
name|siba_addrspace_device_region
parameter_list|(
name|u_int
name|addrspace
parameter_list|)
block|{
comment|/* The first addrspace is always mapped to device0.0; the remainder 	 * are mapped to device1.0 + (n - 1) */
if|if
condition|(
name|addrspace
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|addrspace
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Map an config block index to its corresponding bhnd(4) BHND_PORT_AGENT port  * number.  *   * @param cfg Config block index.  */
end_comment

begin_function
name|u_int
name|siba_cfg_agent_port
parameter_list|(
name|u_int
name|cfg
parameter_list|)
block|{
comment|/* Always agent0 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Map an config block index to its corresponding bhnd(4) BHND_PORT_AGENT port  * region number.  *   * @param cfg Config block index.  */
end_comment

begin_function
name|u_int
name|siba_cfg_agent_region
parameter_list|(
name|u_int
name|cfg
parameter_list|)
block|{
comment|/* Always agent0.<idx> */
return|return
operator|(
name|cfg
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the number of bhnd(4) ports to advertise for the given  * @p core_id and @p port_type.  *   * Refer to the siba_addrspace_index() and siba_cfg_index() functions for  * information on siba's mapping of bhnd(4) port and region identifiers.  *   * @param core_id The siba core info.  * @param port_type The bhnd(4) port type.  */
end_comment

begin_function
name|u_int
name|siba_port_count
parameter_list|(
name|struct
name|siba_core_id
modifier|*
name|core_id
parameter_list|,
name|bhnd_port_type
name|port_type
parameter_list|)
block|{
switch|switch
condition|(
name|port_type
condition|)
block|{
case|case
name|BHND_PORT_DEVICE
case|:
comment|/* 0, 1, or 2 ports */
return|return
operator|(
name|min
argument_list|(
name|core_id
operator|->
name|num_addrspace
argument_list|,
literal|2
argument_list|)
operator|)
return|;
case|case
name|BHND_PORT_AGENT
case|:
comment|/* One agent port maps all configuration blocks */
if|if
condition|(
name|core_id
operator|->
name|num_cfg_blocks
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Do not advertise an agent port if there are no configuration 		 * register blocks */
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Return true if @p port of @p port_type is defined by @p core_id, false  * otherwise.  *   * @param core_id The siba core info.  * @param port_type The bhnd(4) port type.  * @param port The bhnd(4) port number.  */
end_comment

begin_function
name|bool
name|siba_is_port_valid
parameter_list|(
name|struct
name|siba_core_id
modifier|*
name|core_id
parameter_list|,
name|bhnd_port_type
name|port_type
parameter_list|,
name|u_int
name|port
parameter_list|)
block|{
comment|/* Verify the index against the port count */
if|if
condition|(
name|siba_port_count
argument_list|(
name|core_id
argument_list|,
name|port_type
argument_list|)
operator|<=
name|port
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the number of bhnd(4) regions to advertise for @p core_id on the  * @p port of @p port_type.  *   * @param core_id The siba core info.  * @param port_type The bhnd(4) port type.  */
end_comment

begin_function
name|u_int
name|siba_port_region_count
parameter_list|(
name|struct
name|siba_core_id
modifier|*
name|core_id
parameter_list|,
name|bhnd_port_type
name|port_type
parameter_list|,
name|u_int
name|port
parameter_list|)
block|{
comment|/* The port must exist */
if|if
condition|(
operator|!
name|siba_is_port_valid
argument_list|(
name|core_id
argument_list|,
name|port_type
argument_list|,
name|port
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|port_type
condition|)
block|{
case|case
name|BHND_PORT_DEVICE
case|:
comment|/* The first address space, if any, is mapped to device0.0 */
if|if
condition|(
name|port
operator|==
literal|0
condition|)
return|return
operator|(
name|min
argument_list|(
name|core_id
operator|->
name|num_addrspace
argument_list|,
literal|1
argument_list|)
operator|)
return|;
comment|/* All remaining address spaces are mapped to device0.(n - 1) */
if|if
condition|(
name|port
operator|==
literal|1
operator|&&
name|core_id
operator|->
name|num_addrspace
operator|>=
literal|2
condition|)
return|return
operator|(
name|core_id
operator|->
name|num_addrspace
operator|-
literal|1
operator|)
return|;
break|break;
case|case
name|BHND_PORT_AGENT
case|:
comment|/* All config blocks are mapped to a single port */
if|if
condition|(
name|port
operator|==
literal|0
condition|)
return|return
operator|(
name|core_id
operator|->
name|num_cfg_blocks
operator|)
return|;
break|break;
default|default:
break|break;
block|}
comment|/* Validated above */
name|panic
argument_list|(
literal|"siba_is_port_valid() returned true for unknown %s.%u port"
argument_list|,
name|bhnd_port_type_name
argument_list|(
name|port_type
argument_list|)
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Map a bhnd(4) type/port/region triplet to its associated config block index,  * if any.  *   * We map config registers to port/region identifiers as follows:  *   * 	[port].[region]	[cfg register block]  * 	agent0.0	0  * 	agent0.1	1  *   * @param num_addrspace The number of available siba address spaces.  * @param port_type The bhnd(4) port type.  * @param port The bhnd(4) port number.  * @param region The bhnd(4) port region.  * @param addridx On success, the corresponding addrspace index.  *   * @retval 0 success  * @retval ENOENT if the given type/port/region cannot be mapped to a  * siba config register block.  */
end_comment

begin_function
name|int
name|siba_cfg_index
parameter_list|(
name|struct
name|siba_core_id
modifier|*
name|core_id
parameter_list|,
name|bhnd_port_type
name|port_type
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|region
parameter_list|,
name|u_int
modifier|*
name|cfgidx
parameter_list|)
block|{
comment|/* Config blocks are mapped to agent ports */
if|if
condition|(
name|port_type
operator|!=
name|BHND_PORT_AGENT
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Port must be valid */
if|if
condition|(
operator|!
name|siba_is_port_valid
argument_list|(
name|core_id
argument_list|,
name|port_type
argument_list|,
name|port
argument_list|)
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|region
operator|>=
name|core_id
operator|->
name|num_cfg_blocks
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|region
operator|>=
name|SIBA_MAX_CFG
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Found */
operator|*
name|cfgidx
operator|=
name|region
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Map an bhnd(4) type/port/region triplet to its associated config block  * entry, if any.  *  * The only supported port type is BHND_PORT_DEVICE.  *   * @param dinfo The device info to search for a matching address space.  * @param type The bhnd(4) port type.  * @param port The bhnd(4) port number.  * @param region The bhnd(4) port region.  */
end_comment

begin_function
name|struct
name|siba_cfg_block
modifier|*
name|siba_find_cfg_block
parameter_list|(
name|struct
name|siba_devinfo
modifier|*
name|dinfo
parameter_list|,
name|bhnd_port_type
name|type
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|region
parameter_list|)
block|{
name|u_int
name|cfgidx
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Map to addrspace index */
name|error
operator|=
name|siba_cfg_index
argument_list|(
operator|&
name|dinfo
operator|->
name|core_id
argument_list|,
name|type
argument_list|,
name|port
argument_list|,
name|region
argument_list|,
operator|&
name|cfgidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Found */
return|return
operator|(
operator|&
name|dinfo
operator|->
name|cfg
index|[
name|cfgidx
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Map a bhnd(4) type/port/region triplet to its associated address space  * index, if any.  *   * For compatibility with bcma(4), we map address spaces to port/region  * identifiers as follows:  *   * 	[port]		[addrspace]  * 	device0.0	0  * 	device1.0	1  * 	device1.1	2  * 	device1.2	3  *   * @param core_id The siba core info.  * @param port_type The bhnd(4) port type.  * @param port The bhnd(4) port number.  * @param region The bhnd(4) port region.  * @param addridx On success, the corresponding addrspace index.  *   * @retval 0 success  * @retval ENOENT if the given type/port/region cannot be mapped to a  * siba address space.  */
end_comment

begin_function
name|int
name|siba_addrspace_index
parameter_list|(
name|struct
name|siba_core_id
modifier|*
name|core_id
parameter_list|,
name|bhnd_port_type
name|port_type
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|region
parameter_list|,
name|u_int
modifier|*
name|addridx
parameter_list|)
block|{
name|u_int
name|idx
decl_stmt|;
comment|/* Address spaces are always device ports */
if|if
condition|(
name|port_type
operator|!=
name|BHND_PORT_DEVICE
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Port must be valid */
if|if
condition|(
operator|!
name|siba_is_port_valid
argument_list|(
name|core_id
argument_list|,
name|port_type
argument_list|,
name|port
argument_list|)
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|port
operator|==
literal|0
condition|)
name|idx
operator|=
name|region
expr_stmt|;
elseif|else
if|if
condition|(
name|port
operator|==
literal|1
condition|)
name|idx
operator|=
name|region
operator|+
literal|1
expr_stmt|;
else|else
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|idx
operator|>=
name|core_id
operator|->
name|num_addrspace
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Found */
operator|*
name|addridx
operator|=
name|idx
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Map an bhnd(4) type/port/region triplet to its associated address space  * entry, if any.  *  * The only supported port type is BHND_PORT_DEVICE.  *   * @param dinfo The device info to search for a matching address space.  * @param type The bhnd(4) port type.  * @param port The bhnd(4) port number.  * @param region The bhnd(4) port region.  */
end_comment

begin_function
name|struct
name|siba_addrspace
modifier|*
name|siba_find_addrspace
parameter_list|(
name|struct
name|siba_devinfo
modifier|*
name|dinfo
parameter_list|,
name|bhnd_port_type
name|type
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|region
parameter_list|)
block|{
name|u_int
name|addridx
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Map to addrspace index */
name|error
operator|=
name|siba_addrspace_index
argument_list|(
operator|&
name|dinfo
operator|->
name|core_id
argument_list|,
name|type
argument_list|,
name|port
argument_list|,
name|region
argument_list|,
operator|&
name|addridx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Found */
if|if
condition|(
name|addridx
operator|>=
name|SIBA_MAX_ADDRSPACE
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|dinfo
operator|->
name|addrspace
index|[
name|addridx
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Append an address space entry to @p dinfo.  *   * @param dinfo The device info entry to update.  * @param addridx The address space index.  * @param base The mapping's base address.  * @param size The mapping size.  * @param bus_reserved Number of bytes to reserve in @p size for bus use  * when registering the resource list entry. This is used to reserve bus  * access to the core's SIBA_CFG* register blocks.  *   * @retval 0 success  * @retval non-zero An error occurred appending the entry.  */
end_comment

begin_function
name|int
name|siba_append_dinfo_region
parameter_list|(
name|struct
name|siba_devinfo
modifier|*
name|dinfo
parameter_list|,
name|uint8_t
name|addridx
parameter_list|,
name|uint32_t
name|base
parameter_list|,
name|uint32_t
name|size
parameter_list|,
name|uint32_t
name|bus_reserved
parameter_list|)
block|{
name|struct
name|siba_addrspace
modifier|*
name|sa
decl_stmt|;
name|rman_res_t
name|r_size
decl_stmt|;
comment|/* Verify that base + size will not overflow */
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|UINT32_MAX
operator|-
operator|(
name|size
operator|-
literal|1
operator|)
operator|<
name|base
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
comment|/* Verify that size - bus_reserved will not underflow */
if|if
condition|(
name|size
operator|<
name|bus_reserved
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
comment|/* Must not be 0-length */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Must not exceed addrspace array size */
if|if
condition|(
name|addridx
operator|>=
name|nitems
argument_list|(
name|dinfo
operator|->
name|addrspace
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Initialize new addrspace entry */
name|sa
operator|=
operator|&
name|dinfo
operator|->
name|addrspace
index|[
name|addridx
index|]
expr_stmt|;
name|sa
operator|->
name|sa_base
operator|=
name|base
expr_stmt|;
name|sa
operator|->
name|sa_size
operator|=
name|size
expr_stmt|;
name|sa
operator|->
name|sa_bus_reserved
operator|=
name|bus_reserved
expr_stmt|;
comment|/* Populate the resource list */
name|r_size
operator|=
name|size
operator|-
name|bus_reserved
expr_stmt|;
name|sa
operator|->
name|sa_rid
operator|=
name|resource_list_add_next
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|base
argument_list|,
name|base
operator|+
operator|(
name|r_size
operator|-
literal|1
operator|)
argument_list|,
name|r_size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Deallocate the given device info structure and any associated resources.  *   * @param dev The requesting bus device.  * @param child The siba child device.  * @param dinfo Device info associated with @p child to be deallocated.  */
end_comment

begin_function
name|void
name|siba_free_dinfo
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|siba_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
name|resource_list_free
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|)
expr_stmt|;
comment|/* Free all mapped configuration blocks */
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|dinfo
operator|->
name|cfg
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dinfo
operator|->
name|cfg_res
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|bhnd_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|dinfo
operator|->
name|cfg_rid
index|[
name|i
index|]
argument_list|,
name|dinfo
operator|->
name|cfg_res
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg_res
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|dinfo
operator|->
name|cfg_rid
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Unmap the core's interrupt */
if|if
condition|(
name|dinfo
operator|->
name|intr_en
operator|&&
name|dinfo
operator|->
name|intr
operator|.
name|mapped
condition|)
block|{
name|BHND_BUS_UNMAP_INTR
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|dinfo
operator|->
name|intr
operator|.
name|irq
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|intr
operator|.
name|mapped
operator|=
name|false
expr_stmt|;
block|}
name|free
argument_list|(
name|dinfo
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Return the core-enumeration-relative offset for the @p addrspace  * SIBA_R0_ADMATCH* register.  *   * @param addrspace The address space index.  *   * @retval non-zero success  * @retval 0 the given @p addrspace index is not supported.  */
end_comment

begin_function
name|u_int
name|siba_admatch_offset
parameter_list|(
name|uint8_t
name|addrspace
parameter_list|)
block|{
switch|switch
condition|(
name|addrspace
condition|)
block|{
case|case
literal|0
case|:
return|return
name|SB0_REG_ABS
argument_list|(
name|SIBA_CFG0_ADMATCH0
argument_list|)
return|;
case|case
literal|1
case|:
return|return
name|SB0_REG_ABS
argument_list|(
name|SIBA_CFG0_ADMATCH1
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|SB0_REG_ABS
argument_list|(
name|SIBA_CFG0_ADMATCH2
argument_list|)
return|;
case|case
literal|3
case|:
return|return
name|SB0_REG_ABS
argument_list|(
name|SIBA_CFG0_ADMATCH3
argument_list|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Parse a SIBA_R0_ADMATCH* register.  *   * @param addrspace The address space index.  * @param am The address match register value to be parsed.  * @param[out] addr The parsed address.  * @param[out] size The parsed size.  *   * @retval 0 success  * @retval non-zero a parse error occurred.  */
end_comment

begin_function
name|int
name|siba_parse_admatch
parameter_list|(
name|uint32_t
name|am
parameter_list|,
name|uint32_t
modifier|*
name|addr
parameter_list|,
name|uint32_t
modifier|*
name|size
parameter_list|)
block|{
name|u_int
name|am_type
decl_stmt|;
comment|/* Negative encoding is not supported. This is not used on any 	 * currently known devices*/
if|if
condition|(
name|am
operator|&
name|SIBA_AM_ADNEG
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Extract the base address and size */
name|am_type
operator|=
name|SIBA_REG_GET
argument_list|(
name|am
argument_list|,
name|AM_TYPE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|am_type
condition|)
block|{
case|case
literal|0
case|:
operator|*
name|addr
operator|=
name|am
operator|&
name|SIBA_AM_BASE0_MASK
expr_stmt|;
operator|*
name|size
operator|=
literal|1
operator|<<
operator|(
name|SIBA_REG_GET
argument_list|(
name|am
argument_list|,
name|AM_ADINT0
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
operator|*
name|addr
operator|=
name|am
operator|&
name|SIBA_AM_BASE1_MASK
expr_stmt|;
operator|*
name|size
operator|=
literal|1
operator|<<
operator|(
name|SIBA_REG_GET
argument_list|(
name|am
argument_list|,
name|AM_ADINT1
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|addr
operator|=
name|am
operator|&
name|SIBA_AM_BASE2_MASK
expr_stmt|;
operator|*
name|size
operator|=
literal|1
operator|<<
operator|(
name|SIBA_REG_GET
argument_list|(
name|am
argument_list|,
name|AM_ADINT2
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Write @p value to @p dev's CFG0 target/initiator state register and  * wait for completion.  *   * @param dev The siba(4) child device.  * @param reg The state register to write (e.g. SIBA_CFG0_TMSTATELOW,  *    SIBA_CFG0_IMSTATE)  * @param value The value to write to @p reg.  * @param mask The mask of bits to be included from @p value.  *   * @retval 0 success.  * @retval ENODEV if SIBA_CFG0 is not mapped by @p dinfo.  * @retval ETIMEDOUT if a timeout occurs prior to SIBA_TMH_BUSY clearing.  */
end_comment

begin_function
name|int
name|siba_write_target_state
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|siba_devinfo
modifier|*
name|dinfo
parameter_list|,
name|bus_size_t
name|reg
parameter_list|,
name|uint32_t
name|value
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
name|struct
name|bhnd_resource
modifier|*
name|r
decl_stmt|;
name|uint32_t
name|rval
decl_stmt|;
comment|/* Must have a CFG0 block */
if|if
condition|(
operator|(
name|r
operator|=
name|dinfo
operator|->
name|cfg_res
index|[
literal|0
index|]
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Verify the register offset falls within CFG register block */
if|if
condition|(
name|reg
operator|>
name|SIBA_CFG_SIZE
operator|-
literal|4
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|300
condition|;
name|i
operator|+=
literal|10
control|)
block|{
name|rval
operator|=
name|bhnd_bus_read_4
argument_list|(
name|r
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rval
operator|&=
operator|~
name|mask
expr_stmt|;
name|rval
operator||=
operator|(
name|value
operator|&
name|mask
operator|)
expr_stmt|;
name|bhnd_bus_write_4
argument_list|(
name|r
argument_list|,
name|reg
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|bhnd_bus_read_4
argument_list|(
name|r
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* read-back */
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* If the write has completed, wait for target busy state 		 * to clear */
name|rval
operator|=
name|bhnd_bus_read_4
argument_list|(
name|r
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rval
operator|&
name|mask
operator|)
operator|==
operator|(
name|value
operator|&
name|mask
operator|)
condition|)
return|return
operator|(
name|siba_wait_target_busy
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|,
literal|100000
argument_list|)
operator|)
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Spin for up to @p usec waiting for SIBA_TMH_BUSY to clear in  * @p dev's SIBA_CFG0_TMSTATEHIGH register.  *   * @param dev The siba(4) child device to wait on.  * @param dinfo The @p dev's device info  *   * @retval 0 if SIBA_TMH_BUSY is cleared prior to the @p usec timeout.  * @retval ENODEV if SIBA_CFG0 is not mapped by @p dinfo.  * @retval ETIMEDOUT if a timeout occurs prior to SIBA_TMH_BUSY clearing.  */
end_comment

begin_function
name|int
name|siba_wait_target_busy
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|siba_devinfo
modifier|*
name|dinfo
parameter_list|,
name|int
name|usec
parameter_list|)
block|{
name|struct
name|bhnd_resource
modifier|*
name|r
decl_stmt|;
name|uint32_t
name|ts_high
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|dinfo
operator|->
name|cfg_res
index|[
literal|0
index|]
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|usec
condition|;
name|i
operator|+=
literal|10
control|)
block|{
name|ts_high
operator|=
name|bhnd_bus_read_4
argument_list|(
name|r
argument_list|,
name|SIBA_CFG0_TMSTATEHIGH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ts_high
operator|&
name|SIBA_TMH_BUSY
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SIBA_TMH_BUSY wait timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
end_function

end_unit

