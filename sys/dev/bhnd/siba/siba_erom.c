begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Landon Fuller<landonf@FreeBSD.org>  * Copyright (c) 2017 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by Landon Fuller  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhnd_erom.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/chipc/chipcreg.h>
end_include

begin_include
include|#
directive|include
file|"sibareg.h"
end_include

begin_include
include|#
directive|include
file|"sibavar.h"
end_include

begin_struct_decl
struct_decl|struct
name|siba_erom
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|siba_erom_io
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|int
name|siba_eio_init
parameter_list|(
name|struct
name|siba_erom_io
modifier|*
name|io
parameter_list|,
name|struct
name|bhnd_erom_io
modifier|*
name|eio
parameter_list|,
name|u_int
name|ncores
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|siba_eio_read_4
parameter_list|(
name|struct
name|siba_erom_io
modifier|*
name|io
parameter_list|,
name|u_int
name|core_idx
parameter_list|,
name|bus_size_t
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|siba_core_id
name|siba_eio_read_core_id
parameter_list|(
name|struct
name|siba_erom_io
modifier|*
name|io
parameter_list|,
name|u_int
name|core_idx
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|siba_eio_read_chipid
parameter_list|(
name|struct
name|siba_erom_io
modifier|*
name|io
parameter_list|,
name|bus_addr_t
name|enum_addr
parameter_list|,
name|struct
name|bhnd_chipid
modifier|*
name|cid
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * SIBA EROM generic I/O context  */
end_comment

begin_struct
struct|struct
name|siba_erom_io
block|{
name|struct
name|bhnd_erom_io
modifier|*
name|eio
decl_stmt|;
comment|/**< erom I/O callbacks */
name|bhnd_addr_t
name|base_addr
decl_stmt|;
comment|/**< address of first core */
name|u_int
name|ncores
decl_stmt|;
comment|/**< core count */
block|}
struct|;
end_struct

begin_comment
comment|/**  * SIBA EROM per-instance state.  */
end_comment

begin_struct
struct|struct
name|siba_erom
block|{
name|struct
name|bhnd_erom
name|obj
decl_stmt|;
name|struct
name|siba_erom_io
name|io
decl_stmt|;
comment|/**< i/o context */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|EROM_LOG
parameter_list|(
name|io
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {				\ 	printf("%s: " fmt, __FUNCTION__, ##__VA_ARGS__);	\ } while(0)
end_define

begin_comment
comment|/* SIBA implementation of BHND_EROM_PROBE() */
end_comment

begin_function
specifier|static
name|int
name|siba_erom_probe
parameter_list|(
name|bhnd_erom_class_t
modifier|*
name|cls
parameter_list|,
name|struct
name|bhnd_erom_io
modifier|*
name|eio
parameter_list|,
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|hint
parameter_list|,
name|struct
name|bhnd_chipid
modifier|*
name|cid
parameter_list|)
block|{
name|struct
name|siba_erom_io
name|io
decl_stmt|;
name|uint32_t
name|idreg
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Initialize I/O context, assuming at least the first core is mapped */
if|if
condition|(
operator|(
name|error
operator|=
name|siba_eio_init
argument_list|(
operator|&
name|io
argument_list|,
name|eio
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Try using the provided hint. */
if|if
condition|(
name|hint
operator|!=
name|NULL
condition|)
block|{
name|struct
name|siba_core_id
name|sid
decl_stmt|;
comment|/* Validate bus type */
if|if
condition|(
name|hint
operator|->
name|chip_type
operator|!=
name|BHND_CHIPTYPE_SIBA
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 		 * Verify the first core's IDHIGH/IDLOW identification. 		 *  		 * The core must be a Broadcom core, but must *not* be 		 * a chipcommon core; those shouldn't be hinted. 		 * 		 * The first core on EXTIF-equipped devices varies, but on the 		 * BCM4710, it's a SDRAM core (0x803). 		 */
name|sid
operator|=
name|siba_eio_read_core_id
argument_list|(
operator|&
name|io
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sid
operator|.
name|core_info
operator|.
name|vendor
operator|!=
name|BHND_MFGID_BCM
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|sid
operator|.
name|core_info
operator|.
name|device
operator|==
name|BHND_COREID_CC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|cid
operator|=
operator|*
name|hint
expr_stmt|;
block|}
else|else
block|{
comment|/* Validate bus type */
name|idreg
operator|=
name|siba_eio_read_4
argument_list|(
operator|&
name|io
argument_list|,
literal|0
argument_list|,
name|CHIPC_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIPC_GET_BITS
argument_list|(
name|idreg
argument_list|,
name|CHIPC_ID_BUS
argument_list|)
operator|!=
name|BHND_CHIPTYPE_SIBA
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Identify the chipset */
if|if
condition|(
operator|(
name|error
operator|=
name|siba_eio_read_chipid
argument_list|(
operator|&
name|io
argument_list|,
name|SIBA_ENUM_ADDR
argument_list|,
name|cid
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Verify the chip type */
if|if
condition|(
name|cid
operator|->
name|chip_type
operator|!=
name|BHND_CHIPTYPE_SIBA
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * gcc hack: ensure bhnd_chipid.ncores cannot exceed SIBA_MAX_CORES 	 * without triggering build failure due to -Wtype-limits 	 * 	 * if (cid.ncores> SIBA_MAX_CORES) 	 *      return (EINVAL) 	 */
assert|_Static_assert
argument_list|(
operator|(
literal|2
operator|^
sizeof|sizeof
argument_list|(
name|cid
operator|->
name|ncores
argument_list|)
operator|)
operator|<=
name|SIBA_MAX_CORES
argument_list|,
literal|"ncores could result in over-read of backing resource"
argument_list|)
assert|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* SIBA implementation of BHND_EROM_INIT() */
end_comment

begin_function
specifier|static
name|int
name|siba_erom_init
parameter_list|(
name|bhnd_erom_t
modifier|*
name|erom
parameter_list|,
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|cid
parameter_list|,
name|struct
name|bhnd_erom_io
modifier|*
name|eio
parameter_list|)
block|{
name|struct
name|siba_erom
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|siba_erom
operator|*
operator|)
name|erom
expr_stmt|;
comment|/* Attempt to map the full core enumeration space */
name|error
operator|=
name|bhnd_erom_io_map
argument_list|(
name|eio
argument_list|,
name|cid
operator|->
name|enum_addr
argument_list|,
name|cid
operator|->
name|ncores
operator|*
name|SIBA_CORE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"%s: failed to map %u cores: %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|cid
operator|->
name|ncores
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Initialize I/O context */
return|return
operator|(
name|siba_eio_init
argument_list|(
operator|&
name|sc
operator|->
name|io
argument_list|,
name|eio
argument_list|,
name|cid
operator|->
name|ncores
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* SIBA implementation of BHND_EROM_FINI() */
end_comment

begin_function
specifier|static
name|void
name|siba_erom_fini
parameter_list|(
name|bhnd_erom_t
modifier|*
name|erom
parameter_list|)
block|{
name|struct
name|siba_erom
modifier|*
name|sc
init|=
operator|(
expr|struct
name|siba_erom
operator|*
operator|)
name|erom
decl_stmt|;
name|bhnd_erom_io_fini
argument_list|(
name|sc
operator|->
name|io
operator|.
name|eio
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize siba_erom resource I/O context */
end_comment

begin_function
specifier|static
name|int
name|siba_eio_init
parameter_list|(
name|struct
name|siba_erom_io
modifier|*
name|io
parameter_list|,
name|struct
name|bhnd_erom_io
modifier|*
name|eio
parameter_list|,
name|u_int
name|ncores
parameter_list|)
block|{
name|io
operator|->
name|eio
operator|=
name|eio
expr_stmt|;
name|io
operator|->
name|ncores
operator|=
name|ncores
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read a 32-bit value from @p offset relative to the base address of  * the given @p core_idx.  *   * @param io EROM I/O context.  * @param core_idx Core index.  * @param offset Core register offset.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|siba_eio_read_4
parameter_list|(
name|struct
name|siba_erom_io
modifier|*
name|io
parameter_list|,
name|u_int
name|core_idx
parameter_list|,
name|bus_size_t
name|offset
parameter_list|)
block|{
comment|/* Sanity check core index and offset */
if|if
condition|(
name|core_idx
operator|>=
name|io
operator|->
name|ncores
condition|)
name|panic
argument_list|(
literal|"core index %u out of range (ncores=%u)"
argument_list|,
name|core_idx
argument_list|,
name|io
operator|->
name|ncores
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|SIBA_CORE_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
name|panic
argument_list|(
literal|"invalid core offset %#jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|offset
argument_list|)
expr_stmt|;
comment|/* Perform read */
return|return
operator|(
name|bhnd_erom_io_read
argument_list|(
name|io
operator|->
name|eio
argument_list|,
name|SIBA_CORE_OFFSET
argument_list|(
name|core_idx
argument_list|)
operator|+
name|offset
argument_list|,
literal|4
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read and parse identification registers for the given @p core_index.  *   * @param io EROM I/O context.  * @param core_idx The core index.  * @param unit The caller-specified unit number to be included in the return  * value.  */
end_comment

begin_function
specifier|static
name|struct
name|siba_core_id
name|siba_eio_read_core_id
parameter_list|(
name|struct
name|siba_erom_io
modifier|*
name|io
parameter_list|,
name|u_int
name|core_idx
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|uint32_t
name|idhigh
decl_stmt|,
name|idlow
decl_stmt|;
name|idhigh
operator|=
name|siba_eio_read_4
argument_list|(
name|io
argument_list|,
name|core_idx
argument_list|,
name|SB0_REG_ABS
argument_list|(
name|SIBA_CFG0_IDHIGH
argument_list|)
argument_list|)
expr_stmt|;
name|idlow
operator|=
name|siba_eio_read_4
argument_list|(
name|io
argument_list|,
name|core_idx
argument_list|,
name|SB0_REG_ABS
argument_list|(
name|SIBA_CFG0_IDLOW
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|siba_parse_core_id
argument_list|(
name|idhigh
argument_list|,
name|idlow
argument_list|,
name|core_idx
argument_list|,
name|unit
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read and parse the chip identification register from the ChipCommon core.  *   * @param io EROM I/O context.  * @param enum_addr The physical address mapped by @p io.  * @param cid On success, the parsed chip identifier.  */
end_comment

begin_function
specifier|static
name|int
name|siba_eio_read_chipid
parameter_list|(
name|struct
name|siba_erom_io
modifier|*
name|io
parameter_list|,
name|bus_addr_t
name|enum_addr
parameter_list|,
name|struct
name|bhnd_chipid
modifier|*
name|cid
parameter_list|)
block|{
name|struct
name|siba_core_id
name|ccid
decl_stmt|;
name|uint32_t
name|idreg
decl_stmt|;
comment|/* Identify the chipcommon core */
name|ccid
operator|=
name|siba_eio_read_core_id
argument_list|(
name|io
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccid
operator|.
name|core_info
operator|.
name|vendor
operator|!=
name|BHND_MFGID_BCM
operator|||
name|ccid
operator|.
name|core_info
operator|.
name|device
operator|!=
name|BHND_COREID_CC
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|EROM_LOG
argument_list|(
name|io
argument_list|,
literal|"first core not chipcommon "
literal|"(vendor=%#hx, core=%#hx)\n"
argument_list|,
name|ccid
operator|.
name|core_info
operator|.
name|vendor
argument_list|,
name|ccid
operator|.
name|core_info
operator|.
name|device
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Identify the chipset */
name|idreg
operator|=
name|siba_eio_read_4
argument_list|(
name|io
argument_list|,
literal|0
argument_list|,
name|CHIPC_ID
argument_list|)
expr_stmt|;
operator|*
name|cid
operator|=
name|bhnd_parse_chipid
argument_list|(
name|idreg
argument_list|,
name|enum_addr
argument_list|)
expr_stmt|;
comment|/* Fix up the core count in-place */
return|return
operator|(
name|bhnd_chipid_fixed_ncores
argument_list|(
name|cid
argument_list|,
name|ccid
operator|.
name|core_info
operator|.
name|hwrev
argument_list|,
operator|&
name|cid
operator|->
name|ncores
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|siba_erom_lookup_core
parameter_list|(
name|bhnd_erom_t
modifier|*
name|erom
parameter_list|,
specifier|const
name|struct
name|bhnd_core_match
modifier|*
name|desc
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|core
parameter_list|)
block|{
name|struct
name|siba_erom
modifier|*
name|sc
decl_stmt|;
name|struct
name|bhnd_core_match
name|imatch
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|siba_erom
operator|*
operator|)
name|erom
expr_stmt|;
comment|/* We can't determine a core's unit number during the initial scan. */
name|imatch
operator|=
operator|*
name|desc
expr_stmt|;
name|imatch
operator|.
name|m
operator|.
name|match
operator|.
name|core_unit
operator|=
literal|0
expr_stmt|;
comment|/* Locate the first matching core */
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|io
operator|.
name|ncores
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|siba_core_id
name|sid
decl_stmt|;
name|struct
name|bhnd_core_info
name|ci
decl_stmt|;
comment|/* Read the core info */
name|sid
operator|=
name|siba_eio_read_core_id
argument_list|(
operator|&
name|sc
operator|->
name|io
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ci
operator|=
name|sid
operator|.
name|core_info
expr_stmt|;
comment|/* Check for initial match */
if|if
condition|(
operator|!
name|bhnd_core_matches
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|imatch
argument_list|)
condition|)
continue|continue;
comment|/* Re-scan preceding cores to determine the unit number. */
for|for
control|(
name|u_int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|sid
operator|=
name|siba_eio_read_core_id
argument_list|(
operator|&
name|sc
operator|->
name|io
argument_list|,
name|j
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Bump the unit number? */
if|if
condition|(
name|sid
operator|.
name|core_info
operator|.
name|vendor
operator|==
name|ci
operator|.
name|vendor
operator|&&
name|sid
operator|.
name|core_info
operator|.
name|device
operator|==
name|ci
operator|.
name|device
condition|)
name|ci
operator|.
name|unit
operator|++
expr_stmt|;
block|}
comment|/* Check for full match against now-valid unit number */
if|if
condition|(
operator|!
name|bhnd_core_matches
argument_list|(
operator|&
name|ci
argument_list|,
name|desc
argument_list|)
condition|)
continue|continue;
comment|/* Matching core found */
operator|*
name|core
operator|=
name|ci
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Not found */
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|siba_erom_lookup_core_addr
parameter_list|(
name|bhnd_erom_t
modifier|*
name|erom
parameter_list|,
specifier|const
name|struct
name|bhnd_core_match
modifier|*
name|desc
parameter_list|,
name|bhnd_port_type
name|type
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|region
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|info
parameter_list|,
name|bhnd_addr_t
modifier|*
name|addr
parameter_list|,
name|bhnd_size_t
modifier|*
name|size
parameter_list|)
block|{
name|struct
name|siba_erom
modifier|*
name|sc
decl_stmt|;
name|struct
name|bhnd_core_info
name|core
decl_stmt|;
name|struct
name|siba_core_id
name|sid
decl_stmt|;
name|uint32_t
name|am
decl_stmt|,
name|am_addr
decl_stmt|,
name|am_size
decl_stmt|;
name|u_int
name|am_offset
decl_stmt|;
name|u_int
name|addrspace
decl_stmt|,
name|cfg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|siba_erom
operator|*
operator|)
name|erom
expr_stmt|;
comment|/* Locate the requested core */
if|if
condition|(
operator|(
name|error
operator|=
name|siba_erom_lookup_core
argument_list|(
name|erom
argument_list|,
name|desc
argument_list|,
operator|&
name|core
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Fetch full siba core ident */
name|sid
operator|=
name|siba_eio_read_core_id
argument_list|(
operator|&
name|sc
operator|->
name|io
argument_list|,
name|core
operator|.
name|core_idx
argument_list|,
name|core
operator|.
name|unit
argument_list|)
expr_stmt|;
comment|/* Is port valid? */
if|if
condition|(
operator|!
name|siba_is_port_valid
argument_list|(
operator|&
name|sid
argument_list|,
name|type
argument_list|,
name|port
argument_list|)
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Is region valid? */
if|if
condition|(
name|region
operator|>=
name|siba_port_region_count
argument_list|(
operator|&
name|sid
argument_list|,
name|type
argument_list|,
name|port
argument_list|)
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Is this a siba configuration region? If so, this is mapped to an 	 * offset within the device0.0 port */
name|error
operator|=
name|siba_cfg_index
argument_list|(
operator|&
name|sid
argument_list|,
name|type
argument_list|,
name|port
argument_list|,
name|region
argument_list|,
operator|&
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|bhnd_addr_t
name|region_addr
decl_stmt|;
name|bhnd_addr_t
name|region_size
decl_stmt|;
name|bhnd_size_t
name|cfg_offset
decl_stmt|,
name|cfg_size
decl_stmt|;
name|cfg_offset
operator|=
name|SIBA_CFG_OFFSET
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|cfg_size
operator|=
name|SIBA_CFG_SIZE
expr_stmt|;
comment|/* Fetch the device0.0 addr/size */
name|error
operator|=
name|siba_erom_lookup_core_addr
argument_list|(
name|erom
argument_list|,
name|desc
argument_list|,
name|BHND_PORT_DEVICE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|region_addr
argument_list|,
operator|&
name|region_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Verify that our offset fits within the region */
if|if
condition|(
name|region_size
operator|<
name|cfg_size
condition|)
block|{
name|printf
argument_list|(
literal|"%s%u.%u offset %ju exceeds %s0.0 size %ju\n"
argument_list|,
name|bhnd_port_type_name
argument_list|(
name|type
argument_list|)
argument_list|,
name|port
argument_list|,
name|region
argument_list|,
name|cfg_offset
argument_list|,
name|bhnd_port_type_name
argument_list|(
name|BHND_PORT_DEVICE
argument_list|)
argument_list|,
name|region_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|BHND_ADDR_MAX
operator|-
name|region_addr
operator|<
name|cfg_offset
condition|)
block|{
name|printf
argument_list|(
literal|"%s%u.%u offset %ju would overflow %s0.0 addr "
literal|"%ju\n"
argument_list|,
name|bhnd_port_type_name
argument_list|(
name|type
argument_list|)
argument_list|,
name|port
argument_list|,
name|region
argument_list|,
name|cfg_offset
argument_list|,
name|bhnd_port_type_name
argument_list|(
name|BHND_PORT_DEVICE
argument_list|)
argument_list|,
name|region_addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
operator|*
name|info
operator|=
name|core
expr_stmt|;
operator|*
name|addr
operator|=
name|region_addr
operator|+
name|cfg_offset
expr_stmt|;
operator|*
name|size
operator|=
name|cfg_size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  	 * Otherwise, must be a device port. 	 *  	 * Map the bhnd device port to a siba addrspace index. Unlike siba(4) 	 * bus drivers, we do not exclude the siba(4) configuration blocks from 	 * the first device port. 	 */
name|error
operator|=
name|siba_addrspace_index
argument_list|(
operator|&
name|sid
argument_list|,
name|type
argument_list|,
name|port
argument_list|,
name|region
argument_list|,
operator|&
name|addrspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Determine the register offset */
name|am_offset
operator|=
name|siba_admatch_offset
argument_list|(
name|addrspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|am_offset
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"addrspace %u is unsupported"
argument_list|,
name|addrspace
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* Read and parse the address match register */
name|am
operator|=
name|siba_eio_read_4
argument_list|(
operator|&
name|sc
operator|->
name|io
argument_list|,
name|core
operator|.
name|core_idx
argument_list|,
name|am_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|siba_parse_admatch
argument_list|(
name|am
argument_list|,
operator|&
name|am_addr
argument_list|,
operator|&
name|am_size
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"failed to decode address match register value 0x%x\n"
argument_list|,
name|am
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
operator|*
name|info
operator|=
name|core
expr_stmt|;
operator|*
name|addr
operator|=
name|am_addr
expr_stmt|;
operator|*
name|size
operator|=
name|am_size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* BHND_EROM_GET_CORE_TABLE() */
end_comment

begin_function
specifier|static
name|int
name|siba_erom_get_core_table
parameter_list|(
name|bhnd_erom_t
modifier|*
name|erom
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
modifier|*
name|cores
parameter_list|,
name|u_int
modifier|*
name|num_cores
parameter_list|)
block|{
name|struct
name|siba_erom
modifier|*
name|sc
decl_stmt|;
name|struct
name|bhnd_core_info
modifier|*
name|out
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|siba_erom
operator|*
operator|)
name|erom
expr_stmt|;
comment|/* Allocate our core array */
name|out
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|out
argument_list|)
operator|*
name|sc
operator|->
name|io
operator|.
name|ncores
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
operator|*
name|cores
operator|=
name|out
expr_stmt|;
operator|*
name|num_cores
operator|=
name|sc
operator|->
name|io
operator|.
name|ncores
expr_stmt|;
comment|/* Enumerate all cores. */
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|io
operator|.
name|ncores
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|siba_core_id
name|sid
decl_stmt|;
comment|/* Read the core info */
name|sid
operator|=
name|siba_eio_read_core_id
argument_list|(
operator|&
name|sc
operator|->
name|io
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
index|[
name|i
index|]
operator|=
name|sid
operator|.
name|core_info
expr_stmt|;
comment|/* Determine unit number */
for|for
control|(
name|u_int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|out
index|[
name|j
index|]
operator|.
name|vendor
operator|==
name|out
index|[
name|i
index|]
operator|.
name|vendor
operator|&&
name|out
index|[
name|j
index|]
operator|.
name|device
operator|==
name|out
index|[
name|i
index|]
operator|.
name|device
condition|)
name|out
index|[
name|i
index|]
operator|.
name|unit
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* BHND_EROM_FREE_CORE_TABLE() */
end_comment

begin_function
specifier|static
name|void
name|siba_erom_free_core_table
parameter_list|(
name|bhnd_erom_t
modifier|*
name|erom
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|cores
parameter_list|)
block|{
name|free
argument_list|(
name|cores
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* BHND_EROM_DUMP() */
end_comment

begin_function
specifier|static
name|int
name|siba_erom_dump
parameter_list|(
name|bhnd_erom_t
modifier|*
name|erom
parameter_list|)
block|{
name|struct
name|siba_erom
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|siba_erom
operator|*
operator|)
name|erom
expr_stmt|;
comment|/* Enumerate all cores. */
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|io
operator|.
name|ncores
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|idhigh
decl_stmt|,
name|idlow
decl_stmt|;
name|uint32_t
name|nraddr
decl_stmt|;
name|idhigh
operator|=
name|siba_eio_read_4
argument_list|(
operator|&
name|sc
operator|->
name|io
argument_list|,
name|i
argument_list|,
name|SB0_REG_ABS
argument_list|(
name|SIBA_CFG0_IDHIGH
argument_list|)
argument_list|)
expr_stmt|;
name|idlow
operator|=
name|siba_eio_read_4
argument_list|(
operator|&
name|sc
operator|->
name|io
argument_list|,
name|i
argument_list|,
name|SB0_REG_ABS
argument_list|(
name|SIBA_CFG0_IDLOW
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"siba core %u:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tvendor:\t0x%04x\n"
argument_list|,
name|SIBA_REG_GET
argument_list|(
name|idhigh
argument_list|,
name|IDH_VENDOR
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tdevice:\t0x%04x\n"
argument_list|,
name|SIBA_REG_GET
argument_list|(
name|idhigh
argument_list|,
name|IDH_DEVICE
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\trev:\t0x%04x\n"
argument_list|,
name|SIBA_IDH_CORE_REV
argument_list|(
name|idhigh
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tsbrev:\t0x%02x\n"
argument_list|,
name|SIBA_REG_GET
argument_list|(
name|idlow
argument_list|,
name|IDL_SBREV
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enumerate the address match registers */
name|nraddr
operator|=
name|SIBA_REG_GET
argument_list|(
name|idlow
argument_list|,
name|IDL_NRADDR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tnraddr\t0x%04x\n"
argument_list|,
name|nraddr
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|addrspace
init|=
literal|0
init|;
name|addrspace
operator|<
name|nraddr
condition|;
name|addrspace
operator|++
control|)
block|{
name|uint32_t
name|am
decl_stmt|,
name|am_addr
decl_stmt|,
name|am_size
decl_stmt|;
name|u_int
name|am_offset
decl_stmt|;
comment|/* Determine the register offset */
name|am_offset
operator|=
name|siba_admatch_offset
argument_list|(
name|addrspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|am_offset
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"addrspace %zu unsupported"
argument_list|,
name|addrspace
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Read and parse the address match register */
name|am
operator|=
name|siba_eio_read_4
argument_list|(
operator|&
name|sc
operator|->
name|io
argument_list|,
name|i
argument_list|,
name|am_offset
argument_list|)
expr_stmt|;
name|error
operator|=
name|siba_parse_admatch
argument_list|(
name|am
argument_list|,
operator|&
name|am_addr
argument_list|,
operator|&
name|am_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"failed to decode address match "
literal|"register value 0x%x\n"
argument_list|,
name|am
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"\taddrspace %zu\n"
argument_list|,
name|addrspace
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\taddr: 0x%08x\n"
argument_list|,
name|am_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\tsize: 0x%08x\n"
argument_list|,
name|am_size
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|siba_erom_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|bhnd_erom_probe
argument_list|,
name|siba_erom_probe
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|bhnd_erom_init
argument_list|,
name|siba_erom_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|bhnd_erom_fini
argument_list|,
name|siba_erom_fini
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|bhnd_erom_get_core_table
argument_list|,
name|siba_erom_get_core_table
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|bhnd_erom_free_core_table
argument_list|,
name|siba_erom_free_core_table
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|bhnd_erom_lookup_core
argument_list|,
name|siba_erom_lookup_core
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|bhnd_erom_lookup_core_addr
argument_list|,
name|siba_erom_lookup_core_addr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|bhnd_erom_dump
argument_list|,
name|siba_erom_dump
argument_list|)
block|,
name|KOBJMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|BHND_EROM_DEFINE_CLASS
argument_list|(
name|siba_erom
argument_list|,
name|siba_erom_parser
argument_list|,
name|siba_erom_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|siba_erom
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

