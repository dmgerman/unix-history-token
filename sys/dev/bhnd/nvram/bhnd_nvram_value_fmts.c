begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Landon Fuller<landonf@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/_inttypes.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_KERNEL */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_include
include|#
directive|include
file|"bhnd_nvram_private.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_valuevar.h"
end_include

begin_function_decl
specifier|static
name|bool
name|bhnd_nvram_ident_octet_string
parameter_list|(
specifier|const
name|char
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|char
modifier|*
name|delim
parameter_list|,
name|size_t
modifier|*
name|nelem
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|bhnd_nvram_ident_num_string
parameter_list|(
specifier|const
name|char
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|u_int
name|base
parameter_list|,
name|u_int
modifier|*
name|obase
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_val_bcm_macaddr_filter
parameter_list|(
specifier|const
name|bhnd_nvram_val_fmt_t
modifier|*
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_val_bcm_macaddr_encode
parameter_list|(
name|bhnd_nvram_val_t
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_val_bcm_macaddr_string_filter
parameter_list|(
specifier|const
name|bhnd_nvram_val_fmt_t
modifier|*
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_val_bcm_macaddr_string_encode_elem
parameter_list|(
name|bhnd_nvram_val_t
modifier|*
name|value
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|void
modifier|*
name|bhnd_nvram_val_bcm_macaddr_string_next
parameter_list|(
name|bhnd_nvram_val_t
modifier|*
name|value
parameter_list|,
specifier|const
name|void
modifier|*
name|prev
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_val_bcm_int_filter
parameter_list|(
specifier|const
name|bhnd_nvram_val_fmt_t
modifier|*
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_val_bcm_int_encode
parameter_list|(
name|bhnd_nvram_val_t
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_val_bcm_decimal_encode_elem
parameter_list|(
name|bhnd_nvram_val_t
modifier|*
name|value
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_val_bcm_hex_encode_elem
parameter_list|(
name|bhnd_nvram_val_t
modifier|*
name|value
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_val_bcm_leddc_filter
parameter_list|(
specifier|const
name|bhnd_nvram_val_fmt_t
modifier|*
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_val_bcm_leddc_encode_elem
parameter_list|(
name|bhnd_nvram_val_t
modifier|*
name|value
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_val_bcmstr_encode
parameter_list|(
name|bhnd_nvram_val_t
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_val_bcmstr_csv_filter
parameter_list|(
specifier|const
name|bhnd_nvram_val_fmt_t
modifier|*
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|void
modifier|*
name|bhnd_nvram_val_bcmstr_csv_next
parameter_list|(
name|bhnd_nvram_val_t
modifier|*
name|value
parameter_list|,
specifier|const
name|void
modifier|*
name|prev
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Broadcom NVRAM MAC address format.  */
end_comment

begin_decl_stmt
specifier|const
name|bhnd_nvram_val_fmt_t
name|bhnd_nvram_val_bcm_macaddr_fmt
init|=
block|{
operator|.
name|name
operator|=
literal|"bcm-macaddr"
block|,
operator|.
name|native_type
operator|=
name|BHND_NVRAM_TYPE_UINT8_ARRAY
block|,
operator|.
name|op_filter
operator|=
name|bhnd_nvram_val_bcm_macaddr_filter
block|,
operator|.
name|op_encode
operator|=
name|bhnd_nvram_val_bcm_macaddr_encode
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** Broadcom NVRAM MAC address string format. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bhnd_nvram_val_fmt_t
name|bhnd_nvram_val_bcm_macaddr_string_fmt
init|=
block|{
operator|.
name|name
operator|=
literal|"bcm-macaddr-string"
block|,
operator|.
name|native_type
operator|=
name|BHND_NVRAM_TYPE_STRING
block|,
operator|.
name|op_filter
operator|=
name|bhnd_nvram_val_bcm_macaddr_string_filter
block|,
operator|.
name|op_encode_elem
operator|=
name|bhnd_nvram_val_bcm_macaddr_string_encode_elem
block|,
operator|.
name|op_next
operator|=
name|bhnd_nvram_val_bcm_macaddr_string_next
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Broadcom NVRAM LED duty-cycle format.  */
end_comment

begin_decl_stmt
specifier|const
name|bhnd_nvram_val_fmt_t
name|bhnd_nvram_val_bcm_leddc_fmt
init|=
block|{
operator|.
name|name
operator|=
literal|"bcm-leddc"
block|,
operator|.
name|native_type
operator|=
name|BHND_NVRAM_TYPE_UINT32
block|,
operator|.
name|op_filter
operator|=
name|bhnd_nvram_val_bcm_leddc_filter
block|,
operator|.
name|op_encode_elem
operator|=
name|bhnd_nvram_val_bcm_leddc_encode_elem
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Broadcom NVRAM decimal integer format.  *  * Extends standard integer handling, encoding the string representation of  * the integer value as a decimal string:  * - Positive values will be string-encoded without a prefix.  * - Negative values will be string-encoded with a leading '-' sign.  */
end_comment

begin_decl_stmt
specifier|const
name|bhnd_nvram_val_fmt_t
name|bhnd_nvram_val_bcm_decimal_fmt
init|=
block|{
operator|.
name|name
operator|=
literal|"bcm-decimal"
block|,
operator|.
name|native_type
operator|=
name|BHND_NVRAM_TYPE_UINT64
block|,
operator|.
name|op_filter
operator|=
name|bhnd_nvram_val_bcm_int_filter
block|,
operator|.
name|op_encode
operator|=
name|bhnd_nvram_val_bcm_int_encode
block|,
operator|.
name|op_encode_elem
operator|=
name|bhnd_nvram_val_bcm_decimal_encode_elem
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Broadcom NVRAM decimal integer format.  *  * Extends standard integer handling, encoding the string representation of  * unsigned and positive signed integer values as an 0x-prefixed hexadecimal  * string.  *   * For compatibility with standard Broadcom NVRAM parsing, if the integer is  * both signed and negative, it will be string encoded as a negative decimal  * value, not as a twos-complement hexadecimal value.  */
end_comment

begin_decl_stmt
specifier|const
name|bhnd_nvram_val_fmt_t
name|bhnd_nvram_val_bcm_hex_fmt
init|=
block|{
operator|.
name|name
operator|=
literal|"bcm-hex"
block|,
operator|.
name|native_type
operator|=
name|BHND_NVRAM_TYPE_UINT64
block|,
operator|.
name|op_filter
operator|=
name|bhnd_nvram_val_bcm_int_filter
block|,
operator|.
name|op_encode
operator|=
name|bhnd_nvram_val_bcm_int_encode
block|,
operator|.
name|op_encode_elem
operator|=
name|bhnd_nvram_val_bcm_hex_encode_elem
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Broadcom NVRAM string format.  *   * Handles standard, comma-delimited, and octet-string values as used in  * Broadcom NVRAM data.  */
end_comment

begin_decl_stmt
specifier|const
name|bhnd_nvram_val_fmt_t
name|bhnd_nvram_val_bcm_string_fmt
init|=
block|{
operator|.
name|name
operator|=
literal|"bcm-string"
block|,
operator|.
name|native_type
operator|=
name|BHND_NVRAM_TYPE_STRING
block|,
operator|.
name|op_encode
operator|=
name|bhnd_nvram_val_bcmstr_encode
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** Broadcom comma-delimited string. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bhnd_nvram_val_fmt_t
name|bhnd_nvram_val_bcm_string_csv_fmt
init|=
block|{
operator|.
name|name
operator|=
literal|"bcm-string[]"
block|,
operator|.
name|native_type
operator|=
name|BHND_NVRAM_TYPE_STRING
block|,
operator|.
name|op_filter
operator|=
name|bhnd_nvram_val_bcmstr_csv_filter
block|,
operator|.
name|op_next
operator|=
name|bhnd_nvram_val_bcmstr_csv_next
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Common hex/decimal integer filter implementation.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_val_bcm_int_filter
parameter_list|(
specifier|const
name|bhnd_nvram_val_fmt_t
modifier|*
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|)
block|{
name|bhnd_nvram_type
name|itype_base
decl_stmt|;
name|itype_base
operator|=
name|bhnd_nvram_base_type
argument_list|(
name|itype
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|itype_base
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_STRING
case|:
comment|/* 		 * If the input is a string, delegate to the Broadcom 		 * string format -- preserving the original string value 		 * takes priority over enforcing hexadecimal/integer string 		 * formatting. 		 */
operator|*
name|fmt
operator|=
operator|&
name|bhnd_nvram_val_bcm_string_fmt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
if|if
condition|(
name|bhnd_nvram_is_int_type
argument_list|(
name|itype_base
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Broadcom hex/decimal integer encode implementation.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_val_bcm_int_encode
parameter_list|(
name|bhnd_nvram_val_t
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
block|{
comment|/* If encoding to a string, format multiple elements (if any) with a 	 * comma delimiter. */
if|if
condition|(
name|otype
operator|==
name|BHND_NVRAM_TYPE_STRING
condition|)
return|return
operator|(
name|bhnd_nvram_val_printf
argument_list|(
name|value
argument_list|,
literal|"%[]s"
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
literal|","
argument_list|)
operator|)
return|;
return|return
operator|(
name|bhnd_nvram_val_generic_encode
argument_list|(
name|value
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Broadcom hex integer encode_elem implementation.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_val_bcm_hex_encode_elem
parameter_list|(
name|bhnd_nvram_val_t
modifier|*
name|value
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
block|{
name|bhnd_nvram_type
name|itype
decl_stmt|;
name|ssize_t
name|width
decl_stmt|;
name|int
name|error
decl_stmt|;
name|itype
operator|=
name|bhnd_nvram_val_elem_type
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|bhnd_nvram_is_int_type
argument_list|(
name|itype
argument_list|)
argument_list|,
operator|(
literal|"invalid type"
operator|)
argument_list|)
expr_stmt|;
comment|/* If not encoding as a string, perform generic value encoding */
if|if
condition|(
name|otype
operator|!=
name|BHND_NVRAM_TYPE_STRING
condition|)
return|return
operator|(
name|bhnd_nvram_val_generic_encode_elem
argument_list|(
name|value
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|)
operator|)
return|;
comment|/* If the value is a signed, negative value, encode as a decimal 	 * string */
if|if
condition|(
name|bhnd_nvram_is_signed_type
argument_list|(
name|itype
argument_list|)
condition|)
block|{
name|int64_t
name|sval
decl_stmt|;
name|size_t
name|slen
decl_stmt|;
name|bhnd_nvram_type
name|stype
decl_stmt|;
name|stype
operator|=
name|BHND_NVRAM_TYPE_INT64
expr_stmt|;
name|slen
operator|=
sizeof|sizeof
argument_list|(
name|sval
argument_list|)
expr_stmt|;
comment|/* Fetch 64-bit signed representation */
name|error
operator|=
name|bhnd_nvram_value_coerce
argument_list|(
name|inp
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|,
operator|&
name|sval
argument_list|,
operator|&
name|slen
argument_list|,
name|stype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Decimal encoding required? */
if|if
condition|(
name|sval
operator|<
literal|0
condition|)
return|return
operator|(
name|bhnd_nvram_value_printf
argument_list|(
literal|"%I64d"
argument_list|,
operator|&
name|sval
argument_list|,
name|slen
argument_list|,
name|stype
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Encode the value as a hex string. 	 *  	 * Most producers of Broadcom NVRAM values zero-pad hex values out to 	 * their native width (width * two hex characters), and we do the same 	 * for compatibility 	 */
name|width
operator|=
name|bhnd_nvram_value_size
argument_list|(
name|itype
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|*
literal|2
expr_stmt|;
return|return
operator|(
name|bhnd_nvram_value_printf
argument_list|(
literal|"0x%0*I64X"
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
name|width
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Broadcom decimal integer encode_elem implementation.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_val_bcm_decimal_encode_elem
parameter_list|(
name|bhnd_nvram_val_t
modifier|*
name|value
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sfmt
decl_stmt|;
name|bhnd_nvram_type
name|itype
decl_stmt|;
name|itype
operator|=
name|bhnd_nvram_val_elem_type
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|bhnd_nvram_is_int_type
argument_list|(
name|itype
argument_list|)
argument_list|,
operator|(
literal|"invalid type"
operator|)
argument_list|)
expr_stmt|;
comment|/* If not encoding as a string, perform generic value encoding */
if|if
condition|(
name|otype
operator|!=
name|BHND_NVRAM_TYPE_STRING
condition|)
return|return
operator|(
name|bhnd_nvram_val_generic_encode_elem
argument_list|(
name|value
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|)
operator|)
return|;
name|sfmt
operator|=
name|bhnd_nvram_is_signed_type
argument_list|(
name|itype
argument_list|)
condition|?
literal|"%I64d"
else|:
literal|"%I64u"
expr_stmt|;
return|return
operator|(
name|bhnd_nvram_value_printf
argument_list|(
name|sfmt
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Broadcom LED duty-cycle filter.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_val_bcm_leddc_filter
parameter_list|(
specifier|const
name|bhnd_nvram_val_fmt_t
modifier|*
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|plen
decl_stmt|;
switch|switch
condition|(
name|itype
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_UINT16
case|:
case|case
name|BHND_NVRAM_TYPE_UINT32
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|BHND_NVRAM_TYPE_STRING
case|:
comment|/* Trim any whitespace */
name|p
operator|=
name|inp
expr_stmt|;
name|plen
operator|=
name|bhnd_nvram_trim_field
argument_list|(
operator|&
name|p
argument_list|,
name|ilen
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* If the value is not a valid integer string, delegate to the 		 * Broadcom string format */
if|if
condition|(
operator|!
name|bhnd_nvram_ident_num_string
argument_list|(
name|p
argument_list|,
name|plen
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
operator|*
name|fmt
operator|=
operator|&
name|bhnd_nvram_val_bcm_string_fmt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Broadcom LED duty-cycle encode.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_val_bcm_leddc_encode_elem
parameter_list|(
name|bhnd_nvram_val_t
modifier|*
name|value
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
block|{
name|bhnd_nvram_type
name|itype
decl_stmt|;
name|size_t
name|limit
decl_stmt|,
name|nbytes
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint16_t
name|led16
decl_stmt|;
name|uint32_t
name|led32
decl_stmt|;
name|bool
name|led16_lossy
decl_stmt|;
union|union
block|{
name|uint16_t
name|u16
decl_stmt|;
name|uint32_t
name|u32
decl_stmt|;
block|}
name|strval
union|;
comment|/* 	 * LED duty-cycle values represent the on/off periods as a 32-bit 	 * integer, with the top 16 bits representing on cycles, and the 	 * bottom 16 representing off cycles. 	 *  	 * LED duty cycle values have three different formats: 	 *  	 * - SPROM:	A 16-bit unsigned integer, with on/off cycles encoded 	 *		as 8-bit values. 	 * - NVRAM:	A 16-bit decimal or hexadecimal string, with on/off 	 *		cycles encoded as 8-bit values as per the SPROM format. 	 * - NVRAM:	A 32-bit decimal or hexadecimal string, with on/off 	 *		cycles encoded as 16-bit values. 	 * 	 * To convert from a 16-bit representation to a 32-bit representation: 	 *     ((value& 0xFF00)<< 16) | ((value& 0x00FF)<< 8) 	 *  	 * To convert from a 32-bit representation to a 16-bit representation, 	 * perform the same operation in reverse, discarding the lower 8-bits 	 * of each half of the 32-bit representation: 	 *     ((value>> 16)& 0xFF00) | ((value>> 8)& 0x00FF) 	 */
name|itype
operator|=
name|bhnd_nvram_val_elem_type
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|nbytes
operator|=
literal|0
expr_stmt|;
name|led16_lossy
operator|=
name|false
expr_stmt|;
comment|/* Determine output byte limit */
if|if
condition|(
name|outp
operator|!=
name|NULL
condition|)
name|limit
operator|=
operator|*
name|olen
expr_stmt|;
else|else
name|limit
operator|=
literal|0
expr_stmt|;
comment|/* If the input/output types match, just delegate to standard value 	 * encoding support */
if|if
condition|(
name|otype
operator|==
name|itype
condition|)
block|{
return|return
operator|(
name|bhnd_nvram_value_coerce
argument_list|(
name|inp
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|)
operator|)
return|;
block|}
comment|/* If our value is a string, it may either be a 16-bit or a 32-bit 	 * representation of the duty cycle */
if|if
condition|(
name|itype
operator|==
name|BHND_NVRAM_TYPE_STRING
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|uint32_t
name|ival
decl_stmt|;
name|size_t
name|nlen
decl_stmt|,
name|parsed
decl_stmt|;
comment|/* Parse integer value */
name|p
operator|=
name|inp
expr_stmt|;
name|nlen
operator|=
sizeof|sizeof
argument_list|(
name|ival
argument_list|)
expr_stmt|;
name|error
operator|=
name|bhnd_nvram_parse_int
argument_list|(
name|p
argument_list|,
name|ilen
argument_list|,
literal|0
argument_list|,
operator|&
name|parsed
argument_list|,
operator|&
name|ival
argument_list|,
operator|&
name|nlen
argument_list|,
name|BHND_NVRAM_TYPE_UINT32
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Trailing garbage? */
if|if
condition|(
name|parsed
operator|<
name|ilen
operator|&&
operator|*
operator|(
name|p
operator|+
name|parsed
operator|)
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|EFTYPE
operator|)
return|;
comment|/* Point inp and itype to either our parsed 32-bit or 16-bit 		 * value */
name|inp
operator|=
operator|&
name|strval
expr_stmt|;
if|if
condition|(
name|ival
operator|&
literal|0xFFFF0000
condition|)
block|{
name|strval
operator|.
name|u32
operator|=
name|ival
expr_stmt|;
name|itype
operator|=
name|BHND_NVRAM_TYPE_UINT32
expr_stmt|;
block|}
else|else
block|{
name|strval
operator|.
name|u16
operator|=
name|ival
expr_stmt|;
name|itype
operator|=
name|BHND_NVRAM_TYPE_UINT16
expr_stmt|;
block|}
block|}
comment|/* Populate both u32 and (possibly lossy) u16 LEDDC representations */
switch|switch
condition|(
name|itype
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_UINT16
case|:
block|{
name|led16
operator|=
operator|*
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|inp
expr_stmt|;
name|led32
operator|=
operator|(
operator|(
name|led16
operator|&
literal|0xFF00
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|led16
operator|&
literal|0x00FF
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* If all bits are set in the 16-bit value (indicating that 		 * the value is 'unset' in SPROM), we must update the 32-bit 		 * representation to match. */
if|if
condition|(
name|led16
operator|==
name|UINT16_MAX
condition|)
name|led32
operator|=
name|UINT32_MAX
expr_stmt|;
break|break;
block|}
case|case
name|BHND_NVRAM_TYPE_UINT32
case|:
name|led32
operator|=
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|inp
expr_stmt|;
name|led16
operator|=
operator|(
operator|(
name|led32
operator|>>
literal|16
operator|)
operator|&
literal|0xFF00
operator|)
operator||
operator|(
operator|(
name|led32
operator|>>
literal|8
operator|)
operator|&
literal|0x00FF
operator|)
expr_stmt|;
comment|/* 		 * Determine whether the led16 conversion is lossy: 		 *  		 * - If the lower 8 bits of each half of the 32-bit value 		 *   aren't set, we can safely use the 16-bit representation 		 *   without losing data. 		 * - If all bits in the 32-bit value are set, the variable is 		 *   treated as unset in  SPROM. We can safely use the 16-bit 		 *   representation without losing data. 		 */
if|if
condition|(
operator|(
name|led32
operator|&
literal|0x00FF00FF
operator|)
operator|!=
literal|0
operator|&&
name|led32
operator|!=
name|UINT32_MAX
condition|)
name|led16_lossy
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|BHND_NV_PANIC
argument_list|(
literal|"unsupported backing data type: %s"
argument_list|,
name|bhnd_nvram_type_name
argument_list|(
name|itype
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Encode as requested output type. 	 */
switch|switch
condition|(
name|otype
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_STRING
case|:
comment|/* 		 * Prefer 16-bit format. 		 */
if|if
condition|(
operator|!
name|led16_lossy
condition|)
block|{
return|return
operator|(
name|bhnd_nvram_value_printf
argument_list|(
literal|"0x%04hX"
argument_list|,
operator|&
name|led16
argument_list|,
sizeof|sizeof
argument_list|(
name|led16
argument_list|)
argument_list|,
name|BHND_NVRAM_TYPE_UINT16
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|bhnd_nvram_value_printf
argument_list|(
literal|"0x%04X"
argument_list|,
operator|&
name|led32
argument_list|,
sizeof|sizeof
argument_list|(
name|led32
argument_list|)
argument_list|,
name|BHND_NVRAM_TYPE_UINT32
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|)
operator|)
return|;
block|}
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT16
case|:
block|{
comment|/* Can we encode as uint16 without losing data? */
if|if
condition|(
name|led16_lossy
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
comment|/* Write led16 format */
name|nbytes
operator|+=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|>=
name|nbytes
condition|)
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|outp
operator|=
name|led16
expr_stmt|;
break|break;
block|}
case|case
name|BHND_NVRAM_TYPE_UINT32
case|:
comment|/* Write led32 format */
name|nbytes
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|>=
name|nbytes
condition|)
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|outp
operator|=
name|led32
expr_stmt|;
break|break;
default|default:
comment|/* No other output formats are supported */
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
comment|/* Provide the actual length */
operator|*
name|olen
operator|=
name|nbytes
expr_stmt|;
comment|/* Report insufficient space (if output was requested) */
if|if
condition|(
name|limit
operator|<
name|nbytes
operator|&&
name|outp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Broadcom NVRAM string encoding.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_val_bcmstr_encode
parameter_list|(
name|bhnd_nvram_val_t
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
block|{
name|bhnd_nvram_val_t
name|array
decl_stmt|;
specifier|const
name|bhnd_nvram_val_fmt_t
modifier|*
name|array_fmt
decl_stmt|;
specifier|const
name|void
modifier|*
name|inp
decl_stmt|;
name|bhnd_nvram_type
name|itype
decl_stmt|;
name|size_t
name|ilen
decl_stmt|;
name|int
name|error
decl_stmt|;
name|inp
operator|=
name|bhnd_nvram_val_bytes
argument_list|(
name|value
argument_list|,
operator|&
name|ilen
argument_list|,
operator|&
name|itype
argument_list|)
expr_stmt|;
comment|/* If the output is not an array type (or if it's a character array), 	 * we can fall back on standard string encoding */
if|if
condition|(
operator|!
name|bhnd_nvram_is_array_type
argument_list|(
name|otype
argument_list|)
operator|||
name|otype
operator|==
name|BHND_NVRAM_TYPE_CHAR_ARRAY
condition|)
block|{
return|return
operator|(
name|bhnd_nvram_value_coerce
argument_list|(
name|inp
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|)
operator|)
return|;
block|}
comment|/* Otherwise, we need to interpret our value as either a macaddr 	 * string, or a comma-delimited string. */
name|inp
operator|=
name|bhnd_nvram_val_bytes
argument_list|(
name|value
argument_list|,
operator|&
name|ilen
argument_list|,
operator|&
name|itype
argument_list|)
expr_stmt|;
if|if
condition|(
name|bhnd_nvram_ident_octet_string
argument_list|(
name|inp
argument_list|,
name|ilen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
name|array_fmt
operator|=
operator|&
name|bhnd_nvram_val_bcm_macaddr_string_fmt
expr_stmt|;
else|else
name|array_fmt
operator|=
operator|&
name|bhnd_nvram_val_bcm_string_csv_fmt
expr_stmt|;
comment|/* Wrap in array-typed representation */
name|error
operator|=
name|bhnd_nvram_val_init
argument_list|(
operator|&
name|array
argument_list|,
name|array_fmt
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|,
name|BHND_NVRAM_VAL_BORROW_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error initializing array representation: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Ask the array-typed value to perform the encode */
name|error
operator|=
name|bhnd_nvram_val_encode
argument_list|(
operator|&
name|array
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|BHND_NV_LOG
argument_list|(
literal|"error encoding array representation: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bhnd_nvram_val_release
argument_list|(
operator|&
name|array
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Broadcom NVRAM comma-delimited string filter.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_val_bcmstr_csv_filter
parameter_list|(
specifier|const
name|bhnd_nvram_val_fmt_t
modifier|*
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|)
block|{
switch|switch
condition|(
name|itype
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_STRING
case|:
case|case
name|BHND_NVRAM_TYPE_STRING_ARRAY
case|:
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Broadcom NVRAM comma-delimited string iteration.  */
end_comment

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|bhnd_nvram_val_bcmstr_csv_next
parameter_list|(
name|bhnd_nvram_val_t
modifier|*
name|value
parameter_list|,
specifier|const
name|void
modifier|*
name|prev
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|inp
decl_stmt|;
name|bhnd_nvram_type
name|itype
decl_stmt|;
name|size_t
name|ilen
decl_stmt|,
name|remain
decl_stmt|;
name|char
name|delim
decl_stmt|;
comment|/* Fetch backing representation */
name|inp
operator|=
name|bhnd_nvram_val_bytes
argument_list|(
name|value
argument_list|,
operator|&
name|ilen
argument_list|,
operator|&
name|itype
argument_list|)
expr_stmt|;
comment|/* Fetch next value */
switch|switch
condition|(
name|itype
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_STRING
case|:
comment|/* Zero-length array? */
if|if
condition|(
name|ilen
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
comment|/* First element */
name|next
operator|=
name|inp
expr_stmt|;
name|remain
operator|=
name|ilen
expr_stmt|;
name|delim
operator|=
literal|','
expr_stmt|;
block|}
else|else
block|{
comment|/* Advance to the previous element's delimiter */
name|next
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|prev
operator|+
operator|*
name|len
expr_stmt|;
comment|/* Did we hit the end of the string? */
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|next
operator|-
name|inp
argument_list|)
operator|>=
name|ilen
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Fetch (and skip past) the delimiter */
name|delim
operator|=
operator|*
name|next
expr_stmt|;
name|next
operator|++
expr_stmt|;
name|remain
operator|=
name|ilen
operator|-
call|(
name|size_t
call|)
argument_list|(
name|next
operator|-
name|inp
argument_list|)
expr_stmt|;
comment|/* Was the delimiter the final character? */
if|if
condition|(
name|remain
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Parse the field value, up to the next delimiter */
operator|*
name|len
operator|=
name|bhnd_nvram_parse_field
argument_list|(
operator|&
name|next
argument_list|,
name|remain
argument_list|,
name|delim
argument_list|)
expr_stmt|;
return|return
operator|(
name|next
operator|)
return|;
case|case
name|BHND_NVRAM_TYPE_STRING_ARRAY
case|:
name|next
operator|=
name|bhnd_nvram_string_array_next
argument_list|(
name|inp
argument_list|,
name|ilen
argument_list|,
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
operator|*
name|len
operator|=
name|strlen
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* Account for trailing NUL */
if|if
condition|(
operator|*
name|len
operator|+
call|(
name|size_t
call|)
argument_list|(
name|next
operator|-
name|inp
argument_list|)
operator|<
name|ilen
condition|)
operator|(
operator|*
name|len
operator|)
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|next
operator|)
return|;
default|default:
name|BHND_NV_PANIC
argument_list|(
literal|"unsupported type: %d"
argument_list|,
name|itype
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * MAC address filter.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_val_bcm_macaddr_filter
parameter_list|(
specifier|const
name|bhnd_nvram_val_fmt_t
modifier|*
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|)
block|{
switch|switch
condition|(
name|itype
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_UINT8_ARRAY
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|BHND_NVRAM_TYPE_STRING
case|:
comment|/* Let bcm_macaddr_string format handle it */
operator|*
name|fmt
operator|=
operator|&
name|bhnd_nvram_val_bcm_macaddr_string_fmt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * MAC address encoding.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_val_bcm_macaddr_encode
parameter_list|(
name|bhnd_nvram_val_t
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|inp
decl_stmt|;
name|bhnd_nvram_type
name|itype
decl_stmt|;
name|size_t
name|ilen
decl_stmt|;
comment|/* 	 * If converting to a string (or a single-element string array), 	 * produce an octet string (00:00:...). 	 */
if|if
condition|(
name|bhnd_nvram_base_type
argument_list|(
name|otype
argument_list|)
operator|==
name|BHND_NVRAM_TYPE_STRING
condition|)
block|{
return|return
operator|(
name|bhnd_nvram_val_printf
argument_list|(
name|value
argument_list|,
literal|"%[]02hhX"
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
literal|":"
argument_list|)
operator|)
return|;
block|}
comment|/* Otherwise, use standard encoding support */
name|inp
operator|=
name|bhnd_nvram_val_bytes
argument_list|(
name|value
argument_list|,
operator|&
name|ilen
argument_list|,
operator|&
name|itype
argument_list|)
expr_stmt|;
return|return
operator|(
name|bhnd_nvram_value_coerce
argument_list|(
name|inp
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * MAC address string filter.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_val_bcm_macaddr_string_filter
parameter_list|(
specifier|const
name|bhnd_nvram_val_fmt_t
modifier|*
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|)
block|{
switch|switch
condition|(
name|itype
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_STRING
case|:
comment|/* Use the standard Broadcom string format implementation if 		 * the input is not an octet string. */
if|if
condition|(
operator|!
name|bhnd_nvram_ident_octet_string
argument_list|(
name|inp
argument_list|,
name|ilen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
operator|*
name|fmt
operator|=
operator|&
name|bhnd_nvram_val_bcm_string_fmt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * MAC address string octet encoding.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_val_bcm_macaddr_string_encode_elem
parameter_list|(
name|bhnd_nvram_val_t
modifier|*
name|value
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
block|{
name|size_t
name|nparsed
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* If integer encoding is requested, explicitly parse our 	 * non-0x-prefixed as a base 16 integer value */
if|if
condition|(
name|bhnd_nvram_is_int_type
argument_list|(
name|otype
argument_list|)
condition|)
block|{
name|error
operator|=
name|bhnd_nvram_parse_int
argument_list|(
name|inp
argument_list|,
name|ilen
argument_list|,
literal|16
argument_list|,
operator|&
name|nparsed
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nparsed
operator|!=
name|ilen
condition|)
return|return
operator|(
name|EFTYPE
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Otherwise, use standard encoding support */
return|return
operator|(
name|bhnd_nvram_value_coerce
argument_list|(
name|inp
argument_list|,
name|ilen
argument_list|,
name|bhnd_nvram_val_elem_type
argument_list|(
name|value
argument_list|)
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * MAC address string octet iteration.  */
end_comment

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|bhnd_nvram_val_bcm_macaddr_string_next
parameter_list|(
name|bhnd_nvram_val_t
modifier|*
name|value
parameter_list|,
specifier|const
name|void
modifier|*
name|prev
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|bhnd_nvram_type
name|stype
decl_stmt|;
name|size_t
name|slen
decl_stmt|,
name|remain
decl_stmt|;
name|char
name|delim
decl_stmt|;
comment|/* Fetch backing string */
name|str
operator|=
name|bhnd_nvram_val_bytes
argument_list|(
name|value
argument_list|,
operator|&
name|slen
argument_list|,
operator|&
name|stype
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|stype
operator|==
name|BHND_NVRAM_TYPE_STRING
argument_list|,
operator|(
literal|"unsupported type: %d"
operator|,
name|stype
operator|)
argument_list|)
expr_stmt|;
comment|/* Zero-length array? */
if|if
condition|(
name|slen
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
comment|/* First element */
comment|/* Determine delimiter */
if|if
condition|(
operator|!
name|bhnd_nvram_ident_octet_string
argument_list|(
name|str
argument_list|,
name|slen
argument_list|,
operator|&
name|delim
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
comment|/* Default to comma-delimited parsing */
name|delim
operator|=
literal|','
expr_stmt|;
block|}
comment|/* Parsing will start at the base string pointer */
name|next
operator|=
name|str
expr_stmt|;
name|remain
operator|=
name|slen
expr_stmt|;
block|}
else|else
block|{
comment|/* Advance to the previous element's delimiter */
name|next
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|prev
operator|+
operator|*
name|len
expr_stmt|;
comment|/* Did we hit the end of the string? */
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|next
operator|-
name|str
argument_list|)
operator|>=
name|slen
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Fetch (and skip past) the delimiter */
name|delim
operator|=
operator|*
name|next
expr_stmt|;
name|next
operator|++
expr_stmt|;
name|remain
operator|=
name|slen
operator|-
call|(
name|size_t
call|)
argument_list|(
name|next
operator|-
name|str
argument_list|)
expr_stmt|;
comment|/* Was the delimiter the final character? */
if|if
condition|(
name|remain
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Parse the field value, up to the next delimiter */
operator|*
name|len
operator|=
name|bhnd_nvram_parse_field
argument_list|(
operator|&
name|next
argument_list|,
name|remain
argument_list|,
name|delim
argument_list|)
expr_stmt|;
return|return
operator|(
name|next
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Determine whether @p inp is in octet string format, consisting of a  * fields of two hex characters, separated with ':' or '-' delimiters.  *   * This may be used to identify MAC address octet strings  * (BHND_NVRAM_SFMT_MACADDR).  *  * @param		inp	The string to be parsed.  * @param		ilen	The length of @p inp, in bytes.  * @param[out]		delim	On success, the delimiter used by this octet  * 				string. May be set to NULL if the field  *				delimiter is not desired.  * @param[out]		nelem	On success, the number of fields in this  *				octet string. May be set to NULL if the field  *				count is not desired.  *  *   * @retval true		if @p inp is a valid octet string  * @retval false	if @p inp is not a valid octet string.  */
end_comment

begin_function
specifier|static
name|bool
name|bhnd_nvram_ident_octet_string
parameter_list|(
specifier|const
name|char
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|char
modifier|*
name|delim
parameter_list|,
name|size_t
modifier|*
name|nelem
parameter_list|)
block|{
name|size_t
name|elem_count
decl_stmt|;
name|size_t
name|max_elem_count
decl_stmt|,
name|min_elem_count
decl_stmt|;
name|size_t
name|field_count
decl_stmt|;
name|char
name|idelim
decl_stmt|;
name|field_count
operator|=
literal|0
expr_stmt|;
comment|/* Require exactly two digits. If we relax this, there is room 	 * for ambiguity with signed integers and the '-' delimiter */
name|min_elem_count
operator|=
literal|2
expr_stmt|;
name|max_elem_count
operator|=
literal|2
expr_stmt|;
comment|/* Identify the delimiter used. The standard delimiter for MAC 	 * addresses is ':', but some earlier NVRAM formats may use '-' */
for|for
control|(
specifier|const
name|char
modifier|*
name|d
init|=
literal|":-"
init|;
condition|;
name|d
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|loc
decl_stmt|;
comment|/* No delimiter found, not an octet string */
if|if
condition|(
operator|*
name|d
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Look for the delimiter */
if|if
condition|(
operator|(
name|loc
operator|=
name|memchr
argument_list|(
name|inp
argument_list|,
operator|*
name|d
argument_list|,
name|ilen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Delimiter found */
name|idelim
operator|=
operator|*
name|loc
expr_stmt|;
break|break;
block|}
comment|/* To disambiguate from signed integers, if the delimiter is "-", 	 * the octets must be exactly 2 chars each */
if|if
condition|(
name|idelim
operator|==
literal|'-'
condition|)
name|min_elem_count
operator|=
literal|2
expr_stmt|;
comment|/* String must be composed of individual octets (zero or more hex 	 * digits) separated by our delimiter. */
name|elem_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
specifier|const
name|char
modifier|*
name|p
init|=
name|inp
init|;
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|inp
argument_list|)
operator|<
name|ilen
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|':'
case|:
case|case
literal|'-'
case|:
case|case
literal|'\0'
case|:
comment|/* Hit a delim character; all delims must match 			 * the first delimiter used */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
name|idelim
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Must have parsed at least min_elem_count digits */
if|if
condition|(
name|elem_count
operator|<
name|min_elem_count
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Reset element count */
name|elem_count
operator|=
literal|0
expr_stmt|;
comment|/* Bump field count */
name|field_count
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* More than maximum number of hex digits? */
if|if
condition|(
name|elem_count
operator|>=
name|max_elem_count
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Octet values must be hex digits */
if|if
condition|(
operator|!
name|bhnd_nv_isxdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|elem_count
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|delim
operator|!=
name|NULL
condition|)
operator|*
name|delim
operator|=
name|idelim
expr_stmt|;
if|if
condition|(
name|nelem
operator|!=
name|NULL
condition|)
operator|*
name|nelem
operator|=
name|field_count
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Determine whether @p inp is in hexadecimal, octal, or decimal string  * format.  *  * - A @p str may be prefixed with a single optional '+' or '-' sign denoting  *   signedness.  * - A hexadecimal @p str may include an '0x' or '0X' prefix, denoting that a  *   base 16 integer follows.  * - An octal @p str may include a '0' prefix, denoting that an octal integer  *   follows.  *   * @param	inp	The string to be parsed.  * @param	ilen	The length of @p inp, in bytes.  * @param	base	The input string's base (2-36), or 0.  * @param[out]	obase	On success, will be set to the base of the parsed  *			integer. May be set to NULL if the base is not  *			desired.  *  * @retval true		if @p inp is a valid number string  * @retval false	if @p inp is not a valid number string.  * @retval false	if @p base is invalid.  */
end_comment

begin_function
specifier|static
name|bool
name|bhnd_nvram_ident_num_string
parameter_list|(
specifier|const
name|char
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|u_int
name|base
parameter_list|,
name|u_int
modifier|*
name|obase
parameter_list|)
block|{
name|size_t
name|nbytes
decl_stmt|,
name|ndigits
decl_stmt|;
name|nbytes
operator|=
literal|0
expr_stmt|;
name|ndigits
operator|=
literal|0
expr_stmt|;
comment|/* Parse and skip sign */
if|if
condition|(
name|nbytes
operator|>=
name|ilen
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|inp
index|[
name|nbytes
index|]
operator|==
literal|'-'
operator|||
name|inp
index|[
name|nbytes
index|]
operator|==
literal|'+'
condition|)
name|nbytes
operator|++
expr_stmt|;
comment|/* Truncated after sign character? */
if|if
condition|(
name|nbytes
operator|==
name|ilen
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Identify (or validate) hex base, skipping 0x/0X prefix */
if|if
condition|(
name|base
operator|==
literal|16
operator|||
name|base
operator|==
literal|0
condition|)
block|{
comment|/* Check for (and skip) 0x/0X prefix */
if|if
condition|(
name|ilen
operator|-
name|nbytes
operator|>=
literal|2
operator|&&
name|inp
index|[
name|nbytes
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|inp
index|[
name|nbytes
operator|+
literal|1
index|]
operator|==
literal|'x'
operator|||
name|inp
index|[
name|nbytes
operator|+
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
name|nbytes
operator|+=
literal|2
expr_stmt|;
block|}
block|}
comment|/* Truncated after hex prefix? */
if|if
condition|(
name|nbytes
operator|==
name|ilen
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Differentiate decimal/octal by looking for a leading 0 */
if|if
condition|(
name|base
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|inp
index|[
name|nbytes
index|]
operator|==
literal|'0'
condition|)
block|{
name|base
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
literal|10
expr_stmt|;
block|}
block|}
comment|/* Consume and validate all remaining digit characters */
for|for
control|(
init|;
name|nbytes
operator|<
name|ilen
condition|;
name|nbytes
operator|++
control|)
block|{
name|u_int
name|carry
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Parse carry value */
name|c
operator|=
name|inp
index|[
name|nbytes
index|]
expr_stmt|;
if|if
condition|(
name|bhnd_nv_isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|carry
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bhnd_nv_isxdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|bhnd_nv_isupper
argument_list|(
name|c
argument_list|)
condition|)
name|carry
operator|=
operator|(
name|c
operator|-
literal|'A'
operator|)
operator|+
literal|10
expr_stmt|;
else|else
name|carry
operator|=
operator|(
name|c
operator|-
literal|'a'
operator|)
operator|+
literal|10
expr_stmt|;
block|}
else|else
block|{
comment|/* Hit a non-digit character */
return|return
operator|(
name|false
operator|)
return|;
block|}
comment|/* If carry is outside the base, it's not a valid digit 		 * in the current parse context; consider it a non-digit 		 * character */
if|if
condition|(
name|carry
operator|>=
name|base
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Increment parsed digit count */
name|ndigits
operator|++
expr_stmt|;
block|}
comment|/* Empty integer string? */
if|if
condition|(
name|ndigits
operator|==
literal|0
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Valid integer -- provide the base and return */
if|if
condition|(
name|obase
operator|!=
name|NULL
condition|)
operator|*
name|obase
operator|=
name|base
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

end_unit

