begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Landon Fuller<landonf@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_parserreg.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_parservar.h"
end_include

begin_comment
comment|/*  * BHND NVRAM Parser  *   * Provides identification, decoding, and encoding of BHND NVRAM data.  */
end_comment

begin_function_decl
specifier|static
specifier|const
name|struct
name|bhnd_nvram_ops
modifier|*
name|bhnd_nvram_find_ops
parameter_list|(
name|bhnd_nvram_format
name|fmt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_find_var
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|value
parameter_list|,
name|size_t
modifier|*
name|value_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_keycmp
parameter_list|(
specifier|const
name|char
modifier|*
name|lhs
parameter_list|,
name|size_t
name|lhs_len
parameter_list|,
specifier|const
name|char
modifier|*
name|rhs
parameter_list|,
name|size_t
name|rhs_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_sort_idx
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_generate_index
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_index_lookup
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
name|struct
name|bhnd_nvram_idx
modifier|*
name|idx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|env
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|value
parameter_list|,
name|size_t
modifier|*
name|value_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_buffer_lookup
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|env
parameter_list|,
name|size_t
modifier|*
name|env_len
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|value
parameter_list|,
name|size_t
modifier|*
name|value_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|bhnd_nvram_bufptr_valid
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|nbytes
parameter_list|,
name|bool
name|log_error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_parse_env
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|env
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|key
parameter_list|,
name|size_t
modifier|*
name|key_len
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|val
parameter_list|,
name|size_t
modifier|*
name|val_len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Calculate the size of the NVRAM data in @p data.  *   * @param		data	Pointer to NVRAM data to be parsed.  * @param[in,out]	size	On input, the total size of @p data. On  *				successful parsing of @p data, will be set to  *				the parsed size (which may be larger).  */
end_comment

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|bhnd_nvram_op_getsize
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/** Perform format-specific initialization. */
end_comment

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|bhnd_nvram_op_init
function_decl|)
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/** Initialize any format-specific default values. */
end_comment

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|bhnd_nvram_op_init_defaults
function_decl|)
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|bhnd_nvram_op_enum_buf
function_decl|)
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|env
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint8_t
specifier|const
modifier|*
modifier|*
name|next
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* FMT_BCM ops */
end_comment

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_bcm_getsize
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_bcm_init
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_bcm_init_defaults
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_bcm_enum_buf
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|env
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint8_t
specifier|const
modifier|*
modifier|*
name|next
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* FMT_TLV ops */
end_comment

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_tlv_getsize
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_tlv_init
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_tlv_enum_buf
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|env
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint8_t
specifier|const
modifier|*
modifier|*
name|next
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* FMT_TXT ops */
end_comment

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_txt_getsize
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_txt_init
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_txt_enum_buf
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|env
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint8_t
specifier|const
modifier|*
modifier|*
name|next
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Format-specific operations.  */
end_comment

begin_struct
struct|struct
name|bhnd_nvram_ops
block|{
name|bhnd_nvram_format
name|fmt
decl_stmt|;
comment|/**< nvram format */
name|bhnd_nvram_op_getsize
name|getsize
decl_stmt|;
comment|/**< determine actual NVRAM size */
name|bhnd_nvram_op_init
name|init
decl_stmt|;
comment|/**< format-specific initialization */
name|bhnd_nvram_op_enum_buf
name|enum_buf
decl_stmt|;
comment|/**< enumerate backing buffer */
name|bhnd_nvram_op_init_defaults
name|init_defaults
decl_stmt|;
comment|/**< populate any default values */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bhnd_nvram_ops
name|bhnd_nvram_ops_table
index|[]
init|=
block|{
block|{
name|BHND_NVRAM_FMT_BCM
block|,
name|bhnd_nvram_bcm_getsize
block|,
name|bhnd_nvram_bcm_init
block|,
name|bhnd_nvram_bcm_enum_buf
block|,
name|bhnd_nvram_bcm_init_defaults
block|}
block|,
block|{
name|BHND_NVRAM_FMT_TLV
block|,
name|bhnd_nvram_tlv_getsize
block|,
name|bhnd_nvram_tlv_init
block|,
name|bhnd_nvram_tlv_enum_buf
block|,
name|NULL
block|}
block|,
block|{
name|BHND_NVRAM_FMT_BTXT
block|,
name|bhnd_nvram_txt_getsize
block|,
name|bhnd_nvram_txt_init
block|,
name|bhnd_nvram_txt_enum_buf
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NVRAM_LOG
parameter_list|(
name|sc
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {			\ 	if (sc->dev != NULL)					\ 		device_printf(sc->dev, fmt, ##__VA_ARGS__);	\ 	else							\ 		printf("bhnd_nvram: " fmt, ##__VA_ARGS__);	\ } while (0)
end_define

begin_comment
comment|/* Limit a size_t value to a suitable range for use as a printf string field  * width */
end_comment

begin_define
define|#
directive|define
name|NVRAM_PRINT_WIDTH
parameter_list|(
name|_len
parameter_list|)
define|\
value|((_len)> NVRAM_VAL_MAX ? NVRAM_VAL_MAX : (int)(_len))
end_define

begin_comment
comment|/* Is _c a field terminating/delimiting character? */
end_comment

begin_define
define|#
directive|define
name|nvram_is_ftermc
parameter_list|(
name|_c
parameter_list|)
value|((_c) == '\0' || nvram_is_fdelim(_c))
end_define

begin_comment
comment|/* Is _c a field delimiting character? */
end_comment

begin_define
define|#
directive|define
name|nvram_is_fdelim
parameter_list|(
name|_c
parameter_list|)
value|((_c) == ',')
end_define

begin_comment
comment|/**  * Identify @p ident.  *   * @param ident Initial header data to be used for identification.  * @param expected Expected format against which @p ident will be tested.  *   * @retval 0 If @p ident has the @p expected format.  * @retval ENODEV If @p ident does not match @p expected.  */
end_comment

begin_function
name|int
name|bhnd_nvram_parser_identify
parameter_list|(
specifier|const
name|union
name|bhnd_nvram_ident
modifier|*
name|ident
parameter_list|,
name|bhnd_nvram_format
name|expected
parameter_list|)
block|{
name|uint32_t
name|bcm_magic
init|=
name|le32toh
argument_list|(
name|ident
operator|->
name|bcm
operator|.
name|magic
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|expected
condition|)
block|{
case|case
name|BHND_NVRAM_FMT_BCM
case|:
if|if
condition|(
name|bcm_magic
operator|==
name|NVRAM_MAGIC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ENODEV
operator|)
return|;
case|case
name|BHND_NVRAM_FMT_TLV
case|:
if|if
condition|(
name|bcm_magic
operator|==
name|NVRAM_MAGIC
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
name|ident
operator|->
name|tlv
operator|.
name|tag
operator|!=
name|NVRAM_TLV_TYPE_ENV
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|BHND_NVRAM_FMT_BTXT
case|:
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|ident
operator|->
name|btxt
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|ident
operator|->
name|btxt
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: unknown format: %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|expected
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/** Return the set of operations for @p fmt, if any */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|bhnd_nvram_ops
modifier|*
name|bhnd_nvram_find_ops
parameter_list|(
name|bhnd_nvram_format
name|fmt
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_nvram_ops
modifier|*
name|ops
decl_stmt|;
comment|/* Fetch format-specific operation callbacks */
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|bhnd_nvram_ops_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ops
operator|=
operator|&
name|bhnd_nvram_ops_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ops
operator|->
name|fmt
operator|!=
name|fmt
condition|)
continue|continue;
comment|/* found */
return|return
operator|(
name|ops
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Identify the NVRAM format at @p offset within @p r, verify the  * CRC (if applicable), and allocate a local shadow copy of the NVRAM data.  *   * After initialization, no reference to @p input will be held by the  * NVRAM parser, and @p input may be safely deallocated.  *   * @param[out] sc The NVRAM parser state to be initialized.  * @param dev The parser's parent device, or NULL if none.  * @param data NVRAM data to be parsed.  * @param size Size of @p data.  * @param fmt Required format of @p input.  *   * @retval 0 success  * @retval ENOMEM If internal allocation of NVRAM state fails.  * @retval EINVAL If @p input parsing fails.  */
end_comment

begin_function
name|int
name|bhnd_nvram_parser_init
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bhnd_nvram_format
name|fmt
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Initialize NVRAM state */
name|memset
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|devpaths
argument_list|)
expr_stmt|;
comment|/* Verify data format and init operation callbacks */
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
expr|union
name|bhnd_nvram_ident
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|bhnd_nvram_parser_identify
argument_list|(
operator|(
specifier|const
expr|union
name|bhnd_nvram_ident
operator|*
operator|)
name|data
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|sc
operator|->
name|ops
operator|=
name|bhnd_nvram_find_ops
argument_list|(
name|fmt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NVRAM_LOG
argument_list|(
name|sc
argument_list|,
literal|"unsupported format: %d\n"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Determine appropriate size for backing buffer */
name|sc
operator|->
name|buf_size
operator|=
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sc
operator|->
name|ops
operator|->
name|getsize
argument_list|(
name|data
argument_list|,
operator|&
name|sc
operator|->
name|buf_size
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|buf_size
operator|>
name|size
condition|)
block|{
name|NVRAM_LOG
argument_list|(
name|sc
argument_list|,
literal|"cannot parse %zu NVRAM bytes, would overrun "
literal|"%zu byte input buffer\n"
argument_list|,
name|sc
operator|->
name|buf_size
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Allocate and populate backing buffer */
name|sc
operator|->
name|buf
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|buf_size
argument_list|,
name|M_BHND_NVRAM
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|memcpy
argument_list|(
name|sc
operator|->
name|buf
argument_list|,
name|data
argument_list|,
name|sc
operator|->
name|buf_size
argument_list|)
expr_stmt|;
comment|/* Allocate default/pending variable hash tables */
name|error
operator|=
name|bhnd_nvram_varmap_init
argument_list|(
operator|&
name|sc
operator|->
name|defaults
argument_list|,
name|NVRAM_SMALL_HASH_SIZE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
name|error
operator|=
name|bhnd_nvram_varmap_init
argument_list|(
operator|&
name|sc
operator|->
name|pending
argument_list|,
name|NVRAM_SMALL_HASH_SIZE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Perform format-specific initialization */
if|if
condition|(
operator|(
name|error
operator|=
name|sc
operator|->
name|ops
operator|->
name|init
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Generate all indices */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_generate_index
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Add any format-specific default values */
if|if
condition|(
name|sc
operator|->
name|ops
operator|->
name|init_defaults
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|sc
operator|->
name|ops
operator|->
name|init_defaults
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|cleanup
label|:
name|bhnd_nvram_parser_fini
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Release all resources held by @p sc.  *   * @param sc A NVRAM instance previously initialized via  * bhnd_nvram_parser_init().  */
end_comment

begin_function
name|void
name|bhnd_nvram_parser_fini
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bhnd_nvram_devpath
modifier|*
name|dpath
decl_stmt|,
modifier|*
name|dnext
decl_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|dpath
argument_list|,
argument|&sc->devpaths
argument_list|,
argument|dp_link
argument_list|,
argument|dnext
argument_list|)
block|{
name|free
argument_list|(
name|dpath
operator|->
name|path
argument_list|,
name|M_BHND_NVRAM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dpath
argument_list|,
name|M_BHND_NVRAM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|defaults
operator|.
name|table
operator|!=
name|NULL
condition|)
name|bhnd_nvram_varmap_free
argument_list|(
operator|&
name|sc
operator|->
name|defaults
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pending
operator|.
name|table
operator|!=
name|NULL
condition|)
name|bhnd_nvram_varmap_free
argument_list|(
operator|&
name|sc
operator|->
name|pending
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|idx
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|idx
argument_list|,
name|M_BHND_NVRAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|buf
argument_list|,
name|M_BHND_NVRAM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Identify the integer format of @p field.  *  * @param field Field to be identified.  * @param field_len Length of @p field.  * @param[out] base Integer base, or 0 if integer format unrecognized.  * @param[out] negated True if integer is prefixed with negation sign.  *   * @retval true if parsed successfully  * @retval false if the format of @p field cannot be determined.  */
end_comment

begin_function
specifier|static
name|bool
name|bhnd_nvram_identify_intfmt
parameter_list|(
specifier|const
name|char
modifier|*
name|field
parameter_list|,
name|size_t
name|field_len
parameter_list|,
name|int
modifier|*
name|base
parameter_list|,
name|bool
modifier|*
name|negated
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Hex? */
name|p
operator|=
name|field
expr_stmt|;
if|if
condition|(
name|field_len
operator|>
literal|2
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
block|{
name|bool
name|valid
decl_stmt|;
comment|/* Check all field characters */
name|valid
operator|=
name|true
expr_stmt|;
for|for
control|(
name|p
operator|=
name|field
operator|+
literal|2
init|;
name|p
operator|-
name|field
operator|<
name|field_len
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isxdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
continue|continue;
name|valid
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|valid
condition|)
block|{
operator|*
name|base
operator|=
literal|16
expr_stmt|;
operator|*
name|negated
operator|=
name|false
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
block|}
comment|/* Decimal? */
name|p
operator|=
name|field
expr_stmt|;
if|if
condition|(
name|field_len
operator|>=
literal|1
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'-'
operator|||
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
block|{
name|bool
name|valid
decl_stmt|;
name|valid
operator|=
name|true
expr_stmt|;
operator|*
name|negated
operator|=
name|false
expr_stmt|;
for|for
control|(
name|p
operator|=
name|field
init|;
name|p
operator|-
name|field
operator|<
name|field_len
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|==
name|field
operator|&&
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
operator|*
name|negated
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
continue|continue;
name|valid
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|valid
condition|)
block|{
operator|*
name|base
operator|=
literal|10
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
block|}
comment|/* No match */
operator|*
name|base
operator|=
literal|0
expr_stmt|;
operator|*
name|negated
operator|=
name|false
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Search for a field delimiter or '\0' in @p value, returning the  * size of the first field (not including its terminating character).  *   * If no terminating character is found, @p value_len is returned.  *   * @param value The value to be searched.  * @param value_size The size of @p value.  */
end_comment

begin_function
specifier|static
name|size_t
name|bhnd_nvram_parse_field_len
parameter_list|(
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|size_t
name|value_size
parameter_list|)
block|{
for|for
control|(
specifier|const
name|char
modifier|*
name|p
init|=
name|value
init|;
name|p
operator|-
name|value
operator|<
name|value_size
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|nvram_is_ftermc
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
operator|(
name|p
operator|-
name|value
operator|)
return|;
block|}
return|return
operator|(
name|value_size
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a string NVRAM variable, writing the NUL-terminated result  * to buf (if non-NULL). */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_parse_strvar
parameter_list|(
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|size_t
name|value_len
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|size_t
name|str_len
decl_stmt|;
name|size_t
name|req_size
decl_stmt|;
name|size_t
name|max_size
decl_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|max_size
operator|=
operator|*
name|size
expr_stmt|;
else|else
name|max_size
operator|=
literal|0
expr_stmt|;
comment|/* Determine input and output sizes, including whether additional space 	 * is required for a trailing NUL */
name|str_len
operator|=
name|strnlen
argument_list|(
name|value
argument_list|,
name|value_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_len
operator|==
name|value_len
condition|)
name|req_size
operator|=
name|str_len
operator|+
literal|1
expr_stmt|;
else|else
name|req_size
operator|=
name|value_len
expr_stmt|;
comment|/* Provide actual size to caller */
operator|*
name|size
operator|=
name|req_size
expr_stmt|;
if|if
condition|(
name|max_size
operator|<
name|req_size
condition|)
block|{
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Copy and NUL terminate output */
name|memcpy
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
name|str_len
argument_list|)
expr_stmt|;
name|buf
index|[
name|str_len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read an NVRAM variable.  *  * @param		sc	The NVRAM parser state.  * @param		name	The NVRAM variable name.  * @param[out]		buf	On success, the requested value will be written  *				to this buffer. This argment may be NULL if  *				the value is not desired.  * @param[in,out]	len	The capacity of @p buf. On success, will be set  *				to the actual size of the requested value.  * @param		type	The requested data type to be written to @p buf.  *  * @retval 0		success  * @retval ENOENT	The requested variable was not found.  * @retval ENOMEM	If @p buf is non-NULL and a buffer of @p len is too  *			small to hold the requested value.  * @retval non-zero	If reading @p name otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_nvram_parser_getvar
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|bhnd_nvram_type
name|type
parameter_list|)
block|{
name|char
modifier|*
name|cstr
decl_stmt|,
name|cstr_buf
index|[
name|NVRAM_VAL_MAX
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|size_t
name|cstr_size
decl_stmt|;
name|size_t
name|limit
decl_stmt|,
name|nbytes
decl_stmt|;
name|size_t
name|field_len
decl_stmt|,
name|val_len
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Verify name validity */
if|if
condition|(
operator|!
name|bhnd_nvram_validate_name
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Fetch variable's string value */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_find_var
argument_list|(
name|sc
argument_list|,
name|name
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|val_len
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|nbytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|limit
operator|=
operator|*
name|len
expr_stmt|;
else|else
name|limit
operator|=
literal|0
expr_stmt|;
comment|/* Populate C string requests directly from the fetched value */
if|if
condition|(
name|type
operator|==
name|BHND_NVRAM_TYPE_CSTR
condition|)
return|return
operator|(
name|bhnd_nvram_parse_strvar
argument_list|(
name|val
argument_list|,
name|val_len
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|)
return|;
comment|/* Determine actual string length. */
name|val_len
operator|=
name|strnlen
argument_list|(
name|val
argument_list|,
name|val_len
argument_list|)
expr_stmt|;
comment|/* Try parsing as an octet string value (e.g. a MAC address) */
if|if
condition|(
name|bhnd_nvram_parse_octet_string
argument_list|(
name|val
argument_list|,
name|val_len
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|type
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Otherwise, we need a NUL-terminated copy of the string value 	 * for parsing */
name|cstr_size
operator|=
name|val_len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cstr_size
operator|<=
sizeof|sizeof
argument_list|(
name|cstr
argument_list|)
condition|)
block|{
comment|/* prefer stack allocated buffer */
name|cstr
operator|=
name|cstr_buf
expr_stmt|;
block|}
else|else
block|{
name|cstr
operator|=
name|malloc
argument_list|(
name|cstr_size
argument_list|,
name|M_BHND_NVRAM
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cstr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
block|}
comment|/* Copy and NUL terminate */
name|strncpy
argument_list|(
name|cstr
argument_list|,
name|val
argument_list|,
name|val_len
argument_list|)
expr_stmt|;
name|cstr
index|[
name|val_len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Parse */
for|for
control|(
name|char
modifier|*
name|p
init|=
name|cstr
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
control|)
block|{
name|char
modifier|*
name|endp
decl_stmt|;
name|int
name|base
decl_stmt|;
name|bool
name|is_int
decl_stmt|,
name|is_negated
decl_stmt|;
union|union
block|{
name|unsigned
name|long
name|u32
decl_stmt|;
name|long
name|s32
decl_stmt|;
block|}
name|intv
union|;
comment|/* Determine the field length */
name|field_len
operator|=
name|val_len
operator|-
operator|(
name|p
operator|-
name|cstr
operator|)
expr_stmt|;
name|field_len
operator|=
name|bhnd_nvram_parse_field_len
argument_list|(
name|p
argument_list|,
name|field_len
argument_list|)
expr_stmt|;
comment|/* Skip any leading whitespace */
while|while
condition|(
name|field_len
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|field_len
operator|--
expr_stmt|;
block|}
comment|/* Empty field values cannot be parsed as a fixed 		 * data type */
if|if
condition|(
name|field_len
operator|==
literal|0
condition|)
block|{
name|NVRAM_LOG
argument_list|(
name|sc
argument_list|,
literal|"error: cannot parse empty string in "
literal|"'%s'\n"
argument_list|,
name|cstr
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
comment|/* Attempt to identify the integer format */
name|is_int
operator|=
name|bhnd_nvram_identify_intfmt
argument_list|(
name|p
argument_list|,
name|field_len
argument_list|,
operator|&
name|base
argument_list|,
operator|&
name|is_negated
argument_list|)
expr_stmt|;
comment|/* Extract the field data */
define|#
directive|define
name|NV_READ_INT
parameter_list|(
name|_ctype
parameter_list|,
name|_max
parameter_list|,
name|_min
parameter_list|,
name|_dest
parameter_list|,
name|_strto
parameter_list|)
value|do {		\ 	if (!is_int) {							\ 		error = EFTYPE;						\ 		goto finished;						\ 	}								\ 									\ 	if (is_negated&& _min == 0) {					\ 		error = ERANGE;						\ 		goto finished;						\ 	}								\ 									\ 	_dest = _strto(p,&endp, base);					\ 	if (endp == p || !nvram_is_ftermc(*endp)) {			\ 		error = ERANGE;						\ 		goto finished;						\ 	}								\ 									\ 	if (_dest> _max || _dest< _min) {				\ 		error = ERANGE;						\ 		goto finished;						\ 	}								\ 									\ 	if (limit> nbytes&& limit - nbytes>= sizeof(_ctype))		\ 		*((_ctype *)((uint8_t *)buf + nbytes)) = _dest;		\ 									\ 	nbytes += sizeof(_ctype);					\ } while(0)
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_CHAR
case|:
comment|/* Copy out the characters directly */
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|field_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|limit
operator|>
name|nbytes
condition|)
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|nbytes
operator|)
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
name|nbytes
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT8
case|:
name|NV_READ_INT
argument_list|(
name|uint8_t
argument_list|,
name|UINT8_MAX
argument_list|,
literal|0
argument_list|,
name|intv
operator|.
name|u32
argument_list|,
name|strtoul
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT16
case|:
name|NV_READ_INT
argument_list|(
name|uint16_t
argument_list|,
name|UINT16_MAX
argument_list|,
literal|0
argument_list|,
name|intv
operator|.
name|u32
argument_list|,
name|strtoul
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT32
case|:
name|NV_READ_INT
argument_list|(
name|uint32_t
argument_list|,
name|UINT32_MAX
argument_list|,
literal|0
argument_list|,
name|intv
operator|.
name|u32
argument_list|,
name|strtoul
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_INT8
case|:
name|NV_READ_INT
argument_list|(
name|int8_t
argument_list|,
name|INT8_MAX
argument_list|,
name|INT8_MIN
argument_list|,
name|intv
operator|.
name|s32
argument_list|,
name|strtol
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_INT16
case|:
name|NV_READ_INT
argument_list|(
name|int16_t
argument_list|,
name|INT16_MAX
argument_list|,
name|INT16_MIN
argument_list|,
name|intv
operator|.
name|s32
argument_list|,
name|strtol
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_INT32
case|:
name|NV_READ_INT
argument_list|(
name|int32_t
argument_list|,
name|INT32_MAX
argument_list|,
name|INT32_MIN
argument_list|,
name|intv
operator|.
name|s32
argument_list|,
name|strtol
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_CSTR
case|:
comment|/* Must be handled above */
comment|/* fallthrough */
default|default:
name|NVRAM_LOG
argument_list|(
name|sc
argument_list|,
literal|"unhandled NVRAM type: %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
comment|/* Advance to next field, skip any trailing delimiter */
name|p
operator|+=
name|field_len
expr_stmt|;
if|if
condition|(
name|nvram_is_fdelim
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|finished
label|:
if|if
condition|(
name|cstr
operator|!=
name|cstr_buf
condition|)
name|free
argument_list|(
name|cstr
argument_list|,
name|M_BHND_NVRAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Set an NVRAM variable.  *   * @param		sc	The NVRAM parser state.  * @param		name	The NVRAM variable name.  * @param[out]		buf	The new value.  * @param[in,out]	len	The size of @p buf.  * @param		type	The data type of @p buf.  *  * @retval 0		success  * @retval ENOENT	The requested variable was not found.  * @retval EINVAL	If @p len does not match the expected variable size.  */
end_comment

begin_function
name|int
name|bhnd_nvram_parser_setvar
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|bhnd_nvram_type
name|type
parameter_list|)
block|{
comment|/* Verify name validity */
if|if
condition|(
operator|!
name|bhnd_nvram_validate_name
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Verify buffer size alignment for the given type. If this is a 	 * variable width type, a width of 0 will always pass this check */
if|if
condition|(
name|len
operator|%
name|bhnd_nvram_type_width
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Determine string format (or directly add variable, if a C string) */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_UINT8
case|:
case|case
name|BHND_NVRAM_TYPE_UINT16
case|:
case|case
name|BHND_NVRAM_TYPE_UINT32
case|:
case|case
name|BHND_NVRAM_TYPE_INT8
case|:
case|case
name|BHND_NVRAM_TYPE_INT16
case|:
case|case
name|BHND_NVRAM_TYPE_INT32
case|:
comment|// TODO: primitive type value support
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
case|case
name|BHND_NVRAM_TYPE_CHAR
case|:
case|case
name|BHND_NVRAM_TYPE_CSTR
case|:
return|return
operator|(
name|bhnd_nvram_varmap_add
argument_list|(
operator|&
name|sc
operator|->
name|pending
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if @p ptr + nbytes falls within our backing buffer, false  * otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|bhnd_nvram_bufptr_valid
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|nbytes
parameter_list|,
name|bool
name|log_error
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|p
init|=
name|ptr
decl_stmt|;
if|if
condition|(
name|p
operator|<
name|sc
operator|->
name|buf
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|nbytes
operator|>
name|sc
operator|->
name|buf_size
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|p
operator|-
name|sc
operator|->
name|buf
operator|>
name|sc
operator|->
name|buf_size
operator|-
name|nbytes
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
name|true
operator|)
return|;
name|failed
label|:
if|if
condition|(
name|log_error
condition|)
name|NVRAM_LOG
argument_list|(
name|sc
argument_list|,
literal|"NVRAM record not readable at %p+%#zx (base=%p, "
literal|"len=%zu)\n"
argument_list|,
name|p
argument_list|,
name|nbytes
argument_list|,
name|sc
operator|->
name|buf
argument_list|,
name|sc
operator|->
name|buf_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Parse a 'key=value' env string.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_parse_env
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|env
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|key
parameter_list|,
name|size_t
modifier|*
name|key_len
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|val
parameter_list|,
name|size_t
modifier|*
name|val_len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Key */
if|if
condition|(
operator|(
name|p
operator|=
name|memchr
argument_list|(
name|env
argument_list|,
literal|'='
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NVRAM_LOG
argument_list|(
name|sc
argument_list|,
literal|"missing delim in '%.*s'\n"
argument_list|,
name|NVRAM_PRINT_WIDTH
argument_list|(
name|len
argument_list|)
argument_list|,
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|key
operator|=
name|env
expr_stmt|;
operator|*
name|key_len
operator|=
name|p
operator|-
name|env
expr_stmt|;
comment|/* Skip '=' */
name|p
operator|++
expr_stmt|;
comment|/* Vaue */
operator|*
name|val
operator|=
name|p
expr_stmt|;
operator|*
name|val_len
operator|=
name|len
operator|-
operator|(
name|p
operator|-
name|env
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Fetch a string pointer to @p name's value, if any.  *   * @param	sc		The NVRAM parser state.  * @param	name		The NVRAM variable name.  * @param[out]	value		On success, a pointer to the variable's value  *				string. The string may not be NUL terminated.  * @param[out]	value_len	On success, the length of @p value, not  *				including a terminating NUL (if any exists).  *  * @retval 0		success  * @retval ENOENT	The requested variable was not found.  * @retval non-zero	If reading @p name otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_find_var
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|value
parameter_list|,
name|size_t
modifier|*
name|value_len
parameter_list|)
block|{
name|struct
name|bhnd_nvram_tuple
modifier|*
name|t
decl_stmt|;
name|bhnd_nvram_op_enum_buf
name|enum_fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|env
decl_stmt|;
name|size_t
name|env_len
decl_stmt|;
name|size_t
name|name_len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|enum_fn
operator|=
name|sc
operator|->
name|ops
operator|->
name|enum_buf
expr_stmt|;
name|name_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Search path: 	 *  	 * - uncommitted changes 	 * - index lookup OR buffer scan 	 * - registered defaults 	 */
comment|/* Search uncommitted changes */
name|t
operator|=
name|bhnd_nvram_varmap_find
argument_list|(
operator|&
name|sc
operator|->
name|pending
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|value
operator|!=
name|NULL
condition|)
block|{
comment|/* Uncommited value exists, is not a deletion */
operator|*
name|value
operator|=
name|t
operator|->
name|value
expr_stmt|;
operator|*
name|value_len
operator|=
name|t
operator|->
name|value_len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* Value is marked for deletion. */
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
block|}
comment|/* Search backing buffer. We the index if available; otherwise, 	 * perform a buffer scan */
if|if
condition|(
name|sc
operator|->
name|idx
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|bhnd_nvram_index_lookup
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|idx
argument_list|,
name|name
argument_list|,
operator|&
name|env
argument_list|,
operator|&
name|env_len
argument_list|,
name|value
argument_list|,
name|value_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|bhnd_nvram_buffer_lookup
argument_list|(
name|sc
argument_list|,
name|name
argument_list|,
operator|&
name|env
argument_list|,
operator|&
name|env_len
argument_list|,
name|value
argument_list|,
name|value_len
argument_list|)
expr_stmt|;
block|}
name|failed
label|:
comment|/* If a parse error occured, we don't want to hide the issue by 	 * returning a default NVRAM value. Otherwise, look for a matching 	 * default. */
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|t
operator|=
name|bhnd_nvram_varmap_find
argument_list|(
operator|&
name|sc
operator|->
name|defaults
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
operator|*
name|value
operator|=
name|t
operator|->
name|value
expr_stmt|;
operator|*
name|value_len
operator|=
name|t
operator|->
name|value_len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Not found, and no default value available */
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * An strcmp()-compatible  lexical comparison implementation that  * handles non-NUL-terminated strings.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_keycmp
parameter_list|(
specifier|const
name|char
modifier|*
name|lhs
parameter_list|,
name|size_t
name|lhs_len
parameter_list|,
specifier|const
name|char
modifier|*
name|rhs
parameter_list|,
name|size_t
name|rhs_len
parameter_list|)
block|{
name|int
name|order
decl_stmt|;
name|order
operator|=
name|strncmp
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
name|ulmin
argument_list|(
name|lhs_len
argument_list|,
name|rhs_len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lhs_len
operator|<
name|rhs_len
condition|)
name|order
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|lhs_len
operator|>
name|rhs_len
condition|)
name|order
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|order
operator|)
return|;
block|}
end_function

begin_comment
comment|/* sort function for bhnd_nvram_idx_entry values */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_sort_idx
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
name|struct
name|bhnd_nvram
modifier|*
name|sc
decl_stmt|;
specifier|const
name|struct
name|bhnd_nvram_idx_entry
modifier|*
name|l_idx
decl_stmt|,
modifier|*
name|r_idx
decl_stmt|;
specifier|const
name|char
modifier|*
name|l_str
decl_stmt|,
modifier|*
name|r_str
decl_stmt|;
name|sc
operator|=
name|ctx
expr_stmt|;
name|l_idx
operator|=
name|lhs
expr_stmt|;
name|r_idx
operator|=
name|rhs
expr_stmt|;
comment|/* Fetch string pointers */
name|l_str
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|sc
operator|->
name|buf
operator|+
name|l_idx
operator|->
name|env_offset
operator|)
expr_stmt|;
name|r_str
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|sc
operator|->
name|buf
operator|+
name|r_idx
operator|->
name|env_offset
operator|)
expr_stmt|;
comment|/* Perform comparison */
return|return
operator|(
name|bhnd_nvram_keycmp
argument_list|(
name|l_str
argument_list|,
name|l_idx
operator|->
name|key_len
argument_list|,
name|r_str
argument_list|,
name|r_idx
operator|->
name|key_len
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Generate all indices for the NVRAM data backing @p nvram.  *   * @param sc		The NVRAM parser state.  *  * @retval 0		success  * @retval non-zero	If indexing @p nvram fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_generate_index
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|)
block|{
name|bhnd_nvram_op_enum_buf
name|enum_fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|env
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|size_t
name|env_len
decl_stmt|;
name|size_t
name|idx_bytes
decl_stmt|;
name|size_t
name|key_len
decl_stmt|,
name|val_len
decl_stmt|;
name|size_t
name|num_records
decl_stmt|;
name|int
name|error
decl_stmt|;
name|enum_fn
operator|=
name|sc
operator|->
name|ops
operator|->
name|enum_buf
expr_stmt|;
name|num_records
operator|=
literal|0
expr_stmt|;
comment|/* Parse and register all device path aliases */
name|p
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|error
operator|=
name|enum_fn
argument_list|(
name|sc
argument_list|,
operator|&
name|env
argument_list|,
operator|&
name|env_len
argument_list|,
name|p
argument_list|,
operator|&
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|bhnd_nvram_devpath
modifier|*
name|devpath
decl_stmt|;
name|char
modifier|*
name|eptr
decl_stmt|;
name|char
name|suffix
index|[
name|NVRAM_KEY_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|size_t
name|suffix_len
decl_stmt|;
name|u_long
name|index
decl_stmt|;
comment|/* Hit EOF */
if|if
condition|(
name|env
operator|==
name|NULL
condition|)
break|break;
name|num_records
operator|++
expr_stmt|;
comment|/* Skip string comparison if env_len< strlen(devpath) */
if|if
condition|(
name|env_len
operator|<
name|NVRAM_DEVPATH_LEN
condition|)
continue|continue;
comment|/* Check for devpath prefix */
if|if
condition|(
name|strncmp
argument_list|(
name|env
argument_list|,
name|NVRAM_DEVPATH_STR
argument_list|,
name|NVRAM_DEVPATH_LEN
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Split key and value */
name|error
operator|=
name|bhnd_nvram_parse_env
argument_list|(
name|sc
argument_list|,
name|env
argument_list|,
name|env_len
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|key_len
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|val_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* NUL terminate the devpath's suffix */
if|if
condition|(
name|key_len
operator|>=
sizeof|sizeof
argument_list|(
name|suffix
argument_list|)
condition|)
block|{
name|NVRAM_LOG
argument_list|(
name|sc
argument_list|,
literal|"variable '%.*s' exceeds NVRAM_KEY_MAX, "
literal|"skipping devpath parsing\n"
argument_list|,
name|NVRAM_PRINT_WIDTH
argument_list|(
name|key_len
argument_list|)
argument_list|,
name|key
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|suffix_len
operator|=
name|key_len
operator|-
name|NVRAM_DEVPATH_LEN
expr_stmt|;
if|if
condition|(
name|suffix_len
operator|==
literal|0
condition|)
continue|continue;
name|strcpy
argument_list|(
name|suffix
argument_list|,
name|key
operator|+
name|NVRAM_DEVPATH_LEN
argument_list|)
expr_stmt|;
name|suffix
index|[
name|suffix_len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Parse the index value */
name|index
operator|=
name|strtoul
argument_list|(
name|suffix
argument_list|,
operator|&
name|eptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|==
name|suffix
operator|||
operator|*
name|eptr
operator|!=
literal|'\0'
condition|)
block|{
name|NVRAM_LOG
argument_list|(
name|sc
argument_list|,
literal|"invalid devpath variable '%.*s'\n"
argument_list|,
name|NVRAM_PRINT_WIDTH
argument_list|(
name|key_len
argument_list|)
argument_list|,
name|key
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Register path alias */
name|devpath
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|devpath
argument_list|)
argument_list|,
name|M_BHND_NVRAM
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|devpath
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|devpath
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|devpath
operator|->
name|path
operator|=
name|strndup
argument_list|(
name|val
argument_list|,
name|val_len
argument_list|,
name|M_BHND_NVRAM
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|devpaths
argument_list|,
name|devpath
argument_list|,
name|dp_link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Save record count */
name|sc
operator|->
name|num_buf_vars
operator|=
name|num_records
expr_stmt|;
comment|/* Skip generating variable index if threshold is not met */
if|if
condition|(
name|sc
operator|->
name|num_buf_vars
operator|<
name|NVRAM_IDX_VAR_THRESH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Allocate and populate variable index */
name|idx_bytes
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|bhnd_nvram_idx
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|bhnd_nvram_idx_entry
argument_list|)
operator|*
name|sc
operator|->
name|num_buf_vars
operator|)
expr_stmt|;
name|sc
operator|->
name|idx
operator|=
name|malloc
argument_list|(
name|idx_bytes
argument_list|,
name|M_BHND_NVRAM
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|idx
operator|==
name|NULL
condition|)
block|{
name|NVRAM_LOG
argument_list|(
name|sc
argument_list|,
literal|"error allocating %zu byte index\n"
argument_list|,
name|idx_bytes
argument_list|)
expr_stmt|;
goto|goto
name|bad_index
goto|;
block|}
name|sc
operator|->
name|idx
operator|->
name|num_entries
operator|=
name|sc
operator|->
name|num_buf_vars
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|NVRAM_LOG
argument_list|(
name|sc
argument_list|,
literal|"allocated %zu byte index for %zu variables "
literal|"in %zu bytes\n"
argument_list|,
name|idx_bytes
argument_list|,
name|sc
operator|->
name|num_buf_vars
argument_list|,
name|sc
operator|->
name|buf_size
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|idx
operator|->
name|num_entries
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bhnd_nvram_idx_entry
modifier|*
name|idx
decl_stmt|;
name|size_t
name|env_offset
decl_stmt|;
name|size_t
name|key_len
decl_stmt|,
name|val_len
decl_stmt|;
comment|/* Fetch next record */
if|if
condition|(
operator|(
name|error
operator|=
name|enum_fn
argument_list|(
name|sc
argument_list|,
operator|&
name|env
argument_list|,
operator|&
name|env_len
argument_list|,
name|p
argument_list|,
operator|&
name|p
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Early EOF */
if|if
condition|(
name|env
operator|==
name|NULL
condition|)
block|{
name|NVRAM_LOG
argument_list|(
name|sc
argument_list|,
literal|"indexing failed, expected %zu records "
literal|"(got %zu)\n"
argument_list|,
name|sc
operator|->
name|idx
operator|->
name|num_entries
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|bad_index
goto|;
block|}
comment|/* Calculate env offset */
name|env_offset
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|env
operator|-
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|buf
expr_stmt|;
if|if
condition|(
name|env_offset
operator|>
name|NVRAM_IDX_OFFSET_MAX
condition|)
block|{
name|NVRAM_LOG
argument_list|(
name|sc
argument_list|,
literal|"'%.*s' offset %#zx exceeds maximum "
literal|"indexable value\n"
argument_list|,
name|NVRAM_PRINT_WIDTH
argument_list|(
name|env_len
argument_list|)
argument_list|,
name|env
argument_list|,
name|env_offset
argument_list|)
expr_stmt|;
goto|goto
name|bad_index
goto|;
block|}
comment|/* Split key and value */
name|error
operator|=
name|bhnd_nvram_parse_env
argument_list|(
name|sc
argument_list|,
name|env
argument_list|,
name|env_len
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|key_len
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|val_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|key_len
operator|>
name|NVRAM_IDX_LEN_MAX
condition|)
block|{
name|NVRAM_LOG
argument_list|(
name|sc
argument_list|,
literal|"key length %#zx at %#zx exceeds maximum "
literal|"indexable value\n"
argument_list|,
name|key_len
argument_list|,
name|env_offset
argument_list|)
expr_stmt|;
goto|goto
name|bad_index
goto|;
block|}
if|if
condition|(
name|val_len
operator|>
name|NVRAM_IDX_LEN_MAX
condition|)
block|{
name|NVRAM_LOG
argument_list|(
name|sc
argument_list|,
literal|"value length %#zx for key '%.*s' "
literal|"exceeds maximum indexable value\n"
argument_list|,
name|val_len
argument_list|,
name|NVRAM_PRINT_WIDTH
argument_list|(
name|key_len
argument_list|)
argument_list|,
name|key
argument_list|)
expr_stmt|;
goto|goto
name|bad_index
goto|;
block|}
name|idx
operator|=
operator|&
name|sc
operator|->
name|idx
operator|->
name|entries
index|[
name|i
index|]
expr_stmt|;
name|idx
operator|->
name|env_offset
operator|=
name|env_offset
expr_stmt|;
name|idx
operator|->
name|key_len
operator|=
name|key_len
expr_stmt|;
name|idx
operator|->
name|val_len
operator|=
name|val_len
expr_stmt|;
block|}
comment|/* Sort the index table */
name|qsort_r
argument_list|(
name|sc
operator|->
name|idx
operator|->
name|entries
argument_list|,
name|sc
operator|->
name|idx
operator|->
name|num_entries
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|idx
operator|->
name|entries
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|sc
argument_list|,
name|bhnd_nvram_sort_idx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad_index
label|:
comment|/* Fall back on non-indexed access */
name|NVRAM_LOG
argument_list|(
name|sc
argument_list|,
literal|"reverting to non-indexed variable lookup\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|idx
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|idx
argument_list|,
name|M_BHND_NVRAM
argument_list|)
expr_stmt|;
name|sc
operator|->
name|idx
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Perform an index lookup of @p name.  *  * @param	sc		The NVRAM parser state.  * @param	idx		The index to search.  * @param	name		The variable to search for.  * @param[out]	env		On success, the pointer to @p name within the  *				backing buffer.  * @param[out]	env_len		On success, the length of @p env.  * @param[out]	value		On success, the pointer to @p name's value  *				within the backing buffer.  * @param[out]	value_len	On success, the length of @p value.  *   * @retval 0 If @p name was found in the index.  * @retval ENOENT If @p name was not found in the index.  * @retval ENODEV If no index has been generated.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_index_lookup
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
name|struct
name|bhnd_nvram_idx
modifier|*
name|idx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|env
parameter_list|,
name|size_t
modifier|*
name|env_len
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|value
parameter_list|,
name|size_t
modifier|*
name|value_len
parameter_list|)
block|{
name|struct
name|bhnd_nvram_idx_entry
modifier|*
name|idxe
decl_stmt|;
specifier|const
name|char
modifier|*
name|idxe_key
decl_stmt|;
name|size_t
name|min
decl_stmt|,
name|mid
decl_stmt|,
name|max
decl_stmt|;
name|size_t
name|name_len
decl_stmt|;
name|int
name|order
decl_stmt|;
if|if
condition|(
name|idx
operator|->
name|num_entries
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* 	 * Locate the requested variable using a binary search. 	 */
name|min
operator|=
literal|0
expr_stmt|;
name|mid
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|idx
operator|->
name|num_entries
operator|-
literal|1
expr_stmt|;
name|name_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
name|max
operator|>=
name|min
condition|)
block|{
comment|/* Select midpoint */
name|mid
operator|=
operator|(
name|min
operator|+
name|max
operator|)
operator|/
literal|2
expr_stmt|;
name|idxe
operator|=
operator|&
name|idx
operator|->
name|entries
index|[
name|mid
index|]
expr_stmt|;
comment|/* Determine which side of the partition to search */
name|idxe_key
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|sc
operator|->
name|buf
operator|+
name|idxe
operator|->
name|env_offset
operator|)
expr_stmt|;
name|order
operator|=
name|bhnd_nvram_keycmp
argument_list|(
name|idxe_key
argument_list|,
name|idxe
operator|->
name|key_len
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|<
literal|0
condition|)
block|{
comment|/* Search upper partition */
name|min
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|order
operator|>
literal|0
condition|)
block|{
comment|/* Search lower partition */
name|max
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|order
operator|==
literal|0
condition|)
block|{
comment|/* Match found */
operator|*
name|env
operator|=
name|sc
operator|->
name|buf
operator|+
name|idxe
operator|->
name|env_offset
expr_stmt|;
operator|*
name|env_len
operator|=
name|idxe
operator|->
name|key_len
operator|+
name|idxe
operator|->
name|val_len
operator|+
literal|1
comment|/* '=' */
expr_stmt|;
operator|*
name|value
operator|=
operator|*
name|env
operator|+
name|idxe
operator|->
name|key_len
operator|+
literal|1
comment|/* '=' */
expr_stmt|;
operator|*
name|value_len
operator|=
name|idxe
operator|->
name|val_len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* Not found */
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Perform a unindexed search for an entry matching @p name in the backing  * NVRAM data buffer.  *  * @param	sc		The NVRAM parser state.  * @param	name		The variable to search for.  * @param[out]	env		On success, the pointer to @p name within the  *				backing buffer.  * @param[out]	env_len		On success, the length of @p env.  * @param[out]	value		On success, the pointer to @p name's value  *				within the backing buffer.  * @param[out]	value_len	On success, the length of @p value.  *   * @retval 0 If @p name was found in the index.  * @retval ENOENT If @p name was not found in the index.  * @retval ENODEV If no index has been generated.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_buffer_lookup
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|env
parameter_list|,
name|size_t
modifier|*
name|env_len
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|value
parameter_list|,
name|size_t
modifier|*
name|value_len
parameter_list|)
block|{
name|bhnd_nvram_op_enum_buf
name|enum_fn
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|size_t
name|name_len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|enum_fn
operator|=
name|sc
operator|->
name|ops
operator|->
name|enum_buf
expr_stmt|;
name|name_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Iterate over all records in the backing buffer */
name|p
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|error
operator|=
name|enum_fn
argument_list|(
name|sc
argument_list|,
name|env
argument_list|,
name|env_len
argument_list|,
name|p
argument_list|,
operator|&
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Hit EOF, not found */
if|if
condition|(
operator|*
name|env
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Skip string comparison if env_len< strlen('key=') */
if|if
condition|(
operator|*
name|env_len
operator|<
name|name_len
operator|+
literal|1
condition|)
continue|continue;
comment|/* Skip string comparison if delimiter isn't found at 		* expected position */
if|if
condition|(
operator|*
operator|(
operator|*
name|env
operator|+
name|name_len
operator|)
operator|!=
literal|'='
condition|)
continue|continue;
comment|/* Check for match */
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|env
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Found */
operator|*
name|value
operator|=
operator|*
name|env
operator|+
name|name_len
operator|+
literal|1
expr_stmt|;
operator|*
name|value_len
operator|=
operator|*
name|env_len
operator|-
name|name_len
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* FMT_BCM NVRAM data size calculation */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_bcm_getsize
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_nvram_header
modifier|*
name|hdr
decl_stmt|;
if|if
condition|(
operator|*
name|size
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|hdr
operator|=
operator|(
specifier|const
expr|struct
name|bhnd_nvram_header
operator|*
operator|)
name|data
expr_stmt|;
operator|*
name|size
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* FMT_BCM-specific parser initialization */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_bcm_init
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|uint32_t
name|cfg0
decl_stmt|;
name|uint8_t
name|crc
decl_stmt|,
name|valid
decl_stmt|;
comment|/* Validate CRC */
if|if
condition|(
name|sc
operator|->
name|buf_size
operator|<
name|NVRAM_CRC_SKIP
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|buf_size
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|bhnd_nvram_header
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|cfg0
operator|=
operator|(
operator|(
expr|struct
name|bhnd_nvram_header
operator|*
operator|)
name|sc
operator|->
name|buf
operator|)
operator|->
name|cfg0
expr_stmt|;
name|valid
operator|=
operator|(
name|cfg0
operator|&
name|NVRAM_CFG0_CRC_MASK
operator|)
operator|>>
name|NVRAM_CFG0_CRC_SHIFT
expr_stmt|;
name|p
operator|=
name|sc
operator|->
name|buf
expr_stmt|;
name|crc
operator|=
name|bhnd_nvram_crc8
argument_list|(
name|p
operator|+
name|NVRAM_CRC_SKIP
argument_list|,
name|sc
operator|->
name|buf_size
operator|-
name|NVRAM_CRC_SKIP
argument_list|,
name|BHND_NVRAM_CRC8_INITIAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|crc
operator|!=
name|valid
condition|)
block|{
name|NVRAM_LOG
argument_list|(
name|sc
argument_list|,
literal|"warning: NVRAM CRC error (crc=%#hhx, "
literal|"expected=%hhx)\n"
argument_list|,
name|crc
argument_list|,
name|valid
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Populate FMT_BCM-specific default values */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_bcm_init_defaults
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bhnd_nvram_header
modifier|*
name|header
decl_stmt|;
name|char
name|vbuf
index|[
name|NVRAM_VAL_MAX
index|]
decl_stmt|;
name|uint32_t
name|value
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|nwrite
decl_stmt|;
comment|/* Verify that our header is readable */
name|header
operator|=
operator|(
expr|struct
name|bhnd_nvram_header
operator|*
operator|)
name|sc
operator|->
name|buf
expr_stmt|;
if|if
condition|(
operator|!
name|bhnd_nvram_bufptr_valid
argument_list|(
name|sc
argument_list|,
name|header
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
argument_list|,
name|true
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Extract a value value from the NVRAM header, format it, and 	 * register a new default variable tuple */
define|#
directive|define
name|NVRAM_BCM_HEADER_DEFAULT
parameter_list|(
name|_field
parameter_list|,
name|_name
parameter_list|)
value|do {			\ 	value = NVRAM_GET_BITS(le32toh(header->_field), _name);		\ 	nwrite = snprintf(vbuf, sizeof(vbuf), _name ##_FMT, value);	\ 	if (nwrite< 0 || nwrite>= sizeof(vbuf)) {			\ 		NVRAM_LOG(sc, "%s: formatting '%s' failed: %d\n",	\ 		    __FUNCTION__, _name ## _VAR, nwrite);		\ 		return (ENXIO);						\ 	}								\ 	error = bhnd_nvram_varmap_add(&sc->defaults,			\ 		_name ##_VAR, vbuf, strlen(vbuf));			\ 									\ 	if (error)							\ 		return (error);						\ } while(0)
name|NVRAM_BCM_HEADER_DEFAULT
argument_list|(
name|cfg0
argument_list|,
name|NVRAM_CFG0_SDRAM_INIT
argument_list|)
expr_stmt|;
name|NVRAM_BCM_HEADER_DEFAULT
argument_list|(
name|cfg1
argument_list|,
name|NVRAM_CFG1_SDRAM_CFG
argument_list|)
expr_stmt|;
name|NVRAM_BCM_HEADER_DEFAULT
argument_list|(
name|cfg1
argument_list|,
name|NVRAM_CFG1_SDRAM_REFRESH
argument_list|)
expr_stmt|;
name|NVRAM_BCM_HEADER_DEFAULT
argument_list|(
name|sdram_ncdl
argument_list|,
name|NVRAM_SDRAM_NCDL
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|NVRAM_BCM_HEADER_DEFAULT
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* FMT_BCM record parsing */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_bcm_enum_buf
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|env
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint8_t
specifier|const
modifier|*
modifier|*
name|next
parameter_list|)
block|{
comment|/* First record is found following the NVRAM header */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|sc
operator|->
name|buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|bhnd_nvram_header
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bhnd_nvram_bufptr_valid
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
name|true
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* EOF */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|env
operator|=
name|NULL
expr_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
operator|*
name|next
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Provide pointer to env data */
operator|*
name|env
operator|=
name|p
expr_stmt|;
operator|*
name|len
operator|=
name|strnlen
argument_list|(
name|p
argument_list|,
name|sc
operator|->
name|buf_size
operator|-
operator|(
name|p
operator|-
name|sc
operator|->
name|buf
operator|)
argument_list|)
expr_stmt|;
comment|/* Advance to next entry and skip terminating NUL */
name|p
operator|+=
operator|*
name|len
expr_stmt|;
if|if
condition|(
name|bhnd_nvram_bufptr_valid
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
name|NVRAM_LOG
argument_list|(
name|sc
argument_list|,
literal|"warning: missing NVRAM termination record"
argument_list|)
expr_stmt|;
block|}
operator|*
name|next
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* FMT_TLV NVRAM data size calculation */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_tlv_getsize
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
specifier|const
name|start
init|=
name|data
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|uint16_t
name|rlen
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|offset
operator|<
operator|*
name|size
condition|)
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* Fetch type */
name|type
operator|=
operator|*
operator|(
name|start
operator|+
name|offset
operator|)
expr_stmt|;
comment|/* EOF */
if|if
condition|(
name|type
operator|==
name|NVRAM_TLV_TYPE_END
condition|)
block|{
operator|*
name|size
operator|=
name|offset
operator|+
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|offset
operator|++
operator|)
operator|==
operator|*
name|size
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Determine record length */
if|if
condition|(
name|type
operator|&
name|NVRAM_TLV_TF_U8_LEN
condition|)
block|{
name|rlen
operator|=
operator|*
operator|(
name|start
operator|+
name|offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|rlen
operator|=
operator|*
operator|(
name|start
operator|+
name|offset
operator|)
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|++
operator|)
operator|==
operator|*
name|size
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rlen
operator||=
operator|*
operator|(
name|start
operator|+
name|offset
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|offset
operator|++
operator|)
operator|>=
operator|*
name|size
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Advance to next entry */
if|if
condition|(
name|rlen
operator|>
operator|*
name|size
operator|||
operator|*
name|size
operator|-
name|rlen
operator|<
name|offset
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|offset
operator|+=
name|rlen
expr_stmt|;
block|}
comment|/* EOF not found */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* FMT_TLV-specific parser initialization */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_tlv_init
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* FMT_TLV record parsing */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_tlv_enum_buf
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|env
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint8_t
specifier|const
modifier|*
modifier|*
name|next
parameter_list|)
block|{
name|size_t
name|rlen
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|sc
operator|->
name|buf
expr_stmt|;
comment|/* Fetch type */
if|if
condition|(
operator|!
name|bhnd_nvram_bufptr_valid
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
name|true
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|type
operator|=
operator|*
name|p
expr_stmt|;
comment|/* EOF */
if|if
condition|(
name|type
operator|==
name|NVRAM_TLV_TYPE_END
condition|)
block|{
operator|*
name|env
operator|=
name|NULL
expr_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
operator|*
name|next
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Determine record length */
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|NVRAM_TLV_TF_U8_LEN
condition|)
block|{
if|if
condition|(
operator|!
name|bhnd_nvram_bufptr_valid
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
name|true
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rlen
operator|=
operator|*
name|p
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|bhnd_nvram_bufptr_valid
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
literal|2
argument_list|,
name|true
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rlen
operator|=
operator|(
name|p
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|p
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Verify record readability */
if|if
condition|(
operator|!
name|bhnd_nvram_bufptr_valid
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
name|rlen
argument_list|,
name|true
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Error on non-env records */
if|if
condition|(
name|type
operator|!=
name|NVRAM_TLV_TYPE_ENV
condition|)
block|{
name|NVRAM_LOG
argument_list|(
name|sc
argument_list|,
literal|"unsupported NVRAM TLV tag: %#hhx\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Skip flag field */
if|if
condition|(
name|rlen
operator|<
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|p
operator|++
expr_stmt|;
name|rlen
operator|--
expr_stmt|;
comment|/* Provide pointer to env data */
operator|*
name|env
operator|=
name|p
expr_stmt|;
operator|*
name|len
operator|=
name|strnlen
argument_list|(
operator|*
name|env
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
comment|/* Advance to next entry */
operator|*
name|next
operator|=
name|p
operator|+
name|rlen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* FMT_BTXT NVRAM data size calculation */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_txt_getsize
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
operator|*
name|size
operator|=
operator|(
name|strnlen
argument_list|(
name|data
argument_list|,
operator|*
name|size
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* FMT_BTXT-specific parser initialization */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_txt_init
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Seek past the next line ending (\r, \r\n, or \n) */
end_comment

begin_function
specifier|static
specifier|const
name|uint8_t
modifier|*
name|bhnd_nvram_txt_seek_eol
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|p
parameter_list|)
block|{
while|while
condition|(
name|p
operator|<
name|sc
operator|->
name|buf
operator|+
name|sc
operator|->
name|buf_size
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\r'
case|:
comment|/* \r\n */
if|if
condition|(
name|bhnd_nvram_bufptr_valid
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|+
literal|1
operator|)
return|;
case|case
literal|'\n'
case|:
return|return
operator|(
name|p
operator|+
literal|1
operator|)
return|;
default|default:
name|p
operator|++
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Seek to the next valid key=value entry (or EOF) */
end_comment

begin_function
specifier|static
specifier|const
name|uint8_t
modifier|*
name|bhnd_nvram_txt_seek_nextline
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|p
parameter_list|)
block|{
comment|/* Skip leading whitespace and comments */
while|while
condition|(
name|p
operator|<
name|sc
operator|->
name|buf
operator|+
name|sc
operator|->
name|buf_size
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
condition|)
block|{
name|p
operator|=
name|bhnd_nvram_txt_seek_eol
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* FMT_BTXT record parsing */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_txt_enum_buf
parameter_list|(
name|struct
name|bhnd_nvram
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|env
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint8_t
specifier|const
modifier|*
modifier|*
name|next
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|startp
decl_stmt|;
name|size_t
name|line_len
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|sc
operator|->
name|buf
expr_stmt|;
comment|/* Skip any leading whitespace and comments */
name|p
operator|=
name|bhnd_nvram_txt_seek_nextline
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* EOF? */
if|if
condition|(
operator|!
name|bhnd_nvram_bufptr_valid
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
condition|)
block|{
operator|*
name|env
operator|=
name|NULL
expr_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
operator|*
name|next
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Find record termination (EOL, or '#') */
name|startp
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|sc
operator|->
name|buf
operator|+
name|sc
operator|->
name|buf_size
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\r'
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Calculate line length, check for EOF */
name|line_len
operator|=
name|p
operator|-
name|startp
expr_stmt|;
if|if
condition|(
operator|!
name|bhnd_nvram_bufptr_valid
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
condition|)
block|{
operator|*
name|env
operator|=
name|NULL
expr_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
operator|*
name|next
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Got env data; trim any tailing whitespace */
operator|*
name|env
operator|=
name|startp
expr_stmt|;
operator|*
name|len
operator|=
name|line_len
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|line_len
operator|&&
name|line_len
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|startp
index|[
name|line_len
operator|-
name|i
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
operator|*
name|len
operator|-=
literal|1
expr_stmt|;
block|}
comment|/* Advance to next entry */
name|p
operator|=
name|bhnd_nvram_txt_seek_nextline
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|next
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

