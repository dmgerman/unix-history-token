begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Landon Fuller<landonf@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * BHND CFE NVRAM driver.  *   * Provides access to device NVRAM via CFE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhnd.h>
end_include

begin_include
include|#
directive|include
file|<dev/cfe/cfe_api.h>
end_include

begin_include
include|#
directive|include
file|<dev/cfe/cfe_error.h>
end_include

begin_include
include|#
directive|include
file|<dev/cfe/cfe_ioctl.h>
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_if.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvramvar.h"
end_include

begin_function_decl
specifier|static
name|int
name|nvram_open_cfedev
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|char
modifier|*
name|devname
parameter_list|,
name|int
name|fd
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|,
name|uint32_t
modifier|*
name|size
parameter_list|,
name|bhnd_nvram_format
name|fmt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|nvram_find_cfedev
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
modifier|*
name|fd
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|,
name|uint32_t
modifier|*
name|size
parameter_list|,
name|bhnd_nvram_format
modifier|*
name|fmt
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/** Known CFE NVRAM device names, in probe order. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nvram_cfe_devs
index|[]
init|=
block|{
literal|"nflash0.nvram"
block|,
comment|/* NAND */
literal|"nflash1.nvram"
block|,
literal|"flash0.nvram"
block|,
literal|"flash1.nvram"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** Supported CFE NVRAM formats, in probe order. */
end_comment

begin_decl_stmt
name|bhnd_nvram_format
name|nvram_cfe_fmts
index|[]
init|=
block|{
name|BHND_NVRAM_FMT_BCM
block|,
name|BHND_NVRAM_FMT_TLV
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|bhnd_nvram_cfe_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
modifier|*
name|devname
decl_stmt|;
name|bhnd_nvram_format
name|fmt
decl_stmt|;
name|int64_t
name|offset
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* Defer to default driver implementation */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_probe
argument_list|(
name|dev
argument_list|)
operator|)
operator|>
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Locate a usable CFE device */
name|devname
operator|=
name|nvram_find_cfedev
argument_list|(
name|dev
argument_list|,
operator|&
name|fd
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|devname
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|cfe_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|BHND_NVRAM_FMT_BCM
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Broadcom NVRAM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_FMT_TLV
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Broadcom WGT634U NVRAM"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unknown NVRAM format: %d\n"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Refuse wildcard attachments */
return|return
operator|(
name|BUS_PROBE_NOWILDCARD
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_cfe_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
modifier|*
name|devname
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|bhnd_nvram_format
name|fmt
decl_stmt|;
name|int64_t
name|offset
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|buffer
operator|=
name|NULL
expr_stmt|;
name|fd
operator|=
name|CFE_ERR
expr_stmt|;
comment|/* Locate NVRAM device via CFE */
name|devname
operator|=
name|nvram_find_cfedev
argument_list|(
name|dev
argument_list|,
operator|&
name|fd
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|devname
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CFE NVRAM device not found\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Copy out NVRAM buffer */
name|buffer
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|size_t
name|remain
init|=
name|size
init|;
name|remain
operator|>
literal|0
condition|;
control|)
block|{
name|int
name|nr
decl_stmt|,
name|req
decl_stmt|;
name|req
operator|=
name|ulmin
argument_list|(
name|INT_MAX
argument_list|,
name|remain
argument_list|)
expr_stmt|;
name|nr
operator|=
name|cfe_readblk
argument_list|(
name|fd
argument_list|,
name|size
operator|-
name|remain
argument_list|,
name|buffer
operator|+
operator|(
name|size
operator|-
name|remain
operator|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: cfe_readblk() failed: %d\n"
argument_list|,
name|devname
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|remain
operator|-=
name|nr
expr_stmt|;
if|if
condition|(
name|nr
operator|==
literal|0
operator|&&
name|remain
operator|>
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: cfe_readblk() unexpected EOF: "
literal|"%zu of %zu pending\n"
argument_list|,
name|devname
argument_list|,
name|remain
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CFE %s (%#jx+%#jx)\n"
argument_list|,
name|devname
argument_list|,
operator|(
name|uintmax_t
operator|)
name|offset
argument_list|,
operator|(
name|uintmax_t
operator|)
name|size
argument_list|)
expr_stmt|;
comment|/* Delegate to default driver implementation */
name|error
operator|=
name|bhnd_nvram_attach
argument_list|(
name|dev
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|buffer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buffer
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|cfe_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Identify and open a CFE NVRAM device.  *   * @param	dev	bhnd_nvram_cfe device.  * @param	devname	The name of the CFE device to be probed.  * @param	fd	An open CFE file descriptor for @p devname.  * @param[out]	offset	On success, the NVRAM data offset within @p @fd.  * @param[out]	size	On success, maximum the NVRAM data size within @p fd.  * @param	fmt	The expected NVRAM data format for this device.  *   * @retval	0		success  * @retval	non-zero	If probing @p devname fails, a regular unix  * 				error code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|nvram_open_cfedev
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|char
modifier|*
name|devname
parameter_list|,
name|int
name|fd
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|,
name|uint32_t
modifier|*
name|size
parameter_list|,
name|bhnd_nvram_format
name|fmt
parameter_list|)
block|{
name|union
name|bhnd_nvram_ident
name|ident
decl_stmt|;
name|nvram_info_t
name|nvram_info
decl_stmt|;
name|int
name|cerr
decl_stmt|,
name|devinfo
decl_stmt|,
name|dtype
decl_stmt|,
name|rlen
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Try to fetch device info */
if|if
condition|(
operator|(
name|devinfo
operator|=
name|cfe_getdevinfo
argument_list|(
name|devname
argument_list|)
operator|)
operator|==
name|CFE_ERR_DEVNOTFOUND
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
name|devinfo
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cfe_getdevinfo() failed: %d"
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Verify device type */
name|dtype
operator|=
name|devinfo
operator|&
name|CFE_DEV_MASK
expr_stmt|;
switch|switch
condition|(
name|dtype
condition|)
block|{
case|case
name|CFE_DEV_FLASH
case|:
case|case
name|CFE_DEV_NVRAM
case|:
comment|/* Valid device type */
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: unknown device type %d\n"
argument_list|,
name|devname
argument_list|,
name|dtype
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Try to fetch nvram info from CFE */
name|cerr
operator|=
name|cfe_ioctl
argument_list|(
name|fd
argument_list|,
name|IOCTL_NVRAM_GETINFO
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|nvram_info
argument_list|,
sizeof|sizeof
argument_list|(
name|nvram_info
argument_list|)
argument_list|,
operator|&
name|rlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cerr
operator|!=
name|CFE_OK
operator|&&
name|cerr
operator|!=
name|CFE_ERR_INV_COMMAND
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: IOCTL_NVRAM_GETINFO failed: %d\n"
argument_list|,
name|devname
argument_list|,
name|cerr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Fall back on flash info. 	 *  	 * This is known to be required on the Asus RT-N53 (CFE 5.70.55.33,  	 * BBP 1.0.37, BCM5358UB0), where IOCTL_NVRAM_GETINFO returns 	 * CFE_ERR_INV_COMMAND. 	 */
if|if
condition|(
name|cerr
operator|==
name|CFE_ERR_INV_COMMAND
condition|)
block|{
name|flash_info_t
name|fi
decl_stmt|;
name|cerr
operator|=
name|cfe_ioctl
argument_list|(
name|fd
argument_list|,
name|IOCTL_FLASH_GETINFO
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|fi
argument_list|,
sizeof|sizeof
argument_list|(
name|fi
argument_list|)
argument_list|,
operator|&
name|rlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cerr
operator|!=
name|CFE_OK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: IOCTL_FLASH_GETINFO failed: "
literal|"%d\n"
argument_list|,
name|devname
argument_list|,
name|cerr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|nvram_info
operator|.
name|nvram_eraseflg
operator|=
operator|!
operator|(
name|fi
operator|.
name|flash_flags
operator|&
name|FLASH_FLAG_NOERASE
operator|)
expr_stmt|;
name|nvram_info
operator|.
name|nvram_offset
operator|=
literal|0x0
expr_stmt|;
name|nvram_info
operator|.
name|nvram_size
operator|=
name|fi
operator|.
name|flash_size
expr_stmt|;
block|}
comment|/* Try to read NVRAM header/format identification */
name|cerr
operator|=
name|cfe_readblk
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|ident
argument_list|,
sizeof|sizeof
argument_list|(
name|ident
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cerr
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: cfe_readblk() failed: %d\n"
argument_list|,
name|devname
argument_list|,
name|cerr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cerr
operator|==
literal|0
condition|)
block|{
comment|/* EOF */
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cerr
operator|!=
sizeof|sizeof
argument_list|(
name|ident
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: cfe_readblk() short read: %d\n"
argument_list|,
name|devname
argument_list|,
name|cerr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Verify expected format */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_parser_identify
argument_list|(
operator|&
name|ident
argument_list|,
name|fmt
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Provide offset and size */
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|BHND_NVRAM_FMT_TLV
case|:
comment|/* No size field is available; must assume the NVRAM data 		 * consumes up to the full CFE NVRAM range */
operator|*
name|offset
operator|=
name|nvram_info
operator|.
name|nvram_offset
expr_stmt|;
operator|*
name|size
operator|=
name|nvram_info
operator|.
name|nvram_size
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_FMT_BCM
case|:
if|if
condition|(
name|ident
operator|.
name|bcm
operator|.
name|size
operator|>
name|nvram_info
operator|.
name|nvram_size
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: NVRAM size %#x overruns %#x "
literal|"device limit\n"
argument_list|,
name|devname
argument_list|,
name|ident
operator|.
name|bcm
operator|.
name|size
argument_list|,
name|nvram_info
operator|.
name|nvram_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
operator|*
name|offset
operator|=
name|nvram_info
operator|.
name|nvram_offset
expr_stmt|;
operator|*
name|size
operator|=
name|ident
operator|.
name|bcm
operator|.
name|size
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find (and open) a CFE NVRAM device.  *   * @param	dev	bhnd_nvram_cfe device.  * @param[out]	fd	On success, a valid CFE file descriptor. The callee  *			is responsible for closing this file descriptor via  *			cfe_close().  * @param[out]	offset	On success, the NVRAM data offset within @p @fd.  * @param[out]	size	On success, maximum the NVRAM data size within @p fd.  * @param	fmt	The expected NVRAM data format for this device.  *   * @return	On success, the opened CFE device's name will be returned. On  *		error, returns NULL.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|nvram_find_cfedev
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
modifier|*
name|fd
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|,
name|uint32_t
modifier|*
name|size
parameter_list|,
name|bhnd_nvram_format
modifier|*
name|fmt
parameter_list|)
block|{
name|char
modifier|*
name|devname
decl_stmt|;
name|int
name|error
decl_stmt|;
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|nvram_cfe_fmts
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|fmt
operator|=
name|nvram_cfe_fmts
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|u_int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|nitems
argument_list|(
name|nvram_cfe_devs
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|devname
operator|=
name|nvram_cfe_devs
index|[
name|j
index|]
expr_stmt|;
comment|/* Open for reading */
operator|*
name|fd
operator|=
name|cfe_open
argument_list|(
name|devname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|fd
operator|==
name|CFE_ERR_DEVNOTFOUND
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|*
name|fd
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: cfe_open() failed: "
literal|"%d\n"
argument_list|,
name|devname
argument_list|,
operator|*
name|fd
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Probe */
name|error
operator|=
name|nvram_open_cfedev
argument_list|(
name|dev
argument_list|,
name|devname
argument_list|,
operator|*
name|fd
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
operator|*
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
name|devname
operator|)
return|;
comment|/* Keep searching */
name|devname
operator|=
name|NULL
expr_stmt|;
name|cfe_close
argument_list|(
operator|*
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|bhnd_nvram_cfe_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|bhnd_nvram_cfe_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|bhnd_nvram_cfe_attach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_1
argument_list|(
name|bhnd_nvram
argument_list|,
name|bhnd_nvram_cfe
argument_list|,
name|bhnd_nvram_cfe_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bhnd_nvram_softc
argument_list|)
argument_list|,
name|bhnd_nvram_driver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EARLY_DRIVER_MODULE
argument_list|(
name|bhnd_nvram_cfe
argument_list|,
name|nexus
argument_list|,
name|bhnd_nvram_cfe
argument_list|,
name|bhnd_nvram_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|BUS_PASS_BUS
operator|+
name|BUS_PASS_ORDER_EARLY
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

