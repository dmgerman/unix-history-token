begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Landon Fuller<landonf@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_KERNEL */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_include
include|#
directive|include
file|"bhnd_nvram_private.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_datavar.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_data_tlvreg.h"
end_include

begin_comment
comment|/*  * CFE TLV NVRAM data class.  *   * The CFE-defined TLV NVRAM format is used on the WGT634U.  */
end_comment

begin_struct
struct|struct
name|bhnd_nvram_tlv
block|{
name|struct
name|bhnd_nvram_data
name|nv
decl_stmt|;
comment|/**< common instance state */
name|struct
name|bhnd_nvram_io
modifier|*
name|data
decl_stmt|;
comment|/**< backing buffer */
name|size_t
name|count
decl_stmt|;
comment|/**< variable count */
block|}
struct|;
end_struct

begin_macro
name|BHND_NVRAM_DATA_CLASS_DEFN
argument_list|(
argument|tlv
argument_list|,
literal|"WGT634U"
argument_list|,
argument|BHND_NVRAM_DATA_CAP_DEVPATHS
argument_list|,
argument|sizeof(struct bhnd_nvram_tlv)
argument_list|)
end_macro

begin_comment
comment|/** Minimal TLV_ENV record header */
end_comment

begin_struct
struct|struct
name|bhnd_nvram_tlv_env_hdr
block|{
name|uint8_t
name|tag
decl_stmt|;
name|uint8_t
name|size
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_comment
comment|/** Minimal TLV_ENV record */
end_comment

begin_struct
struct|struct
name|bhnd_nvram_tlv_env
block|{
name|struct
name|bhnd_nvram_tlv_env_hdr
name|hdr
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|;
name|char
name|envp
index|[]
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_comment
comment|/* Return the length in bytes of an TLV_ENV's envp data */
end_comment

begin_define
define|#
directive|define
name|NVRAM_TLV_ENVP_DATA_LEN
parameter_list|(
name|_env
parameter_list|)
define|\
value|(((_env)->hdr.size< sizeof((_env)->flags)) ? 0 :	\ 	    ((_env)->hdr.size - sizeof((_env)->flags)))
end_define

begin_comment
comment|/* Maximum supported length of the envp data field, in bytes */
end_comment

begin_define
define|#
directive|define
name|NVRAM_TLV_ENVP_DATA_MAX_LEN
define|\
value|(UINT8_MAX - sizeof(uint8_t)
comment|/* flags */
value|)
end_define

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_tlv_parse_size
parameter_list|(
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_tlv_next_record
parameter_list|(
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|,
name|size_t
modifier|*
name|next
parameter_list|,
name|size_t
modifier|*
name|offset
parameter_list|,
name|uint8_t
modifier|*
name|tag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|bhnd_nvram_tlv_env
modifier|*
name|bhnd_nvram_tlv_next_env
parameter_list|(
name|struct
name|bhnd_nvram_tlv
modifier|*
name|tlv
parameter_list|,
name|size_t
modifier|*
name|next
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|bhnd_nvram_tlv_env
modifier|*
name|bhnd_nvram_tlv_get_env
parameter_list|(
name|struct
name|bhnd_nvram_tlv
modifier|*
name|tlv
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|bhnd_nvram_tlv_to_cookie
parameter_list|(
name|struct
name|bhnd_nvram_tlv
modifier|*
name|tlv
parameter_list|,
name|size_t
name|io_offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|bhnd_nvram_tlv_to_offset
parameter_list|(
name|struct
name|bhnd_nvram_tlv
modifier|*
name|tlv
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|bhnd_nvram_tlv_probe
parameter_list|(
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|bhnd_nvram_tlv_env
name|ident
decl_stmt|;
name|size_t
name|nbytes
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nbytes
operator|=
name|bhnd_nvram_io_getsize
argument_list|(
name|io
argument_list|)
expr_stmt|;
comment|/* Handle what might be an empty TLV image */
if|if
condition|(
name|nbytes
operator|<
sizeof|sizeof
argument_list|(
name|ident
argument_list|)
condition|)
block|{
name|uint8_t
name|tag
decl_stmt|;
comment|/* Fetch just the first tag */
name|error
operator|=
name|bhnd_nvram_io_read
argument_list|(
name|io
argument_list|,
literal|0x0
argument_list|,
operator|&
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* This *could* be an empty TLV image, but all we're 		 * testing for here is a single 0x0 byte followed by EOF */
if|if
condition|(
name|tag
operator|==
name|NVRAM_TLV_TYPE_END
condition|)
return|return
operator|(
name|BHND_NVRAM_DATA_PROBE_MAYBE
operator|)
return|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Otherwise, look at the initial header for a valid TLV ENV tag, 	 * plus one byte of the entry data */
name|error
operator|=
name|bhnd_nvram_io_read
argument_list|(
name|io
argument_list|,
literal|0x0
argument_list|,
operator|&
name|ident
argument_list|,
sizeof|sizeof
argument_list|(
name|ident
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ident
operator|.
name|envp
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* First entry should be a variable record (which we statically 	 * assert as being defined to use a single byte size field) */
if|if
condition|(
name|ident
operator|.
name|hdr
operator|.
name|tag
operator|!=
name|NVRAM_TLV_TYPE_ENV
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
assert|_Static_assert
argument_list|(
name|NVRAM_TLV_TYPE_ENV
operator|&
name|NVRAM_TLV_TF_U8_LEN
argument_list|,
literal|"TYPE_ENV is not a U8-sized field"
argument_list|)
assert|;
comment|/* The entry must be at least 3 characters ('x=\0') in length */
if|if
condition|(
name|ident
operator|.
name|hdr
operator|.
name|size
operator|<
literal|3
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* The first character should be a valid key char (alpha) */
if|if
condition|(
operator|!
name|bhnd_nv_isalpha
argument_list|(
name|ident
operator|.
name|envp
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|BHND_NVRAM_DATA_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_tlv_getvar_direct
parameter_list|(
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|bhnd_nvram_type
name|type
parameter_list|)
block|{
name|struct
name|bhnd_nvram_tlv_env
name|env
decl_stmt|;
name|char
name|data
index|[
name|NVRAM_TLV_ENVP_DATA_MAX_LEN
index|]
decl_stmt|;
name|size_t
name|data_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|size_t
name|keylen
decl_stmt|,
name|vlen
decl_stmt|;
name|size_t
name|namelen
decl_stmt|;
name|size_t
name|next
decl_stmt|,
name|off
decl_stmt|;
name|uint8_t
name|tag
decl_stmt|;
name|int
name|error
decl_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Iterate over the input looking for the requested variable */
name|next
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|error
operator|=
name|bhnd_nvram_tlv_next_record
argument_list|(
name|io
argument_list|,
operator|&
name|next
argument_list|,
operator|&
name|off
argument_list|,
operator|&
name|tag
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|NVRAM_TLV_TYPE_END
case|:
comment|/* Not found */
return|return
operator|(
name|ENOENT
operator|)
return|;
case|case
name|NVRAM_TLV_TYPE_ENV
case|:
comment|/* Read the record header */
name|error
operator|=
name|bhnd_nvram_io_read
argument_list|(
name|io
argument_list|,
name|off
argument_list|,
operator|&
name|env
argument_list|,
sizeof|sizeof
argument_list|(
name|env
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error reading TLV_ENV record "
literal|"header: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Read the record data */
name|data_len
operator|=
name|NVRAM_TLV_ENVP_DATA_LEN
argument_list|(
operator|&
name|env
argument_list|)
expr_stmt|;
name|error
operator|=
name|bhnd_nvram_io_read
argument_list|(
name|io
argument_list|,
name|off
operator|+
sizeof|sizeof
argument_list|(
name|env
argument_list|)
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error reading TLV_ENV record "
literal|"data: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Parse the key=value string */
name|error
operator|=
name|bhnd_nvram_parse_env
argument_list|(
name|data
argument_list|,
name|data_len
argument_list|,
literal|'='
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|keylen
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|vlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error parsing TLV_ENV data: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Match against requested variable name */
if|if
condition|(
name|keylen
operator|==
name|namelen
operator|&&
name|strncmp
argument_list|(
name|key
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|bhnd_nvram_value_coerce
argument_list|(
name|value
argument_list|,
name|vlen
argument_list|,
name|BHND_NVRAM_TYPE_STRING
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
break|break;
default|default:
comment|/* Skip unknown tags */
break|break;
block|}
block|}
comment|/* Hit I/O error */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_tlv_serialize
parameter_list|(
name|bhnd_nvram_data_class
modifier|*
name|cls
parameter_list|,
name|bhnd_nvram_plist
modifier|*
name|props
parameter_list|,
name|bhnd_nvram_plist
modifier|*
name|options
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|)
block|{
name|bhnd_nvram_prop
modifier|*
name|prop
decl_stmt|;
name|size_t
name|limit
decl_stmt|,
name|nbytes
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Determine output byte limit */
if|if
condition|(
name|outp
operator|!=
name|NULL
condition|)
name|limit
operator|=
operator|*
name|olen
expr_stmt|;
else|else
name|limit
operator|=
literal|0
expr_stmt|;
name|nbytes
operator|=
literal|0
expr_stmt|;
comment|/* Write all properties */
name|prop
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|prop
operator|=
name|bhnd_nvram_plist_next
argument_list|(
name|props
argument_list|,
name|prop
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|bhnd_nvram_tlv_env
name|env
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|size_t
name|name_len
decl_stmt|,
name|value_len
decl_stmt|;
name|size_t
name|rec_size
decl_stmt|;
name|env
operator|.
name|hdr
operator|.
name|tag
operator|=
name|NVRAM_TLV_TYPE_ENV
expr_stmt|;
name|env
operator|.
name|hdr
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|env
operator|.
name|flags
argument_list|)
expr_stmt|;
name|env
operator|.
name|flags
operator|=
literal|0x0
expr_stmt|;
comment|/* Fetch name value and add to record length */
name|name
operator|=
name|bhnd_nvram_prop_name
argument_list|(
name|prop
argument_list|)
expr_stmt|;
name|name_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
comment|/* '=' */
expr_stmt|;
if|if
condition|(
name|UINT8_MAX
operator|-
name|env
operator|.
name|hdr
operator|.
name|size
operator|<
name|name_len
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"%s name exceeds maximum TLV record "
literal|"length\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
comment|/* would overflow TLV size */
block|}
name|env
operator|.
name|hdr
operator|.
name|size
operator|+=
name|name_len
expr_stmt|;
comment|/* Add string value to record length */
name|error
operator|=
name|bhnd_nvram_prop_encode
argument_list|(
name|prop
argument_list|,
name|NULL
argument_list|,
operator|&
name|value_len
argument_list|,
name|BHND_NVRAM_TYPE_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error serializing %s to required type "
literal|"%s: %d\n"
argument_list|,
name|name
argument_list|,
name|bhnd_nvram_type_name
argument_list|(
name|BHND_NVRAM_TYPE_STRING
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|UINT8_MAX
operator|-
name|env
operator|.
name|hdr
operator|.
name|size
operator|<
name|value_len
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"%s value exceeds maximum TLV record "
literal|"length\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
comment|/* would overflow TLV size */
block|}
name|env
operator|.
name|hdr
operator|.
name|size
operator|+=
name|value_len
expr_stmt|;
comment|/* Calculate total record size */
name|rec_size
operator|=
sizeof|sizeof
argument_list|(
name|env
operator|.
name|hdr
argument_list|)
operator|+
name|env
operator|.
name|hdr
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|SIZE_MAX
operator|-
name|nbytes
operator|<
name|rec_size
condition|)
return|return
operator|(
name|EFTYPE
operator|)
return|;
comment|/* would overflow size_t */
comment|/* Calculate our output pointer */
if|if
condition|(
name|nbytes
operator|>
name|limit
operator|||
name|limit
operator|-
name|nbytes
operator|<
name|rec_size
condition|)
block|{
comment|/* buffer is full; cannot write */
name|p
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|outp
operator|+
name|nbytes
expr_stmt|;
block|}
comment|/* Write to output */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
operator|&
name|env
argument_list|,
sizeof|sizeof
argument_list|(
name|env
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|name
argument_list|,
name|name_len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p
index|[
name|name_len
operator|-
literal|1
index|]
operator|=
literal|'='
expr_stmt|;
name|p
operator|+=
name|name_len
expr_stmt|;
name|error
operator|=
name|bhnd_nvram_prop_encode
argument_list|(
name|prop
argument_list|,
name|p
argument_list|,
operator|&
name|value_len
argument_list|,
name|BHND_NVRAM_TYPE_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error serializing %s to required "
literal|"type %s: %d\n"
argument_list|,
name|name
argument_list|,
name|bhnd_nvram_type_name
argument_list|(
name|BHND_NVRAM_TYPE_STRING
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|nbytes
operator|+=
name|rec_size
expr_stmt|;
block|}
comment|/* Write terminating END record */
if|if
condition|(
name|limit
operator|>
name|nbytes
condition|)
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|outp
operator|+
name|nbytes
operator|)
operator|=
name|NVRAM_TLV_TYPE_END
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
name|SIZE_MAX
condition|)
return|return
operator|(
name|EFTYPE
operator|)
return|;
comment|/* would overflow size_t */
name|nbytes
operator|++
expr_stmt|;
comment|/* Provide required length */
operator|*
name|olen
operator|=
name|nbytes
expr_stmt|;
if|if
condition|(
name|limit
operator|<
operator|*
name|olen
condition|)
block|{
if|if
condition|(
name|outp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize @p tlv with the provided NVRAM TLV data mapped by @p src.  *   * @param tlv A newly allocated data instance.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_tlv_init
parameter_list|(
name|struct
name|bhnd_nvram_tlv
modifier|*
name|tlv
parameter_list|,
name|struct
name|bhnd_nvram_io
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|bhnd_nvram_tlv_env
modifier|*
name|env
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|size_t
name|next
decl_stmt|;
name|int
name|error
decl_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|tlv
operator|->
name|data
operator|==
name|NULL
argument_list|,
operator|(
literal|"tlv data already initialized"
operator|)
argument_list|)
expr_stmt|;
comment|/* Determine the actual size of the TLV source data */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_tlv_parse_size
argument_list|(
name|src
argument_list|,
operator|&
name|size
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Copy to our own internal buffer */
if|if
condition|(
operator|(
name|tlv
operator|->
name|data
operator|=
name|bhnd_nvram_iobuf_copy_range
argument_list|(
name|src
argument_list|,
literal|0x0
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Initialize our backing buffer */
name|tlv
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|next
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|env
operator|=
name|bhnd_nvram_tlv_next_env
argument_list|(
name|tlv
argument_list|,
operator|&
name|next
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|env_len
decl_stmt|;
name|size_t
name|name_len
decl_stmt|;
comment|/* TLV_ENV data must not be empty */
name|env_len
operator|=
name|NVRAM_TLV_ENVP_DATA_LEN
argument_list|(
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_len
operator|==
literal|0
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"cannot parse zero-length TLV_ENV record "
literal|"data\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Parse the key=value string, and then replace the '=' 		 * delimiter with '\0' to allow us to provide direct  		 * name pointers from our backing buffer */
name|error
operator|=
name|bhnd_nvram_parse_env
argument_list|(
name|env
operator|->
name|envp
argument_list|,
name|env_len
argument_list|,
literal|'='
argument_list|,
name|NULL
argument_list|,
operator|&
name|name_len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error parsing TLV_ENV data: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Replace '=' with '\0' */
operator|*
operator|(
name|env
operator|->
name|envp
operator|+
name|name_len
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* Add to variable count */
name|tlv
operator|->
name|count
operator|++
expr_stmt|;
block|}
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_tlv_new
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|bhnd_nvram_tlv
modifier|*
name|tlv
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allocate and initialize the TLV data instance */
name|tlv
operator|=
operator|(
expr|struct
name|bhnd_nvram_tlv
operator|*
operator|)
name|nv
expr_stmt|;
comment|/* Parse the TLV input data and initialize our backing 	 * data representation */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_tlv_init
argument_list|(
name|tlv
argument_list|,
name|io
argument_list|)
operator|)
condition|)
block|{
name|bhnd_nvram_tlv_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bhnd_nvram_tlv_free
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|)
block|{
name|struct
name|bhnd_nvram_tlv
modifier|*
name|tlv
init|=
operator|(
expr|struct
name|bhnd_nvram_tlv
operator|*
operator|)
name|nv
decl_stmt|;
if|if
condition|(
name|tlv
operator|->
name|data
operator|!=
name|NULL
condition|)
name|bhnd_nvram_io_free
argument_list|(
name|tlv
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|bhnd_nvram_tlv_count
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|)
block|{
name|struct
name|bhnd_nvram_tlv
modifier|*
name|tlv
init|=
operator|(
expr|struct
name|bhnd_nvram_tlv
operator|*
operator|)
name|nv
decl_stmt|;
return|return
operator|(
name|tlv
operator|->
name|count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bhnd_nvram_plist
modifier|*
name|bhnd_nvram_tlv_options
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|bhnd_nvram_tlv_caps
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|)
block|{
return|return
operator|(
name|BHND_NVRAM_DATA_CAP_READ_PTR
operator||
name|BHND_NVRAM_DATA_CAP_DEVPATHS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|bhnd_nvram_tlv_next
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|bhnd_nvram_tlv
modifier|*
name|tlv
decl_stmt|;
name|struct
name|bhnd_nvram_tlv_env
modifier|*
name|env
decl_stmt|;
name|size_t
name|io_offset
decl_stmt|;
name|tlv
operator|=
operator|(
expr|struct
name|bhnd_nvram_tlv
operator|*
operator|)
name|nv
expr_stmt|;
comment|/* Find next readable TLV record */
if|if
condition|(
operator|*
name|cookiep
operator|==
name|NULL
condition|)
block|{
comment|/* Start search at offset 0x0 */
name|io_offset
operator|=
literal|0x0
expr_stmt|;
name|env
operator|=
name|bhnd_nvram_tlv_next_env
argument_list|(
name|tlv
argument_list|,
operator|&
name|io_offset
argument_list|,
name|cookiep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Seek past the previous env record */
name|io_offset
operator|=
name|bhnd_nvram_tlv_to_offset
argument_list|(
name|tlv
argument_list|,
operator|*
name|cookiep
argument_list|)
expr_stmt|;
name|env
operator|=
name|bhnd_nvram_tlv_next_env
argument_list|(
name|tlv
argument_list|,
operator|&
name|io_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|==
name|NULL
condition|)
name|BHND_NV_PANIC
argument_list|(
literal|"invalid cookiep; record missing"
argument_list|)
expr_stmt|;
comment|/* Advance to next env record, update the caller's cookiep */
name|env
operator|=
name|bhnd_nvram_tlv_next_env
argument_list|(
name|tlv
argument_list|,
operator|&
name|io_offset
argument_list|,
name|cookiep
argument_list|)
expr_stmt|;
block|}
comment|/* Check for EOF */
if|if
condition|(
name|env
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Return the NUL terminated name */
return|return
operator|(
name|env
operator|->
name|envp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|bhnd_nvram_tlv_find
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_data_generic_find
argument_list|(
name|nv
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_tlv_getvar_order
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
name|cookiep1
parameter_list|,
name|void
modifier|*
name|cookiep2
parameter_list|)
block|{
if|if
condition|(
name|cookiep1
operator|<
name|cookiep2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|cookiep1
operator|>
name|cookiep2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_tlv_getvar
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|bhnd_nvram_type
name|type
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_data_generic_rp_getvar
argument_list|(
name|nv
argument_list|,
name|cookiep
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_tlv_copy_val
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|,
name|bhnd_nvram_val
modifier|*
modifier|*
name|value
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_data_generic_rp_copy_val
argument_list|(
name|nv
argument_list|,
name|cookiep
argument_list|,
name|value
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|bhnd_nvram_tlv_getvar_ptr
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|bhnd_nvram_type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|bhnd_nvram_tlv
modifier|*
name|tlv
decl_stmt|;
name|struct
name|bhnd_nvram_tlv_env
modifier|*
name|env
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tlv
operator|=
operator|(
expr|struct
name|bhnd_nvram_tlv
operator|*
operator|)
name|nv
expr_stmt|;
comment|/* Fetch pointer to the TLV_ENV record */
if|if
condition|(
operator|(
name|env
operator|=
name|bhnd_nvram_tlv_get_env
argument_list|(
name|tlv
argument_list|,
name|cookiep
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|BHND_NV_PANIC
argument_list|(
literal|"invalid cookiep: %p"
argument_list|,
name|cookiep
argument_list|)
expr_stmt|;
comment|/* Parse value pointer and length from key\0value data */
name|error
operator|=
name|bhnd_nvram_parse_env
argument_list|(
name|env
operator|->
name|envp
argument_list|,
name|NVRAM_TLV_ENVP_DATA_LEN
argument_list|(
name|env
argument_list|)
argument_list|,
literal|'\0'
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|BHND_NV_PANIC
argument_list|(
literal|"unexpected error parsing '%s'"
argument_list|,
name|env
operator|->
name|envp
argument_list|)
expr_stmt|;
comment|/* Type is always CSTR */
operator|*
name|type
operator|=
name|BHND_NVRAM_TYPE_STRING
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|bhnd_nvram_tlv_getvar_name
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|bhnd_nvram_tlv
modifier|*
name|tlv
decl_stmt|;
specifier|const
name|struct
name|bhnd_nvram_tlv_env
modifier|*
name|env
decl_stmt|;
name|tlv
operator|=
operator|(
expr|struct
name|bhnd_nvram_tlv
operator|*
operator|)
name|nv
expr_stmt|;
comment|/* Fetch pointer to the TLV_ENV record */
if|if
condition|(
operator|(
name|env
operator|=
name|bhnd_nvram_tlv_get_env
argument_list|(
name|tlv
argument_list|,
name|cookiep
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|BHND_NV_PANIC
argument_list|(
literal|"invalid cookiep: %p"
argument_list|,
name|cookiep
argument_list|)
expr_stmt|;
comment|/* Return name pointer */
return|return
operator|(
operator|&
name|env
operator|->
name|envp
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_tlv_filter_setvar
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
name|bhnd_nvram_val
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|bhnd_nvram_val
modifier|*
name|str
decl_stmt|;
specifier|const
name|char
modifier|*
name|inp
decl_stmt|;
name|bhnd_nvram_type
name|itype
decl_stmt|;
name|size_t
name|ilen
decl_stmt|;
name|size_t
name|name_len
decl_stmt|,
name|tlv_nremain
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tlv_nremain
operator|=
name|NVRAM_TLV_ENVP_DATA_MAX_LEN
expr_stmt|;
comment|/* Name (trimmed of any path prefix) must be valid */
if|if
condition|(
operator|!
name|bhnd_nvram_validate_name
argument_list|(
name|bhnd_nvram_trim_path_name
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 'name=' must fit within the maximum TLV_ENV record length */
name|name_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* '=' */
if|if
condition|(
name|tlv_nremain
operator|<
name|name_len
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"'%s=' exceeds maximum TLV_ENV record length\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|tlv_nremain
operator|-=
name|name_len
expr_stmt|;
comment|/* Convert value to a (bcm-formatted) string */
name|error
operator|=
name|bhnd_nvram_val_convert_new
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|bhnd_nvram_val_bcm_string_fmt
argument_list|,
name|value
argument_list|,
name|BHND_NVRAM_VAL_DYNAMIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* The string value must fit within remaining TLV_ENV record length */
name|inp
operator|=
name|bhnd_nvram_val_bytes
argument_list|(
name|str
argument_list|,
operator|&
name|ilen
argument_list|,
operator|&
name|itype
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlv_nremain
operator|<
name|ilen
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"'%.*s\\0' exceeds maximum TLV_ENV record length\n"
argument_list|,
name|BHND_NV_PRINT_WIDTH
argument_list|(
name|ilen
argument_list|)
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|bhnd_nvram_val_release
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|tlv_nremain
operator|-=
name|name_len
expr_stmt|;
comment|/* Success. Transfer result ownership to the caller. */
operator|*
name|result
operator|=
name|str
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_tlv_filter_unsetvar
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* We permit deletion of any variable */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Iterate over the records starting at @p next, returning the parsed  * record's @p tag, @p size, and @p offset.  *   * @param		io		The I/O context to parse.  * @param[in,out]	next		The next offset to be parsed, or 0x0  *					to begin parsing. Upon successful  *					return, will be set to the offset of the  *					next record (or EOF, if  *					NVRAM_TLV_TYPE_END was parsed).  * @param[out]		offset		The record's value offset.  * @param[out]		tag		The record's tag.  *   * @retval 0		success  * @retval EINVAL	if parsing @p io as TLV fails.  * @retval non-zero	if reading @p io otherwise fails, a regular unix error  *			code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_tlv_next_record
parameter_list|(
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|,
name|size_t
modifier|*
name|next
parameter_list|,
name|size_t
modifier|*
name|offset
parameter_list|,
name|uint8_t
modifier|*
name|tag
parameter_list|)
block|{
name|size_t
name|io_offset
decl_stmt|,
name|io_size
decl_stmt|;
name|uint16_t
name|parsed_len
decl_stmt|;
name|uint8_t
name|len_hdr
index|[
literal|2
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|io_offset
operator|=
operator|*
name|next
expr_stmt|;
name|io_size
operator|=
name|bhnd_nvram_io_getsize
argument_list|(
name|io
argument_list|)
expr_stmt|;
comment|/* Save the record offset */
if|if
condition|(
name|offset
operator|!=
name|NULL
condition|)
operator|*
name|offset
operator|=
name|io_offset
expr_stmt|;
comment|/* Fetch initial tag */
name|error
operator|=
name|bhnd_nvram_io_read
argument_list|(
name|io
argument_list|,
name|io_offset
argument_list|,
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|io_offset
operator|++
expr_stmt|;
comment|/* EOF */
if|if
condition|(
operator|*
name|tag
operator|==
name|NVRAM_TLV_TYPE_END
condition|)
block|{
operator|*
name|next
operator|=
name|io_offset
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Read length field */
if|if
condition|(
operator|*
name|tag
operator|&
name|NVRAM_TLV_TF_U8_LEN
condition|)
block|{
name|error
operator|=
name|bhnd_nvram_io_read
argument_list|(
name|io
argument_list|,
name|io_offset
argument_list|,
operator|&
name|len_hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|len_hdr
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error reading TLV record size: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|parsed_len
operator|=
name|len_hdr
index|[
literal|0
index|]
expr_stmt|;
name|io_offset
operator|++
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|bhnd_nvram_io_read
argument_list|(
name|io
argument_list|,
name|io_offset
argument_list|,
operator|&
name|len_hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|len_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error reading 16-bit TLV record "
literal|"size: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|parsed_len
operator|=
operator|(
name|len_hdr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|len_hdr
index|[
literal|1
index|]
expr_stmt|;
name|io_offset
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Advance to next record */
if|if
condition|(
name|parsed_len
operator|>
name|io_size
operator|||
name|io_size
operator|-
name|parsed_len
operator|<
name|io_offset
condition|)
block|{
comment|/* Hit early EOF */
name|BHND_NV_LOG
argument_list|(
literal|"TLV record length %hu truncated by input "
literal|"size of %zu\n"
argument_list|,
name|parsed_len
argument_list|,
name|io_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|next
operator|=
name|io_offset
operator|+
name|parsed_len
expr_stmt|;
comment|/* Valid record found */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Parse the TLV data in @p io to determine the total size of the TLV  * data mapped by @p io (which may be less than the size of @p io).  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_tlv_parse_size
parameter_list|(
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|size_t
name|next
decl_stmt|;
name|uint8_t
name|tag
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* We have to perform a minimal parse to determine the actual length */
name|next
operator|=
literal|0x0
expr_stmt|;
operator|*
name|size
operator|=
literal|0x0
expr_stmt|;
comment|/* Iterate over the input until we hit END tag or the read fails */
do|do
block|{
name|error
operator|=
name|bhnd_nvram_tlv_next_record
argument_list|(
name|io
argument_list|,
operator|&
name|next
argument_list|,
name|NULL
argument_list|,
operator|&
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
do|while
condition|(
name|tag
operator|!=
name|NVRAM_TLV_TYPE_END
condition|)
do|;
comment|/* Offset should now point to EOF */
name|BHND_NV_ASSERT
argument_list|(
name|next
operator|<=
name|bhnd_nvram_io_getsize
argument_list|(
name|io
argument_list|)
argument_list|,
operator|(
literal|"parse returned invalid EOF offset"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|size
operator|=
name|next
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Iterate over the records in @p tlv, returning a pointer to the next  * NVRAM_TLV_TYPE_ENV record, or NULL if EOF is reached.  *   * @param		tlv		The TLV instance.  * @param[in,out]	next		The next offset to be parsed, or 0x0  *					to begin parsing. Upon successful  *					return, will be set to the offset of the  *					next record.  */
end_comment

begin_function
specifier|static
name|struct
name|bhnd_nvram_tlv_env
modifier|*
name|bhnd_nvram_tlv_next_env
parameter_list|(
name|struct
name|bhnd_nvram_tlv
modifier|*
name|tlv
parameter_list|,
name|size_t
modifier|*
name|next
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|uint8_t
name|tag
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Find the next TLV_ENV record, starting at @p next */
do|do
block|{
name|void
modifier|*
name|c
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
comment|/* Fetch the next TLV record */
name|error
operator|=
name|bhnd_nvram_tlv_next_record
argument_list|(
name|tlv
operator|->
name|data
argument_list|,
name|next
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"unexpected error in next_record(): %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Only interested in ENV records */
if|if
condition|(
name|tag
operator|!=
name|NVRAM_TLV_TYPE_ENV
condition|)
continue|continue;
comment|/* Map and return TLV_ENV record pointer */
name|c
operator|=
name|bhnd_nvram_tlv_to_cookie
argument_list|(
name|tlv
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* Provide the cookiep value for the returned record */
if|if
condition|(
name|cookiep
operator|!=
name|NULL
condition|)
operator|*
name|cookiep
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|bhnd_nvram_tlv_get_env
argument_list|(
name|tlv
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
do|while
condition|(
name|tag
operator|!=
name|NVRAM_TLV_TYPE_END
condition|)
do|;
comment|/* No remaining ENV records */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return a pointer to the TLV_ENV record for @p cookiep, or NULL  * if none vailable.  */
end_comment

begin_function
specifier|static
name|struct
name|bhnd_nvram_tlv_env
modifier|*
name|bhnd_nvram_tlv_get_env
parameter_list|(
name|struct
name|bhnd_nvram_tlv
modifier|*
name|tlv
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|bhnd_nvram_tlv_env
modifier|*
name|env
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|navail
decl_stmt|;
name|size_t
name|io_offset
decl_stmt|,
name|io_size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|io_size
operator|=
name|bhnd_nvram_io_getsize
argument_list|(
name|tlv
operator|->
name|data
argument_list|)
expr_stmt|;
name|io_offset
operator|=
name|bhnd_nvram_tlv_to_offset
argument_list|(
name|tlv
argument_list|,
name|cookiep
argument_list|)
expr_stmt|;
comment|/* At EOF? */
if|if
condition|(
name|io_offset
operator|==
name|io_size
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Fetch non-const pointer to the record entry */
name|error
operator|=
name|bhnd_nvram_io_write_ptr
argument_list|(
name|tlv
operator|->
name|data
argument_list|,
name|io_offset
argument_list|,
operator|&
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|env
operator|->
name|hdr
argument_list|)
argument_list|,
operator|&
name|navail
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* Should never occur with a valid cookiep */
name|BHND_NV_LOG
argument_list|(
literal|"error mapping record for cookiep: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Validate the record pointer */
name|env
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|env
operator|->
name|hdr
operator|.
name|tag
operator|!=
name|NVRAM_TLV_TYPE_ENV
condition|)
block|{
comment|/* Should never occur with a valid cookiep */
name|BHND_NV_LOG
argument_list|(
literal|"non-ENV record mapped for %p\n"
argument_list|,
name|cookiep
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Is the required variable name data is mapped? */
if|if
condition|(
name|navail
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|bhnd_nvram_tlv_env_hdr
argument_list|)
operator|+
name|env
operator|->
name|hdr
operator|.
name|size
operator|||
name|env
operator|->
name|hdr
operator|.
name|size
operator|==
sizeof|sizeof
argument_list|(
name|env
operator|->
name|flags
argument_list|)
condition|)
block|{
comment|/* Should never occur with a valid cookiep */
name|BHND_NV_LOG
argument_list|(
literal|"TLV_ENV variable data not mapped for %p\n"
argument_list|,
name|cookiep
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|env
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return a cookiep for the given I/O offset.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|bhnd_nvram_tlv_to_cookie
parameter_list|(
name|struct
name|bhnd_nvram_tlv
modifier|*
name|tlv
parameter_list|,
name|size_t
name|io_offset
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|io_offset
operator|<
name|bhnd_nvram_io_getsize
argument_list|(
name|tlv
operator|->
name|data
argument_list|)
argument_list|,
operator|(
literal|"io_offset %zu out-of-range"
operator|,
name|io_offset
operator|)
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|io_offset
operator|<
name|UINTPTR_MAX
argument_list|,
operator|(
literal|"io_offset %#zx exceeds UINTPTR_MAX"
operator|,
name|io_offset
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|bhnd_nvram_io_read_ptr
argument_list|(
name|tlv
operator|->
name|data
argument_list|,
literal|0x0
argument_list|,
operator|&
name|ptr
argument_list|,
name|io_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|BHND_NV_PANIC
argument_list|(
literal|"error mapping offset %zu: %d"
argument_list|,
name|io_offset
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|ptr
operator|+
name|io_offset
expr_stmt|;
return|return
operator|(
name|__DECONST
argument_list|(
name|void
operator|*
argument_list|,
name|ptr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert a cookiep back to an I/O offset */
end_comment

begin_function
specifier|static
name|size_t
name|bhnd_nvram_tlv_to_offset
parameter_list|(
name|struct
name|bhnd_nvram_tlv
modifier|*
name|tlv
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|ptr
decl_stmt|;
name|intptr_t
name|offset
decl_stmt|;
name|size_t
name|io_size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|cookiep
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null cookiep"
operator|)
argument_list|)
expr_stmt|;
name|io_size
operator|=
name|bhnd_nvram_io_getsize
argument_list|(
name|tlv
operator|->
name|data
argument_list|)
expr_stmt|;
name|error
operator|=
name|bhnd_nvram_io_read_ptr
argument_list|(
name|tlv
operator|->
name|data
argument_list|,
literal|0x0
argument_list|,
operator|&
name|ptr
argument_list|,
name|io_size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|BHND_NV_PANIC
argument_list|(
literal|"error mapping offset %zu: %d"
argument_list|,
name|io_size
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|cookiep
operator|-
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|ptr
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|offset
operator|>=
literal|0
argument_list|,
operator|(
literal|"invalid cookiep"
operator|)
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
operator|(
name|uintptr_t
operator|)
name|offset
operator|<
name|SIZE_MAX
argument_list|,
operator|(
literal|"cookiep> SIZE_MAX)"
operator|)
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
operator|(
name|uintptr_t
operator|)
name|offset
operator|<=
name|io_size
argument_list|,
operator|(
literal|"cookiep> io_size)"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|size_t
operator|)
name|offset
operator|)
return|;
block|}
end_function

end_unit

