begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Landon Fuller<landonf@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/_inttypes.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_KERNEL */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_include
include|#
directive|include
file|"bhnd_nvram_private.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_data_spromvar.h"
end_include

begin_function_decl
specifier|static
name|int
name|bhnd_sprom_opcode_sort_idx
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_opcode_idx_vid_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_sprom_opcode_reset
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_sprom_opcode_next_var
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_sprom_opcode_set_type
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|bhnd_nvram_type
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_sprom_opcode_set_var
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|size_t
name|vid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_sprom_opcode_clear_var
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_sprom_opcode_flush_bind
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_sprom_opcode_read_opval32
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint8_t
name|type
parameter_list|,
name|uint32_t
modifier|*
name|opval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_sprom_opcode_step
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint8_t
modifier|*
name|opcode
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SPROM_OP_BAD
parameter_list|(
name|_state
parameter_list|,
name|_fmt
parameter_list|,
modifier|...
parameter_list|)
define|\
value|BHND_NV_LOG("bad encoding at %td: " _fmt,			\ 	    (_state)->input - (_state)->layout->bindings, ##__VA_ARGS__)
end_define

begin_comment
comment|/**  * Initialize SPROM opcode evaluation state.  *   * @param state The opcode state to be initialized.  * @param layout The SPROM layout to be parsed by this instance.  *   *   * @retval 0 success  * @retval non-zero If initialization fails, a regular unix error code will be  * returned.  */
end_comment

begin_function
name|int
name|bhnd_sprom_opcode_init
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
specifier|const
name|struct
name|bhnd_sprom_layout
modifier|*
name|layout
parameter_list|)
block|{
name|bhnd_sprom_opcode_idx_entry
modifier|*
name|idx
decl_stmt|;
name|size_t
name|num_vars
decl_stmt|,
name|num_idx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|idx
operator|=
name|NULL
expr_stmt|;
name|state
operator|->
name|layout
operator|=
name|layout
expr_stmt|;
name|state
operator|->
name|idx
operator|=
name|NULL
expr_stmt|;
name|state
operator|->
name|num_idx
operator|=
literal|0
expr_stmt|;
comment|/* Initialize interpretation state */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_reset
argument_list|(
name|state
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Allocate and populate our opcode index */
name|num_idx
operator|=
name|state
operator|->
name|layout
operator|->
name|num_vars
expr_stmt|;
name|idx
operator|=
name|bhnd_nv_calloc
argument_list|(
name|num_idx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|idx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|num_vars
operator|=
literal|0
init|;
name|num_vars
operator|<
name|num_idx
condition|;
name|num_vars
operator|++
control|)
block|{
name|size_t
name|opcodes
decl_stmt|;
comment|/* Seek to next entry */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_next_var
argument_list|(
name|state
argument_list|)
operator|)
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"error reading expected variable "
literal|"entry: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bhnd_nv_free
argument_list|(
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* We limit the SPROM index representations to the minimal 		 * type widths capable of covering all known layouts */
comment|/* Save SPROM image offset */
if|if
condition|(
name|state
operator|->
name|offset
operator|>
name|UINT16_MAX
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"cannot index large offset %u\n"
argument_list|,
name|state
operator|->
name|offset
argument_list|)
expr_stmt|;
name|bhnd_nv_free
argument_list|(
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|idx
index|[
name|num_vars
index|]
operator|.
name|offset
operator|=
name|state
operator|->
name|offset
expr_stmt|;
comment|/* Save current variable ID */
if|if
condition|(
name|state
operator|->
name|vid
operator|>
name|UINT16_MAX
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"cannot index large vid %zu\n"
argument_list|,
name|state
operator|->
name|vid
argument_list|)
expr_stmt|;
name|bhnd_nv_free
argument_list|(
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|idx
index|[
name|num_vars
index|]
operator|.
name|vid
operator|=
name|state
operator|->
name|vid
expr_stmt|;
comment|/* Save opcode position */
name|opcodes
operator|=
operator|(
name|state
operator|->
name|input
operator|-
name|state
operator|->
name|layout
operator|->
name|bindings
operator|)
expr_stmt|;
if|if
condition|(
name|opcodes
operator|>
name|UINT16_MAX
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"cannot index large opcode offset "
literal|"%zu\n"
argument_list|,
name|opcodes
argument_list|)
expr_stmt|;
name|bhnd_nv_free
argument_list|(
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|idx
index|[
name|num_vars
index|]
operator|.
name|opcodes
operator|=
name|opcodes
expr_stmt|;
block|}
comment|/* Should have reached end of binding table; next read must return 	 * ENOENT */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_next_var
argument_list|(
name|state
argument_list|)
operator|)
operator|!=
name|ENOENT
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"expected EOF parsing binding table: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bhnd_nv_free
argument_list|(
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Reset interpretation state */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_reset
argument_list|(
name|state
argument_list|)
operator|)
condition|)
block|{
name|bhnd_nv_free
argument_list|(
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Make index available to opcode state evaluation */
name|qsort
argument_list|(
name|idx
argument_list|,
name|num_idx
argument_list|,
sizeof|sizeof
argument_list|(
name|idx
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|bhnd_sprom_opcode_sort_idx
argument_list|)
expr_stmt|;
name|state
operator|->
name|idx
operator|=
name|idx
expr_stmt|;
name|state
operator|->
name|num_idx
operator|=
name|num_idx
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Reset SPROM opcode evaluation state; future evaluation will be performed  * starting at the first opcode.  *   * @param state The opcode state to be reset.  *  * @retval 0 success  * @retval non-zero If reset fails, a regular unix error code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_sprom_opcode_reset
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|)
block|{
name|memset
argument_list|(
operator|&
name|state
operator|->
name|var
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|input
operator|=
name|state
operator|->
name|layout
operator|->
name|bindings
expr_stmt|;
name|state
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|vid
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|var_state
operator|=
name|SPROM_OPCODE_VAR_STATE_NONE
expr_stmt|;
name|bit_set
argument_list|(
name|state
operator|->
name|revs
argument_list|,
name|state
operator|->
name|layout
operator|->
name|rev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Free any resources associated with @p state.  *   * @param state An opcode state previously successfully initialized with  * bhnd_sprom_opcode_init().  */
end_comment

begin_function
name|void
name|bhnd_sprom_opcode_fini
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|)
block|{
name|bhnd_nv_free
argument_list|(
name|state
operator|->
name|idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Sort function used to prepare our index for querying; sorts  * bhnd_sprom_opcode_idx_entry values by variable ID, ascending.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_sprom_opcode_sort_idx
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
specifier|const
name|bhnd_sprom_opcode_idx_entry
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|l
operator|=
name|lhs
expr_stmt|;
name|r
operator|=
name|rhs
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|vid
operator|<
name|r
operator|->
name|vid
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|l
operator|->
name|vid
operator|>
name|r
operator|->
name|vid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Binary search comparison function used by bhnd_sprom_opcode_index_find();  * searches bhnd_sprom_opcode_idx_entry values by variable ID, ascending.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_opcode_idx_vid_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
specifier|const
name|bhnd_sprom_opcode_idx_entry
modifier|*
name|entry
decl_stmt|;
name|size_t
name|vid
decl_stmt|;
name|vid
operator|=
operator|*
operator|(
specifier|const
name|size_t
operator|*
operator|)
name|key
expr_stmt|;
name|entry
operator|=
name|rhs
expr_stmt|;
if|if
condition|(
name|vid
operator|<
name|entry
operator|->
name|vid
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|vid
operator|>
name|entry
operator|->
name|vid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Locate an index entry for the variable with @p name, or NULL if not found.  *   * @param state The opcode state to be queried.  * @param name	The name to search for.  *  * @retval non-NULL	If @p name is found, its index entry value will be  *			returned.  * @retval NULL		If @p name is not found.  */
end_comment

begin_function
name|bhnd_sprom_opcode_idx_entry
modifier|*
name|bhnd_sprom_opcode_index_find
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
decl_stmt|;
name|size_t
name|vid
decl_stmt|;
comment|/* Determine the variable ID for the given name */
if|if
condition|(
operator|(
name|var
operator|=
name|bhnd_nvram_find_vardefn
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|vid
operator|=
name|bhnd_nvram_get_vardefn_id
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* Search our index for the variable ID */
return|return
operator|(
name|bsearch
argument_list|(
operator|&
name|vid
argument_list|,
name|state
operator|->
name|idx
argument_list|,
name|state
operator|->
name|num_idx
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|idx
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|bhnd_nvram_opcode_idx_vid_compare
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Iterate over all index entries in @p state.  *   * @param		state	The opcode state to be iterated.  * @param[in,out]	prev	An entry previously returned by  *				bhnd_sprom_opcode_index_next(), or a NULL value  *				to begin iteration.  *   * @return Returns the next index entry name, or NULL if all entries have  * been iterated.  */
end_comment

begin_function
name|bhnd_sprom_opcode_idx_entry
modifier|*
name|bhnd_sprom_opcode_index_next
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|bhnd_sprom_opcode_idx_entry
modifier|*
name|prev
parameter_list|)
block|{
name|size_t
name|idxpos
decl_stmt|;
comment|/* Get next index position */
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|idxpos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Determine current position */
name|idxpos
operator|=
call|(
name|size_t
call|)
argument_list|(
name|prev
operator|-
name|state
operator|->
name|idx
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|idxpos
operator|<
name|state
operator|->
name|num_idx
argument_list|,
operator|(
literal|"invalid index %zu"
operator|,
name|idxpos
operator|)
argument_list|)
expr_stmt|;
comment|/* Advance to next entry */
name|idxpos
operator|++
expr_stmt|;
block|}
comment|/* Check for EOF */
if|if
condition|(
name|idxpos
operator|==
name|state
operator|->
name|num_idx
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|state
operator|->
name|idx
index|[
name|idxpos
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Reset SPROM opcode evaluation state and seek to the @p entry's position.  *   * @param state The opcode state to be reset.  * @param entry The indexed entry to which we'll seek the opcode state.  */
end_comment

begin_function
name|int
name|bhnd_sprom_opcode_seek
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|bhnd_sprom_opcode_idx_entry
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|entry
operator|->
name|opcodes
operator|<
name|state
operator|->
name|layout
operator|->
name|bindings_size
argument_list|,
operator|(
literal|"index entry references invalid opcode position"
operator|)
argument_list|)
expr_stmt|;
comment|/* Reset state */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_reset
argument_list|(
name|state
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Seek to the indexed sprom opcode offset */
name|state
operator|->
name|input
operator|=
name|state
operator|->
name|layout
operator|->
name|bindings
operator|+
name|entry
operator|->
name|opcodes
expr_stmt|;
comment|/* Restore the indexed sprom data offset and VID */
name|state
operator|->
name|offset
operator|=
name|entry
operator|->
name|offset
expr_stmt|;
comment|/* Restore the indexed sprom variable ID */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_set_var
argument_list|(
name|state
argument_list|,
name|entry
operator|->
name|vid
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Set the current revision range for @p state. This also resets  * variable state.  *   * @param state The opcode state to update  * @param start The first revision in the range.  * @param end The last revision in the range.  *  * @retval 0 success  * @retval non-zero If updating @p state fails, a regular unix error code will  * be returned.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|bhnd_sprom_opcode_set_revs
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint8_t
name|start
parameter_list|,
name|uint8_t
name|end
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Validate the revision range */
if|if
condition|(
name|start
operator|>
name|SPROM_OP_REV_MAX
operator|||
name|end
operator|>
name|SPROM_OP_REV_MAX
operator|||
name|end
operator|<
name|start
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"invalid revision range: %hhu-%hhu\n"
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Clear variable state */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_clear_var
argument_list|(
name|state
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Reset revision mask */
name|memset
argument_list|(
name|state
operator|->
name|revs
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|revs
argument_list|)
argument_list|)
expr_stmt|;
name|bit_nset
argument_list|(
name|state
operator|->
name|revs
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Set the current variable's value mask for @p state.  *   * @param state The opcode state to update  * @param mask The mask to be set  *  * @retval 0 success  * @retval non-zero If updating @p state fails, a regular unix error code will  * be returned.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|bhnd_sprom_opcode_set_mask
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
if|if
condition|(
name|state
operator|->
name|var_state
operator|!=
name|SPROM_OPCODE_VAR_STATE_OPEN
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"no open variable definition\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|state
operator|->
name|var
operator|.
name|mask
operator|=
name|mask
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Set the current variable's value shift for @p state.  *   * @param state The opcode state to update  * @param shift The shift to be set  *  * @retval 0 success  * @retval non-zero If updating @p state fails, a regular unix error code will  * be returned.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|bhnd_sprom_opcode_set_shift
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|int8_t
name|shift
parameter_list|)
block|{
if|if
condition|(
name|state
operator|->
name|var_state
operator|!=
name|SPROM_OPCODE_VAR_STATE_OPEN
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"no open variable definition\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|state
operator|->
name|var
operator|.
name|shift
operator|=
name|shift
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Register a new BIND/BINDN operation with @p state.  *   * @param state The opcode state to update.  * @param count The number of elements to be bound.  * @param skip_in The number of input elements to skip after each bind.  * @param skip_in_negative If true, the input skip should be subtracted from  * the current offset after each bind. If false, the input skip should be  * added.  * @param skip_out The number of output elements to skip after each bind.  *   * @retval 0 success  * @retval EINVAL if a variable definition is not open.  * @retval EINVAL if @p skip_in and @p count would trigger an overflow or  * underflow when applied to the current input offset.  * @retval ERANGE if @p skip_in would overflow uint32_t when multiplied by  * @p count and the scale value.  * @retval ERANGE if @p skip_out would overflow uint32_t when multiplied by  * @p count and the scale value.  * @retval non-zero If updating @p state otherwise fails, a regular unix error  * code will be returned.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|bhnd_sprom_opcode_set_bind
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint8_t
name|count
parameter_list|,
name|uint8_t
name|skip_in
parameter_list|,
name|bool
name|skip_in_negative
parameter_list|,
name|uint8_t
name|skip_out
parameter_list|)
block|{
name|uint32_t
name|iskip_total
decl_stmt|;
name|uint32_t
name|iskip_scaled
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Must have an open variable */
if|if
condition|(
name|state
operator|->
name|var_state
operator|!=
name|SPROM_OPCODE_VAR_STATE_OPEN
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"no open variable definition\n"
argument_list|)
expr_stmt|;
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"BIND outside of variable definition\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Cannot overwite an existing bind definition */
if|if
condition|(
name|state
operator|->
name|var
operator|.
name|have_bind
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"BIND overwrites existing definition\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Must have a count of at least 1 */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"BIND with zero count\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Scale skip_in by the current type width */
name|iskip_scaled
operator|=
name|skip_in
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_apply_scale
argument_list|(
name|state
argument_list|,
operator|&
name|iskip_scaled
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Calculate total input bytes skipped: iskip_scaled * count) */
if|if
condition|(
name|iskip_scaled
operator|>
literal|0
operator|&&
name|UINT32_MAX
operator|/
name|iskip_scaled
operator|<
name|count
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"skip_in %hhu would overflow"
argument_list|,
name|skip_in
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|iskip_total
operator|=
name|iskip_scaled
operator|*
name|count
expr_stmt|;
comment|/* Verify that the skip_in value won't under/overflow the current 	 * input offset. */
if|if
condition|(
name|skip_in_negative
condition|)
block|{
if|if
condition|(
name|iskip_total
operator|>
name|state
operator|->
name|offset
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"skip_in %hhu would underflow "
literal|"offset %u\n"
argument_list|,
name|skip_in
argument_list|,
name|state
operator|->
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|UINT32_MAX
operator|-
name|iskip_total
operator|<
name|state
operator|->
name|offset
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"skip_in %hhu would overflow "
literal|"offset %u\n"
argument_list|,
name|skip_in
argument_list|,
name|state
operator|->
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/* Set the actual count and skip values */
name|state
operator|->
name|var
operator|.
name|have_bind
operator|=
name|true
expr_stmt|;
name|state
operator|->
name|var
operator|.
name|bind
operator|.
name|count
operator|=
name|count
expr_stmt|;
name|state
operator|->
name|var
operator|.
name|bind
operator|.
name|skip_in
operator|=
name|skip_in
expr_stmt|;
name|state
operator|->
name|var
operator|.
name|bind
operator|.
name|skip_out
operator|=
name|skip_out
expr_stmt|;
name|state
operator|->
name|var
operator|.
name|bind
operator|.
name|skip_in_negative
operator|=
name|skip_in_negative
expr_stmt|;
comment|/* Update total bind count for the current variable */
name|state
operator|->
name|var
operator|.
name|bind_total
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Apply and clear the current opcode bind state, if any.  *   * @param state The opcode state to update.  *   * @retval 0 success  * @retval non-zero If updating @p state otherwise fails, a regular unix error  * code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_sprom_opcode_flush_bind
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint32_t
name|skip
decl_stmt|;
comment|/* Nothing to do? */
if|if
condition|(
name|state
operator|->
name|var_state
operator|!=
name|SPROM_OPCODE_VAR_STATE_OPEN
operator|||
operator|!
name|state
operator|->
name|var
operator|.
name|have_bind
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Apply SPROM offset adjustment */
if|if
condition|(
name|state
operator|->
name|var
operator|.
name|bind
operator|.
name|count
operator|>
literal|0
condition|)
block|{
name|skip
operator|=
name|state
operator|->
name|var
operator|.
name|bind
operator|.
name|skip_in
operator|*
name|state
operator|->
name|var
operator|.
name|bind
operator|.
name|count
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_apply_scale
argument_list|(
name|state
argument_list|,
operator|&
name|skip
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|state
operator|->
name|var
operator|.
name|bind
operator|.
name|skip_in_negative
condition|)
block|{
name|state
operator|->
name|offset
operator|-=
name|skip
expr_stmt|;
block|}
else|else
block|{
name|state
operator|->
name|offset
operator|+=
name|skip
expr_stmt|;
block|}
block|}
comment|/* Clear bind state */
name|memset
argument_list|(
operator|&
name|state
operator|->
name|var
operator|.
name|bind
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|var
operator|.
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|var
operator|.
name|have_bind
operator|=
name|false
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Set the current type to @p type, and reset type-specific  * stream state.  *  * @param state The opcode state to update.  * @param type The new type.  *   * @retval 0 success  * @retval EINVAL if @p vid is not a valid variable ID.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_sprom_opcode_set_type
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|bhnd_nvram_type
name|type
parameter_list|)
block|{
name|bhnd_nvram_type
name|base_type
decl_stmt|;
name|size_t
name|width
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
comment|/* Must have an open variable definition */
if|if
condition|(
name|state
operator|->
name|var_state
operator|!=
name|SPROM_OPCODE_VAR_STATE_OPEN
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"type set outside variable definition\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Fetch type width for use as our scale value */
name|width
operator|=
name|bhnd_nvram_type_width
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"unsupported variable-width type: %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|width
operator|>
name|UINT32_MAX
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"invalid type width %zu for type: %d\n"
argument_list|,
name|width
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Determine default mask value for the element type */
name|base_type
operator|=
name|bhnd_nvram_base_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_UINT8
case|:
case|case
name|BHND_NVRAM_TYPE_INT8
case|:
case|case
name|BHND_NVRAM_TYPE_CHAR
case|:
name|mask
operator|=
name|UINT8_MAX
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT16
case|:
case|case
name|BHND_NVRAM_TYPE_INT16
case|:
name|mask
operator|=
name|UINT16_MAX
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT32
case|:
case|case
name|BHND_NVRAM_TYPE_INT32
case|:
name|mask
operator|=
name|UINT32_MAX
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_STRING
case|:
comment|/* fallthrough (unused by SPROM) */
default|default:
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"unsupported type: %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Update state */
name|state
operator|->
name|var
operator|.
name|base_type
operator|=
name|base_type
expr_stmt|;
name|state
operator|->
name|var
operator|.
name|mask
operator|=
name|mask
expr_stmt|;
name|state
operator|->
name|var
operator|.
name|scale
operator|=
operator|(
name|uint32_t
operator|)
name|width
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Clear current variable state, if any.  *   * @param state The opcode state to update.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_sprom_opcode_clear_var
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|->
name|var_state
operator|==
name|SPROM_OPCODE_VAR_STATE_NONE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|BHND_NV_ASSERT
argument_list|(
name|state
operator|->
name|var_state
operator|==
name|SPROM_OPCODE_VAR_STATE_DONE
argument_list|,
operator|(
literal|"incomplete variable definition"
operator|)
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
operator|!
name|state
operator|->
name|var
operator|.
name|have_bind
argument_list|,
operator|(
literal|"stale bind state"
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|state
operator|->
name|var
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|var_state
operator|=
name|SPROM_OPCODE_VAR_STATE_NONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Set the current variable's array element count to @p nelem.  *  * @param state The opcode state to update.  * @param nelem The new array length.  *   * @retval 0 success  * @retval EINVAL if no open variable definition exists.  * @retval EINVAL if @p nelem is zero.  * @retval ENXIO if @p nelem is greater than one, and the current variable does  * not have an array type.  * @retval ENXIO if @p nelem exceeds the array length of the NVRAM variable  * definition.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_sprom_opcode_set_nelem
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint8_t
name|nelem
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
decl_stmt|;
comment|/* Must have a defined variable */
if|if
condition|(
name|state
operator|->
name|var_state
operator|!=
name|SPROM_OPCODE_VAR_STATE_OPEN
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"array length set without open variable "
literal|"state"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Locate the actual variable definition */
if|if
condition|(
operator|(
name|var
operator|=
name|bhnd_nvram_get_vardefn
argument_list|(
name|state
operator|->
name|vid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"unknown variable ID: %zu\n"
argument_list|,
name|state
operator|->
name|vid
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Must be greater than zero */
if|if
condition|(
name|nelem
operator|==
literal|0
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"invalid nelem: %hhu\n"
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* If the variable is not an array-typed value, the array length 	 * must be 1 */
if|if
condition|(
operator|!
name|bhnd_nvram_is_array_type
argument_list|(
name|var
operator|->
name|type
argument_list|)
operator|&&
name|nelem
operator|!=
literal|1
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"nelem %hhu on non-array %zu\n"
argument_list|,
name|nelem
argument_list|,
name|state
operator|->
name|vid
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Cannot exceed the variable's defined array length */
if|if
condition|(
name|nelem
operator|>
name|var
operator|->
name|nelem
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"nelem %hhu exceeds %zu length %hhu\n"
argument_list|,
name|nelem
argument_list|,
name|state
operator|->
name|vid
argument_list|,
name|var
operator|->
name|nelem
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Valid length; update state */
name|state
operator|->
name|var
operator|.
name|nelem
operator|=
name|nelem
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Set the current variable ID to @p vid, and reset variable-specific  * stream state.  *  * @param state The opcode state to update.  * @param vid The new variable ID.  *   * @retval 0 success  * @retval EINVAL if @p vid is not a valid variable ID.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_sprom_opcode_set_var
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|size_t
name|vid
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
decl_stmt|;
name|int
name|error
decl_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|state
operator|->
name|var_state
operator|==
name|SPROM_OPCODE_VAR_STATE_NONE
argument_list|,
operator|(
literal|"overwrite of open variable definition"
operator|)
argument_list|)
expr_stmt|;
comment|/* Locate the variable definition */
if|if
condition|(
operator|(
name|var
operator|=
name|bhnd_nvram_get_vardefn
argument_list|(
name|vid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"unknown variable ID: %zu\n"
argument_list|,
name|vid
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Update vid and var state */
name|state
operator|->
name|vid
operator|=
name|vid
expr_stmt|;
name|state
operator|->
name|var_state
operator|=
name|SPROM_OPCODE_VAR_STATE_OPEN
expr_stmt|;
comment|/* Initialize default variable record values */
name|memset
argument_list|(
operator|&
name|state
operator|->
name|var
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|var
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set initial base type */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_set_type
argument_list|(
name|state
argument_list|,
name|var
operator|->
name|type
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Set default array length */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_set_nelem
argument_list|(
name|state
argument_list|,
name|var
operator|->
name|nelem
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Mark the currently open variable definition as complete.  *   * @param state The opcode state to update.  *  * @retval 0 success  * @retval EINVAL if no incomplete open variable definition exists.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_sprom_opcode_end_var
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|->
name|var_state
operator|!=
name|SPROM_OPCODE_VAR_STATE_OPEN
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"no open variable definition\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|state
operator|->
name|var_state
operator|=
name|SPROM_OPCODE_VAR_STATE_DONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Apply the current scale to @p value.  *   * @param state The SPROM opcode state.  * @param[in,out] value The value to scale  *   * @retval 0 success  * @retval EINVAL if no open variable definition exists.  * @retval EINVAL if applying the current scale would overflow.  */
end_comment

begin_function
name|int
name|bhnd_sprom_opcode_apply_scale
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint32_t
modifier|*
name|value
parameter_list|)
block|{
comment|/* Must have a defined variable (and thus, scale) */
if|if
condition|(
name|state
operator|->
name|var_state
operator|!=
name|SPROM_OPCODE_VAR_STATE_OPEN
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"scaled value encoded without open "
literal|"variable state"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Applying the scale value must not overflow */
if|if
condition|(
name|UINT32_MAX
operator|/
name|state
operator|->
name|var
operator|.
name|scale
operator|<
operator|*
name|value
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"cannot represent %"
name|PRIu32
literal|" * %"
name|PRIu32
literal|"\n"
argument_list|,
operator|*
name|value
argument_list|,
name|state
operator|->
name|var
operator|.
name|scale
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|value
operator|=
operator|(
operator|*
name|value
operator|)
operator|*
name|state
operator|->
name|var
operator|.
name|scale
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read a SPROM_OP_DATA_* value from @p opcodes.  *   * @param state The SPROM opcode state.  * @param type The SROM_OP_DATA_* type to be read.  * @param opval On success, the 32bit data representation. If @p type is signed,  * the value will be appropriately sign extended and may be directly cast to  * int32_t.  *   * @retval 0 success  * @retval non-zero If reading the value otherwise fails, a regular unix error  * code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_sprom_opcode_read_opval32
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint8_t
name|type
parameter_list|,
name|uint32_t
modifier|*
name|opval
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|p
operator|=
name|state
operator|->
name|input
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SPROM_OP_DATA_I8
case|:
comment|/* Convert to signed value first, then sign extend */
operator|*
name|opval
operator|=
call|(
name|int32_t
call|)
argument_list|(
name|int8_t
argument_list|)
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|SPROM_OP_DATA_U8
case|:
operator|*
name|opval
operator|=
operator|*
name|p
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|SPROM_OP_DATA_U8_SCALED
case|:
operator|*
name|opval
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_apply_scale
argument_list|(
name|state
argument_list|,
name|opval
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|p
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|SPROM_OP_DATA_U16
case|:
operator|*
name|opval
operator|=
name|le16dec
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|SPROM_OP_DATA_U32
case|:
operator|*
name|opval
operator|=
name|le32dec
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
break|break;
default|default:
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"unsupported data type: %hhu\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Update read address */
name|state
operator|->
name|input
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if our layout revision is currently defined by the SPROM  * opcode state.  *   * This may be used to test whether the current opcode stream state applies  * to the layout that we are actually parsing.  *   * A given opcode stream may cover multiple layout revisions, switching  * between them prior to defining a set of variables.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|bhnd_sprom_opcode_matches_layout_rev
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|)
block|{
return|return
operator|(
name|bit_test
argument_list|(
name|state
operator|->
name|revs
argument_list|,
name|state
operator|->
name|layout
operator|->
name|rev
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * When evaluating @p state and @p opcode, rewrite @p opcode based on the  * current evaluation state.  *   * This allows the insertion of implicit opcodes into interpretation of the  * opcode stream.  *   * If @p opcode is rewritten, it should be returned from  * bhnd_sprom_opcode_step() instead of the opcode parsed from @p state's opcode  * stream.  *   * If @p opcode remains unmodified, then bhnd_sprom_opcode_step() should  * proceed to standard evaluation.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_sprom_opcode_rewrite_opcode
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint8_t
modifier|*
name|opcode
parameter_list|)
block|{
name|uint8_t
name|op
decl_stmt|;
name|int
name|error
decl_stmt|;
name|op
operator|=
name|SPROM_OPCODE_OP
argument_list|(
operator|*
name|opcode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
operator|->
name|var_state
condition|)
block|{
case|case
name|SPROM_OPCODE_VAR_STATE_NONE
case|:
comment|/* No open variable definition */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SPROM_OPCODE_VAR_STATE_OPEN
case|:
comment|/* Open variable definition; check for implicit closure. */
comment|/* 		 * If a variable definition contains no explicit bind 		 * instructions prior to closure, we must generate a DO_BIND 		 * instruction with count and skip values of 1. 		 */
if|if
condition|(
name|SPROM_OP_IS_VAR_END
argument_list|(
name|op
argument_list|)
operator|&&
name|state
operator|->
name|var
operator|.
name|bind_total
operator|==
literal|0
condition|)
block|{
name|uint8_t
name|count
decl_stmt|,
name|skip_in
decl_stmt|,
name|skip_out
decl_stmt|;
name|bool
name|skip_in_negative
decl_stmt|;
comment|/* Create bind with skip_in/skip_out of 1, count of 1 */
name|count
operator|=
literal|1
expr_stmt|;
name|skip_in
operator|=
literal|1
expr_stmt|;
name|skip_out
operator|=
literal|1
expr_stmt|;
name|skip_in_negative
operator|=
name|false
expr_stmt|;
name|error
operator|=
name|bhnd_sprom_opcode_set_bind
argument_list|(
name|state
argument_list|,
name|count
argument_list|,
name|skip_in
argument_list|,
name|skip_in_negative
argument_list|,
name|skip_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Return DO_BIND */
operator|*
name|opcode
operator|=
name|SPROM_OPCODE_DO_BIND
operator||
operator|(
literal|0
operator|<<
name|SPROM_OP_BIND_SKIP_IN_SIGN
operator|)
operator||
operator|(
literal|1
operator|<<
name|SPROM_OP_BIND_SKIP_IN_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|SPROM_OP_BIND_SKIP_OUT_SHIFT
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * If a variable is implicitly closed (e.g. by a new variable 		 * definition), we must generate a VAR_END instruction. 		 */
if|if
condition|(
name|SPROM_OP_IS_IMPLICIT_VAR_END
argument_list|(
name|op
argument_list|)
condition|)
block|{
comment|/* Mark as complete */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_end_var
argument_list|(
name|state
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Return VAR_END */
operator|*
name|opcode
operator|=
name|SPROM_OPCODE_VAR_END
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|SPROM_OPCODE_VAR_STATE_DONE
case|:
comment|/* Previously completed variable definition. Discard variable 		 * state */
return|return
operator|(
name|bhnd_sprom_opcode_clear_var
argument_list|(
name|state
argument_list|)
operator|)
return|;
block|}
comment|/* Nothing to do */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Evaluate one opcode from @p state.  *  * @param state The opcode state to be evaluated.  * @param[out] opcode On success, the evaluated opcode  *   * @retval 0 success  * @retval ENOENT if EOF is reached  * @retval non-zero if evaluation otherwise fails, a regular unix error  * code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_sprom_opcode_step
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint8_t
modifier|*
name|opcode
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
while|while
condition|(
operator|*
name|state
operator|->
name|input
operator|!=
name|SPROM_OPCODE_EOF
condition|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|uint8_t
name|op
decl_stmt|,
name|rewrite
decl_stmt|,
name|immd
decl_stmt|;
comment|/* Fetch opcode */
operator|*
name|opcode
operator|=
operator|*
name|state
operator|->
name|input
expr_stmt|;
name|op
operator|=
name|SPROM_OPCODE_OP
argument_list|(
operator|*
name|opcode
argument_list|)
expr_stmt|;
name|immd
operator|=
name|SPROM_OPCODE_IMM
argument_list|(
operator|*
name|opcode
argument_list|)
expr_stmt|;
comment|/* Clear any existing bind state */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_flush_bind
argument_list|(
name|state
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Insert local opcode based on current state? */
name|rewrite
operator|=
operator|*
name|opcode
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_rewrite_opcode
argument_list|(
name|state
argument_list|,
operator|&
name|rewrite
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|rewrite
operator|!=
operator|*
name|opcode
condition|)
block|{
comment|/* Provide rewritten opcode */
operator|*
name|opcode
operator|=
name|rewrite
expr_stmt|;
comment|/* We must keep evaluating until we hit a state 			 * applicable to the SPROM revision we're parsing */
if|if
condition|(
operator|!
name|bhnd_sprom_opcode_matches_layout_rev
argument_list|(
name|state
argument_list|)
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Advance input */
name|state
operator|->
name|input
operator|++
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SPROM_OPCODE_VAR_IMM
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_set_var
argument_list|(
name|state
argument_list|,
name|immd
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|SPROM_OPCODE_VAR_REL_IMM
case|:
name|error
operator|=
name|bhnd_sprom_opcode_set_var
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|vid
operator|+
name|immd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|SPROM_OPCODE_VAR
case|:
name|error
operator|=
name|bhnd_sprom_opcode_read_opval32
argument_list|(
name|state
argument_list|,
name|immd
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_set_var
argument_list|(
name|state
argument_list|,
name|val
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|SPROM_OPCODE_VAR_END
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_end_var
argument_list|(
name|state
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|SPROM_OPCODE_NELEM
case|:
name|immd
operator|=
operator|*
name|state
operator|->
name|input
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_set_nelem
argument_list|(
name|state
argument_list|,
name|immd
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|state
operator|->
name|input
operator|++
expr_stmt|;
break|break;
case|case
name|SPROM_OPCODE_DO_BIND
case|:
case|case
name|SPROM_OPCODE_DO_BINDN
case|:
block|{
name|uint8_t
name|count
decl_stmt|,
name|skip_in
decl_stmt|,
name|skip_out
decl_stmt|;
name|bool
name|skip_in_negative
decl_stmt|;
comment|/* Fetch skip arguments */
name|skip_in
operator|=
operator|(
name|immd
operator|&
name|SPROM_OP_BIND_SKIP_IN_MASK
operator|)
operator|>>
name|SPROM_OP_BIND_SKIP_IN_SHIFT
expr_stmt|;
name|skip_in_negative
operator|=
operator|(
operator|(
name|immd
operator|&
name|SPROM_OP_BIND_SKIP_IN_SIGN
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|skip_out
operator|=
operator|(
name|immd
operator|&
name|SPROM_OP_BIND_SKIP_OUT_MASK
operator|)
operator|>>
name|SPROM_OP_BIND_SKIP_OUT_SHIFT
expr_stmt|;
comment|/* Fetch count argument (if any) */
if|if
condition|(
name|op
operator|==
name|SPROM_OPCODE_DO_BINDN
condition|)
block|{
comment|/* Count is provided as trailing U8 */
name|count
operator|=
operator|*
name|state
operator|->
name|input
expr_stmt|;
name|state
operator|->
name|input
operator|++
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Set BIND state */
name|error
operator|=
name|bhnd_sprom_opcode_set_bind
argument_list|(
name|state
argument_list|,
name|count
argument_list|,
name|skip_in
argument_list|,
name|skip_in_negative
argument_list|,
name|skip_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
block|}
case|case
name|SPROM_OPCODE_DO_BINDN_IMM
case|:
block|{
name|uint8_t
name|count
decl_stmt|,
name|skip_in
decl_stmt|,
name|skip_out
decl_stmt|;
name|bool
name|skip_in_negative
decl_stmt|;
comment|/* Implicit skip_in/skip_out of 1, count encoded as immd 			 * value */
name|count
operator|=
name|immd
expr_stmt|;
name|skip_in
operator|=
literal|1
expr_stmt|;
name|skip_out
operator|=
literal|1
expr_stmt|;
name|skip_in_negative
operator|=
name|false
expr_stmt|;
name|error
operator|=
name|bhnd_sprom_opcode_set_bind
argument_list|(
name|state
argument_list|,
name|count
argument_list|,
name|skip_in
argument_list|,
name|skip_in_negative
argument_list|,
name|skip_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
block|}
case|case
name|SPROM_OPCODE_REV_IMM
case|:
name|error
operator|=
name|bhnd_sprom_opcode_set_revs
argument_list|(
name|state
argument_list|,
name|immd
argument_list|,
name|immd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|SPROM_OPCODE_REV_RANGE
case|:
block|{
name|uint8_t
name|range
decl_stmt|;
name|uint8_t
name|rstart
decl_stmt|,
name|rend
decl_stmt|;
comment|/* Revision range is encoded in next byte, as 			 * { uint8_t start:4, uint8_t end:4 } */
name|range
operator|=
operator|*
name|state
operator|->
name|input
expr_stmt|;
name|rstart
operator|=
operator|(
name|range
operator|&
name|SPROM_OP_REV_START_MASK
operator|)
operator|>>
name|SPROM_OP_REV_START_SHIFT
expr_stmt|;
name|rend
operator|=
operator|(
name|range
operator|&
name|SPROM_OP_REV_END_MASK
operator|)
operator|>>
name|SPROM_OP_REV_END_SHIFT
expr_stmt|;
comment|/* Update revision bitmask */
name|error
operator|=
name|bhnd_sprom_opcode_set_revs
argument_list|(
name|state
argument_list|,
name|rstart
argument_list|,
name|rend
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Advance input */
name|state
operator|->
name|input
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|SPROM_OPCODE_MASK_IMM
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_set_mask
argument_list|(
name|state
argument_list|,
name|immd
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|SPROM_OPCODE_MASK
case|:
name|error
operator|=
name|bhnd_sprom_opcode_read_opval32
argument_list|(
name|state
argument_list|,
name|immd
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_set_mask
argument_list|(
name|state
argument_list|,
name|val
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|SPROM_OPCODE_SHIFT_IMM
case|:
name|error
operator|=
name|bhnd_sprom_opcode_set_shift
argument_list|(
name|state
argument_list|,
name|immd
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|SPROM_OPCODE_SHIFT
case|:
block|{
name|int8_t
name|shift
decl_stmt|;
if|if
condition|(
name|immd
operator|==
name|SPROM_OP_DATA_I8
condition|)
block|{
name|shift
operator|=
call|(
name|int8_t
call|)
argument_list|(
operator|*
name|state
operator|->
name|input
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|immd
operator|==
name|SPROM_OP_DATA_U8
condition|)
block|{
name|val
operator|=
operator|*
name|state
operator|->
name|input
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|INT8_MAX
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"invalid shift "
literal|"value: %#x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|shift
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"unsupported shift data "
literal|"type: %#hhx\n"
argument_list|,
name|immd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_set_shift
argument_list|(
name|state
argument_list|,
name|shift
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|state
operator|->
name|input
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|SPROM_OPCODE_OFFSET_REL_IMM
case|:
comment|/* Fetch unscaled relative offset */
name|val
operator|=
name|immd
expr_stmt|;
comment|/* Apply scale */
name|error
operator|=
name|bhnd_sprom_opcode_apply_scale
argument_list|(
name|state
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Adding val must not overflow our offset */
if|if
condition|(
name|UINT32_MAX
operator|-
name|state
operator|->
name|offset
operator|<
name|val
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"offset out of range\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Adjust offset */
name|state
operator|->
name|offset
operator|+=
name|val
expr_stmt|;
break|break;
case|case
name|SPROM_OPCODE_OFFSET
case|:
name|error
operator|=
name|bhnd_sprom_opcode_read_opval32
argument_list|(
name|state
argument_list|,
name|immd
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|state
operator|->
name|offset
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|SPROM_OPCODE_TYPE
case|:
comment|/* Type follows as U8 */
name|immd
operator|=
operator|*
name|state
operator|->
name|input
expr_stmt|;
name|state
operator|->
name|input
operator|++
expr_stmt|;
comment|/* fall through */
case|case
name|SPROM_OPCODE_TYPE_IMM
case|:
switch|switch
condition|(
name|immd
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_UINT8
case|:
case|case
name|BHND_NVRAM_TYPE_UINT16
case|:
case|case
name|BHND_NVRAM_TYPE_UINT32
case|:
case|case
name|BHND_NVRAM_TYPE_UINT64
case|:
case|case
name|BHND_NVRAM_TYPE_INT8
case|:
case|case
name|BHND_NVRAM_TYPE_INT16
case|:
case|case
name|BHND_NVRAM_TYPE_INT32
case|:
case|case
name|BHND_NVRAM_TYPE_INT64
case|:
case|case
name|BHND_NVRAM_TYPE_CHAR
case|:
case|case
name|BHND_NVRAM_TYPE_STRING
case|:
name|error
operator|=
name|bhnd_sprom_opcode_set_type
argument_list|(
name|state
argument_list|,
operator|(
name|bhnd_nvram_type
operator|)
name|immd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
default|default:
name|BHND_NV_LOG
argument_list|(
literal|"unrecognized type %#hhx\n"
argument_list|,
name|immd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
default|default:
name|BHND_NV_LOG
argument_list|(
literal|"unrecognized opcode %#hhx\n"
argument_list|,
operator|*
name|opcode
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* We must keep evaluating until we hit a state applicable to 		 * the SPROM revision we're parsing */
if|if
condition|(
name|bhnd_sprom_opcode_matches_layout_rev
argument_list|(
name|state
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* End of opcode stream */
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Reset SPROM opcode evaluation state, seek to the @p entry's position,  * and perform complete evaluation of the variable's opcodes.  *   * @param state The opcode state to be to be evaluated.  * @param entry The indexed variable location.  *  * @retval 0 success  * @retval non-zero If evaluation fails, a regular unix error code will be  * returned.  */
end_comment

begin_function
name|int
name|bhnd_sprom_opcode_parse_var
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|bhnd_sprom_opcode_idx_entry
modifier|*
name|entry
parameter_list|)
block|{
name|uint8_t
name|opcode
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Seek to entry */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_seek
argument_list|(
name|state
argument_list|,
name|entry
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Parse full variable definition */
while|while
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_step
argument_list|(
name|state
argument_list|,
operator|&
name|opcode
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Iterate until VAR_END */
if|if
condition|(
name|SPROM_OPCODE_OP
argument_list|(
name|opcode
argument_list|)
operator|!=
name|SPROM_OPCODE_VAR_END
condition|)
continue|continue;
name|BHND_NV_ASSERT
argument_list|(
name|state
operator|->
name|var_state
operator|==
name|SPROM_OPCODE_VAR_STATE_DONE
argument_list|,
operator|(
literal|"incomplete variable definition"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Error parsing definition */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Evaluate @p state until the next variable definition is found.  *   * @param state The opcode state to be evaluated.  *   * @retval 0 success  * @retval ENOENT if no additional variable definitions are available.  * @retval non-zero if evaluation otherwise fails, a regular unix error  * code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_sprom_opcode_next_var
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|)
block|{
name|uint8_t
name|opcode
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Step until we hit a variable opcode */
while|while
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_step
argument_list|(
name|state
argument_list|,
operator|&
name|opcode
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|SPROM_OPCODE_OP
argument_list|(
name|opcode
argument_list|)
condition|)
block|{
case|case
name|SPROM_OPCODE_VAR
case|:
case|case
name|SPROM_OPCODE_VAR_IMM
case|:
case|case
name|SPROM_OPCODE_VAR_REL_IMM
case|:
name|BHND_NV_ASSERT
argument_list|(
name|state
operator|->
name|var_state
operator|==
name|SPROM_OPCODE_VAR_STATE_OPEN
argument_list|,
operator|(
literal|"missing variable definition"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
continue|continue;
block|}
block|}
comment|/* Reached EOF, or evaluation failed */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Evaluate @p state until the next binding for the current variable definition  * is found.  *   * @param state The opcode state to be evaluated.  *   * @retval 0 success  * @retval ENOENT if no additional binding opcodes are found prior to reaching  * a new variable definition, or the end of @p state's binding opcodes.  * @retval non-zero if evaluation otherwise fails, a regular unix error  * code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_sprom_opcode_next_binding
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|)
block|{
name|uint8_t
name|opcode
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|var_state
operator|!=
name|SPROM_OPCODE_VAR_STATE_OPEN
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Step until we hit a bind opcode, or a new variable */
while|while
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_step
argument_list|(
name|state
argument_list|,
operator|&
name|opcode
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|SPROM_OPCODE_OP
argument_list|(
name|opcode
argument_list|)
condition|)
block|{
case|case
name|SPROM_OPCODE_DO_BIND
case|:
case|case
name|SPROM_OPCODE_DO_BINDN
case|:
case|case
name|SPROM_OPCODE_DO_BINDN_IMM
case|:
comment|/* Found next bind */
name|BHND_NV_ASSERT
argument_list|(
name|state
operator|->
name|var_state
operator|==
name|SPROM_OPCODE_VAR_STATE_OPEN
argument_list|,
operator|(
literal|"missing variable definition"
operator|)
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|state
operator|->
name|var
operator|.
name|have_bind
argument_list|,
operator|(
literal|"missing bind"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SPROM_OPCODE_VAR_END
case|:
comment|/* No further binding opcodes */
name|BHND_NV_ASSERT
argument_list|(
name|state
operator|->
name|var_state
operator|==
name|SPROM_OPCODE_VAR_STATE_DONE
argument_list|,
operator|(
literal|"variable definition still available"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
comment|/* Not found, or evaluation failed */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

