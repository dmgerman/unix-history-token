begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Landon Fuller<landonf@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_KERNEL */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_include
include|#
directive|include
file|"bhnd_nvram_private.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_datavar.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_storevar.h"
end_include

begin_comment
comment|/*  * BHND NVRAM Store  *  * Manages in-memory and persistent representations of NVRAM data.  */
end_comment

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_sort_idx
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_generate_index
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|bhnd_nvram_index_lookup
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Allocate and initialize a new NVRAM data store instance.  *  * The caller is responsible for deallocating the instance via  * bhnd_nvram_store_free().  *   * @param[out] store On success, a pointer to the newly allocated NVRAM data  * instance.  * @param data The NVRAM data to be managed by the returned NVRAM data store  * instance.  *  * @retval 0 success  * @retval non-zero if an error occurs during allocation or initialization, a  * regular unix error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_nvram_store_new
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
modifier|*
name|store
parameter_list|,
name|struct
name|bhnd_nvram_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allocate new instance */
name|sc
operator|=
name|bhnd_nv_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|paths
argument_list|)
expr_stmt|;
comment|/* Retain the NVRAM data */
name|sc
operator|->
name|nv
operator|=
name|bhnd_nvram_data_retain
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* Allocate uncommitted change list */
name|sc
operator|->
name|pending
operator|=
name|nvlist_create
argument_list|(
name|NV_FLAG_IGNORE_CASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pending
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Generate all indices */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_generate_index
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
name|BHND_NVSTORE_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|*
name|store
operator|=
name|sc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|cleanup
label|:
name|bhnd_nvram_store_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Allocate and initialize a new NVRAM data store instance, parsing the  * NVRAM data from @p io.  *  * The caller is responsible for deallocating the instance via  * bhnd_nvram_store_free().  *   * The NVRAM data mapped by @p io will be copied, and @p io may be safely  * deallocated after bhnd_nvram_store_new() returns.  *   * @param[out] store On success, a pointer to the newly allocated NVRAM data  * instance.  * @param io An I/O context mapping the NVRAM data to be copied and parsed.  * @param cls The NVRAM data class to be used when parsing @p io, or NULL  * to perform runtime identification of the appropriate data class.  *  * @retval 0 success  * @retval non-zero if an error occurs during allocation or initialization, a  * regular unix error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_nvram_store_parse_new
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
modifier|*
name|store
parameter_list|,
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|,
name|bhnd_nvram_data_class
modifier|*
name|cls
parameter_list|)
block|{
name|struct
name|bhnd_nvram_data
modifier|*
name|data
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Try to parse the data */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_data_new
argument_list|(
name|cls
argument_list|,
operator|&
name|data
argument_list|,
name|io
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Try to create our new store instance */
name|error
operator|=
name|bhnd_nvram_store_new
argument_list|(
name|store
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|bhnd_nvram_data_release
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Free an NVRAM store instance, releasing all associated resources.  *   * @param sc A store instance previously allocated via  * bhnd_nvram_store_new().  */
end_comment

begin_function
name|void
name|bhnd_nvram_store_free
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bhnd_nvstore_path
modifier|*
name|dpath
decl_stmt|,
modifier|*
name|dnext
decl_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|dpath
argument_list|,
argument|&sc->paths
argument_list|,
argument|dp_link
argument_list|,
argument|dnext
argument_list|)
block|{
name|bhnd_nv_free
argument_list|(
name|dpath
operator|->
name|path
argument_list|)
expr_stmt|;
name|bhnd_nv_free
argument_list|(
name|dpath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|pending
operator|!=
name|NULL
condition|)
name|nvlist_destroy
argument_list|(
name|sc
operator|->
name|pending
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|idx
operator|!=
name|NULL
condition|)
name|bhnd_nv_free
argument_list|(
name|sc
operator|->
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nv
operator|!=
name|NULL
condition|)
name|bhnd_nvram_data_release
argument_list|(
name|sc
operator|->
name|nv
argument_list|)
expr_stmt|;
name|BHND_NVSTORE_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bhnd_nv_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Read an NVRAM variable.  *  * @param              sc      The NVRAM parser state.  * @param              name    The NVRAM variable name.  * @param[out]         buf     On success, the requested value will be written  *                             to this buffer. This argment may be NULL if  *                             the value is not desired.  * @param[in,out]      len     The capacity of @p buf. On success, will be set  *                             to the actual size of the requested value.  * @param              type    The requested data type to be written to @p buf.  *  * @retval 0           success  * @retval ENOENT      The requested variable was not found.  * @retval ENOMEM      If @p buf is non-NULL and a buffer of @p len is too  *                     small to hold the requested value.  * @retval non-zero    If reading @p name otherwise fails, a regular unix  *                     error code will be returned.   */
end_comment

begin_function
name|int
name|bhnd_nvram_store_getvar
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|bhnd_nvram_type
name|type
parameter_list|)
block|{
name|void
modifier|*
name|cookiep
decl_stmt|;
specifier|const
name|void
modifier|*
name|inp
decl_stmt|;
name|size_t
name|ilen
decl_stmt|;
name|bhnd_nvram_type
name|itype
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Search order: 	 * 	 * - uncommitted changes 	 * - index lookup OR buffer scan 	 */
name|BHND_NVSTORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Is variable marked for deletion? */
if|if
condition|(
name|nvlist_exists_null
argument_list|(
name|sc
operator|->
name|pending
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|BHND_NVSTORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* Does an uncommitted value exist? */
if|if
condition|(
name|nvlist_exists_string
argument_list|(
name|sc
operator|->
name|pending
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|/* Uncommited value exists, is not a deletion */
name|inp
operator|=
name|nvlist_get_string
argument_list|(
name|sc
operator|->
name|pending
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ilen
operator|=
name|strlen
argument_list|(
name|inp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|itype
operator|=
name|BHND_NVRAM_TYPE_STRING
expr_stmt|;
comment|/* Coerce borrowed data reference before releasing 		 * our lock. */
name|error
operator|=
name|bhnd_nvram_value_coerce
argument_list|(
name|inp
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|BHND_NVSTORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|nvlist_exists
argument_list|(
name|sc
operator|->
name|pending
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|BHND_NV_PANIC
argument_list|(
literal|"invalid value type for pending change %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Fetch variable from parsed NVRAM data. */
if|if
condition|(
operator|(
name|cookiep
operator|=
name|bhnd_nvram_index_lookup
argument_list|(
name|sc
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|BHND_NVSTORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* Let the parser itself perform value coercion */
name|error
operator|=
name|bhnd_nvram_data_getvar
argument_list|(
name|sc
operator|->
name|nv
argument_list|,
name|cookiep
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|BHND_NVSTORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Set an NVRAM variable.  *   * @param		sc	The NVRAM parser state.  * @param		name	The NVRAM variable name.  * @param[out]		buf	The new value.  * @param[in,out]	len	The size of @p buf.  * @param		type	The data type of @p buf.  *  * @retval 0		success  * @retval ENOENT	The requested variable was not found.  * @retval EINVAL	If @p len does not match the expected variable size.  */
end_comment

begin_function
name|int
name|bhnd_nvram_store_setvar
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|bhnd_nvram_type
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|inp
decl_stmt|;
name|char
name|vbuf
index|[
literal|512
index|]
decl_stmt|;
comment|/* Verify name validity */
if|if
condition|(
operator|!
name|bhnd_nvram_validate_name
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Verify buffer size alignment for the given type. If this is a 	 * variable width type, a width of 0 will always pass this check */
if|if
condition|(
name|len
operator|%
name|bhnd_nvram_value_size
argument_list|(
name|type
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Determine string format (or directly add variable, if a C string) */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_UINT8
case|:
case|case
name|BHND_NVRAM_TYPE_UINT16
case|:
case|case
name|BHND_NVRAM_TYPE_UINT32
case|:
case|case
name|BHND_NVRAM_TYPE_UINT64
case|:
case|case
name|BHND_NVRAM_TYPE_INT8
case|:
case|case
name|BHND_NVRAM_TYPE_INT16
case|:
case|case
name|BHND_NVRAM_TYPE_INT32
case|:
case|case
name|BHND_NVRAM_TYPE_INT64
case|:
case|case
name|BHND_NVRAM_TYPE_UINT8_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_UINT16_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_UINT32_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_UINT64_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_INT8_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_INT16_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_INT32_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_INT64_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_CHAR_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_STRING_ARRAY
case|:
comment|// TODO: non-char/string value support
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
case|case
name|BHND_NVRAM_TYPE_CHAR
case|:
case|case
name|BHND_NVRAM_TYPE_STRING
case|:
name|inp
operator|=
name|buf
expr_stmt|;
comment|/* Must not exceed buffer size */
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|vbuf
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Must have room for a trailing NUL */
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|vbuf
argument_list|)
operator|&&
name|inp
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Copy out the string value and append trailing NUL */
name|strlcpy
argument_list|(
name|vbuf
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Add to pending change list */
name|BHND_NVSTORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|nvlist_add_string
argument_list|(
name|sc
operator|->
name|pending
argument_list|,
name|name
argument_list|,
name|vbuf
argument_list|)
expr_stmt|;
name|BHND_NVSTORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* sort function for bhnd_nvstore_index cookie values */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_sort_idx
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
decl_stmt|;
specifier|const
name|char
modifier|*
name|l_str
decl_stmt|,
modifier|*
name|r_str
decl_stmt|;
name|sc
operator|=
name|ctx
expr_stmt|;
comment|/* Fetch string pointers from the cookiep values */
name|l_str
operator|=
name|bhnd_nvram_data_getvar_name
argument_list|(
name|sc
operator|->
name|nv
argument_list|,
operator|*
operator|(
name|void
operator|*
specifier|const
operator|*
operator|)
name|lhs
argument_list|)
expr_stmt|;
name|r_str
operator|=
name|bhnd_nvram_data_getvar_name
argument_list|(
name|sc
operator|->
name|nv
argument_list|,
operator|*
operator|(
name|void
operator|*
specifier|const
operator|*
operator|)
name|rhs
argument_list|)
expr_stmt|;
comment|/* Perform comparison */
return|return
operator|(
name|strcasecmp
argument_list|(
name|l_str
argument_list|,
name|r_str
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Parse and register all device paths and path aliases in @p nvram.  *   * @param sc		The NVRAM parser state.  *  * @retval 0		success  * @retval non-zero	If registering device paths fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_register_devpaths
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|void
modifier|*
name|cookiep
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Skip if backing parser does not support device paths */
if|if
condition|(
operator|!
operator|(
name|bhnd_nvram_data_caps
argument_list|(
name|sc
operator|->
name|nv
argument_list|)
operator|&
name|BHND_NVRAM_DATA_CAP_DEVPATHS
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Parse and register all device path aliases */
name|cookiep
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|name
operator|=
name|bhnd_nvram_data_next
argument_list|(
name|sc
operator|->
name|nv
argument_list|,
operator|&
name|cookiep
argument_list|)
operator|)
condition|)
block|{
name|struct
name|bhnd_nvstore_path
modifier|*
name|devpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
name|char
modifier|*
name|eptr
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|size_t
name|path_len
decl_stmt|;
name|u_long
name|index
decl_stmt|;
name|path
operator|=
name|NULL
expr_stmt|;
comment|/* Check for devpath prefix */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"devpath"
argument_list|,
name|strlen
argument_list|(
literal|"devpath"
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Parse index value that should follow a 'devpath' prefix */
name|suffix
operator|=
name|name
operator|+
name|strlen
argument_list|(
literal|"devpath"
argument_list|)
expr_stmt|;
name|index
operator|=
name|strtoul
argument_list|(
name|suffix
argument_list|,
operator|&
name|eptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|==
name|suffix
operator|||
operator|*
name|eptr
operator|!=
literal|'\0'
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"invalid devpath variable '%s'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Determine path value length */
name|error
operator|=
name|bhnd_nvram_data_getvar
argument_list|(
name|sc
operator|->
name|nv
argument_list|,
name|cookiep
argument_list|,
name|NULL
argument_list|,
operator|&
name|path_len
argument_list|,
name|BHND_NVRAM_TYPE_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Allocate path buffer */
if|if
condition|(
operator|(
name|path
operator|=
name|bhnd_nv_malloc
argument_list|(
name|path_len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Decode to our new buffer */
name|error
operator|=
name|bhnd_nvram_data_getvar
argument_list|(
name|sc
operator|->
name|nv
argument_list|,
name|cookiep
argument_list|,
name|path
argument_list|,
operator|&
name|path_len
argument_list|,
name|BHND_NVRAM_TYPE_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|bhnd_nv_free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Register path alias */
name|devpath
operator|=
name|bhnd_nv_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|devpath
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|devpath
operator|==
name|NULL
condition|)
block|{
name|bhnd_nv_free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|devpath
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|devpath
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|paths
argument_list|,
name|devpath
argument_list|,
name|dp_link
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Generate all indices for the NVRAM data backing @p nvram.  *   * @param sc		The NVRAM parser state.  *  * @retval 0		success  * @retval non-zero	If indexing @p nvram fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_generate_index
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|void
modifier|*
name|cookiep
decl_stmt|;
name|size_t
name|idx_bytes
decl_stmt|;
name|size_t
name|num_vars
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Parse and register all device path aliases */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_register_devpaths
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Skip generating a variable index if threshold is not met ... */
name|num_vars
operator|=
name|bhnd_nvram_data_count
argument_list|(
name|sc
operator|->
name|nv
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_vars
operator|<
name|NVRAM_IDX_VAR_THRESH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ... or if the backing data instance implements indexed lookup 	 * internally */
if|if
condition|(
name|bhnd_nvram_data_caps
argument_list|(
name|sc
operator|->
name|nv
argument_list|)
operator|&
name|BHND_NVRAM_DATA_CAP_INDEXED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Allocate and populate variable index */
name|idx_bytes
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|bhnd_nvstore_index
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|num_vars
operator|)
expr_stmt|;
name|sc
operator|->
name|idx
operator|=
name|bhnd_nv_malloc
argument_list|(
name|idx_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|idx
operator|==
name|NULL
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error allocating %zu byte index\n"
argument_list|,
name|idx_bytes
argument_list|)
expr_stmt|;
goto|goto
name|bad_index
goto|;
block|}
name|sc
operator|->
name|idx
operator|->
name|num_cookiep
operator|=
name|num_vars
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
if|if
condition|(
name|bootverbose
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"allocated %zu byte index for %zu variables\n"
argument_list|,
name|idx_bytes
argument_list|,
name|num_vars
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _KERNEL */
name|cookiep
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|idx
operator|->
name|num_cookiep
condition|;
name|i
operator|++
control|)
block|{
comment|/* Fetch next entry */
name|name
operator|=
name|bhnd_nvram_data_next
argument_list|(
name|sc
operator|->
name|nv
argument_list|,
operator|&
name|cookiep
argument_list|)
expr_stmt|;
comment|/* Early EOF */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"indexing failed, expected %zu records "
literal|"(got %zu)\n"
argument_list|,
name|sc
operator|->
name|idx
operator|->
name|num_cookiep
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|bad_index
goto|;
block|}
comment|/* Save the variable's cookiep */
name|sc
operator|->
name|idx
operator|->
name|cookiep
index|[
name|i
index|]
operator|=
name|cookiep
expr_stmt|;
block|}
comment|/* Sort the index table */
name|qsort_r
argument_list|(
name|sc
operator|->
name|idx
operator|->
name|cookiep
argument_list|,
name|sc
operator|->
name|idx
operator|->
name|num_cookiep
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|idx
operator|->
name|cookiep
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|sc
argument_list|,
name|bhnd_nvram_sort_idx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad_index
label|:
comment|/* Fall back on non-indexed access */
name|BHND_NV_LOG
argument_list|(
literal|"reverting to non-indexed variable lookup\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|idx
operator|!=
name|NULL
condition|)
block|{
name|bhnd_nv_free
argument_list|(
name|sc
operator|->
name|idx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|idx
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Perform an index lookup of @p name, returning the associated cookie  * value, or NULL if the variable does not exist.  *  * @param	sc		The NVRAM parser state.  * @param	name		The variable to search for.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|bhnd_nvram_index_lookup
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|void
modifier|*
name|cookiep
decl_stmt|;
specifier|const
name|char
modifier|*
name|indexed_name
decl_stmt|;
name|size_t
name|min
decl_stmt|,
name|mid
decl_stmt|,
name|max
decl_stmt|;
name|int
name|order
decl_stmt|;
name|BHND_NVSTORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|idx
operator|==
name|NULL
operator|||
name|sc
operator|->
name|idx
operator|->
name|num_cookiep
operator|==
literal|0
condition|)
return|return
operator|(
name|bhnd_nvram_data_find
argument_list|(
name|sc
operator|->
name|nv
argument_list|,
name|name
argument_list|)
operator|)
return|;
comment|/* 	 * Locate the requested variable using a binary search. 	 */
name|BHND_NV_ASSERT
argument_list|(
name|sc
operator|->
name|idx
operator|->
name|num_cookiep
operator|>
literal|0
argument_list|,
operator|(
literal|"empty array causes underflow"
operator|)
argument_list|)
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|sc
operator|->
name|idx
operator|->
name|num_cookiep
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|max
operator|>=
name|min
condition|)
block|{
comment|/* Select midpoint */
name|mid
operator|=
operator|(
name|min
operator|+
name|max
operator|)
operator|/
literal|2
expr_stmt|;
name|cookiep
operator|=
name|sc
operator|->
name|idx
operator|->
name|cookiep
index|[
name|mid
index|]
expr_stmt|;
comment|/* Determine which side of the partition to search */
name|indexed_name
operator|=
name|bhnd_nvram_data_getvar_name
argument_list|(
name|sc
operator|->
name|nv
argument_list|,
name|cookiep
argument_list|)
expr_stmt|;
name|order
operator|=
name|strcasecmp
argument_list|(
name|indexed_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|<
literal|0
condition|)
block|{
comment|/* Search upper partition */
name|min
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|order
operator|>
literal|0
condition|)
block|{
comment|/* Search (non-empty) lower partition */
if|if
condition|(
name|mid
operator|==
literal|0
condition|)
break|break;
name|max
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|order
operator|==
literal|0
condition|)
block|{
comment|/* Match found */
return|return
operator|(
name|cookiep
operator|)
return|;
block|}
block|}
comment|/* Not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

end_unit

