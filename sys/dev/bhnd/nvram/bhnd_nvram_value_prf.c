begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Landon Fuller<landonf@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/_inttypes.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_KERNEL */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_include
include|#
directive|include
file|"bhnd_nvram_private.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_valuevar.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_define
define|#
directive|define
name|bhnd_nv_hex2ascii
parameter_list|(
name|hex
parameter_list|)
value|hex2ascii(hex)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_KERNEL */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
name|bhnd_nv_hex2ascii
index|[]
init|=
literal|"0123456789abcdefghijklmnopqrstuvwxyz"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|bhnd_nv_hex2ascii
parameter_list|(
name|hex
parameter_list|)
value|(bhnd_nv_hex2ascii[hex])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_comment
comment|/**  * Maximum size, in bytes, of a string-encoded NVRAM integer value, not  * including any prefix (0x, 0, etc).  *   * We assume the largest possible encoding is the base-2 representation  * of a 64-bit integer.  */
end_comment

begin_define
define|#
directive|define
name|NV_NUMSTR_MAX
value|((sizeof(uint64_t) * CHAR_BIT) + 1)
end_define

begin_comment
comment|/**  * Format a string representation of @p value using @p fmt, with, writing the  * result to @p outp.  *  * @param		value	The value to be formatted.  * @param		fmt	The format string.  * @param[out]		outp	On success, the string will be written to this   *				buffer. This argment may be NULL if the value is  *				not desired.  * @param[in,out]	olen	The capacity of @p outp. On success, will be set  *				to the actual number of bytes required for the  *				requested string encoding (including a trailing  *				NUL).  *   * Refer to bhnd_nvram_val_vprintf() for full format string documentation.  *  * @retval 0		success  * @retval EINVAL	If @p fmt contains unrecognized format string  *			specifiers.  * @retval ENOMEM	If the @p outp is non-NULL, and the provided @p olen  *			is too small to hold the encoded value.  * @retval EFTYPE	If value coercion from @p value to a single string  *			value via @p fmt is unsupported.  * @retval ERANGE	If value coercion of @p value would overflow (or  *			underflow) the representation defined by @p fmt.  */
end_comment

begin_function
name|int
name|bhnd_nvram_val_printf
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|char
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|error
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|olen
argument_list|)
expr_stmt|;
name|error
operator|=
name|bhnd_nvram_val_vprintf
argument_list|(
name|value
argument_list|,
name|fmt
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Format a string representation of the elements of @p value using @p fmt,  * writing the result to @p outp.  *  * @param		value	The value to be formatted.  * @param		fmt	The format string.  * @param[out]		outp	On success, the string will be written to this   *				buffer. This argment may be NULL if the value is  *				not desired.  * @param[in,out]	olen	The capacity of @p outp. On success, will be set  *				to the actual number of bytes required for the  *				requested string encoding (including a trailing  *				NUL).  * @param		ap	Argument list.  *  * @par Format Strings  *   * Value format strings are similar, but not identical to, those used  * by printf(3).  *   * Format specifier format:  *     %[repeat][flags][width][.precision][length modifier][specifier]  *  * The format specifier is interpreted as an encoding directive for an  * individual value element; each format specifier will fetch the next element  * from the value, encode the element as the appropriate type based on the  * length modifiers and specifier, and then format the result as a string.  *   * For example, given a string value of '0x000F', and a format specifier of  * '%#hhx', the value will be asked to encode its first element as  * BHND_NVRAM_TYPE_UINT8. String formatting will then be applied to the 8-bit  * unsigned integer representation, producing a string value of "0xF".  *   * Repeat:  * - [digits]		Repeatedly apply the format specifier to the input  *			value's elements up to `digits` times. The delimiter  *			must be passed as a string in the next variadic  *			argument.  * - []			Repeatedly apply the format specifier to the input  *			value's elements until all elements have been. The  *			processed. The delimiter must be passed as a string in  *			the next variadic argument.  * - [*]		Repeatedly apply the format specifier to the input  *			value's elements. The repeat count is read from the  *			next variadic argument as a size_t value  *   * Flags:  * - '#'		use alternative form (e.g. 0x/0X prefixing of hex  *			strings).  * - '0'		zero padding  * - '-'		left adjust padding  * - '+'		include a sign character  * - ' '		include a space in place of a sign character for  *			positive numbers.  *   * Width/Precision:  * - digits		minimum field width.  * - *			read the minimum field width from the next variadic  *			argument as a ssize_t value. A negative value enables  *			left adjustment.  * - .digits		field precision.  * - .*			read the field precision from the next variadic argument  *			as a ssize_t value. A negative value enables left  *			adjustment.  *  * Length Modifiers:  * - 'hh', 'I8'		Convert the value to an 8-bit signed or unsigned  *			integer.  * - 'h', 'I16'		Convert the value to an 16-bit signed or unsigned  *			integer.  * - 'l', 'I32'		Convert the value to an 32-bit signed or unsigned  *			integer.  * - 'll', 'j', 'I64'	Convert the value to an 64-bit signed or unsigned  *			integer.  *   * Data Specifiers:  * - 'd', 'i'		Convert and format as a signed decimal integer.  * - 'u'		Convert and format as an unsigned decimal integer.  * - 'o'		Convert and format as an unsigned octal integer.  * - 'x'		Convert and format as an unsigned hexadecimal integer,  *			using lowercase hex digits.  * - 'X'		Convert and format as an unsigned hexadecimal integer,  *			using uppercase hex digits.  * - 's'		Convert and format as a string.  * - '%'		Print a literal '%' character.  *  * @retval 0		success  * @retval EINVAL	If @p fmt contains unrecognized format string  *			specifiers.  * @retval ENOMEM	If the @p outp is non-NULL, and the provided @p olen  *			is too small to hold the encoded value.  * @retval EFTYPE	If value coercion from @p value to a single string  *			value via @p fmt is unsupported.  * @retval ERANGE	If value coercion of @p value would overflow (or  *			underflow) the representation defined by @p fmt.  */
end_comment

begin_function
name|int
name|bhnd_nvram_val_vprintf
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|char
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|elem
decl_stmt|;
name|size_t
name|elen
decl_stmt|;
name|size_t
name|limit
decl_stmt|,
name|nbytes
decl_stmt|;
name|int
name|error
decl_stmt|;
name|elem
operator|=
name|NULL
expr_stmt|;
comment|/* Determine output byte limit */
name|nbytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|outp
operator|!=
name|NULL
condition|)
name|limit
operator|=
operator|*
name|olen
expr_stmt|;
else|else
name|limit
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|WRITE_CHAR
parameter_list|(
name|_c
parameter_list|)
value|do {			\ 	if (limit> nbytes)			\ 		*(outp + nbytes) = _c;		\ 						\ 	if (nbytes == SIZE_MAX)			\ 		return (EFTYPE);		\ 	nbytes++;				\ } while (0)
comment|/* Encode string value as per the format string */
for|for
control|(
specifier|const
name|char
modifier|*
name|p
init|=
name|fmt
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|delim
decl_stmt|;
name|size_t
name|precision
decl_stmt|,
name|width
decl_stmt|,
name|delim_len
decl_stmt|;
name|u_long
name|repeat
decl_stmt|,
name|bits
decl_stmt|;
name|bool
name|alt_form
decl_stmt|,
name|ladjust
decl_stmt|,
name|have_precision
decl_stmt|;
name|char
name|padc
decl_stmt|,
name|signc
decl_stmt|,
name|lenc
decl_stmt|;
name|padc
operator|=
literal|' '
expr_stmt|;
name|signc
operator|=
literal|'\0'
expr_stmt|;
name|lenc
operator|=
literal|'\0'
expr_stmt|;
name|delim
operator|=
literal|""
expr_stmt|;
name|delim_len
operator|=
literal|0
expr_stmt|;
name|ladjust
operator|=
name|false
expr_stmt|;
name|alt_form
operator|=
name|false
expr_stmt|;
name|have_precision
operator|=
name|false
expr_stmt|;
name|precision
operator|=
literal|1
expr_stmt|;
name|bits
operator|=
literal|32
expr_stmt|;
name|width
operator|=
literal|0
expr_stmt|;
name|repeat
operator|=
literal|1
expr_stmt|;
comment|/* Copy all input to output until we hit a format specifier */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'%'
condition|)
block|{
name|WRITE_CHAR
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Hit '%' -- is this followed by an escaped '%' literal? */
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
block|{
name|WRITE_CHAR
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Parse repeat specifier */
if|if
condition|(
operator|*
name|p
operator|==
literal|'['
condition|)
block|{
name|p
operator|++
expr_stmt|;
comment|/* Determine repeat count */
if|if
condition|(
operator|*
name|p
operator|==
literal|']'
condition|)
block|{
comment|/* Repeat consumes all input */
name|repeat
operator|=
name|bhnd_nvram_val_nelem
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
comment|/* Repeat is supplied as an argument */
name|repeat
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|endp
decl_stmt|;
comment|/* Repeat specified as argument */
name|repeat
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|endp
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error parsing repeat "
literal|"count at '%s'"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Advance past repeat count */
name|p
operator|=
name|endp
expr_stmt|;
block|}
comment|/* Advance past terminating ']' */
if|if
condition|(
operator|*
name|p
operator|!=
literal|']'
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error parsing repeat count at "
literal|"'%s'"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|p
operator|++
expr_stmt|;
name|delim
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|delim_len
operator|=
name|strlen
argument_list|(
name|delim
argument_list|)
expr_stmt|;
block|}
comment|/* Parse flags */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
specifier|const
name|char
modifier|*
name|np
decl_stmt|;
name|bool
name|stop
decl_stmt|;
name|stop
operator|=
name|false
expr_stmt|;
name|np
operator|=
name|p
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'#'
case|:
name|alt_form
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
name|padc
operator|=
literal|'0'
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|ladjust
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|' '
case|:
comment|/* Must not override '+' */
if|if
condition|(
name|signc
operator|!=
literal|'+'
condition|)
name|signc
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|signc
operator|=
literal|'+'
expr_stmt|;
break|break;
default|default:
comment|/* Non-flag character */
name|stop
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stop
condition|)
break|break;
else|else
name|p
operator|=
name|np
expr_stmt|;
block|}
comment|/* Parse minimum width */
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
name|ssize_t
name|arg
decl_stmt|;
comment|/* Width is supplied as an argument */
name|arg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
comment|/* Negative width argument is interpreted as 			 * '-' flag followed by positive width */
if|if
condition|(
name|arg
operator|<
literal|0
condition|)
block|{
name|ladjust
operator|=
name|true
expr_stmt|;
name|arg
operator|=
operator|-
name|arg
expr_stmt|;
block|}
name|width
operator|=
name|arg
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bhnd_nv_isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|parsed
decl_stmt|;
comment|/* Parse width value */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|error
operator|=
name|bhnd_nvram_parse_int
argument_list|(
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|,
literal|10
argument_list|,
operator|&
name|parsed
argument_list|,
operator|&
name|v
argument_list|,
operator|&
name|len
argument_list|,
name|BHND_NVRAM_TYPE_UINT32
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error parsing width %s: %d\n"
argument_list|,
name|p
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Save width and advance input */
name|width
operator|=
name|v
expr_stmt|;
name|p
operator|+=
name|parsed
expr_stmt|;
block|}
comment|/* Parse precision */
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|parsed
decl_stmt|;
name|p
operator|++
expr_stmt|;
name|have_precision
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
name|ssize_t
name|arg
decl_stmt|;
comment|/* Precision is specified as an argument */
name|arg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
comment|/* Negative precision argument is interpreted 				 * as '-' flag followed by positive 				 * precision */
if|if
condition|(
name|arg
operator|<
literal|0
condition|)
block|{
name|ladjust
operator|=
name|true
expr_stmt|;
name|arg
operator|=
operator|-
name|arg
expr_stmt|;
block|}
name|precision
operator|=
name|arg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|bhnd_nv_isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
comment|/* Implicit precision of 0 */
name|precision
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Parse precision value */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|error
operator|=
name|bhnd_nvram_parse_int
argument_list|(
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|,
literal|10
argument_list|,
operator|&
name|parsed
argument_list|,
operator|&
name|v
argument_list|,
operator|&
name|len
argument_list|,
name|BHND_NVRAM_TYPE_UINT32
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error parsing width %s: "
literal|"%d\n"
argument_list|,
name|p
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Save precision and advance input */
name|precision
operator|=
name|v
expr_stmt|;
name|p
operator|+=
name|parsed
expr_stmt|;
block|}
block|}
comment|/* Parse length modifiers */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
specifier|const
name|char
modifier|*
name|np
decl_stmt|;
name|bool
name|stop
decl_stmt|;
name|stop
operator|=
name|false
expr_stmt|;
name|np
operator|=
name|p
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'h'
case|:
if|if
condition|(
name|lenc
operator|==
literal|'\0'
condition|)
block|{
comment|/* Set initial length value */
name|lenc
operator|=
operator|*
name|p
expr_stmt|;
name|bits
operator|=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lenc
operator|==
operator|*
name|p
operator|&&
name|bits
operator|==
literal|16
condition|)
block|{
comment|/* Modify previous length value */
name|bits
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|BHND_NV_LOG
argument_list|(
literal|"invalid length modifier "
literal|"%c\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|lenc
operator|==
literal|'\0'
condition|)
block|{
comment|/* Set initial length value */
name|lenc
operator|=
operator|*
name|p
expr_stmt|;
name|bits
operator|=
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lenc
operator|==
operator|*
name|p
operator|&&
name|bits
operator|==
literal|32
condition|)
block|{
comment|/* Modify previous length value */
name|bits
operator|=
literal|64
expr_stmt|;
block|}
else|else
block|{
name|BHND_NV_LOG
argument_list|(
literal|"invalid length modifier "
literal|"%c\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
case|case
literal|'j'
case|:
comment|/* Conflicts with all other length 				 * specifications, and may only occur once */
if|if
condition|(
name|lenc
operator|!=
literal|'\0'
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"invalid length modifier "
literal|"%c\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|lenc
operator|=
operator|*
name|p
expr_stmt|;
name|bits
operator|=
literal|64
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
block|{
name|char
modifier|*
name|endp
decl_stmt|;
comment|/* Conflicts with all other length 				 * specifications, and may only occur once */
if|if
condition|(
name|lenc
operator|!=
literal|'\0'
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"invalid length modifier "
literal|"%c\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|lenc
operator|=
operator|*
name|p
expr_stmt|;
comment|/* Parse the length specifier value */
name|p
operator|++
expr_stmt|;
name|bits
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|endp
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"invalid size specifier: "
literal|"%s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Advance input past the parsed integer */
name|np
operator|=
name|endp
expr_stmt|;
break|break;
block|}
default|default:
comment|/* Non-length modifier character */
name|stop
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stop
condition|)
break|break;
else|else
name|p
operator|=
name|np
expr_stmt|;
block|}
comment|/* Parse conversion specifier and format the value(s) */
for|for
control|(
name|u_long
name|n
init|=
literal|0
init|;
name|n
operator|<
name|repeat
condition|;
name|n
operator|++
control|)
block|{
name|bhnd_nvram_type
name|arg_type
decl_stmt|;
name|size_t
name|arg_size
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|u_long
name|base
decl_stmt|;
name|bool
name|is_signed
decl_stmt|,
name|is_upper
decl_stmt|;
name|is_signed
operator|=
name|false
expr_stmt|;
name|is_upper
operator|=
name|false
expr_stmt|;
name|base
operator|=
literal|0
expr_stmt|;
comment|/* Fetch next element */
name|elem
operator|=
name|bhnd_nvram_val_next
argument_list|(
name|value
argument_list|,
name|elem
argument_list|,
operator|&
name|elen
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|==
name|NULL
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"format string references more "
literal|"than %zu available value elements\n"
argument_list|,
name|bhnd_nvram_val_nelem
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 			 * If this is not the first value, append the delimiter. 			 */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|size_t
name|nremain
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|limit
operator|>
name|nbytes
condition|)
name|nremain
operator|=
name|limit
operator|-
name|nbytes
expr_stmt|;
if|if
condition|(
name|nremain
operator|>=
name|delim_len
condition|)
name|memcpy
argument_list|(
name|outp
operator|+
name|nbytes
argument_list|,
name|delim
argument_list|,
name|delim_len
argument_list|)
expr_stmt|;
comment|/* Add delimiter length to the total byte count */
if|if
condition|(
name|SIZE_MAX
operator|-
name|nbytes
operator|<
name|delim_len
condition|)
return|return
operator|(
name|EFTYPE
operator|)
return|;
comment|/* overflows size_t */
name|nbytes
operator|+=
name|delim_len
expr_stmt|;
block|}
comment|/* Parse integer conversion specifiers */
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
name|base
operator|=
literal|10
expr_stmt|;
name|is_signed
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|base
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|base
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|base
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|base
operator|=
literal|16
expr_stmt|;
name|is_upper
operator|=
name|true
expr_stmt|;
break|break;
block|}
comment|/* Format argument */
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
define|#
directive|define
name|NV_ENCODE_INT
parameter_list|(
name|_width
parameter_list|)
value|do { 					\ 	arg_type = (is_signed) ? BHND_NVRAM_TYPE_INT ## _width :	\ 	    BHND_NVRAM_TYPE_UINT ## _width;				\ 	arg_size = sizeof(v.u ## _width);				\ 	error = bhnd_nvram_val_encode_elem(value, elem, elen,		\&v.u ## _width,&arg_size, arg_type);			\ 	if (error) {							\ 		BHND_NV_LOG("error encoding argument as %s: %d\n",	\ 		     bhnd_nvram_type_name(arg_type), error);		\ 		return (error);						\ 	}								\ 									\ 	if (is_signed) {						\ 		if (v.i ## _width< 0) {				\ 			add_neg = true;					\ 			numval = (int64_t)-(v.i ## _width);		\ 		} else {						\ 			numval = (int64_t) (v.i ## _width);		\ 		}							\ 	} else {							\ 		numval = v.u ## _width;					\ 	}								\ } while(0)
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
case|case
literal|'u'
case|:
case|case
literal|'o'
case|:
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
block|{
name|char
name|numbuf
index|[
name|NV_NUMSTR_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|sptr
decl_stmt|;
name|uint64_t
name|numval
decl_stmt|;
name|size_t
name|slen
decl_stmt|;
name|bool
name|add_neg
decl_stmt|;
union|union
block|{
name|uint8_t
name|u8
decl_stmt|;
name|uint16_t
name|u16
decl_stmt|;
name|uint32_t
name|u32
decl_stmt|;
name|uint64_t
name|u64
decl_stmt|;
name|int8_t
name|i8
decl_stmt|;
name|int16_t
name|i16
decl_stmt|;
name|int32_t
name|i32
decl_stmt|;
name|int64_t
name|i64
decl_stmt|;
block|}
name|v
union|;
name|add_neg
operator|=
name|false
expr_stmt|;
comment|/* If precision is specified, it overrides 				 * (and behaves identically) to a zero-prefixed 				 * minimum width */
if|if
condition|(
name|have_precision
condition|)
block|{
name|padc
operator|=
literal|'0'
expr_stmt|;
name|width
operator|=
name|precision
expr_stmt|;
name|ladjust
operator|=
name|false
expr_stmt|;
block|}
comment|/* If zero-padding is used, value must be right 				 * adjusted */
if|if
condition|(
name|padc
operator|==
literal|'0'
condition|)
name|ladjust
operator|=
name|false
expr_stmt|;
comment|/* Request encode to the appropriate integer 				 * type, and then promote to common 64-bit 				 * representation */
switch|switch
condition|(
name|bits
condition|)
block|{
case|case
literal|8
case|:
name|NV_ENCODE_INT
argument_list|(
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|NV_ENCODE_INT
argument_list|(
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|NV_ENCODE_INT
argument_list|(
literal|32
argument_list|)
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|NV_ENCODE_INT
argument_list|(
literal|64
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BHND_NV_LOG
argument_list|(
literal|"invalid length specifier: "
literal|"%lu\n"
argument_list|,
name|bits
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
undef|#
directive|undef
name|NV_ENCODE_INT
comment|/* If a precision of 0 is specified and the 				 * value is also zero, no characters should 				 * be produced */
if|if
condition|(
name|have_precision
operator|&&
name|precision
operator|==
literal|0
operator|&&
name|numval
operator|==
literal|0
condition|)
block|{
break|break;
block|}
comment|/* Emit string representation to local buffer */
name|BHND_NV_ASSERT
argument_list|(
name|base
operator|<=
literal|16
argument_list|,
operator|(
literal|"invalid base"
operator|)
argument_list|)
expr_stmt|;
name|sptr
operator|=
name|numbuf
operator|+
name|nitems
argument_list|(
name|numbuf
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|slen
operator|=
literal|0
init|;
name|slen
operator|<
sizeof|sizeof
argument_list|(
name|numbuf
argument_list|)
condition|;
name|slen
operator|++
control|)
block|{
name|char
name|c
decl_stmt|;
name|uint64_t
name|n
decl_stmt|;
name|n
operator|=
name|numval
operator|%
name|base
expr_stmt|;
name|c
operator|=
name|bhnd_nv_hex2ascii
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_upper
condition|)
name|c
operator|=
name|bhnd_nv_toupper
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|sptr
operator|--
expr_stmt|;
operator|*
name|sptr
operator|=
name|c
expr_stmt|;
name|numval
operator|/=
operator|(
name|uint64_t
operator|)
name|base
expr_stmt|;
if|if
condition|(
name|numval
operator|==
literal|0
condition|)
block|{
name|slen
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|arg_size
operator|=
name|slen
expr_stmt|;
comment|/* Reserve space for 0/0x prefix? */
if|if
condition|(
name|alt_form
condition|)
block|{
if|if
condition|(
name|numval
operator|==
literal|0
condition|)
block|{
comment|/* If 0, no prefix */
name|alt_form
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base
operator|==
literal|8
condition|)
block|{
name|arg_size
operator|+=
literal|1
expr_stmt|;
comment|/* 0 */
block|}
elseif|else
if|if
condition|(
name|base
operator|==
literal|16
condition|)
block|{
name|arg_size
operator|+=
literal|2
expr_stmt|;
comment|/* 0x/0X */
block|}
block|}
comment|/* Reserve space for ' ', '+', or '-' prefix? */
if|if
condition|(
name|add_neg
operator|||
name|signc
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|add_neg
condition|)
name|signc
operator|=
literal|'-'
expr_stmt|;
name|arg_size
operator|++
expr_stmt|;
block|}
comment|/* Right adjust (if using spaces) */
if|if
condition|(
operator|!
name|ladjust
operator|&&
name|padc
operator|!=
literal|'0'
condition|)
block|{
for|for
control|(
name|i
operator|=
name|arg_size
init|;
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
name|WRITE_CHAR
argument_list|(
name|padc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signc
operator|!=
literal|'\0'
condition|)
name|WRITE_CHAR
argument_list|(
name|signc
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt_form
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|8
condition|)
block|{
name|WRITE_CHAR
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base
operator|==
literal|16
condition|)
block|{
name|WRITE_CHAR
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_upper
condition|)
name|WRITE_CHAR
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
else|else
name|WRITE_CHAR
argument_list|(
literal|'x'
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Right adjust (if using zeros) */
if|if
condition|(
operator|!
name|ladjust
operator|&&
name|padc
operator|==
literal|'0'
condition|)
block|{
for|for
control|(
name|i
operator|=
name|slen
init|;
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
name|WRITE_CHAR
argument_list|(
name|padc
argument_list|)
expr_stmt|;
block|}
comment|/* Write the string to our output buffer */
if|if
condition|(
name|limit
operator|>
name|nbytes
operator|&&
name|limit
operator|-
name|nbytes
operator|>=
name|slen
condition|)
name|memcpy
argument_list|(
name|outp
operator|+
name|nbytes
argument_list|,
name|sptr
argument_list|,
name|slen
argument_list|)
expr_stmt|;
comment|/* Update the total byte count */
if|if
condition|(
name|SIZE_MAX
operator|-
name|nbytes
operator|<
name|arg_size
condition|)
return|return
operator|(
name|EFTYPE
operator|)
return|;
comment|/* overflows size_t */
name|nbytes
operator|+=
name|arg_size
expr_stmt|;
comment|/* Left adjust */
for|for
control|(
name|i
operator|=
name|arg_size
init|;
name|ladjust
operator|&&
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
name|WRITE_CHAR
argument_list|(
name|padc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'s'
case|:
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|slen
decl_stmt|;
comment|/* Query the total length of the element when 				 * converted to a string */
name|arg_type
operator|=
name|BHND_NVRAM_TYPE_STRING
expr_stmt|;
name|error
operator|=
name|bhnd_nvram_val_encode_elem
argument_list|(
name|value
argument_list|,
name|elem
argument_list|,
name|elen
argument_list|,
name|NULL
argument_list|,
operator|&
name|arg_size
argument_list|,
name|arg_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error encoding argument "
literal|"as %s: %d\n"
argument_list|,
name|bhnd_nvram_type_name
argument_list|(
name|arg_type
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Do not include trailing NUL in the string 				 * length */
if|if
condition|(
name|arg_size
operator|>
literal|0
condition|)
name|arg_size
operator|--
expr_stmt|;
comment|/* Right adjust */
for|for
control|(
name|i
operator|=
name|arg_size
init|;
operator|!
name|ladjust
operator|&&
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
name|WRITE_CHAR
argument_list|(
name|padc
argument_list|)
expr_stmt|;
comment|/* Determine output positition and remaining 				 * buffer space */
if|if
condition|(
name|limit
operator|>
name|nbytes
condition|)
block|{
name|s
operator|=
name|outp
operator|+
name|nbytes
expr_stmt|;
name|slen
operator|=
name|limit
operator|-
name|nbytes
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|NULL
expr_stmt|;
name|slen
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Encode the string to our output buffer */
name|error
operator|=
name|bhnd_nvram_val_encode_elem
argument_list|(
name|value
argument_list|,
name|elem
argument_list|,
name|elen
argument_list|,
name|s
argument_list|,
operator|&
name|slen
argument_list|,
name|arg_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOMEM
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error encoding argument "
literal|"as %s: %d\n"
argument_list|,
name|bhnd_nvram_type_name
argument_list|(
name|arg_type
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Update the total byte count */
if|if
condition|(
name|SIZE_MAX
operator|-
name|nbytes
operator|<
name|arg_size
condition|)
return|return
operator|(
name|EFTYPE
operator|)
return|;
comment|/* overflows size_t */
name|nbytes
operator|+=
name|arg_size
expr_stmt|;
comment|/* Left adjust */
for|for
control|(
name|i
operator|=
name|arg_size
init|;
name|ladjust
operator|&&
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
name|WRITE_CHAR
argument_list|(
name|padc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'c'
case|:
block|{
name|char
name|c
decl_stmt|;
name|arg_type
operator|=
name|BHND_NVRAM_TYPE_CHAR
expr_stmt|;
name|arg_size
operator|=
name|bhnd_nvram_type_width
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
comment|/* Encode as single character */
name|error
operator|=
name|bhnd_nvram_val_encode_elem
argument_list|(
name|value
argument_list|,
name|elem
argument_list|,
name|elen
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|arg_size
argument_list|,
name|arg_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error encoding argument "
literal|"as %s: %d\n"
argument_list|,
name|bhnd_nvram_type_name
argument_list|(
name|arg_type
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|BHND_NV_ASSERT
argument_list|(
name|arg_size
operator|==
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|(
literal|"invalid encoded size"
operator|)
argument_list|)
expr_stmt|;
comment|/* Right adjust */
for|for
control|(
name|i
operator|=
name|arg_size
init|;
operator|!
name|ladjust
operator|&&
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
name|WRITE_CHAR
argument_list|(
name|padc
argument_list|)
expr_stmt|;
name|WRITE_CHAR
argument_list|(
name|padc
argument_list|)
expr_stmt|;
comment|/* Left adjust */
for|for
control|(
name|i
operator|=
name|arg_size
init|;
name|ladjust
operator|&&
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
name|WRITE_CHAR
argument_list|(
name|padc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* Append terminating NUL */
if|if
condition|(
name|limit
operator|>
name|nbytes
condition|)
operator|*
operator|(
name|outp
operator|+
name|nbytes
operator|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<
name|SIZE_MAX
condition|)
name|nbytes
operator|++
expr_stmt|;
else|else
return|return
operator|(
name|EFTYPE
operator|)
return|;
comment|/* Report required space */
operator|*
name|olen
operator|=
name|nbytes
expr_stmt|;
if|if
condition|(
name|limit
operator|<
name|nbytes
condition|)
block|{
if|if
condition|(
name|outp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

