begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Landon Fuller<landonf@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/_inttypes.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_KERNEL */
end_comment

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_include
include|#
directive|include
file|"bhnd_nvram_private.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_valuevar.h"
end_include

begin_function_decl
specifier|static
name|void
modifier|*
name|bhnd_nvram_val_alloc_bytes
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_val_set
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_val_set_inline
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|BHND_NVRAM_VAL_INITIALIZER
parameter_list|(
name|_fmt
parameter_list|,
name|_storage
parameter_list|)
define|\
value|(bhnd_nvram_val) {					\ 		.refs = 1,					\ 		.val_storage = _storage,			\ 		.fmt = _fmt,					\ 		.data_storage = BHND_NVRAM_VAL_DATA_NONE,	\ 	};
end_define

begin_comment
comment|/** Assert that @p value's backing representation state has initialized  *  as empty. */
end_comment

begin_define
define|#
directive|define
name|BHND_NVRAM_VAL_ASSERT_EMPTY
parameter_list|(
name|_value
parameter_list|)
define|\
value|BHND_NV_ASSERT(						\ 	    value->data_storage == BHND_NVRAM_VAL_DATA_NONE&&	\ 	    value->data_len == 0&&				\ 	    value->data.ptr == NULL,				\ 	    ("previously initialized value"))
end_define

begin_comment
comment|/* Common initialization support for bhnd_nvram_val_init() and  * bhnd_nvram_val_new() */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_val_init_common
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
name|bhnd_nvram_val_storage
name|val_storage
parameter_list|,
specifier|const
name|bhnd_nvram_val_fmt
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|void
modifier|*
name|outp
decl_stmt|;
name|bhnd_nvram_type
name|otype
decl_stmt|;
name|size_t
name|olen
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Determine expected data type, and allow the format to delegate to 	 * a new format instance */
if|if
condition|(
name|fmt
operator|!=
name|NULL
operator|&&
name|fmt
operator|->
name|op_filter
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|bhnd_nvram_val_fmt
modifier|*
name|nfmt
init|=
name|fmt
decl_stmt|;
comment|/* Use the filter function to determine whether direct 		 * initialization from is itype permitted */
name|error
operator|=
name|fmt
operator|->
name|op_filter
argument_list|(
operator|&
name|nfmt
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Retry initialization with new format? */
if|if
condition|(
name|nfmt
operator|!=
name|fmt
condition|)
block|{
return|return
operator|(
name|bhnd_nvram_val_init_common
argument_list|(
name|value
argument_list|,
name|val_storage
argument_list|,
name|nfmt
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
comment|/* Value can be initialized with provided input type */
name|otype
operator|=
name|itype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
operator|!=
name|NULL
condition|)
block|{
comment|/* Value must be initialized with the format's native 		 * type */
name|otype
operator|=
name|fmt
operator|->
name|native_type
expr_stmt|;
block|}
else|else
block|{
comment|/* No format specified; we can initialize directly from the 		 * input data, and we'll handle all format operations 		 * internally. */
name|otype
operator|=
name|itype
expr_stmt|;
block|}
comment|/* Initialize value instance */
operator|*
name|value
operator|=
name|BHND_NVRAM_VAL_INITIALIZER
argument_list|(
name|fmt
argument_list|,
name|val_storage
argument_list|)
expr_stmt|;
comment|/* If input data already in native format, init directly. */
if|if
condition|(
name|otype
operator|==
name|itype
condition|)
block|{
name|error
operator|=
name|bhnd_nvram_val_set
argument_list|(
name|value
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Determine size when encoded in native format */
name|error
operator|=
name|bhnd_nvram_value_coerce
argument_list|(
name|inp
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|,
name|NULL
argument_list|,
operator|&
name|olen
argument_list|,
name|otype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Fetch reference to (or allocate) an appropriately sized buffer */
name|outp
operator|=
name|bhnd_nvram_val_alloc_bytes
argument_list|(
name|value
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|outp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Perform encode */
name|error
operator|=
name|bhnd_nvram_value_coerce
argument_list|(
name|inp
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|,
name|outp
argument_list|,
operator|&
name|olen
argument_list|,
name|otype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize an externally allocated instance of @p value with @p fmt from the  * given @p inp buffer of @p itype and @p ilen.  *  * On success, the caller owns a reference to @p value, and is responsible for  * freeing any resources allocated for @p value via bhnd_nvram_val_release().  *  * @param	value	The externally allocated value instance to be  *			initialized.  * @param	fmt	The value's format, or NULL to use the default format  *			for @p itype.  * @param	inp	Input buffer.  * @param	ilen	Input buffer length.  * @param	itype	Input buffer type.  * @param	flags	Value flags (see BHND_NVRAM_VAL_*).  *   * @retval 0		success  * @retval ENOMEM	If allocation fails.  * @retval EFTYPE	If @p fmt initialization from @p itype is unsupported.  * @retval EFAULT	if @p ilen is not correctly aligned for elements of  *			@p itype.  * @retval ERANGE	If value coercion would overflow (or underflow) the  *			@p fmt representation.  */
end_comment

begin_function
name|int
name|bhnd_nvram_val_init
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
specifier|const
name|bhnd_nvram_val_fmt
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|bhnd_nvram_val_init_common
argument_list|(
name|value
argument_list|,
name|BHND_NVRAM_VAL_STORAGE_AUTO
argument_list|,
name|fmt
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|bhnd_nvram_val_release
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Allocate a value instance with @p fmt, and attempt to initialize its internal  * representation from the given @p inp buffer of @p itype and @p ilen.  *  * On success, the caller owns a reference to @p value, and is responsible for  * freeing any resources allocated for @p value via bhnd_nvram_val_release().  *  * @param[out]	value	On success, the allocated value instance.  * @param	fmt	The value's format, or NULL to use the default format  *			for @p itype.  * @param	inp	Input buffer.  * @param	ilen	Input buffer length.  * @param	itype	Input buffer type.  * @param	flags	Value flags (see BHND_NVRAM_VAL_*).  *   * @retval 0		success  * @retval ENOMEM	If allocation fails.  * @retval EFTYPE	If @p fmt initialization from @p itype is unsupported.  * @retval EFAULT	if @p ilen is not correctly aligned for elements of  *			@p itype.  * @retval ERANGE	If value coercion would overflow (or underflow) the  *			@p fmt representation.  */
end_comment

begin_function
name|int
name|bhnd_nvram_val_new
parameter_list|(
name|bhnd_nvram_val
modifier|*
modifier|*
name|value
parameter_list|,
specifier|const
name|bhnd_nvram_val_fmt
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Allocate new instance */
if|if
condition|(
operator|(
operator|*
name|value
operator|=
name|bhnd_nv_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|value
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Perform common initialization. */
name|error
operator|=
name|bhnd_nvram_val_init_common
argument_list|(
operator|*
name|value
argument_list|,
name|BHND_NVRAM_VAL_STORAGE_DYNAMIC
argument_list|,
name|fmt
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* Will also free() the value allocation */
name|bhnd_nvram_val_release
argument_list|(
operator|*
name|value
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Copy or retain a reference to @p value.  *   * On success, the caller is responsible for freeing the result via  * bhnd_nvram_val_release().  *   * @param	value	The value to be copied (or retained).  *   * @retval bhnd_nvram_val	if @p value was successfully copied or retained.  * @retval NULL			if allocation failed.  */
end_comment

begin_function
name|bhnd_nvram_val
modifier|*
name|bhnd_nvram_val_copy
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|)
block|{
name|bhnd_nvram_val
modifier|*
name|result
decl_stmt|;
specifier|const
name|void
modifier|*
name|bytes
decl_stmt|;
name|bhnd_nvram_type
name|type
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* If dynamically allocated, simply bump the reference count */
if|if
condition|(
name|value
operator|->
name|val_storage
operator|==
name|BHND_NVRAM_VAL_STORAGE_DYNAMIC
condition|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|value
operator|->
name|refs
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
comment|/* Otherwise, we need to perform an actual copy */
name|BHND_NV_ASSERT
argument_list|(
name|value
operator|->
name|refs
operator|==
literal|1
argument_list|,
operator|(
literal|"non-allocated value has "
literal|"active refcount (%u)"
operator|,
name|value
operator|->
name|refs
operator|)
argument_list|)
expr_stmt|;
comment|/* Compute the new value's flags based on the source value */
switch|switch
condition|(
name|value
operator|->
name|data_storage
condition|)
block|{
case|case
name|BHND_NVRAM_VAL_DATA_NONE
case|:
case|case
name|BHND_NVRAM_VAL_DATA_INLINE
case|:
case|case
name|BHND_NVRAM_VAL_DATA_EXT_WEAK
case|:
case|case
name|BHND_NVRAM_VAL_DATA_EXT_ALLOC
case|:
comment|/* Copy the source data and permit additional allocation if the 		 * value cannot be represented inline */
name|flags
operator|=
name|BHND_NVRAM_VAL_COPY_DATA
operator||
name|BHND_NVRAM_VAL_DYNAMIC
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_VAL_DATA_EXT_STATIC
case|:
name|flags
operator|=
name|BHND_NVRAM_VAL_STATIC_DATA
expr_stmt|;
break|break;
default|default:
name|BHND_NV_PANIC
argument_list|(
literal|"invalid storage type: %d"
argument_list|,
name|value
operator|->
name|data_storage
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate new value copy */
name|bytes
operator|=
name|bhnd_nvram_val_bytes
argument_list|(
name|value
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
name|error
operator|=
name|bhnd_nvram_val_new
argument_list|(
operator|&
name|result
argument_list|,
name|value
operator|->
name|fmt
argument_list|,
name|bytes
argument_list|,
name|len
argument_list|,
name|type
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"copy failed: %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Release a reference to @p value.  *  * If this is the last reference, all associated resources will be freed.  *   * @param	value	The value to be released.  */
end_comment

begin_function
name|void
name|bhnd_nvram_val_release
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|)
block|{
name|BHND_NV_ASSERT
argument_list|(
name|value
operator|->
name|refs
operator|>=
literal|1
argument_list|,
operator|(
literal|"value over-released"
operator|)
argument_list|)
expr_stmt|;
comment|/* Drop reference */
if|if
condition|(
operator|!
name|refcount_release
argument_list|(
operator|&
name|value
operator|->
name|refs
argument_list|)
condition|)
return|return;
comment|/* Free allocated external representation data */
if|if
condition|(
name|value
operator|->
name|data_storage
operator|==
name|BHND_NVRAM_VAL_DATA_EXT_ALLOC
condition|)
name|bhnd_nv_free
argument_list|(
name|__DECONST
argument_list|(
name|void
operator|*
argument_list|,
name|value
operator|->
name|data
operator|.
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Free instance if dynamically allocated */
if|if
condition|(
name|value
operator|->
name|val_storage
operator|==
name|BHND_NVRAM_VAL_STORAGE_DYNAMIC
condition|)
name|bhnd_nv_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Standard string/char array/char encoding implementation.  *  * Input type must be one of:  * - BHND_NVRAM_TYPE_STRING  * - BHND_NVRAM_TYPE_CHAR  * - BHND_NVRAM_TYPE_CHAR_ARRAY  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_val_encode_string
parameter_list|(
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cstr
decl_stmt|;
name|bhnd_nvram_type
name|otype_base
decl_stmt|;
name|size_t
name|cstr_size
decl_stmt|,
name|cstr_len
decl_stmt|;
name|size_t
name|limit
decl_stmt|,
name|nbytes
decl_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|itype
operator|==
name|BHND_NVRAM_TYPE_STRING
operator|||
name|itype
operator|==
name|BHND_NVRAM_TYPE_CHAR
operator|||
name|itype
operator|==
name|BHND_NVRAM_TYPE_CHAR_ARRAY
argument_list|,
operator|(
literal|"unsupported type: %d"
operator|,
name|itype
operator|)
argument_list|)
expr_stmt|;
name|cstr
operator|=
name|inp
expr_stmt|;
name|cstr_size
operator|=
name|ilen
expr_stmt|;
name|nbytes
operator|=
literal|0
expr_stmt|;
name|otype_base
operator|=
name|bhnd_nvram_base_type
argument_list|(
name|otype
argument_list|)
expr_stmt|;
comment|/* Determine output byte limit */
if|if
condition|(
name|outp
operator|!=
name|NULL
condition|)
name|limit
operator|=
operator|*
name|olen
expr_stmt|;
else|else
name|limit
operator|=
literal|0
expr_stmt|;
comment|/* Determine string length, minus trailing NUL (if any) */
name|cstr_len
operator|=
name|strnlen
argument_list|(
name|cstr
argument_list|,
name|cstr_size
argument_list|)
expr_stmt|;
comment|/* Parse the field data */
switch|switch
condition|(
name|otype
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_CHAR
case|:
case|case
name|BHND_NVRAM_TYPE_CHAR_ARRAY
case|:
comment|/* String must contain exactly 1 non-terminating-NUL character 		 * to be represented as a single char */
if|if
condition|(
operator|!
name|bhnd_nvram_is_array_type
argument_list|(
name|otype
argument_list|)
condition|)
block|{
if|if
condition|(
name|cstr_len
operator|!=
literal|1
condition|)
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
comment|/* Copy out the characters directly (excluding trailing NUL) */
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cstr_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|limit
operator|>
name|nbytes
condition|)
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|outp
operator|+
name|nbytes
operator|)
operator|=
name|cstr
index|[
name|i
index|]
expr_stmt|;
name|nbytes
operator|++
expr_stmt|;
block|}
comment|/* Provide required length */
operator|*
name|olen
operator|=
name|nbytes
expr_stmt|;
if|if
condition|(
name|limit
operator|<
operator|*
name|olen
operator|&&
name|outp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|BHND_NVRAM_TYPE_UINT8
case|:
case|case
name|BHND_NVRAM_TYPE_UINT8_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_UINT16
case|:
case|case
name|BHND_NVRAM_TYPE_UINT16_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_UINT32
case|:
case|case
name|BHND_NVRAM_TYPE_UINT32_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_UINT64
case|:
case|case
name|BHND_NVRAM_TYPE_UINT64_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_INT8
case|:
case|case
name|BHND_NVRAM_TYPE_INT8_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_INT16
case|:
case|case
name|BHND_NVRAM_TYPE_INT16_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_INT32
case|:
case|case
name|BHND_NVRAM_TYPE_INT32_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_INT64
case|:
case|case
name|BHND_NVRAM_TYPE_INT64_ARRAY
case|:
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|plen
decl_stmt|,
name|parsed_len
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Trim leading/trailing whitespace */
name|p
operator|=
name|cstr
expr_stmt|;
name|plen
operator|=
name|bhnd_nvram_trim_field
argument_list|(
operator|&
name|p
argument_list|,
name|cstr_len
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* Try to parse the integer value */
name|error
operator|=
name|bhnd_nvram_parse_int
argument_list|(
name|p
argument_list|,
name|plen
argument_list|,
literal|0
argument_list|,
operator|&
name|parsed_len
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
name|otype_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_DEBUG
argument_list|(
literal|"error parsing '%.*s' as integer: %d\n"
argument_list|,
name|BHND_NV_PRINT_WIDTH
argument_list|(
name|plen
argument_list|)
argument_list|,
name|p
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Do additional bytes remain unparsed? */
if|if
condition|(
name|plen
operator|!=
name|parsed_len
condition|)
block|{
name|BHND_NV_DEBUG
argument_list|(
literal|"error parsing '%.*s' as a single "
literal|"integer value; trailing garbage '%.*s'\n"
argument_list|,
name|BHND_NV_PRINT_WIDTH
argument_list|(
name|plen
argument_list|)
argument_list|,
name|p
argument_list|,
name|BHND_NV_PRINT_WIDTH
argument_list|(
name|plen
operator|-
name|parsed_len
argument_list|)
argument_list|,
name|p
operator|+
name|parsed_len
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|BHND_NVRAM_TYPE_STRING
case|:
case|case
name|BHND_NVRAM_TYPE_STRING_ARRAY
case|:
comment|/* Copy out the string representation as-is */
operator|*
name|olen
operator|=
name|cstr_size
expr_stmt|;
comment|/* Need additional space for trailing NUL? */
if|if
condition|(
name|cstr_len
operator|==
name|cstr_size
condition|)
operator|(
operator|*
name|olen
operator|)
operator|++
expr_stmt|;
comment|/* Skip output? */
if|if
condition|(
name|outp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Verify required length */
if|if
condition|(
name|limit
operator|<
operator|*
name|olen
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Copy and NUL terminate */
name|strncpy
argument_list|(
name|outp
argument_list|,
name|cstr
argument_list|,
name|cstr_len
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|outp
operator|+
name|cstr_len
operator|)
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|BHND_NV_PANIC
argument_list|(
literal|"unknown type %s"
argument_list|,
name|bhnd_nvram_type_name
argument_list|(
name|otype
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Standard integer encoding implementation.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_val_encode_int
parameter_list|(
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|)
block|{
name|bhnd_nvram_type
name|otype_base
decl_stmt|;
name|size_t
name|limit
decl_stmt|,
name|nbytes
decl_stmt|;
name|bool
name|itype_signed
decl_stmt|,
name|otype_signed
decl_stmt|,
name|otype_int
decl_stmt|;
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
name|int64_t
name|i64
decl_stmt|;
block|}
name|intv
union|;
name|BHND_NV_ASSERT
argument_list|(
name|bhnd_nvram_is_int_type
argument_list|(
name|itype
argument_list|)
argument_list|,
operator|(
literal|"non-integer type"
operator|)
argument_list|)
expr_stmt|;
comment|/* Determine output byte limit */
if|if
condition|(
name|outp
operator|!=
name|NULL
condition|)
name|limit
operator|=
operator|*
name|olen
expr_stmt|;
else|else
name|limit
operator|=
literal|0
expr_stmt|;
comment|/* Fetch output type info */
name|otype_base
operator|=
name|bhnd_nvram_base_type
argument_list|(
name|otype
argument_list|)
expr_stmt|;
name|otype_int
operator|=
name|bhnd_nvram_is_int_type
argument_list|(
name|otype
argument_list|)
expr_stmt|;
name|otype_signed
operator|=
name|bhnd_nvram_is_signed_type
argument_list|(
name|otype_base
argument_list|)
expr_stmt|;
comment|/* 	 * Promote integer value to a common 64-bit representation. 	 */
switch|switch
condition|(
name|itype
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_UINT8
case|:
if|if
condition|(
name|ilen
operator|!=
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|itype_signed
operator|=
name|false
expr_stmt|;
name|intv
operator|.
name|u64
operator|=
operator|*
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|inp
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT16
case|:
if|if
condition|(
name|ilen
operator|!=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|itype_signed
operator|=
name|false
expr_stmt|;
name|intv
operator|.
name|u64
operator|=
operator|*
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|inp
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT32
case|:
if|if
condition|(
name|ilen
operator|!=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|itype_signed
operator|=
name|false
expr_stmt|;
name|intv
operator|.
name|u64
operator|=
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|inp
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT64
case|:
if|if
condition|(
name|ilen
operator|!=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|itype_signed
operator|=
name|false
expr_stmt|;
name|intv
operator|.
name|u64
operator|=
operator|*
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
name|inp
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_INT8
case|:
if|if
condition|(
name|ilen
operator|!=
sizeof|sizeof
argument_list|(
name|int8_t
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|itype_signed
operator|=
name|true
expr_stmt|;
name|intv
operator|.
name|i64
operator|=
operator|*
operator|(
specifier|const
name|int8_t
operator|*
operator|)
name|inp
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_INT16
case|:
if|if
condition|(
name|ilen
operator|!=
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|itype_signed
operator|=
name|true
expr_stmt|;
name|intv
operator|.
name|i64
operator|=
operator|*
operator|(
specifier|const
name|int16_t
operator|*
operator|)
name|inp
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_INT32
case|:
if|if
condition|(
name|ilen
operator|!=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|itype_signed
operator|=
name|true
expr_stmt|;
name|intv
operator|.
name|i64
operator|=
operator|*
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|inp
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_INT64
case|:
if|if
condition|(
name|ilen
operator|!=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|itype_signed
operator|=
name|true
expr_stmt|;
name|intv
operator|.
name|i64
operator|=
operator|*
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|inp
expr_stmt|;
break|break;
default|default:
name|BHND_NV_PANIC
argument_list|(
literal|"invalid type %d\n"
argument_list|,
name|itype
argument_list|)
expr_stmt|;
block|}
comment|/* Perform signed/unsigned conversion */
if|if
condition|(
name|itype_signed
operator|&&
name|otype_int
operator|&&
operator|!
name|otype_signed
condition|)
block|{
if|if
condition|(
name|intv
operator|.
name|i64
operator|<
literal|0
condition|)
block|{
comment|/* Can't represent negative value */
name|BHND_NV_LOG
argument_list|(
literal|"cannot represent %"
name|PRId64
literal|" as %s\n"
argument_list|,
name|intv
operator|.
name|i64
argument_list|,
name|bhnd_nvram_type_name
argument_list|(
name|otype
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERANGE
operator|)
return|;
block|}
comment|/* Convert to unsigned representation */
name|intv
operator|.
name|u64
operator|=
name|intv
operator|.
name|i64
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|itype_signed
operator|&&
name|otype_int
operator|&&
name|otype_signed
condition|)
block|{
comment|/* Handle unsigned -> signed coercions */
if|if
condition|(
name|intv
operator|.
name|u64
operator|>
name|INT64_MAX
condition|)
block|{
comment|/* Can't represent positive value */
name|BHND_NV_LOG
argument_list|(
literal|"cannot represent %"
name|PRIu64
literal|" as %s\n"
argument_list|,
name|intv
operator|.
name|u64
argument_list|,
name|bhnd_nvram_type_name
argument_list|(
name|otype
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERANGE
operator|)
return|;
block|}
comment|/* Convert to signed representation */
name|intv
operator|.
name|i64
operator|=
name|intv
operator|.
name|u64
expr_stmt|;
block|}
comment|/* Write output */
switch|switch
condition|(
name|otype
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_CHAR
case|:
case|case
name|BHND_NVRAM_TYPE_CHAR_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_UINT8
case|:
case|case
name|BHND_NVRAM_TYPE_UINT8_ARRAY
case|:
if|if
condition|(
name|intv
operator|.
name|u64
operator|>
name|UINT8_MAX
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
name|nbytes
operator|=
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|>=
name|nbytes
condition|)
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|outp
operator|)
operator|=
operator|(
name|uint8_t
operator|)
name|intv
operator|.
name|u64
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT16
case|:
case|case
name|BHND_NVRAM_TYPE_UINT16_ARRAY
case|:
if|if
condition|(
name|intv
operator|.
name|u64
operator|>
name|UINT16_MAX
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
name|nbytes
operator|=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|>=
name|nbytes
condition|)
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|outp
operator|)
operator|=
operator|(
name|uint16_t
operator|)
name|intv
operator|.
name|u64
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT32
case|:
case|case
name|BHND_NVRAM_TYPE_UINT32_ARRAY
case|:
if|if
condition|(
name|intv
operator|.
name|u64
operator|>
name|UINT32_MAX
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
name|nbytes
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|>=
name|nbytes
condition|)
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|outp
operator|)
operator|=
operator|(
name|uint32_t
operator|)
name|intv
operator|.
name|u64
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT64
case|:
case|case
name|BHND_NVRAM_TYPE_UINT64_ARRAY
case|:
name|nbytes
operator|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|>=
name|nbytes
condition|)
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|outp
operator|)
operator|=
name|intv
operator|.
name|u64
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_INT8
case|:
case|case
name|BHND_NVRAM_TYPE_INT8_ARRAY
case|:
if|if
condition|(
name|intv
operator|.
name|i64
operator|<
name|INT8_MIN
operator|||
name|intv
operator|.
name|i64
operator|>
name|INT8_MAX
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
name|nbytes
operator|=
sizeof|sizeof
argument_list|(
name|int8_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|>=
name|nbytes
condition|)
operator|*
operator|(
operator|(
name|int8_t
operator|*
operator|)
name|outp
operator|)
operator|=
operator|(
name|int8_t
operator|)
name|intv
operator|.
name|i64
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_INT16
case|:
case|case
name|BHND_NVRAM_TYPE_INT16_ARRAY
case|:
if|if
condition|(
name|intv
operator|.
name|i64
operator|<
name|INT16_MIN
operator|||
name|intv
operator|.
name|i64
operator|>
name|INT16_MAX
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
name|nbytes
operator|=
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|>=
name|nbytes
condition|)
operator|*
operator|(
operator|(
name|int16_t
operator|*
operator|)
name|outp
operator|)
operator|=
operator|(
name|int16_t
operator|)
name|intv
operator|.
name|i64
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_INT32
case|:
case|case
name|BHND_NVRAM_TYPE_INT32_ARRAY
case|:
if|if
condition|(
name|intv
operator|.
name|i64
operator|<
name|INT32_MIN
operator|||
name|intv
operator|.
name|i64
operator|>
name|INT32_MAX
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
name|nbytes
operator|=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|>=
name|nbytes
condition|)
operator|*
operator|(
operator|(
name|int32_t
operator|*
operator|)
name|outp
operator|)
operator|=
operator|(
name|int32_t
operator|)
name|intv
operator|.
name|i64
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_INT64
case|:
case|case
name|BHND_NVRAM_TYPE_INT64_ARRAY
case|:
name|nbytes
operator|=
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|>=
name|nbytes
condition|)
operator|*
operator|(
operator|(
name|int64_t
operator|*
operator|)
name|outp
operator|)
operator|=
name|intv
operator|.
name|i64
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_STRING
case|:
case|case
name|BHND_NVRAM_TYPE_STRING_ARRAY
case|:
block|{
name|ssize_t
name|len
decl_stmt|;
comment|/* Attempt to write the entry + NUL */
if|if
condition|(
name|otype_signed
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|outp
argument_list|,
name|limit
argument_list|,
literal|"%"
name|PRId64
argument_list|,
name|intv
operator|.
name|i64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|outp
argument_list|,
name|limit
argument_list|,
literal|"%"
name|PRIu64
argument_list|,
name|intv
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"snprintf() failed: %zd\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
comment|/* Set total length to the formatted string length, plus 		 * trailing NUL */
name|nbytes
operator|=
name|len
operator|+
literal|1
expr_stmt|;
break|break;
block|}
default|default:
name|BHND_NV_LOG
argument_list|(
literal|"unknown type %s\n"
argument_list|,
name|bhnd_nvram_type_name
argument_list|(
name|otype
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
comment|/* Provide required length */
operator|*
name|olen
operator|=
name|nbytes
expr_stmt|;
if|if
condition|(
name|limit
operator|<
operator|*
name|olen
condition|)
block|{
if|if
condition|(
name|outp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Encode the given @p value as @p otype, writing the result to @p outp.  *  * @param		value	The value to be encoded.  * @param[out]		outp	On success, the value will be written to this   *				buffer. This argment may be NULL if the value is  *				not desired.  * @param[in,out]	olen	The capacity of @p outp. On success, will be set  *				to the actual size of the requested value.  * @param		otype	The data type to be written to @p outp.  *  * @retval 0		success  * @retval ENOMEM	If the @p outp is non-NULL, and the provided @p olen  *			is too small to hold the encoded value.  * @retval EFTYPE	If value coercion from @p value to @p otype is  *			impossible.  * @retval ERANGE	If value coercion would overflow (or underflow) the  *			a @p otype representation.  */
end_comment

begin_function
name|int
name|bhnd_nvram_val_encode
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
block|{
comment|/* Prefer format implementation */
if|if
condition|(
name|value
operator|->
name|fmt
operator|!=
name|NULL
operator|&&
name|value
operator|->
name|fmt
operator|->
name|op_encode
operator|!=
name|NULL
condition|)
return|return
operator|(
name|value
operator|->
name|fmt
operator|->
name|op_encode
argument_list|(
name|value
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|)
operator|)
return|;
return|return
operator|(
name|bhnd_nvram_val_generic_encode
argument_list|(
name|value
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Encode the given @p value's element as @p otype, writing the result to  * @p outp.  *  * @param		inp	The element to be be encoded. Must be a value  *				previously returned by bhnd_nvram_val_next()  *				or bhnd_nvram_val_elem().  * @param		ilen	The size of @p inp, as returned by  *				bhnd_nvram_val_next() or bhnd_nvram_val_elem().  * @param[out]		outp	On success, the value will be written to this   *				buffer. This argment may be NULL if the value is  *				not desired.  * @param[in,out]	olen	The capacity of @p outp. On success, will be set  *				to the actual size of the requested value.  * @param		otype	The data type to be written to @p outp.  *  * @retval 0		success  * @retval ENOMEM	If the @p outp is non-NULL, and the provided @p olen  *			is too small to hold the encoded value.  * @retval EFTYPE	If value coercion from @p value to @p otype is  *			impossible.  * @retval ERANGE	If value coercion would overflow (or underflow) the  *			a @p otype representation.  */
end_comment

begin_function
name|int
name|bhnd_nvram_val_encode_elem
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
block|{
comment|/* Prefer format implementation */
if|if
condition|(
name|value
operator|->
name|fmt
operator|!=
name|NULL
operator|&&
name|value
operator|->
name|fmt
operator|->
name|op_encode_elem
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|value
operator|->
name|fmt
operator|->
name|op_encode_elem
argument_list|(
name|value
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|bhnd_nvram_val_generic_encode_elem
argument_list|(
name|value
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the type, size, and a pointer to the internal representation  * of @p value.  *   * @param	value	The value to be queried.  * @param[out]	olen	Size of the returned data, in bytes.  * @param[out]	otype	Data type.  */
end_comment

begin_function
specifier|const
name|void
modifier|*
name|bhnd_nvram_val_bytes
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
modifier|*
name|otype
parameter_list|)
block|{
comment|/* Provide type and length */
operator|*
name|otype
operator|=
name|value
operator|->
name|data_type
expr_stmt|;
operator|*
name|olen
operator|=
name|value
operator|->
name|data_len
expr_stmt|;
switch|switch
condition|(
name|value
operator|->
name|data_storage
condition|)
block|{
case|case
name|BHND_NVRAM_VAL_DATA_EXT_ALLOC
case|:
case|case
name|BHND_NVRAM_VAL_DATA_EXT_STATIC
case|:
case|case
name|BHND_NVRAM_VAL_DATA_EXT_WEAK
case|:
comment|/* Return a pointer to external storage */
return|return
operator|(
name|value
operator|->
name|data
operator|.
name|ptr
operator|)
return|;
case|case
name|BHND_NVRAM_VAL_DATA_INLINE
case|:
comment|/* Return a pointer to inline storage */
return|return
operator|(
operator|&
name|value
operator|->
name|data
operator|)
return|;
case|case
name|BHND_NVRAM_VAL_DATA_NONE
case|:
name|BHND_NV_PANIC
argument_list|(
literal|"uninitialized value"
argument_list|)
expr_stmt|;
block|}
name|BHND_NV_PANIC
argument_list|(
literal|"unknown storage type: %d"
argument_list|,
name|value
operator|->
name|data_storage
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Iterate over all array elements in @p value.  *  * @param		value	The value to be iterated  * @param		prev	A value pointer previously returned by  *				bhnd_nvram_val_next() or bhnd_nvram_val_elem(),  *				or NULL to begin iteration at the first element.  * @param[in,out]	len	If prev is non-NULL, len must be a pointer  *				to the length previously returned by  *				bhnd_nvram_val_next() or bhnd_nvram_val_elem().  *				On success, will be set to the next element's  *				length, in bytes.  *  * @retval non-NULL	A borrowed reference to the element data.  * @retval NULL		If the end of the element array is reached.  */
end_comment

begin_function
specifier|const
name|void
modifier|*
name|bhnd_nvram_val_next
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
specifier|const
name|void
modifier|*
name|prev
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
comment|/* Prefer the format implementation */
if|if
condition|(
name|value
operator|->
name|fmt
operator|!=
name|NULL
operator|&&
name|value
operator|->
name|fmt
operator|->
name|op_next
operator|!=
name|NULL
condition|)
return|return
operator|(
name|value
operator|->
name|fmt
operator|->
name|op_next
argument_list|(
name|value
argument_list|,
name|prev
argument_list|,
name|len
argument_list|)
operator|)
return|;
return|return
operator|(
name|bhnd_nvram_val_generic_next
argument_list|(
name|value
argument_list|,
name|prev
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return value's element data type.  *  * @param	value	The value to be queried.  */
end_comment

begin_function
name|bhnd_nvram_type
name|bhnd_nvram_val_elem_type
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_base_type
argument_list|(
name|value
operator|->
name|data_type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the total number of elements represented by @p value.  */
end_comment

begin_function
name|size_t
name|bhnd_nvram_val_nelem
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|bytes
decl_stmt|;
name|bhnd_nvram_type
name|type
decl_stmt|;
name|size_t
name|nelem
decl_stmt|,
name|len
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Prefer format implementation */
if|if
condition|(
name|value
operator|->
name|fmt
operator|!=
name|NULL
operator|&&
name|value
operator|->
name|fmt
operator|->
name|op_nelem
operator|!=
name|NULL
condition|)
return|return
operator|(
name|value
operator|->
name|fmt
operator|->
name|op_nelem
argument_list|(
name|value
argument_list|)
operator|)
return|;
comment|/* 	 * If a custom op_next() is defined, bhnd_nvram_value_nelem() almost 	 * certainly cannot produce a valid element count; it assumes a standard 	 * data format that may not apply when custom iteration is required. 	 * 	 * Instead, use bhnd_nvram_val_next() to parse the backing data and 	 * produce a total count. 	 */
if|if
condition|(
name|value
operator|->
name|fmt
operator|!=
name|NULL
operator|&&
name|value
operator|->
name|fmt
operator|->
name|op_next
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|void
modifier|*
name|next
decl_stmt|;
name|next
operator|=
name|NULL
expr_stmt|;
name|nelem
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
name|bhnd_nvram_val_next
argument_list|(
name|value
argument_list|,
name|next
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|nelem
operator|++
expr_stmt|;
return|return
operator|(
name|nelem
operator|)
return|;
block|}
comment|/* Otherwise, compute the standard element count */
name|bytes
operator|=
name|bhnd_nvram_val_bytes
argument_list|(
name|value
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_value_nelem
argument_list|(
name|type
argument_list|,
name|bytes
argument_list|,
name|len
argument_list|,
operator|&
name|nelem
argument_list|)
operator|)
condition|)
block|{
comment|/* Should always succeed */
name|BHND_NV_PANIC
argument_list|(
literal|"error calculating element count for type '%s' "
literal|"with length %zu: %d\n"
argument_list|,
name|bhnd_nvram_type_name
argument_list|(
name|type
argument_list|)
argument_list|,
name|len
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nelem
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Generic implementation of bhnd_nvram_val_op_encode(), compatible with  * all supported NVRAM data types.  */
end_comment

begin_function
name|int
name|bhnd_nvram_val_generic_encode
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|inp
decl_stmt|;
name|bhnd_nvram_type
name|itype
decl_stmt|;
name|size_t
name|ilen
decl_stmt|;
specifier|const
name|void
modifier|*
name|next
decl_stmt|;
name|bhnd_nvram_type
name|otype_base
decl_stmt|;
name|size_t
name|limit
decl_stmt|,
name|nelem
decl_stmt|,
name|nbytes
decl_stmt|;
name|size_t
name|next_len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nbytes
operator|=
literal|0
expr_stmt|;
name|nelem
operator|=
literal|0
expr_stmt|;
name|otype_base
operator|=
name|bhnd_nvram_base_type
argument_list|(
name|otype
argument_list|)
expr_stmt|;
comment|/* 	 * Normally, a rank polymorphic type like a character array would not 	 * be representable as a rank 1 type. 	 *  	 * As a special-cased exception, we can support conversion directly 	 * from CHAR_ARRAY to STRING by treating the character array as a 	 * non-NUL-terminated string. 	 *  	 * This conversion is isomorphic; we also support conversion directly 	 * from a STRING to a CHAR_ARRAY by the same mechanism. 	 */
name|inp
operator|=
name|bhnd_nvram_val_bytes
argument_list|(
name|value
argument_list|,
operator|&
name|ilen
argument_list|,
operator|&
name|itype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|itype
operator|==
name|BHND_NVRAM_TYPE_CHAR_ARRAY
operator|&&
name|otype
operator|==
name|BHND_NVRAM_TYPE_STRING
operator|)
operator|||
operator|(
name|itype
operator|==
name|BHND_NVRAM_TYPE_STRING
operator|&&
name|otype
operator|==
name|BHND_NVRAM_TYPE_CHAR_ARRAY
operator|)
condition|)
block|{
return|return
operator|(
name|bhnd_nvram_val_encode_elem
argument_list|(
name|value
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * If both input and output are non-array types, try to encode them 	 * without performing element iteration. 	 */
if|if
condition|(
operator|!
name|bhnd_nvram_is_array_type
argument_list|(
name|itype
argument_list|)
operator|&&
operator|!
name|bhnd_nvram_is_array_type
argument_list|(
name|otype
argument_list|)
condition|)
block|{
return|return
operator|(
name|bhnd_nvram_val_encode_elem
argument_list|(
name|value
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|)
operator|)
return|;
block|}
comment|/* Determine output byte limit */
if|if
condition|(
name|outp
operator|!=
name|NULL
condition|)
name|limit
operator|=
operator|*
name|olen
expr_stmt|;
else|else
name|limit
operator|=
literal|0
expr_stmt|;
comment|/* Iterate over our array elements and encode as the requested 	 * type */
name|next
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
name|bhnd_nvram_val_next
argument_list|(
name|value
argument_list|,
name|next
argument_list|,
operator|&
name|next_len
argument_list|)
operator|)
condition|)
block|{
name|void
modifier|*
name|elem_outp
decl_stmt|;
name|size_t
name|elem_nbytes
decl_stmt|;
comment|/* If the output type is not an array type, we can only encode 		 * one element */
name|nelem
operator|++
expr_stmt|;
if|if
condition|(
name|nelem
operator|>
literal|1
operator|&&
operator|!
name|bhnd_nvram_is_array_type
argument_list|(
name|otype
argument_list|)
condition|)
block|{
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
comment|/* Determine output offset / limit */
if|if
condition|(
name|nbytes
operator|>=
name|limit
condition|)
block|{
name|elem_nbytes
operator|=
literal|0
expr_stmt|;
name|elem_outp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|elem_nbytes
operator|=
name|limit
operator|-
name|nbytes
expr_stmt|;
name|elem_outp
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|outp
operator|+
name|nbytes
expr_stmt|;
block|}
comment|/* Attempt encode */
name|error
operator|=
name|bhnd_nvram_val_encode_elem
argument_list|(
name|value
argument_list|,
name|next
argument_list|,
name|next_len
argument_list|,
name|elem_outp
argument_list|,
operator|&
name|elem_nbytes
argument_list|,
name|otype_base
argument_list|)
expr_stmt|;
comment|/* If encoding failed for any reason other than ENOMEM (which 		 * we'll detect and report below), return immediately */
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOMEM
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Add to total length */
if|if
condition|(
name|SIZE_MAX
operator|-
name|nbytes
operator|<
name|elem_nbytes
condition|)
return|return
operator|(
name|EFTYPE
operator|)
return|;
comment|/* would overflow size_t */
name|nbytes
operator|+=
name|elem_nbytes
expr_stmt|;
block|}
comment|/* Provide the actual length */
operator|*
name|olen
operator|=
name|nbytes
expr_stmt|;
comment|/* If no output was requested, nothing left to do */
if|if
condition|(
name|outp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Otherwise, report a memory error if the output buffer was too 	 * small */
if|if
condition|(
name|limit
operator|<
name|nbytes
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Generic implementation of bhnd_nvram_val_op_encode_elem(), compatible with  * all supported NVRAM data types.  */
end_comment

begin_function
name|int
name|bhnd_nvram_val_generic_encode_elem
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
block|{
name|bhnd_nvram_type
name|itype
decl_stmt|;
name|itype
operator|=
name|bhnd_nvram_val_elem_type
argument_list|(
name|value
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|itype
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_STRING
case|:
case|case
name|BHND_NVRAM_TYPE_CHAR
case|:
case|case
name|BHND_NVRAM_TYPE_CHAR_ARRAY
case|:
return|return
operator|(
name|bhnd_nvram_val_encode_string
argument_list|(
name|outp
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|)
operator|)
return|;
case|case
name|BHND_NVRAM_TYPE_UINT8
case|:
case|case
name|BHND_NVRAM_TYPE_UINT16
case|:
case|case
name|BHND_NVRAM_TYPE_UINT32
case|:
case|case
name|BHND_NVRAM_TYPE_UINT64
case|:
case|case
name|BHND_NVRAM_TYPE_INT8
case|:
case|case
name|BHND_NVRAM_TYPE_INT16
case|:
case|case
name|BHND_NVRAM_TYPE_INT32
case|:
case|case
name|BHND_NVRAM_TYPE_INT64
case|:
return|return
operator|(
name|bhnd_nvram_val_encode_int
argument_list|(
name|outp
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|)
operator|)
return|;
default|default:
name|BHND_NV_PANIC
argument_list|(
literal|"missing encode_elem() implementation"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Generic implementation of bhnd_nvram_val_op_next(), compatible with  * all supported NVRAM data types.  */
end_comment

begin_function
specifier|const
name|void
modifier|*
name|bhnd_nvram_val_generic_next
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
specifier|const
name|void
modifier|*
name|prev
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|inp
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|next
decl_stmt|;
name|bhnd_nvram_type
name|itype
decl_stmt|;
name|size_t
name|ilen
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
comment|/* Otherwise, default to iterating over the backing representation 	 * according to its native representation */
name|inp
operator|=
name|bhnd_nvram_val_bytes
argument_list|(
name|value
argument_list|,
operator|&
name|ilen
argument_list|,
operator|&
name|itype
argument_list|)
expr_stmt|;
comment|/* First element */
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
comment|/* Zero-length array? */
if|if
condition|(
name|ilen
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|len
operator|=
name|bhnd_nvram_value_size
argument_list|(
name|itype
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|inp
operator|)
return|;
block|}
comment|/* Advance to next element */
name|BHND_NV_ASSERT
argument_list|(
name|prev
operator|>=
operator|(
specifier|const
name|void
operator|*
operator|)
name|inp
argument_list|,
operator|(
literal|"invalid cookiep"
operator|)
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|prev
operator|+
operator|*
name|len
expr_stmt|;
name|offset
operator|=
call|(
name|size_t
call|)
argument_list|(
name|next
operator|-
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|ilen
condition|)
block|{
comment|/* Hit end of the array */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Determine element size */
operator|*
name|len
operator|=
name|bhnd_nvram_value_size
argument_list|(
name|itype
argument_list|,
name|next
argument_list|,
name|ilen
operator|-
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ilen
operator|-
name|offset
operator|<
operator|*
name|len
condition|)
name|BHND_NV_PANIC
argument_list|(
literal|"short element -- misaligned representation"
argument_list|)
expr_stmt|;
return|return
operator|(
name|next
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize the representation of @p value with @p ptr.  *   * If @p value is an externally allocated instance and the representation  * cannot be represented inline, the given data will not be copied, and @p ptr  * must remain valid for the lifetime of @p value.  *  * Otherwise, @p value will be initialized with a copy of the @p ptr.  *   * @param	value	The value to be initialized.  * @param	inp	The external representation.  * @param	ilen	The external representation length, in bytes.  * @param	itype	The external representation's data type.  * @param	flags	Value flags.  *   * @retval 0		success.  * @retval ENOMEM	if allocation fails  * @retval EFTYPE	if @p itype is not an array type, and @p ilen is not  *			equal to the size of a single element of @p itype.  * @retval EFAULT	if @p ilen is not correctly aligned for elements of  *			@p itype.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_val_set
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|void
modifier|*
name|bytes
decl_stmt|;
name|BHND_NVRAM_VAL_ASSERT_EMPTY
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Reference the external data */
if|if
condition|(
operator|(
name|flags
operator|&
name|BHND_NVRAM_VAL_BORROW_DATA
operator|)
operator|||
operator|(
name|flags
operator|&
name|BHND_NVRAM_VAL_STATIC_DATA
operator|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|BHND_NVRAM_VAL_BORROW_DATA
condition|)
name|value
operator|->
name|data_storage
operator|=
name|BHND_NVRAM_VAL_DATA_EXT_WEAK
expr_stmt|;
else|else
name|value
operator|->
name|data_storage
operator|=
name|BHND_NVRAM_VAL_DATA_EXT_STATIC
expr_stmt|;
name|value
operator|->
name|data
operator|.
name|ptr
operator|=
name|inp
expr_stmt|;
name|value
operator|->
name|data_type
operator|=
name|itype
expr_stmt|;
name|value
operator|->
name|data_len
operator|=
name|ilen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Fetch reference to (or allocate) an appropriately sized buffer */
name|bytes
operator|=
name|bhnd_nvram_val_alloc_bytes
argument_list|(
name|value
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Copy data */
name|memcpy
argument_list|(
name|bytes
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize the internal inline representation of @p value with a copy of  * the data referenced by @p inp of @p itype.  *   * If @p inp is NULL, @p itype and @p ilen will be validated, but no data will  * be copied.  *  * @param	value	The value to be initialized.  * @param	inp	The input data to be copied, or NULL to verify  *			that data of @p ilen and @p itype can be represented  *			inline.  * @param	ilen	The size of the external buffer to be allocated.  * @param	itype	The type of the external buffer to be allocated.  *   * @retval 0		success  * @retval ENOMEM	if @p ilen is too large to be represented inline.  * @retval EFAULT	if @p ilen is not correctly aligned for elements of  *			@p itype.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_val_set_inline
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|)
block|{
name|BHND_NVRAM_VAL_ASSERT_EMPTY
argument_list|(
name|value
argument_list|)
expr_stmt|;
define|#
directive|define
name|NV_STORE_INIT_INLINE
parameter_list|()
value|do {					\ 	value->data_len = ilen;						\ } while(0)
define|#
directive|define
name|NV_STORE_INLINE
parameter_list|(
name|_type
parameter_list|,
name|_dest
parameter_list|)
value|do {				\ 	if (ilen != sizeof(_type))					\ 		return (EFAULT);					\ 									\ 	if (inp != NULL) {						\ 		value->data._dest[0] = *(const _type *)inp;		\ 		NV_STORE_INIT_INLINE();					\ 	}								\ } while (0)
define|#
directive|define
name|NV_COPY_ARRRAY_INLINE
parameter_list|(
name|_type
parameter_list|,
name|_dest
parameter_list|)
value|do {		\ 	if (ilen % sizeof(_type) != 0)				\ 		return (EFAULT);				\ 								\ 	if (ilen> nitems(value->data. _dest))			\ 		return (ENOMEM);				\ 								\ 	if (inp == NULL)					\ 		return (0);					\ 								\ 	memcpy(&value->data._dest, inp, ilen);			\ 	if (inp != NULL) {					\ 		memcpy(&value->data._dest, inp, ilen);		\ 		NV_STORE_INIT_INLINE();				\ 	}							\ } while (0)
comment|/* Attempt to copy to inline storage */
switch|switch
condition|(
name|itype
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_CHAR
case|:
name|NV_STORE_INLINE
argument_list|(
name|uint8_t
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|BHND_NVRAM_TYPE_UINT8
case|:
case|case
name|BHND_NVRAM_TYPE_INT8
case|:
name|NV_STORE_INLINE
argument_list|(
name|uint8_t
argument_list|,
name|u8
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|BHND_NVRAM_TYPE_UINT16
case|:
case|case
name|BHND_NVRAM_TYPE_INT16
case|:
name|NV_STORE_INLINE
argument_list|(
name|uint16_t
argument_list|,
name|u16
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|BHND_NVRAM_TYPE_UINT32
case|:
case|case
name|BHND_NVRAM_TYPE_INT32
case|:
name|NV_STORE_INLINE
argument_list|(
name|uint32_t
argument_list|,
name|u32
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|BHND_NVRAM_TYPE_UINT64
case|:
case|case
name|BHND_NVRAM_TYPE_INT64
case|:
name|NV_STORE_INLINE
argument_list|(
name|uint32_t
argument_list|,
name|u32
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|BHND_NVRAM_TYPE_CHAR_ARRAY
case|:
name|NV_COPY_ARRRAY_INLINE
argument_list|(
name|uint8_t
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|BHND_NVRAM_TYPE_UINT8_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_INT8_ARRAY
case|:
name|NV_COPY_ARRRAY_INLINE
argument_list|(
name|uint8_t
argument_list|,
name|u8
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|BHND_NVRAM_TYPE_UINT16_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_INT16_ARRAY
case|:
name|NV_COPY_ARRRAY_INLINE
argument_list|(
name|uint16_t
argument_list|,
name|u16
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|BHND_NVRAM_TYPE_UINT32_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_INT32_ARRAY
case|:
name|NV_COPY_ARRRAY_INLINE
argument_list|(
name|uint32_t
argument_list|,
name|u32
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|BHND_NVRAM_TYPE_UINT64_ARRAY
case|:
case|case
name|BHND_NVRAM_TYPE_INT64_ARRAY
case|:
name|NV_COPY_ARRRAY_INLINE
argument_list|(
name|uint64_t
argument_list|,
name|u64
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|BHND_NVRAM_TYPE_STRING
case|:
case|case
name|BHND_NVRAM_TYPE_STRING_ARRAY
case|:
if|if
condition|(
name|ilen
operator|>
sizeof|sizeof
argument_list|(
name|value
operator|->
name|data
operator|.
name|ch
argument_list|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|inp
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|value
operator|->
name|data
operator|.
name|ch
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
name|NV_STORE_INIT_INLINE
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
undef|#
directive|undef
name|NV_STORE_INIT_INLINE
undef|#
directive|undef
name|NV_STORE_INLINE
undef|#
directive|undef
name|NV_COPY_ARRRAY_INLINE
name|BHND_NV_PANIC
argument_list|(
literal|"unknown data type %d"
argument_list|,
name|itype
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Initialize the internal representation of @p value with a buffer allocation  * of @p len and @p itype, returning a pointer to the allocated buffer.  *   * If a buffer of @p len and @p itype can be represented inline, no  * external buffer will be allocated, and instead a pointer to the inline  * data representation will be returned.  *  * @param	value	The value to be initialized.  * @param	ilen	The size of the external buffer to be allocated.  * @param	itype	The type of the external buffer to be allocated.  * @param	flags	Value flags.  *   * @retval non-null	The newly allocated buffer.  * @retval NULL		If allocation failed.  * @retval NULL		If @p value is an externally allocated instance.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|bhnd_nvram_val_alloc_bytes
parameter_list|(
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|BHND_NVRAM_VAL_ASSERT_EMPTY
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Can we use inline storage? */
if|if
condition|(
name|bhnd_nvram_val_set_inline
argument_list|(
name|value
argument_list|,
name|NULL
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|)
operator|==
literal|0
condition|)
block|{
name|BHND_NV_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|value
operator|->
name|data
argument_list|)
operator|>=
name|ilen
argument_list|,
operator|(
literal|"ilen exceeds inline storage"
operator|)
argument_list|)
expr_stmt|;
name|value
operator|->
name|data_type
operator|=
name|itype
expr_stmt|;
name|value
operator|->
name|data_len
operator|=
name|ilen
expr_stmt|;
name|value
operator|->
name|data_storage
operator|=
name|BHND_NVRAM_VAL_DATA_INLINE
expr_stmt|;
return|return
operator|(
operator|&
name|value
operator|->
name|data
operator|)
return|;
block|}
comment|/* Is allocation permitted? */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|BHND_NVRAM_VAL_DYNAMIC
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Allocate external storage */
if|if
condition|(
operator|(
name|ptr
operator|=
name|bhnd_nv_malloc
argument_list|(
name|ilen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|value
operator|->
name|data
operator|.
name|ptr
operator|=
name|ptr
expr_stmt|;
name|value
operator|->
name|data_len
operator|=
name|ilen
expr_stmt|;
name|value
operator|->
name|data_type
operator|=
name|itype
expr_stmt|;
name|value
operator|->
name|data_storage
operator|=
name|BHND_NVRAM_VAL_DATA_EXT_ALLOC
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

end_unit

