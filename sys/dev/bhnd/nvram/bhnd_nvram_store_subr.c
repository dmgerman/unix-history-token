begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Landon Fuller<landonf@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/hash.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/_inttypes.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_KERNEL */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_include
include|#
directive|include
file|"bhnd_nvram_private.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_datavar.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_storevar.h"
end_include

begin_function_decl
specifier|static
name|int
name|bhnd_nvstore_idx_cmp
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Allocate and initialize a new path instance.  *   * The caller is responsible for deallocating the instance via  * bhnd_nvstore_path_free().  *   * @param	path_str	The path's canonical string representation.  * @param	path_len	The length of @p path_str.  *   * @retval non-NULL	success  * @retval NULL		if allocation fails.  */
end_comment

begin_function
name|bhnd_nvstore_path
modifier|*
name|bhnd_nvstore_path_new
parameter_list|(
specifier|const
name|char
modifier|*
name|path_str
parameter_list|,
name|size_t
name|path_len
parameter_list|)
block|{
name|bhnd_nvstore_path
modifier|*
name|path
decl_stmt|;
comment|/* Allocate new entry */
name|path
operator|=
name|bhnd_nv_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|path
operator|->
name|index
operator|=
name|NULL
expr_stmt|;
name|path
operator|->
name|num_vars
operator|=
literal|0
expr_stmt|;
name|path
operator|->
name|pending
operator|=
name|bhnd_nvram_plist_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|pending
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|path
operator|->
name|path_str
operator|=
name|bhnd_nv_strndup
argument_list|(
name|path_str
argument_list|,
name|path_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|path_str
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
name|path
operator|)
return|;
name|failed
label|:
if|if
condition|(
name|path
operator|->
name|pending
operator|!=
name|NULL
condition|)
name|bhnd_nvram_plist_release
argument_list|(
name|path
operator|->
name|pending
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|path_str
operator|!=
name|NULL
condition|)
name|bhnd_nv_free
argument_list|(
name|path
operator|->
name|path_str
argument_list|)
expr_stmt|;
name|bhnd_nv_free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Free an NVRAM path instance, releasing all associated resources.  */
end_comment

begin_function
name|void
name|bhnd_nvstore_path_free
parameter_list|(
name|struct
name|bhnd_nvstore_path
modifier|*
name|path
parameter_list|)
block|{
comment|/* Free the per-path index */
if|if
condition|(
name|path
operator|->
name|index
operator|!=
name|NULL
condition|)
name|bhnd_nvstore_index_free
argument_list|(
name|path
operator|->
name|index
argument_list|)
expr_stmt|;
name|bhnd_nvram_plist_release
argument_list|(
name|path
operator|->
name|pending
argument_list|)
expr_stmt|;
name|bhnd_nv_free
argument_list|(
name|path
operator|->
name|path_str
argument_list|)
expr_stmt|;
name|bhnd_nv_free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Allocate and initialize a new index instance with @p capacity.  *   * The caller is responsible for deallocating the instance via  * bhnd_nvstore_index_free().  *   * @param	capacity	The maximum number of variables to be indexed.  *   * @retval non-NULL	success  * @retval NULL		if allocation fails.  */
end_comment

begin_function
name|bhnd_nvstore_index
modifier|*
name|bhnd_nvstore_index_new
parameter_list|(
name|size_t
name|capacity
parameter_list|)
block|{
name|bhnd_nvstore_index
modifier|*
name|index
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
comment|/* Allocate and populate variable index */
name|bytes
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|bhnd_nvstore_index
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|capacity
operator|)
expr_stmt|;
name|index
operator|=
name|bhnd_nv_malloc
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|NULL
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error allocating %zu byte index\n"
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|index
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|index
operator|->
name|capacity
operator|=
name|capacity
expr_stmt|;
return|return
operator|(
name|index
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Free an index instance, releasing all associated resources.  *   * @param	index	An index instance previously allocated via  *			bhnd_nvstore_index_new().  */
end_comment

begin_function
name|void
name|bhnd_nvstore_index_free
parameter_list|(
name|bhnd_nvstore_index
modifier|*
name|index
parameter_list|)
block|{
name|bhnd_nv_free
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Append a new NVRAM variable's @p cookiep value to @p index.  *   * After one or more append requests, the index must be prepared via  * bhnd_nvstore_index_prepare() before any indexed lookups are performed.  *  * @param	sc	The NVRAM store from which NVRAM values will be queried.  * @param	index	The index to be modified.  * @param	cookiep	The cookiep value (as provided by the backing NVRAM  *			data instance of @p sc) to be included in @p index.  *   * @retval 0		success  * @retval ENOMEM	if appending an additional entry would exceed the  *			capacity of @p index.  */
end_comment

begin_function
name|int
name|bhnd_nvstore_index_append
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|,
name|bhnd_nvstore_index
modifier|*
name|index
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|)
block|{
name|BHND_NVSTORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|->
name|count
operator|>=
name|index
operator|->
name|capacity
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|index
operator|->
name|cookiep
index|[
name|index
operator|->
name|count
index|]
operator|=
name|cookiep
expr_stmt|;
name|index
operator|->
name|count
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* sort function for bhnd_nvstore_index_prepare() */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvstore_idx_cmp
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
decl_stmt|;
name|void
modifier|*
name|l_cookiep
decl_stmt|,
modifier|*
name|r_cookiep
decl_stmt|;
specifier|const
name|char
modifier|*
name|l_str
decl_stmt|,
modifier|*
name|r_str
decl_stmt|;
specifier|const
name|char
modifier|*
name|l_name
decl_stmt|,
modifier|*
name|r_name
decl_stmt|;
name|int
name|order
decl_stmt|;
name|sc
operator|=
name|ctx
expr_stmt|;
name|l_cookiep
operator|=
operator|*
operator|(
name|void
operator|*
specifier|const
operator|*
operator|)
name|lhs
expr_stmt|;
name|r_cookiep
operator|=
operator|*
operator|(
name|void
operator|*
specifier|const
operator|*
operator|)
name|rhs
expr_stmt|;
name|BHND_NVSTORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Fetch string pointers from the cookiep values */
name|l_str
operator|=
name|bhnd_nvram_data_getvar_name
argument_list|(
name|sc
operator|->
name|data
argument_list|,
name|l_cookiep
argument_list|)
expr_stmt|;
name|r_str
operator|=
name|bhnd_nvram_data_getvar_name
argument_list|(
name|sc
operator|->
name|data
argument_list|,
name|r_cookiep
argument_list|)
expr_stmt|;
comment|/* Trim device path prefixes */
if|if
condition|(
name|sc
operator|->
name|data_caps
operator|&
name|BHND_NVRAM_DATA_CAP_DEVPATHS
condition|)
block|{
name|l_name
operator|=
name|bhnd_nvram_trim_path_name
argument_list|(
name|l_str
argument_list|)
expr_stmt|;
name|r_name
operator|=
name|bhnd_nvram_trim_path_name
argument_list|(
name|r_str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l_name
operator|=
name|l_str
expr_stmt|;
name|r_name
operator|=
name|r_str
expr_stmt|;
block|}
comment|/* Perform comparison */
name|order
operator|=
name|strcmp
argument_list|(
name|l_name
argument_list|,
name|r_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|!=
literal|0
operator|||
name|lhs
operator|==
name|rhs
condition|)
return|return
operator|(
name|order
operator|)
return|;
comment|/* If the backing data incorrectly contains variables with duplicate 	 * names, we need a sort order that provides stable behavior. 	 *  	 * Since Broadcom's own code varies wildly on this question, we just 	 * use a simple precedence rule: The first declaration of a variable 	 * takes precedence. */
return|return
operator|(
name|bhnd_nvram_data_getvar_order
argument_list|(
name|sc
operator|->
name|data
argument_list|,
name|l_cookiep
argument_list|,
name|r_cookiep
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Prepare @p index for querying via bhnd_nvstore_index_lookup().  *   * After one or more append requests, the index must be prepared via  * bhnd_nvstore_index_prepare() before any indexed lookups are performed.  *  * @param	sc	The NVRAM store from which NVRAM values will be queried.  * @param	index	The index to be prepared.  *   * @retval 0		success  * @retval non-zero	if preparing @p index otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_nvstore_index_prepare
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|,
name|bhnd_nvstore_index
modifier|*
name|index
parameter_list|)
block|{
name|BHND_NVSTORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Sort the index table */
name|qsort_r
argument_list|(
name|index
operator|->
name|cookiep
argument_list|,
name|index
operator|->
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|index
operator|->
name|cookiep
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|sc
argument_list|,
name|bhnd_nvstore_idx_cmp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return a borrowed reference to the root path node.  *   * @param	sc	The NVRAM store.  */
end_comment

begin_function
name|bhnd_nvstore_path
modifier|*
name|bhnd_nvstore_get_root_path
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|)
block|{
name|BHND_NVSTORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|root_path
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if @p path is the root path node.  *   * @param	sc	The NVRAM store.  * @param	path	The path to query.  */
end_comment

begin_function
name|bool
name|bhnd_nvstore_is_root_path
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|,
name|bhnd_nvstore_path
modifier|*
name|path
parameter_list|)
block|{
name|BHND_NVSTORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|root_path
operator|==
name|path
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the update entry matching @p name in @p path, or NULL if no entry  * found.  *   * @param sc	The NVRAM store.  * @param path	The path to query.  * @param name	The NVRAM variable name to search for in @p path's update list.  *   * @retval non-NULL	success  * @retval NULL		if @p name is not found in @p path.  */
end_comment

begin_function
name|bhnd_nvram_prop
modifier|*
name|bhnd_nvstore_path_get_update
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|,
name|bhnd_nvstore_path
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|BHND_NVSTORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
return|return
operator|(
name|bhnd_nvram_plist_get_prop
argument_list|(
name|path
operator|->
name|pending
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Register or remove an update record for @p name in @p path.  *   * @param sc	The NVRAM store.  * @param path	The path to be modified.  * @param name	The path-relative variable name to be modified.  * @param value	The new value. A value of BHND_NVRAM_TYPE_NULL denotes deletion.  *   * @retval 0		success  * @retval ENOMEM	if allocation fails.  * @retval ENOENT	if @p name is unknown.  * @retval EINVAL	if @p value is NULL, and deletion of @p is not  *			supported.  * @retval EINVAL	if @p value cannot be converted to a supported value  *			type.  */
end_comment

begin_function
name|int
name|bhnd_nvstore_path_register_update
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|,
name|bhnd_nvstore_path
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|)
block|{
name|bhnd_nvram_val
modifier|*
name|prop_val
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_name
decl_stmt|;
name|void
modifier|*
name|cookiep
decl_stmt|;
name|char
modifier|*
name|namebuf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bool
name|nvram_committed
decl_stmt|;
name|namebuf
operator|=
name|NULL
expr_stmt|;
name|prop_val
operator|=
name|NULL
expr_stmt|;
comment|/* Determine whether the variable is currently defined in the 	 * backing NVRAM data, and derive its full path-prefixed name */
name|nvram_committed
operator|=
name|false
expr_stmt|;
name|cookiep
operator|=
name|bhnd_nvstore_index_lookup
argument_list|(
name|sc
argument_list|,
name|path
operator|->
name|index
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookiep
operator|!=
name|NULL
condition|)
block|{
comment|/* Variable is defined in the backing data */
name|nvram_committed
operator|=
name|true
expr_stmt|;
comment|/* Use the existing variable name */
name|full_name
operator|=
name|bhnd_nvram_data_getvar_name
argument_list|(
name|sc
operator|->
name|data
argument_list|,
name|cookiep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|path
operator|==
name|sc
operator|->
name|root_path
condition|)
block|{
comment|/* No prefix required for root path */
name|full_name
operator|=
name|name
expr_stmt|;
block|}
else|else
block|{
name|bhnd_nvstore_alias
modifier|*
name|alias
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* New variable is being set; we need to determine the 		 * appropriate path prefix */
name|alias
operator|=
name|bhnd_nvstore_find_alias
argument_list|(
name|sc
argument_list|,
name|path
operator|->
name|path_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|alias
operator|!=
name|NULL
condition|)
block|{
comment|/* Use<alias>:name */
name|len
operator|=
name|bhnd_nv_asprintf
argument_list|(
operator|&
name|namebuf
argument_list|,
literal|"%lu:%s"
argument_list|,
name|alias
operator|->
name|alias
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Use path/name */
name|len
operator|=
name|bhnd_nv_asprintf
argument_list|(
operator|&
name|namebuf
argument_list|,
literal|"%s/%s"
argument_list|,
name|path
operator|->
name|path_str
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|full_name
operator|=
name|namebuf
expr_stmt|;
block|}
comment|/* Allow the data store to filter the NVRAM operation */
if|if
condition|(
name|bhnd_nvram_val_type
argument_list|(
name|value
argument_list|)
operator|==
name|BHND_NVRAM_TYPE_NULL
condition|)
block|{
name|error
operator|=
name|bhnd_nvram_data_filter_unsetvar
argument_list|(
name|sc
operator|->
name|data
argument_list|,
name|full_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"cannot unset property %s: %d\n"
argument_list|,
name|full_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
operator|(
name|prop_val
operator|=
name|bhnd_nvram_val_copy
argument_list|(
name|value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|bhnd_nvram_data_filter_setvar
argument_list|(
name|sc
operator|->
name|data
argument_list|,
name|full_name
argument_list|,
name|value
argument_list|,
operator|&
name|prop_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"cannot set property %s: %d\n"
argument_list|,
name|full_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/* Add relative variable name to the per-path update list */
if|if
condition|(
name|bhnd_nvram_val_type
argument_list|(
name|value
argument_list|)
operator|==
name|BHND_NVRAM_TYPE_NULL
operator|&&
operator|!
name|nvram_committed
condition|)
block|{
comment|/* This is a deletion request for a variable not defined in 		 * out backing store; we can simply remove the corresponding 		 * update entry. */
name|bhnd_nvram_plist_remove
argument_list|(
name|path
operator|->
name|pending
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Update or append a pending update entry */
name|error
operator|=
name|bhnd_nvram_plist_replace_val
argument_list|(
name|path
operator|->
name|pending
argument_list|,
name|name
argument_list|,
name|prop_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
block|}
comment|/* Success */
name|error
operator|=
literal|0
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|namebuf
operator|!=
name|NULL
condition|)
name|bhnd_nv_free
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_val
operator|!=
name|NULL
condition|)
name|bhnd_nvram_val_release
argument_list|(
name|prop_val
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Iterate over all variable cookiep values retrievable from the backing  * data store in @p path.  *   * @warning Pending updates in @p path are ignored by this function.  *  * @param		sc	The NVRAM store.  * @param		path	The NVRAM path to be iterated.  * @param[in,out]	indexp	A pointer to an opaque indexp value previously  *				returned by bhnd_nvstore_path_data_next(), or a  *				NULL value to begin iteration.  *  * @return Returns the next variable name, or NULL if there are no more  * variables defined in @p path.  */
end_comment

begin_function
name|void
modifier|*
name|bhnd_nvstore_path_data_next
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|,
name|bhnd_nvstore_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
modifier|*
name|indexp
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|index_ref
decl_stmt|;
name|BHND_NVSTORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* No index */
if|if
condition|(
name|path
operator|->
name|index
operator|==
name|NULL
condition|)
block|{
comment|/* An index is required for all non-empty, non-root path 		 * instances */
name|BHND_NV_ASSERT
argument_list|(
name|bhnd_nvstore_is_root_path
argument_list|(
name|sc
argument_list|,
name|path
argument_list|)
argument_list|,
operator|(
literal|"missing index for non-root path %s"
operator|,
name|path
operator|->
name|path_str
operator|)
argument_list|)
expr_stmt|;
comment|/* Iterate NVRAM data directly, using the NVRAM data's cookiep 		 * value as our indexp context */
if|if
condition|(
operator|(
name|bhnd_nvram_data_next
argument_list|(
name|sc
operator|->
name|data
argument_list|,
name|indexp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|*
name|indexp
operator|)
return|;
block|}
comment|/* Empty index */
if|if
condition|(
name|path
operator|->
name|index
operator|->
name|count
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|*
name|indexp
operator|==
name|NULL
condition|)
block|{
comment|/* First index entry */
name|index_ref
operator|=
operator|&
name|path
operator|->
name|index
operator|->
name|cookiep
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|idxpos
decl_stmt|;
comment|/* Advance to next index entry */
name|index_ref
operator|=
operator|*
name|indexp
expr_stmt|;
name|index_ref
operator|++
expr_stmt|;
comment|/* Hit end of index? */
name|BHND_NV_ASSERT
argument_list|(
name|index_ref
operator|>
name|path
operator|->
name|index
operator|->
name|cookiep
argument_list|,
operator|(
literal|"invalid indexp"
operator|)
argument_list|)
expr_stmt|;
name|idxpos
operator|=
operator|(
name|index_ref
operator|-
name|path
operator|->
name|index
operator|->
name|cookiep
operator|)
expr_stmt|;
if|if
condition|(
name|idxpos
operator|>=
name|path
operator|->
name|index
operator|->
name|count
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Provide new index position */
operator|*
name|indexp
operator|=
name|index_ref
expr_stmt|;
comment|/* Return the data's cookiep value */
return|return
operator|(
operator|*
name|index_ref
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Perform an lookup of @p name in the backing NVRAM data for @p path,  * returning the associated cookiep value, or NULL if the variable is not found  * in the backing NVRAM data.  *   * @warning Pending updates in @p path are ignored by this function.  *   * @param	sc	The NVRAM store from which NVRAM values will be queried.  * @param	path	The path to be queried.  * @param	name	The variable name to be queried.  *   * @retval non-NULL	success  * @retval NULL		if @p name is not found in @p index.  */
end_comment

begin_function
name|void
modifier|*
name|bhnd_nvstore_path_data_lookup
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|,
name|bhnd_nvstore_path
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|BHND_NVSTORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* No index */
if|if
condition|(
name|path
operator|->
name|index
operator|==
name|NULL
condition|)
block|{
comment|/* An index is required for all non-empty, non-root path 		 * instances */
name|BHND_NV_ASSERT
argument_list|(
name|bhnd_nvstore_is_root_path
argument_list|(
name|sc
argument_list|,
name|path
argument_list|)
argument_list|,
operator|(
literal|"missing index for non-root path %s"
operator|,
name|path
operator|->
name|path_str
operator|)
argument_list|)
expr_stmt|;
comment|/* Look up directly in NVRAM data */
return|return
operator|(
name|bhnd_nvram_data_find
argument_list|(
name|sc
operator|->
name|data
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
comment|/* Otherwise, delegate to an index-based lookup */
return|return
operator|(
name|bhnd_nvstore_index_lookup
argument_list|(
name|sc
argument_list|,
name|path
operator|->
name|index
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Perform an index lookup of @p name, returning the associated cookiep  * value, or NULL if the variable does not exist.  *   * @param	sc	The NVRAM store from which NVRAM values will be queried.  * @param	index	The index to be queried.  * @param	name	The variable name to be queried.  *   * @retval non-NULL	success  * @retval NULL		if @p name is not found in @p index.  */
end_comment

begin_function
name|void
modifier|*
name|bhnd_nvstore_index_lookup
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|,
name|bhnd_nvstore_index
modifier|*
name|index
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|void
modifier|*
name|cookiep
decl_stmt|;
specifier|const
name|char
modifier|*
name|indexed_name
decl_stmt|;
name|size_t
name|min
decl_stmt|,
name|mid
decl_stmt|,
name|max
decl_stmt|;
name|uint32_t
name|data_caps
decl_stmt|;
name|int
name|order
decl_stmt|;
name|BHND_NVSTORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|index
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL index"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Locate the requested variable using a binary search. 	 */
if|if
condition|(
name|index
operator|->
name|count
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|data_caps
operator|=
name|sc
operator|->
name|data_caps
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|index
operator|->
name|count
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|max
operator|>=
name|min
condition|)
block|{
comment|/* Select midpoint */
name|mid
operator|=
operator|(
name|min
operator|+
name|max
operator|)
operator|/
literal|2
expr_stmt|;
name|cookiep
operator|=
name|index
operator|->
name|cookiep
index|[
name|mid
index|]
expr_stmt|;
comment|/* Fetch variable name */
name|indexed_name
operator|=
name|bhnd_nvram_data_getvar_name
argument_list|(
name|sc
operator|->
name|data
argument_list|,
name|cookiep
argument_list|)
expr_stmt|;
comment|/* Trim any path prefix */
if|if
condition|(
name|data_caps
operator|&
name|BHND_NVRAM_DATA_CAP_DEVPATHS
condition|)
name|indexed_name
operator|=
name|bhnd_nvram_trim_path_name
argument_list|(
name|indexed_name
argument_list|)
expr_stmt|;
comment|/* Determine which side of the partition to search */
name|order
operator|=
name|strcmp
argument_list|(
name|indexed_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|<
literal|0
condition|)
block|{
comment|/* Search upper partition */
name|min
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|order
operator|>
literal|0
condition|)
block|{
comment|/* Search (non-empty) lower partition */
if|if
condition|(
name|mid
operator|==
literal|0
condition|)
break|break;
name|max
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|order
operator|==
literal|0
condition|)
block|{
name|size_t
name|idx
decl_stmt|;
comment|/* 			 * Match found. 			 *  			 * If this happens to be a key with multiple definitions 			 * in the backing store, we need to find the entry with 			 * the highest declaration precedence. 			 *  			 * Duplicates are sorted in order of descending 			 * precedence; to find the highest precedence entry, 			 * we search backwards through the index. 			 */
name|idx
operator|=
name|mid
expr_stmt|;
while|while
condition|(
name|idx
operator|>
literal|0
condition|)
block|{
name|void
modifier|*
name|dup_cookiep
decl_stmt|;
specifier|const
name|char
modifier|*
name|dup_name
decl_stmt|;
comment|/* Fetch preceding index entry */
name|idx
operator|--
expr_stmt|;
name|dup_cookiep
operator|=
name|index
operator|->
name|cookiep
index|[
name|idx
index|]
expr_stmt|;
name|dup_name
operator|=
name|bhnd_nvram_data_getvar_name
argument_list|(
name|sc
operator|->
name|data
argument_list|,
name|dup_cookiep
argument_list|)
expr_stmt|;
comment|/* Trim any path prefix */
if|if
condition|(
name|data_caps
operator|&
name|BHND_NVRAM_DATA_CAP_DEVPATHS
condition|)
block|{
name|dup_name
operator|=
name|bhnd_nvram_trim_path_name
argument_list|(
name|dup_name
argument_list|)
expr_stmt|;
block|}
comment|/* If no match, current cookiep is the variable 				 * definition with the highest precedence */
if|if
condition|(
name|strcmp
argument_list|(
name|indexed_name
argument_list|,
name|dup_name
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|cookiep
operator|)
return|;
comment|/* Otherwise, prefer this earlier definition, 				 * and keep searching for a higher-precedence 				 * definitions */
name|cookiep
operator|=
name|dup_cookiep
expr_stmt|;
block|}
return|return
operator|(
name|cookiep
operator|)
return|;
block|}
block|}
comment|/* Not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the device path entry registered for @p path, if any.  *   * @param	sc		The NVRAM store to be queried.  * @param	path		The device path to search for.  * @param	path_len	The length of @p path.  *  * @retval non-NULL	if found.  * @retval NULL		if not found.  */
end_comment

begin_function
name|bhnd_nvstore_path
modifier|*
name|bhnd_nvstore_get_path
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|size_t
name|path_len
parameter_list|)
block|{
name|bhnd_nvstore_path_list
modifier|*
name|plist
decl_stmt|;
name|bhnd_nvstore_path
modifier|*
name|p
decl_stmt|;
name|uint32_t
name|h
decl_stmt|;
name|BHND_NVSTORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Use hash lookup */
name|h
operator|=
name|hash32_strn
argument_list|(
name|path
argument_list|,
name|path_len
argument_list|,
name|HASHINIT
argument_list|)
expr_stmt|;
name|plist
operator|=
operator|&
name|sc
operator|->
name|paths
index|[
name|h
operator|%
name|nitems
argument_list|(
name|sc
operator|->
name|paths
argument_list|)
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|p
argument_list|,
argument|plist
argument_list|,
argument|np_link
argument_list|)
block|{
comment|/* Check for prefix match */
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|->
name|path_str
argument_list|,
name|path
argument_list|,
name|path_len
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Check for complete match */
if|if
condition|(
name|strnlen
argument_list|(
name|path
argument_list|,
name|path_len
argument_list|)
operator|!=
name|strlen
argument_list|(
name|p
operator|->
name|path_str
argument_list|)
condition|)
continue|continue;
return|return
operator|(
name|p
operator|)
return|;
block|}
comment|/* Not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Resolve @p aval to its corresponding device path entry, if any.  *   * @param	sc		The NVRAM store to be queried.  * @param	aval		The device path alias value to search for.  *  * @retval non-NULL	if found.  * @retval NULL		if not found.  */
end_comment

begin_function
name|bhnd_nvstore_path
modifier|*
name|bhnd_nvstore_resolve_path_alias
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|,
name|u_long
name|aval
parameter_list|)
block|{
name|bhnd_nvstore_alias
modifier|*
name|alias
decl_stmt|;
name|BHND_NVSTORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Fetch alias entry */
if|if
condition|(
operator|(
name|alias
operator|=
name|bhnd_nvstore_get_alias
argument_list|(
name|sc
argument_list|,
name|aval
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|alias
operator|->
name|path
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Register a device path entry for the path referenced by variable name  * @p info, if any.  *  * @param	sc		The NVRAM store to be updated.  * @param	info		The NVRAM variable name info.  * @param	cookiep		The NVRAM variable's cookiep value.  *  * @retval 0		if the path was successfully registered, or an identical  *			path or alias entry exists.  * @retval EEXIST	if a conflicting entry already exists for the path or  *			alias referenced by @p info.  * @retval ENOENT	if @p info contains a dangling alias reference.  * @retval EINVAL	if @p info contains an unsupported bhnd_nvstore_var_type  *			and bhnd_nvstore_path_type combination.  * @retval ENOMEM	if allocation fails.  */
end_comment

begin_function
name|int
name|bhnd_nvstore_var_register_path
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|,
name|bhnd_nvstore_name_info
modifier|*
name|info
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|)
block|{
switch|switch
condition|(
name|info
operator|->
name|type
condition|)
block|{
case|case
name|BHND_NVSTORE_VAR
case|:
comment|/* Variable */
switch|switch
condition|(
name|info
operator|->
name|path_type
condition|)
block|{
case|case
name|BHND_NVSTORE_PATH_STRING
case|:
comment|/* Variable contains a full path string 			 * (pci/1/1/varname); register the path */
return|return
operator|(
name|bhnd_nvstore_register_path
argument_list|(
name|sc
argument_list|,
name|info
operator|->
name|path
operator|.
name|str
operator|.
name|value
argument_list|,
name|info
operator|->
name|path
operator|.
name|str
operator|.
name|value_len
argument_list|)
operator|)
return|;
case|case
name|BHND_NVSTORE_PATH_ALIAS
case|:
comment|/* Variable contains an alias reference (0:varname). 			 * There's no path to register */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|BHND_NV_PANIC
argument_list|(
literal|"unsupported path type %d"
argument_list|,
name|info
operator|->
name|path_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_NVSTORE_ALIAS_DECL
case|:
comment|/* Alias declaration */
return|return
operator|(
name|bhnd_nvstore_register_alias
argument_list|(
name|sc
argument_list|,
name|info
argument_list|,
name|cookiep
argument_list|)
operator|)
return|;
block|}
name|BHND_NV_PANIC
argument_list|(
literal|"unsupported var type %d"
argument_list|,
name|info
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Resolve the device path entry referenced referenced by @p info.  *  * @param	sc		The NVRAM store to be updated.  * @param	info		Variable name information descriptor containing  *				the path or path alias to be resolved.  *  * @retval non-NULL	if found.  * @retval NULL		if not found.  */
end_comment

begin_function
name|bhnd_nvstore_path
modifier|*
name|bhnd_nvstore_var_get_path
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|,
name|bhnd_nvstore_name_info
modifier|*
name|info
parameter_list|)
block|{
switch|switch
condition|(
name|info
operator|->
name|path_type
condition|)
block|{
case|case
name|BHND_NVSTORE_PATH_STRING
case|:
return|return
operator|(
name|bhnd_nvstore_get_path
argument_list|(
name|sc
argument_list|,
name|info
operator|->
name|path
operator|.
name|str
operator|.
name|value
argument_list|,
name|info
operator|->
name|path
operator|.
name|str
operator|.
name|value_len
argument_list|)
operator|)
return|;
case|case
name|BHND_NVSTORE_PATH_ALIAS
case|:
return|return
operator|(
name|bhnd_nvstore_resolve_path_alias
argument_list|(
name|sc
argument_list|,
name|info
operator|->
name|path
operator|.
name|alias
operator|.
name|value
argument_list|)
operator|)
return|;
block|}
name|BHND_NV_PANIC
argument_list|(
literal|"unsupported path type %d"
argument_list|,
name|info
operator|->
name|path_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Return the device path alias entry registered for @p alias_val, if any.  *   * @param	sc		The NVRAM store to be queried.  * @param	alias_val	The alias value to search for.  *  * @retval non-NULL	if found.  * @retval NULL		if not found.  */
end_comment

begin_function
name|bhnd_nvstore_alias
modifier|*
name|bhnd_nvstore_get_alias
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|,
name|u_long
name|alias_val
parameter_list|)
block|{
name|bhnd_nvstore_alias_list
modifier|*
name|alist
decl_stmt|;
name|bhnd_nvstore_alias
modifier|*
name|alias
decl_stmt|;
name|BHND_NVSTORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Can use hash lookup */
name|alist
operator|=
operator|&
name|sc
operator|->
name|aliases
index|[
name|alias_val
operator|%
name|nitems
argument_list|(
name|sc
operator|->
name|aliases
argument_list|)
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|alias
argument_list|,
argument|alist
argument_list|,
argument|na_link
argument_list|)
block|{
if|if
condition|(
name|alias
operator|->
name|alias
operator|==
name|alias_val
condition|)
return|return
operator|(
name|alias
operator|)
return|;
block|}
comment|/* Not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the device path alias entry registered for @p path, if any.  *   * @param	sc	The NVRAM store to be queried.  * @param	path	The alias path to search for.  *  * @retval non-NULL	if found.  * @retval NULL		if not found.  */
end_comment

begin_function
name|bhnd_nvstore_alias
modifier|*
name|bhnd_nvstore_find_alias
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|bhnd_nvstore_alias
modifier|*
name|alias
decl_stmt|;
name|BHND_NVSTORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Have to scan the full table */
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|aliases
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|alias
argument_list|,
argument|&sc->aliases[i]
argument_list|,
argument|na_link
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|alias
operator|->
name|path
operator|->
name|path_str
argument_list|,
name|path
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|alias
operator|)
return|;
block|}
block|}
comment|/* Not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Register a device path entry for @p path.  *   * @param	sc		The NVRAM store to be updated.  * @param	path_str	The absolute device path string.  * @param	path_len	The length of @p path_str.  *   * @retval 0		if the path was successfully registered, or an identical  *			path/alias entry already exists.  * @retval ENOMEM	if allocation fails.  */
end_comment

begin_function
name|int
name|bhnd_nvstore_register_path
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|path_str
parameter_list|,
name|size_t
name|path_len
parameter_list|)
block|{
name|bhnd_nvstore_path_list
modifier|*
name|plist
decl_stmt|;
name|bhnd_nvstore_path
modifier|*
name|path
decl_stmt|;
name|uint32_t
name|h
decl_stmt|;
name|BHND_NVSTORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Already exists? */
if|if
condition|(
name|bhnd_nvstore_get_path
argument_list|(
name|sc
argument_list|,
name|path_str
argument_list|,
name|path_len
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Can't represent more than SIZE_MAX paths */
if|if
condition|(
name|sc
operator|->
name|num_paths
operator|==
name|SIZE_MAX
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Allocate new entry */
name|path
operator|=
name|bhnd_nvstore_path_new
argument_list|(
name|path_str
argument_list|,
name|path_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Insert in path hash table */
name|h
operator|=
name|hash32_str
argument_list|(
name|path
operator|->
name|path_str
argument_list|,
name|HASHINIT
argument_list|)
expr_stmt|;
name|plist
operator|=
operator|&
name|sc
operator|->
name|paths
index|[
name|h
operator|%
name|nitems
argument_list|(
name|sc
operator|->
name|paths
argument_list|)
index|]
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|plist
argument_list|,
name|path
argument_list|,
name|np_link
argument_list|)
expr_stmt|;
comment|/* Increment path count */
name|sc
operator|->
name|num_paths
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Register a device path alias for an NVRAM 'devpathX' variable.  *   * The path value for the alias will be fetched from the backing NVRAM data.  *   * @param	sc	The NVRAM store to be updated.  * @param	info	The NVRAM variable name info.  * @param	cookiep	The NVRAM variable's cookiep value.  *   * @retval 0		if the alias was successfully registered, or an  *			identical alias entry exists.  * @retval EEXIST	if a conflicting alias or path entry already exists.  * @retval EINVAL	if @p info is not a BHND_NVSTORE_ALIAS_DECL or does  *			not contain a BHND_NVSTORE_PATH_ALIAS entry.  * @retval ENOMEM	if allocation fails.  */
end_comment

begin_function
name|int
name|bhnd_nvstore_register_alias
parameter_list|(
name|struct
name|bhnd_nvram_store
modifier|*
name|sc
parameter_list|,
specifier|const
name|bhnd_nvstore_name_info
modifier|*
name|info
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|)
block|{
name|bhnd_nvstore_alias_list
modifier|*
name|alist
decl_stmt|;
name|bhnd_nvstore_alias
modifier|*
name|alias
decl_stmt|;
name|bhnd_nvstore_path
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|path_str
decl_stmt|;
name|size_t
name|path_len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|BHND_NVSTORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|path_str
operator|=
name|NULL
expr_stmt|;
name|alias
operator|=
name|NULL
expr_stmt|;
comment|/* Can't represent more than SIZE_MAX aliases */
if|if
condition|(
name|sc
operator|->
name|num_aliases
operator|==
name|SIZE_MAX
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Must be an alias declaration */
if|if
condition|(
name|info
operator|->
name|type
operator|!=
name|BHND_NVSTORE_ALIAS_DECL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|info
operator|->
name|path_type
operator|!=
name|BHND_NVSTORE_PATH_ALIAS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Fetch the devpath variable's value length */
name|error
operator|=
name|bhnd_nvram_data_getvar
argument_list|(
name|sc
operator|->
name|data
argument_list|,
name|cookiep
argument_list|,
name|NULL
argument_list|,
operator|&
name|path_len
argument_list|,
name|BHND_NVRAM_TYPE_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Allocate path string buffer */
if|if
condition|(
operator|(
name|path_str
operator|=
name|bhnd_nv_malloc
argument_list|(
name|path_len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Decode to our new buffer */
name|error
operator|=
name|bhnd_nvram_data_getvar
argument_list|(
name|sc
operator|->
name|data
argument_list|,
name|cookiep
argument_list|,
name|path_str
argument_list|,
operator|&
name|path_len
argument_list|,
name|BHND_NVRAM_TYPE_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
comment|/* Trim trailing '/' character(s) from the path length */
name|path_len
operator|=
name|strnlen
argument_list|(
name|path_str
argument_list|,
name|path_len
argument_list|)
expr_stmt|;
while|while
condition|(
name|path_len
operator|>
literal|0
operator|&&
name|path_str
index|[
name|path_len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|path_str
index|[
name|path_len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|path_len
operator|--
expr_stmt|;
block|}
comment|/* Is a conflicting alias entry already registered for this alias 	 * value? */
name|alias
operator|=
name|bhnd_nvstore_get_alias
argument_list|(
name|sc
argument_list|,
name|info
operator|->
name|path
operator|.
name|alias
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|alias
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|alias
operator|->
name|cookiep
operator|!=
name|cookiep
operator|||
name|strcmp
argument_list|(
name|alias
operator|->
name|path
operator|->
name|path_str
argument_list|,
name|path_str
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
block|}
comment|/* Is a conflicting entry already registered for the alias path? */
if|if
condition|(
operator|(
name|alias
operator|=
name|bhnd_nvstore_find_alias
argument_list|(
name|sc
argument_list|,
name|path_str
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|alias
operator|->
name|alias
operator|!=
name|info
operator|->
name|path
operator|.
name|alias
operator|.
name|value
operator|||
name|alias
operator|->
name|cookiep
operator|!=
name|cookiep
operator|||
name|strcmp
argument_list|(
name|alias
operator|->
name|path
operator|->
name|path_str
argument_list|,
name|path_str
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
block|}
comment|/* Get (or register) the target path entry */
name|path
operator|=
name|bhnd_nvstore_get_path
argument_list|(
name|sc
argument_list|,
name|path_str
argument_list|,
name|path_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|bhnd_nvstore_register_path
argument_list|(
name|sc
argument_list|,
name|path_str
argument_list|,
name|path_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
name|path
operator|=
name|bhnd_nvstore_get_path
argument_list|(
name|sc
argument_list|,
name|path_str
argument_list|,
name|path_len
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|path
operator|!=
name|NULL
argument_list|,
operator|(
literal|"missing registered path"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate alias entry */
name|alias
operator|=
name|bhnd_nv_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|alias
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alias
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|alias
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|alias
operator|->
name|cookiep
operator|=
name|cookiep
expr_stmt|;
name|alias
operator|->
name|alias
operator|=
name|info
operator|->
name|path
operator|.
name|alias
operator|.
name|value
expr_stmt|;
comment|/* Insert in alias hash table */
name|alist
operator|=
operator|&
name|sc
operator|->
name|aliases
index|[
name|alias
operator|->
name|alias
operator|%
name|nitems
argument_list|(
name|sc
operator|->
name|aliases
argument_list|)
index|]
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|alist
argument_list|,
name|alias
argument_list|,
name|na_link
argument_list|)
expr_stmt|;
comment|/* Increment alias count */
name|sc
operator|->
name|num_aliases
operator|++
expr_stmt|;
name|bhnd_nv_free
argument_list|(
name|path_str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
if|if
condition|(
name|path_str
operator|!=
name|NULL
condition|)
name|bhnd_nv_free
argument_list|(
name|path_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|alias
operator|!=
name|NULL
condition|)
name|bhnd_nv_free
argument_list|(
name|alias
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * If @p child is equal to or a child path of @p parent, return a pointer to  * @p child's path component(s) relative to @p parent; otherwise, return NULL.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|bhnd_nvstore_parse_relpath
parameter_list|(
specifier|const
name|char
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|child
parameter_list|)
block|{
name|size_t
name|prefix_len
decl_stmt|;
comment|/* All paths have an implicit leading '/'; this allows us to treat 	 * our manufactured root path of "/" as a prefix to all NVRAM-defined 	 * paths (which do not necessarily include a leading '/' */
if|if
condition|(
operator|*
name|parent
operator|==
literal|'/'
condition|)
name|parent
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|child
operator|==
literal|'/'
condition|)
name|child
operator|++
expr_stmt|;
comment|/* Is parent a prefix of child? */
name|prefix_len
operator|=
name|strlen
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|parent
argument_list|,
name|child
argument_list|,
name|prefix_len
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* A zero-length prefix matches everything */
if|if
condition|(
name|prefix_len
operator|==
literal|0
condition|)
return|return
operator|(
name|child
operator|)
return|;
comment|/* Is child equal to parent? */
if|if
condition|(
name|child
index|[
name|prefix_len
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|child
operator|+
name|prefix_len
operator|)
return|;
comment|/* Is child actually a child of parent? */
if|if
condition|(
name|child
index|[
name|prefix_len
index|]
operator|==
literal|'/'
condition|)
return|return
operator|(
name|child
operator|+
name|prefix_len
operator|+
literal|1
operator|)
return|;
comment|/* No match (e.g. parent=/foo..., child=/fooo...) */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Parse a raw NVRAM variable name and return its @p entry_type, its  * type-specific @p prefix (e.g. '0:', 'pci/1/1', 'devpath'), and its  * type-specific @p suffix (e.g. 'varname', '0').  *   * @param	name		The NVRAM variable name to be parsed. This  *				value must remain valid for the lifetime of  *				@p info.  * @param	type		The NVRAM name type -- either INTERNAL for names  *				parsed from backing NVRAM data, or EXTERNAL for  *				names provided by external NVRAM store clients.  * @param	data_caps	The backing NVRAM data capabilities  *				(see bhnd_nvram_data_caps()).  * @param[out]	info		On success, the parsed variable name info.  *   * @retval 0		success  * @retval non-zero	if parsing @p name otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_nvstore_parse_name_info
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bhnd_nvstore_name_type
name|type
parameter_list|,
name|uint32_t
name|data_caps
parameter_list|,
name|bhnd_nvstore_name_info
modifier|*
name|info
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
comment|/* Skip path parsing? */
if|if
condition|(
name|data_caps
operator|&
name|BHND_NVRAM_DATA_CAP_DEVPATHS
condition|)
block|{
comment|/* devpath declaration? (devpath0=pci/1/1) */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"devpath"
argument_list|,
name|strlen
argument_list|(
literal|"devpath"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|u_long
name|alias
decl_stmt|;
comment|/* Perform standard validation on the relative 			 * variable name */
if|if
condition|(
name|type
operator|!=
name|BHND_NVSTORE_NAME_INTERNAL
operator|&&
operator|!
name|bhnd_nvram_validate_name
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* Parse alias value that should follow a 'devpath' 			 * prefix */
name|p
operator|=
name|name
operator|+
name|strlen
argument_list|(
literal|"devpath"
argument_list|)
expr_stmt|;
name|alias
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|!=
name|p
operator|&&
operator|*
name|endp
operator|==
literal|'\0'
condition|)
block|{
name|info
operator|->
name|type
operator|=
name|BHND_NVSTORE_ALIAS_DECL
expr_stmt|;
name|info
operator|->
name|path_type
operator|=
name|BHND_NVSTORE_PATH_ALIAS
expr_stmt|;
name|info
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|info
operator|->
name|path
operator|.
name|alias
operator|.
name|value
operator|=
name|alias
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* device aliased variable? (0:varname) */
if|if
condition|(
name|bhnd_nv_isdigit
argument_list|(
operator|*
name|name
argument_list|)
condition|)
block|{
name|u_long
name|alias
decl_stmt|;
comment|/* Parse '0:' alias prefix */
name|alias
operator|=
name|strtoul
argument_list|(
name|name
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|!=
name|name
operator|&&
operator|*
name|endp
operator|==
literal|':'
condition|)
block|{
comment|/* Perform standard validation on the relative 				 * variable name */
if|if
condition|(
name|type
operator|!=
name|BHND_NVSTORE_NAME_INTERNAL
operator|&&
operator|!
name|bhnd_nvram_validate_name
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|info
operator|->
name|type
operator|=
name|BHND_NVSTORE_VAR
expr_stmt|;
name|info
operator|->
name|path_type
operator|=
name|BHND_NVSTORE_PATH_ALIAS
expr_stmt|;
comment|/* name follows 0: prefix */
name|info
operator|->
name|name
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
name|info
operator|->
name|path
operator|.
name|alias
operator|.
name|value
operator|=
name|alias
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* device variable? (pci/1/1/varname) */
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|relative_name
decl_stmt|;
name|size_t
name|path_len
decl_stmt|;
comment|/* Determine the path length; 'p' points at the last 			 * path separator in 'name' */
name|path_len
operator|=
name|p
operator|-
name|name
expr_stmt|;
name|path
operator|=
name|name
expr_stmt|;
comment|/* The relative variable name directly follows the 			 * final path separator '/' */
name|relative_name
operator|=
name|path
operator|+
name|path_len
operator|+
literal|1
expr_stmt|;
comment|/* Now that we calculated the name offset, exclude all 			 * trailing '/' characters from the path length */
while|while
condition|(
name|path_len
operator|>
literal|0
operator|&&
name|path
index|[
name|path_len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|path_len
operator|--
expr_stmt|;
comment|/* Perform standard validation on the relative 			 * variable name */
if|if
condition|(
name|type
operator|!=
name|BHND_NVSTORE_NAME_INTERNAL
operator|&&
operator|!
name|bhnd_nvram_validate_name
argument_list|(
name|relative_name
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* Initialize result with pointers into the name 			 * buffer */
name|info
operator|->
name|type
operator|=
name|BHND_NVSTORE_VAR
expr_stmt|;
name|info
operator|->
name|path_type
operator|=
name|BHND_NVSTORE_PATH_STRING
expr_stmt|;
name|info
operator|->
name|name
operator|=
name|relative_name
expr_stmt|;
name|info
operator|->
name|path
operator|.
name|str
operator|.
name|value
operator|=
name|path
expr_stmt|;
name|info
operator|->
name|path
operator|.
name|str
operator|.
name|value_len
operator|=
name|path_len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* If all other parsing fails, the result is a simple variable with 	 * an implicit path of "/" */
if|if
condition|(
name|type
operator|!=
name|BHND_NVSTORE_NAME_INTERNAL
operator|&&
operator|!
name|bhnd_nvram_validate_name
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|/* Invalid relative name */
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|info
operator|->
name|type
operator|=
name|BHND_NVSTORE_VAR
expr_stmt|;
name|info
operator|->
name|path_type
operator|=
name|BHND_NVSTORE_PATH_STRING
expr_stmt|;
name|info
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|info
operator|->
name|path
operator|.
name|str
operator|.
name|value
operator|=
name|BHND_NVSTORE_ROOT_PATH
expr_stmt|;
name|info
operator|->
name|path
operator|.
name|str
operator|.
name|value_len
operator|=
name|BHND_NVSTORE_ROOT_PATH_LEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

