begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Landon Fuller<landonf@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/_inttypes.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_KERNEL */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_include
include|#
directive|include
file|"bhnd_nvram_map.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_private.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_datavar.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_data_spromvar.h"
end_include

begin_comment
comment|/*  * BHND SPROM NVRAM data class  *  * The SPROM data format is a fixed-layout, non-self-descriptive binary format,  * used on Broadcom wireless and wired adapters, that provides a subset of the  * variables defined by Broadcom SoC NVRAM formats.  */
end_comment

begin_function_decl
specifier|static
specifier|const
name|bhnd_sprom_layout
modifier|*
name|bhnd_nvram_sprom_get_layout
parameter_list|(
name|uint8_t
name|sromrev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_sprom_ident
parameter_list|(
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|,
specifier|const
name|bhnd_sprom_layout
modifier|*
modifier|*
name|ident
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_sprom_write_var
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|bhnd_sprom_opcode_idx_entry
modifier|*
name|entry
parameter_list|,
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_sprom_read_var
parameter_list|(
name|struct
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|struct
name|bhnd_sprom_opcode_idx_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|,
name|union
name|bhnd_nvram_sprom_storage
modifier|*
name|storage
parameter_list|,
name|bhnd_nvram_val
modifier|*
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_sprom_write_offset
parameter_list|(
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
parameter_list|,
name|struct
name|bhnd_nvram_io
modifier|*
name|data
parameter_list|,
name|bhnd_nvram_type
name|type
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|uint32_t
name|mask
parameter_list|,
name|int8_t
name|shift
parameter_list|,
name|uint32_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhnd_nvram_sprom_read_offset
parameter_list|(
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
parameter_list|,
name|struct
name|bhnd_nvram_io
modifier|*
name|data
parameter_list|,
name|bhnd_nvram_type
name|type
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|uint32_t
name|mask
parameter_list|,
name|int8_t
name|shift
parameter_list|,
name|uint32_t
modifier|*
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|bhnd_sprom_is_external_immutable
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_macro
name|BHND_NVRAM_DATA_CLASS_DEFN
argument_list|(
argument|sprom
argument_list|,
literal|"Broadcom SPROM"
argument_list|,
argument|BHND_NVRAM_DATA_CAP_DEVPATHS
argument_list|,
argument|sizeof(struct bhnd_nvram_sprom)
argument_list|)
end_macro

begin_define
define|#
directive|define
name|SPROM_COOKIE_TO_VID
parameter_list|(
name|_cookie
parameter_list|)
define|\
value|(((struct bhnd_sprom_opcode_idx_entry *)(_cookie))->vid)
end_define

begin_define
define|#
directive|define
name|SPROM_COOKIE_TO_NVRAM_VAR
parameter_list|(
name|_cookie
parameter_list|)
define|\
value|bhnd_nvram_get_vardefn(SPROM_COOKIE_TO_VID(_cookie))
end_define

begin_comment
comment|/**  * Read the magic value from @p io, and verify that it matches  * the @p layout's expected magic value.  *   * If @p layout does not defined a magic value, @p magic is set to 0x0  * and success is returned.  *   * @param	io	An I/O context mapping the SPROM data to be identified.  * @param	layout	The SPROM layout against which @p io should be verified.  * @param[out]	magic	On success, the SPROM magic value.  *   * @retval 0		success  * @retval non-zero	If checking @p io otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_check_magic
parameter_list|(
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|,
specifier|const
name|bhnd_sprom_layout
modifier|*
name|layout
parameter_list|,
name|uint16_t
modifier|*
name|magic
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Skip if layout does not define a magic value */
if|if
condition|(
name|layout
operator|->
name|flags
operator|&
name|SPROM_LAYOUT_MAGIC_NONE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Read the magic value */
name|error
operator|=
name|bhnd_nvram_io_read
argument_list|(
name|io
argument_list|,
name|layout
operator|->
name|magic_offset
argument_list|,
name|magic
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|magic
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|magic
operator|=
name|le16toh
argument_list|(
operator|*
name|magic
argument_list|)
expr_stmt|;
comment|/* If the signature does not match, skip to next layout */
if|if
condition|(
operator|*
name|magic
operator|!=
name|layout
operator|->
name|magic_value
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Attempt to identify the format of the SPROM data mapped by @p io.  *  * The SPROM data format does not provide any identifying information at a  * known offset, instead requiring that we iterate over the known SPROM image  * sizes until we are able to compute a valid checksum (and, for later  * revisions, validate a signature at a revision-specific offset).  *  * @param	io	An I/O context mapping the SPROM data to be identified.  * @param[out]	ident	On success, the identified SPROM layout.  *  * @retval 0		success  * @retval non-zero	If identifying @p io otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_ident
parameter_list|(
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|,
specifier|const
name|bhnd_sprom_layout
modifier|*
modifier|*
name|ident
parameter_list|)
block|{
name|uint8_t
name|crc
decl_stmt|;
name|size_t
name|crc_errors
decl_stmt|;
name|size_t
name|nbytes
decl_stmt|;
name|int
name|error
decl_stmt|;
name|crc
operator|=
name|BHND_NVRAM_CRC8_INITIAL
expr_stmt|;
name|crc_errors
operator|=
literal|0
expr_stmt|;
name|nbytes
operator|=
literal|0
expr_stmt|;
comment|/* We iterate the SPROM layouts smallest to largest, allowing us to 	 * perform incremental checksum calculation */
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bhnd_sprom_num_layouts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|bhnd_sprom_layout
modifier|*
name|layout
decl_stmt|;
name|u_char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|size_t
name|nread
decl_stmt|;
name|uint16_t
name|magic
decl_stmt|;
name|uint8_t
name|srev
decl_stmt|;
name|bool
name|crc_valid
decl_stmt|;
name|bool
name|have_magic
decl_stmt|;
name|layout
operator|=
operator|&
name|bhnd_sprom_layouts
index|[
name|i
index|]
expr_stmt|;
name|have_magic
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|layout
operator|->
name|flags
operator|&
name|SPROM_LAYOUT_MAGIC_NONE
operator|)
condition|)
name|have_magic
operator|=
name|false
expr_stmt|;
comment|/* 		 * Read image data and update CRC (errors are reported 		 * after the signature check) 		 *  		 * Layout instances must be ordered from smallest to largest by 		 * the nvram_map compiler, allowing us to incrementally update 		 * our CRC. 		 */
if|if
condition|(
name|nbytes
operator|>
name|layout
operator|->
name|size
condition|)
name|BHND_NV_PANIC
argument_list|(
literal|"SPROM layout defined out-of-order"
argument_list|)
expr_stmt|;
name|nread
operator|=
name|layout
operator|->
name|size
operator|-
name|nbytes
expr_stmt|;
while|while
condition|(
name|nread
operator|>
literal|0
condition|)
block|{
name|size_t
name|nr
decl_stmt|;
name|nr
operator|=
name|bhnd_nv_ummin
argument_list|(
name|nread
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_io_read
argument_list|(
name|io
argument_list|,
name|nbytes
argument_list|,
name|buf
argument_list|,
name|nr
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|crc
operator|=
name|bhnd_nvram_crc8
argument_list|(
name|buf
argument_list|,
name|nr
argument_list|,
name|crc
argument_list|)
expr_stmt|;
name|crc_valid
operator|=
operator|(
name|crc
operator|==
name|BHND_NVRAM_CRC8_VALID
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|crc_valid
condition|)
name|crc_errors
operator|++
expr_stmt|;
name|nread
operator|-=
name|nr
expr_stmt|;
name|nbytes
operator|+=
name|nr
expr_stmt|;
block|}
comment|/* Read SPROM revision */
name|error
operator|=
name|bhnd_nvram_io_read
argument_list|(
name|io
argument_list|,
name|layout
operator|->
name|srev_offset
argument_list|,
operator|&
name|srev
argument_list|,
sizeof|sizeof
argument_list|(
name|srev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Early sromrev 1 devices (specifically some BCM440x enet 		 * cards) are reported to have been incorrectly programmed 		 * with a revision of 0x10. */
if|if
condition|(
name|layout
operator|->
name|rev
operator|==
literal|1
operator|&&
name|srev
operator|==
literal|0x10
condition|)
name|srev
operator|=
literal|0x1
expr_stmt|;
comment|/* Check revision against the layout definition */
if|if
condition|(
name|srev
operator|!=
name|layout
operator|->
name|rev
condition|)
continue|continue;
comment|/* Check the magic value, skipping to the next layout on 		 * failure. */
name|error
operator|=
name|bhnd_nvram_sprom_check_magic
argument_list|(
name|io
argument_list|,
name|layout
argument_list|,
operator|&
name|magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* If the CRC is was valid, log the mismatch */
if|if
condition|(
name|crc_valid
operator|||
name|BHND_NV_VERBOSE
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"invalid sprom %hhu signature: "
literal|"0x%hx (expected 0x%hx)\n"
argument_list|,
name|srev
argument_list|,
name|magic
argument_list|,
name|layout
operator|->
name|magic_value
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
continue|continue;
block|}
comment|/* Check for an earlier CRC error */
if|if
condition|(
operator|!
name|crc_valid
condition|)
block|{
comment|/* If the magic check succeeded, then we may just have 			 * data corruption -- log the CRC error */
if|if
condition|(
name|have_magic
operator|||
name|BHND_NV_VERBOSE
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"sprom %hhu CRC error (crc=%#hhx, "
literal|"expected=%#x)\n"
argument_list|,
name|srev
argument_list|,
name|crc
argument_list|,
name|BHND_NVRAM_CRC8_VALID
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Identified */
operator|*
name|ident
operator|=
name|layout
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* No match */
if|if
condition|(
name|crc_errors
operator|>
literal|0
operator|&&
name|BHND_NV_VERBOSE
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"sprom parsing failed with %zu CRC errors\n"
argument_list|,
name|crc_errors
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_probe
parameter_list|(
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|)
block|{
specifier|const
name|bhnd_sprom_layout
modifier|*
name|layout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Try to parse the input */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_sprom_ident
argument_list|(
name|io
argument_list|,
operator|&
name|layout
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|BHND_NVRAM_DATA_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_getvar_direct
parameter_list|(
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|bhnd_nvram_type
name|type
parameter_list|)
block|{
specifier|const
name|bhnd_sprom_layout
modifier|*
name|layout
decl_stmt|;
name|bhnd_sprom_opcode_state
name|state
decl_stmt|;
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
decl_stmt|;
name|size_t
name|vid
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Look up the variable definition and ID */
if|if
condition|(
operator|(
name|var
operator|=
name|bhnd_nvram_find_vardefn
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|vid
operator|=
name|bhnd_nvram_get_vardefn_id
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* Identify the SPROM image layout */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_sprom_ident
argument_list|(
name|io
argument_list|,
operator|&
name|layout
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Initialize SPROM layout interpreter */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_init
argument_list|(
operator|&
name|state
argument_list|,
name|layout
argument_list|)
operator|)
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error initializing opcode state: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Find SPROM layout entry for the requested variable */
while|while
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_next_var
argument_list|(
operator|&
name|state
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|bhnd_sprom_opcode_idx_entry
name|entry
decl_stmt|;
name|union
name|bhnd_nvram_sprom_storage
name|storage
decl_stmt|;
name|bhnd_nvram_val
name|val
decl_stmt|;
comment|/* Fetch the variable's entry state */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_init_entry
argument_list|(
operator|&
name|state
argument_list|,
operator|&
name|entry
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Match against expected VID */
if|if
condition|(
name|entry
operator|.
name|vid
operator|!=
name|vid
condition|)
continue|continue;
comment|/* Decode variable to a new value instance */
name|error
operator|=
name|bhnd_nvram_sprom_read_var
argument_list|(
operator|&
name|state
argument_list|,
operator|&
name|entry
argument_list|,
name|io
argument_list|,
operator|&
name|storage
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Perform value coercion */
name|error
operator|=
name|bhnd_nvram_val_encode
argument_list|(
operator|&
name|val
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Clean up */
name|bhnd_nvram_val_release
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Hit EOF without matching the requested variable? */
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Some other parse error occured */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the SPROM layout definition for the given @p sromrev, or NULL if  * not found.  */
end_comment

begin_function
specifier|static
specifier|const
name|bhnd_sprom_layout
modifier|*
name|bhnd_nvram_sprom_get_layout
parameter_list|(
name|uint8_t
name|sromrev
parameter_list|)
block|{
comment|/* Find matching SPROM layout definition */
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bhnd_sprom_num_layouts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bhnd_sprom_layouts
index|[
name|i
index|]
operator|.
name|rev
operator|==
name|sromrev
condition|)
return|return
operator|(
operator|&
name|bhnd_sprom_layouts
index|[
name|i
index|]
operator|)
return|;
block|}
comment|/* Not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Serialize a SPROM variable.  *  * @param state	The SPROM opcode state describing the layout of @p io.  * @param entry	The variable's SPROM opcode index entry.  * @param value	The value to encode to @p io as per @p entry.  * @param io	I/O context to which @p value should be written, or NULL  *		if no output should be produced. This may be used to validate  *		values prior to write.  *  * @retval 0		success  * @retval EFTYPE	If value coercion from @p value to the type required by  *			@p entry is unsupported.  * @retval ERANGE	If value coercion from @p value would overflow  *			(or underflow) the type required by @p entry.  * @retval non-zero	If serialization otherwise fails, a regular unix error  *			code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_write_var
parameter_list|(
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|bhnd_sprom_opcode_idx_entry
modifier|*
name|entry
parameter_list|,
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
decl_stmt|;
name|uint32_t
name|u32
index|[
name|BHND_SPROM_ARRAY_MAXLEN
index|]
decl_stmt|;
name|bhnd_nvram_type
name|itype
decl_stmt|,
name|var_base_type
decl_stmt|;
name|size_t
name|ipos
decl_stmt|,
name|ilen
decl_stmt|,
name|nelem
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Fetch variable definition and the native element type */
name|var
operator|=
name|bhnd_nvram_get_vardefn
argument_list|(
name|entry
operator|->
name|vid
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|var
operator|!=
name|NULL
argument_list|,
operator|(
literal|"missing variable definition"
operator|)
argument_list|)
expr_stmt|;
name|var_base_type
operator|=
name|bhnd_nvram_base_type
argument_list|(
name|var
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* Fetch the element count from the SPROM variable layout definition */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_eval_var
argument_list|(
name|state
argument_list|,
name|entry
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|nelem
operator|=
name|state
operator|->
name|var
operator|.
name|nelem
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|nelem
operator|<=
name|var
operator|->
name|nelem
argument_list|,
operator|(
literal|"SPROM nelem=%zu exceeds maximum "
literal|"NVRAM nelem=%hhu"
operator|,
name|nelem
operator|,
name|var
operator|->
name|nelem
operator|)
argument_list|)
expr_stmt|;
comment|/* Promote the data to a common 32-bit representation */
if|if
condition|(
name|bhnd_nvram_is_signed_type
argument_list|(
name|var_base_type
argument_list|)
condition|)
name|itype
operator|=
name|BHND_NVRAM_TYPE_INT32_ARRAY
expr_stmt|;
else|else
name|itype
operator|=
name|BHND_NVRAM_TYPE_UINT32_ARRAY
expr_stmt|;
comment|/* Calculate total size of the 32-bit promoted representation */
if|if
condition|(
operator|(
name|ilen
operator|=
name|bhnd_nvram_value_size
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|itype
argument_list|,
name|nelem
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Variable-width types are unsupported */
name|BHND_NV_LOG
argument_list|(
literal|"invalid %s SPROM variable type %d\n"
argument_list|,
name|var
operator|->
name|name
argument_list|,
name|var
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
comment|/* The native representation must fit within our scratch array */
if|if
condition|(
name|ilen
operator|>
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error encoding '%s', SPROM_ARRAY_MAXLEN "
literal|"incorrect\n"
argument_list|,
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
comment|/* Initialize our common 32-bit value representation */
if|if
condition|(
name|bhnd_nvram_val_type
argument_list|(
name|value
argument_list|)
operator|==
name|BHND_NVRAM_TYPE_NULL
condition|)
block|{
comment|/* No value provided; can this variable be encoded as missing 		 * by setting all bits to one? */
if|if
condition|(
operator|!
operator|(
name|var
operator|->
name|flags
operator|&
name|BHND_NVRAM_VF_IGNALL1
operator|)
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"missing required property: %s\n"
argument_list|,
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Set all bits */
name|memset
argument_list|(
name|u32
argument_list|,
literal|0xFF
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bhnd_nvram_val
name|bcm_val
decl_stmt|;
specifier|const
name|void
modifier|*
name|var_ptr
decl_stmt|;
name|bhnd_nvram_type
name|var_type
decl_stmt|,
name|raw_type
decl_stmt|;
name|size_t
name|var_len
decl_stmt|,
name|enc_nelem
decl_stmt|;
comment|/* Try to coerce the value to the native variable format. */
name|error
operator|=
name|bhnd_nvram_val_convert_init
argument_list|(
operator|&
name|bcm_val
argument_list|,
name|var
operator|->
name|fmt
argument_list|,
name|value
argument_list|,
name|BHND_NVRAM_VAL_DYNAMIC
operator||
name|BHND_NVRAM_VAL_BORROW_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error converting input type %s to %s "
literal|"format\n"
argument_list|,
name|bhnd_nvram_type_name
argument_list|(
name|bhnd_nvram_val_type
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
name|bhnd_nvram_val_fmt_name
argument_list|(
name|var
operator|->
name|fmt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|var_ptr
operator|=
name|bhnd_nvram_val_bytes
argument_list|(
operator|&
name|bcm_val
argument_list|,
operator|&
name|var_len
argument_list|,
operator|&
name|var_type
argument_list|)
expr_stmt|;
comment|/* 		 * Promote to a common 32-bit representation.  		 * 		 * We must use the raw type to interpret the input data as its 		 * underlying integer representation -- otherwise, coercion 		 * would attempt to parse the input as its complex 		 * representation. 		 * 		 * For example, direct CHAR -> UINT32 coercion would attempt to 		 * parse the character as a decimal integer, rather than 		 * promoting the raw UTF8 byte value to a 32-bit value. 		 */
name|raw_type
operator|=
name|bhnd_nvram_raw_type
argument_list|(
name|var_type
argument_list|)
expr_stmt|;
name|error
operator|=
name|bhnd_nvram_value_coerce
argument_list|(
name|var_ptr
argument_list|,
name|var_len
argument_list|,
name|raw_type
argument_list|,
name|u32
argument_list|,
operator|&
name|ilen
argument_list|,
name|itype
argument_list|)
expr_stmt|;
comment|/* Clean up temporary value representation */
name|bhnd_nvram_val_release
argument_list|(
operator|&
name|bcm_val
argument_list|)
expr_stmt|;
comment|/* Report coercion failure */
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error promoting %s to %s: %d\n"
argument_list|,
name|bhnd_nvram_type_name
argument_list|(
name|var_type
argument_list|)
argument_list|,
name|bhnd_nvram_type_name
argument_list|(
name|itype
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Encoded element count must match SPROM's definition */
name|error
operator|=
name|bhnd_nvram_value_nelem
argument_list|(
name|u32
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|,
operator|&
name|enc_nelem
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|enc_nelem
operator|!=
name|nelem
condition|)
block|{
specifier|const
name|char
modifier|*
name|type_name
decl_stmt|;
name|type_name
operator|=
name|bhnd_nvram_type_name
argument_list|(
name|var_base_type
argument_list|)
expr_stmt|;
name|BHND_NV_LOG
argument_list|(
literal|"invalid %s property value '%s[%zu]': "
literal|"required %s[%zu]"
argument_list|,
name|var
operator|->
name|name
argument_list|,
name|type_name
argument_list|,
name|enc_nelem
argument_list|,
name|type_name
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
block|}
comment|/* 	 * Seek to the start of the variable's SPROM layout definition and 	 * iterate over all bindings. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_seek
argument_list|(
name|state
argument_list|,
name|entry
argument_list|)
operator|)
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"variable seek failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ipos
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_next_binding
argument_list|(
name|state
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|bhnd_sprom_opcode_bind
modifier|*
name|binding
decl_stmt|;
name|bhnd_sprom_opcode_var
modifier|*
name|binding_var
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|uint32_t
name|skip_out_bytes
decl_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|state
operator|->
name|var_state
operator|>=
name|SPROM_OPCODE_VAR_STATE_OPEN
argument_list|,
operator|(
literal|"invalid var state"
operator|)
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|state
operator|->
name|var
operator|.
name|have_bind
argument_list|,
operator|(
literal|"invalid bind state"
operator|)
argument_list|)
expr_stmt|;
name|binding_var
operator|=
operator|&
name|state
operator|->
name|var
expr_stmt|;
name|binding
operator|=
operator|&
name|state
operator|->
name|var
operator|.
name|bind
expr_stmt|;
comment|/* Calculate output skip bytes for this binding. 		 *  		 * Skip directions are defined in terms of decoding, and 		 * reversed when encoding. */
name|skip_out_bytes
operator|=
name|binding
operator|->
name|skip_in
expr_stmt|;
name|error
operator|=
name|bhnd_sprom_opcode_apply_scale
argument_list|(
name|state
argument_list|,
operator|&
name|skip_out_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Bind */
name|offset
operator|=
name|state
operator|->
name|offset
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|binding
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ipos
operator|>=
name|nelem
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"input skip %u positioned %zu "
literal|"beyond nelem %zu\n"
argument_list|,
name|binding
operator|->
name|skip_out
argument_list|,
name|ipos
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Write next offset */
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|bhnd_nvram_sprom_write_offset
argument_list|(
name|var
argument_list|,
name|io
argument_list|,
name|binding_var
operator|->
name|base_type
argument_list|,
name|offset
argument_list|,
name|binding_var
operator|->
name|mask
argument_list|,
name|binding_var
operator|->
name|shift
argument_list|,
name|u32
index|[
name|ipos
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Adjust output position; this was already verified to 			 * not overflow/underflow during SPROM opcode 			 * evaluation */
if|if
condition|(
name|binding
operator|->
name|skip_in_negative
condition|)
block|{
name|offset
operator|-=
name|skip_out_bytes
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|+=
name|skip_out_bytes
expr_stmt|;
block|}
comment|/* Skip advancing input if additional bindings are 			 * required to fully encode intv */
if|if
condition|(
name|binding
operator|->
name|skip_out
operator|==
literal|0
condition|)
continue|continue;
comment|/* Advance input position */
if|if
condition|(
name|SIZE_MAX
operator|-
name|binding
operator|->
name|skip_out
operator|<
name|ipos
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"output skip %u would overflow "
literal|"%zu\n"
argument_list|,
name|binding
operator|->
name|skip_out
argument_list|,
name|ipos
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ipos
operator|+=
name|binding
operator|->
name|skip_out
expr_stmt|;
block|}
block|}
comment|/* Did we iterate all bindings until hitting end of the variable 	 * definition? */
name|BHND_NV_ASSERT
argument_list|(
name|error
operator|!=
literal|0
argument_list|,
operator|(
literal|"loop terminated early"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_serialize
parameter_list|(
name|bhnd_nvram_data_class
modifier|*
name|cls
parameter_list|,
name|bhnd_nvram_plist
modifier|*
name|props
parameter_list|,
name|bhnd_nvram_plist
modifier|*
name|options
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|)
block|{
name|bhnd_sprom_opcode_state
name|state
decl_stmt|;
name|struct
name|bhnd_nvram_io
modifier|*
name|io
decl_stmt|;
name|bhnd_nvram_prop
modifier|*
name|prop
decl_stmt|;
name|bhnd_sprom_opcode_idx_entry
modifier|*
name|entry
decl_stmt|;
specifier|const
name|bhnd_sprom_layout
modifier|*
name|layout
decl_stmt|;
name|size_t
name|limit
decl_stmt|;
name|uint8_t
name|crc
decl_stmt|;
name|uint8_t
name|sromrev
decl_stmt|;
name|int
name|error
decl_stmt|;
name|limit
operator|=
operator|*
name|olen
expr_stmt|;
name|layout
operator|=
name|NULL
expr_stmt|;
name|io
operator|=
name|NULL
expr_stmt|;
comment|/* Fetch sromrev property */
if|if
condition|(
operator|!
name|bhnd_nvram_plist_contains
argument_list|(
name|props
argument_list|,
name|BHND_NVAR_SROMREV
argument_list|)
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"missing required property: %s\n"
argument_list|,
name|BHND_NVAR_SROMREV
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|bhnd_nvram_plist_get_uint8
argument_list|(
name|props
argument_list|,
name|BHND_NVAR_SROMREV
argument_list|,
operator|&
name|sromrev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error reading sromrev property: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
comment|/* Find SPROM layout definition */
if|if
condition|(
operator|(
name|layout
operator|=
name|bhnd_nvram_sprom_get_layout
argument_list|(
name|sromrev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"unsupported sromrev: %hhu\n"
argument_list|,
name|sromrev
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
comment|/* Provide required size to caller */
operator|*
name|olen
operator|=
name|layout
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|outp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|limit
operator|<
operator|*
name|olen
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Initialize SPROM layout interpreter */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_init
argument_list|(
operator|&
name|state
argument_list|,
name|layout
argument_list|)
operator|)
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error initializing opcode state: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Check for unsupported properties */
name|prop
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|prop
operator|=
name|bhnd_nvram_plist_next
argument_list|(
name|props
argument_list|,
name|prop
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Fetch the corresponding SPROM layout index entry */
name|name
operator|=
name|bhnd_nvram_prop_name
argument_list|(
name|prop
argument_list|)
expr_stmt|;
name|entry
operator|=
name|bhnd_sprom_opcode_index_find
argument_list|(
operator|&
name|state
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"property '%s' unsupported by sromrev "
literal|"%hhu\n"
argument_list|,
name|name
argument_list|,
name|layout
operator|->
name|rev
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
block|}
comment|/* Zero-initialize output */
name|memset
argument_list|(
name|outp
argument_list|,
literal|0
argument_list|,
operator|*
name|olen
argument_list|)
expr_stmt|;
comment|/* Allocate wrapping I/O context for output buffer */
name|io
operator|=
name|bhnd_nvram_ioptr_new
argument_list|(
name|outp
argument_list|,
operator|*
name|olen
argument_list|,
operator|*
name|olen
argument_list|,
name|BHND_NVRAM_IOPTR_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
comment|/* 	 * Serialize all SPROM variable data. 	 */
name|entry
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|bhnd_sprom_opcode_index_next
argument_list|(
operator|&
name|state
argument_list|,
name|entry
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
decl_stmt|;
name|bhnd_nvram_val
modifier|*
name|val
decl_stmt|;
name|var
operator|=
name|bhnd_nvram_get_vardefn
argument_list|(
name|entry
operator|->
name|vid
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|var
operator|!=
name|NULL
argument_list|,
operator|(
literal|"missing variable definition"
operator|)
argument_list|)
expr_stmt|;
comment|/* Fetch prop; will be NULL if unavailable */
name|prop
operator|=
name|bhnd_nvram_plist_get_prop
argument_list|(
name|props
argument_list|,
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|!=
name|NULL
condition|)
block|{
name|val
operator|=
name|bhnd_nvram_prop_val
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|BHND_NVRAM_VAL_NULL
expr_stmt|;
block|}
comment|/* Attempt to serialize the property value to the appropriate 		 * offset within the output buffer */
name|error
operator|=
name|bhnd_nvram_sprom_write_var
argument_list|(
operator|&
name|state
argument_list|,
name|entry
argument_list|,
name|val
argument_list|,
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error serializing %s to required type "
literal|"%s: %d\n"
argument_list|,
name|var
operator|->
name|name
argument_list|,
name|bhnd_nvram_type_name
argument_list|(
name|var
operator|->
name|type
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* ENOMEM is reserved for signaling that the output 			 * buffer capacity is insufficient */
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
block|}
comment|/* 	 * Write magic value, if any. 	 */
if|if
condition|(
operator|!
operator|(
name|layout
operator|->
name|flags
operator|&
name|SPROM_LAYOUT_MAGIC_NONE
operator|)
condition|)
block|{
name|uint16_t
name|magic
decl_stmt|;
name|magic
operator|=
name|htole16
argument_list|(
name|layout
operator|->
name|magic_value
argument_list|)
expr_stmt|;
name|error
operator|=
name|bhnd_nvram_io_write
argument_list|(
name|io
argument_list|,
name|layout
operator|->
name|magic_offset
argument_list|,
operator|&
name|magic
argument_list|,
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error writing magic value: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
block|}
comment|/* Calculate the CRC over all SPROM data, not including the CRC byte. */
name|crc
operator|=
operator|~
name|bhnd_nvram_crc8
argument_list|(
name|outp
argument_list|,
name|layout
operator|->
name|crc_offset
argument_list|,
name|BHND_NVRAM_CRC8_INITIAL
argument_list|)
expr_stmt|;
comment|/* Write the checksum. */
name|error
operator|=
name|bhnd_nvram_io_write
argument_list|(
name|io
argument_list|,
name|layout
operator|->
name|crc_offset
argument_list|,
operator|&
name|crc
argument_list|,
sizeof|sizeof
argument_list|(
name|crc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error writing CRC value: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
comment|/* 	 * Success! 	 */
name|error
operator|=
literal|0
expr_stmt|;
name|finished
label|:
name|bhnd_sprom_opcode_fini
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|!=
name|NULL
condition|)
name|bhnd_nvram_io_free
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_new
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|bhnd_nvram_sprom
modifier|*
name|sp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sp
operator|=
operator|(
expr|struct
name|bhnd_nvram_sprom
operator|*
operator|)
name|nv
expr_stmt|;
comment|/* Identify the SPROM input data */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_sprom_ident
argument_list|(
name|io
argument_list|,
operator|&
name|sp
operator|->
name|layout
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Copy SPROM image to our shadow buffer */
name|sp
operator|->
name|data
operator|=
name|bhnd_nvram_iobuf_copy_range
argument_list|(
name|io
argument_list|,
literal|0
argument_list|,
name|sp
operator|->
name|layout
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|data
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
comment|/* Initialize SPROM binding eval state */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_init
argument_list|(
operator|&
name|sp
operator|->
name|state
argument_list|,
name|sp
operator|->
name|layout
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
if|if
condition|(
name|sp
operator|->
name|data
operator|!=
name|NULL
condition|)
name|bhnd_nvram_io_free
argument_list|(
name|sp
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bhnd_nvram_sprom_free
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|)
block|{
name|struct
name|bhnd_nvram_sprom
modifier|*
name|sp
init|=
operator|(
expr|struct
name|bhnd_nvram_sprom
operator|*
operator|)
name|nv
decl_stmt|;
name|bhnd_sprom_opcode_fini
argument_list|(
operator|&
name|sp
operator|->
name|state
argument_list|)
expr_stmt|;
name|bhnd_nvram_io_free
argument_list|(
name|sp
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|bhnd_nvram_sprom_count
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|)
block|{
name|struct
name|bhnd_nvram_sprom
modifier|*
name|sprom
init|=
operator|(
expr|struct
name|bhnd_nvram_sprom
operator|*
operator|)
name|nv
decl_stmt|;
return|return
operator|(
name|sprom
operator|->
name|layout
operator|->
name|num_vars
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bhnd_nvram_plist
modifier|*
name|bhnd_nvram_sprom_options
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|bhnd_nvram_sprom_caps
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|)
block|{
return|return
operator|(
name|BHND_NVRAM_DATA_CAP_INDEXED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|bhnd_nvram_sprom_next
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|bhnd_nvram_sprom
modifier|*
name|sp
decl_stmt|;
name|bhnd_sprom_opcode_idx_entry
modifier|*
name|entry
decl_stmt|;
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
decl_stmt|;
name|sp
operator|=
operator|(
expr|struct
name|bhnd_nvram_sprom
operator|*
operator|)
name|nv
expr_stmt|;
comment|/* Find next index entry that is not disabled by virtue of IGNALL1 */
name|entry
operator|=
operator|*
name|cookiep
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|bhnd_sprom_opcode_index_next
argument_list|(
operator|&
name|sp
operator|->
name|state
argument_list|,
name|entry
argument_list|)
operator|)
condition|)
block|{
comment|/* Update cookiep and fetch variable definition */
operator|*
name|cookiep
operator|=
name|entry
expr_stmt|;
name|var
operator|=
name|SPROM_COOKIE_TO_NVRAM_VAR
argument_list|(
operator|*
name|cookiep
argument_list|)
expr_stmt|;
comment|/* We might need to parse the variable's value to determine 		 * whether it should be treated as unset */
if|if
condition|(
name|var
operator|->
name|flags
operator|&
name|BHND_NVRAM_VF_IGNALL1
condition|)
block|{
name|int
name|error
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|error
operator|=
name|bhnd_nvram_sprom_getvar
argument_list|(
name|nv
argument_list|,
operator|*
name|cookiep
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|,
name|var
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_ASSERT
argument_list|(
name|error
operator|==
name|ENOENT
argument_list|,
operator|(
literal|"unexpected "
literal|"error parsing variable: %d"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Found! */
return|return
operator|(
name|var
operator|->
name|name
operator|)
return|;
block|}
comment|/* Reached end of index entries */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|bhnd_nvram_sprom_find
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|bhnd_nvram_sprom
modifier|*
name|sp
decl_stmt|;
name|bhnd_sprom_opcode_idx_entry
modifier|*
name|entry
decl_stmt|;
name|sp
operator|=
operator|(
expr|struct
name|bhnd_nvram_sprom
operator|*
operator|)
name|nv
expr_stmt|;
name|entry
operator|=
name|bhnd_sprom_opcode_index_find
argument_list|(
operator|&
name|sp
operator|->
name|state
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Write @p value of @p type to the SPROM @p data at @p offset, applying  * @p mask and @p shift, and OR with the existing data.  *  * @param var The NVRAM variable definition.  * @param data The SPROM data to be modified.  * @param type The type to write at @p offset.  * @param offset The data offset to be written.  * @param mask The mask to be applied to @p value after shifting.  * @param shift The shift to be applied to @p value; if positive, a left  * shift will be applied, if negative, a right shift (this is the reverse of the  * decoding behavior)  * @param value The value to be written. The parsed value will be OR'd with the  * current contents of @p data at @p offset.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_write_offset
parameter_list|(
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
parameter_list|,
name|struct
name|bhnd_nvram_io
modifier|*
name|data
parameter_list|,
name|bhnd_nvram_type
name|type
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|uint32_t
name|mask
parameter_list|,
name|int8_t
name|shift
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|union
name|bhnd_nvram_sprom_storage
name|scratch
decl_stmt|;
name|int
name|error
decl_stmt|;
define|#
directive|define
name|NV_WRITE_INT
parameter_list|(
name|_widen
parameter_list|,
name|_repr
parameter_list|,
name|_swap
parameter_list|)
value|do {		\
comment|/* Narrow the 32-bit representation */
value|\ 	scratch._repr[1] = (_widen)value;			\ 								\
comment|/* Shift and mask the new value */
value|\ 	if (shift> 0)						\ 		scratch._repr[1]<<= shift;			\ 	else if (shift< 0)					\ 		scratch._repr[1]>>= -shift;			\ 	scratch._repr[1]&= mask;				\ 								\
comment|/* Swap to output byte order */
value|\ 	scratch._repr[1] = _swap(scratch._repr[1]);		\ 								\
comment|/* Fetch the current value */
value|\ 	error = bhnd_nvram_io_read(data, offset,		\&scratch._repr[0], sizeof(scratch._repr[0]));	\ 	if (error) {						\ 		BHND_NV_LOG("error reading %s SPROM offset "	\ 		    "%#zx: %d\n", var->name, offset, error);	\ 		return (EFTYPE);				\ 	}							\ 								\
comment|/* Mask and set our new value's bits in the current	\ 	 * value */
value|\ 	if (shift>= 0)						\ 		scratch._repr[0]&= ~_swap(mask<< shift);	\ 	else if (shift< 0)					\ 		scratch._repr[0]&= ~_swap(mask>> (-shift));	\ 	scratch._repr[0] |= scratch._repr[1];			\ 								\
comment|/* Perform write */
value|\ 	error = bhnd_nvram_io_write(data, offset,		\&scratch._repr[0], sizeof(scratch._repr[0]));	\ 	if (error) {						\ 		BHND_NV_LOG("error writing %s SPROM offset "	\ 		    "%#zx: %d\n", var->name, offset, error);	\ 		return (EFTYPE);				\ 	}							\ } while(0)
comment|/* Apply mask/shift and widen to a common 32bit representation */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_UINT8
case|:
name|NV_WRITE_INT
argument_list|(
name|uint32_t
argument_list|,
name|u8
argument_list|,	)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT16
case|:
name|NV_WRITE_INT
argument_list|(
name|uint32_t
argument_list|,
name|u16
argument_list|,
name|htole16
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT32
case|:
name|NV_WRITE_INT
argument_list|(
name|uint32_t
argument_list|,
name|u32
argument_list|,
name|htole32
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_INT8
case|:
name|NV_WRITE_INT
argument_list|(
name|int32_t
argument_list|,
name|i8
argument_list|,	)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_INT16
case|:
name|NV_WRITE_INT
argument_list|(
name|int32_t
argument_list|,
name|i16
argument_list|,
name|htole16
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_INT32
case|:
name|NV_WRITE_INT
argument_list|(
name|int32_t
argument_list|,
name|i32
argument_list|,
name|htole32
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_CHAR
case|:
name|NV_WRITE_INT
argument_list|(
name|uint32_t
argument_list|,
name|u8
argument_list|,	)
expr_stmt|;
break|break;
default|default:
name|BHND_NV_LOG
argument_list|(
literal|"unhandled %s offset type: %d\n"
argument_list|,
name|var
operator|->
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
undef|#
directive|undef
name|NV_WRITE_INT
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read the value of @p type from the SPROM @p data at @p offset, apply @p mask  * and @p shift, and OR with the existing @p value.  *   * @param var The NVRAM variable definition.  * @param data The SPROM data to be decoded.  * @param type The type to read at @p offset  * @param offset The data offset to be read.  * @param mask The mask to be applied to the value read at @p offset.  * @param shift The shift to be applied after masking; if positive, a right  * shift will be applied, if negative, a left shift.  * @param value The read destination; the parsed value will be OR'd with the  * current contents of @p value.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_read_offset
parameter_list|(
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
parameter_list|,
name|struct
name|bhnd_nvram_io
modifier|*
name|data
parameter_list|,
name|bhnd_nvram_type
name|type
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|uint32_t
name|mask
parameter_list|,
name|int8_t
name|shift
parameter_list|,
name|uint32_t
modifier|*
name|value
parameter_list|)
block|{
name|union
name|bhnd_nvram_sprom_storage
name|scratch
decl_stmt|;
name|int
name|error
decl_stmt|;
define|#
directive|define
name|NV_PARSE_INT
parameter_list|(
name|_widen
parameter_list|,
name|_repr
parameter_list|,
name|_swap
parameter_list|)
value|do {	\
comment|/* Perform read */
value|\ 	error = bhnd_nvram_io_read(data, offset,		\&scratch._repr[0], sizeof(scratch._repr[0]));	\ 	if (error) {						\ 		BHND_NV_LOG("error reading %s SPROM offset "	\ 		    "%#zx: %d\n", var->name, offset, error);	\ 		return (EFTYPE);				\ 	}							\ 								\
comment|/* Swap to host byte order */
value|\ 	scratch._repr[0] = _swap(scratch._repr[0]);		\ 								\
comment|/* Mask and shift the value */
value|\ 	scratch._repr[0]&= mask;				\ 	if (shift> 0) {					\ 		scratch. _repr[0]>>= shift;			\ 	} else if (shift< 0) {					\ 		scratch. _repr[0]<<= -shift;			\ 	}							\ 								\
comment|/* Widen to 32-bit representation and OR with current	\ 	 * value */
value|\ 	(*value) |= (_widen)scratch._repr[0];			\ } while(0)
comment|/* Apply mask/shift and widen to a common 32bit representation */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_UINT8
case|:
name|NV_PARSE_INT
argument_list|(
name|uint32_t
argument_list|,
name|u8
argument_list|,	)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT16
case|:
name|NV_PARSE_INT
argument_list|(
name|uint32_t
argument_list|,
name|u16
argument_list|,
name|le16toh
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT32
case|:
name|NV_PARSE_INT
argument_list|(
name|uint32_t
argument_list|,
name|u32
argument_list|,
name|le32toh
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_INT8
case|:
name|NV_PARSE_INT
argument_list|(
name|int32_t
argument_list|,
name|i8
argument_list|,	)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_INT16
case|:
name|NV_PARSE_INT
argument_list|(
name|int32_t
argument_list|,
name|i16
argument_list|,
name|le16toh
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_INT32
case|:
name|NV_PARSE_INT
argument_list|(
name|int32_t
argument_list|,
name|i32
argument_list|,
name|le32toh
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_CHAR
case|:
name|NV_PARSE_INT
argument_list|(
name|uint32_t
argument_list|,
name|u8
argument_list|,	)
expr_stmt|;
break|break;
default|default:
name|BHND_NV_LOG
argument_list|(
literal|"unhandled %s offset type: %d\n"
argument_list|,
name|var
operator|->
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
undef|#
directive|undef
name|NV_PARSE_INT
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read a SPROM variable value from @p io.  *   * @param	state		The SPROM opcode state describing the layout of @p io.  * @param	entry		The variable's SPROM opcode index entry.  * @param	io		The input I/O context.  * @param	storage		Storage to be used with @p val.  * @param[out]	val		Value instance to be initialized with the  *				parsed variable data.  *  * The returned @p val instance will hold a borrowed reference to @p storage,  * and must be copied via bhnd_nvram_val_copy() if it will be referenced beyond  * the lifetime of @p storage.  *  * The caller is responsible for releasing any allocated value state  * via bhnd_nvram_val_release().  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_read_var
parameter_list|(
name|struct
name|bhnd_sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|struct
name|bhnd_sprom_opcode_idx_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|,
name|union
name|bhnd_nvram_sprom_storage
modifier|*
name|storage
parameter_list|,
name|bhnd_nvram_val
modifier|*
name|val
parameter_list|)
block|{
name|union
name|bhnd_nvram_sprom_storage
modifier|*
name|inp
decl_stmt|;
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
decl_stmt|;
name|bhnd_nvram_type
name|var_btype
decl_stmt|;
name|uint32_t
name|intv
decl_stmt|;
name|size_t
name|ilen
decl_stmt|,
name|ipos
decl_stmt|,
name|iwidth
decl_stmt|;
name|size_t
name|nelem
decl_stmt|;
name|bool
name|all_bits_set
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Fetch canonical variable definition */
name|var
operator|=
name|bhnd_nvram_get_vardefn
argument_list|(
name|entry
operator|->
name|vid
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|var
operator|!=
name|NULL
argument_list|,
operator|(
literal|"invalid entry"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Fetch the array length from the SPROM variable definition. 	 * 	 * This generally be identical to the array length provided by the 	 * canonical NVRAM variable definition, but some SPROM layouts may 	 * define a smaller element count. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_eval_var
argument_list|(
name|state
argument_list|,
name|entry
argument_list|)
operator|)
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"variable evaluation failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|nelem
operator|=
name|state
operator|->
name|var
operator|.
name|nelem
expr_stmt|;
if|if
condition|(
name|nelem
operator|>
name|var
operator|->
name|nelem
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"SPROM array element count %zu cannot be "
literal|"represented by '%s' element count of %hhu\n"
argument_list|,
name|nelem
argument_list|,
name|var
operator|->
name|name
argument_list|,
name|var
operator|->
name|nelem
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
comment|/* Fetch the var's base element type */
name|var_btype
operator|=
name|bhnd_nvram_base_type
argument_list|(
name|var
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* Calculate total byte length of the native encoding */
if|if
condition|(
operator|(
name|iwidth
operator|=
name|bhnd_nvram_value_size
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|var_btype
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* SPROM does not use (and we do not support) decoding of 		 * variable-width data types */
name|BHND_NV_LOG
argument_list|(
literal|"invalid SPROM data type: %d"
argument_list|,
name|var
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
name|ilen
operator|=
name|nelem
operator|*
name|iwidth
expr_stmt|;
comment|/* Decode into our caller's local storage */
name|inp
operator|=
name|storage
expr_stmt|;
if|if
condition|(
name|ilen
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|storage
argument_list|)
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error decoding '%s', SPROM_ARRAY_MAXLEN "
literal|"incorrect\n"
argument_list|,
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
comment|/* Zero-initialize our decode buffer; any output elements skipped 	 * during decode should default to zero. */
name|memset
argument_list|(
name|inp
argument_list|,
literal|0
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
comment|/* 	 * Decode the SPROM data, iteratively decoding up to nelem values. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_seek
argument_list|(
name|state
argument_list|,
name|entry
argument_list|)
operator|)
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"variable seek failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ipos
operator|=
literal|0
expr_stmt|;
name|intv
operator|=
literal|0x0
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|flags
operator|&
name|BHND_NVRAM_VF_IGNALL1
condition|)
name|all_bits_set
operator|=
name|true
expr_stmt|;
else|else
name|all_bits_set
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|(
name|error
operator|=
name|bhnd_sprom_opcode_next_binding
argument_list|(
name|state
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|bhnd_sprom_opcode_bind
modifier|*
name|binding
decl_stmt|;
name|bhnd_sprom_opcode_var
modifier|*
name|binding_var
decl_stmt|;
name|bhnd_nvram_type
name|intv_type
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|size_t
name|nbyte
decl_stmt|;
name|uint32_t
name|skip_in_bytes
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|state
operator|->
name|var_state
operator|>=
name|SPROM_OPCODE_VAR_STATE_OPEN
argument_list|,
operator|(
literal|"invalid var state"
operator|)
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|state
operator|->
name|var
operator|.
name|have_bind
argument_list|,
operator|(
literal|"invalid bind state"
operator|)
argument_list|)
expr_stmt|;
name|binding_var
operator|=
operator|&
name|state
operator|->
name|var
expr_stmt|;
name|binding
operator|=
operator|&
name|state
operator|->
name|var
operator|.
name|bind
expr_stmt|;
if|if
condition|(
name|ipos
operator|>=
name|nelem
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"output skip %u positioned "
literal|"%zu beyond nelem %zu\n"
argument_list|,
name|binding
operator|->
name|skip_out
argument_list|,
name|ipos
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Calculate input skip bytes for this binding */
name|skip_in_bytes
operator|=
name|binding
operator|->
name|skip_in
expr_stmt|;
name|error
operator|=
name|bhnd_sprom_opcode_apply_scale
argument_list|(
name|state
argument_list|,
operator|&
name|skip_in_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Bind */
name|offset
operator|=
name|state
operator|->
name|offset
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|binding
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* Read the offset value, OR'ing with the current 			 * value of intv */
name|error
operator|=
name|bhnd_nvram_sprom_read_offset
argument_list|(
name|var
argument_list|,
name|io
argument_list|,
name|binding_var
operator|->
name|base_type
argument_list|,
name|offset
argument_list|,
name|binding_var
operator|->
name|mask
argument_list|,
name|binding_var
operator|->
name|shift
argument_list|,
operator|&
name|intv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* If IGNALL1, record whether value does not have 			 * all bits set. */
if|if
condition|(
name|var
operator|->
name|flags
operator|&
name|BHND_NVRAM_VF_IGNALL1
operator|&&
name|all_bits_set
condition|)
block|{
name|uint32_t
name|all1
decl_stmt|;
name|all1
operator|=
name|binding_var
operator|->
name|mask
expr_stmt|;
if|if
condition|(
name|binding_var
operator|->
name|shift
operator|>
literal|0
condition|)
name|all1
operator|>>=
name|binding_var
operator|->
name|shift
expr_stmt|;
elseif|else
if|if
condition|(
name|binding_var
operator|->
name|shift
operator|<
literal|0
condition|)
name|all1
operator|<<=
operator|-
name|binding_var
operator|->
name|shift
expr_stmt|;
if|if
condition|(
operator|(
name|intv
operator|&
name|all1
operator|)
operator|!=
name|all1
condition|)
name|all_bits_set
operator|=
name|false
expr_stmt|;
block|}
comment|/* Adjust input position; this was already verified to 			 * not overflow/underflow during SPROM opcode 			 * evaluation */
if|if
condition|(
name|binding
operator|->
name|skip_in_negative
condition|)
block|{
name|offset
operator|-=
name|skip_in_bytes
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|+=
name|skip_in_bytes
expr_stmt|;
block|}
comment|/* Skip writing to inp if additional bindings are 			 * required to fully populate intv */
if|if
condition|(
name|binding
operator|->
name|skip_out
operator|==
literal|0
condition|)
continue|continue;
comment|/* We use bhnd_nvram_value_coerce() to perform 			 * overflow-checked coercion from the widened 			 * uint32/int32 intv value to the requested output 			 * type */
if|if
condition|(
name|bhnd_nvram_is_signed_type
argument_list|(
name|var_btype
argument_list|)
condition|)
name|intv_type
operator|=
name|BHND_NVRAM_TYPE_INT32
expr_stmt|;
else|else
name|intv_type
operator|=
name|BHND_NVRAM_TYPE_UINT32
expr_stmt|;
comment|/* Calculate address of the current element output 			 * position */
name|ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|inp
operator|+
operator|(
name|iwidth
operator|*
name|ipos
operator|)
expr_stmt|;
comment|/* Perform coercion of the array element */
name|nbyte
operator|=
name|iwidth
expr_stmt|;
name|error
operator|=
name|bhnd_nvram_value_coerce
argument_list|(
operator|&
name|intv
argument_list|,
sizeof|sizeof
argument_list|(
name|intv
argument_list|)
argument_list|,
name|intv_type
argument_list|,
name|ptr
argument_list|,
operator|&
name|nbyte
argument_list|,
name|var_btype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Clear temporary state */
name|intv
operator|=
literal|0x0
expr_stmt|;
comment|/* Advance output position */
if|if
condition|(
name|SIZE_MAX
operator|-
name|binding
operator|->
name|skip_out
operator|<
name|ipos
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"output skip %u would overflow "
literal|"%zu\n"
argument_list|,
name|binding
operator|->
name|skip_out
argument_list|,
name|ipos
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ipos
operator|+=
name|binding
operator|->
name|skip_out
expr_stmt|;
block|}
block|}
comment|/* Did we iterate all bindings until hitting end of the variable 	 * definition? */
name|BHND_NV_ASSERT
argument_list|(
name|error
operator|!=
literal|0
argument_list|,
operator|(
literal|"loop terminated early"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* If marked IGNALL1 and all bits are set, treat variable as 	 * unavailable */
if|if
condition|(
operator|(
name|var
operator|->
name|flags
operator|&
name|BHND_NVRAM_VF_IGNALL1
operator|)
operator|&&
name|all_bits_set
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Provide value wrapper */
return|return
operator|(
name|bhnd_nvram_val_init
argument_list|(
name|val
argument_list|,
name|var
operator|->
name|fmt
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|var
operator|->
name|type
argument_list|,
name|BHND_NVRAM_VAL_BORROW_DATA
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Common variable decoding; fetches and decodes variable to @p val,  * using @p storage for actual data storage.  *   * The returned @p val instance will hold a borrowed reference to @p storage,  * and must be copied via bhnd_nvram_val_copy() if it will be referenced beyond  * the lifetime of @p storage.  *  * The caller is responsible for releasing any allocated value state  * via bhnd_nvram_val_release().  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_getvar_common
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|,
name|union
name|bhnd_nvram_sprom_storage
modifier|*
name|storage
parameter_list|,
name|bhnd_nvram_val
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|bhnd_nvram_sprom
modifier|*
name|sp
decl_stmt|;
name|bhnd_sprom_opcode_idx_entry
modifier|*
name|entry
decl_stmt|;
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
decl_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|cookiep
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL variable cookiep"
operator|)
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|(
expr|struct
name|bhnd_nvram_sprom
operator|*
operator|)
name|nv
expr_stmt|;
name|entry
operator|=
name|cookiep
expr_stmt|;
comment|/* Fetch canonical variable definition */
name|var
operator|=
name|SPROM_COOKIE_TO_NVRAM_VAR
argument_list|(
name|cookiep
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|var
operator|!=
name|NULL
argument_list|,
operator|(
literal|"invalid cookiep %p"
operator|,
name|cookiep
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bhnd_nvram_sprom_read_var
argument_list|(
operator|&
name|sp
operator|->
name|state
argument_list|,
name|entry
argument_list|,
name|sp
operator|->
name|data
argument_list|,
name|storage
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_getvar_order
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
name|cookiep1
parameter_list|,
name|void
modifier|*
name|cookiep2
parameter_list|)
block|{
name|struct
name|bhnd_sprom_opcode_idx_entry
modifier|*
name|e1
decl_stmt|,
modifier|*
name|e2
decl_stmt|;
name|e1
operator|=
name|cookiep1
expr_stmt|;
name|e2
operator|=
name|cookiep2
expr_stmt|;
comment|/* Use the index entry order; this matches the order of variables 	 * returned via bhnd_nvram_sprom_next() */
if|if
condition|(
name|e1
operator|<
name|e2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|e1
operator|>
name|e2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_getvar
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
block|{
name|bhnd_nvram_val
name|val
decl_stmt|;
name|union
name|bhnd_nvram_sprom_storage
name|storage
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Decode variable to a new value instance */
name|error
operator|=
name|bhnd_nvram_sprom_getvar_common
argument_list|(
name|nv
argument_list|,
name|cookiep
argument_list|,
operator|&
name|storage
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Perform value coercion */
name|error
operator|=
name|bhnd_nvram_val_encode
argument_list|(
operator|&
name|val
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|otype
argument_list|)
expr_stmt|;
comment|/* Clean up */
name|bhnd_nvram_val_release
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_copy_val
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|,
name|bhnd_nvram_val
modifier|*
modifier|*
name|value
parameter_list|)
block|{
name|bhnd_nvram_val
name|val
decl_stmt|;
name|union
name|bhnd_nvram_sprom_storage
name|storage
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Decode variable to a new value instance */
name|error
operator|=
name|bhnd_nvram_sprom_getvar_common
argument_list|(
name|nv
argument_list|,
name|cookiep
argument_list|,
operator|&
name|storage
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Attempt to copy to heap */
operator|*
name|value
operator|=
name|bhnd_nvram_val_copy
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
name|bhnd_nvram_val_release
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|value
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|bhnd_nvram_sprom_getvar_ptr
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|bhnd_nvram_type
modifier|*
name|type
parameter_list|)
block|{
comment|/* Unsupported */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|bhnd_nvram_sprom_getvar_name
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
decl_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|cookiep
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL variable cookiep"
operator|)
argument_list|)
expr_stmt|;
name|var
operator|=
name|SPROM_COOKIE_TO_NVRAM_VAR
argument_list|(
name|cookiep
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|var
operator|!=
name|NULL
argument_list|,
operator|(
literal|"invalid cookiep %p"
operator|,
name|cookiep
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|var
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_filter_setvar
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
name|bhnd_nvram_val
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|bhnd_nvram_sprom
modifier|*
name|sp
decl_stmt|;
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
decl_stmt|;
name|bhnd_sprom_opcode_idx_entry
modifier|*
name|entry
decl_stmt|;
name|bhnd_nvram_val
modifier|*
name|spval
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sp
operator|=
operator|(
expr|struct
name|bhnd_nvram_sprom
operator|*
operator|)
name|nv
expr_stmt|;
comment|/* Is this an externally immutable variable name? */
if|if
condition|(
name|bhnd_sprom_is_external_immutable
argument_list|(
name|name
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Variable must be defined in our SPROM layout */
if|if
condition|(
operator|(
name|entry
operator|=
name|bhnd_sprom_opcode_index_find
argument_list|(
operator|&
name|sp
operator|->
name|state
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|var
operator|=
name|bhnd_nvram_get_vardefn
argument_list|(
name|entry
operator|->
name|vid
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|var
operator|!=
name|NULL
argument_list|,
operator|(
literal|"missing variable definition"
operator|)
argument_list|)
expr_stmt|;
comment|/* Value must be convertible to the native variable type */
name|error
operator|=
name|bhnd_nvram_val_convert_new
argument_list|(
operator|&
name|spval
argument_list|,
name|var
operator|->
name|fmt
argument_list|,
name|value
argument_list|,
name|BHND_NVRAM_VAL_DYNAMIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Value must be encodeable by our SPROM layout */
name|error
operator|=
name|bhnd_nvram_sprom_write_var
argument_list|(
operator|&
name|sp
operator|->
name|state
argument_list|,
name|entry
argument_list|,
name|spval
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|bhnd_nvram_val_release
argument_list|(
name|spval
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Success. Transfer our ownership of the converted value to the 	 * caller */
operator|*
name|result
operator|=
name|spval
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_filter_unsetvar
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|bhnd_nvram_sprom
modifier|*
name|sp
decl_stmt|;
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
decl_stmt|;
name|bhnd_sprom_opcode_idx_entry
modifier|*
name|entry
decl_stmt|;
name|sp
operator|=
operator|(
expr|struct
name|bhnd_nvram_sprom
operator|*
operator|)
name|nv
expr_stmt|;
comment|/* Is this an externally immutable variable name? */
if|if
condition|(
name|bhnd_sprom_is_external_immutable
argument_list|(
name|name
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Variable must be defined in our SPROM layout */
if|if
condition|(
operator|(
name|entry
operator|=
name|bhnd_sprom_opcode_index_find
argument_list|(
operator|&
name|sp
operator|->
name|state
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|var
operator|=
name|bhnd_nvram_get_vardefn
argument_list|(
name|entry
operator|->
name|vid
argument_list|)
expr_stmt|;
comment|/* Variable must be capable of representing a NULL/deleted value. 	 *  	 * Since SPROM's layout is fixed, this requires IGNALL -- if 	 * all bits are set, an IGNALL variable is treated as unset. */
if|if
condition|(
operator|!
operator|(
name|var
operator|->
name|flags
operator|&
name|BHND_NVRAM_VF_IGNALL1
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if @p name represents a special immutable variable name  * (e.g. sromrev) that cannot be updated in an SPROM existing image.  *   * @param name The name to check.  */
end_comment

begin_function
specifier|static
name|bool
name|bhnd_sprom_is_external_immutable
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* The layout revision is immutable and cannot be changed */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|BHND_NVAR_SROMREV
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

end_unit

