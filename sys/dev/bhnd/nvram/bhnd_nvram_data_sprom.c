begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Landon Fuller<landonf@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/_inttypes.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_KERNEL */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_include
include|#
directive|include
file|"bhnd_nvram_private.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_datavar.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_data_spromvar.h"
end_include

begin_comment
comment|/*  * BHND SPROM NVRAM data class  *  * The SPROM data format is a fixed-layout, non-self-descriptive binary format,  * used on Broadcom wireless and wired adapters, that provides a subset of the  * variables defined by Broadcom SoC NVRAM formats.  */
end_comment

begin_macro
name|BHND_NVRAM_DATA_CLASS_DEFN
argument_list|(
argument|sprom
argument_list|,
literal|"Broadcom SPROM"
argument_list|,
argument|sizeof(struct bhnd_nvram_sprom)
argument_list|)
end_macro

begin_function_decl
specifier|static
name|int
name|sprom_sort_idx
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sprom_opcode_state_init
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
specifier|const
name|struct
name|bhnd_sprom_layout
modifier|*
name|layout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sprom_opcode_state_reset
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sprom_opcode_state_seek
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|struct
name|sprom_opcode_idx
modifier|*
name|indexed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sprom_opcode_next_var
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sprom_opcode_parse_var
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|struct
name|sprom_opcode_idx
modifier|*
name|indexed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sprom_opcode_next_binding
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sprom_opcode_set_type
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|bhnd_nvram_type
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sprom_opcode_set_var
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|size_t
name|vid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sprom_opcode_clear_var
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sprom_opcode_flush_bind
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sprom_opcode_read_opval32
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint8_t
name|type
parameter_list|,
name|uint32_t
modifier|*
name|opval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sprom_opcode_apply_scale
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint32_t
modifier|*
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sprom_opcode_step
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint8_t
modifier|*
name|opcode
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SPROM_OP_BAD
parameter_list|(
name|_state
parameter_list|,
name|_fmt
parameter_list|,
modifier|...
parameter_list|)
define|\
value|BHND_NV_LOG("bad encoding at %td: " _fmt,			\ 	    (_state)->input - (_state)->layout->bindings, ##__VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|SPROM_COOKIE_TO_NVRAM
parameter_list|(
name|_cookie
parameter_list|)
define|\
value|bhnd_nvram_get_vardefn(((struct sprom_opcode_idx *)_cookie)->vid)
end_define

begin_comment
comment|/**  * Read the magic value from @p io, and verify that it matches  * the @p layout's expected magic value.  *   * If @p layout does not defined a magic value, @p magic is set to 0x0  * and success is returned.  *   * @param	io	An I/O context mapping the SPROM data to be identified.  * @param	layout	The SPROM layout against which @p io should be verified.  * @param[out]	magic	On success, the SPROM magic value.  *   * @retval 0		success  * @retval non-zero	If checking @p io otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_check_magic
parameter_list|(
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|,
specifier|const
name|struct
name|bhnd_sprom_layout
modifier|*
name|layout
parameter_list|,
name|uint16_t
modifier|*
name|magic
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Skip if layout does not define a magic value */
if|if
condition|(
name|layout
operator|->
name|flags
operator|&
name|SPROM_LAYOUT_MAGIC_NONE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Read the magic value */
name|error
operator|=
name|bhnd_nvram_io_read
argument_list|(
name|io
argument_list|,
name|layout
operator|->
name|magic_offset
argument_list|,
name|magic
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|magic
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|magic
operator|=
name|le16toh
argument_list|(
operator|*
name|magic
argument_list|)
expr_stmt|;
comment|/* If the signature does not match, skip to next layout */
if|if
condition|(
operator|*
name|magic
operator|!=
name|layout
operator|->
name|magic_value
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Attempt to identify the format of the SPROM data mapped by @p io.  *  * The SPROM data format does not provide any identifying information at a  * known offset, instead requiring that we iterate over the known SPROM image  * sizes until we are able to compute a valid checksum (and, for later  * revisions, validate a signature at a revision-specific offset).  *  * @param	io	An I/O context mapping the SPROM data to be identified.  * @param[out]	ident	On success, the identified SPROM layout.  * @param[out]	shadow	On success, a correctly sized iobuf instance mapping  *			a copy of the identified SPROM image. The caller is  *			responsible for deallocating this instance via  *			bhnd_nvram_io_free()  *  * @retval 0		success  * @retval non-zero	If identifying @p io otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_ident
parameter_list|(
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|,
specifier|const
name|struct
name|bhnd_sprom_layout
modifier|*
modifier|*
name|ident
parameter_list|,
name|struct
name|bhnd_nvram_io
modifier|*
modifier|*
name|shadow
parameter_list|)
block|{
name|struct
name|bhnd_nvram_io
modifier|*
name|buf
decl_stmt|;
name|uint8_t
name|crc
decl_stmt|;
name|size_t
name|crc_errors
decl_stmt|;
name|size_t
name|sprom_sz_max
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Find the largest SPROM layout size */
name|sprom_sz_max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bhnd_sprom_num_layouts
condition|;
name|i
operator|++
control|)
block|{
name|sprom_sz_max
operator|=
name|bhnd_nv_ummax
argument_list|(
name|sprom_sz_max
argument_list|,
name|bhnd_sprom_layouts
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate backing buffer and initialize CRC state */
name|buf
operator|=
name|bhnd_nvram_iobuf_empty
argument_list|(
literal|0
argument_list|,
name|sprom_sz_max
argument_list|)
expr_stmt|;
name|crc
operator|=
name|BHND_NVRAM_CRC8_INITIAL
expr_stmt|;
name|crc_errors
operator|=
literal|0
expr_stmt|;
comment|/* We iterate the SPROM layouts smallest to largest, allowing us to 	 * perform incremental checksum calculation */
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bhnd_sprom_num_layouts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|bhnd_sprom_layout
modifier|*
name|layout
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|nbytes
decl_stmt|,
name|nr
decl_stmt|;
name|uint16_t
name|magic
decl_stmt|;
name|uint8_t
name|srev
decl_stmt|;
name|bool
name|crc_valid
decl_stmt|;
name|bool
name|have_magic
decl_stmt|;
name|layout
operator|=
operator|&
name|bhnd_sprom_layouts
index|[
name|i
index|]
expr_stmt|;
name|nbytes
operator|=
name|bhnd_nvram_io_getsize
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|layout
operator|->
name|flags
operator|&
name|SPROM_LAYOUT_MAGIC_NONE
operator|)
condition|)
block|{
name|have_magic
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|have_magic
operator|=
name|true
expr_stmt|;
block|}
comment|/* Layout instances must be ordered from smallest to largest by 		 * the nvram_map compiler */
if|if
condition|(
name|nbytes
operator|>
name|layout
operator|->
name|size
condition|)
name|BHND_NV_PANIC
argument_list|(
literal|"SPROM layout is defined out-of-order"
argument_list|)
expr_stmt|;
comment|/* Calculate number of additional bytes to be read */
name|nr
operator|=
name|layout
operator|->
name|size
operator|-
name|nbytes
expr_stmt|;
comment|/* Adjust the buffer size and fetch a write pointer */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_io_setsize
argument_list|(
name|buf
argument_list|,
name|layout
operator|->
name|size
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
name|error
operator|=
name|bhnd_nvram_io_write_ptr
argument_list|(
name|buf
argument_list|,
name|nbytes
argument_list|,
operator|&
name|ptr
argument_list|,
name|nr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
comment|/* Read image data and update CRC (errors are reported 		 * after the signature check) */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_io_read
argument_list|(
name|io
argument_list|,
name|nbytes
argument_list|,
name|ptr
argument_list|,
name|nr
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
name|crc
operator|=
name|bhnd_nvram_crc8
argument_list|(
name|ptr
argument_list|,
name|nr
argument_list|,
name|crc
argument_list|)
expr_stmt|;
name|crc_valid
operator|=
operator|(
name|crc
operator|==
name|BHND_NVRAM_CRC8_VALID
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|crc_valid
condition|)
name|crc_errors
operator|++
expr_stmt|;
comment|/* Fetch SPROM revision */
name|error
operator|=
name|bhnd_nvram_io_read
argument_list|(
name|buf
argument_list|,
name|layout
operator|->
name|srev_offset
argument_list|,
operator|&
name|srev
argument_list|,
sizeof|sizeof
argument_list|(
name|srev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
comment|/* Early sromrev 1 devices (specifically some BCM440x enet 		 * cards) are reported to have been incorrectly programmed 		 * with a revision of 0x10. */
if|if
condition|(
name|layout
operator|->
name|rev
operator|==
literal|1
operator|&&
name|srev
operator|==
literal|0x10
condition|)
name|srev
operator|=
literal|0x1
expr_stmt|;
comment|/* Check revision against the layout definition */
if|if
condition|(
name|srev
operator|!=
name|layout
operator|->
name|rev
condition|)
continue|continue;
comment|/* Check the magic value, skipping to the next layout on 		 * failure. */
name|error
operator|=
name|bhnd_nvram_sprom_check_magic
argument_list|(
name|buf
argument_list|,
name|layout
argument_list|,
operator|&
name|magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* If the CRC is was valid, log the mismatch */
if|if
condition|(
name|crc_valid
operator|||
name|BHND_NV_VERBOSE
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"invalid sprom %hhu signature: "
literal|"0x%hx (expected 0x%hx)\n"
argument_list|,
name|srev
argument_list|,
name|magic
argument_list|,
name|layout
operator|->
name|magic_value
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
continue|continue;
block|}
comment|/* Check for an earlier CRC error */
if|if
condition|(
operator|!
name|crc_valid
condition|)
block|{
comment|/* If the magic check succeeded, then we may just have 			 * data corruption -- log the CRC error */
if|if
condition|(
name|have_magic
operator|||
name|BHND_NV_VERBOSE
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"sprom %hhu CRC error (crc=%#hhx, "
literal|"expected=%#x)\n"
argument_list|,
name|srev
argument_list|,
name|crc
argument_list|,
name|BHND_NVRAM_CRC8_VALID
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Identified */
operator|*
name|shadow
operator|=
name|buf
expr_stmt|;
operator|*
name|ident
operator|=
name|layout
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* No match -- set error and fallthrough */
name|error
operator|=
name|ENXIO
expr_stmt|;
if|if
condition|(
name|crc_errors
operator|>
literal|0
operator|&&
name|BHND_NV_VERBOSE
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"sprom parsing failed with %zu CRC errors\n"
argument_list|,
name|crc_errors
argument_list|)
expr_stmt|;
block|}
name|failed
label|:
name|bhnd_nvram_io_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_probe
parameter_list|(
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_sprom_layout
modifier|*
name|layout
decl_stmt|;
name|struct
name|bhnd_nvram_io
modifier|*
name|shadow
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Try to parse the input */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_sprom_ident
argument_list|(
name|io
argument_list|,
operator|&
name|layout
argument_list|,
operator|&
name|shadow
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Clean up the shadow iobuf */
name|bhnd_nvram_io_free
argument_list|(
name|shadow
argument_list|)
expr_stmt|;
return|return
operator|(
name|BHND_NVRAM_DATA_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_new
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|struct
name|bhnd_nvram_io
modifier|*
name|io
parameter_list|)
block|{
name|struct
name|bhnd_nvram_sprom
modifier|*
name|sp
decl_stmt|;
name|size_t
name|num_vars
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sp
operator|=
operator|(
expr|struct
name|bhnd_nvram_sprom
operator|*
operator|)
name|nv
expr_stmt|;
comment|/* Identify the SPROM input data */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_sprom_ident
argument_list|(
name|io
argument_list|,
operator|&
name|sp
operator|->
name|layout
argument_list|,
operator|&
name|sp
operator|->
name|data
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
comment|/* Initialize SPROM binding eval state */
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_state_init
argument_list|(
operator|&
name|sp
operator|->
name|state
argument_list|,
name|sp
operator|->
name|layout
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
comment|/* Allocate our opcode index */
name|sp
operator|->
name|num_idx
operator|=
name|sp
operator|->
name|layout
operator|->
name|num_vars
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|idx
operator|=
name|bhnd_nv_calloc
argument_list|(
name|sp
operator|->
name|num_idx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sp
operator|->
name|idx
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
comment|/* Parse out index entries from our stateful opcode stream */
for|for
control|(
name|num_vars
operator|=
literal|0
init|;
name|num_vars
operator|<
name|sp
operator|->
name|num_idx
condition|;
name|num_vars
operator|++
control|)
block|{
name|size_t
name|opcodes
decl_stmt|;
comment|/* Seek to next entry */
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_next_var
argument_list|(
operator|&
name|sp
operator|->
name|state
argument_list|)
operator|)
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
operator|&
name|sp
operator|->
name|state
argument_list|,
literal|"error reading expected variable entry: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* We limit the SPROM index representations to the minimal 		 * type widths capable of covering all known layouts */
comment|/* Save SPROM image offset */
if|if
condition|(
name|sp
operator|->
name|state
operator|.
name|offset
operator|>
name|UINT16_MAX
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
operator|&
name|sp
operator|->
name|state
argument_list|,
literal|"cannot index large offset %u\n"
argument_list|,
name|sp
operator|->
name|state
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|idx
index|[
name|num_vars
index|]
operator|.
name|offset
operator|=
name|sp
operator|->
name|state
operator|.
name|offset
expr_stmt|;
comment|/* Save current variable ID */
if|if
condition|(
name|sp
operator|->
name|state
operator|.
name|vid
operator|>
name|UINT16_MAX
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
operator|&
name|sp
operator|->
name|state
argument_list|,
literal|"cannot index large vid %zu\n"
argument_list|,
name|sp
operator|->
name|state
operator|.
name|vid
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|idx
index|[
name|num_vars
index|]
operator|.
name|vid
operator|=
name|sp
operator|->
name|state
operator|.
name|vid
expr_stmt|;
comment|/* Save opcode position */
name|opcodes
operator|=
operator|(
name|sp
operator|->
name|state
operator|.
name|input
operator|-
name|sp
operator|->
name|layout
operator|->
name|bindings
operator|)
expr_stmt|;
if|if
condition|(
name|opcodes
operator|>
name|UINT16_MAX
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
operator|&
name|sp
operator|->
name|state
argument_list|,
literal|"cannot index large opcode offset %zu\n"
argument_list|,
name|opcodes
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|idx
index|[
name|num_vars
index|]
operator|.
name|opcodes
operator|=
name|opcodes
expr_stmt|;
block|}
comment|/* Should have reached end of binding table; next read must return 	 * ENOENT */
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_next_var
argument_list|(
operator|&
name|sp
operator|->
name|state
argument_list|)
operator|)
operator|!=
name|ENOENT
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"expected EOF parsing binding table: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* Sort index by variable ID, ascending */
name|qsort
argument_list|(
name|sp
operator|->
name|idx
argument_list|,
name|sp
operator|->
name|num_idx
argument_list|,
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|idx
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|sprom_sort_idx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
if|if
condition|(
name|sp
operator|->
name|data
operator|!=
name|NULL
condition|)
name|bhnd_nvram_io_free
argument_list|(
name|sp
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|idx
operator|!=
name|NULL
condition|)
name|bhnd_nv_free
argument_list|(
name|sp
operator|->
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* sort function for sprom_opcode_idx values */
end_comment

begin_function
specifier|static
name|int
name|sprom_sort_idx
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
specifier|const
name|struct
name|sprom_opcode_idx
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|l
operator|=
name|lhs
expr_stmt|;
name|r
operator|=
name|rhs
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|vid
operator|<
name|r
operator|->
name|vid
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|l
operator|->
name|vid
operator|>
name|r
operator|->
name|vid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bhnd_nvram_sprom_free
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|)
block|{
name|struct
name|bhnd_nvram_sprom
modifier|*
name|sp
init|=
operator|(
expr|struct
name|bhnd_nvram_sprom
operator|*
operator|)
name|nv
decl_stmt|;
name|bhnd_nvram_io_free
argument_list|(
name|sp
operator|->
name|data
argument_list|)
expr_stmt|;
name|bhnd_nv_free
argument_list|(
name|sp
operator|->
name|idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bhnd_nvram_plist
modifier|*
name|bhnd_nvram_sprom_options
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|size_t
name|bhnd_nvram_sprom_count
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|)
block|{
name|struct
name|bhnd_nvram_sprom
modifier|*
name|sprom
init|=
operator|(
expr|struct
name|bhnd_nvram_sprom
operator|*
operator|)
name|nv
decl_stmt|;
return|return
operator|(
name|sprom
operator|->
name|layout
operator|->
name|num_vars
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_size
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|struct
name|bhnd_nvram_sprom
modifier|*
name|sprom
init|=
operator|(
expr|struct
name|bhnd_nvram_sprom
operator|*
operator|)
name|nv
decl_stmt|;
comment|/* The serialized form will be identical in length 	 * to our backing buffer representation */
operator|*
name|size
operator|=
name|bhnd_nvram_io_getsize
argument_list|(
name|sprom
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_serialize
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|bhnd_nvram_sprom
modifier|*
name|sprom
decl_stmt|;
name|size_t
name|limit
decl_stmt|,
name|req_len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sprom
operator|=
operator|(
expr|struct
name|bhnd_nvram_sprom
operator|*
operator|)
name|nv
expr_stmt|;
name|limit
operator|=
operator|*
name|len
expr_stmt|;
comment|/* Provide the required size */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_sprom_size
argument_list|(
name|nv
argument_list|,
operator|&
name|req_len
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|len
operator|=
name|req_len
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|len
operator|>
name|limit
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Write to the output buffer */
return|return
operator|(
name|bhnd_nvram_io_read
argument_list|(
name|sprom
operator|->
name|data
argument_list|,
literal|0x0
argument_list|,
name|buf
argument_list|,
operator|*
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|bhnd_nvram_sprom_caps
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|)
block|{
return|return
operator|(
name|BHND_NVRAM_DATA_CAP_INDEXED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|bhnd_nvram_sprom_next
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|bhnd_nvram_sprom
modifier|*
name|sp
decl_stmt|;
name|struct
name|sprom_opcode_idx
modifier|*
name|idx_entry
decl_stmt|;
name|size_t
name|idx_next
decl_stmt|;
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
decl_stmt|;
name|sp
operator|=
operator|(
expr|struct
name|bhnd_nvram_sprom
operator|*
operator|)
name|nv
expr_stmt|;
comment|/* Seek to appropriate starting point */
if|if
condition|(
operator|*
name|cookiep
operator|==
name|NULL
condition|)
block|{
comment|/* Start search at first index entry */
name|idx_next
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Determine current index position */
name|idx_entry
operator|=
operator|*
name|cookiep
expr_stmt|;
name|idx_next
operator|=
call|(
name|size_t
call|)
argument_list|(
name|idx_entry
operator|-
name|sp
operator|->
name|idx
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|idx_next
operator|<
name|sp
operator|->
name|num_idx
argument_list|,
operator|(
literal|"invalid index %zu; corrupt cookie?"
operator|,
name|idx_next
operator|)
argument_list|)
expr_stmt|;
comment|/* Advance to next entry */
name|idx_next
operator|++
expr_stmt|;
comment|/* Check for EOF */
if|if
condition|(
name|idx_next
operator|==
name|sp
operator|->
name|num_idx
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Skip entries that are disabled by virtue of IGNALL1 */
for|for
control|(
init|;
name|idx_next
operator|<
name|sp
operator|->
name|num_idx
condition|;
name|idx_next
operator|++
control|)
block|{
comment|/* Fetch index entry and update cookiep  */
name|idx_entry
operator|=
operator|&
name|sp
operator|->
name|idx
index|[
name|idx_next
index|]
expr_stmt|;
operator|*
name|cookiep
operator|=
name|idx_entry
expr_stmt|;
comment|/* Fetch variable definition */
name|var
operator|=
name|bhnd_nvram_get_vardefn
argument_list|(
name|idx_entry
operator|->
name|vid
argument_list|)
expr_stmt|;
comment|/* We might need to parse the variable's value to determine 		 * whether it should be treated as unset */
if|if
condition|(
name|var
operator|->
name|flags
operator|&
name|BHND_NVRAM_VF_IGNALL1
condition|)
block|{
name|int
name|error
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|error
operator|=
name|bhnd_nvram_sprom_getvar
argument_list|(
name|nv
argument_list|,
operator|*
name|cookiep
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|,
name|var
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_ASSERT
argument_list|(
name|error
operator|==
name|ENOENT
argument_list|,
operator|(
literal|"unexpected "
literal|"error parsing variable: %d"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Found! */
return|return
operator|(
name|var
operator|->
name|name
operator|)
return|;
block|}
comment|/* Reached end of index entries */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* bsearch function used by bhnd_nvram_sprom_find() */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_find_vid_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
specifier|const
name|struct
name|sprom_opcode_idx
modifier|*
name|r
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|l
operator|=
operator|*
operator|(
specifier|const
name|size_t
operator|*
operator|)
name|key
expr_stmt|;
name|r
operator|=
name|rhs
expr_stmt|;
if|if
condition|(
name|l
operator|<
name|r
operator|->
name|vid
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|l
operator|>
name|r
operator|->
name|vid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|bhnd_nvram_sprom_find
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|bhnd_nvram_sprom
modifier|*
name|sp
decl_stmt|;
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
decl_stmt|;
name|size_t
name|vid
decl_stmt|;
name|sp
operator|=
operator|(
expr|struct
name|bhnd_nvram_sprom
operator|*
operator|)
name|nv
expr_stmt|;
comment|/* Determine the variable ID for the given name */
if|if
condition|(
operator|(
name|var
operator|=
name|bhnd_nvram_find_vardefn
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|vid
operator|=
name|bhnd_nvram_get_vardefn_id
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* Search our index for the variable ID */
return|return
operator|(
name|bsearch
argument_list|(
operator|&
name|vid
argument_list|,
name|sp
operator|->
name|idx
argument_list|,
name|sp
operator|->
name|num_idx
argument_list|,
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|idx
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|bhnd_nvram_sprom_find_vid_compare
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read the value of @p type from the SPROM data at @p offset, apply @p mask  * and @p shift, and OR with the existing @p value.  *   * @param sp The SPROM data instance.  * @param var The NVRAM variable definition  * @param type The type to read at @p offset  * @param offset The data offset to be read.  * @param mask The mask to be applied to the value read at @p offset.  * @param shift The shift to be applied after masking; if positive, a right  * shift will be applied, if negative, a left shift.  * @param value The read destination; the parsed value will be OR'd with the  * current contents of @p value.  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_read_offset
parameter_list|(
name|struct
name|bhnd_nvram_sprom
modifier|*
name|sp
parameter_list|,
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
parameter_list|,
name|bhnd_nvram_type
name|type
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|uint32_t
name|mask
parameter_list|,
name|int8_t
name|shift
parameter_list|,
name|union
name|bhnd_nvram_sprom_intv
modifier|*
name|value
parameter_list|)
block|{
name|size_t
name|sp_width
decl_stmt|;
name|int
name|error
decl_stmt|;
union|union
block|{
name|uint8_t
name|u8
decl_stmt|;
name|uint16_t
name|u16
decl_stmt|;
name|uint32_t
name|u32
decl_stmt|;
name|int8_t
name|s8
decl_stmt|;
name|int16_t
name|s16
decl_stmt|;
name|int32_t
name|s32
decl_stmt|;
block|}
name|sp_value
union|;
comment|/* Determine type width */
name|sp_width
operator|=
name|bhnd_nvram_type_width
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp_width
operator|==
literal|0
condition|)
block|{
comment|/* Variable-width types are unsupported */
name|BHND_NV_LOG
argument_list|(
literal|"invalid %s SPROM offset type %d\n"
argument_list|,
name|var
operator|->
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
comment|/* Perform read */
name|error
operator|=
name|bhnd_nvram_io_read
argument_list|(
name|sp
operator|->
name|data
argument_list|,
name|offset
argument_list|,
operator|&
name|sp_value
argument_list|,
name|sp_width
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error reading %s SPROM offset %#zx: %d\n"
argument_list|,
name|var
operator|->
name|name
argument_list|,
name|offset
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
define|#
directive|define
name|NV_PARSE_INT
parameter_list|(
name|_type
parameter_list|,
name|_src
parameter_list|,
name|_dest
parameter_list|,
name|_swap
parameter_list|)
value|do {			\
comment|/* Swap to host byte order */
value|\ 	sp_value. _src = (_type) _swap(sp_value. _src);			\ 									\
comment|/* Mask and shift the value */
value|\ 	sp_value. _src&= mask;				\ 	if (shift> 0) {					\ 		sp_value. _src>>= shift;			\ 	} else if (shift< 0) {				\ 		sp_value. _src<<= -shift;			\ 	}								\ 									\
comment|/* Emit output, widening to 32-bit representation  */
value|\ 	value-> _dest |= sp_value. _src;				\ } while(0)
comment|/* Apply mask/shift and widen to a common 32bit representation */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_UINT8
case|:
name|NV_PARSE_INT
argument_list|(
name|uint8_t
argument_list|,
name|u8
argument_list|,
name|u32
argument_list|,	)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT16
case|:
name|NV_PARSE_INT
argument_list|(
name|uint16_t
argument_list|,
name|u16
argument_list|,
name|u32
argument_list|,
name|le16toh
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT32
case|:
name|NV_PARSE_INT
argument_list|(
name|uint32_t
argument_list|,
name|u32
argument_list|,
name|u32
argument_list|,
name|le32toh
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_INT8
case|:
name|NV_PARSE_INT
argument_list|(
name|int8_t
argument_list|,
name|s8
argument_list|,
name|s32
argument_list|,	)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_INT16
case|:
name|NV_PARSE_INT
argument_list|(
name|int16_t
argument_list|,
name|s16
argument_list|,
name|s32
argument_list|,
name|le16toh
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_INT32
case|:
name|NV_PARSE_INT
argument_list|(
name|int32_t
argument_list|,
name|s32
argument_list|,
name|s32
argument_list|,
name|le32toh
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_CHAR
case|:
name|NV_PARSE_INT
argument_list|(
name|uint8_t
argument_list|,
name|u8
argument_list|,
name|u32
argument_list|,	)
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT64
case|:
case|case
name|BHND_NVRAM_TYPE_INT64
case|:
case|case
name|BHND_NVRAM_TYPE_STRING
case|:
comment|/* fallthrough (unused by SPROM) */
default|default:
name|BHND_NV_LOG
argument_list|(
literal|"unhandled %s offset type: %d\n"
argument_list|,
name|var
operator|->
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Common variable decoding; fetches and decodes variable to @p val,  * using @p storage for actual data storage.  *   * The returned @p val instance will hold a borrowed reference to @p storage,  * and must be copied via bhnd_nvram_val_copy() if it will be referenced beyond  * the lifetime of @p storage.  *  * The caller is responsible for releasing any allocated value state  * via bhnd_nvram_val_release().  */
end_comment

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_getvar_common
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|,
name|union
name|bhnd_nvram_sprom_storage
modifier|*
name|storage
parameter_list|,
name|bhnd_nvram_val
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|bhnd_nvram_sprom
modifier|*
name|sp
decl_stmt|;
name|struct
name|sprom_opcode_idx
modifier|*
name|entry
decl_stmt|;
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
decl_stmt|;
name|union
name|bhnd_nvram_sprom_storage
modifier|*
name|inp
decl_stmt|;
name|bhnd_nvram_type
name|var_btype
decl_stmt|;
name|union
name|bhnd_nvram_sprom_intv
name|intv
decl_stmt|;
name|size_t
name|ilen
decl_stmt|,
name|ipos
decl_stmt|,
name|iwidth
decl_stmt|;
name|size_t
name|nelem
decl_stmt|;
name|bool
name|all_bits_set
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sp
operator|=
operator|(
expr|struct
name|bhnd_nvram_sprom
operator|*
operator|)
name|nv
expr_stmt|;
name|entry
operator|=
name|cookiep
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|cookiep
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL variable cookiep"
operator|)
argument_list|)
expr_stmt|;
comment|/* Fetch canonical variable definition */
name|var
operator|=
name|SPROM_COOKIE_TO_NVRAM
argument_list|(
name|cookiep
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|var
operator|!=
name|NULL
argument_list|,
operator|(
literal|"invalid cookiep %p"
operator|,
name|cookiep
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Fetch the array length from the SPROM variable definition. 	 * 	 * This generally be identical to the array length provided by the 	 * canonical NVRAM variable definition, but some SPROM layouts may 	 * define a smaller element count. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_parse_var
argument_list|(
operator|&
name|sp
operator|->
name|state
argument_list|,
name|entry
argument_list|)
operator|)
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"variable evaluation failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|nelem
operator|=
name|sp
operator|->
name|state
operator|.
name|var
operator|.
name|nelem
expr_stmt|;
if|if
condition|(
name|nelem
operator|>
name|var
operator|->
name|nelem
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"SPROM array element count %zu cannot be "
literal|"represented by '%s' element count of %hhu\n"
argument_list|,
name|nelem
argument_list|,
name|var
operator|->
name|name
argument_list|,
name|var
operator|->
name|nelem
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
comment|/* Fetch the var's base element type */
name|var_btype
operator|=
name|bhnd_nvram_base_type
argument_list|(
name|var
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* Calculate total byte length of the native encoding */
if|if
condition|(
operator|(
name|iwidth
operator|=
name|bhnd_nvram_value_size
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|var_btype
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* SPROM does not use (and we do not support) decoding of 		 * variable-width data types */
name|BHND_NV_LOG
argument_list|(
literal|"invalid SPROM data type: %d"
argument_list|,
name|var
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
name|ilen
operator|=
name|nelem
operator|*
name|iwidth
expr_stmt|;
comment|/* Decode into our caller's local storage */
name|inp
operator|=
name|storage
expr_stmt|;
if|if
condition|(
name|ilen
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|storage
argument_list|)
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error decoding '%s', SPROM_ARRAY_MAXLEN "
literal|"incorrect\n"
argument_list|,
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
comment|/* Zero-initialize our decode buffer; any output elements skipped 	 * during decode should default to zero. */
name|memset
argument_list|(
name|inp
argument_list|,
literal|0
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
comment|/* 	 * Decode the SPROM data, iteratively decoding up to nelem values. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_state_seek
argument_list|(
operator|&
name|sp
operator|->
name|state
argument_list|,
name|entry
argument_list|)
operator|)
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"variable seek failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ipos
operator|=
literal|0
expr_stmt|;
name|intv
operator|.
name|u32
operator|=
literal|0x0
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|flags
operator|&
name|BHND_NVRAM_VF_IGNALL1
condition|)
name|all_bits_set
operator|=
name|true
expr_stmt|;
else|else
name|all_bits_set
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_next_binding
argument_list|(
operator|&
name|sp
operator|->
name|state
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|sprom_opcode_bind
modifier|*
name|binding
decl_stmt|;
name|struct
name|sprom_opcode_var
modifier|*
name|binding_var
decl_stmt|;
name|bhnd_nvram_type
name|intv_type
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|size_t
name|nbyte
decl_stmt|;
name|uint32_t
name|skip_in_bytes
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|sp
operator|->
name|state
operator|.
name|var_state
operator|>=
name|SPROM_OPCODE_VAR_STATE_OPEN
argument_list|,
operator|(
literal|"invalid var state"
operator|)
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|sp
operator|->
name|state
operator|.
name|var
operator|.
name|have_bind
argument_list|,
operator|(
literal|"invalid bind state"
operator|)
argument_list|)
expr_stmt|;
name|binding_var
operator|=
operator|&
name|sp
operator|->
name|state
operator|.
name|var
expr_stmt|;
name|binding
operator|=
operator|&
name|sp
operator|->
name|state
operator|.
name|var
operator|.
name|bind
expr_stmt|;
if|if
condition|(
name|ipos
operator|>=
name|nelem
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"output skip %u positioned "
literal|"%zu beyond nelem %zu\n"
argument_list|,
name|binding
operator|->
name|skip_out
argument_list|,
name|ipos
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Calculate input skip bytes for this binding */
name|skip_in_bytes
operator|=
name|binding
operator|->
name|skip_in
expr_stmt|;
name|error
operator|=
name|sprom_opcode_apply_scale
argument_list|(
operator|&
name|sp
operator|->
name|state
argument_list|,
operator|&
name|skip_in_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Bind */
name|offset
operator|=
name|sp
operator|->
name|state
operator|.
name|offset
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|binding
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* Read the offset value, OR'ing with the current 			 * value of intv */
name|error
operator|=
name|bhnd_nvram_sprom_read_offset
argument_list|(
name|sp
argument_list|,
name|var
argument_list|,
name|binding_var
operator|->
name|base_type
argument_list|,
name|offset
argument_list|,
name|binding_var
operator|->
name|mask
argument_list|,
name|binding_var
operator|->
name|shift
argument_list|,
operator|&
name|intv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* If IGNALL1, record whether value does not have 			 * all bits set. */
if|if
condition|(
name|var
operator|->
name|flags
operator|&
name|BHND_NVRAM_VF_IGNALL1
operator|&&
name|all_bits_set
condition|)
block|{
name|uint32_t
name|all1
decl_stmt|;
name|all1
operator|=
name|binding_var
operator|->
name|mask
expr_stmt|;
if|if
condition|(
name|binding_var
operator|->
name|shift
operator|>
literal|0
condition|)
name|all1
operator|>>=
name|binding_var
operator|->
name|shift
expr_stmt|;
elseif|else
if|if
condition|(
name|binding_var
operator|->
name|shift
operator|<
literal|0
condition|)
name|all1
operator|<<=
operator|-
name|binding_var
operator|->
name|shift
expr_stmt|;
if|if
condition|(
operator|(
name|intv
operator|.
name|u32
operator|&
name|all1
operator|)
operator|!=
name|all1
condition|)
name|all_bits_set
operator|=
name|false
expr_stmt|;
block|}
comment|/* Adjust input position; this was already verified to 			 * not overflow/underflow during SPROM opcode 			 * evaluation */
if|if
condition|(
name|binding
operator|->
name|skip_in_negative
condition|)
block|{
name|offset
operator|-=
name|skip_in_bytes
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|+=
name|skip_in_bytes
expr_stmt|;
block|}
comment|/* Skip writing to inp if additional bindings are 			 * required to fully populate intv */
if|if
condition|(
name|binding
operator|->
name|skip_out
operator|==
literal|0
condition|)
continue|continue;
comment|/* We use bhnd_nvram_value_coerce() to perform 			 * overflow-checked coercion from the widened 			 * uint32/int32 intv value to the requested output 			 * type */
if|if
condition|(
name|bhnd_nvram_is_signed_type
argument_list|(
name|var_btype
argument_list|)
condition|)
name|intv_type
operator|=
name|BHND_NVRAM_TYPE_INT32
expr_stmt|;
else|else
name|intv_type
operator|=
name|BHND_NVRAM_TYPE_UINT32
expr_stmt|;
comment|/* Calculate address of the current element output 			 * position */
name|ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|inp
operator|+
operator|(
name|iwidth
operator|*
name|ipos
operator|)
expr_stmt|;
comment|/* Perform coercion of the array element */
name|nbyte
operator|=
name|iwidth
expr_stmt|;
name|error
operator|=
name|bhnd_nvram_value_coerce
argument_list|(
operator|&
name|intv
operator|.
name|u32
argument_list|,
sizeof|sizeof
argument_list|(
name|intv
operator|.
name|u32
argument_list|)
argument_list|,
name|intv_type
argument_list|,
name|ptr
argument_list|,
operator|&
name|nbyte
argument_list|,
name|var_btype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Clear temporary state */
name|intv
operator|.
name|u32
operator|=
literal|0x0
expr_stmt|;
comment|/* Advance output position */
if|if
condition|(
name|SIZE_MAX
operator|-
name|binding
operator|->
name|skip_out
operator|<
name|ipos
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"output skip %u would overflow "
literal|"%zu\n"
argument_list|,
name|binding
operator|->
name|skip_out
argument_list|,
name|ipos
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ipos
operator|+=
name|binding
operator|->
name|skip_out
expr_stmt|;
block|}
block|}
comment|/* Did we iterate all bindings until hitting end of the variable 	 * definition? */
name|BHND_NV_ASSERT
argument_list|(
name|error
operator|!=
literal|0
argument_list|,
operator|(
literal|"loop terminated early"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* If marked IGNALL1 and all bits are set, treat variable as 	 * unavailable */
if|if
condition|(
operator|(
name|var
operator|->
name|flags
operator|&
name|BHND_NVRAM_VF_IGNALL1
operator|)
operator|&&
name|all_bits_set
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Provide value wrapper */
return|return
operator|(
name|bhnd_nvram_val_init
argument_list|(
name|val
argument_list|,
name|var
operator|->
name|fmt
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|var
operator|->
name|type
argument_list|,
name|BHND_NVRAM_VAL_BORROW_DATA
argument_list|)
operator|)
return|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_getvar_order
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
name|cookiep1
parameter_list|,
name|void
modifier|*
name|cookiep2
parameter_list|)
block|{
name|struct
name|sprom_opcode_idx_entry
modifier|*
name|e1
decl_stmt|,
modifier|*
name|e2
decl_stmt|;
name|e1
operator|=
name|cookiep1
expr_stmt|;
name|e2
operator|=
name|cookiep2
expr_stmt|;
comment|/* Use the index entry order; this matches the order of variables 	 * returned via bhnd_nvram_sprom_next() */
if|if
condition|(
name|e1
operator|<
name|e2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|e1
operator|>
name|e2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_getvar
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
block|{
name|bhnd_nvram_val
name|val
decl_stmt|;
name|union
name|bhnd_nvram_sprom_storage
name|storage
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Decode variable to a new value instance */
name|error
operator|=
name|bhnd_nvram_sprom_getvar_common
argument_list|(
name|nv
argument_list|,
name|cookiep
argument_list|,
operator|&
name|storage
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Perform value coercion */
name|error
operator|=
name|bhnd_nvram_val_encode
argument_list|(
operator|&
name|val
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|otype
argument_list|)
expr_stmt|;
comment|/* Clean up */
name|bhnd_nvram_val_release
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_copy_val
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|,
name|bhnd_nvram_val
modifier|*
modifier|*
name|value
parameter_list|)
block|{
name|bhnd_nvram_val
name|val
decl_stmt|;
name|union
name|bhnd_nvram_sprom_storage
name|storage
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Decode variable to a new value instance */
name|error
operator|=
name|bhnd_nvram_sprom_getvar_common
argument_list|(
name|nv
argument_list|,
name|cookiep
argument_list|,
operator|&
name|storage
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Attempt to copy to heap */
operator|*
name|value
operator|=
name|bhnd_nvram_val_copy
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
name|bhnd_nvram_val_release
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|value
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|bhnd_nvram_sprom_getvar_ptr
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|bhnd_nvram_type
modifier|*
name|type
parameter_list|)
block|{
comment|/* Unsupported */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|bhnd_nvram_sprom_getvar_name
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
decl_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|cookiep
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL variable cookiep"
operator|)
argument_list|)
expr_stmt|;
name|var
operator|=
name|SPROM_COOKIE_TO_NVRAM
argument_list|(
name|cookiep
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|var
operator|!=
name|NULL
argument_list|,
operator|(
literal|"invalid cookiep %p"
operator|,
name|cookiep
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|var
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_filter_setvar
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bhnd_nvram_val
modifier|*
name|value
parameter_list|,
name|bhnd_nvram_val
modifier|*
modifier|*
name|result
parameter_list|)
block|{
comment|// XXX TODO
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhnd_nvram_sprom_filter_unsetvar
parameter_list|(
name|struct
name|bhnd_nvram_data
modifier|*
name|nv
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|// XXX TODO
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize SPROM opcode evaluation state.  *   * @param state The opcode state to be initialized.  * @param layout The SPROM layout to be parsed by this instance.  *   *   * @retval 0 success  * @retval non-zero If initialization fails, a regular unix error code will be  * returned.  */
end_comment

begin_function
specifier|static
name|int
name|sprom_opcode_state_init
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
specifier|const
name|struct
name|bhnd_sprom_layout
modifier|*
name|layout
parameter_list|)
block|{
name|memset
argument_list|(
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|layout
operator|=
name|layout
expr_stmt|;
name|state
operator|->
name|input
operator|=
name|layout
operator|->
name|bindings
expr_stmt|;
name|state
operator|->
name|var_state
operator|=
name|SPROM_OPCODE_VAR_STATE_NONE
expr_stmt|;
name|bit_set
argument_list|(
name|state
operator|->
name|revs
argument_list|,
name|layout
operator|->
name|rev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Reset SPROM opcode evaluation state; future evaluation will be performed  * starting at the first opcode.  *   * @param state The opcode state to be reset.  *  * @retval 0 success  * @retval non-zero If reset fails, a regular unix error code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|sprom_opcode_state_reset
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|)
block|{
return|return
operator|(
name|sprom_opcode_state_init
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|layout
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Reset SPROM opcode evaluation state and seek to the @p indexed position.  *   * @param state The opcode state to be reset.  * @param indexed The indexed location to which we'll seek the opcode state.  */
end_comment

begin_function
specifier|static
name|int
name|sprom_opcode_state_seek
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|struct
name|sprom_opcode_idx
modifier|*
name|indexed
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|indexed
operator|->
name|opcodes
operator|<
name|state
operator|->
name|layout
operator|->
name|bindings_size
argument_list|,
operator|(
literal|"index entry references invalid opcode position"
operator|)
argument_list|)
expr_stmt|;
comment|/* Reset state */
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_state_reset
argument_list|(
name|state
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Seek to the indexed sprom opcode offset */
name|state
operator|->
name|input
operator|=
name|state
operator|->
name|layout
operator|->
name|bindings
operator|+
name|indexed
operator|->
name|opcodes
expr_stmt|;
comment|/* Restore the indexed sprom data offset and VID */
name|state
operator|->
name|offset
operator|=
name|indexed
operator|->
name|offset
expr_stmt|;
comment|/* Restore the indexed sprom variable ID */
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_set_var
argument_list|(
name|state
argument_list|,
name|indexed
operator|->
name|vid
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Set the current revision range for @p state. This also resets  * variable state.  *   * @param state The opcode state to update  * @param start The first revision in the range.  * @param end The last revision in the range.  *  * @retval 0 success  * @retval non-zero If updating @p state fails, a regular unix error code will  * be returned.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|sprom_opcode_set_revs
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint8_t
name|start
parameter_list|,
name|uint8_t
name|end
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Validate the revision range */
if|if
condition|(
name|start
operator|>
name|SPROM_OP_REV_MAX
operator|||
name|end
operator|>
name|SPROM_OP_REV_MAX
operator|||
name|end
operator|<
name|start
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"invalid revision range: %hhu-%hhu\n"
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Clear variable state */
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_clear_var
argument_list|(
name|state
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Reset revision mask */
name|memset
argument_list|(
name|state
operator|->
name|revs
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|revs
argument_list|)
argument_list|)
expr_stmt|;
name|bit_nset
argument_list|(
name|state
operator|->
name|revs
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Set the current variable's value mask for @p state.  *   * @param state The opcode state to update  * @param mask The mask to be set  *  * @retval 0 success  * @retval non-zero If updating @p state fails, a regular unix error code will  * be returned.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|sprom_opcode_set_mask
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
if|if
condition|(
name|state
operator|->
name|var_state
operator|!=
name|SPROM_OPCODE_VAR_STATE_OPEN
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"no open variable definition\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|state
operator|->
name|var
operator|.
name|mask
operator|=
name|mask
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Set the current variable's value shift for @p state.  *   * @param state The opcode state to update  * @param shift The shift to be set  *  * @retval 0 success  * @retval non-zero If updating @p state fails, a regular unix error code will  * be returned.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|sprom_opcode_set_shift
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|int8_t
name|shift
parameter_list|)
block|{
if|if
condition|(
name|state
operator|->
name|var_state
operator|!=
name|SPROM_OPCODE_VAR_STATE_OPEN
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"no open variable definition\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|state
operator|->
name|var
operator|.
name|shift
operator|=
name|shift
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Register a new BIND/BINDN operation with @p state.  *   * @param state The opcode state to update.  * @param count The number of elements to be bound.  * @param skip_in The number of input elements to skip after each bind.  * @param skip_in_negative If true, the input skip should be subtracted from  * the current offset after each bind. If false, the input skip should be  * added.  * @param skip_out The number of output elements to skip after each bind.  *   * @retval 0 success  * @retval EINVAL if a variable definition is not open.  * @retval EINVAL if @p skip_in and @p count would trigger an overflow or  * underflow when applied to the current input offset.  * @retval ERANGE if @p skip_in would overflow uint32_t when multiplied by  * @p count and the scale value.  * @retval ERANGE if @p skip_out would overflow uint32_t when multiplied by  * @p count and the scale value.  * @retval non-zero If updating @p state otherwise fails, a regular unix error  * code will be returned.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|sprom_opcode_set_bind
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint8_t
name|count
parameter_list|,
name|uint8_t
name|skip_in
parameter_list|,
name|bool
name|skip_in_negative
parameter_list|,
name|uint8_t
name|skip_out
parameter_list|)
block|{
name|uint32_t
name|iskip_total
decl_stmt|;
name|uint32_t
name|iskip_scaled
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Must have an open variable */
if|if
condition|(
name|state
operator|->
name|var_state
operator|!=
name|SPROM_OPCODE_VAR_STATE_OPEN
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"no open variable definition\n"
argument_list|)
expr_stmt|;
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"BIND outside of variable definition\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Cannot overwite an existing bind definition */
if|if
condition|(
name|state
operator|->
name|var
operator|.
name|have_bind
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"BIND overwrites existing definition\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Must have a count of at least 1 */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"BIND with zero count\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Scale skip_in by the current type width */
name|iskip_scaled
operator|=
name|skip_in
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_apply_scale
argument_list|(
name|state
argument_list|,
operator|&
name|iskip_scaled
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Calculate total input bytes skipped: iskip_scaled * count) */
if|if
condition|(
name|iskip_scaled
operator|>
literal|0
operator|&&
name|UINT32_MAX
operator|/
name|iskip_scaled
operator|<
name|count
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"skip_in %hhu would overflow"
argument_list|,
name|skip_in
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|iskip_total
operator|=
name|iskip_scaled
operator|*
name|count
expr_stmt|;
comment|/* Verify that the skip_in value won't under/overflow the current 	 * input offset. */
if|if
condition|(
name|skip_in_negative
condition|)
block|{
if|if
condition|(
name|iskip_total
operator|>
name|state
operator|->
name|offset
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"skip_in %hhu would underflow "
literal|"offset %u\n"
argument_list|,
name|skip_in
argument_list|,
name|state
operator|->
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|UINT32_MAX
operator|-
name|iskip_total
operator|<
name|state
operator|->
name|offset
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"skip_in %hhu would overflow "
literal|"offset %u\n"
argument_list|,
name|skip_in
argument_list|,
name|state
operator|->
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/* Set the actual count and skip values */
name|state
operator|->
name|var
operator|.
name|have_bind
operator|=
name|true
expr_stmt|;
name|state
operator|->
name|var
operator|.
name|bind
operator|.
name|count
operator|=
name|count
expr_stmt|;
name|state
operator|->
name|var
operator|.
name|bind
operator|.
name|skip_in
operator|=
name|skip_in
expr_stmt|;
name|state
operator|->
name|var
operator|.
name|bind
operator|.
name|skip_out
operator|=
name|skip_out
expr_stmt|;
name|state
operator|->
name|var
operator|.
name|bind
operator|.
name|skip_in_negative
operator|=
name|skip_in_negative
expr_stmt|;
comment|/* Update total bind count for the current variable */
name|state
operator|->
name|var
operator|.
name|bind_total
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Apply and clear the current opcode bind state, if any.  *   * @param state The opcode state to update.  *   * @retval 0 success  * @retval non-zero If updating @p state otherwise fails, a regular unix error  * code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|sprom_opcode_flush_bind
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint32_t
name|skip
decl_stmt|;
comment|/* Nothing to do? */
if|if
condition|(
name|state
operator|->
name|var_state
operator|!=
name|SPROM_OPCODE_VAR_STATE_OPEN
operator|||
operator|!
name|state
operator|->
name|var
operator|.
name|have_bind
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Apply SPROM offset adjustment */
if|if
condition|(
name|state
operator|->
name|var
operator|.
name|bind
operator|.
name|count
operator|>
literal|0
condition|)
block|{
name|skip
operator|=
name|state
operator|->
name|var
operator|.
name|bind
operator|.
name|skip_in
operator|*
name|state
operator|->
name|var
operator|.
name|bind
operator|.
name|count
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_apply_scale
argument_list|(
name|state
argument_list|,
operator|&
name|skip
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|state
operator|->
name|var
operator|.
name|bind
operator|.
name|skip_in_negative
condition|)
block|{
name|state
operator|->
name|offset
operator|-=
name|skip
expr_stmt|;
block|}
else|else
block|{
name|state
operator|->
name|offset
operator|+=
name|skip
expr_stmt|;
block|}
block|}
comment|/* Clear bind state */
name|memset
argument_list|(
operator|&
name|state
operator|->
name|var
operator|.
name|bind
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|var
operator|.
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|var
operator|.
name|have_bind
operator|=
name|false
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Set the current type to @p type, and reset type-specific  * stream state.  *  * @param state The opcode state to update.  * @param type The new type.  *   * @retval 0 success  * @retval EINVAL if @p vid is not a valid variable ID.  */
end_comment

begin_function
specifier|static
name|int
name|sprom_opcode_set_type
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|bhnd_nvram_type
name|type
parameter_list|)
block|{
name|bhnd_nvram_type
name|base_type
decl_stmt|;
name|size_t
name|width
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
comment|/* Must have an open variable definition */
if|if
condition|(
name|state
operator|->
name|var_state
operator|!=
name|SPROM_OPCODE_VAR_STATE_OPEN
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"type set outside variable definition\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Fetch type width for use as our scale value */
name|width
operator|=
name|bhnd_nvram_type_width
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"unsupported variable-width type: %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|width
operator|>
name|UINT32_MAX
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"invalid type width %zu for type: %d\n"
argument_list|,
name|width
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Determine default mask value for the element type */
name|base_type
operator|=
name|bhnd_nvram_base_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_UINT8
case|:
case|case
name|BHND_NVRAM_TYPE_INT8
case|:
case|case
name|BHND_NVRAM_TYPE_CHAR
case|:
name|mask
operator|=
name|UINT8_MAX
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT16
case|:
case|case
name|BHND_NVRAM_TYPE_INT16
case|:
name|mask
operator|=
name|UINT16_MAX
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_UINT32
case|:
case|case
name|BHND_NVRAM_TYPE_INT32
case|:
name|mask
operator|=
name|UINT32_MAX
expr_stmt|;
break|break;
case|case
name|BHND_NVRAM_TYPE_STRING
case|:
comment|/* fallthrough (unused by SPROM) */
default|default:
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"unsupported type: %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Update state */
name|state
operator|->
name|var
operator|.
name|base_type
operator|=
name|base_type
expr_stmt|;
name|state
operator|->
name|var
operator|.
name|mask
operator|=
name|mask
expr_stmt|;
name|state
operator|->
name|var
operator|.
name|scale
operator|=
operator|(
name|uint32_t
operator|)
name|width
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Clear current variable state, if any.  *   * @param state The opcode state to update.  */
end_comment

begin_function
specifier|static
name|int
name|sprom_opcode_clear_var
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|->
name|var_state
operator|==
name|SPROM_OPCODE_VAR_STATE_NONE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|BHND_NV_ASSERT
argument_list|(
name|state
operator|->
name|var_state
operator|==
name|SPROM_OPCODE_VAR_STATE_DONE
argument_list|,
operator|(
literal|"incomplete variable definition"
operator|)
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
operator|!
name|state
operator|->
name|var
operator|.
name|have_bind
argument_list|,
operator|(
literal|"stale bind state"
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|state
operator|->
name|var
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|var_state
operator|=
name|SPROM_OPCODE_VAR_STATE_NONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Set the current variable's array element count to @p nelem.  *  * @param state The opcode state to update.  * @param nelem The new array length.  *   * @retval 0 success  * @retval EINVAL if no open variable definition exists.  * @retval EINVAL if @p nelem is zero.  * @retval ENXIO if @p nelem is greater than one, and the current variable does  * not have an array type.  * @retval ENXIO if @p nelem exceeds the array length of the NVRAM variable  * definition.  */
end_comment

begin_function
specifier|static
name|int
name|sprom_opcode_set_nelem
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint8_t
name|nelem
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
decl_stmt|;
comment|/* Must have a defined variable */
if|if
condition|(
name|state
operator|->
name|var_state
operator|!=
name|SPROM_OPCODE_VAR_STATE_OPEN
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"array length set without open variable "
literal|"state"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Locate the actual variable definition */
if|if
condition|(
operator|(
name|var
operator|=
name|bhnd_nvram_get_vardefn
argument_list|(
name|state
operator|->
name|vid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"unknown variable ID: %zu\n"
argument_list|,
name|state
operator|->
name|vid
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Must be greater than zero */
if|if
condition|(
name|nelem
operator|==
literal|0
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"invalid nelem: %hhu\n"
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* If the variable is not an array-typed value, the array length 	 * must be 1 */
if|if
condition|(
operator|!
name|bhnd_nvram_is_array_type
argument_list|(
name|var
operator|->
name|type
argument_list|)
operator|&&
name|nelem
operator|!=
literal|1
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"nelem %hhu on non-array %zu\n"
argument_list|,
name|nelem
argument_list|,
name|state
operator|->
name|vid
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Cannot exceed the variable's defined array length */
if|if
condition|(
name|nelem
operator|>
name|var
operator|->
name|nelem
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"nelem %hhu exceeds %zu length %hhu\n"
argument_list|,
name|nelem
argument_list|,
name|state
operator|->
name|vid
argument_list|,
name|var
operator|->
name|nelem
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Valid length; update state */
name|state
operator|->
name|var
operator|.
name|nelem
operator|=
name|nelem
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Set the current variable ID to @p vid, and reset variable-specific  * stream state.  *  * @param state The opcode state to update.  * @param vid The new variable ID.  *   * @retval 0 success  * @retval EINVAL if @p vid is not a valid variable ID.  */
end_comment

begin_function
specifier|static
name|int
name|sprom_opcode_set_var
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|size_t
name|vid
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_nvram_vardefn
modifier|*
name|var
decl_stmt|;
name|int
name|error
decl_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|state
operator|->
name|var_state
operator|==
name|SPROM_OPCODE_VAR_STATE_NONE
argument_list|,
operator|(
literal|"overwrite of open variable definition"
operator|)
argument_list|)
expr_stmt|;
comment|/* Locate the variable definition */
if|if
condition|(
operator|(
name|var
operator|=
name|bhnd_nvram_get_vardefn
argument_list|(
name|vid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"unknown variable ID: %zu\n"
argument_list|,
name|vid
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Update vid and var state */
name|state
operator|->
name|vid
operator|=
name|vid
expr_stmt|;
name|state
operator|->
name|var_state
operator|=
name|SPROM_OPCODE_VAR_STATE_OPEN
expr_stmt|;
comment|/* Initialize default variable record values */
name|memset
argument_list|(
operator|&
name|state
operator|->
name|var
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|var
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set initial base type */
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_set_type
argument_list|(
name|state
argument_list|,
name|var
operator|->
name|type
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Set default array length */
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_set_nelem
argument_list|(
name|state
argument_list|,
name|var
operator|->
name|nelem
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Mark the currently open variable definition as complete.  *   * @param state The opcode state to update.  *  * @retval 0 success  * @retval EINVAL if no incomplete open variable definition exists.  */
end_comment

begin_function
specifier|static
name|int
name|sprom_opcode_end_var
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|->
name|var_state
operator|!=
name|SPROM_OPCODE_VAR_STATE_OPEN
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"no open variable definition\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|state
operator|->
name|var_state
operator|=
name|SPROM_OPCODE_VAR_STATE_DONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Apply the current scale to @p value.  *   * @param state The SPROM opcode state.  * @param[in,out] value The value to scale  *   * @retval 0 success  * @retval EINVAL if no open variable definition exists.  * @retval EINVAL if applying the current scale would overflow.  */
end_comment

begin_function
specifier|static
name|int
name|sprom_opcode_apply_scale
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint32_t
modifier|*
name|value
parameter_list|)
block|{
comment|/* Must have a defined variable (and thus, scale) */
if|if
condition|(
name|state
operator|->
name|var_state
operator|!=
name|SPROM_OPCODE_VAR_STATE_OPEN
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"scaled value encoded without open "
literal|"variable state"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Applying the scale value must not overflow */
if|if
condition|(
name|UINT32_MAX
operator|/
name|state
operator|->
name|var
operator|.
name|scale
operator|<
operator|*
name|value
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"cannot represent %"
name|PRIu32
literal|" * %"
name|PRIu32
literal|"\n"
argument_list|,
operator|*
name|value
argument_list|,
name|state
operator|->
name|var
operator|.
name|scale
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|value
operator|=
operator|(
operator|*
name|value
operator|)
operator|*
name|state
operator|->
name|var
operator|.
name|scale
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read a SPROM_OP_DATA_* value from @p opcodes.  *   * @param state The SPROM opcode state.  * @param type The SROM_OP_DATA_* type to be read.  * @param opval On success, the 32bit data representation. If @p type is signed,  * the value will be appropriately sign extended and may be directly cast to  * int32_t.  *   * @retval 0 success  * @retval non-zero If reading the value otherwise fails, a regular unix error  * code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|sprom_opcode_read_opval32
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint8_t
name|type
parameter_list|,
name|uint32_t
modifier|*
name|opval
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|p
operator|=
name|state
operator|->
name|input
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SPROM_OP_DATA_I8
case|:
comment|/* Convert to signed value first, then sign extend */
operator|*
name|opval
operator|=
call|(
name|int32_t
call|)
argument_list|(
name|int8_t
argument_list|)
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|SPROM_OP_DATA_U8
case|:
operator|*
name|opval
operator|=
operator|*
name|p
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|SPROM_OP_DATA_U8_SCALED
case|:
operator|*
name|opval
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_apply_scale
argument_list|(
name|state
argument_list|,
name|opval
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|p
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|SPROM_OP_DATA_U16
case|:
operator|*
name|opval
operator|=
name|le16dec
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|SPROM_OP_DATA_U32
case|:
operator|*
name|opval
operator|=
name|le32dec
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
break|break;
default|default:
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"unsupported data type: %hhu\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Update read address */
name|state
operator|->
name|input
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if our layout revision is currently defined by the SPROM  * opcode state.  *   * This may be used to test whether the current opcode stream state applies  * to the layout that we are actually parsing.  *   * A given opcode stream may cover multiple layout revisions, switching  * between them prior to defining a set of variables.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|sprom_opcode_matches_layout_rev
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|)
block|{
return|return
operator|(
name|bit_test
argument_list|(
name|state
operator|->
name|revs
argument_list|,
name|state
operator|->
name|layout
operator|->
name|rev
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * When evaluating @p state and @p opcode, rewrite @p opcode and the current  * evaluation state, as required.  *   * If @p opcode is rewritten, it should be returned from  * sprom_opcode_step() instead of the opcode parsed from @p state's opcode  * stream.  *   * If @p opcode remains unmodified, then sprom_opcode_step() should proceed  * to standard evaluation.  */
end_comment

begin_function
specifier|static
name|int
name|sprom_opcode_rewrite_opcode
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint8_t
modifier|*
name|opcode
parameter_list|)
block|{
name|uint8_t
name|op
decl_stmt|;
name|int
name|error
decl_stmt|;
name|op
operator|=
name|SPROM_OPCODE_OP
argument_list|(
operator|*
name|opcode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
operator|->
name|var_state
condition|)
block|{
case|case
name|SPROM_OPCODE_VAR_STATE_NONE
case|:
comment|/* No open variable definition */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SPROM_OPCODE_VAR_STATE_OPEN
case|:
comment|/* Open variable definition; check for implicit closure. */
comment|/* 		 * If a variable definition contains no explicit bind 		 * instructions prior to closure, we must generate a DO_BIND 		 * instruction with count and skip values of 1. 		 */
if|if
condition|(
name|SPROM_OP_IS_VAR_END
argument_list|(
name|op
argument_list|)
operator|&&
name|state
operator|->
name|var
operator|.
name|bind_total
operator|==
literal|0
condition|)
block|{
name|uint8_t
name|count
decl_stmt|,
name|skip_in
decl_stmt|,
name|skip_out
decl_stmt|;
name|bool
name|skip_in_negative
decl_stmt|;
comment|/* Create bind with skip_in/skip_out of 1, count of 1 */
name|count
operator|=
literal|1
expr_stmt|;
name|skip_in
operator|=
literal|1
expr_stmt|;
name|skip_out
operator|=
literal|1
expr_stmt|;
name|skip_in_negative
operator|=
name|false
expr_stmt|;
name|error
operator|=
name|sprom_opcode_set_bind
argument_list|(
name|state
argument_list|,
name|count
argument_list|,
name|skip_in
argument_list|,
name|skip_in_negative
argument_list|,
name|skip_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Return DO_BIND */
operator|*
name|opcode
operator|=
name|SPROM_OPCODE_DO_BIND
operator||
operator|(
literal|0
operator|<<
name|SPROM_OP_BIND_SKIP_IN_SIGN
operator|)
operator||
operator|(
literal|1
operator|<<
name|SPROM_OP_BIND_SKIP_IN_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|SPROM_OP_BIND_SKIP_OUT_SHIFT
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * If a variable is implicitly closed (e.g. by a new variable 		 * definition), we must generate a VAR_END instruction. 		 */
if|if
condition|(
name|SPROM_OP_IS_IMPLICIT_VAR_END
argument_list|(
name|op
argument_list|)
condition|)
block|{
comment|/* Mark as complete */
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_end_var
argument_list|(
name|state
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Return VAR_END */
operator|*
name|opcode
operator|=
name|SPROM_OPCODE_VAR_END
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|SPROM_OPCODE_VAR_STATE_DONE
case|:
comment|/* Previously completed variable definition. Discard variable 		 * state */
return|return
operator|(
name|sprom_opcode_clear_var
argument_list|(
name|state
argument_list|)
operator|)
return|;
block|}
comment|/* Nothing to do */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Evaluate one opcode from @p state.  *  * @param state The opcode state to be evaluated.  * @param[out] opcode On success, the evaluated opcode  *   * @retval 0 success  * @retval ENOENT if EOF is reached  * @retval non-zero if evaluation otherwise fails, a regular unix error  * code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|sprom_opcode_step
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|uint8_t
modifier|*
name|opcode
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
while|while
condition|(
operator|*
name|state
operator|->
name|input
operator|!=
name|SPROM_OPCODE_EOF
condition|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|uint8_t
name|op
decl_stmt|,
name|rewrite
decl_stmt|,
name|immd
decl_stmt|;
comment|/* Fetch opcode */
operator|*
name|opcode
operator|=
operator|*
name|state
operator|->
name|input
expr_stmt|;
name|op
operator|=
name|SPROM_OPCODE_OP
argument_list|(
operator|*
name|opcode
argument_list|)
expr_stmt|;
name|immd
operator|=
name|SPROM_OPCODE_IMM
argument_list|(
operator|*
name|opcode
argument_list|)
expr_stmt|;
comment|/* Clear any existing bind state */
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_flush_bind
argument_list|(
name|state
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Insert local opcode based on current state? */
name|rewrite
operator|=
operator|*
name|opcode
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_rewrite_opcode
argument_list|(
name|state
argument_list|,
operator|&
name|rewrite
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|rewrite
operator|!=
operator|*
name|opcode
condition|)
block|{
comment|/* Provide rewritten opcode */
operator|*
name|opcode
operator|=
name|rewrite
expr_stmt|;
comment|/* We must keep evaluating until we hit a state 			 * applicable to the SPROM revision we're parsing */
if|if
condition|(
operator|!
name|sprom_opcode_matches_layout_rev
argument_list|(
name|state
argument_list|)
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Advance input */
name|state
operator|->
name|input
operator|++
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SPROM_OPCODE_VAR_IMM
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_set_var
argument_list|(
name|state
argument_list|,
name|immd
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|SPROM_OPCODE_VAR_REL_IMM
case|:
name|error
operator|=
name|sprom_opcode_set_var
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|vid
operator|+
name|immd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|SPROM_OPCODE_VAR
case|:
name|error
operator|=
name|sprom_opcode_read_opval32
argument_list|(
name|state
argument_list|,
name|immd
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_set_var
argument_list|(
name|state
argument_list|,
name|val
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|SPROM_OPCODE_VAR_END
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_end_var
argument_list|(
name|state
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|SPROM_OPCODE_NELEM
case|:
name|immd
operator|=
operator|*
name|state
operator|->
name|input
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_set_nelem
argument_list|(
name|state
argument_list|,
name|immd
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|state
operator|->
name|input
operator|++
expr_stmt|;
break|break;
case|case
name|SPROM_OPCODE_DO_BIND
case|:
case|case
name|SPROM_OPCODE_DO_BINDN
case|:
block|{
name|uint8_t
name|count
decl_stmt|,
name|skip_in
decl_stmt|,
name|skip_out
decl_stmt|;
name|bool
name|skip_in_negative
decl_stmt|;
comment|/* Fetch skip arguments */
name|skip_in
operator|=
operator|(
name|immd
operator|&
name|SPROM_OP_BIND_SKIP_IN_MASK
operator|)
operator|>>
name|SPROM_OP_BIND_SKIP_IN_SHIFT
expr_stmt|;
name|skip_in_negative
operator|=
operator|(
operator|(
name|immd
operator|&
name|SPROM_OP_BIND_SKIP_IN_SIGN
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|skip_out
operator|=
operator|(
name|immd
operator|&
name|SPROM_OP_BIND_SKIP_OUT_MASK
operator|)
operator|>>
name|SPROM_OP_BIND_SKIP_OUT_SHIFT
expr_stmt|;
comment|/* Fetch count argument (if any) */
if|if
condition|(
name|op
operator|==
name|SPROM_OPCODE_DO_BINDN
condition|)
block|{
comment|/* Count is provided as trailing U8 */
name|count
operator|=
operator|*
name|state
operator|->
name|input
expr_stmt|;
name|state
operator|->
name|input
operator|++
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Set BIND state */
name|error
operator|=
name|sprom_opcode_set_bind
argument_list|(
name|state
argument_list|,
name|count
argument_list|,
name|skip_in
argument_list|,
name|skip_in_negative
argument_list|,
name|skip_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
block|}
case|case
name|SPROM_OPCODE_DO_BINDN_IMM
case|:
block|{
name|uint8_t
name|count
decl_stmt|,
name|skip_in
decl_stmt|,
name|skip_out
decl_stmt|;
name|bool
name|skip_in_negative
decl_stmt|;
comment|/* Implicit skip_in/skip_out of 1, count encoded as immd 			 * value */
name|count
operator|=
name|immd
expr_stmt|;
name|skip_in
operator|=
literal|1
expr_stmt|;
name|skip_out
operator|=
literal|1
expr_stmt|;
name|skip_in_negative
operator|=
name|false
expr_stmt|;
name|error
operator|=
name|sprom_opcode_set_bind
argument_list|(
name|state
argument_list|,
name|count
argument_list|,
name|skip_in
argument_list|,
name|skip_in_negative
argument_list|,
name|skip_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
block|}
case|case
name|SPROM_OPCODE_REV_IMM
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_set_revs
argument_list|(
name|state
argument_list|,
name|immd
argument_list|,
name|immd
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|SPROM_OPCODE_REV_RANGE
case|:
block|{
name|uint8_t
name|range
decl_stmt|;
name|uint8_t
name|rstart
decl_stmt|,
name|rend
decl_stmt|;
comment|/* Revision range is encoded in next byte, as 			 * { uint8_t start:4, uint8_t end:4 } */
name|range
operator|=
operator|*
name|state
operator|->
name|input
expr_stmt|;
name|rstart
operator|=
operator|(
name|range
operator|&
name|SPROM_OP_REV_START_MASK
operator|)
operator|>>
name|SPROM_OP_REV_START_SHIFT
expr_stmt|;
name|rend
operator|=
operator|(
name|range
operator|&
name|SPROM_OP_REV_END_MASK
operator|)
operator|>>
name|SPROM_OP_REV_END_SHIFT
expr_stmt|;
comment|/* Update revision bitmask */
name|error
operator|=
name|sprom_opcode_set_revs
argument_list|(
name|state
argument_list|,
name|rstart
argument_list|,
name|rend
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Advance input */
name|state
operator|->
name|input
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|SPROM_OPCODE_MASK_IMM
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_set_mask
argument_list|(
name|state
argument_list|,
name|immd
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|SPROM_OPCODE_MASK
case|:
name|error
operator|=
name|sprom_opcode_read_opval32
argument_list|(
name|state
argument_list|,
name|immd
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_set_mask
argument_list|(
name|state
argument_list|,
name|val
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|SPROM_OPCODE_SHIFT_IMM
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_set_shift
argument_list|(
name|state
argument_list|,
name|immd
operator|*
literal|2
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|SPROM_OPCODE_SHIFT
case|:
block|{
name|int8_t
name|shift
decl_stmt|;
if|if
condition|(
name|immd
operator|==
name|SPROM_OP_DATA_I8
condition|)
block|{
name|shift
operator|=
call|(
name|int8_t
call|)
argument_list|(
operator|*
name|state
operator|->
name|input
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|immd
operator|==
name|SPROM_OP_DATA_U8
condition|)
block|{
name|val
operator|=
operator|*
name|state
operator|->
name|input
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|INT8_MAX
condition|)
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"invalid shift "
literal|"value: %#x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|shift
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
name|SPROM_OP_BAD
argument_list|(
name|state
argument_list|,
literal|"unsupported shift data "
literal|"type: %#hhx\n"
argument_list|,
name|immd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_set_shift
argument_list|(
name|state
argument_list|,
name|shift
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|state
operator|->
name|input
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|SPROM_OPCODE_OFFSET_REL_IMM
case|:
comment|/* Fetch unscaled relative offset */
name|val
operator|=
name|immd
expr_stmt|;
comment|/* Apply scale */
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_apply_scale
argument_list|(
name|state
argument_list|,
operator|&
name|val
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Adding val must not overflow our offset */
if|if
condition|(
name|UINT32_MAX
operator|-
name|state
operator|->
name|offset
operator|<
name|val
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"offset out of range\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Adjust offset */
name|state
operator|->
name|offset
operator|+=
name|val
expr_stmt|;
break|break;
case|case
name|SPROM_OPCODE_OFFSET
case|:
name|error
operator|=
name|sprom_opcode_read_opval32
argument_list|(
name|state
argument_list|,
name|immd
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|state
operator|->
name|offset
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|SPROM_OPCODE_TYPE
case|:
comment|/* Type follows as U8 */
name|immd
operator|=
operator|*
name|state
operator|->
name|input
expr_stmt|;
name|state
operator|->
name|input
operator|++
expr_stmt|;
comment|/* fall through */
case|case
name|SPROM_OPCODE_TYPE_IMM
case|:
switch|switch
condition|(
name|immd
condition|)
block|{
case|case
name|BHND_NVRAM_TYPE_UINT8
case|:
case|case
name|BHND_NVRAM_TYPE_UINT16
case|:
case|case
name|BHND_NVRAM_TYPE_UINT32
case|:
case|case
name|BHND_NVRAM_TYPE_UINT64
case|:
case|case
name|BHND_NVRAM_TYPE_INT8
case|:
case|case
name|BHND_NVRAM_TYPE_INT16
case|:
case|case
name|BHND_NVRAM_TYPE_INT32
case|:
case|case
name|BHND_NVRAM_TYPE_INT64
case|:
case|case
name|BHND_NVRAM_TYPE_CHAR
case|:
case|case
name|BHND_NVRAM_TYPE_STRING
case|:
name|error
operator|=
name|sprom_opcode_set_type
argument_list|(
name|state
argument_list|,
operator|(
name|bhnd_nvram_type
operator|)
name|immd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
default|default:
name|BHND_NV_LOG
argument_list|(
literal|"unrecognized type %#hhx\n"
argument_list|,
name|immd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
default|default:
name|BHND_NV_LOG
argument_list|(
literal|"unrecognized opcode %#hhx\n"
argument_list|,
operator|*
name|opcode
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* We must keep evaluating until we hit a state applicable to 		 * the SPROM revision we're parsing */
if|if
condition|(
name|sprom_opcode_matches_layout_rev
argument_list|(
name|state
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* End of opcode stream */
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Reset SPROM opcode evaluation state, seek to the @p indexed position,  * and perform complete evaluation of the variable's opcodes.  *   * @param state The opcode state to be to be evaluated.  * @param indexed The indexed variable location.  *  * @retval 0 success  * @retval non-zero If evaluation fails, a regular unix error code will be  * returned.  */
end_comment

begin_function
specifier|static
name|int
name|sprom_opcode_parse_var
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|,
name|struct
name|sprom_opcode_idx
modifier|*
name|indexed
parameter_list|)
block|{
name|uint8_t
name|opcode
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Seek to entry */
if|if
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_state_seek
argument_list|(
name|state
argument_list|,
name|indexed
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Parse full variable definition */
while|while
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_step
argument_list|(
name|state
argument_list|,
operator|&
name|opcode
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Iterate until VAR_END */
if|if
condition|(
name|SPROM_OPCODE_OP
argument_list|(
name|opcode
argument_list|)
operator|!=
name|SPROM_OPCODE_VAR_END
condition|)
continue|continue;
name|BHND_NV_ASSERT
argument_list|(
name|state
operator|->
name|var_state
operator|==
name|SPROM_OPCODE_VAR_STATE_DONE
argument_list|,
operator|(
literal|"incomplete variable definition"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Error parsing definition */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Evaluate @p state until the next variable definition is found.  *   * @param state The opcode state to be evaluated.  *   * @retval 0 success  * @retval ENOENT if no additional variable definitions are available.  * @retval non-zero if evaluation otherwise fails, a regular unix error  * code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|sprom_opcode_next_var
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|)
block|{
name|uint8_t
name|opcode
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Step until we hit a variable opcode */
while|while
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_step
argument_list|(
name|state
argument_list|,
operator|&
name|opcode
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|SPROM_OPCODE_OP
argument_list|(
name|opcode
argument_list|)
condition|)
block|{
case|case
name|SPROM_OPCODE_VAR
case|:
case|case
name|SPROM_OPCODE_VAR_IMM
case|:
case|case
name|SPROM_OPCODE_VAR_REL_IMM
case|:
name|BHND_NV_ASSERT
argument_list|(
name|state
operator|->
name|var_state
operator|==
name|SPROM_OPCODE_VAR_STATE_OPEN
argument_list|,
operator|(
literal|"missing variable definition"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
continue|continue;
block|}
block|}
comment|/* Reached EOF, or evaluation failed */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Evaluate @p state until the next binding for the current variable definition  * is found.  *   * @param state The opcode state to be evaluated.  *   * @retval 0 success  * @retval ENOENT if no additional binding opcodes are found prior to reaching  * a new variable definition, or the end of @p state's binding opcodes.  * @retval non-zero if evaluation otherwise fails, a regular unix error  * code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|sprom_opcode_next_binding
parameter_list|(
name|struct
name|sprom_opcode_state
modifier|*
name|state
parameter_list|)
block|{
name|uint8_t
name|opcode
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|var_state
operator|!=
name|SPROM_OPCODE_VAR_STATE_OPEN
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Step until we hit a bind opcode, or a new variable */
while|while
condition|(
operator|(
name|error
operator|=
name|sprom_opcode_step
argument_list|(
name|state
argument_list|,
operator|&
name|opcode
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|SPROM_OPCODE_OP
argument_list|(
name|opcode
argument_list|)
condition|)
block|{
case|case
name|SPROM_OPCODE_DO_BIND
case|:
case|case
name|SPROM_OPCODE_DO_BINDN
case|:
case|case
name|SPROM_OPCODE_DO_BINDN_IMM
case|:
comment|/* Found next bind */
name|BHND_NV_ASSERT
argument_list|(
name|state
operator|->
name|var_state
operator|==
name|SPROM_OPCODE_VAR_STATE_OPEN
argument_list|,
operator|(
literal|"missing variable definition"
operator|)
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|state
operator|->
name|var
operator|.
name|have_bind
argument_list|,
operator|(
literal|"missing bind"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SPROM_OPCODE_VAR_END
case|:
comment|/* No further binding opcodes */
name|BHND_NV_ASSERT
argument_list|(
name|state
operator|->
name|var_state
operator|==
name|SPROM_OPCODE_VAR_STATE_DONE
argument_list|,
operator|(
literal|"variable definition still available"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
comment|/* Not found, or evaluation failed */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

