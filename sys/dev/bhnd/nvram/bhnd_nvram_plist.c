begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Landon Fuller<landonf@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/hash.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_KERNEL */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_include
include|#
directive|include
file|"bhnd_nvram_plistvar.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_private.h"
end_include

begin_function_decl
specifier|static
name|bhnd_nvram_plist_entry
modifier|*
name|bhnd_nvram_plist_get_entry
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Allocate and initialize a new, empty property list.  *   * The caller is responsible for releasing the returned property value  * via bhnd_nvram_plist_release().  *   * @retval non-NULL	success  * @retval NULL		if allocation fails.  */
end_comment

begin_function
name|bhnd_nvram_plist
modifier|*
name|bhnd_nvram_plist_new
parameter_list|(
name|void
parameter_list|)
block|{
name|bhnd_nvram_plist
modifier|*
name|plist
decl_stmt|;
name|plist
operator|=
name|bhnd_nv_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|plist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plist
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Implicit caller-owned reference */
name|plist
operator|->
name|refs
operator|=
literal|1
expr_stmt|;
comment|/* Initialize entry list */
name|plist
operator|->
name|num_entries
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|plist
operator|->
name|entries
argument_list|)
expr_stmt|;
comment|/* Initialize entry hash table */
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|plist
operator|->
name|names
argument_list|)
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|plist
operator|->
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|plist
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Retain a reference and return @p plist to the caller.  *   * The caller is responsible for releasing their reference ownership via  * bhnd_nvram_plist_release().  *   * @param	plist	The property list to be retained.  */
end_comment

begin_function
name|bhnd_nvram_plist
modifier|*
name|bhnd_nvram_plist_retain
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|)
block|{
name|BHND_NV_ASSERT
argument_list|(
name|plist
operator|->
name|refs
operator|>=
literal|1
argument_list|,
operator|(
literal|"plist over-released"
operator|)
argument_list|)
expr_stmt|;
name|refcount_acquire
argument_list|(
operator|&
name|plist
operator|->
name|refs
argument_list|)
expr_stmt|;
return|return
operator|(
name|plist
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Release a reference to @p plist.  *  * If this is the last reference, all associated resources will be freed.  *   * @param	plist	The property list to be released.  */
end_comment

begin_function
name|void
name|bhnd_nvram_plist_release
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|)
block|{
name|bhnd_nvram_plist_entry
modifier|*
name|ple
decl_stmt|,
modifier|*
name|ple_next
decl_stmt|;
name|BHND_NV_ASSERT
argument_list|(
name|plist
operator|->
name|refs
operator|>=
literal|1
argument_list|,
operator|(
literal|"plist over-released"
operator|)
argument_list|)
expr_stmt|;
comment|/* Drop reference */
if|if
condition|(
operator|!
name|refcount_release
argument_list|(
operator|&
name|plist
operator|->
name|refs
argument_list|)
condition|)
return|return;
comment|/* Free all property entries */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ple
argument_list|,
argument|&plist->entries
argument_list|,
argument|pl_link
argument_list|,
argument|ple_next
argument_list|)
block|{
name|bhnd_nvram_prop_release
argument_list|(
name|ple
operator|->
name|prop
argument_list|)
expr_stmt|;
name|bhnd_nv_free
argument_list|(
name|ple
argument_list|)
expr_stmt|;
block|}
comment|/* Free plist instance */
name|bhnd_nv_free
argument_list|(
name|plist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Return a shallow copy of @p plist.  *   * The caller is responsible for releasing the returned property value  * via bhnd_nvram_plist_release().  *   * @retval non-NULL	success  * @retval NULL		if allocation fails.  */
end_comment

begin_function
name|bhnd_nvram_plist
modifier|*
name|bhnd_nvram_plist_copy
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|)
block|{
name|bhnd_nvram_plist
modifier|*
name|copy
decl_stmt|;
name|bhnd_nvram_prop
modifier|*
name|prop
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allocate new, empty plist */
if|if
condition|(
operator|(
name|copy
operator|=
name|bhnd_nvram_plist_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Append all properties */
name|prop
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|prop
operator|=
name|bhnd_nvram_plist_next
argument_list|(
name|plist
argument_list|,
name|prop
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|bhnd_nvram_plist_append
argument_list|(
name|copy
argument_list|,
name|prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|ENOMEM
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"error copying property: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|bhnd_nvram_plist_release
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* Return ownership of the copy to our caller */
return|return
operator|(
name|copy
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the number of properties in @p plist.  */
end_comment

begin_function
name|size_t
name|bhnd_nvram_plist_count
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|)
block|{
return|return
operator|(
name|plist
operator|->
name|num_entries
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if @p plist contains a property name @p name, false otherwise.  *   * @param	plist	The property list to be queried.  * @param	name	The property name to be queried.  */
end_comment

begin_function
name|bool
name|bhnd_nvram_plist_contains
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|bhnd_nvram_plist_get_entry
argument_list|(
name|plist
argument_list|,
name|name
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Replace the current property value for a property matching the name  * of @p prop, maintaining the property's current order in @p plist.  *   * If a matching property is not found in @p plist, @p prop will instead be  * appended.  *   * @param	plist	The property list to be modified.  * @param	prop	The replacement property.  *   * @retval 0		success  * @retval ENOMEM	if allocation fails.  * @retval non-zero	if modifying @p plist otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_nvram_plist_replace
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
name|bhnd_nvram_prop
modifier|*
name|prop
parameter_list|)
block|{
name|bhnd_nvram_plist_entry
modifier|*
name|entry
decl_stmt|;
comment|/* Fetch current entry */
name|entry
operator|=
name|bhnd_nvram_plist_get_entry
argument_list|(
name|plist
argument_list|,
name|prop
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
comment|/* Not found -- append property instead */
return|return
operator|(
name|bhnd_nvram_plist_append
argument_list|(
name|plist
argument_list|,
name|prop
argument_list|)
operator|)
return|;
block|}
comment|/* Replace the current entry's property reference */
name|bhnd_nvram_prop_release
argument_list|(
name|entry
operator|->
name|prop
argument_list|)
expr_stmt|;
name|entry
operator|->
name|prop
operator|=
name|bhnd_nvram_prop_retain
argument_list|(
name|prop
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Replace the current property value for a property matching @p name,  * maintaining the property's order in @p plist.  *   * If @p name is not found in @p plist, a new property will be appended.  *   * @param	plist	The property list to be modified.  * @param	name	The name of the property to be replaced.  * @param	val	The replacement value for @p name.  *   * @retval 0		success  * @retval ENOMEM	if allocation fails.  * @retval non-zero	if modifying @p plist otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_nvram_plist_replace_val
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bhnd_nvram_val
modifier|*
name|val
parameter_list|)
block|{
name|bhnd_nvram_prop
modifier|*
name|prop
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Construct a new property instance for the name and value */
if|if
condition|(
operator|(
name|prop
operator|=
name|bhnd_nvram_prop_new
argument_list|(
name|name
argument_list|,
name|val
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Attempt replace */
name|error
operator|=
name|bhnd_nvram_plist_replace
argument_list|(
name|plist
argument_list|,
name|prop
argument_list|)
expr_stmt|;
name|bhnd_nvram_prop_release
argument_list|(
name|prop
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Replace the current property value for a property matching @p name, copying  * the new property value from the given @p inp buffer of @p itype and @p ilen.   *   * The current property order of @p name in @p plist will be maintained.  *   * If @p name is not found in @p plist, a new property will be appended.  *   * @param	plist	The property list to be modified.  * @param	name	The name of the property to be replaced.  * @param	inp	Input buffer.  * @param	ilen	Input buffer length.  * @param	itype	Input buffer type.  *   * @retval 0		success  * @retval ENOMEM	if allocation fails.  * @retval non-zero	if modifying @p plist otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_nvram_plist_replace_bytes
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|)
block|{
name|bhnd_nvram_prop
modifier|*
name|prop
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|prop
operator|=
name|bhnd_nvram_prop_bytes_new
argument_list|(
name|name
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|error
operator|=
name|bhnd_nvram_plist_replace
argument_list|(
name|plist
argument_list|,
name|prop
argument_list|)
expr_stmt|;
name|bhnd_nvram_prop_release
argument_list|(
name|prop
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Replace the current property value for a property matching @p name, copying  * the new property value from @p val.  *   * The current property order of @p name in @p plist will be maintained.  *   * If @p name is not found in @p plist, a new property will be appended.  *   * @param	plist	The property list to be modified.  * @param	name	The name of the property to be replaced.  * @param	val	The property's replacement string value.  *   * @retval 0		success  * @retval ENOMEM	if allocation fails.  * @retval non-zero	if modifying @p plist otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_nvram_plist_replace_string
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_plist_replace_bytes
argument_list|(
name|plist
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|,
name|BHND_NVRAM_TYPE_STRING
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Remove the property entry for the property @p name, if any.  *   * @param	plist	The property list to be modified.  * @param	name	The name of the property to be removed.  */
end_comment

begin_function
name|void
name|bhnd_nvram_plist_remove
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|bhnd_nvram_plist_entry
modifier|*
name|entry
decl_stmt|;
comment|/* Fetch entry */
name|entry
operator|=
name|bhnd_nvram_plist_get_entry
argument_list|(
name|plist
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return;
comment|/* Remove from entry list and hash table */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|plist
operator|->
name|entries
argument_list|,
name|entry
argument_list|,
name|pl_link
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|entry
argument_list|,
name|pl_hash_link
argument_list|)
expr_stmt|;
comment|/* Free plist entry */
name|bhnd_nvram_prop_release
argument_list|(
name|entry
operator|->
name|prop
argument_list|)
expr_stmt|;
name|bhnd_nv_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* Decrement entry count */
name|BHND_NV_ASSERT
argument_list|(
name|plist
operator|->
name|num_entries
operator|>
literal|0
argument_list|,
operator|(
literal|"entry count over-release"
operator|)
argument_list|)
expr_stmt|;
name|plist
operator|->
name|num_entries
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Fetch the property list entry for @p name, if any.  *   * @param	plist	The property list to be queried.  * @param	name	The property name to be queried.  *   * @retval non-NULL	if @p name is found.  * @retval NULL		if @p name is not found.  */
end_comment

begin_function
specifier|static
name|bhnd_nvram_plist_entry
modifier|*
name|bhnd_nvram_plist_get_entry
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|bhnd_nvram_plist_entry_list
modifier|*
name|hash_list
decl_stmt|;
name|bhnd_nvram_plist_entry
modifier|*
name|entry
decl_stmt|;
name|uint32_t
name|h
decl_stmt|;
name|h
operator|=
name|hash32_str
argument_list|(
name|name
argument_list|,
name|HASHINIT
argument_list|)
expr_stmt|;
name|hash_list
operator|=
operator|&
name|plist
operator|->
name|names
index|[
name|h
operator|%
name|nitems
argument_list|(
name|plist
operator|->
name|names
argument_list|)
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|hash_list
argument_list|,
argument|pl_hash_link
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|->
name|prop
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|entry
operator|)
return|;
block|}
empty_stmt|;
comment|/* Not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Append all properties from @p tail to @p plist.   *   * @param	plist	The property list to be modified.  * @param	tail	The property list to append.  *   * @retval 0		success  * @retval ENOMEM	if allocation fails.  * @retval EEXIST	an existing property from @p tail was found in @p plist.  */
end_comment

begin_function
name|int
name|bhnd_nvram_plist_append_list
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
name|bhnd_nvram_plist
modifier|*
name|tail
parameter_list|)
block|{
name|bhnd_nvram_prop
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|bhnd_nvram_plist_next
argument_list|(
name|tail
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_plist_append
argument_list|(
name|plist
argument_list|,
name|p
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Append @p prop to @p plist.  *   * @param	plist	The property list to be modified.  * @param	prop	The property to append.  *   * @retval 0		success  * @retval ENOMEM	if allocation fails.  * @retval EEXIST	an existing property with @p name was found in @p plist.  */
end_comment

begin_function
name|int
name|bhnd_nvram_plist_append
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
name|bhnd_nvram_prop
modifier|*
name|prop
parameter_list|)
block|{
name|bhnd_nvram_plist_entry_list
modifier|*
name|hash_list
decl_stmt|;
name|bhnd_nvram_plist_entry
modifier|*
name|entry
decl_stmt|;
name|uint32_t
name|h
decl_stmt|;
if|if
condition|(
name|bhnd_nvram_plist_contains
argument_list|(
name|plist
argument_list|,
name|prop
operator|->
name|name
argument_list|)
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
comment|/* Have we hit the maximum representable entry count? */
if|if
condition|(
name|plist
operator|->
name|num_entries
operator|==
name|SIZE_MAX
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Allocate new entry */
name|entry
operator|=
name|bhnd_nv_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|entry
operator|->
name|prop
operator|=
name|bhnd_nvram_prop_retain
argument_list|(
name|prop
argument_list|)
expr_stmt|;
comment|/* Append to entry list */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|plist
operator|->
name|entries
argument_list|,
name|entry
argument_list|,
name|pl_link
argument_list|)
expr_stmt|;
comment|/* Add to name-based hash table */
name|h
operator|=
name|hash32_str
argument_list|(
name|prop
operator|->
name|name
argument_list|,
name|HASHINIT
argument_list|)
expr_stmt|;
name|hash_list
operator|=
operator|&
name|plist
operator|->
name|names
index|[
name|h
operator|%
name|nitems
argument_list|(
name|plist
operator|->
name|names
argument_list|)
index|]
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|hash_list
argument_list|,
name|entry
argument_list|,
name|pl_hash_link
argument_list|)
expr_stmt|;
comment|/* Increment entry count */
name|plist
operator|->
name|num_entries
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Append a new property to @p plist with @p name and @p val.  *   * @param	plist	The property list to be modified.  * @param	name	The name of the property to be appended.  * @param	val	The value of the property to be appended.  *   * @retval 0		success  * @retval ENOMEM	if allocation fails.  * @retval EEXIST	an existing property with @p name was found in @p plist.  */
end_comment

begin_function
name|int
name|bhnd_nvram_plist_append_val
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bhnd_nvram_val
modifier|*
name|val
parameter_list|)
block|{
name|bhnd_nvram_prop
modifier|*
name|prop
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|prop
operator|=
name|bhnd_nvram_prop_new
argument_list|(
name|name
argument_list|,
name|val
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|error
operator|=
name|bhnd_nvram_plist_append
argument_list|(
name|plist
argument_list|,
name|prop
argument_list|)
expr_stmt|;
name|bhnd_nvram_prop_release
argument_list|(
name|prop
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Append a new property to @p plist, copying the property value from the  * given @p inp buffer of @p itype and @p ilen.  *   * @param	plist	The property list to be modified.  * @param	name	The name of the property to be appended.  * @param	inp	Input buffer.  * @param	ilen	Input buffer length.  * @param	itype	Input buffer type.  *   * @retval 0		success  * @retval ENOMEM	if allocation fails.  * @retval EEXIST	an existing property with @p name was found in @p plist.  */
end_comment

begin_function
name|int
name|bhnd_nvram_plist_append_bytes
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|)
block|{
name|bhnd_nvram_prop
modifier|*
name|prop
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|prop
operator|=
name|bhnd_nvram_prop_bytes_new
argument_list|(
name|name
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|error
operator|=
name|bhnd_nvram_plist_append
argument_list|(
name|plist
argument_list|,
name|prop
argument_list|)
expr_stmt|;
name|bhnd_nvram_prop_release
argument_list|(
name|prop
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Append a new string property to @p plist, copying the property value from  * @p val.  *   * @param	plist	The property list to be modified.  * @param	name	The name of the property to be appended.  * @param	val	The new property's string value.  *  * @retval 0		success  * @retval ENOMEM	if allocation fails.  * @retval EEXIST	an existing property with @p name was found in @p plist.  */
end_comment

begin_function
name|int
name|bhnd_nvram_plist_append_string
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_plist_append_bytes
argument_list|(
name|plist
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|,
name|BHND_NVRAM_TYPE_STRING
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Iterate over all properties in @p plist.  *   * @param	plist	The property list to be iterated.  * @param	prop	A property in @p plist, or NULL to return the first  *			property in @p plist.  *   * @retval non-NULL	A borrowed reference to the next property in @p plist.  * @retval NULL		If the end of the property list is reached or @p prop  *			is not found in @p plist.  */
end_comment

begin_function
name|bhnd_nvram_prop
modifier|*
name|bhnd_nvram_plist_next
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
name|bhnd_nvram_prop
modifier|*
name|prop
parameter_list|)
block|{
name|bhnd_nvram_plist_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|prop
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|entry
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|plist
operator|->
name|entries
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|entry
operator|->
name|prop
operator|)
return|;
block|}
comment|/* Look up previous property entry by name */
if|if
condition|(
operator|(
name|entry
operator|=
name|bhnd_nvram_plist_get_entry
argument_list|(
name|plist
argument_list|,
name|prop
operator|->
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* The property instance must be identical */
if|if
condition|(
name|entry
operator|->
name|prop
operator|!=
name|prop
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Fetch next entry */
if|if
condition|(
operator|(
name|entry
operator|=
name|TAILQ_NEXT
argument_list|(
name|entry
argument_list|,
name|pl_link
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|entry
operator|->
name|prop
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return a borrowed reference to a named property, or NULL if @p name is  * not found in @p plist.  *   * @param	plist	The property list to be queried.  * @param	name	The name of the property to be returned.  *  * @retval non-NULL	if @p name is found.  * @retval NULL		if @p name is not found.  */
end_comment

begin_function
name|bhnd_nvram_prop
modifier|*
name|bhnd_nvram_plist_get_prop
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|bhnd_nvram_plist_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|(
name|entry
operator|=
name|bhnd_nvram_plist_get_entry
argument_list|(
name|plist
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|entry
operator|->
name|prop
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return a borrowed reference to the named property's value, or NULL if  * @p name is not found in @p plist.  *   * @param	plist	The property list to be queried.  * @param	name	The name of the property to be returned.  *  * @retval non-NULL	if @p name is found.  * @retval NULL		if @p name is not found.  */
end_comment

begin_function
name|bhnd_nvram_val
modifier|*
name|bhnd_nvram_plist_get_val
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|bhnd_nvram_prop
modifier|*
name|prop
decl_stmt|;
if|if
condition|(
operator|(
name|prop
operator|=
name|bhnd_nvram_plist_get_prop
argument_list|(
name|plist
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|bhnd_nvram_prop_val
argument_list|(
name|prop
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Attempt to encode a named property's value as @p otype, writing the result  * to @p outp.  *  * @param		plist	The property list to be queried.  * @param		name	The name of the property value to be returned.  * @param[out]		outp	On success, the value will be written to this   *				buffer. This argment may be NULL if the value is  *				not desired.  * @param[in,out]	olen	The capacity of @p outp. On success, will be set  *				to the actual size of the requested value.  * @param		otype	The data type to be written to @p outp.  *  * @retval 0		success  * @retval ENOENT	If @p name is not found in @p plist.  * @retval ENOMEM	If the @p outp is non-NULL, and the provided @p olen  *			is too small to hold the encoded value.  * @retval EFTYPE	If value coercion from @p prop to @p otype is  *			impossible.  * @retval ERANGE	If value coercion would overflow (or underflow) the  *			a @p otype representation.  */
end_comment

begin_function
name|int
name|bhnd_nvram_plist_get_encoded
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
block|{
name|bhnd_nvram_prop
modifier|*
name|prop
decl_stmt|;
if|if
condition|(
operator|(
name|prop
operator|=
name|bhnd_nvram_plist_get_prop
argument_list|(
name|plist
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
return|return
operator|(
name|bhnd_nvram_prop_encode
argument_list|(
name|prop
argument_list|,
name|outp
argument_list|,
operator|&
name|olen
argument_list|,
name|otype
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the character representation of a named property's value.  *   * @param	plist	The property list to be queried.  * @param	name	The name of the property value to be returned.  * @param[out]	val	On success, the character value of @p name.  *  * @retval 0		success  * @retval ENOENT	If @p name is not found in @p plist.  * @retval EFTYPE	If coercion of the property's value to @p val.  * @retval ERANGE	If coercion of the property's value would overflow  *			(or underflow) @p val.  */
end_comment

begin_function
name|int
name|bhnd_nvram_plist_get_char
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|u_char
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_plist_get_encoded
argument_list|(
name|plist
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|val
argument_list|)
argument_list|,
name|BHND_NVRAM_TYPE_CHAR
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the uint8 representation of a named property's value.  *   * @param	plist	The property list to be queried.  * @param	name	The name of the property value to be returned.  * @param[out]	val	On success, the uint8 value of @p name.  *  * @retval 0		success  * @retval ENOENT	If @p name is not found in @p plist.  * @retval EFTYPE	If coercion of the property's value to @p val.  * @retval ERANGE	If coercion of the property's value would overflow  *			(or underflow) @p val.  */
end_comment

begin_function
name|int
name|bhnd_nvram_plist_get_uint8
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint8_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_plist_get_encoded
argument_list|(
name|plist
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|val
argument_list|)
argument_list|,
name|BHND_NVRAM_TYPE_UINT8
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the uint16 representation of a named property's value.  *   * @param	plist	The property list to be queried.  * @param	name	The name of the property value to be returned.  * @param[out]	val	On success, the uint16 value of @p name.  *  * @retval 0		success  * @retval ENOENT	If @p name is not found in @p plist.  * @retval EFTYPE	If coercion of the property's value to @p val.  * @retval ERANGE	If coercion of the property's value would overflow  *			(or underflow) @p val.  */
end_comment

begin_function
name|int
name|bhnd_nvram_plist_get_uint16
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint16_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_plist_get_encoded
argument_list|(
name|plist
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|val
argument_list|)
argument_list|,
name|BHND_NVRAM_TYPE_UINT16
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the uint32 representation of a named property's value.  *   * @param	plist	The property list to be queried.  * @param	name	The name of the property value to be returned.  * @param[out]	val	On success, the uint32 value of @p name.  *  * @retval 0		success  * @retval ENOENT	If @p name is not found in @p plist.  * @retval EFTYPE	If coercion of the property's value to @p val.  * @retval ERANGE	If coercion of the property's value would overflow  *			(or underflow) @p val.  */
end_comment

begin_function
name|int
name|bhnd_nvram_plist_get_uint32
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_plist_get_encoded
argument_list|(
name|plist
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|val
argument_list|)
argument_list|,
name|BHND_NVRAM_TYPE_UINT32
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the uint64 representation of a named property's value.  *   * @param	plist	The property list to be queried.  * @param	name	The name of the property value to be returned.  * @param[out]	val	On success, the uint64 value of @p name.  *  * @retval 0		success  * @retval ENOENT	If @p name is not found in @p plist.  * @retval EFTYPE	If coercion of the property's value to @p val.  * @retval ERANGE	If coercion of the property's value would overflow  *			(or underflow) @p val.  */
end_comment

begin_function
name|int
name|bhnd_nvram_plist_get_uint64
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_plist_get_encoded
argument_list|(
name|plist
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|val
argument_list|)
argument_list|,
name|BHND_NVRAM_TYPE_UINT64
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the boolean representation of a named property's value.  *   * @param	plist	The property list to be queried.  * @param	name	The name of the property value to be returned.  * @param[out]	val	On success, the boolean value of @p name.  *  * @retval 0		success  * @retval ENOENT	If @p name is not found in @p plist.  * @retval EFTYPE	If coercion of the property's value to @p val.  * @retval ERANGE	If coercion of the property's value would overflow  *			(or underflow) @p val.  */
end_comment

begin_function
name|int
name|bhnd_nvram_plist_get_bool
parameter_list|(
name|bhnd_nvram_plist
modifier|*
name|plist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bool
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_plist_get_encoded
argument_list|(
name|plist
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|val
argument_list|)
argument_list|,
name|BHND_NVRAM_TYPE_BOOL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Allocate and initialize a new property value.  *   * The caller is responsible for releasing the returned property value  * via bhnd_nvram_prop_release().  *   * @param	name	Property name.  * @param	val	Property value.  *   * @retval non-NULL	success  * @retval NULL		if allocation fails.  */
end_comment

begin_function
name|struct
name|bhnd_nvram_prop
modifier|*
name|bhnd_nvram_prop_new
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bhnd_nvram_val
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|bhnd_nvram_prop
modifier|*
name|prop
decl_stmt|;
name|prop
operator|=
name|bhnd_nv_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Implicit caller-owned reference */
name|prop
operator|->
name|refs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|prop
operator|->
name|name
operator|=
name|bhnd_nv_strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
operator|(
name|prop
operator|->
name|val
operator|=
name|bhnd_nvram_val_copy
argument_list|(
name|val
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
name|prop
operator|)
return|;
name|failed
label|:
if|if
condition|(
name|prop
operator|->
name|name
operator|!=
name|NULL
condition|)
name|bhnd_nv_free
argument_list|(
name|prop
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|->
name|val
operator|!=
name|NULL
condition|)
name|bhnd_nvram_val_release
argument_list|(
name|prop
operator|->
name|val
argument_list|)
expr_stmt|;
name|bhnd_nv_free
argument_list|(
name|prop
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Allocate a new property value and attempt to initialize its value from  * the given @p inp buffer of @p itype and @p ilen.  *  * The caller is responsible for releasing the returned property value  * via bhnd_nvram_prop_release().  *  * @param	name	Property name.  * @param	inp	Input buffer.  * @param	ilen	Input buffer length.  * @param	itype	Input buffer type.  *   * @retval non-NULL	success  * @retval NULL		if allocation or initialization fails.  */
end_comment

begin_function
name|bhnd_nvram_prop
modifier|*
name|bhnd_nvram_prop_bytes_new
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|void
modifier|*
name|inp
parameter_list|,
name|size_t
name|ilen
parameter_list|,
name|bhnd_nvram_type
name|itype
parameter_list|)
block|{
name|bhnd_nvram_prop
modifier|*
name|prop
decl_stmt|;
name|bhnd_nvram_val
modifier|*
name|val
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Construct new value instance */
name|error
operator|=
name|bhnd_nvram_val_new
argument_list|(
operator|&
name|val
argument_list|,
name|NULL
argument_list|,
name|inp
argument_list|,
name|ilen
argument_list|,
name|itype
argument_list|,
name|BHND_NVRAM_VAL_DYNAMIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|ENOMEM
condition|)
block|{
name|BHND_NV_LOG
argument_list|(
literal|"invalid input data; initialization "
literal|"failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Delegate to default implementation */
name|prop
operator|=
name|bhnd_nvram_prop_new
argument_list|(
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Clean up */
name|bhnd_nvram_val_release
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|prop
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Retain a reference and return @p prop to the caller.  *   * The caller is responsible for releasing their reference ownership via  * bhnd_nvram_prop_release().  *   * @param	prop	The property to be retained.  */
end_comment

begin_function
name|bhnd_nvram_prop
modifier|*
name|bhnd_nvram_prop_retain
parameter_list|(
name|bhnd_nvram_prop
modifier|*
name|prop
parameter_list|)
block|{
name|BHND_NV_ASSERT
argument_list|(
name|prop
operator|->
name|refs
operator|>=
literal|1
argument_list|,
operator|(
literal|"prop over-released"
operator|)
argument_list|)
expr_stmt|;
name|refcount_acquire
argument_list|(
operator|&
name|prop
operator|->
name|refs
argument_list|)
expr_stmt|;
return|return
operator|(
name|prop
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Release a reference to @p prop.  *  * If this is the last reference, all associated resources will be freed.  *   * @param	prop	The property to be released.  */
end_comment

begin_function
name|void
name|bhnd_nvram_prop_release
parameter_list|(
name|bhnd_nvram_prop
modifier|*
name|prop
parameter_list|)
block|{
name|BHND_NV_ASSERT
argument_list|(
name|prop
operator|->
name|refs
operator|>=
literal|1
argument_list|,
operator|(
literal|"prop over-released"
operator|)
argument_list|)
expr_stmt|;
comment|/* Drop reference */
if|if
condition|(
operator|!
name|refcount_release
argument_list|(
operator|&
name|prop
operator|->
name|refs
argument_list|)
condition|)
return|return;
comment|/* Free property data */
name|bhnd_nvram_val_release
argument_list|(
name|prop
operator|->
name|val
argument_list|)
expr_stmt|;
name|bhnd_nv_free
argument_list|(
name|prop
operator|->
name|name
argument_list|)
expr_stmt|;
name|bhnd_nv_free
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Return a borrowed reference to the property's name.  *   * @param	prop	The property to query.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|bhnd_nvram_prop_name
parameter_list|(
name|bhnd_nvram_prop
modifier|*
name|prop
parameter_list|)
block|{
return|return
operator|(
name|prop
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return a borrowed reference to the property's value.  *   * @param	prop	The property to query.  */
end_comment

begin_function
name|bhnd_nvram_val
modifier|*
name|bhnd_nvram_prop_val
parameter_list|(
name|bhnd_nvram_prop
modifier|*
name|prop
parameter_list|)
block|{
return|return
operator|(
name|prop
operator|->
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the property's value type.  *   * @param	prop	The property to query.  */
end_comment

begin_function
name|bhnd_nvram_type
name|bhnd_nvram_prop_type
parameter_list|(
name|bhnd_nvram_prop
modifier|*
name|prop
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_val_type
argument_list|(
name|prop
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if @p prop has a NULL value type (BHND_NVRAM_TYPE_NULL), false  * otherwise.  *   * @param      prop    The property to query.  */
end_comment

begin_function
name|bool
name|bhnd_nvram_prop_is_null
parameter_list|(
name|bhnd_nvram_prop
modifier|*
name|prop
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_prop_type
argument_list|(
name|prop
argument_list|)
operator|==
name|BHND_NVRAM_TYPE_NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return a borrowed reference to the property's internal value representation.  *  * @param	prop	The property to query.  * @param[out]	olen	The returned data's size, in bytes.  * @param[out]	otype	The returned data's type.  */
end_comment

begin_function
specifier|const
name|void
modifier|*
name|bhnd_nvram_prop_bytes
parameter_list|(
name|bhnd_nvram_prop
modifier|*
name|prop
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
modifier|*
name|otype
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|bytes
decl_stmt|;
name|bytes
operator|=
name|bhnd_nvram_val_bytes
argument_list|(
name|prop
operator|->
name|val
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|)
expr_stmt|;
name|BHND_NV_ASSERT
argument_list|(
operator|*
name|otype
operator|==
name|bhnd_nvram_prop_type
argument_list|(
name|prop
argument_list|)
argument_list|,
operator|(
literal|"type mismatch"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bytes
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Attempt to encode the property's value as @p otype, writing the result  * to @p outp.  *  * @param		prop	The property to be encoded.  * @param[out]		outp	On success, the value will be written to this   *				buffer. This argment may be NULL if the value is  *				not desired.  * @param[in,out]	olen	The capacity of @p outp. On success, will be set  *				to the actual size of the requested value.  * @param		otype	The data type to be written to @p outp.  *  * @retval 0		success  * @retval ENOMEM	If the @p outp is non-NULL, and the provided @p olen  *			is too small to hold the encoded value.  * @retval EFTYPE	If value coercion from @p prop to @p otype is  *			impossible.  * @retval ERANGE	If value coercion would overflow (or underflow) the  *			a @p otype representation.  */
end_comment

begin_function
name|int
name|bhnd_nvram_prop_encode
parameter_list|(
name|bhnd_nvram_prop
modifier|*
name|prop
parameter_list|,
name|void
modifier|*
name|outp
parameter_list|,
name|size_t
modifier|*
name|olen
parameter_list|,
name|bhnd_nvram_type
name|otype
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_val_encode
argument_list|(
name|prop
operator|->
name|val
argument_list|,
name|outp
argument_list|,
name|olen
argument_list|,
name|otype
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

