begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Landon Fuller<landon@landonf.org>  * Copyright (c) 2017 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by Landon Fuller  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/siba/sibareg.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/chipc/chipcreg.h>
end_include

begin_include
include|#
directive|include
file|"nvram/bhnd_nvram.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_chipc_if.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_if.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_map.h"
end_include

begin_include
include|#
directive|include
file|"bhndreg.h"
end_include

begin_include
include|#
directive|include
file|"bhndvar.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_private.h"
end_include

begin_function_decl
specifier|static
name|void
name|bhnd_service_registry_free_entry
parameter_list|(
name|struct
name|bhnd_service_entry
modifier|*
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_ascending_probe_order
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_descending_probe_order
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* BHND core device description table. */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|bhnd_core_desc
block|{
name|uint16_t
name|vendor
decl_stmt|;
name|uint16_t
name|device
decl_stmt|;
name|bhnd_devclass_t
name|class
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|bhnd_core_descs
index|[]
init|=
block|{
define|#
directive|define
name|BHND_CDESC
parameter_list|(
name|_mfg
parameter_list|,
name|_cid
parameter_list|,
name|_cls
parameter_list|,
name|_desc
parameter_list|)
define|\
value|{ BHND_MFGID_ ## _mfg, BHND_COREID_ ## _cid,	\ 		BHND_DEVCLASS_ ## _cls, _desc }
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|CC
argument_list|,
name|CC
argument_list|,
literal|"ChipCommon I/O Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|ILINE20
argument_list|,
name|OTHER
argument_list|,
literal|"iLine20 HPNA"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|SRAM
argument_list|,
name|RAM
argument_list|,
literal|"SRAM"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|SDRAM
argument_list|,
name|RAM
argument_list|,
literal|"SDRAM"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|PCI
argument_list|,
name|PCI
argument_list|,
literal|"PCI Bridge"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|MIPS
argument_list|,
name|CPU
argument_list|,
literal|"BMIPS CPU"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|ENET
argument_list|,
name|ENET_MAC
argument_list|,
literal|"Fast Ethernet MAC"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|CODEC
argument_list|,
name|OTHER
argument_list|,
literal|"V.90 Modem Codec"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|USB
argument_list|,
name|USB_DUAL
argument_list|,
literal|"USB 1.1 Device/Host Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|ADSL
argument_list|,
name|OTHER
argument_list|,
literal|"ADSL Core"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|ILINE100
argument_list|,
name|OTHER
argument_list|,
literal|"iLine100 HPNA"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|IPSEC
argument_list|,
name|OTHER
argument_list|,
literal|"IPsec Accelerator"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|UTOPIA
argument_list|,
name|OTHER
argument_list|,
literal|"UTOPIA ATM Core"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|PCMCIA
argument_list|,
name|PCCARD
argument_list|,
literal|"PCMCIA Bridge"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|SOCRAM
argument_list|,
name|RAM
argument_list|,
literal|"Internal Memory"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|MEMC
argument_list|,
name|MEMC
argument_list|,
literal|"MEMC SDRAM Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|OFDM
argument_list|,
name|OTHER
argument_list|,
literal|"OFDM PHY"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|EXTIF
argument_list|,
name|OTHER
argument_list|,
literal|"External Interface"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|D11
argument_list|,
name|WLAN
argument_list|,
literal|"802.11 MAC/PHY/Radio"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|APHY
argument_list|,
name|WLAN_PHY
argument_list|,
literal|"802.11a PHY"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|BPHY
argument_list|,
name|WLAN_PHY
argument_list|,
literal|"802.11b PHY"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|GPHY
argument_list|,
name|WLAN_PHY
argument_list|,
literal|"802.11g PHY"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|MIPS33
argument_list|,
name|CPU
argument_list|,
literal|"BMIPS33 CPU"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|USB11H
argument_list|,
name|USB_HOST
argument_list|,
literal|"USB 1.1 Host Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|USB11D
argument_list|,
name|USB_DEV
argument_list|,
literal|"USB 1.1 Device Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|USB20H
argument_list|,
name|USB_HOST
argument_list|,
literal|"USB 2.0 Host Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|USB20D
argument_list|,
name|USB_DEV
argument_list|,
literal|"USB 2.0 Device Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|SDIOH
argument_list|,
name|OTHER
argument_list|,
literal|"SDIO Host Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|ROBO
argument_list|,
name|OTHER
argument_list|,
literal|"RoboSwitch"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|ATA100
argument_list|,
name|OTHER
argument_list|,
literal|"Parallel ATA Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|SATAXOR
argument_list|,
name|OTHER
argument_list|,
literal|"SATA DMA/XOR Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|GIGETH
argument_list|,
name|ENET_MAC
argument_list|,
literal|"Gigabit Ethernet MAC"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|PCIE
argument_list|,
name|PCIE
argument_list|,
literal|"PCIe Bridge"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NPHY
argument_list|,
name|WLAN_PHY
argument_list|,
literal|"802.11n 2x2 PHY"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|SRAMC
argument_list|,
name|MEMC
argument_list|,
literal|"SRAM Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|MINIMAC
argument_list|,
name|OTHER
argument_list|,
literal|"MINI MAC/PHY"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|ARM11
argument_list|,
name|CPU
argument_list|,
literal|"ARM1176 CPU"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|ARM7S
argument_list|,
name|CPU
argument_list|,
literal|"ARM7TDMI-S CPU"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|LPPHY
argument_list|,
name|WLAN_PHY
argument_list|,
literal|"802.11a/b/g PHY"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|PMU
argument_list|,
name|PMU
argument_list|,
literal|"PMU"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|SSNPHY
argument_list|,
name|WLAN_PHY
argument_list|,
literal|"802.11n Single-Stream PHY"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|SDIOD
argument_list|,
name|OTHER
argument_list|,
literal|"SDIO Device Core"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|ARMCM3
argument_list|,
name|CPU
argument_list|,
literal|"ARM Cortex-M3 CPU"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|HTPHY
argument_list|,
name|WLAN_PHY
argument_list|,
literal|"802.11n 4x4 PHY"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|MIPS
argument_list|,
name|MIPS74K
argument_list|,
name|CPU
argument_list|,
literal|"MIPS74k CPU"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|GMAC
argument_list|,
name|ENET_MAC
argument_list|,
literal|"Gigabit MAC core"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|DMEMC
argument_list|,
name|MEMC
argument_list|,
literal|"DDR1/DDR2 Memory Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|PCIERC
argument_list|,
name|OTHER
argument_list|,
literal|"PCIe Root Complex"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|OCP
argument_list|,
name|SOC_BRIDGE
argument_list|,
literal|"OCP to OCP Bridge"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|SC
argument_list|,
name|OTHER
argument_list|,
literal|"Shared Common Core"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|AHB
argument_list|,
name|SOC_BRIDGE
argument_list|,
literal|"OCP to AHB Bridge"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|SPIH
argument_list|,
name|OTHER
argument_list|,
literal|"SPI Host Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|I2S
argument_list|,
name|OTHER
argument_list|,
literal|"I2S Digital Audio Interface"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|DMEMS
argument_list|,
name|MEMC
argument_list|,
literal|"SDR/DDR1 Memory Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|UBUS_SHIM
argument_list|,
name|OTHER
argument_list|,
literal|"BCM6362/UBUS WLAN SHIM"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|PCIE2
argument_list|,
name|PCIE
argument_list|,
literal|"PCIe Bridge (Gen2)"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|ARM
argument_list|,
name|APB_BRIDGE
argument_list|,
name|SOC_BRIDGE
argument_list|,
literal|"BP135 AMBA3 AXI to APB Bridge"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|ARM
argument_list|,
name|PL301
argument_list|,
name|SOC_ROUTER
argument_list|,
literal|"PL301 AMBA3 Interconnect"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|ARM
argument_list|,
name|EROM
argument_list|,
name|EROM
argument_list|,
literal|"PL366 Device Enumeration ROM"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|ARM
argument_list|,
name|OOB_ROUTER
argument_list|,
name|OTHER
argument_list|,
literal|"PL367 OOB Interrupt Router"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|ARM
argument_list|,
name|AXI_UNMAPPED
argument_list|,
name|OTHER
argument_list|,
literal|"Unmapped Address Ranges"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
literal|4706_CC
argument_list|,
name|CC
argument_list|,
literal|"ChipCommon I/O Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_PCIE2
argument_list|,
name|PCIE
argument_list|,
literal|"PCIe Bridge (Gen2)"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_DMA
argument_list|,
name|OTHER
argument_list|,
literal|"DMA engine"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_SDIO
argument_list|,
name|OTHER
argument_list|,
literal|"SDIO 3.0 Host Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_USB20H
argument_list|,
name|USB_HOST
argument_list|,
literal|"USB 2.0 Host Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_USB30H
argument_list|,
name|USB_HOST
argument_list|,
literal|"USB 3.0 Host Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_A9JTAG
argument_list|,
name|OTHER
argument_list|,
literal|"ARM Cortex A9 JTAG Interface"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_DDR23_MEMC
argument_list|,
name|MEMC
argument_list|,
literal|"Denali DDR2/DD3 Memory Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_ROM
argument_list|,
name|NVRAM
argument_list|,
literal|"System ROM"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_NAND
argument_list|,
name|NVRAM
argument_list|,
literal|"NAND Flash Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_QSPI
argument_list|,
name|NVRAM
argument_list|,
literal|"QSPI Flash Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_CC_B
argument_list|,
name|CC_B
argument_list|,
literal|"ChipCommon B Auxiliary I/O Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
literal|4706_SOCRAM
argument_list|,
name|RAM
argument_list|,
literal|"Internal Memory"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|IHOST_ARMCA9
argument_list|,
name|CPU
argument_list|,
literal|"ARM Cortex A9 CPU"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
literal|4706_GMAC_CMN
argument_list|,
name|ENET
argument_list|,
literal|"Gigabit MAC (Common)"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
literal|4706_GMAC
argument_list|,
name|ENET_MAC
argument_list|,
literal|"Gigabit MAC"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|AMEMC
argument_list|,
name|MEMC
argument_list|,
literal|"Denali DDR1/DDR2 Memory Controller"
argument_list|)
block|,
undef|#
directive|undef
name|BHND_CDESC
comment|/* Derived from inspection of the BCM4331 cores that provide PrimeCell 	 * IDs. Due to lack of documentation, the surmised device name/purpose 	 * provided here may be incorrect. */
block|{
name|BHND_MFGID_ARM
block|,
name|BHND_PRIMEID_EROM
block|,
name|BHND_DEVCLASS_OTHER
block|,
literal|"PL364 Device Enumeration ROM"
block|}
block|,
block|{
name|BHND_MFGID_ARM
block|,
name|BHND_PRIMEID_SWRAP
block|,
name|BHND_DEVCLASS_OTHER
block|,
literal|"PL368 Device Management Interface"
block|}
block|,
block|{
name|BHND_MFGID_ARM
block|,
name|BHND_PRIMEID_MWRAP
block|,
name|BHND_DEVCLASS_OTHER
block|,
literal|"PL369 Device Management Interface"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_comment
comment|/**  * Return the name for a given JEP106 manufacturer ID.  *   * @param vendor A JEP106 Manufacturer ID, including the non-standard ARM 4-bit  * JEP106 continuation code.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|bhnd_vendor_name
parameter_list|(
name|uint16_t
name|vendor
parameter_list|)
block|{
switch|switch
condition|(
name|vendor
condition|)
block|{
case|case
name|BHND_MFGID_ARM
case|:
return|return
literal|"ARM"
return|;
case|case
name|BHND_MFGID_BCM
case|:
return|return
literal|"Broadcom"
return|;
case|case
name|BHND_MFGID_MIPS
case|:
return|return
literal|"MIPS"
return|;
default|default:
return|return
literal|"unknown"
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Return the name of a port type.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|bhnd_port_type_name
parameter_list|(
name|bhnd_port_type
name|port_type
parameter_list|)
block|{
switch|switch
condition|(
name|port_type
condition|)
block|{
case|case
name|BHND_PORT_DEVICE
case|:
return|return
operator|(
literal|"device"
operator|)
return|;
case|case
name|BHND_PORT_BRIDGE
case|:
return|return
operator|(
literal|"bridge"
operator|)
return|;
case|case
name|BHND_PORT_AGENT
case|:
return|return
operator|(
literal|"agent"
operator|)
return|;
default|default:
return|return
literal|"unknown"
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Return the name of an NVRAM source.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|bhnd_nvram_src_name
parameter_list|(
name|bhnd_nvram_src
name|nvram_src
parameter_list|)
block|{
switch|switch
condition|(
name|nvram_src
condition|)
block|{
case|case
name|BHND_NVRAM_SRC_FLASH
case|:
return|return
operator|(
literal|"flash"
operator|)
return|;
case|case
name|BHND_NVRAM_SRC_OTP
case|:
return|return
operator|(
literal|"OTP"
operator|)
return|;
case|case
name|BHND_NVRAM_SRC_SPROM
case|:
return|return
operator|(
literal|"SPROM"
operator|)
return|;
case|case
name|BHND_NVRAM_SRC_UNKNOWN
case|:
return|return
operator|(
literal|"none"
operator|)
return|;
default|default:
return|return
operator|(
literal|"unknown"
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|bhnd_core_desc
modifier|*
name|bhnd_find_core_desc
parameter_list|(
name|uint16_t
name|vendor
parameter_list|,
name|uint16_t
name|device
parameter_list|)
block|{
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|bhnd_core_descs
index|[
name|i
index|]
operator|.
name|desc
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bhnd_core_descs
index|[
name|i
index|]
operator|.
name|vendor
operator|!=
name|vendor
condition|)
continue|continue;
if|if
condition|(
name|bhnd_core_descs
index|[
name|i
index|]
operator|.
name|device
operator|!=
name|device
condition|)
continue|continue;
return|return
operator|(
operator|&
name|bhnd_core_descs
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return a human-readable name for a BHND core.  *   * @param vendor The core designer's JEDEC-106 Manufacturer ID  * @param device The core identifier.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|bhnd_find_core_name
parameter_list|(
name|uint16_t
name|vendor
parameter_list|,
name|uint16_t
name|device
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_core_desc
modifier|*
name|desc
decl_stmt|;
if|if
condition|(
operator|(
name|desc
operator|=
name|bhnd_find_core_desc
argument_list|(
name|vendor
argument_list|,
name|device
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"unknown"
operator|)
return|;
return|return
name|desc
operator|->
name|desc
return|;
block|}
end_function

begin_comment
comment|/**  * Return the device class for a BHND core.  *   * @param vendor The core designer's JEDEC-106 Manufacturer ID  * @param device The core identifier.  */
end_comment

begin_function
name|bhnd_devclass_t
name|bhnd_find_core_class
parameter_list|(
name|uint16_t
name|vendor
parameter_list|,
name|uint16_t
name|device
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_core_desc
modifier|*
name|desc
decl_stmt|;
if|if
condition|(
operator|(
name|desc
operator|=
name|bhnd_find_core_desc
argument_list|(
name|vendor
argument_list|,
name|device
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|BHND_DEVCLASS_OTHER
operator|)
return|;
return|return
name|desc
operator|->
name|class
return|;
block|}
end_function

begin_comment
comment|/**  * Return a human-readable name for a BHND core.  *   * @param ci The core's info record.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|bhnd_core_name
parameter_list|(
specifier|const
name|struct
name|bhnd_core_info
modifier|*
name|ci
parameter_list|)
block|{
return|return
name|bhnd_find_core_name
argument_list|(
name|ci
operator|->
name|vendor
argument_list|,
name|ci
operator|->
name|device
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the device class for a BHND core.  *   * @param ci The core's info record.  */
end_comment

begin_function
name|bhnd_devclass_t
name|bhnd_core_class
parameter_list|(
specifier|const
name|struct
name|bhnd_core_info
modifier|*
name|ci
parameter_list|)
block|{
return|return
name|bhnd_find_core_class
argument_list|(
name|ci
operator|->
name|vendor
argument_list|,
name|ci
operator|->
name|device
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Write a human readable name representation of the given  * BHND_CHIPID_* constant to @p buffer.  *   * @param buffer Output buffer, or NULL to compute the required size.  * @param size Capacity of @p buffer, in bytes.  * @param chip_id Chip ID to be formatted.  *   * @return Returns the required number of bytes on success, or a negative  * integer on failure. No more than @p size-1 characters be written, with  * the @p size'th set to '\0'.  *   * @sa BHND_CHIPID_MAX_NAMELEN  */
end_comment

begin_function
name|int
name|bhnd_format_chip_id
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint16_t
name|chip_id
parameter_list|)
block|{
comment|/* All hex formatted IDs are within the range of 0x4000-0x9C3F (40000-1) */
if|if
condition|(
name|chip_id
operator|>=
literal|0x4000
operator|&&
name|chip_id
operator|<=
literal|0x9C3F
condition|)
return|return
operator|(
name|snprintf
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|,
literal|"BCM%hX"
argument_list|,
name|chip_id
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|snprintf
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|,
literal|"BCM%hu"
argument_list|,
name|chip_id
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize a core info record with data from from a bhnd-attached @p dev.  *   * @param dev A bhnd device.  * @param core The record to be initialized.  */
end_comment

begin_function
name|struct
name|bhnd_core_info
name|bhnd_get_core_info
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
expr|struct
name|bhnd_core_info
operator|)
block|{
operator|.
name|vendor
operator|=
name|bhnd_get_vendor
argument_list|(
name|dev
argument_list|)
block|,
operator|.
name|device
operator|=
name|bhnd_get_device
argument_list|(
name|dev
argument_list|)
block|,
operator|.
name|hwrev
operator|=
name|bhnd_get_hwrev
argument_list|(
name|dev
argument_list|)
block|,
operator|.
name|core_idx
operator|=
name|bhnd_get_core_index
argument_list|(
name|dev
argument_list|)
block|,
operator|.
name|unit
operator|=
name|bhnd_get_core_unit
argument_list|(
argument|dev
argument_list|)
block|}
return|;
block|}
end_function

begin_comment
comment|/**  * Find a @p class child device with @p unit on @p bus.  *   * @param bus The bhnd-compatible bus to be searched.  * @param class The device class to match on.  * @param unit The core unit number; specify -1 to return the first match  * regardless of unit number.  *   * @retval device_t if a matching child device is found.  * @retval NULL if no matching child device is found.  */
end_comment

begin_function
name|device_t
name|bhnd_bus_find_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|bhnd_devclass_t
name|class
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|bhnd_core_match
name|md
init|=
block|{
name|BHND_MATCH_CORE_CLASS
argument_list|(
name|class
argument_list|)
block|,
name|BHND_MATCH_CORE_UNIT
argument_list|(
argument|unit
argument_list|)
block|}
decl_stmt|;
if|if
condition|(
name|unit
operator|==
operator|-
literal|1
condition|)
name|md
operator|.
name|m
operator|.
name|match
operator|.
name|core_unit
operator|=
literal|0
expr_stmt|;
return|return
name|bhnd_bus_match_child
argument_list|(
name|bus
argument_list|,
operator|&
name|md
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find the first child device on @p bus that matches @p desc.  *   * @param bus The bhnd-compatible bus to be searched.  * @param desc A match descriptor.  *   * @retval device_t if a matching child device is found.  * @retval NULL if no matching child device is found.  */
end_comment

begin_function
name|device_t
name|bhnd_bus_match_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
specifier|const
name|struct
name|bhnd_core_match
modifier|*
name|desc
parameter_list|)
block|{
name|device_t
modifier|*
name|devlistp
decl_stmt|;
name|device_t
name|match
decl_stmt|;
name|int
name|devcnt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|device_get_children
argument_list|(
name|bus
argument_list|,
operator|&
name|devlistp
argument_list|,
operator|&
name|devcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|match
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|devcnt
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bhnd_core_info
name|ci
init|=
name|bhnd_get_core_info
argument_list|(
name|devlistp
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|bhnd_core_matches
argument_list|(
operator|&
name|ci
argument_list|,
name|desc
argument_list|)
condition|)
block|{
name|match
operator|=
name|devlistp
index|[
name|i
index|]
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|free
argument_list|(
name|devlistp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|match
return|;
block|}
end_function

begin_comment
comment|/**  * Retrieve an ordered list of all device instances currently connected to  * @p bus, returning a pointer to the array in @p devlistp and the count  * in @p ndevs.  *   * The memory allocated for the table must be freed via  * bhnd_bus_free_children().  *   * @param	bus		The bhnd-compatible bus to be queried.  * @param[out]	devlist		The array of devices.  * @param[out]	devcount	The number of devices in @p devlistp  * @param	order		The order in which devices will be returned  *				in @p devlist.  *   * @retval 0		success  * @retval non-zero	if an error occurs, a regular unix error code will  *			be returned.  */
end_comment

begin_function
name|int
name|bhnd_bus_get_children
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
modifier|*
modifier|*
name|devlist
parameter_list|,
name|int
modifier|*
name|devcount
parameter_list|,
name|bhnd_device_order
name|order
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Fetch device array */
if|if
condition|(
operator|(
name|error
operator|=
name|device_get_children
argument_list|(
name|bus
argument_list|,
name|devlist
argument_list|,
name|devcount
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Perform requested sorting */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_sort_devices
argument_list|(
operator|*
name|devlist
argument_list|,
operator|*
name|devcount
argument_list|,
name|order
argument_list|)
operator|)
condition|)
block|{
name|bhnd_bus_free_children
argument_list|(
operator|*
name|devlist
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Free any memory allocated in a previous call to bhnd_bus_get_children().  *  * @param devlist The device array returned by bhnd_bus_get_children().  */
end_comment

begin_function
name|void
name|bhnd_bus_free_children
parameter_list|(
name|device_t
modifier|*
name|devlist
parameter_list|)
block|{
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Perform in-place sorting of an array of bhnd device instances.  *   * @param devlist	An array of bhnd devices.  * @param devcount	The number of devices in @p devs.  * @param order		The sort order to be used.  */
end_comment

begin_function
name|int
name|bhnd_sort_devices
parameter_list|(
name|device_t
modifier|*
name|devlist
parameter_list|,
name|size_t
name|devcount
parameter_list|,
name|bhnd_device_order
name|order
parameter_list|)
block|{
name|int
function_decl|(
modifier|*
name|compare
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
switch|switch
condition|(
name|order
condition|)
block|{
case|case
name|BHND_DEVICE_ORDER_ATTACH
case|:
name|compare
operator|=
name|compare_ascending_probe_order
expr_stmt|;
break|break;
case|case
name|BHND_DEVICE_ORDER_DETACH
case|:
name|compare
operator|=
name|compare_descending_probe_order
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown sort order: %d\n"
argument_list|,
name|order
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|qsort
argument_list|(
name|devlist
argument_list|,
name|devcount
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|devlist
argument_list|)
argument_list|,
name|compare
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Ascending comparison of bhnd device's probe order.  */
end_comment

begin_function
specifier|static
name|int
name|compare_ascending_probe_order
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
name|device_t
name|ldev
decl_stmt|,
name|rdev
decl_stmt|;
name|int
name|lorder
decl_stmt|,
name|rorder
decl_stmt|;
name|ldev
operator|=
operator|(
operator|*
operator|(
specifier|const
name|device_t
operator|*
operator|)
name|lhs
operator|)
expr_stmt|;
name|rdev
operator|=
operator|(
operator|*
operator|(
specifier|const
name|device_t
operator|*
operator|)
name|rhs
operator|)
expr_stmt|;
name|lorder
operator|=
name|BHND_BUS_GET_PROBE_ORDER
argument_list|(
name|device_get_parent
argument_list|(
name|ldev
argument_list|)
argument_list|,
name|ldev
argument_list|)
expr_stmt|;
name|rorder
operator|=
name|BHND_BUS_GET_PROBE_ORDER
argument_list|(
name|device_get_parent
argument_list|(
name|rdev
argument_list|)
argument_list|,
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|lorder
operator|<
name|rorder
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|lorder
operator|>
name|rorder
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Descending comparison of bhnd device's probe order.  */
end_comment

begin_function
specifier|static
name|int
name|compare_descending_probe_order
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
return|return
operator|(
name|compare_ascending_probe_order
argument_list|(
name|rhs
argument_list|,
name|lhs
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Call device_probe_and_attach() for each of the bhnd bus device's  * children, in bhnd attach order.  *   * @param bus The bhnd-compatible bus for which all children should be probed  * and attached.  */
end_comment

begin_function
name|int
name|bhnd_bus_probe_children
parameter_list|(
name|device_t
name|bus
parameter_list|)
block|{
name|device_t
modifier|*
name|devs
decl_stmt|;
name|int
name|ndevs
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Fetch children in attach order */
name|error
operator|=
name|bhnd_bus_get_children
argument_list|(
name|bus
argument_list|,
operator|&
name|devs
argument_list|,
operator|&
name|ndevs
argument_list|,
name|BHND_DEVICE_ORDER_ATTACH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Probe and attach all children */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ndevs
condition|;
name|i
operator|++
control|)
block|{
name|device_t
name|child
init|=
name|devs
index|[
name|i
index|]
decl_stmt|;
name|device_probe_and_attach
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
name|bhnd_bus_free_children
argument_list|(
name|devs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Walk up the bhnd device hierarchy to locate the root device  * to which the bhndb bridge is attached.  *   * This can be used from within bhnd host bridge drivers to locate the  * actual upstream host device.  *   * @param dev A bhnd device.  * @param bus_class The expected bus (e.g. "pci") to which the bridge root  * should be attached.  *   * @retval device_t if a matching parent device is found.  * @retval NULL @p dev is not attached via a bhndb bus  * @retval NULL no parent device is attached via @p bus_class.  */
end_comment

begin_function
name|device_t
name|bhnd_find_bridge_root
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|devclass_t
name|bus_class
parameter_list|)
block|{
name|devclass_t
name|bhndb_class
decl_stmt|;
name|device_t
name|parent
decl_stmt|;
name|KASSERT
argument_list|(
name|device_get_devclass
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
operator|==
name|bhnd_devclass
argument_list|,
operator|(
literal|"%s not a bhnd device"
operator|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bhndb_class
operator|=
name|devclass_find
argument_list|(
literal|"bhndb"
argument_list|)
expr_stmt|;
comment|/* Walk the device tree until we hit a bridge */
name|parent
operator|=
name|dev
expr_stmt|;
while|while
condition|(
operator|(
name|parent
operator|=
name|device_get_parent
argument_list|(
name|parent
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|device_get_devclass
argument_list|(
name|parent
argument_list|)
operator|==
name|bhndb_class
condition|)
break|break;
block|}
comment|/* No bridge? */
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Search for a parent attached to the expected bus class */
while|while
condition|(
operator|(
name|parent
operator|=
name|device_get_parent
argument_list|(
name|parent
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|device_t
name|bus
decl_stmt|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|!=
name|NULL
operator|&&
name|device_get_devclass
argument_list|(
name|bus
argument_list|)
operator|==
name|bus_class
condition|)
return|return
operator|(
name|parent
operator|)
return|;
block|}
comment|/* Not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find the first core in @p cores that matches @p desc.  *   * @param cores The table to search.  * @param num_cores The length of @p cores.  * @param desc A match descriptor.  *   * @retval bhnd_core_info if a matching core is found.  * @retval NULL if no matching core is found.  */
end_comment

begin_function
specifier|const
name|struct
name|bhnd_core_info
modifier|*
name|bhnd_match_core
parameter_list|(
specifier|const
name|struct
name|bhnd_core_info
modifier|*
name|cores
parameter_list|,
name|u_int
name|num_cores
parameter_list|,
specifier|const
name|struct
name|bhnd_core_match
modifier|*
name|desc
parameter_list|)
block|{
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num_cores
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bhnd_core_matches
argument_list|(
operator|&
name|cores
index|[
name|i
index|]
argument_list|,
name|desc
argument_list|)
condition|)
return|return
operator|&
name|cores
index|[
name|i
index|]
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find the first core in @p cores with the given @p class.  *   * @param cores The table to search.  * @param num_cores The length of @p cores.  * @param desc A match descriptor.  *   * @retval bhnd_core_info if a matching core is found.  * @retval NULL if no matching core is found.  */
end_comment

begin_function
specifier|const
name|struct
name|bhnd_core_info
modifier|*
name|bhnd_find_core
parameter_list|(
specifier|const
name|struct
name|bhnd_core_info
modifier|*
name|cores
parameter_list|,
name|u_int
name|num_cores
parameter_list|,
name|bhnd_devclass_t
name|class
parameter_list|)
block|{
name|struct
name|bhnd_core_match
name|md
init|=
block|{
name|BHND_MATCH_CORE_CLASS
argument_list|(
argument|class
argument_list|)
block|}
decl_stmt|;
return|return
name|bhnd_match_core
argument_list|(
name|cores
argument_list|,
name|num_cores
argument_list|,
operator|&
name|md
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Create an equality match descriptor for @p core.  *   * @param core The core info to be matched on.  * @param desc On return, will be populated with a match descriptor for @p core.  */
end_comment

begin_function
name|struct
name|bhnd_core_match
name|bhnd_core_get_match_desc
parameter_list|(
specifier|const
name|struct
name|bhnd_core_info
modifier|*
name|core
parameter_list|)
block|{
return|return
operator|(
operator|(
expr|struct
name|bhnd_core_match
operator|)
block|{
name|BHND_MATCH_CORE_VENDOR
argument_list|(
name|core
operator|->
name|vendor
argument_list|)
block|,
name|BHND_MATCH_CORE_ID
argument_list|(
name|core
operator|->
name|device
argument_list|)
block|,
name|BHND_MATCH_CORE_REV
argument_list|(
name|HWREV_EQ
argument_list|(
name|core
operator|->
name|hwrev
argument_list|)
argument_list|)
block|,
name|BHND_MATCH_CORE_CLASS
argument_list|(
name|bhnd_core_class
argument_list|(
name|core
argument_list|)
argument_list|)
block|,
name|BHND_MATCH_CORE_IDX
argument_list|(
name|core
operator|->
name|core_idx
argument_list|)
block|,
name|BHND_MATCH_CORE_UNIT
argument_list|(
argument|core->unit
argument_list|)
block|}
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if the @p lhs is equal to @p rhs  *   * @param lhs The first bhnd core descriptor to compare.  * @param rhs The second bhnd core descriptor to compare.  *   * @retval true if @p lhs is equal to @p rhs  * @retval false if @p lhs is not equal to @p rhs  */
end_comment

begin_function
name|bool
name|bhnd_cores_equal
parameter_list|(
specifier|const
name|struct
name|bhnd_core_info
modifier|*
name|lhs
parameter_list|,
specifier|const
name|struct
name|bhnd_core_info
modifier|*
name|rhs
parameter_list|)
block|{
name|struct
name|bhnd_core_match
name|md
decl_stmt|;
comment|/* Use an equality match descriptor to perform the comparison */
name|md
operator|=
name|bhnd_core_get_match_desc
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
return|return
operator|(
name|bhnd_core_matches
argument_list|(
name|lhs
argument_list|,
operator|&
name|md
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if the @p core matches @p desc.  *   * @param core A bhnd core descriptor.  * @param desc A match descriptor to compare against @p core.  *   * @retval true if @p core matches @p match  * @retval false if @p core does not match @p match.  */
end_comment

begin_function
name|bool
name|bhnd_core_matches
parameter_list|(
specifier|const
name|struct
name|bhnd_core_info
modifier|*
name|core
parameter_list|,
specifier|const
name|struct
name|bhnd_core_match
modifier|*
name|desc
parameter_list|)
block|{
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|core_vendor
operator|&&
name|desc
operator|->
name|core_vendor
operator|!=
name|core
operator|->
name|vendor
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|core_id
operator|&&
name|desc
operator|->
name|core_id
operator|!=
name|core
operator|->
name|device
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|core_unit
operator|&&
name|desc
operator|->
name|core_unit
operator|!=
name|core
operator|->
name|unit
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|core_rev
operator|&&
operator|!
name|bhnd_hwrev_matches
argument_list|(
name|core
operator|->
name|hwrev
argument_list|,
operator|&
name|desc
operator|->
name|core_rev
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|core_idx
operator|&&
name|desc
operator|->
name|core_idx
operator|!=
name|core
operator|->
name|core_idx
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|core_class
operator|&&
name|desc
operator|->
name|core_class
operator|!=
name|bhnd_core_class
argument_list|(
name|core
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if the @p chip matches @p desc.  *   * @param chip A bhnd chip identifier.  * @param desc A match descriptor to compare against @p chip.  *   * @retval true if @p chip matches @p match  * @retval false if @p chip does not match @p match.  */
end_comment

begin_function
name|bool
name|bhnd_chip_matches
parameter_list|(
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|chip
parameter_list|,
specifier|const
name|struct
name|bhnd_chip_match
modifier|*
name|desc
parameter_list|)
block|{
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|chip_id
operator|&&
name|chip
operator|->
name|chip_id
operator|!=
name|desc
operator|->
name|chip_id
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|chip_pkg
operator|&&
name|chip
operator|->
name|chip_pkg
operator|!=
name|desc
operator|->
name|chip_pkg
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|chip_rev
operator|&&
operator|!
name|bhnd_hwrev_matches
argument_list|(
name|chip
operator|->
name|chip_rev
argument_list|,
operator|&
name|desc
operator|->
name|chip_rev
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|chip_type
operator|&&
name|chip
operator|->
name|chip_type
operator|!=
name|desc
operator|->
name|chip_type
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if the @p board matches @p desc.  *   * @param board The bhnd board info.  * @param desc A match descriptor to compare against @p board.  *   * @retval true if @p chip matches @p match  * @retval false if @p chip does not match @p match.  */
end_comment

begin_function
name|bool
name|bhnd_board_matches
parameter_list|(
specifier|const
name|struct
name|bhnd_board_info
modifier|*
name|board
parameter_list|,
specifier|const
name|struct
name|bhnd_board_match
modifier|*
name|desc
parameter_list|)
block|{
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|board_srom_rev
operator|&&
operator|!
name|bhnd_hwrev_matches
argument_list|(
name|board
operator|->
name|board_srom_rev
argument_list|,
operator|&
name|desc
operator|->
name|board_srom_rev
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|board_vendor
operator|&&
name|board
operator|->
name|board_vendor
operator|!=
name|desc
operator|->
name|board_vendor
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|board_type
operator|&&
name|board
operator|->
name|board_type
operator|!=
name|desc
operator|->
name|board_type
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|board_rev
operator|&&
operator|!
name|bhnd_hwrev_matches
argument_list|(
name|board
operator|->
name|board_rev
argument_list|,
operator|&
name|desc
operator|->
name|board_rev
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if the @p hwrev matches @p desc.  *   * @param hwrev A bhnd hardware revision.  * @param desc A match descriptor to compare against @p core.  *   * @retval true if @p hwrev matches @p match  * @retval false if @p hwrev does not match @p match.  */
end_comment

begin_function
name|bool
name|bhnd_hwrev_matches
parameter_list|(
name|uint16_t
name|hwrev
parameter_list|,
specifier|const
name|struct
name|bhnd_hwrev_match
modifier|*
name|desc
parameter_list|)
block|{
if|if
condition|(
name|desc
operator|->
name|start
operator|!=
name|BHND_HWREV_INVALID
operator|&&
name|desc
operator|->
name|start
operator|>
name|hwrev
condition|)
return|return
name|false
return|;
if|if
condition|(
name|desc
operator|->
name|end
operator|!=
name|BHND_HWREV_INVALID
operator|&&
name|desc
operator|->
name|end
operator|<
name|hwrev
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if the @p dev matches @p desc.  *   * @param dev A bhnd device.  * @param desc A match descriptor to compare against @p dev.  *   * @retval true if @p dev matches @p match  * @retval false if @p dev does not match @p match.  */
end_comment

begin_function
name|bool
name|bhnd_device_matches
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|bhnd_device_match
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|bhnd_core_info
name|core
decl_stmt|;
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|chip
decl_stmt|;
name|struct
name|bhnd_board_info
name|board
decl_stmt|;
name|device_t
name|parent
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Construct individual match descriptors */
name|struct
name|bhnd_core_match
name|m_core
init|=
block|{
name|_BHND_CORE_MATCH_COPY
argument_list|(
argument|desc
argument_list|)
block|}
decl_stmt|;
name|struct
name|bhnd_chip_match
name|m_chip
init|=
block|{
name|_BHND_CHIP_MATCH_COPY
argument_list|(
argument|desc
argument_list|)
block|}
decl_stmt|;
name|struct
name|bhnd_board_match
name|m_board
init|=
block|{
name|_BHND_BOARD_MATCH_COPY
argument_list|(
argument|desc
argument_list|)
block|}
decl_stmt|;
comment|/* Fetch and match core info */
if|if
condition|(
name|m_core
operator|.
name|m
operator|.
name|match_flags
condition|)
block|{
comment|/* Only applicable to bhnd-attached cores */
name|parent
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_devclass
argument_list|(
name|parent
argument_list|)
operator|!=
name|bhnd_devclass
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"attempting to match core "
literal|"attributes against non-core device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
name|core
operator|=
name|bhnd_get_core_info
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bhnd_core_matches
argument_list|(
operator|&
name|core
argument_list|,
operator|&
name|m_core
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
comment|/* Fetch and match chip info */
if|if
condition|(
name|m_chip
operator|.
name|m
operator|.
name|match_flags
condition|)
block|{
name|chip
operator|=
name|bhnd_get_chipid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bhnd_chip_matches
argument_list|(
name|chip
argument_list|,
operator|&
name|m_chip
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
comment|/* Fetch and match board info. 	 * 	 * This is not available until  after NVRAM is up; earlier device 	 * matches should not include board requirements */
if|if
condition|(
name|m_board
operator|.
name|m
operator|.
name|match_flags
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_read_board_info
argument_list|(
name|dev
argument_list|,
operator|&
name|board
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to read required board info "
literal|"during device matching: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|bhnd_board_matches
argument_list|(
operator|&
name|board
argument_list|,
operator|&
name|m_board
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
comment|/* All matched */
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Search @p table for an entry matching @p dev.  *   * @param dev A bhnd device to match against @p table.  * @param table The device table to search.  * @param entry_size The @p table entry size, in bytes.  *   * @retval bhnd_device the first matching device, if any.  * @retval NULL if no matching device is found in @p table.  */
end_comment

begin_function
specifier|const
name|struct
name|bhnd_device
modifier|*
name|bhnd_device_lookup
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|bhnd_device
modifier|*
name|table
parameter_list|,
name|size_t
name|entry_size
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_device
modifier|*
name|entry
decl_stmt|;
name|device_t
name|hostb
decl_stmt|,
name|parent
decl_stmt|;
name|bhnd_attach_type
name|attach_type
decl_stmt|;
name|uint32_t
name|dflags
decl_stmt|;
name|parent
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hostb
operator|=
name|bhnd_bus_find_hostb_device
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|attach_type
operator|=
name|bhnd_get_attach_type
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|table
init|;
operator|!
name|BHND_DEVICE_IS_END
argument_list|(
name|entry
argument_list|)
condition|;
name|entry
operator|=
operator|(
specifier|const
expr|struct
name|bhnd_device
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|entry
operator|+
name|entry_size
operator|)
control|)
block|{
comment|/* match core info */
if|if
condition|(
operator|!
name|bhnd_device_matches
argument_list|(
name|dev
argument_list|,
operator|&
name|entry
operator|->
name|core
argument_list|)
condition|)
continue|continue;
comment|/* match device flags */
name|dflags
operator|=
name|entry
operator|->
name|device_flags
expr_stmt|;
comment|/* hostb implies BHND_ATTACH_ADAPTER requirement */
if|if
condition|(
name|dflags
operator|&
name|BHND_DF_HOSTB
condition|)
name|dflags
operator||=
name|BHND_DF_ADAPTER
expr_stmt|;
if|if
condition|(
name|dflags
operator|&
name|BHND_DF_ADAPTER
condition|)
if|if
condition|(
name|attach_type
operator|!=
name|BHND_ATTACH_ADAPTER
condition|)
continue|continue;
if|if
condition|(
name|dflags
operator|&
name|BHND_DF_HOSTB
condition|)
if|if
condition|(
name|dev
operator|!=
name|hostb
condition|)
continue|continue;
if|if
condition|(
name|dflags
operator|&
name|BHND_DF_SOC
condition|)
if|if
condition|(
name|attach_type
operator|!=
name|BHND_ATTACH_NATIVE
condition|)
continue|continue;
comment|/* device found */
return|return
operator|(
name|entry
operator|)
return|;
block|}
comment|/* not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Scan the device @p table for all quirk flags applicable to @p dev.  *   * @param dev A bhnd device to match against @p table.  * @param table The device table to search.  *   * @return returns all matching quirk flags.  */
end_comment

begin_function
name|uint32_t
name|bhnd_device_quirks
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|bhnd_device
modifier|*
name|table
parameter_list|,
name|size_t
name|entry_size
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_device
modifier|*
name|dent
decl_stmt|;
specifier|const
name|struct
name|bhnd_device_quirk
modifier|*
name|qent
decl_stmt|,
modifier|*
name|qtable
decl_stmt|;
name|uint32_t
name|quirks
decl_stmt|;
comment|/* Locate the device entry */
if|if
condition|(
operator|(
name|dent
operator|=
name|bhnd_device_lookup
argument_list|(
name|dev
argument_list|,
name|table
argument_list|,
name|entry_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Quirks table is optional */
name|qtable
operator|=
name|dent
operator|->
name|quirks_table
expr_stmt|;
if|if
condition|(
name|qtable
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Collect matching device quirk entries */
name|quirks
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|qent
operator|=
name|qtable
init|;
operator|!
name|BHND_DEVICE_QUIRK_IS_END
argument_list|(
name|qent
argument_list|)
condition|;
name|qent
operator|++
control|)
block|{
if|if
condition|(
name|bhnd_device_matches
argument_list|(
name|dev
argument_list|,
operator|&
name|qent
operator|->
name|desc
argument_list|)
condition|)
name|quirks
operator||=
name|qent
operator|->
name|quirks
expr_stmt|;
block|}
return|return
operator|(
name|quirks
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Allocate bhnd(4) resources defined in @p rs from a parent bus.  *   * @param dev The device requesting ownership of the resources.  * @param rs A standard bus resource specification. This will be updated  * with the allocated resource's RIDs.  * @param res On success, the allocated bhnd resources.  *   * @retval 0 success  * @retval non-zero if allocation of any non-RF_OPTIONAL resource fails,  * 		    all allocated resources will be released and a regular  * 		    unix error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_alloc_resources
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|resource_spec
modifier|*
name|rs
parameter_list|,
name|struct
name|bhnd_resource
modifier|*
modifier|*
name|res
parameter_list|)
block|{
comment|/* Initialize output array */
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|rs
index|[
name|i
index|]
operator|.
name|type
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|res
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|rs
index|[
name|i
index|]
operator|.
name|type
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|res
index|[
name|i
index|]
operator|=
name|bhnd_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|rs
index|[
name|i
index|]
operator|.
name|type
argument_list|,
operator|&
name|rs
index|[
name|i
index|]
operator|.
name|rid
argument_list|,
name|rs
index|[
name|i
index|]
operator|.
name|flags
argument_list|)
expr_stmt|;
comment|/* Clean up all allocations on failure */
if|if
condition|(
name|res
index|[
name|i
index|]
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|rs
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|RF_OPTIONAL
operator|)
condition|)
block|{
name|bhnd_release_resources
argument_list|(
name|dev
argument_list|,
name|rs
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Release bhnd(4) resources defined in @p rs from a parent bus.  *   * @param dev The device that owns the resources.  * @param rs A standard bus resource specification previously initialized  * by @p bhnd_alloc_resources.  * @param res The bhnd resources to be released.  */
end_comment

begin_function
name|void
name|bhnd_release_resources
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|resource_spec
modifier|*
name|rs
parameter_list|,
name|struct
name|bhnd_resource
modifier|*
modifier|*
name|res
parameter_list|)
block|{
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|rs
index|[
name|i
index|]
operator|.
name|type
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|res
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|bhnd_release_resource
argument_list|(
name|dev
argument_list|,
name|rs
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|rs
index|[
name|i
index|]
operator|.
name|rid
argument_list|,
name|res
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|res
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Parse the CHIPC_ID_* fields from the ChipCommon CHIPC_ID  * register, returning its bhnd_chipid representation.  *   * @param idreg The CHIPC_ID register value.  * @param enum_addr The enumeration address to include in the result.  *  * @warning  * On early siba(4) devices, the ChipCommon core does not provide  * a valid CHIPC_ID_NUMCORE field. On these ChipCommon revisions  * (see CHIPC_NCORES_MIN_HWREV()), this function will parse and return  * an invalid `ncores` value.  */
end_comment

begin_function
name|struct
name|bhnd_chipid
name|bhnd_parse_chipid
parameter_list|(
name|uint32_t
name|idreg
parameter_list|,
name|bhnd_addr_t
name|enum_addr
parameter_list|)
block|{
name|struct
name|bhnd_chipid
name|result
decl_stmt|;
comment|/* Fetch the basic chip info */
name|result
operator|.
name|chip_id
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|idreg
argument_list|,
name|CHIPC_ID_CHIP
argument_list|)
expr_stmt|;
name|result
operator|.
name|chip_pkg
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|idreg
argument_list|,
name|CHIPC_ID_PKG
argument_list|)
expr_stmt|;
name|result
operator|.
name|chip_rev
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|idreg
argument_list|,
name|CHIPC_ID_REV
argument_list|)
expr_stmt|;
name|result
operator|.
name|chip_type
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|idreg
argument_list|,
name|CHIPC_ID_BUS
argument_list|)
expr_stmt|;
name|result
operator|.
name|ncores
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|idreg
argument_list|,
name|CHIPC_ID_NUMCORE
argument_list|)
expr_stmt|;
name|result
operator|.
name|enum_addr
operator|=
name|enum_addr
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Determine the correct core count for a chip identification value that  * may contain an invalid core count.  *   * On some early siba(4) devices (see CHIPC_NCORES_MIN_HWREV()), the ChipCommon  * core does not provide a valid CHIPC_ID_NUMCORE field.  *   * @param cid The chip identification to be queried.  * @param chipc_hwrev The hardware revision of the ChipCommon core from which  * @p cid was parsed.  * @param[out] ncores On success, will be set to the correct core count.  *   * @retval 0 If the core count is already correct, or was mapped to a  * a correct value.  * @retval EINVAL If the core count is incorrect, but the chip was not  * recognized.  */
end_comment

begin_function
name|int
name|bhnd_chipid_fixed_ncores
parameter_list|(
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|cid
parameter_list|,
name|uint16_t
name|chipc_hwrev
parameter_list|,
name|uint8_t
modifier|*
name|ncores
parameter_list|)
block|{
comment|/* bcma(4), and most siba(4) devices */
if|if
condition|(
name|CHIPC_NCORES_MIN_HWREV
argument_list|(
name|chipc_hwrev
argument_list|)
condition|)
block|{
operator|*
name|ncores
operator|=
name|cid
operator|->
name|ncores
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* broken siba(4) chipsets */
switch|switch
condition|(
name|cid
operator|->
name|chip_id
condition|)
block|{
case|case
name|BHND_CHIPID_BCM4306
case|:
operator|*
name|ncores
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|BHND_CHIPID_BCM4704
case|:
operator|*
name|ncores
operator|=
literal|9
expr_stmt|;
break|break;
case|case
name|BHND_CHIPID_BCM5365
case|:
comment|/* 		* BCM5365 does support ID_NUMCORE in at least 		* some of its revisions, but for unknown 		* reasons, Broadcom's drivers always exclude 		* the ChipCommon revision (0x5) used by BCM5365 		* from the set of revisions supporting 		* ID_NUMCORE, and instead supply a fixed value. 		*  		* Presumably, at least some of these devices 		* shipped with a broken ID_NUMCORE value. 		*/
operator|*
name|ncores
operator|=
literal|7
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Allocate the resource defined by @p rs via @p dev, use it  * to read the ChipCommon ID register relative to @p chipc_offset,  * then release the resource.  *   * @param dev The device owning @p rs.  * @param rs A resource spec that encompasses the ChipCommon register block.  * @param chipc_offset The offset of the ChipCommon registers within @p rs.  * @param[out] result the chip identification data.  *   * @retval 0 success  * @retval non-zero if the ChipCommon identification data could not be read.  */
end_comment

begin_function
name|int
name|bhnd_read_chipid
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|resource_spec
modifier|*
name|rs
parameter_list|,
name|bus_size_t
name|chipc_offset
parameter_list|,
name|struct
name|bhnd_chipid
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|bhnd_addr_t
name|enum_addr
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|uint8_t
name|chip_type
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|,
name|rtype
decl_stmt|;
name|rid
operator|=
name|rs
operator|->
name|rid
expr_stmt|;
name|rtype
operator|=
name|rs
operator|->
name|type
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Allocate the ChipCommon window resource and fetch the chipid data */
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|rtype
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate bhnd chipc resource\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Fetch the basic chip info */
name|reg
operator|=
name|bus_read_4
argument_list|(
name|res
argument_list|,
name|chipc_offset
operator|+
name|CHIPC_ID
argument_list|)
expr_stmt|;
name|chip_type
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|reg
argument_list|,
name|CHIPC_ID_BUS
argument_list|)
expr_stmt|;
comment|/* Fetch the EROMPTR */
if|if
condition|(
name|BHND_CHIPTYPE_HAS_EROM
argument_list|(
name|chip_type
argument_list|)
condition|)
block|{
name|enum_addr
operator|=
name|bus_read_4
argument_list|(
name|res
argument_list|,
name|chipc_offset
operator|+
name|CHIPC_EROMPTR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chip_type
operator|==
name|BHND_CHIPTYPE_SIBA
condition|)
block|{
comment|/* siba(4) uses the ChipCommon base address as the enumeration 		 * address */
name|enum_addr
operator|=
name|BHND_DEFAULT_CHIPC_ADDR
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unknown chip type %hhu\n"
argument_list|,
name|chip_type
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
operator|*
name|result
operator|=
name|bhnd_parse_chipid
argument_list|(
name|reg
argument_list|,
name|enum_addr
argument_list|)
expr_stmt|;
comment|/* Fix the core count on early siba(4) devices */
if|if
condition|(
name|chip_type
operator|==
name|BHND_CHIPTYPE_SIBA
condition|)
block|{
name|uint32_t
name|idh
decl_stmt|;
name|uint16_t
name|chipc_hwrev
decl_stmt|;
comment|/*  		 * We need the ChipCommon revision to determine whether 		 * the ncore field is valid. 		 *  		 * We can safely assume the siba IDHIGH register is mapped 		 * within the chipc register block. 		 */
name|idh
operator|=
name|bus_read_4
argument_list|(
name|res
argument_list|,
name|SB0_REG_ABS
argument_list|(
name|SIBA_CFG0_IDHIGH
argument_list|)
argument_list|)
expr_stmt|;
name|chipc_hwrev
operator|=
name|SIBA_IDH_CORE_REV
argument_list|(
name|idh
argument_list|)
expr_stmt|;
name|error
operator|=
name|bhnd_chipid_fixed_ncores
argument_list|(
name|result
argument_list|,
name|chipc_hwrev
argument_list|,
operator|&
name|result
operator|->
name|ncores
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|cleanup
label|:
comment|/* Clean up */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|rtype
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read an NVRAM variable's NUL-terminated string value.  *  * @param 	dev	A bhnd bus child device.  * @param	name	The NVRAM variable name.  * @param[out]	buf	A buffer large enough to hold @p len bytes. On  *			success, the NUL-terminated string value will be  *			written to this buffer. This argment may be NULL if  *			the value is not desired.  * @param	len	The maximum capacity of @p buf.  * @param[out]	rlen	On success, will be set to the actual size of  *			the requested value (including NUL termination). This  *			argment may be NULL if the size is not desired.  *  * @retval 0		success  * @retval ENOENT	The requested variable was not found.  * @retval ENODEV	No valid NVRAM source could be found.  * @retval ENOMEM	If @p buf is non-NULL and a buffer of @p len is too  *			small to hold the requested value.  * @retval EFTYPE	If the variable data cannot be coerced to a valid  *			string representation.  * @retval ERANGE	If value coercion would overflow @p type.  * @retval non-zero	If reading @p name otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_nvram_getvar_str
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|size_t
modifier|*
name|rlen
parameter_list|)
block|{
name|size_t
name|larg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|larg
operator|=
name|len
expr_stmt|;
name|error
operator|=
name|bhnd_nvram_getvar
argument_list|(
name|dev
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
operator|&
name|larg
argument_list|,
name|BHND_NVRAM_TYPE_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlen
operator|!=
name|NULL
condition|)
operator|*
name|rlen
operator|=
name|larg
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read an NVRAM variable's unsigned integer value.  *  * @param 		dev	A bhnd bus child device.  * @param		name	The NVRAM variable name.  * @param[out]		value	On success, the requested value will be written  *				to this pointer.  * @param		width	The output integer type width (1, 2, or  *				4 bytes).  *   * @retval 0		success  * @retval ENOENT	The requested variable was not found.  * @retval ENODEV	No valid NVRAM source could be found.  * @retval EFTYPE	If the variable data cannot be coerced to a  *			a valid unsigned integer representation.  * @retval ERANGE	If value coercion would overflow (or underflow) an  *			unsigned representation of the given @p width.  * @retval non-zero	If reading @p name otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_nvram_getvar_uint
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|value
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|bhnd_nvram_type
name|type
decl_stmt|;
name|size_t
name|len
decl_stmt|;
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|1
case|:
name|type
operator|=
name|BHND_NVRAM_TYPE_UINT8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|type
operator|=
name|BHND_NVRAM_TYPE_UINT16
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|type
operator|=
name|BHND_NVRAM_TYPE_UINT32
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unsupported NVRAM integer width: %d\n"
argument_list|,
name|width
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|len
operator|=
name|width
expr_stmt|;
return|return
operator|(
name|bhnd_nvram_getvar
argument_list|(
name|dev
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
operator|&
name|len
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read an NVRAM variable's unsigned 8-bit integer value.  *  * @param 		dev	A bhnd bus child device.  * @param		name	The NVRAM variable name.  * @param[out]		value	On success, the requested value will be written  *				to this pointer.  *   * @retval 0		success  * @retval ENOENT	The requested variable was not found.  * @retval ENODEV	No valid NVRAM source could be found.  * @retval EFTYPE	If the variable data cannot be coerced to a  *			a valid unsigned integer representation.  * @retval ERANGE	If value coercion would overflow (or underflow) uint8_t.  * @retval non-zero	If reading @p name otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_nvram_getvar_uint8
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint8_t
modifier|*
name|value
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_getvar_uint
argument_list|(
name|dev
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|value
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read an NVRAM variable's unsigned 16-bit integer value.  *  * @param 		dev	A bhnd bus child device.  * @param		name	The NVRAM variable name.  * @param[out]		value	On success, the requested value will be written  *				to this pointer.  *   * @retval 0		success  * @retval ENOENT	The requested variable was not found.  * @retval ENODEV	No valid NVRAM source could be found.  * @retval EFTYPE	If the variable data cannot be coerced to a  *			a valid unsigned integer representation.  * @retval ERANGE	If value coercion would overflow (or underflow)  *			uint16_t.  * @retval non-zero	If reading @p name otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_nvram_getvar_uint16
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint16_t
modifier|*
name|value
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_getvar_uint
argument_list|(
name|dev
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|value
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read an NVRAM variable's unsigned 32-bit integer value.  *  * @param 		dev	A bhnd bus child device.  * @param		name	The NVRAM variable name.  * @param[out]		value	On success, the requested value will be written  *				to this pointer.  *   * @retval 0		success  * @retval ENOENT	The requested variable was not found.  * @retval ENODEV	No valid NVRAM source could be found.  * @retval EFTYPE	If the variable data cannot be coerced to a  *			a valid unsigned integer representation.  * @retval ERANGE	If value coercion would overflow (or underflow)  *			uint32_t.  * @retval non-zero	If reading @p name otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_nvram_getvar_uint32
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint32_t
modifier|*
name|value
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_getvar_uint
argument_list|(
name|dev
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|value
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read an NVRAM variable's signed integer value.  *  * @param 		dev	A bhnd bus child device.  * @param		name	The NVRAM variable name.  * @param[out]		value	On success, the requested value will be written  *				to this pointer.  * @param		width	The output integer type width (1, 2, or  *				4 bytes).  *   * @retval 0		success  * @retval ENOENT	The requested variable was not found.  * @retval ENODEV	No valid NVRAM source could be found.  * @retval EFTYPE	If the variable data cannot be coerced to a  *			a valid integer representation.  * @retval ERANGE	If value coercion would overflow (or underflow) an  *			signed representation of the given @p width.  * @retval non-zero	If reading @p name otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_nvram_getvar_int
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|value
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|bhnd_nvram_type
name|type
decl_stmt|;
name|size_t
name|len
decl_stmt|;
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|1
case|:
name|type
operator|=
name|BHND_NVRAM_TYPE_INT8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|type
operator|=
name|BHND_NVRAM_TYPE_INT16
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|type
operator|=
name|BHND_NVRAM_TYPE_INT32
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unsupported NVRAM integer width: %d\n"
argument_list|,
name|width
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|len
operator|=
name|width
expr_stmt|;
return|return
operator|(
name|bhnd_nvram_getvar
argument_list|(
name|dev
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
operator|&
name|len
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read an NVRAM variable's signed 8-bit integer value.  *  * @param 		dev	A bhnd bus child device.  * @param		name	The NVRAM variable name.  * @param[out]		value	On success, the requested value will be written  *				to this pointer.  *   * @retval 0		success  * @retval ENOENT	The requested variable was not found.  * @retval ENODEV	No valid NVRAM source could be found.  * @retval EFTYPE	If the variable data cannot be coerced to a  *			a valid integer representation.  * @retval ERANGE	If value coercion would overflow (or underflow) int8_t.  * @retval non-zero	If reading @p name otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_nvram_getvar_int8
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int8_t
modifier|*
name|value
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_getvar_int
argument_list|(
name|dev
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|value
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read an NVRAM variable's signed 16-bit integer value.  *  * @param 		dev	A bhnd bus child device.  * @param		name	The NVRAM variable name.  * @param[out]		value	On success, the requested value will be written  *				to this pointer.  *   * @retval 0		success  * @retval ENOENT	The requested variable was not found.  * @retval ENODEV	No valid NVRAM source could be found.  * @retval EFTYPE	If the variable data cannot be coerced to a  *			a valid integer representation.  * @retval ERANGE	If value coercion would overflow (or underflow)  *			int16_t.  * @retval non-zero	If reading @p name otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_nvram_getvar_int16
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int16_t
modifier|*
name|value
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_getvar_int
argument_list|(
name|dev
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|value
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read an NVRAM variable's signed 32-bit integer value.  *  * @param 		dev	A bhnd bus child device.  * @param		name	The NVRAM variable name.  * @param[out]		value	On success, the requested value will be written  *				to this pointer.  *   * @retval 0		success  * @retval ENOENT	The requested variable was not found.  * @retval ENODEV	No valid NVRAM source could be found.  * @retval EFTYPE	If the variable data cannot be coerced to a  *			a valid integer representation.  * @retval ERANGE	If value coercion would overflow (or underflow)  *			int32_t.  * @retval non-zero	If reading @p name otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_nvram_getvar_int32
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int32_t
modifier|*
name|value
parameter_list|)
block|{
return|return
operator|(
name|bhnd_nvram_getvar_int
argument_list|(
name|dev
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|value
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read an NVRAM variable's array value.  *  * @param 		dev	A bhnd bus child device.  * @param		name	The NVRAM variable name.  * @param[out]		buf	A buffer large enough to hold @p size bytes.  *				On success, the requested value will be written  *				to this buffer.  * @param[in,out]	size	The required number of bytes to write to  *				@p buf.  * @param		type	The desired array element data representation.  *   * @retval 0		success  * @retval ENOENT	The requested variable was not found.  * @retval ENODEV	No valid NVRAM source could be found.  * @retval ENXIO	If less than @p size bytes are available.  * @retval ENOMEM	If a buffer of @p size is too small to hold the  *			requested value.  * @retval EFTYPE	If the variable data cannot be coerced to a  *			a valid instance of @p type.  * @retval ERANGE	If value coercion would overflow (or underflow) a  *			representation of @p type.  * @retval non-zero	If reading @p name otherwise fails, a regular unix  *			error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_nvram_getvar_array
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bhnd_nvram_type
name|type
parameter_list|)
block|{
name|size_t
name|nbytes
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Attempt read */
name|nbytes
operator|=
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_nvram_getvar
argument_list|(
name|dev
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
operator|&
name|nbytes
argument_list|,
name|type
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Verify that the expected number of bytes were fetched */
if|if
condition|(
name|nbytes
operator|<
name|size
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize a service provider registry.  *   * @param bsr		The service registry to initialize.  *   * @retval 0            success  * @retval non-zero     if an error occurs initializing the service registry,  *                      a regular unix error code will be returned.   */
end_comment

begin_function
name|int
name|bhnd_service_registry_init
parameter_list|(
name|struct
name|bhnd_service_registry
modifier|*
name|bsr
parameter_list|)
block|{
name|STAILQ_INIT
argument_list|(
operator|&
name|bsr
operator|->
name|entries
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|bsr
operator|->
name|lock
argument_list|,
literal|"bhnd_service_registry lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Release all resources held by @p bsr.  *   * @param bsr		A service registry instance previously successfully  *			initialized via bhnd_service_registry_init().  *  * @retval 0		success  * @retval EBUSY	if active references to service providers registered  *			with @p bsr exist.  */
end_comment

begin_function
name|int
name|bhnd_service_registry_fini
parameter_list|(
name|struct
name|bhnd_service_registry
modifier|*
name|bsr
parameter_list|)
block|{
name|struct
name|bhnd_service_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|enext
decl_stmt|;
comment|/* Remove everthing we can */
name|mtx_lock
argument_list|(
operator|&
name|bsr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|entry
argument_list|,
argument|&bsr->entries
argument_list|,
argument|link
argument_list|,
argument|enext
argument_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|refs
operator|>
literal|0
condition|)
continue|continue;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|bsr
operator|->
name|entries
argument_list|,
name|entry
argument_list|,
name|bhnd_service_entry
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|bsr
operator|->
name|entries
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|bsr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|bsr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|bsr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Register a @p provider for the given @p service.  *  * @param bsr		Service registry to be modified.  * @param provider	Service provider to register.  * @param service	Service for which @p provider will be registered.  * @param flags		Service provider flags (see BHND_SPF_*).  *  * @retval 0		success  * @retval EEXIST	if an entry for @p service already exists.  * @retval EINVAL	if @p service is BHND_SERVICE_ANY.  * @retval non-zero	if registering @p provider otherwise fails, a regular  *			unix error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_service_registry_add
parameter_list|(
name|struct
name|bhnd_service_registry
modifier|*
name|bsr
parameter_list|,
name|device_t
name|provider
parameter_list|,
name|bhnd_service_t
name|service
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|bhnd_service_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|service
operator|==
name|BHND_SERVICE_ANY
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|bsr
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* Is a service provider already registered? */
name|STAILQ_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&bsr->entries
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|service
operator|==
name|service
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|bsr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
block|}
comment|/* Initialize and insert our new entry */
name|entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|bsr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|entry
operator|->
name|provider
operator|=
name|provider
expr_stmt|;
name|entry
operator|->
name|service
operator|=
name|service
expr_stmt|;
name|entry
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|entry
operator|->
name|refs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|bsr
operator|->
name|entries
argument_list|,
name|entry
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bsr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Free an unreferenced registry entry.  *   * @param entry	The entry to be deallocated.  */
end_comment

begin_function
specifier|static
name|void
name|bhnd_service_registry_free_entry
parameter_list|(
name|struct
name|bhnd_service_entry
modifier|*
name|entry
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|entry
operator|->
name|refs
operator|==
literal|0
argument_list|,
operator|(
literal|"provider has active references"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Attempt to remove the @p service provider registration for @p provider.  *  * @param bsr		The service registry to be modified.  * @param provider	The service provider to be deregistered.  * @param service	The service for which @p provider will be deregistered,  *			or BHND_SERVICE_ANY to remove all service  *			registrations for @p provider.  *  * @retval 0		success  * @retval EBUSY	if active references to @p provider exist; @see  *			bhnd_service_registry_retain() and  *			bhnd_service_registry_release().  */
end_comment

begin_function
name|int
name|bhnd_service_registry_remove
parameter_list|(
name|struct
name|bhnd_service_registry
modifier|*
name|bsr
parameter_list|,
name|device_t
name|provider
parameter_list|,
name|bhnd_service_t
name|service
parameter_list|)
block|{
name|struct
name|bhnd_service_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|enext
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bsr
operator|->
name|lock
argument_list|)
expr_stmt|;
define|#
directive|define
name|BHND_PROV_MATCH
parameter_list|(
name|_e
parameter_list|)
define|\
value|((_e)->provider == provider&&	\ 	 (service == BHND_SERVICE_ANY || (_e)->service == service))
comment|/* Validate matching provider entries before making any 	 * modifications */
name|STAILQ_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&bsr->entries
argument_list|,
argument|link
argument_list|)
block|{
comment|/* Skip non-matching entries */
if|if
condition|(
operator|!
name|BHND_PROV_MATCH
argument_list|(
name|entry
argument_list|)
condition|)
continue|continue;
comment|/* Entry is in use? */
if|if
condition|(
name|entry
operator|->
name|refs
operator|>
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|bsr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
comment|/* We can now safely remove matching entries */
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|entry
argument_list|,
argument|&bsr->entries
argument_list|,
argument|link
argument_list|,
argument|enext
argument_list|)
block|{
comment|/* Skip non-matching entries */
if|if
condition|(
operator|!
name|BHND_PROV_MATCH
argument_list|(
name|entry
argument_list|)
condition|)
continue|continue;
comment|/* Remove from list */
name|STAILQ_REMOVE
argument_list|(
operator|&
name|bsr
operator|->
name|entries
argument_list|,
name|entry
argument_list|,
name|bhnd_service_entry
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* Free provider entry */
name|bhnd_service_registry_free_entry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|BHND_PROV_MATCH
name|mtx_unlock
argument_list|(
operator|&
name|bsr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Retain and return a reference to a registered @p service provider, if any.  *  * @param bsr		The service registry to be queried.  * @param service	The service for which a provider should be returned.  *  * On success, the caller assumes ownership the returned provider, and  * is responsible for releasing this reference via  * bhnd_service_registry_release().  *  * @retval device_t	success  * @retval NULL		if no provider is registered for @p service.  */
end_comment

begin_function
name|device_t
name|bhnd_service_registry_retain
parameter_list|(
name|struct
name|bhnd_service_registry
modifier|*
name|bsr
parameter_list|,
name|bhnd_service_t
name|service
parameter_list|)
block|{
name|struct
name|bhnd_service_entry
modifier|*
name|entry
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bsr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&bsr->entries
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|service
operator|!=
name|service
condition|)
continue|continue;
comment|/* With a live refcount, entry is gauranteed to remain alive 		 * after we release our lock */
name|refcount_acquire
argument_list|(
operator|&
name|entry
operator|->
name|refs
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bsr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|entry
operator|->
name|provider
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|bsr
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* Not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Release a reference to a service provider previously returned by  * bhnd_service_registry_retain().  *   * If this is the last reference to an inherited service provider registration  * (@see BHND_SPF_INHERITED), the registration will also be removed, and  * true will be returned.  *  * @param bsr		The service registry from which @p provider  *			was returned.  * @param provider	The provider to be released.  * @param service	The service for which @p provider was previously  *			retained.  * @retval true		The inherited service provider registration was removed;  *			the caller should release its own reference to the  *			provider.  * @retval false	The service provider was not inherited, or active  *			references to the provider remain.  */
end_comment

begin_function
name|bool
name|bhnd_service_registry_release
parameter_list|(
name|struct
name|bhnd_service_registry
modifier|*
name|bsr
parameter_list|,
name|device_t
name|provider
parameter_list|,
name|bhnd_service_t
name|service
parameter_list|)
block|{
name|struct
name|bhnd_service_entry
modifier|*
name|entry
decl_stmt|;
comment|/* Exclusive lock, as we need to prevent any new references to the 	 * entry from being taken if it's to be removed */
name|mtx_lock
argument_list|(
operator|&
name|bsr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&bsr->entries
argument_list|,
argument|link
argument_list|)
block|{
name|bool
name|removed
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|provider
operator|!=
name|provider
condition|)
continue|continue;
if|if
condition|(
name|entry
operator|->
name|service
operator|!=
name|service
condition|)
continue|continue;
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|entry
operator|->
name|refs
argument_list|)
operator|&&
operator|(
name|entry
operator|->
name|flags
operator|&
name|BHND_SPF_INHERITED
operator|)
condition|)
block|{
comment|/* If an inherited entry is no longer actively 			 * referenced, remove the local registration and inform 			 * the caller. */
name|STAILQ_REMOVE
argument_list|(
operator|&
name|bsr
operator|->
name|entries
argument_list|,
name|entry
argument_list|,
name|bhnd_service_entry
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|bhnd_service_registry_free_entry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|removed
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|removed
operator|=
name|false
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|bsr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|removed
operator|)
return|;
block|}
comment|/* Caller owns a reference, but no such provider is registered? */
name|panic
argument_list|(
literal|"invalid service provider reference"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Using the bhnd(4) bus-level core information and a custom core name,  * populate @p dev's device description.  *   * @param dev A bhnd-bus attached device.  * @param dev_name The core's name (e.g. "SDIO Device Core")  */
end_comment

begin_function
name|void
name|bhnd_set_custom_core_desc
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|dev_name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|vendor_name
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
name|vendor_name
operator|=
name|bhnd_get_vendor_name
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|desc
argument_list|,
name|M_BHND
argument_list|,
literal|"%s %s, rev %hhu"
argument_list|,
name|vendor_name
argument_list|,
name|dev_name
argument_list|,
name|bhnd_get_hwrev
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|!=
name|NULL
condition|)
block|{
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|desc
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Using the bhnd(4) bus-level core information, populate @p dev's device  * description.  *   * @param dev A bhnd-bus attached device.  */
end_comment

begin_function
name|void
name|bhnd_set_default_core_desc
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|bhnd_set_custom_core_desc
argument_list|(
name|dev
argument_list|,
name|bhnd_get_device_name
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Using the bhnd @p chip_id, populate the bhnd(4) bus @p dev's device  * description.  *   * @param dev A bhnd-bus attached device.  */
end_comment

begin_function
name|void
name|bhnd_set_default_bus_desc
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|chip_id
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|bus_name
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
name|char
name|chip_name
index|[
name|BHND_CHIPID_MAX_NAMELEN
index|]
decl_stmt|;
comment|/* Determine chip type's bus name */
switch|switch
condition|(
name|chip_id
operator|->
name|chip_type
condition|)
block|{
case|case
name|BHND_CHIPTYPE_SIBA
case|:
name|bus_name
operator|=
literal|"SIBA bus"
expr_stmt|;
break|break;
case|case
name|BHND_CHIPTYPE_BCMA
case|:
case|case
name|BHND_CHIPTYPE_BCMA_ALT
case|:
name|bus_name
operator|=
literal|"BCMA bus"
expr_stmt|;
break|break;
case|case
name|BHND_CHIPTYPE_UBUS
case|:
name|bus_name
operator|=
literal|"UBUS bus"
expr_stmt|;
break|break;
default|default:
name|bus_name
operator|=
literal|"Unknown Type"
expr_stmt|;
break|break;
block|}
comment|/* Format chip name */
name|bhnd_format_chip_id
argument_list|(
name|chip_name
argument_list|,
sizeof|sizeof
argument_list|(
name|chip_name
argument_list|)
argument_list|,
name|chip_id
operator|->
name|chip_id
argument_list|)
expr_stmt|;
comment|/* Format and set device description */
name|asprintf
argument_list|(
operator|&
name|desc
argument_list|,
name|M_BHND
argument_list|,
literal|"%s %s"
argument_list|,
name|chip_name
argument_list|,
name|bus_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|!=
name|NULL
condition|)
block|{
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|desc
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|bus_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_REGISTER_PROVIDER().  *   * This implementation delegates the request to the BHND_BUS_REGISTER_PROVIDER()  * method on the parent of @p dev. If no parent exists, the implementation  * will return an error.   */
end_comment

begin_function
name|int
name|bhnd_bus_generic_register_provider
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|device_t
name|provider
parameter_list|,
name|bhnd_service_t
name|service
parameter_list|)
block|{
name|device_t
name|parent
init|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|BHND_BUS_REGISTER_PROVIDER
argument_list|(
name|parent
argument_list|,
name|child
argument_list|,
name|provider
argument_list|,
name|service
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_DEREGISTER_PROVIDER().  *   * This implementation delegates the request to the  * BHND_BUS_DEREGISTER_PROVIDER() method on the parent of @p dev. If no parent  * exists, the implementation will panic.  */
end_comment

begin_function
name|int
name|bhnd_bus_generic_deregister_provider
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|device_t
name|provider
parameter_list|,
name|bhnd_service_t
name|service
parameter_list|)
block|{
name|device_t
name|parent
init|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|BHND_BUS_DEREGISTER_PROVIDER
argument_list|(
name|parent
argument_list|,
name|child
argument_list|,
name|provider
argument_list|,
name|service
argument_list|)
operator|)
return|;
block|}
name|panic
argument_list|(
literal|"missing BHND_BUS_DEREGISTER_PROVIDER()"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_RETAIN_PROVIDER().  *   * This implementation delegates the request to the  * BHND_BUS_DEREGISTER_PROVIDER() method on the parent of @p dev. If no parent  * exists, the implementation will return NULL.  */
end_comment

begin_function
name|device_t
name|bhnd_bus_generic_retain_provider
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|bhnd_service_t
name|service
parameter_list|)
block|{
name|device_t
name|parent
init|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|BHND_BUS_RETAIN_PROVIDER
argument_list|(
name|parent
argument_list|,
name|child
argument_list|,
name|service
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_RELEASE_PROVIDER().  *   * This implementation delegates the request to the  * BHND_BUS_DEREGISTER_PROVIDER() method on the parent of @p dev. If no parent  * exists, the implementation will panic.  */
end_comment

begin_function
name|void
name|bhnd_bus_generic_release_provider
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|device_t
name|provider
parameter_list|,
name|bhnd_service_t
name|service
parameter_list|)
block|{
name|device_t
name|parent
init|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|BHND_BUS_RELEASE_PROVIDER
argument_list|(
name|parent
argument_list|,
name|child
argument_list|,
name|provider
argument_list|,
name|service
argument_list|)
operator|)
return|;
block|}
name|panic
argument_list|(
literal|"missing BHND_BUS_RELEASE_PROVIDER()"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_REGISTER_PROVIDER().  *   * This implementation uses the bhnd_service_registry_add() function to  * do most of the work. It calls BHND_BUS_GET_SERVICE_REGISTRY() to find  * a suitable service registry to edit.  */
end_comment

begin_function
name|int
name|bhnd_bus_generic_sr_register_provider
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|device_t
name|provider
parameter_list|,
name|bhnd_service_t
name|service
parameter_list|)
block|{
name|struct
name|bhnd_service_registry
modifier|*
name|bsr
decl_stmt|;
name|bsr
operator|=
name|BHND_BUS_GET_SERVICE_REGISTRY
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bsr
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL service registry"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bhnd_service_registry_add
argument_list|(
name|bsr
argument_list|,
name|provider
argument_list|,
name|service
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_DEREGISTER_PROVIDER().  *   * This implementation uses the bhnd_service_registry_remove() function to  * do most of the work. It calls BHND_BUS_GET_SERVICE_REGISTRY() to find  * a suitable service registry to edit.  */
end_comment

begin_function
name|int
name|bhnd_bus_generic_sr_deregister_provider
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|device_t
name|provider
parameter_list|,
name|bhnd_service_t
name|service
parameter_list|)
block|{
name|struct
name|bhnd_service_registry
modifier|*
name|bsr
decl_stmt|;
name|bsr
operator|=
name|BHND_BUS_GET_SERVICE_REGISTRY
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bsr
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL service registry"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bhnd_service_registry_remove
argument_list|(
name|bsr
argument_list|,
name|provider
argument_list|,
name|service
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_RETAIN_PROVIDER().  *   * This implementation uses the bhnd_service_registry_retain() function to  * do most of the work. It calls BHND_BUS_GET_SERVICE_REGISTRY() to find  * a suitable service registry.  *   * If a local provider for the service is not available, and a parent device is  * available, this implementation will attempt to fetch and locally register  * a service provider reference from the parent of @p dev.  */
end_comment

begin_function
name|device_t
name|bhnd_bus_generic_sr_retain_provider
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|bhnd_service_t
name|service
parameter_list|)
block|{
name|struct
name|bhnd_service_registry
modifier|*
name|bsr
decl_stmt|;
name|device_t
name|parent
decl_stmt|,
name|provider
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bsr
operator|=
name|BHND_BUS_GET_SERVICE_REGISTRY
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bsr
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL service registry"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to fetch a service provider reference from either the local 	 * service registry, or if not found, from our parent. 	 *  	 * If we fetch a provider from our parent, we register the provider 	 * with the local service registry to prevent conflicting local 	 * registrations from being added. 	 */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Check the local service registry first */
name|provider
operator|=
name|bhnd_service_registry_retain
argument_list|(
name|bsr
argument_list|,
name|service
argument_list|)
expr_stmt|;
if|if
condition|(
name|provider
operator|!=
name|NULL
condition|)
return|return
operator|(
name|provider
operator|)
return|;
comment|/* Otherwise, try to delegate to our parent (if any) */
if|if
condition|(
operator|(
name|parent
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|provider
operator|=
name|BHND_BUS_RETAIN_PROVIDER
argument_list|(
name|parent
argument_list|,
name|dev
argument_list|,
name|service
argument_list|)
expr_stmt|;
if|if
condition|(
name|provider
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Register the inherited service registration with the local 		 * registry */
name|error
operator|=
name|bhnd_service_registry_add
argument_list|(
name|bsr
argument_list|,
name|provider
argument_list|,
name|service
argument_list|,
name|BHND_SPF_INHERITED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BHND_BUS_RELEASE_PROVIDER
argument_list|(
name|parent
argument_list|,
name|dev
argument_list|,
name|provider
argument_list|,
name|service
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EEXIST
condition|)
block|{
comment|/* A valid service provider was registered 				 * concurrently; retry fetching from the local 				 * registry */
continue|continue;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to register service "
literal|"provider: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_RELEASE_PROVIDER().  *   * This implementation uses the bhnd_service_registry_release() function to  * do most of the work. It calls BHND_BUS_GET_SERVICE_REGISTRY() to find  * a suitable service registry.  */
end_comment

begin_function
name|void
name|bhnd_bus_generic_sr_release_provider
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|device_t
name|provider
parameter_list|,
name|bhnd_service_t
name|service
parameter_list|)
block|{
name|struct
name|bhnd_service_registry
modifier|*
name|bsr
decl_stmt|;
name|bsr
operator|=
name|BHND_BUS_GET_SERVICE_REGISTRY
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bsr
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL service registry"
operator|)
argument_list|)
expr_stmt|;
comment|/* Release the provider reference; if the refcount hits zero on an 	 * inherited reference, true will be returned, and we need to drop 	 * our own bus reference to the provider */
if|if
condition|(
operator|!
name|bhnd_service_registry_release
argument_list|(
name|bsr
argument_list|,
name|provider
argument_list|,
name|service
argument_list|)
condition|)
return|return;
comment|/* Drop our reference to the borrowed provider */
name|BHND_BUS_RELEASE_PROVIDER
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|provider
argument_list|,
name|service
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_IS_HW_DISABLED().  *   * If a parent device is available, this implementation delegates the  * request to the BHND_BUS_IS_HW_DISABLED() method on the parent of @p dev.  *   * If no parent device is available (i.e. on a the bus root), the hardware  * is assumed to be usable and false is returned.  */
end_comment

begin_function
name|bool
name|bhnd_bus_generic_is_hw_disabled
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
if|if
condition|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|BHND_BUS_IS_HW_DISABLED
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|)
operator|)
return|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_GET_CHIPID().  *   * This implementation delegates the request to the BHND_BUS_GET_CHIPID()  * method on the parent of @p dev. If no parent exists, the implementation  * will panic.  */
end_comment

begin_function
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|bhnd_bus_generic_get_chipid
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
if|if
condition|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|BHND_BUS_GET_CHIPID
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|)
operator|)
return|;
name|panic
argument_list|(
literal|"missing BHND_BUS_GET_CHIPID()"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_GET_DMA_TRANSLATION().  *   * If a parent device is available, this implementation delegates the  * request to the BHND_BUS_GET_DMA_TRANSLATION() method on the parent of @p dev.  *  * If no parent device is available, this implementation will panic.  */
end_comment

begin_function
name|int
name|bhnd_bus_generic_get_dma_translation
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|u_int
name|width
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|bus_dma_tag_t
modifier|*
name|dmat
parameter_list|,
name|struct
name|bhnd_dma_translation
modifier|*
name|translation
parameter_list|)
block|{
if|if
condition|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|BHND_BUS_GET_DMA_TRANSLATION
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|width
argument_list|,
name|flags
argument_list|,
name|dmat
argument_list|,
name|translation
argument_list|)
operator|)
return|;
block|}
name|panic
argument_list|(
literal|"missing BHND_BUS_GET_DMA_TRANSLATION()"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* nvram board_info population macros for bhnd_bus_generic_read_board_info() */
end_comment

begin_define
define|#
directive|define
name|BHND_GV
parameter_list|(
name|_dest
parameter_list|,
name|_name
parameter_list|)
define|\
value|bhnd_nvram_getvar_uint(child, BHND_NVAR_ ## _name,&_dest,	\ 	    sizeof(_dest))
end_define

begin_define
define|#
directive|define
name|REQ_BHND_GV
parameter_list|(
name|_dest
parameter_list|,
name|_name
parameter_list|)
value|do {			\ 	if ((error = BHND_GV(_dest, _name))) {				\ 		device_printf(dev,					\ 		    "error reading " __STRING(_name) ": %d\n", error);	\ 		return (error);						\ 	}								\ } while(0)
end_define

begin_define
define|#
directive|define
name|OPT_BHND_GV
parameter_list|(
name|_dest
parameter_list|,
name|_name
parameter_list|,
name|_default
parameter_list|)
value|do {			\ 	if ((error = BHND_GV(_dest, _name))) {				\ 		if (error != ENOENT) {					\ 			device_printf(dev,				\ 			    "error reading "				\ 			       __STRING(_name) ": %d\n", error);	\ 			return (error);					\ 		}							\ 		_dest = _default;					\ 	}								\ } while(0)
end_define

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_READ_BOARDINFO().  *   * This implementation populates @p info with information from NVRAM,  * defaulting board_vendor and board_type fields to 0 if the  * requested variables cannot be found.  *   * This behavior is correct for most SoCs, but must be overridden on  * bridged (PCI, PCMCIA, etc) devices to produce a complete bhnd_board_info  * result.  */
end_comment

begin_function
name|int
name|bhnd_bus_generic_read_board_info
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|bhnd_board_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|OPT_BHND_GV
argument_list|(
name|info
operator|->
name|board_vendor
argument_list|,
name|BOARDVENDOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OPT_BHND_GV
argument_list|(
name|info
operator|->
name|board_type
argument_list|,
name|BOARDTYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* srom>= 2 */
name|REQ_BHND_GV
argument_list|(
name|info
operator|->
name|board_rev
argument_list|,
name|BOARDREV
argument_list|)
expr_stmt|;
name|OPT_BHND_GV
argument_list|(
name|info
operator|->
name|board_srom_rev
argument_list|,
name|SROMREV
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* missing in 								   some SoC 								   NVRAM */
name|REQ_BHND_GV
argument_list|(
name|info
operator|->
name|board_flags
argument_list|,
name|BOARDFLAGS
argument_list|)
expr_stmt|;
name|OPT_BHND_GV
argument_list|(
name|info
operator|->
name|board_flags2
argument_list|,
name|BOARDFLAGS2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* srom>= 4 */
name|OPT_BHND_GV
argument_list|(
name|info
operator|->
name|board_flags3
argument_list|,
name|BOARDFLAGS3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* srom>= 11 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|BHND_GV
end_undef

begin_undef
undef|#
directive|undef
name|BHND_GV_REQ
end_undef

begin_undef
undef|#
directive|undef
name|BHND_GV_OPT
end_undef

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_GET_NVRAM_VAR().  *   * This implementation searches @p dev for a usable NVRAM child device.  *   * If no usable child device is found on @p dev, the request is delegated to  * the BHND_BUS_GET_NVRAM_VAR() method on the parent of @p dev.  */
end_comment

begin_function
name|int
name|bhnd_bus_generic_get_nvram_var
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|bhnd_nvram_type
name|type
parameter_list|)
block|{
name|device_t
name|nvram
decl_stmt|;
name|device_t
name|parent
decl_stmt|;
comment|/* Make sure we're holding Giant for newbus */
name|GIANT_REQUIRED
expr_stmt|;
comment|/* Look for a directly-attached NVRAM child */
if|if
condition|(
operator|(
name|nvram
operator|=
name|device_find_child
argument_list|(
name|dev
argument_list|,
literal|"bhnd_nvram"
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|BHND_NVRAM_GETVAR
argument_list|(
name|nvram
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|type
argument_list|)
return|;
comment|/* Try to delegate to parent */
if|if
condition|(
operator|(
name|parent
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
return|return
operator|(
name|BHND_BUS_GET_NVRAM_VAR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_ALLOC_RESOURCE().  *   * This implementation of BHND_BUS_ALLOC_RESOURCE() delegates allocation  * of the underlying resource to BUS_ALLOC_RESOURCE(), and activation  * to @p dev's BHND_BUS_ACTIVATE_RESOURCE().  */
end_comment

begin_function
name|struct
name|bhnd_resource
modifier|*
name|bhnd_bus_generic_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|bhnd_resource
modifier|*
name|br
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|error
decl_stmt|;
name|br
operator|=
name|NULL
expr_stmt|;
name|res
operator|=
name|NULL
expr_stmt|;
comment|/* Allocate the real bus resource (without activating it) */
name|res
operator|=
name|BUS_ALLOC_RESOURCE
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
operator|(
name|flags
operator|&
operator|~
name|RF_ACTIVE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Allocate our bhnd resource wrapper. */
name|br
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bhnd_resource
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|br
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|br
operator|->
name|direct
operator|=
name|false
expr_stmt|;
name|br
operator|->
name|res
operator|=
name|res
expr_stmt|;
comment|/* Attempt activation */
if|if
condition|(
name|flags
operator|&
name|RF_ACTIVE
condition|)
block|{
name|error
operator|=
name|BHND_BUS_ACTIVATE_RESOURCE
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|br
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
block|}
return|return
operator|(
name|br
operator|)
return|;
name|failed
label|:
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
name|BUS_RELEASE_RESOURCE
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|br
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_RELEASE_RESOURCE().  *   * This implementation of BHND_BUS_RELEASE_RESOURCE() delegates release of  * the backing resource to BUS_RELEASE_RESOURCE().  */
end_comment

begin_function
name|int
name|bhnd_bus_generic_release_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|bhnd_resource
modifier|*
name|r
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|BUS_RELEASE_RESOURCE
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
operator|->
name|res
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|free
argument_list|(
name|r
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_ACTIVATE_RESOURCE().  *   * This implementation of BHND_BUS_ACTIVATE_RESOURCE() first calls the  * BHND_BUS_ACTIVATE_RESOURCE() method of the parent of @p dev.  *   * If this fails, and if @p dev is the direct parent of @p child, standard  * resource activation is attempted via bus_activate_resource(). This enables  * direct use of the bhnd(4) resource APIs on devices that may not be attached  * to a parent bhnd bus or bridge.  */
end_comment

begin_function
name|int
name|bhnd_bus_generic_activate_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|bhnd_resource
modifier|*
name|r
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|bool
name|passthrough
decl_stmt|;
name|passthrough
operator|=
operator|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
operator|)
expr_stmt|;
comment|/* Try to delegate to the parent */
if|if
condition|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|BHND_BUS_ACTIVATE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
block|}
comment|/* If bhnd(4) activation has failed and we're the child's direct 	 * parent, try falling back on standard resource activation. 	 */
if|if
condition|(
name|error
operator|&&
operator|!
name|passthrough
condition|)
block|{
name|error
operator|=
name|bus_activate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
operator|->
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|r
operator|->
name|direct
operator|=
name|true
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_DEACTIVATE_RESOURCE().  *   * This implementation of BHND_BUS_ACTIVATE_RESOURCE() simply calls the  * BHND_BUS_ACTIVATE_RESOURCE() method of the parent of @p dev.  */
end_comment

begin_function
name|int
name|bhnd_bus_generic_deactivate_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|bhnd_resource
modifier|*
name|r
parameter_list|)
block|{
if|if
condition|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|BHND_BUS_DEACTIVATE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_GET_INTR_DOMAIN().  *   * This implementation simply returns the address of nearest bhnd(4) bus,  * which may be @p dev; this behavior may be incompatible with FDT/OFW targets.  */
end_comment

begin_function
name|uintptr_t
name|bhnd_bus_generic_get_intr_domain
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|bool
name|self
parameter_list|)
block|{
return|return
operator|(
operator|(
name|uintptr_t
operator|)
name|dev
operator|)
return|;
block|}
end_function

end_unit

