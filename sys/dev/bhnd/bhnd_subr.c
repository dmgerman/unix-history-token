begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 Landon Fuller<landon@landonf.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/chipc/chipcreg.h>
end_include

begin_include
include|#
directive|include
file|"nvram/bhnd_nvram.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_chipc_if.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_if.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_map.h"
end_include

begin_include
include|#
directive|include
file|"bhndreg.h"
end_include

begin_include
include|#
directive|include
file|"bhndvar.h"
end_include

begin_function_decl
specifier|static
name|device_t
name|find_nvram_child
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* BHND core device description table. */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|bhnd_core_desc
block|{
name|uint16_t
name|vendor
decl_stmt|;
name|uint16_t
name|device
decl_stmt|;
name|bhnd_devclass_t
name|class
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|bhnd_core_descs
index|[]
init|=
block|{
define|#
directive|define
name|BHND_CDESC
parameter_list|(
name|_mfg
parameter_list|,
name|_cid
parameter_list|,
name|_cls
parameter_list|,
name|_desc
parameter_list|)
define|\
value|{ BHND_MFGID_ ## _mfg, BHND_COREID_ ## _cid,	\ 		BHND_DEVCLASS_ ## _cls, _desc }
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|CC
argument_list|,
name|CC
argument_list|,
literal|"ChipCommon I/O Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|ILINE20
argument_list|,
name|OTHER
argument_list|,
literal|"iLine20 HPNA"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|SRAM
argument_list|,
name|RAM
argument_list|,
literal|"SRAM"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|SDRAM
argument_list|,
name|RAM
argument_list|,
literal|"SDRAM"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|PCI
argument_list|,
name|PCI
argument_list|,
literal|"PCI Bridge"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|MIPS
argument_list|,
name|CPU
argument_list|,
literal|"MIPS Core"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|ENET
argument_list|,
name|ENET_MAC
argument_list|,
literal|"Fast Ethernet MAC"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|CODEC
argument_list|,
name|OTHER
argument_list|,
literal|"V.90 Modem Codec"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|USB
argument_list|,
name|OTHER
argument_list|,
literal|"USB 1.1 Device/Host Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|ADSL
argument_list|,
name|OTHER
argument_list|,
literal|"ADSL Core"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|ILINE100
argument_list|,
name|OTHER
argument_list|,
literal|"iLine100 HPNA"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|IPSEC
argument_list|,
name|OTHER
argument_list|,
literal|"IPsec Accelerator"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|UTOPIA
argument_list|,
name|OTHER
argument_list|,
literal|"UTOPIA ATM Core"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|PCMCIA
argument_list|,
name|PCCARD
argument_list|,
literal|"PCMCIA Bridge"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|SOCRAM
argument_list|,
name|RAM
argument_list|,
literal|"Internal Memory"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|MEMC
argument_list|,
name|MEMC
argument_list|,
literal|"MEMC SDRAM Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|OFDM
argument_list|,
name|OTHER
argument_list|,
literal|"OFDM PHY"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|EXTIF
argument_list|,
name|OTHER
argument_list|,
literal|"External Interface"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|D11
argument_list|,
name|WLAN
argument_list|,
literal|"802.11 MAC/PHY/Radio"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|APHY
argument_list|,
name|WLAN_PHY
argument_list|,
literal|"802.11a PHY"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|BPHY
argument_list|,
name|WLAN_PHY
argument_list|,
literal|"802.11b PHY"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|GPHY
argument_list|,
name|WLAN_PHY
argument_list|,
literal|"802.11g PHY"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|MIPS33
argument_list|,
name|CPU
argument_list|,
literal|"MIPS3302 Core"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|USB11H
argument_list|,
name|OTHER
argument_list|,
literal|"USB 1.1 Host Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|USB11D
argument_list|,
name|OTHER
argument_list|,
literal|"USB 1.1 Device Core"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|USB20H
argument_list|,
name|OTHER
argument_list|,
literal|"USB 2.0 Host Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|USB20D
argument_list|,
name|OTHER
argument_list|,
literal|"USB 2.0 Device Core"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|SDIOH
argument_list|,
name|OTHER
argument_list|,
literal|"SDIO Host Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|ROBO
argument_list|,
name|OTHER
argument_list|,
literal|"RoboSwitch"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|ATA100
argument_list|,
name|OTHER
argument_list|,
literal|"Parallel ATA Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|SATAXOR
argument_list|,
name|OTHER
argument_list|,
literal|"SATA DMA/XOR Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|GIGETH
argument_list|,
name|ENET_MAC
argument_list|,
literal|"Gigabit Ethernet MAC"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|PCIE
argument_list|,
name|PCIE
argument_list|,
literal|"PCIe Bridge"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NPHY
argument_list|,
name|WLAN_PHY
argument_list|,
literal|"802.11n 2x2 PHY"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|SRAMC
argument_list|,
name|MEMC
argument_list|,
literal|"SRAM Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|MINIMAC
argument_list|,
name|OTHER
argument_list|,
literal|"MINI MAC/PHY"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|ARM11
argument_list|,
name|CPU
argument_list|,
literal|"ARM1176 CPU"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|ARM7S
argument_list|,
name|CPU
argument_list|,
literal|"ARM7TDMI-S CPU"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|LPPHY
argument_list|,
name|WLAN_PHY
argument_list|,
literal|"802.11a/b/g PHY"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|PMU
argument_list|,
name|PMU
argument_list|,
literal|"PMU"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|SSNPHY
argument_list|,
name|WLAN_PHY
argument_list|,
literal|"802.11n Single-Stream PHY"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|SDIOD
argument_list|,
name|OTHER
argument_list|,
literal|"SDIO Device Core"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|ARMCM3
argument_list|,
name|CPU
argument_list|,
literal|"ARM Cortex-M3 CPU"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|HTPHY
argument_list|,
name|WLAN_PHY
argument_list|,
literal|"802.11n 4x4 PHY"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|MIPS
argument_list|,
name|MIPS74K
argument_list|,
name|CPU
argument_list|,
literal|"MIPS74k CPU"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|GMAC
argument_list|,
name|ENET_MAC
argument_list|,
literal|"Gigabit MAC core"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|DMEMC
argument_list|,
name|MEMC
argument_list|,
literal|"DDR1/DDR2 Memory Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|PCIERC
argument_list|,
name|OTHER
argument_list|,
literal|"PCIe Root Complex"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|OCP
argument_list|,
name|SOC_BRIDGE
argument_list|,
literal|"OCP to OCP Bridge"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|SC
argument_list|,
name|OTHER
argument_list|,
literal|"Shared Common Core"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|AHB
argument_list|,
name|SOC_BRIDGE
argument_list|,
literal|"OCP to AHB Bridge"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|SPIH
argument_list|,
name|OTHER
argument_list|,
literal|"SPI Host Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|I2S
argument_list|,
name|OTHER
argument_list|,
literal|"I2S Digital Audio Interface"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|DMEMS
argument_list|,
name|MEMC
argument_list|,
literal|"SDR/DDR1 Memory Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|UBUS_SHIM
argument_list|,
name|OTHER
argument_list|,
literal|"BCM6362/UBUS WLAN SHIM"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|PCIE2
argument_list|,
name|PCIE
argument_list|,
literal|"PCIe Bridge (Gen2)"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|ARM
argument_list|,
name|APB_BRIDGE
argument_list|,
name|SOC_BRIDGE
argument_list|,
literal|"BP135 AMBA3 AXI to APB Bridge"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|ARM
argument_list|,
name|PL301
argument_list|,
name|SOC_ROUTER
argument_list|,
literal|"PL301 AMBA3 Interconnect"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|ARM
argument_list|,
name|EROM
argument_list|,
name|EROM
argument_list|,
literal|"PL366 Device Enumeration ROM"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|ARM
argument_list|,
name|OOB_ROUTER
argument_list|,
name|OTHER
argument_list|,
literal|"PL367 OOB Interrupt Router"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|ARM
argument_list|,
name|AXI_UNMAPPED
argument_list|,
name|OTHER
argument_list|,
literal|"Unmapped Address Ranges"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
literal|4706_CC
argument_list|,
name|CC
argument_list|,
literal|"ChipCommon I/O Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_PCIE2
argument_list|,
name|PCIE
argument_list|,
literal|"PCIe Bridge (Gen2)"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_DMA
argument_list|,
name|OTHER
argument_list|,
literal|"DMA engine"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_SDIO
argument_list|,
name|OTHER
argument_list|,
literal|"SDIO 3.0 Host Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_USB20H
argument_list|,
name|OTHER
argument_list|,
literal|"USB 2.0 Host Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_USB30H
argument_list|,
name|OTHER
argument_list|,
literal|"USB 3.0 Host Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_A9JTAG
argument_list|,
name|OTHER
argument_list|,
literal|"ARM Cortex A9 JTAG Interface"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_DDR23_MEMC
argument_list|,
name|MEMC
argument_list|,
literal|"Denali DDR2/DD3 Memory Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_ROM
argument_list|,
name|NVRAM
argument_list|,
literal|"System ROM"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_NAND
argument_list|,
name|NVRAM
argument_list|,
literal|"NAND Flash Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_QSPI
argument_list|,
name|NVRAM
argument_list|,
literal|"QSPI Flash Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|NS_CC_B
argument_list|,
name|CC_B
argument_list|,
literal|"ChipCommon B Auxiliary I/O Controller"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
literal|4706_SOCRAM
argument_list|,
name|RAM
argument_list|,
literal|"Internal Memory"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|IHOST_ARMCA9
argument_list|,
name|CPU
argument_list|,
literal|"ARM Cortex A9 CPU"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
literal|4706_GMAC_CMN
argument_list|,
name|ENET
argument_list|,
literal|"Gigabit MAC (Common)"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
literal|4706_GMAC
argument_list|,
name|ENET_MAC
argument_list|,
literal|"Gigabit MAC"
argument_list|)
block|,
name|BHND_CDESC
argument_list|(
name|BCM
argument_list|,
name|AMEMC
argument_list|,
name|MEMC
argument_list|,
literal|"Denali DDR1/DDR2 Memory Controller"
argument_list|)
block|,
undef|#
directive|undef
name|BHND_CDESC
comment|/* Derived from inspection of the BCM4331 cores that provide PrimeCell 	 * IDs. Due to lack of documentation, the surmised device name/purpose 	 * provided here may be incorrect. */
block|{
name|BHND_MFGID_ARM
block|,
name|BHND_PRIMEID_EROM
block|,
name|BHND_DEVCLASS_OTHER
block|,
literal|"PL364 Device Enumeration ROM"
block|}
block|,
block|{
name|BHND_MFGID_ARM
block|,
name|BHND_PRIMEID_SWRAP
block|,
name|BHND_DEVCLASS_OTHER
block|,
literal|"PL368 Device Management Interface"
block|}
block|,
block|{
name|BHND_MFGID_ARM
block|,
name|BHND_PRIMEID_MWRAP
block|,
name|BHND_DEVCLASS_OTHER
block|,
literal|"PL369 Device Management Interface"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_comment
comment|/**  * Return the name for a given JEP106 manufacturer ID.  *   * @param vendor A JEP106 Manufacturer ID, including the non-standard ARM 4-bit  * JEP106 continuation code.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|bhnd_vendor_name
parameter_list|(
name|uint16_t
name|vendor
parameter_list|)
block|{
switch|switch
condition|(
name|vendor
condition|)
block|{
case|case
name|BHND_MFGID_ARM
case|:
return|return
literal|"ARM"
return|;
case|case
name|BHND_MFGID_BCM
case|:
return|return
literal|"Broadcom"
return|;
case|case
name|BHND_MFGID_MIPS
case|:
return|return
literal|"MIPS"
return|;
default|default:
return|return
literal|"unknown"
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Return the name of a port type.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|bhnd_port_type_name
parameter_list|(
name|bhnd_port_type
name|port_type
parameter_list|)
block|{
switch|switch
condition|(
name|port_type
condition|)
block|{
case|case
name|BHND_PORT_DEVICE
case|:
return|return
operator|(
literal|"device"
operator|)
return|;
case|case
name|BHND_PORT_BRIDGE
case|:
return|return
operator|(
literal|"bridge"
operator|)
return|;
case|case
name|BHND_PORT_AGENT
case|:
return|return
operator|(
literal|"agent"
operator|)
return|;
default|default:
return|return
literal|"unknown"
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|bhnd_core_desc
modifier|*
name|bhnd_find_core_desc
parameter_list|(
name|uint16_t
name|vendor
parameter_list|,
name|uint16_t
name|device
parameter_list|)
block|{
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|bhnd_core_descs
index|[
name|i
index|]
operator|.
name|desc
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bhnd_core_descs
index|[
name|i
index|]
operator|.
name|vendor
operator|!=
name|vendor
condition|)
continue|continue;
if|if
condition|(
name|bhnd_core_descs
index|[
name|i
index|]
operator|.
name|device
operator|!=
name|device
condition|)
continue|continue;
return|return
operator|(
operator|&
name|bhnd_core_descs
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return a human-readable name for a BHND core.  *   * @param vendor The core designer's JEDEC-106 Manufacturer ID  * @param device The core identifier.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|bhnd_find_core_name
parameter_list|(
name|uint16_t
name|vendor
parameter_list|,
name|uint16_t
name|device
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_core_desc
modifier|*
name|desc
decl_stmt|;
if|if
condition|(
operator|(
name|desc
operator|=
name|bhnd_find_core_desc
argument_list|(
name|vendor
argument_list|,
name|device
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"unknown"
operator|)
return|;
return|return
name|desc
operator|->
name|desc
return|;
block|}
end_function

begin_comment
comment|/**  * Return the device class for a BHND core.  *   * @param vendor The core designer's JEDEC-106 Manufacturer ID  * @param device The core identifier.  */
end_comment

begin_function
name|bhnd_devclass_t
name|bhnd_find_core_class
parameter_list|(
name|uint16_t
name|vendor
parameter_list|,
name|uint16_t
name|device
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_core_desc
modifier|*
name|desc
decl_stmt|;
if|if
condition|(
operator|(
name|desc
operator|=
name|bhnd_find_core_desc
argument_list|(
name|vendor
argument_list|,
name|device
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|BHND_DEVCLASS_OTHER
operator|)
return|;
return|return
name|desc
operator|->
name|class
return|;
block|}
end_function

begin_comment
comment|/**  * Return a human-readable name for a BHND core.  *   * @param ci The core's info record.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|bhnd_core_name
parameter_list|(
specifier|const
name|struct
name|bhnd_core_info
modifier|*
name|ci
parameter_list|)
block|{
return|return
name|bhnd_find_core_name
argument_list|(
name|ci
operator|->
name|vendor
argument_list|,
name|ci
operator|->
name|device
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the device class for a BHND core.  *   * @param ci The core's info record.  */
end_comment

begin_function
name|bhnd_devclass_t
name|bhnd_core_class
parameter_list|(
specifier|const
name|struct
name|bhnd_core_info
modifier|*
name|ci
parameter_list|)
block|{
return|return
name|bhnd_find_core_class
argument_list|(
name|ci
operator|->
name|vendor
argument_list|,
name|ci
operator|->
name|device
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize a core info record with data from from a bhnd-attached @p dev.  *   * @param dev A bhnd device.  * @param core The record to be initialized.  */
end_comment

begin_function
name|struct
name|bhnd_core_info
name|bhnd_get_core_info
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
expr|struct
name|bhnd_core_info
operator|)
block|{
operator|.
name|vendor
operator|=
name|bhnd_get_vendor
argument_list|(
name|dev
argument_list|)
block|,
operator|.
name|device
operator|=
name|bhnd_get_device
argument_list|(
name|dev
argument_list|)
block|,
operator|.
name|hwrev
operator|=
name|bhnd_get_hwrev
argument_list|(
name|dev
argument_list|)
block|,
operator|.
name|core_idx
operator|=
name|bhnd_get_core_index
argument_list|(
name|dev
argument_list|)
block|,
operator|.
name|unit
operator|=
name|bhnd_get_core_unit
argument_list|(
argument|dev
argument_list|)
block|}
return|;
block|}
end_function

begin_comment
comment|/**  * Find a @p class child device with @p unit on @p dev.  *   * @param parent The bhnd-compatible bus to be searched.  * @param class The device class to match on.  * @param unit The device unit number; specify -1 to return the first match  * regardless of unit number.  *   * @retval device_t if a matching child device is found.  * @retval NULL if no matching child device is found.  */
end_comment

begin_function
name|device_t
name|bhnd_find_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|bhnd_devclass_t
name|class
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|bhnd_core_match
name|md
init|=
block|{
name|BHND_MATCH_CORE_CLASS
argument_list|(
name|class
argument_list|)
block|,
name|BHND_MATCH_CORE_UNIT
argument_list|(
argument|unit
argument_list|)
block|}
decl_stmt|;
if|if
condition|(
name|unit
operator|==
operator|-
literal|1
condition|)
name|md
operator|.
name|m
operator|.
name|match
operator|.
name|core_unit
operator|=
literal|0
expr_stmt|;
return|return
name|bhnd_match_child
argument_list|(
name|dev
argument_list|,
operator|&
name|md
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find the first child device on @p dev that matches @p desc.  *   * @param parent The bhnd-compatible bus to be searched.  * @param desc A match descriptor.  *   * @retval device_t if a matching child device is found.  * @retval NULL if no matching child device is found.  */
end_comment

begin_function
name|device_t
name|bhnd_match_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|bhnd_core_match
modifier|*
name|desc
parameter_list|)
block|{
name|device_t
modifier|*
name|devlistp
decl_stmt|;
name|device_t
name|match
decl_stmt|;
name|int
name|devcnt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlistp
argument_list|,
operator|&
name|devcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|match
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|devcnt
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bhnd_core_info
name|ci
init|=
name|bhnd_get_core_info
argument_list|(
name|devlistp
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|bhnd_core_matches
argument_list|(
operator|&
name|ci
argument_list|,
name|desc
argument_list|)
condition|)
block|{
name|match
operator|=
name|devlistp
index|[
name|i
index|]
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|free
argument_list|(
name|devlistp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|match
return|;
block|}
end_function

begin_comment
comment|/**  * Walk up the bhnd device hierarchy to locate the root device  * to which the bhndb bridge is attached.  *   * This can be used from within bhnd host bridge drivers to locate the  * actual upstream host device.  *   * @param dev A bhnd device.  * @param bus_class The expected bus (e.g. "pci") to which the bridge root  * should be attached.  *   * @retval device_t if a matching parent device is found.  * @retval NULL @p dev is not attached via a bhndb bus  * @retval NULL no parent device is attached via @p bus_class.  */
end_comment

begin_function
name|device_t
name|bhnd_find_bridge_root
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|devclass_t
name|bus_class
parameter_list|)
block|{
name|devclass_t
name|bhndb_class
decl_stmt|;
name|device_t
name|parent
decl_stmt|;
name|KASSERT
argument_list|(
name|device_get_devclass
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
operator|==
name|bhnd_devclass
argument_list|,
operator|(
literal|"%s not a bhnd device"
operator|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bhndb_class
operator|=
name|devclass_find
argument_list|(
literal|"bhndb"
argument_list|)
expr_stmt|;
comment|/* Walk the device tree until we hit a bridge */
name|parent
operator|=
name|dev
expr_stmt|;
while|while
condition|(
operator|(
name|parent
operator|=
name|device_get_parent
argument_list|(
name|parent
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|device_get_devclass
argument_list|(
name|parent
argument_list|)
operator|==
name|bhndb_class
condition|)
break|break;
block|}
comment|/* No bridge? */
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Search for a parent attached to the expected bus class */
while|while
condition|(
operator|(
name|parent
operator|=
name|device_get_parent
argument_list|(
name|parent
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|device_t
name|bus
decl_stmt|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|!=
name|NULL
operator|&&
name|device_get_devclass
argument_list|(
name|bus
argument_list|)
operator|==
name|bus_class
condition|)
return|return
operator|(
name|parent
operator|)
return|;
block|}
comment|/* Not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find the first core in @p cores that matches @p desc.  *   * @param cores The table to search.  * @param num_cores The length of @p cores.  * @param desc A match descriptor.  *   * @retval bhnd_core_info if a matching core is found.  * @retval NULL if no matching core is found.  */
end_comment

begin_function
specifier|const
name|struct
name|bhnd_core_info
modifier|*
name|bhnd_match_core
parameter_list|(
specifier|const
name|struct
name|bhnd_core_info
modifier|*
name|cores
parameter_list|,
name|u_int
name|num_cores
parameter_list|,
specifier|const
name|struct
name|bhnd_core_match
modifier|*
name|desc
parameter_list|)
block|{
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num_cores
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bhnd_core_matches
argument_list|(
operator|&
name|cores
index|[
name|i
index|]
argument_list|,
name|desc
argument_list|)
condition|)
return|return
operator|&
name|cores
index|[
name|i
index|]
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find the first core in @p cores with the given @p class.  *   * @param cores The table to search.  * @param num_cores The length of @p cores.  * @param desc A match descriptor.  *   * @retval bhnd_core_info if a matching core is found.  * @retval NULL if no matching core is found.  */
end_comment

begin_function
specifier|const
name|struct
name|bhnd_core_info
modifier|*
name|bhnd_find_core
parameter_list|(
specifier|const
name|struct
name|bhnd_core_info
modifier|*
name|cores
parameter_list|,
name|u_int
name|num_cores
parameter_list|,
name|bhnd_devclass_t
name|class
parameter_list|)
block|{
name|struct
name|bhnd_core_match
name|md
init|=
block|{
name|BHND_MATCH_CORE_CLASS
argument_list|(
argument|class
argument_list|)
block|}
decl_stmt|;
return|return
name|bhnd_match_core
argument_list|(
name|cores
argument_list|,
name|num_cores
argument_list|,
operator|&
name|md
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if the @p core matches @p desc.  *   * @param core A bhnd core descriptor.  * @param desc A match descriptor to compare against @p core.  *   * @retval true if @p core matches @p match  * @retval false if @p core does not match @p match.  */
end_comment

begin_function
name|bool
name|bhnd_core_matches
parameter_list|(
specifier|const
name|struct
name|bhnd_core_info
modifier|*
name|core
parameter_list|,
specifier|const
name|struct
name|bhnd_core_match
modifier|*
name|desc
parameter_list|)
block|{
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|core_vendor
operator|&&
name|desc
operator|->
name|core_vendor
operator|!=
name|core
operator|->
name|vendor
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|core_id
operator|&&
name|desc
operator|->
name|core_id
operator|!=
name|core
operator|->
name|device
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|core_unit
operator|&&
name|desc
operator|->
name|core_unit
operator|!=
name|core
operator|->
name|unit
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|core_rev
operator|&&
operator|!
name|bhnd_hwrev_matches
argument_list|(
name|core
operator|->
name|hwrev
argument_list|,
operator|&
name|desc
operator|->
name|core_rev
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|core_class
operator|&&
name|desc
operator|->
name|core_class
operator|!=
name|bhnd_core_class
argument_list|(
name|core
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if the @p chip matches @p desc.  *   * @param chip A bhnd chip identifier.  * @param desc A match descriptor to compare against @p chip.  *   * @retval true if @p chip matches @p match  * @retval false if @p chip does not match @p match.  */
end_comment

begin_function
name|bool
name|bhnd_chip_matches
parameter_list|(
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|chip
parameter_list|,
specifier|const
name|struct
name|bhnd_chip_match
modifier|*
name|desc
parameter_list|)
block|{
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|chip_id
operator|&&
name|chip
operator|->
name|chip_id
operator|!=
name|desc
operator|->
name|chip_id
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|chip_pkg
operator|&&
name|chip
operator|->
name|chip_pkg
operator|!=
name|desc
operator|->
name|chip_pkg
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|chip_rev
operator|&&
operator|!
name|bhnd_hwrev_matches
argument_list|(
name|chip
operator|->
name|chip_rev
argument_list|,
operator|&
name|desc
operator|->
name|chip_rev
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if the @p board matches @p desc.  *   * @param board The bhnd board info.  * @param desc A match descriptor to compare against @p board.  *   * @retval true if @p chip matches @p match  * @retval false if @p chip does not match @p match.  */
end_comment

begin_function
name|bool
name|bhnd_board_matches
parameter_list|(
specifier|const
name|struct
name|bhnd_board_info
modifier|*
name|board
parameter_list|,
specifier|const
name|struct
name|bhnd_board_match
modifier|*
name|desc
parameter_list|)
block|{
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|board_srom_rev
operator|&&
operator|!
name|bhnd_hwrev_matches
argument_list|(
name|board
operator|->
name|board_srom_rev
argument_list|,
operator|&
name|desc
operator|->
name|board_srom_rev
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|board_vendor
operator|&&
name|board
operator|->
name|board_vendor
operator|!=
name|desc
operator|->
name|board_vendor
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|board_type
operator|&&
name|board
operator|->
name|board_type
operator|!=
name|desc
operator|->
name|board_type
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|m
operator|.
name|match
operator|.
name|board_rev
operator|&&
operator|!
name|bhnd_hwrev_matches
argument_list|(
name|board
operator|->
name|board_rev
argument_list|,
operator|&
name|desc
operator|->
name|board_rev
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if the @p hwrev matches @p desc.  *   * @param hwrev A bhnd hardware revision.  * @param desc A match descriptor to compare against @p core.  *   * @retval true if @p hwrev matches @p match  * @retval false if @p hwrev does not match @p match.  */
end_comment

begin_function
name|bool
name|bhnd_hwrev_matches
parameter_list|(
name|uint16_t
name|hwrev
parameter_list|,
specifier|const
name|struct
name|bhnd_hwrev_match
modifier|*
name|desc
parameter_list|)
block|{
if|if
condition|(
name|desc
operator|->
name|start
operator|!=
name|BHND_HWREV_INVALID
operator|&&
name|desc
operator|->
name|start
operator|>
name|hwrev
condition|)
return|return
name|false
return|;
if|if
condition|(
name|desc
operator|->
name|end
operator|!=
name|BHND_HWREV_INVALID
operator|&&
name|desc
operator|->
name|end
operator|<
name|hwrev
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if the @p dev matches @p desc.  *   * @param dev A bhnd device.  * @param desc A match descriptor to compare against @p dev.  *   * @retval true if @p dev matches @p match  * @retval false if @p dev does not match @p match.  */
end_comment

begin_function
name|bool
name|bhnd_device_matches
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|bhnd_device_match
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|bhnd_core_info
name|core
decl_stmt|;
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|chip
decl_stmt|;
name|struct
name|bhnd_board_info
name|board
decl_stmt|;
name|device_t
name|parent
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Construct individual match descriptors */
name|struct
name|bhnd_core_match
name|m_core
init|=
block|{
name|_BHND_CORE_MATCH_COPY
argument_list|(
argument|desc
argument_list|)
block|}
decl_stmt|;
name|struct
name|bhnd_chip_match
name|m_chip
init|=
block|{
name|_BHND_CHIP_MATCH_COPY
argument_list|(
argument|desc
argument_list|)
block|}
decl_stmt|;
name|struct
name|bhnd_board_match
name|m_board
init|=
block|{
name|_BHND_BOARD_MATCH_COPY
argument_list|(
argument|desc
argument_list|)
block|}
decl_stmt|;
comment|/* Fetch and match core info */
if|if
condition|(
name|m_core
operator|.
name|m
operator|.
name|match_flags
condition|)
block|{
comment|/* Only applicable to bhnd-attached cores */
name|parent
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_devclass
argument_list|(
name|parent
argument_list|)
operator|!=
name|bhnd_devclass
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"attempting to match core "
literal|"attributes against non-core device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
name|core
operator|=
name|bhnd_get_core_info
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bhnd_core_matches
argument_list|(
operator|&
name|core
argument_list|,
operator|&
name|m_core
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
comment|/* Fetch and match chip info */
if|if
condition|(
name|m_chip
operator|.
name|m
operator|.
name|match_flags
condition|)
block|{
name|chip
operator|=
name|bhnd_get_chipid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bhnd_chip_matches
argument_list|(
name|chip
argument_list|,
operator|&
name|m_chip
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
comment|/* Fetch and match board info. 	 * 	 * This is not available until  after NVRAM is up; earlier device 	 * matches should not include board requirements */
if|if
condition|(
name|m_board
operator|.
name|m
operator|.
name|match_flags
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_read_board_info
argument_list|(
name|dev
argument_list|,
operator|&
name|board
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to read required board info "
literal|"during device matching: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|bhnd_board_matches
argument_list|(
operator|&
name|board
argument_list|,
operator|&
name|m_board
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
comment|/* All matched */
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Search @p table for an entry matching @p dev.  *   * @param dev A bhnd device to match against @p table.  * @param table The device table to search.  * @param entry_size The @p table entry size, in bytes.  *   * @retval bhnd_device the first matching device, if any.  * @retval NULL if no matching device is found in @p table.  */
end_comment

begin_function
specifier|const
name|struct
name|bhnd_device
modifier|*
name|bhnd_device_lookup
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|bhnd_device
modifier|*
name|table
parameter_list|,
name|size_t
name|entry_size
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_device
modifier|*
name|entry
decl_stmt|;
name|device_t
name|hostb
decl_stmt|,
name|parent
decl_stmt|;
name|bhnd_attach_type
name|attach_type
decl_stmt|;
name|uint32_t
name|dflags
decl_stmt|;
name|parent
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hostb
operator|=
name|bhnd_find_hostb_device
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|attach_type
operator|=
name|bhnd_get_attach_type
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|table
init|;
operator|!
name|BHND_DEVICE_IS_END
argument_list|(
name|entry
argument_list|)
condition|;
name|entry
operator|=
operator|(
specifier|const
expr|struct
name|bhnd_device
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|entry
operator|+
name|entry_size
operator|)
control|)
block|{
comment|/* match core info */
if|if
condition|(
operator|!
name|bhnd_device_matches
argument_list|(
name|dev
argument_list|,
operator|&
name|entry
operator|->
name|core
argument_list|)
condition|)
continue|continue;
comment|/* match device flags */
name|dflags
operator|=
name|entry
operator|->
name|device_flags
expr_stmt|;
comment|/* hostb implies BHND_ATTACH_ADAPTER requirement */
if|if
condition|(
name|dflags
operator|&
name|BHND_DF_HOSTB
condition|)
name|dflags
operator||=
name|BHND_DF_ADAPTER
expr_stmt|;
if|if
condition|(
name|dflags
operator|&
name|BHND_DF_ADAPTER
condition|)
if|if
condition|(
name|attach_type
operator|!=
name|BHND_ATTACH_ADAPTER
condition|)
continue|continue;
if|if
condition|(
name|dflags
operator|&
name|BHND_DF_HOSTB
condition|)
if|if
condition|(
name|dev
operator|!=
name|hostb
condition|)
continue|continue;
if|if
condition|(
name|dflags
operator|&
name|BHND_DF_SOC
condition|)
if|if
condition|(
name|attach_type
operator|!=
name|BHND_ATTACH_NATIVE
condition|)
continue|continue;
comment|/* device found */
return|return
operator|(
name|entry
operator|)
return|;
block|}
comment|/* not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Scan the device @p table for all quirk flags applicable to @p dev.  *   * @param dev A bhnd device to match against @p table.  * @param table The device table to search.  *   * @return returns all matching quirk flags.  */
end_comment

begin_function
name|uint32_t
name|bhnd_device_quirks
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|bhnd_device
modifier|*
name|table
parameter_list|,
name|size_t
name|entry_size
parameter_list|)
block|{
specifier|const
name|struct
name|bhnd_device
modifier|*
name|dent
decl_stmt|;
specifier|const
name|struct
name|bhnd_device_quirk
modifier|*
name|qent
decl_stmt|,
modifier|*
name|qtable
decl_stmt|;
name|uint32_t
name|quirks
decl_stmt|;
comment|/* Locate the device entry */
if|if
condition|(
operator|(
name|dent
operator|=
name|bhnd_device_lookup
argument_list|(
name|dev
argument_list|,
name|table
argument_list|,
name|entry_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Quirks table is optional */
name|qtable
operator|=
name|dent
operator|->
name|quirks_table
expr_stmt|;
if|if
condition|(
name|qtable
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Collect matching device quirk entries */
name|quirks
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|qent
operator|=
name|qtable
init|;
operator|!
name|BHND_DEVICE_QUIRK_IS_END
argument_list|(
name|qent
argument_list|)
condition|;
name|qent
operator|++
control|)
block|{
if|if
condition|(
name|bhnd_device_matches
argument_list|(
name|dev
argument_list|,
operator|&
name|qent
operator|->
name|desc
argument_list|)
condition|)
name|quirks
operator||=
name|qent
operator|->
name|quirks
expr_stmt|;
block|}
return|return
operator|(
name|quirks
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Allocate bhnd(4) resources defined in @p rs from a parent bus.  *   * @param dev The device requesting ownership of the resources.  * @param rs A standard bus resource specification. This will be updated  * with the allocated resource's RIDs.  * @param res On success, the allocated bhnd resources.  *   * @retval 0 success  * @retval non-zero if allocation of any non-RF_OPTIONAL resource fails,  * 		    all allocated resources will be released and a regular  * 		    unix error code will be returned.  */
end_comment

begin_function
name|int
name|bhnd_alloc_resources
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|resource_spec
modifier|*
name|rs
parameter_list|,
name|struct
name|bhnd_resource
modifier|*
modifier|*
name|res
parameter_list|)
block|{
comment|/* Initialize output array */
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|rs
index|[
name|i
index|]
operator|.
name|type
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|res
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|rs
index|[
name|i
index|]
operator|.
name|type
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|res
index|[
name|i
index|]
operator|=
name|bhnd_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|rs
index|[
name|i
index|]
operator|.
name|type
argument_list|,
operator|&
name|rs
index|[
name|i
index|]
operator|.
name|rid
argument_list|,
name|rs
index|[
name|i
index|]
operator|.
name|flags
argument_list|)
expr_stmt|;
comment|/* Clean up all allocations on failure */
if|if
condition|(
name|res
index|[
name|i
index|]
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|rs
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|RF_OPTIONAL
operator|)
condition|)
block|{
name|bhnd_release_resources
argument_list|(
name|dev
argument_list|,
name|rs
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/**  * Release bhnd(4) resources defined in @p rs from a parent bus.  *   * @param dev The device that owns the resources.  * @param rs A standard bus resource specification previously initialized  * by @p bhnd_alloc_resources.  * @param res The bhnd resources to be released.  */
end_comment

begin_function
name|void
name|bhnd_release_resources
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|resource_spec
modifier|*
name|rs
parameter_list|,
name|struct
name|bhnd_resource
modifier|*
modifier|*
name|res
parameter_list|)
block|{
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|rs
index|[
name|i
index|]
operator|.
name|type
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|res
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|bhnd_release_resource
argument_list|(
name|dev
argument_list|,
name|rs
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|rs
index|[
name|i
index|]
operator|.
name|rid
argument_list|,
name|res
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|res
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Parse the CHIPC_ID_* fields from the ChipCommon CHIPC_ID  * register, returning its bhnd_chipid representation.  *   * @param idreg The CHIPC_ID register value.  * @param enum_addr The enumeration address to include in the result.  *  * @warning  * On early siba(4) devices, the ChipCommon core does not provide  * a valid CHIPC_ID_NUMCORE field. On these ChipCommon revisions  * (see CHIPC_NCORES_MIN_HWREV()), this function will parse and return  * an invalid `ncores` value.  */
end_comment

begin_function
name|struct
name|bhnd_chipid
name|bhnd_parse_chipid
parameter_list|(
name|uint32_t
name|idreg
parameter_list|,
name|bhnd_addr_t
name|enum_addr
parameter_list|)
block|{
name|struct
name|bhnd_chipid
name|result
decl_stmt|;
comment|/* Fetch the basic chip info */
name|result
operator|.
name|chip_id
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|idreg
argument_list|,
name|CHIPC_ID_CHIP
argument_list|)
expr_stmt|;
name|result
operator|.
name|chip_pkg
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|idreg
argument_list|,
name|CHIPC_ID_PKG
argument_list|)
expr_stmt|;
name|result
operator|.
name|chip_rev
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|idreg
argument_list|,
name|CHIPC_ID_REV
argument_list|)
expr_stmt|;
name|result
operator|.
name|chip_type
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|idreg
argument_list|,
name|CHIPC_ID_BUS
argument_list|)
expr_stmt|;
name|result
operator|.
name|ncores
operator|=
name|CHIPC_GET_BITS
argument_list|(
name|idreg
argument_list|,
name|CHIPC_ID_NUMCORE
argument_list|)
expr_stmt|;
name|result
operator|.
name|enum_addr
operator|=
name|enum_addr
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Allocate the resource defined by @p rs via @p dev, use it  * to read the ChipCommon ID register relative to @p chipc_offset,  * then release the resource.  *   * @param dev The device owning @p rs.  * @param rs A resource spec that encompasses the ChipCommon register block.  * @param chipc_offset The offset of the ChipCommon registers within @p rs.  * @param[out] result the chip identification data.  *   * @retval 0 success  * @retval non-zero if the ChipCommon identification data could not be read.  */
end_comment

begin_function
name|int
name|bhnd_read_chipid
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|resource_spec
modifier|*
name|rs
parameter_list|,
name|bus_size_t
name|chipc_offset
parameter_list|,
name|struct
name|bhnd_chipid
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|,
name|rtype
decl_stmt|;
comment|/* Allocate the ChipCommon window resource and fetch the chipid data */
name|rid
operator|=
name|rs
operator|->
name|rid
expr_stmt|;
name|rtype
operator|=
name|rs
operator|->
name|type
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|rtype
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate bhnd chipc resource\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Fetch the basic chip info */
name|reg
operator|=
name|bus_read_4
argument_list|(
name|res
argument_list|,
name|chipc_offset
operator|+
name|CHIPC_ID
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|bhnd_parse_chipid
argument_list|(
name|reg
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Fetch the enum base address */
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|result
operator|->
name|chip_type
condition|)
block|{
case|case
name|BHND_CHIPTYPE_SIBA
case|:
name|result
operator|->
name|enum_addr
operator|=
name|BHND_DEFAULT_CHIPC_ADDR
expr_stmt|;
break|break;
case|case
name|BHND_CHIPTYPE_BCMA
case|:
case|case
name|BHND_CHIPTYPE_BCMA_ALT
case|:
name|result
operator|->
name|enum_addr
operator|=
name|bus_read_4
argument_list|(
name|res
argument_list|,
name|chipc_offset
operator|+
name|CHIPC_EROMPTR
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHND_CHIPTYPE_UBUS
case|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unsupported ubus/bcm63xx chip type"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|cleanup
goto|;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unknown chip type %hhu\n"
argument_list|,
name|result
operator|->
name|chip_type
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|cleanup
label|:
comment|/* Clean up */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|rtype
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Using the bhnd(4) bus-level core information and a custom core name,  * populate @p dev's device description.  *   * @param dev A bhnd-bus attached device.  * @param dev_name The core's name (e.g. "SDIO Device Core")  */
end_comment

begin_function
name|void
name|bhnd_set_custom_core_desc
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|dev_name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|vendor_name
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
name|vendor_name
operator|=
name|bhnd_get_vendor_name
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|desc
argument_list|,
name|M_BHND
argument_list|,
literal|"%s %s, rev %hhu"
argument_list|,
name|vendor_name
argument_list|,
name|dev_name
argument_list|,
name|bhnd_get_hwrev
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|!=
name|NULL
condition|)
block|{
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|desc
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Using the bhnd(4) bus-level core information, populate @p dev's device  * description.  *   * @param dev A bhnd-bus attached device.  */
end_comment

begin_function
name|void
name|bhnd_set_default_core_desc
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|bhnd_set_custom_core_desc
argument_list|(
name|dev
argument_list|,
name|bhnd_get_device_name
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_IS_HW_DISABLED().  *   * If a parent device is available, this implementation delegates the  * request to the BHND_BUS_IS_HW_DISABLED() method on the parent of @p dev.  *   * If no parent device is available (i.e. on a the bus root), the hardware  * is assumed to be usable and false is returned.  */
end_comment

begin_function
name|bool
name|bhnd_bus_generic_is_hw_disabled
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
if|if
condition|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|BHND_BUS_IS_HW_DISABLED
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|)
operator|)
return|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_GET_CHIPID().  *   * This implementation delegates the request to the BHND_BUS_GET_CHIPID()  * method on the parent of @p dev. If no parent exists, the implementation  * will panic.  */
end_comment

begin_function
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|bhnd_bus_generic_get_chipid
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
if|if
condition|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|BHND_BUS_GET_CHIPID
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|)
operator|)
return|;
name|panic
argument_list|(
literal|"missing BHND_BUS_GET_CHIPID()"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* nvram board_info population macros for bhnd_bus_generic_read_board_info() */
end_comment

begin_define
define|#
directive|define
name|BHND_GV
parameter_list|(
name|_dest
parameter_list|,
name|_name
parameter_list|)
define|\
value|bhnd_nvram_getvar(child, BHND_NVAR_ ## _name,&_dest, sizeof(_dest))
end_define

begin_define
define|#
directive|define
name|REQ_BHND_GV
parameter_list|(
name|_dest
parameter_list|,
name|_name
parameter_list|)
value|do {			\ 	if ((error = BHND_GV(_dest, _name))) {				\ 		device_printf(dev,					\ 		    "error reading " __STRING(_name) ": %d\n", error);	\ 		return (error);						\ 	}								\ } while(0)
end_define

begin_define
define|#
directive|define
name|OPT_BHND_GV
parameter_list|(
name|_dest
parameter_list|,
name|_name
parameter_list|,
name|_default
parameter_list|)
value|do {			\ 	if ((error = BHND_GV(_dest, _name))) {				\ 		if (error != ENOENT) {					\ 			device_printf(dev,				\ 			    "error reading "				\ 			       __STRING(_name) ": %d\n", error);	\ 			return (error);					\ 		}							\ 		_dest = _default;					\ 	}								\ } while(0)
end_define

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_READ_BOARDINFO().  *   * This implementation populates @p info with information from NVRAM,  * defaulting board_vendor and board_type fields to 0 if the  * requested variables cannot be found.  *   * This behavior is correct for most SoCs, but must be overridden on  * bridged (PCI, PCMCIA, etc) devices to produce a complete bhnd_board_info  * result.  */
end_comment

begin_function
name|int
name|bhnd_bus_generic_read_board_info
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|bhnd_board_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|OPT_BHND_GV
argument_list|(
name|info
operator|->
name|board_vendor
argument_list|,
name|BOARDVENDOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OPT_BHND_GV
argument_list|(
name|info
operator|->
name|board_type
argument_list|,
name|BOARDTYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* srom>= 2 */
name|REQ_BHND_GV
argument_list|(
name|info
operator|->
name|board_rev
argument_list|,
name|BOARDREV
argument_list|)
expr_stmt|;
name|REQ_BHND_GV
argument_list|(
name|info
operator|->
name|board_srom_rev
argument_list|,
name|SROMREV
argument_list|)
expr_stmt|;
name|REQ_BHND_GV
argument_list|(
name|info
operator|->
name|board_flags
argument_list|,
name|BOARDFLAGS
argument_list|)
expr_stmt|;
name|OPT_BHND_GV
argument_list|(
name|info
operator|->
name|board_flags2
argument_list|,
name|BOARDFLAGS2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* srom>= 4 */
name|OPT_BHND_GV
argument_list|(
name|info
operator|->
name|board_flags3
argument_list|,
name|BOARDFLAGS3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* srom>= 11 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|BHND_GV
end_undef

begin_undef
undef|#
directive|undef
name|BHND_GV_REQ
end_undef

begin_undef
undef|#
directive|undef
name|BHND_GV_OPT
end_undef

begin_comment
comment|/**  * Find an NVRAM child device on @p dev, if any.  *   * @retval device_t An NVRAM device.  * @retval NULL If no NVRAM device is found.  */
end_comment

begin_function
specifier|static
name|device_t
name|find_nvram_child
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|chipc
decl_stmt|,
name|nvram
decl_stmt|;
comment|/* Look for a directly-attached NVRAM child */
name|nvram
operator|=
name|device_find_child
argument_list|(
name|dev
argument_list|,
literal|"bhnd_nvram"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvram
operator|!=
name|NULL
condition|)
return|return
operator|(
name|nvram
operator|)
return|;
comment|/* Remaining checks are only applicable when searching a bhnd(4) 	 * bus. */
if|if
condition|(
name|device_get_devclass
argument_list|(
name|dev
argument_list|)
operator|!=
name|bhnd_devclass
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Look for a ChipCommon-attached NVRAM device */
if|if
condition|(
operator|(
name|chipc
operator|=
name|bhnd_find_child
argument_list|(
name|dev
argument_list|,
name|BHND_DEVCLASS_CC
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|nvram
operator|=
name|device_find_child
argument_list|(
name|chipc
argument_list|,
literal|"bhnd_nvram"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvram
operator|!=
name|NULL
condition|)
return|return
operator|(
name|nvram
operator|)
return|;
block|}
comment|/* Not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_GET_NVRAM_VAR().  *   * This implementation searches @p dev for a usable NVRAM child device:  * - The first child device implementing the bhnd_nvram devclass is  *   returned, otherwise  * - If @p dev is a bhnd(4) bus, a ChipCommon core that advertises an  *   attached NVRAM source.  *   * If no usable child device is found on @p dev, the request is delegated to  * the BHND_BUS_GET_NVRAM_VAR() method on the parent of @p dev.  */
end_comment

begin_function
name|int
name|bhnd_bus_generic_get_nvram_var
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|device_t
name|nvram
decl_stmt|;
name|device_t
name|parent
decl_stmt|;
comment|/* Try to find an NVRAM device applicable to @p child */
if|if
condition|(
operator|(
name|nvram
operator|=
name|find_nvram_child
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|BHND_NVRAM_GETVAR
argument_list|(
name|nvram
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
return|;
comment|/* Try to delegate to parent */
if|if
condition|(
operator|(
name|parent
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
return|return
operator|(
name|BHND_BUS_GET_NVRAM_VAR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_ALLOC_RESOURCE().  *   * This implementation of BHND_BUS_ALLOC_RESOURCE() delegates allocation  * of the underlying resource to BUS_ALLOC_RESOURCE(), and activation  * to @p dev's BHND_BUS_ACTIVATE_RESOURCE().  */
end_comment

begin_function
name|struct
name|bhnd_resource
modifier|*
name|bhnd_bus_generic_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|bhnd_resource
modifier|*
name|br
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|error
decl_stmt|;
name|br
operator|=
name|NULL
expr_stmt|;
name|res
operator|=
name|NULL
expr_stmt|;
comment|/* Allocate the real bus resource (without activating it) */
name|res
operator|=
name|BUS_ALLOC_RESOURCE
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
operator|(
name|flags
operator|&
operator|~
name|RF_ACTIVE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Allocate our bhnd resource wrapper. */
name|br
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bhnd_resource
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|br
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|br
operator|->
name|direct
operator|=
name|false
expr_stmt|;
name|br
operator|->
name|res
operator|=
name|res
expr_stmt|;
comment|/* Attempt activation */
if|if
condition|(
name|flags
operator|&
name|RF_ACTIVE
condition|)
block|{
name|error
operator|=
name|BHND_BUS_ACTIVATE_RESOURCE
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|br
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
block|}
return|return
operator|(
name|br
operator|)
return|;
name|failed
label|:
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
name|BUS_RELEASE_RESOURCE
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|br
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_RELEASE_RESOURCE().  *   * This implementation of BHND_BUS_RELEASE_RESOURCE() delegates release of  * the backing resource to BUS_RELEASE_RESOURCE().  */
end_comment

begin_function
name|int
name|bhnd_bus_generic_release_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|bhnd_resource
modifier|*
name|r
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|BUS_RELEASE_RESOURCE
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
operator|->
name|res
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|free
argument_list|(
name|r
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_ACTIVATE_RESOURCE().  *   * This implementation of BHND_BUS_ACTIVATE_RESOURCE() simply calls the  * BHND_BUS_ACTIVATE_RESOURCE() method of the parent of @p dev.  */
end_comment

begin_function
name|int
name|bhnd_bus_generic_activate_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|bhnd_resource
modifier|*
name|r
parameter_list|)
block|{
comment|/* Try to delegate to the parent */
if|if
condition|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|BHND_BUS_ACTIVATE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/**  * Helper function for implementing BHND_BUS_DEACTIVATE_RESOURCE().  *   * This implementation of BHND_BUS_ACTIVATE_RESOURCE() simply calls the  * BHND_BUS_ACTIVATE_RESOURCE() method of the parent of @p dev.  */
end_comment

begin_function
name|int
name|bhnd_bus_generic_deactivate_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|bhnd_resource
modifier|*
name|r
parameter_list|)
block|{
if|if
condition|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|BHND_BUS_DEACTIVATE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

end_unit

