begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 Landon Fuller<landon@landonf.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * PCI-specific implementation for the BHNDB bridge driver.  *   * Provides support for bridging from a PCI parent bus to a BHND-compatible  * bus (e.g. bcma or siba) via a Broadcom PCI core configured in end-point  * mode.  *   * This driver handles all interactions with the PCI bridge core. On the  * bridged bhnd bus, the PCI core device will be claimed by a simple  * bhnd_hostb driver.  */
end_comment

begin_comment
comment|// Quirk TODO
end_comment

begin_comment
comment|// WARs for the following are not yet implemented:
end_comment

begin_comment
comment|// - BHND_PCI_QUIRK_SBINTVEC
end_comment

begin_comment
comment|// - BHND_PCIE_QUIRK_ASPM_OVR
end_comment

begin_comment
comment|// - BHND_PCIE_QUIRK_SERDES_NOPLLDOWN
end_comment

begin_comment
comment|// Quirks (and WARs) for the following are not yet defined:
end_comment

begin_comment
comment|// - Power savings via MDIO BLK1/PWR_MGMT3 on PCIe hwrev 15-20, 21-22
end_comment

begin_comment
comment|// - WOWL PME enable/disable
end_comment

begin_comment
comment|// - 4360 PCIe SerDes Tx amplitude/deemphasis (vendor Apple, boards
end_comment

begin_comment
comment|//   BCM94360X51P2, BCM94360X51A).
end_comment

begin_comment
comment|// - PCI latency timer (boards CB2_4321_BOARD, CB2_4321_AG_BOARD)
end_comment

begin_comment
comment|// - Max SerDes TX drive strength (vendor Apple, pcie>= rev10,
end_comment

begin_comment
comment|//   board BCM94322X9)
end_comment

begin_comment
comment|// - 700mV SerDes TX drive strength (chipid BCM4331, boards BCM94331X19,
end_comment

begin_comment
comment|//   BCM94331X28, BCM94331X29B, BCM94331X19C)
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhnd.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/pci/bhnd_pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/pci/mdio_pcievar.h>
end_include

begin_include
include|#
directive|include
file|"bhndb_pcireg.h"
end_include

begin_include
include|#
directive|include
file|"bhndb_pcivar.h"
end_include

begin_include
include|#
directive|include
file|"bhndb_private.h"
end_include

begin_function_decl
specifier|static
name|int
name|bhndb_enable_pci_clocks
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_disable_pci_clocks
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_pci_compat_setregwin
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
parameter_list|,
name|bhnd_addr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_pci_fast_setregwin
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
parameter_list|,
name|bhnd_addr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|bhndb_pcie_read_proto_reg
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bhndb_pcie_write_proto_reg
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bhndb_init_sromless_pci_config
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_pci_wars_register_access
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_pci_wars_early_once
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_pci_wars_hwup
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_pci_wars_hwdown
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|bhndb_pci_discover_quirks
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|bhndb_pci_id
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|bhndb_pci_id
modifier|*
name|bhndb_pci_find_core_id
parameter_list|(
name|struct
name|bhnd_core_info
modifier|*
name|core
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Supported PCI bridge cores.  *  * This table defines quirks specific to core hwrev ranges; see also  * bhndb_pci_discover_quirks() for additional quirk detection.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bhndb_pci_id
name|bhndb_pci_ids
index|[]
init|=
block|{
comment|/* PCI */
name|BHNDB_PCI_ID
argument_list|(
name|PCI
argument_list|,
name|BHND_QUIRK_HWREV_GTE
argument_list|(
literal|0
argument_list|,
name|BHNDB_PCI_QUIRK_EXT_CLOCK_GATING
operator||
name|BHNDB_PCI_QUIRK_SBTOPCI2_PREF_BURST
argument_list|)
argument_list|,
name|BHND_QUIRK_HWREV_RANGE
argument_list|(
literal|0
argument_list|,
literal|5
argument_list|,
name|BHNDB_PCI_QUIRK_SBINTVEC
argument_list|)
argument_list|,
name|BHND_QUIRK_HWREV_GTE
argument_list|(
literal|11
argument_list|,
name|BHNDB_PCI_QUIRK_SBTOPCI2_READMULTI
operator||
name|BHNDB_PCI_QUIRK_CLKRUN_DSBL
argument_list|)
argument_list|,
name|BHND_QUIRK_HWREV_END
argument_list|)
block|,
comment|/* PCI Gen 1 */
name|BHNDB_PCI_ID
argument_list|(
name|PCIE
argument_list|,
name|BHND_QUIRK_HWREV_EQ
argument_list|(
literal|0
argument_list|,
name|BHNDB_PCIE_QUIRK_SDR9_L0s_HANG
argument_list|)
argument_list|,
name|BHND_QUIRK_HWREV_RANGE
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|BHNDB_PCIE_QUIRK_UR_STATUS_FIX
argument_list|)
argument_list|,
name|BHND_QUIRK_HWREV_EQ
argument_list|(
literal|1
argument_list|,
name|BHNDB_PCIE_QUIRK_PCIPM_REQEN
argument_list|)
argument_list|,
name|BHND_QUIRK_HWREV_RANGE
argument_list|(
literal|3
argument_list|,
literal|5
argument_list|,
name|BHNDB_PCIE_QUIRK_ASPM_OVR
operator||
name|BHNDB_PCIE_QUIRK_SDR9_POLARITY
operator||
name|BHNDB_PCIE_QUIRK_SDR9_NO_FREQRETRY
argument_list|)
argument_list|,
name|BHND_QUIRK_HWREV_LTE
argument_list|(
literal|6
argument_list|,
name|BHNDB_PCIE_QUIRK_L1_IDLE_THRESH
argument_list|)
argument_list|,
name|BHND_QUIRK_HWREV_GTE
argument_list|(
literal|6
argument_list|,
name|BHNDB_PCIE_QUIRK_SPROM_L23_PCI_RESET
argument_list|)
argument_list|,
name|BHND_QUIRK_HWREV_EQ
argument_list|(
literal|7
argument_list|,
name|BHNDB_PCIE_QUIRK_SERDES_NOPLLDOWN
argument_list|)
argument_list|,
name|BHND_QUIRK_HWREV_GTE
argument_list|(
literal|8
argument_list|,
name|BHNDB_PCIE_QUIRK_L1_TIMER_PERF
argument_list|)
argument_list|,
name|BHND_QUIRK_HWREV_GTE
argument_list|(
literal|10
argument_list|,
name|BHNDB_PCIE_QUIRK_SD_C22_EXTADDR
argument_list|)
argument_list|,
name|BHND_QUIRK_HWREV_END
argument_list|)
block|,
block|{
name|BHND_COREID_INVALID
block|,
name|BHND_PCI_REGFMT_PCI
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* quirk flag convenience macros */
end_comment

begin_define
define|#
directive|define
name|BHNDB_PCI_QUIRK
parameter_list|(
name|_sc
parameter_list|,
name|_name
parameter_list|)
define|\
value|((_sc)->quirks& BHNDB_PCI_QUIRK_ ## _name)
end_define

begin_define
define|#
directive|define
name|BHNDB_PCIE_QUIRK
parameter_list|(
name|_sc
parameter_list|,
name|_name
parameter_list|)
define|\
value|((_sc)->quirks& BHNDB_PCIE_QUIRK_ ## _name)
end_define

begin_define
define|#
directive|define
name|BHNDB_PCI_ASSERT_QUIRK
parameter_list|(
name|_sc
parameter_list|,
name|name
parameter_list|)
define|\
value|KASSERT(BHNDB_PCI_QUIRK((_sc), name), ("quirk " __STRING(_name) " not set"))
end_define

begin_define
define|#
directive|define
name|BHNDB_PCIE_ASSERT_QUIRK
parameter_list|(
name|_sc
parameter_list|,
name|name
parameter_list|)
define|\
value|KASSERT(BHNDB_PCIE_QUIRK((_sc), name), ("quirk " __STRING(_name) " not set"))
end_define

begin_comment
comment|/* bus_(read|write)_* convenience macros */
end_comment

begin_define
define|#
directive|define
name|BHNDB_PCI_READ_2
parameter_list|(
name|_sc
parameter_list|,
name|_reg
parameter_list|)
define|\
value|bus_read_2((_sc)->mem_res, (_sc)->mem_off + (_reg))
end_define

begin_define
define|#
directive|define
name|BHNDB_PCI_READ_4
parameter_list|(
name|_sc
parameter_list|,
name|_reg
parameter_list|)
define|\
value|bus_read_4((_sc)->mem_res, (_sc)->mem_off + (_reg))
end_define

begin_define
define|#
directive|define
name|BHNDB_PCI_WRITE_2
parameter_list|(
name|_sc
parameter_list|,
name|_reg
parameter_list|,
name|_val
parameter_list|)
define|\
value|bus_write_2((_sc)->mem_res, (_sc)->mem_off +  (_reg), (_val))
end_define

begin_define
define|#
directive|define
name|BHNDB_PCI_WRITE_4
parameter_list|(
name|_sc
parameter_list|,
name|_reg
parameter_list|,
name|_val
parameter_list|)
define|\
value|bus_write_4((_sc)->mem_res, (_sc)->mem_off +  (_reg), (_val))
end_define

begin_comment
comment|/* BHNDB_PCI_REG_* convenience macros */
end_comment

begin_define
define|#
directive|define
name|BPCI_REG_EXTRACT
parameter_list|(
name|_rv
parameter_list|,
name|_a
parameter_list|)
value|BHND_PCI_REG_EXTRACT(_rv, BHND_ ## _a)
end_define

begin_define
define|#
directive|define
name|BPCI_REG_INSERT
parameter_list|(
name|_rv
parameter_list|,
name|_a
parameter_list|,
name|_v
parameter_list|)
value|BHND_PCI_REG_INSERT(_rv, BHND_ ## _a, _v)
end_define

begin_define
define|#
directive|define
name|BPCI_COMMON_REG_EXTRACT
parameter_list|(
name|_r
parameter_list|,
name|_a
parameter_list|)
define|\
value|BHND_PCI_COMMON_REG_EXTRACT(sc->regfmt, _r, _a)
end_define

begin_define
define|#
directive|define
name|BPCI_COMMON_REG_INSERT
parameter_list|(
name|_r
parameter_list|,
name|_a
parameter_list|,
name|_v
parameter_list|)
define|\
value|BHND_PCI_COMMON_REG_INSERT(sc->regfmt, _r, _a, _v)
end_define

begin_define
define|#
directive|define
name|BPCI_COMMON_REG
parameter_list|(
name|_name
parameter_list|)
define|\
value|BHND_PCI_COMMON_REG(sc->regfmt, _name)
end_define

begin_define
define|#
directive|define
name|BPCI_COMMON_REG_OFFSET
parameter_list|(
name|_base
parameter_list|,
name|_offset
parameter_list|)
define|\
value|(BPCI_COMMON_REG(_base) + BPCI_COMMON_REG(_offset))
end_define

begin_comment
comment|/**   * Default bhndb_pci implementation of device_probe().  *   * Verifies that the parent is a PCI/PCIe device.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|parent
decl_stmt|;
name|devclass_t
name|parent_bus
decl_stmt|;
name|devclass_t
name|pci
decl_stmt|;
comment|/* Our parent must be a PCI/PCIe device. */
name|pci
operator|=
name|devclass_find
argument_list|(
literal|"pci"
argument_list|)
expr_stmt|;
name|parent
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|parent_bus
operator|=
name|device_get_devclass
argument_list|(
name|device_get_parent
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent_bus
operator|!=
name|pci
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PCI-BHND bridge"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|reg
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/* Enable PCI bus mastering */
name|pci_enable_busmaster
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine our bridge device class */
name|sc
operator|->
name|pci_devclass
operator|=
name|BHND_DEVCLASS_PCI
expr_stmt|;
if|if
condition|(
name|pci_find_cap
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|pci_devclass
operator|=
name|BHND_DEVCLASS_PCIE
expr_stmt|;
comment|/* Determine the basic set of applicable quirks. This will be updated 	 * in bhndb_pci_init_full_config() once the PCI device core has 	 * been enumerated. */
name|sc
operator|->
name|quirks
operator|=
name|bhndb_pci_discover_quirks
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Using the discovered quirks, apply any WARs required for basic 	 * register access. */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_pci_wars_register_access
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Use siba(4)-compatible regwin handling until we know 	 * what kind of bus is attached */
name|sc
operator|->
name|set_regwin
operator|=
name|bhndb_pci_compat_setregwin
expr_stmt|;
comment|/* Perform full bridge attach. This should call back into our 	 * bhndb_pci_init_full_config() implementation once the bridged 	 * bhnd(4) bus has been enumerated, but before any devices have been 	 * probed or attached. */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_attach
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|pci_devclass
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* If supported, switch to the faster regwin handling */
if|if
condition|(
name|sc
operator|->
name|bhndb
operator|.
name|chipid
operator|.
name|chip_type
operator|!=
name|BHND_CHIPTYPE_SIBA
condition|)
block|{
name|atomic_store_rel_ptr
argument_list|(
operator|(
specifier|volatile
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|set_regwin
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|&
name|bhndb_pci_fast_setregwin
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize the full bridge configuration.  *   * This is called during the DEVICE_ATTACH() process by the bridged bhndb(4)  * bus, prior to probe/attachment of child cores.  *   * At this point, we can introspect the enumerated cores, find our host  * bridge device, and apply any bridge-level hardware workarounds required  * for proper operation of the bridged device cores.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_init_full_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
specifier|const
name|struct
name|bhndb_hw_priority
modifier|*
name|prio_table
parameter_list|)
block|{
name|struct
name|bhnd_core_info
name|core
decl_stmt|;
specifier|const
name|struct
name|bhndb_pci_id
modifier|*
name|id
decl_stmt|;
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bhndb_region
modifier|*
name|pcir
decl_stmt|;
name|bhnd_addr_t
name|pcir_addr
decl_stmt|;
name|bhnd_size_t
name|pcir_size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Let bhndb perform full discovery and initialization of the 	 * available register windows and bridge resources. */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_generic_init_full_config
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|prio_table
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/*  	 * Identify our PCI bridge core, its register family, and any 	 * applicable hardware quirks. 	 */
name|KASSERT
argument_list|(
name|sc
operator|->
name|bhndb
operator|.
name|hostb_dev
argument_list|,
operator|(
literal|"missing hostb device\n"
operator|)
argument_list|)
expr_stmt|;
name|core
operator|=
name|bhnd_get_core_info
argument_list|(
name|sc
operator|->
name|bhndb
operator|.
name|hostb_dev
argument_list|)
expr_stmt|;
name|id
operator|=
name|bhndb_pci_find_core_id
argument_list|(
operator|&
name|core
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s %s hostb core is not recognized\n"
argument_list|,
name|bhnd_vendor_name
argument_list|(
name|core
operator|.
name|vendor
argument_list|)
argument_list|,
name|bhnd_core_name
argument_list|(
operator|&
name|core
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|regfmt
operator|=
name|id
operator|->
name|regfmt
expr_stmt|;
comment|/* Now that we've identified the PCI bridge core, we can determine the 	 * full set of device quirks */
name|sc
operator|->
name|quirks
operator|=
name|bhndb_pci_discover_quirks
argument_list|(
name|sc
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* 	 * Determine and save a reference to the bhndb resource and offset 	 * at which the bridge core's device registers are mapped. 	 *  	 * All known bhnd(4) hardware provides a fixed static mapping of 	 * the PCI core's registers. If this changes in the future -- which 	 * is unlikely -- this driver will need to be adjusted to use 	 * dynamic register windows. 	 */
comment|/* Find base address and size of the PCI core's register block. */
name|error
operator|=
name|bhnd_get_region_addr
argument_list|(
name|sc
operator|->
name|bhndb
operator|.
name|hostb_dev
argument_list|,
name|BHND_PORT_DEVICE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|pcir_addr
argument_list|,
operator|&
name|pcir_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to locate PCI core registers\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Find the bhndb_region that statically maps this block */
name|pcir
operator|=
name|bhndb_find_resource_region
argument_list|(
name|sc
operator|->
name|bhndb
operator|.
name|bus_res
argument_list|,
name|pcir_addr
argument_list|,
name|pcir_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcir
operator|==
name|NULL
operator|||
name|pcir
operator|->
name|static_regwin
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"missing static PCI core register window\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Save borrowed reference to the mapped PCI core registers */
name|sc
operator|->
name|mem_off
operator|=
name|pcir
operator|->
name|static_regwin
operator|->
name|win_offset
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
name|bhndb_find_regwin_resource
argument_list|(
name|sc
operator|->
name|bhndb
operator|.
name|bus_res
argument_list|,
name|pcir
operator|->
name|static_regwin
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_res
operator|==
name|NULL
operator|||
operator|!
operator|(
name|rman_get_flags
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
operator|&
name|RF_ACTIVE
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"no active resource maps the PCI core register window\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Configure a direct bhnd_resource wrapper that we can pass to 	 * bhnd_resource APIs */
name|sc
operator|->
name|bhnd_mem_res
operator|=
operator|(
expr|struct
name|bhnd_resource
operator|)
block|{
operator|.
name|res
operator|=
name|sc
operator|->
name|mem_res
block|,
operator|.
name|direct
operator|=
name|true
block|}
expr_stmt|;
comment|/* 	 * Attach MMIO device (if this is a PCIe device), which is used for 	 * access to the PCIe SerDes required by the quirk workarounds. 	 */
if|if
condition|(
name|sc
operator|->
name|pci_devclass
operator|==
name|BHND_DEVCLASS_PCIE
condition|)
block|{
name|sc
operator|->
name|mdio
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
name|devclass_get_name
argument_list|(
name|bhnd_mdio_pci_devclass
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mdio
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|device_probe_and_attach
argument_list|(
name|sc
operator|->
name|mdio
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to attach MDIO device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* Apply any early one-time quirk workarounds */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_pci_wars_early_once
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Apply attach-time quirk workarounds, required before the bridged 	 * bhnd(4) bus itself performs a full attach(). */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_pci_wars_hwup
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Apply any hardware workarounds that must be executed prior to attempting  * register access on the bridged chipset.  *   * This must be called very early in attach() or resume(), after the basic  * set of applicable device quirks has been determined.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_wars_register_access
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|BHNDB_PCI_QUIRK
argument_list|(
name|sc
argument_list|,
name|EXT_CLOCK_GATING
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_enable_pci_clocks
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to enable clocks\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Apply any hardware work-arounds that must be executed exactly once, early in  * the attach process.  *   * This must be called after core enumeration and discovery of all applicable  * quirks, but prior to probe/attach of any cores, parsing of  * SPROM, etc.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_wars_early_once
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Determine correct polarity by observing the attach-time PCIe PHY 	 * link status. This is used later to reset/force the SerDes 	 * polarity */
if|if
condition|(
name|BHNDB_PCIE_QUIRK
argument_list|(
name|sc
argument_list|,
name|SDR9_POLARITY
argument_list|)
condition|)
block|{
name|uint32_t
name|st
decl_stmt|;
name|bool
name|inv
decl_stmt|;
name|st
operator|=
name|bhndb_pcie_read_proto_reg
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_PLP_STATUSREG
argument_list|)
expr_stmt|;
name|inv
operator|=
operator|(
operator|(
name|st
operator|&
name|BHND_PCIE_PLP_POLARITY_INV
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|sc
operator|->
name|sdr9_quirk_polarity
operator|.
name|inv
operator|=
name|inv
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Apply any hardware workarounds that are required upon attach or resume  * of the bridge device.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_wars_hwup
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Note that the order here matters; these work-arounds 	 * should not be re-ordered without careful review of their 	 * interdependencies */
comment|/* Fix up any PoR defaults on SROMless devices */
name|bhndb_init_sromless_pci_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable PCI prefetch/burst/readmulti flags */
if|if
condition|(
name|BHNDB_PCI_QUIRK
argument_list|(
name|sc
argument_list|,
name|SBTOPCI2_PREF_BURST
argument_list|)
operator|||
name|BHNDB_PCI_QUIRK
argument_list|(
name|sc
argument_list|,
name|SBTOPCI2_READMULTI
argument_list|)
condition|)
block|{
name|uint32_t
name|sbp2
decl_stmt|;
name|sbp2
operator|=
name|BHNDB_PCI_READ_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCI_SBTOPCI2
argument_list|)
expr_stmt|;
if|if
condition|(
name|BHNDB_PCI_QUIRK
argument_list|(
name|sc
argument_list|,
name|SBTOPCI2_PREF_BURST
argument_list|)
condition|)
name|sbp2
operator||=
operator|(
name|BHND_PCI_SBTOPCI_PREF
operator||
name|BHND_PCI_SBTOPCI_BURST
operator|)
expr_stmt|;
if|if
condition|(
name|BHNDB_PCI_QUIRK
argument_list|(
name|sc
argument_list|,
name|SBTOPCI2_READMULTI
argument_list|)
condition|)
name|sbp2
operator||=
name|BHND_PCI_SBTOPCI_RC_READMULTI
expr_stmt|;
name|BHNDB_PCI_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCI_SBTOPCI2
argument_list|,
name|sbp2
argument_list|)
expr_stmt|;
block|}
comment|/* Disable PCI CLKRUN# */
if|if
condition|(
name|BHNDB_PCI_QUIRK
argument_list|(
name|sc
argument_list|,
name|CLKRUN_DSBL
argument_list|)
condition|)
block|{
name|uint32_t
name|ctl
decl_stmt|;
name|ctl
operator|=
name|BHNDB_PCI_READ_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCI_CLKRUN_CTL
argument_list|)
expr_stmt|;
name|ctl
operator||=
name|BHND_PCI_CLKRUN_DSBL
expr_stmt|;
name|BHNDB_PCI_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCI_CLKRUN_CTL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
block|}
comment|/* Enable TLP unmatched address handling work-around */
if|if
condition|(
name|BHNDB_PCIE_QUIRK
argument_list|(
name|sc
argument_list|,
name|UR_STATUS_FIX
argument_list|)
condition|)
block|{
name|uint32_t
name|wrs
decl_stmt|;
name|wrs
operator|=
name|bhndb_pcie_read_proto_reg
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_TLP_WORKAROUNDSREG
argument_list|)
expr_stmt|;
name|wrs
operator||=
name|BHND_PCIE_TLP_WORKAROUND_URBIT
expr_stmt|;
name|bhndb_pcie_write_proto_reg
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_TLP_WORKAROUNDSREG
argument_list|,
name|wrs
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust SerDes CDR tuning to ensure that CDR is stable before sending 	 * data during L0s to L0 exit transitions. */
if|if
condition|(
name|BHNDB_PCIE_QUIRK
argument_list|(
name|sc
argument_list|,
name|SDR9_L0s_HANG
argument_list|)
condition|)
block|{
name|uint16_t
name|sdv
decl_stmt|;
comment|/* Set RX track/acquire timers to 2.064us/40.96us */
name|sdv
operator|=
name|BPCI_REG_INSERT
argument_list|(
literal|0
argument_list|,
name|PCIE_SDR9_RX_TIMER1_LKTRK
argument_list|,
operator|(
literal|2064
operator|/
literal|16
operator|)
argument_list|)
expr_stmt|;
name|sdv
operator|=
name|BPCI_REG_INSERT
argument_list|(
name|sdv
argument_list|,
name|PCIE_SDR9_RX_TIMER1_LKACQ
argument_list|,
operator|(
literal|40960
operator|/
literal|1024
operator|)
argument_list|)
expr_stmt|;
name|MDIO_WRITEREG
argument_list|(
name|sc
operator|->
name|mdio
argument_list|,
name|BHND_PCIE_PHY_SDR9_TXRX
argument_list|,
name|BHND_PCIE_SDR9_RX_TIMER1
argument_list|,
name|sdv
argument_list|)
expr_stmt|;
comment|/* Apply CDR frequency workaround */
name|sdv
operator|=
name|BHND_PCIE_SDR9_RX_CDR_FREQ_OVR_EN
expr_stmt|;
name|sdv
operator|=
name|BPCI_REG_INSERT
argument_list|(
name|sdv
argument_list|,
name|PCIE_SDR9_RX_CDR_FREQ_OVR
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|MDIO_WRITEREG
argument_list|(
name|sc
operator|->
name|mdio
argument_list|,
name|BHND_PCIE_PHY_SDR9_TXRX
argument_list|,
name|BHND_PCIE_SDR9_RX_CDR
argument_list|,
name|sdv
argument_list|)
expr_stmt|;
comment|/* Apply CDR BW tunings */
name|sdv
operator|=
literal|0
expr_stmt|;
name|sdv
operator|=
name|BPCI_REG_INSERT
argument_list|(
name|sdv
argument_list|,
name|PCIE_SDR9_RX_CDRBW_INTGTRK
argument_list|,
literal|0x2
argument_list|)
expr_stmt|;
name|sdv
operator|=
name|BPCI_REG_INSERT
argument_list|(
name|sdv
argument_list|,
name|PCIE_SDR9_RX_CDRBW_INTGACQ
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|sdv
operator|=
name|BPCI_REG_INSERT
argument_list|(
name|sdv
argument_list|,
name|PCIE_SDR9_RX_CDRBW_PROPTRK
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
name|sdv
operator|=
name|BPCI_REG_INSERT
argument_list|(
name|sdv
argument_list|,
name|PCIE_SDR9_RX_CDRBW_PROPACQ
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
name|MDIO_WRITEREG
argument_list|(
name|sc
operator|->
name|mdio
argument_list|,
name|BHND_PCIE_PHY_SDR9_TXRX
argument_list|,
name|BHND_PCIE_SDR9_RX_CDRBW
argument_list|,
name|sdv
argument_list|)
expr_stmt|;
block|}
comment|/* Force correct SerDes polarity */
if|if
condition|(
name|BHNDB_PCIE_QUIRK
argument_list|(
name|sc
argument_list|,
name|SDR9_POLARITY
argument_list|)
condition|)
block|{
name|uint16_t
name|rxctl
decl_stmt|;
name|rxctl
operator|=
name|MDIO_READREG
argument_list|(
name|sc
operator|->
name|mdio
argument_list|,
name|BHND_PCIE_PHY_SDR9_TXRX
argument_list|,
name|BHND_PCIE_SDR9_RX_CTRL
argument_list|)
expr_stmt|;
name|rxctl
operator||=
name|BHND_PCIE_SDR9_RX_CTRL_FORCE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sdr9_quirk_polarity
operator|.
name|inv
condition|)
name|rxctl
operator||=
name|BHND_PCIE_SDR9_RX_CTRL_POLARITY_INV
expr_stmt|;
else|else
name|rxctl
operator|&=
operator|~
name|BHND_PCIE_SDR9_RX_CTRL_POLARITY_INV
expr_stmt|;
name|MDIO_WRITEREG
argument_list|(
name|sc
operator|->
name|mdio
argument_list|,
name|BHND_PCIE_PHY_SDR9_TXRX
argument_list|,
name|BHND_PCIE_SDR9_RX_CTRL
argument_list|,
name|rxctl
argument_list|)
expr_stmt|;
block|}
comment|/* Disable startup retry on PLL frequency detection failure */
if|if
condition|(
name|BHNDB_PCIE_QUIRK
argument_list|(
name|sc
argument_list|,
name|SDR9_NO_FREQRETRY
argument_list|)
condition|)
block|{
name|uint16_t
name|pctl
decl_stmt|;
name|pctl
operator|=
name|MDIO_READREG
argument_list|(
name|sc
operator|->
name|mdio
argument_list|,
name|BHND_PCIE_PHY_SDR9_PLL
argument_list|,
name|BHND_PCIE_SDR9_PLL_CTRL
argument_list|)
expr_stmt|;
name|pctl
operator|&=
operator|~
name|BHND_PCIE_SDR9_PLL_CTRL_FREQDET_EN
expr_stmt|;
name|MDIO_WRITEREG
argument_list|(
name|sc
operator|->
name|mdio
argument_list|,
name|BHND_PCIE_PHY_SDR9_PLL
argument_list|,
name|BHND_PCIE_SDR9_PLL_CTRL
argument_list|,
name|pctl
argument_list|)
expr_stmt|;
block|}
comment|/* Explicitly enable PCI-PM */
if|if
condition|(
name|BHNDB_PCIE_QUIRK
argument_list|(
name|sc
argument_list|,
name|PCIPM_REQEN
argument_list|)
condition|)
block|{
name|uint32_t
name|lcreg
decl_stmt|;
name|lcreg
operator|=
name|bhndb_pcie_read_proto_reg
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_DLLP_LCREG
argument_list|)
expr_stmt|;
name|lcreg
operator||=
name|BHND_PCIE_DLLP_LCREG_PCIPM_EN
expr_stmt|;
name|bhndb_pcie_write_proto_reg
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_DLLP_LCREG
argument_list|,
name|lcreg
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust L1 timer to fix slow L1->L0 transitions */
if|if
condition|(
name|BHNDB_PCIE_QUIRK
argument_list|(
name|sc
argument_list|,
name|L1_IDLE_THRESH
argument_list|)
condition|)
block|{
name|uint32_t
name|pmt
decl_stmt|;
name|pmt
operator|=
name|bhndb_pcie_read_proto_reg
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_DLLP_PMTHRESHREG
argument_list|)
expr_stmt|;
name|pmt
operator|=
name|BPCI_REG_INSERT
argument_list|(
name|pmt
argument_list|,
name|PCIE_L1THRESHOLDTIME
argument_list|,
name|BHND_PCIE_L1THRESHOLD_WARVAL
argument_list|)
expr_stmt|;
name|bhndb_pcie_write_proto_reg
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_DLLP_PMTHRESHREG
argument_list|,
name|pmt
argument_list|)
expr_stmt|;
block|}
comment|/* Extend L1 timer for better performance. 	 * TODO: We could enable/disable this on demand for better power 	 * savings if we tie this to HT clock request handling */
if|if
condition|(
name|BHNDB_PCIE_QUIRK
argument_list|(
name|sc
argument_list|,
name|L1_TIMER_PERF
argument_list|)
condition|)
block|{
name|uint32_t
name|pmt
decl_stmt|;
name|pmt
operator|=
name|bhndb_pcie_read_proto_reg
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_DLLP_PMTHRESHREG
argument_list|)
expr_stmt|;
name|pmt
operator||=
name|BHND_PCIE_ASPMTIMER_EXTEND
expr_stmt|;
name|bhndb_pcie_write_proto_reg
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_DLLP_PMTHRESHREG
argument_list|,
name|pmt
argument_list|)
expr_stmt|;
block|}
comment|/* Enable L23READY_EXIT_NOPRST if not already set in SPROM. */
if|if
condition|(
name|BHNDB_PCIE_QUIRK
argument_list|(
name|sc
argument_list|,
name|SPROM_L23_PCI_RESET
argument_list|)
condition|)
block|{
name|bus_size_t
name|reg
decl_stmt|;
name|uint16_t
name|cfg
decl_stmt|;
comment|/* Fetch the misc cfg flags from SPROM */
name|reg
operator|=
name|BHND_PCIE_SPROM_SHADOW
operator|+
name|BHND_PCIE_SRSH_PCIE_MISC_CONFIG
expr_stmt|;
name|cfg
operator|=
name|BHNDB_PCI_READ_2
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Write EXIT_NOPRST flag if not already set in SPROM */
if|if
condition|(
operator|!
operator|(
name|cfg
operator|&
name|BHND_PCIE_SRSH_L23READY_EXIT_NOPRST
operator|)
condition|)
block|{
name|cfg
operator||=
name|BHND_PCIE_SRSH_L23READY_EXIT_NOPRST
expr_stmt|;
name|BHNDB_PCI_WRITE_2
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Apply any hardware workarounds that are required upon resume of the  * bridge device.  *   * This must be called before any bridged bhnd(4) cores have been resumed.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_wars_hwresume
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Nothing is possible without register access */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_pci_wars_register_access
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Apply the general hwup workarounds */
return|return
operator|(
name|bhndb_pci_wars_hwup
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Apply any hardware workarounds that are required upon detach or suspend  * of the bridge device.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_wars_hwdown
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Reduce L1 timer for better power savings. 	 * TODO: We could enable/disable this on demand for better power 	 * savings if we tie this to HT clock request handling */
if|if
condition|(
name|BHNDB_PCIE_QUIRK
argument_list|(
name|sc
argument_list|,
name|L1_TIMER_PERF
argument_list|)
condition|)
block|{
name|uint32_t
name|pmt
decl_stmt|;
name|pmt
operator|=
name|bhndb_pcie_read_proto_reg
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_DLLP_PMTHRESHREG
argument_list|)
expr_stmt|;
name|pmt
operator|&=
operator|~
name|BHND_PCIE_ASPMTIMER_EXTEND
expr_stmt|;
name|bhndb_pcie_write_proto_reg
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_DLLP_PMTHRESHREG
argument_list|,
name|pmt
argument_list|)
expr_stmt|;
block|}
comment|/* Disable clocks */
if|if
condition|(
name|BHNDB_PCI_QUIRK
argument_list|(
name|sc
argument_list|,
name|EXT_CLOCK_GATING
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_disable_pci_clocks
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to disable clocks\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * On devices without a SROM, the PCI(e) cores will be initialized with  * their Power-on-Reset defaults; this can leave the the BAR0 PCI windows  * potentially mapped to the wrong core index.  *   * This function updates the PCI core's BAR0 PCI configuration to point at the  * current PCI core.  *   * Applies to all PCI/PCIe revisions. Must be applied before bus devices  * are probed/attached or the SPROM is parsed.  */
end_comment

begin_function
specifier|static
name|void
name|bhndb_init_sromless_pci_config
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bus_size_t
name|sprom_addr
decl_stmt|;
name|u_int
name|sprom_core_idx
decl_stmt|;
name|u_int
name|pci_core_idx
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
comment|/* Fetch the SPROM's configured core index */
name|sprom_addr
operator|=
name|BPCI_COMMON_REG_OFFSET
argument_list|(
name|SPROM_SHADOW
argument_list|,
name|SRSH_PI_OFFSET
argument_list|)
expr_stmt|;
name|val
operator|=
name|BHNDB_PCI_READ_2
argument_list|(
name|sc
argument_list|,
name|sprom_addr
argument_list|)
expr_stmt|;
comment|/* If it doesn't match host bridge's core index, update the index 	 * value */
name|sprom_core_idx
operator|=
name|BPCI_COMMON_REG_EXTRACT
argument_list|(
name|val
argument_list|,
name|SRSH_PI
argument_list|)
expr_stmt|;
name|pci_core_idx
operator|=
name|bhnd_get_core_index
argument_list|(
name|sc
operator|->
name|bhndb
operator|.
name|hostb_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sprom_core_idx
operator|!=
name|pci_core_idx
condition|)
block|{
name|val
operator|=
name|BPCI_COMMON_REG_INSERT
argument_list|(
name|val
argument_list|,
name|SRSH_PI
argument_list|,
name|pci_core_idx
argument_list|)
expr_stmt|;
name|BHNDB_PCI_WRITE_2
argument_list|(
name|sc
argument_list|,
name|sprom_addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_generic_detach
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Apply any hardware workarounds. This may disable the clock, and 	 * thus must be called *after* any children have been detached. */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_pci_wars_hwdown
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Disable PCI bus mastering */
name|pci_disable_busmaster
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_generic_suspend
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Apply any hardware workarounds. This may disable the clock, and 	 * thus must be called *after* any children have been suspended. */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_pci_wars_hwdown
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Apply any resume workarounds; these may be required for bridged 	 * device access, and thus must be called *before* any children are 	 * resumed. */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_pci_wars_hwresume
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_generic_resume
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_set_window_addr
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|sc
operator|->
name|set_regwin
argument_list|(
name|sc
argument_list|,
name|rw
argument_list|,
name|addr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * A siba(4) and bcma(4)-compatible bhndb_set_window_addr implementation.  *   * On siba(4) devices, it's possible that writing a PCI window register may  * not succeed; it's necessary to immediately read the configuration register  * and retry if not set to the desired value.  *   * This is not necessary on bcma(4) devices, but other than the overhead of  * validating the register, there's no harm in performing the verification.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_compat_setregwin
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|)
block|{
name|device_t
name|parent
decl_stmt|;
name|int
name|error
decl_stmt|;
name|parent
operator|=
name|sc
operator|->
name|bhndb
operator|.
name|parent_dev
expr_stmt|;
if|if
condition|(
name|rw
operator|->
name|win_type
operator|!=
name|BHNDB_REGWIN_T_DYN
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BHNDB_PCI_BARCTRL_WRITE_RETRY
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_pci_fast_setregwin
argument_list|(
name|sc
argument_list|,
name|rw
argument_list|,
name|addr
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|pci_read_config
argument_list|(
name|parent
argument_list|,
name|rw
operator|->
name|dyn
operator|.
name|cfg_offset
argument_list|,
literal|4
argument_list|)
operator|==
name|addr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/* Unable to set window */
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * A bcma(4)-only bhndb_set_window_addr implementation.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_fast_setregwin
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|)
block|{
name|device_t
name|parent
init|=
name|sc
operator|->
name|bhndb
operator|.
name|parent_dev
decl_stmt|;
comment|/* The PCI bridge core only supports 32-bit addressing, regardless 	 * of the bus' support for 64-bit addressing */
if|if
condition|(
name|addr
operator|>
name|UINT32_MAX
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
switch|switch
condition|(
name|rw
operator|->
name|win_type
condition|)
block|{
case|case
name|BHNDB_REGWIN_T_DYN
case|:
comment|/* Addresses must be page aligned */
if|if
condition|(
name|addr
operator|%
name|rw
operator|->
name|win_size
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pci_write_config
argument_list|(
name|parent
argument_list|,
name|rw
operator|->
name|dyn
operator|.
name|cfg_offset
argument_list|,
name|addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Read a 32-bit PCIe TLP/DLLP/PLP protocol register.  *   * @param sc The bhndb_pci driver state.  * @param addr The protocol register offset.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|bhndb_pcie_read_proto_reg
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|KASSERT
argument_list|(
name|bhnd_get_class
argument_list|(
name|sc
operator|->
name|bhndb
operator|.
name|hostb_dev
argument_list|)
operator|==
name|BHND_DEVCLASS_PCIE
argument_list|,
operator|(
literal|"not a pcie device!"
operator|)
argument_list|)
expr_stmt|;
name|BHNDB_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|bhndb
argument_list|)
expr_stmt|;
name|BHNDB_PCI_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_IND_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|val
operator|=
name|BHNDB_PCI_READ_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_IND_DATA
argument_list|)
expr_stmt|;
name|BHNDB_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|bhndb
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Write a 32-bit PCIe TLP/DLLP/PLP protocol register value.  *   * @param sc The bhndb_pci driver state.  * @param addr The protocol register offset.  * @param val The value to write to @p addr.  */
end_comment

begin_function
specifier|static
name|void
name|bhndb_pcie_write_proto_reg
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|bhnd_get_class
argument_list|(
name|sc
operator|->
name|bhndb
operator|.
name|hostb_dev
argument_list|)
operator|==
name|BHND_DEVCLASS_PCIE
argument_list|,
operator|(
literal|"not a pcie device!"
operator|)
argument_list|)
expr_stmt|;
name|BHNDB_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|bhndb
argument_list|)
expr_stmt|;
name|BHNDB_PCI_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_IND_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|BHNDB_PCI_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BHND_PCIE_IND_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|BHNDB_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|bhndb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Enable externally managed clocks.  *   * Quirk Required: EXT_CLOCK_GATING  *   * @param sc Bridge driver state.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_enable_pci_clocks
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|pci_parent
decl_stmt|;
name|uint32_t
name|gpio_in
decl_stmt|,
name|gpio_out
decl_stmt|,
name|gpio_en
decl_stmt|;
name|uint32_t
name|gpio_flags
decl_stmt|;
name|uint16_t
name|pci_status
decl_stmt|;
name|BHNDB_PCI_ASSERT_QUIRK
argument_list|(
name|sc
argument_list|,
name|EXT_CLOCK_GATING
argument_list|)
expr_stmt|;
name|pci_parent
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|/* Read state of XTAL pin */
name|gpio_in
operator|=
name|pci_read_config
argument_list|(
name|pci_parent
argument_list|,
name|BHNDB_PCI_GPIO_IN
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|gpio_in
operator|&
name|BHNDB_PCI_GPIO_XTAL_ON
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* already enabled */
comment|/* Fetch current config */
name|gpio_out
operator|=
name|pci_read_config
argument_list|(
name|pci_parent
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gpio_en
operator|=
name|pci_read_config
argument_list|(
name|pci_parent
argument_list|,
name|BHNDB_PCI_GPIO_OUTEN
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Set PLL_OFF/XTAL_ON pins to HIGH and enable both pins */
name|gpio_flags
operator|=
operator|(
name|BHNDB_PCI_GPIO_PLL_OFF
operator||
name|BHNDB_PCI_GPIO_XTAL_ON
operator|)
expr_stmt|;
name|gpio_out
operator||=
name|gpio_flags
expr_stmt|;
name|gpio_en
operator||=
name|gpio_flags
expr_stmt|;
name|pci_write_config
argument_list|(
name|pci_parent
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
name|gpio_out
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|pci_parent
argument_list|,
name|BHNDB_PCI_GPIO_OUTEN
argument_list|,
name|gpio_en
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Reset PLL_OFF */
name|gpio_out
operator|&=
operator|~
name|BHNDB_PCI_GPIO_PLL_OFF
expr_stmt|;
name|pci_write_config
argument_list|(
name|pci_parent
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
name|gpio_out
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* Clear any PCI 'sent target-abort' flag. */
name|pci_status
operator|=
name|pci_read_config
argument_list|(
name|pci_parent
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_status
operator|&=
operator|~
name|PCIM_STATUS_STABORT
expr_stmt|;
name|pci_write_config
argument_list|(
name|pci_parent
argument_list|,
name|PCIR_STATUS
argument_list|,
name|pci_status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Disable externally managed clocks.  *   * Quirk Required: EXT_CLOCK_GATING  *   * @param sc Bridge driver state.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_disable_pci_clocks
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|parent_dev
decl_stmt|;
name|uint32_t
name|gpio_out
decl_stmt|,
name|gpio_en
decl_stmt|;
name|BHNDB_PCI_ASSERT_QUIRK
argument_list|(
name|sc
argument_list|,
name|EXT_CLOCK_GATING
argument_list|)
expr_stmt|;
name|parent_dev
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|// TODO: Check board flags for BFL2_XTALBUFOUTEN?
comment|// TODO: Check PCI core revision?
comment|// TODO: Switch to 'slow' clock?
comment|/* Fetch current config */
name|gpio_out
operator|=
name|pci_read_config
argument_list|(
name|parent_dev
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gpio_en
operator|=
name|pci_read_config
argument_list|(
name|parent_dev
argument_list|,
name|BHNDB_PCI_GPIO_OUTEN
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Set PLL_OFF to HIGH, XTAL_ON to LOW. */
name|gpio_out
operator|&=
operator|~
name|BHNDB_PCI_GPIO_XTAL_ON
expr_stmt|;
name|gpio_out
operator||=
name|BHNDB_PCI_GPIO_PLL_OFF
expr_stmt|;
name|pci_write_config
argument_list|(
name|parent_dev
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
name|gpio_out
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Enable both output pins */
name|gpio_en
operator||=
operator|(
name|BHNDB_PCI_GPIO_PLL_OFF
operator||
name|BHNDB_PCI_GPIO_XTAL_ON
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|parent_dev
argument_list|,
name|BHNDB_PCI_GPIO_OUTEN
argument_list|,
name|gpio_en
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find the identification table entry for a core descriptor.  *   * @param sc bhndb PCI driver state.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|bhndb_pci_id
modifier|*
name|bhndb_pci_find_core_id
parameter_list|(
name|struct
name|bhnd_core_info
modifier|*
name|core
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_pci_id
modifier|*
name|id
decl_stmt|;
for|for
control|(
name|id
operator|=
name|bhndb_pci_ids
init|;
name|id
operator|->
name|device
operator|!=
name|BHND_COREID_INVALID
condition|;
name|id
operator|++
control|)
block|{
if|if
condition|(
name|core
operator|->
name|vendor
operator|==
name|BHND_MFGID_BCM
operator|&&
name|core
operator|->
name|device
operator|==
name|id
operator|->
name|device
condition|)
return|return
operator|(
name|id
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return all quirks known to be applicable to the host bridge.  *   * If the PCI bridge core has not yet been identified, no core-specific  * quirk flags will be returned. This function may be called again to  * rediscover applicable quirks after the host bridge core has been  * identified.  *   * @param sc bhndb PCI driver state.  * @param id The host bridge core's identification table entry, or NULL  * if the host bridge core has not yet been identified.  *   * @return Returns the set of quirks applicable to the current hardware.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|bhndb_pci_discover_quirks
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|bhndb_pci_id
modifier|*
name|id
parameter_list|)
block|{
name|struct
name|bhnd_device_quirk
modifier|*
name|qt
decl_stmt|;
name|uint32_t
name|quirks
decl_stmt|;
name|uint8_t
name|hwrev
decl_stmt|;
name|quirks
operator|=
name|BHNDB_PCI_QUIRK_NONE
expr_stmt|;
comment|/* Determine any device class-specific quirks */
switch|switch
condition|(
name|sc
operator|->
name|pci_devclass
condition|)
block|{
case|case
name|BHND_DEVCLASS_PCI
case|:
comment|/* All PCI devices require external clock gating */
name|sc
operator|->
name|quirks
operator||=
name|BHNDB_PCI_QUIRK_EXT_CLOCK_GATING
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|// TODO: Additional quirk matching
comment|/* Determine any PCI core hwrev-specific device quirks */
if|if
condition|(
name|id
operator|!=
name|NULL
condition|)
block|{
name|hwrev
operator|=
name|bhnd_get_hwrev
argument_list|(
name|sc
operator|->
name|bhndb
operator|.
name|hostb_dev
argument_list|)
expr_stmt|;
for|for
control|(
name|qt
operator|=
name|id
operator|->
name|quirks
init|;
name|qt
operator|->
name|quirks
operator|!=
literal|0
condition|;
name|qt
operator|++
control|)
block|{
if|if
condition|(
name|bhnd_hwrev_matches
argument_list|(
name|hwrev
argument_list|,
operator|&
name|qt
operator|->
name|hwrev
argument_list|)
condition|)
name|quirks
operator||=
name|qt
operator|->
name|quirks
expr_stmt|;
block|}
block|}
return|return
operator|(
name|quirks
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support for attaching the PCIe-Gen1 MDIO driver to a parent bhndb PCIe  * bridge device.   */
end_comment

begin_function
specifier|static
name|int
name|bhndb_mdio_pcie_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhndb_softc
modifier|*
name|psc
decl_stmt|;
name|device_t
name|parent
decl_stmt|;
comment|/* Parent must be a bhndb_pcie instance */
name|parent
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_driver
argument_list|(
name|parent
argument_list|)
operator|!=
operator|&
name|bhndb_pci_driver
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Parent must have PCIe-Gen1 hostb device */
name|psc
operator|=
name|device_get_softc
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|psc
operator|->
name|hostb_dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|bhnd_get_vendor
argument_list|(
name|psc
operator|->
name|hostb_dev
argument_list|)
operator|!=
name|BHND_MFGID_BCM
operator|||
name|bhnd_get_device
argument_list|(
name|psc
operator|->
name|hostb_dev
argument_list|)
operator|!=
name|BHND_COREID_PCIE
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|device_quiet
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_NOWILDCARD
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_mdio_pcie_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|psc
decl_stmt|;
name|psc
operator|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bhnd_mdio_pcie_attach
argument_list|(
name|dev
argument_list|,
operator|&
name|psc
operator|->
name|bhnd_mem_res
argument_list|,
operator|-
literal|1
argument_list|,
name|psc
operator|->
name|mem_off
operator|+
name|BHND_PCIE_MDIO_CTL
argument_list|,
operator|(
name|psc
operator|->
name|quirks
operator|&
name|BHNDB_PCIE_QUIRK_SD_C22_EXTADDR
operator|)
operator|!=
literal|0
argument_list|)
operator|)
return|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|bhnd_mdio_pcie_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|bhndb_mdio_pcie_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|bhndb_mdio_pcie_attach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|bhndb_pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|bhndb_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|bhndb_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bhndb_pci_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bhndb_pci_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bhndb_pci_resume
argument_list|)
block|,
comment|/* BHNDB interface */
name|DEVMETHOD
argument_list|(
name|bhndb_init_full_config
argument_list|,
name|bhndb_pci_init_full_config
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhndb_set_window_addr
argument_list|,
name|bhndb_pci_set_window_addr
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_1
argument_list|(
name|bhndb
argument_list|,
name|bhndb_pci_driver
argument_list|,
name|bhndb_pci_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bhndb_pci_softc
argument_list|)
argument_list|,
name|bhndb_driver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_CLASS_1
argument_list|(
name|bhnd_mdio_pci
argument_list|,
name|bhndb_mdio_pcie_driver
argument_list|,
name|bhnd_mdio_pcie_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bhnd_mdio_pcie_softc
argument_list|)
argument_list|,
name|bhnd_mdio_pcie_driver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|bhnd_mdio_pcie
argument_list|,
name|bhndb
argument_list|,
name|bhndb_mdio_pcie_driver
argument_list|,
name|bhnd_mdio_pci_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|bhndb_pci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bhndb_pci
argument_list|,
name|bhnd_pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bhndb_pci
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bhndb_pci
argument_list|,
name|bhndb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

