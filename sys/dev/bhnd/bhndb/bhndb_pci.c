begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Landon Fuller<landon@landonf.org>  * Copyright (c) 2017 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by Landon Fuller  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * PCI-specific implementation for the BHNDB bridge driver.  *   * Provides support for bridging from a PCI parent bus to a BHND-compatible  * bus (e.g. bcma or siba) via a Broadcom PCI core configured in end-point  * mode.  *   * This driver handles all initial generic host-level PCI interactions with a  * PCI/PCIe bridge core operating in endpoint mode. Once the bridged bhnd(4)  * bus has been enumerated, this driver works in tandem with a core-specific  * bhnd_pci_hostb driver to manage the PCI core.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhnd.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhndreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhnd_erom.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhnd_eromvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/siba/sibareg.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/pci/bhnd_pcireg.h>
end_include

begin_include
include|#
directive|include
file|"bhndb_pcireg.h"
end_include

begin_include
include|#
directive|include
file|"bhndb_pcivar.h"
end_include

begin_include
include|#
directive|include
file|"bhndb_private.h"
end_include

begin_struct_decl
struct_decl|struct
name|bhndb_pci_eio
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|int
name|bhndb_pci_alloc_msi
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|,
name|int
modifier|*
name|msi_count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_pci_read_core_table
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|bhnd_chipid
modifier|*
name|chipid
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
modifier|*
name|cores
parameter_list|,
name|u_int
modifier|*
name|ncores
parameter_list|,
name|bhnd_erom_class_t
modifier|*
modifier|*
name|eromcls
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_pci_add_children
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bhnd_devclass_t
name|bhndb_expected_pci_devclass
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|bhndb_is_pcie_attached
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_enable_pci_clocks
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_disable_pci_clocks
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_pci_compat_setregwin
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|pci_dev
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
parameter_list|,
name|bhnd_addr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_pci_fast_setregwin
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|pci_dev
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
parameter_list|,
name|bhnd_addr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bhndb_pci_write_core
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|uint32_t
name|value
parameter_list|,
name|u_int
name|width
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|bhndb_pci_read_core
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|u_int
name|width
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bhndb_init_sromless_pci_config
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bus_addr_t
name|bhndb_pci_sprom_addr
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bus_size_t
name|bhndb_pci_sprom_size
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_pci_eio_init
parameter_list|(
name|struct
name|bhndb_pci_eio
modifier|*
name|pio
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|device_t
name|pci_dev
parameter_list|,
name|struct
name|bhndb_host_resources
modifier|*
name|hr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_pci_eio_map
parameter_list|(
name|struct
name|bhnd_erom_io
modifier|*
name|eio
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|,
name|bhnd_size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|bhndb_pci_eio_read
parameter_list|(
name|struct
name|bhnd_erom_io
modifier|*
name|eio
parameter_list|,
name|bhnd_size_t
name|offset
parameter_list|,
name|u_int
name|width
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|BHNDB_PCI_MSI_COUNT
value|1
end_define

begin_decl_stmt
specifier|static
name|struct
name|bhndb_pci_quirk
name|bhndb_pci_quirks
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bhndb_pci_quirk
name|bhndb_pcie_quirks
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bhndb_pci_quirk
name|bhndb_pcie2_quirks
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bhndb_pci_core
name|bhndb_pci_cores
index|[]
init|=
block|{
name|BHNDB_PCI_CORE
argument_list|(
name|PCI
argument_list|,
name|BHND_PCI_SRSH_PI_OFFSET
argument_list|,
name|bhndb_pci_quirks
argument_list|)
block|,
name|BHNDB_PCI_CORE
argument_list|(
name|PCIE
argument_list|,
name|BHND_PCIE_SRSH_PI_OFFSET
argument_list|,
name|bhndb_pcie_quirks
argument_list|)
block|,
name|BHNDB_PCI_CORE
argument_list|(
name|PCIE2
argument_list|,
name|BHND_PCIE_SRSH_PI_OFFSET
argument_list|,
name|bhndb_pcie2_quirks
argument_list|)
block|,
name|BHNDB_PCI_CORE_END
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bhndb_pci erom I/O instance state */
end_comment

begin_struct
struct|struct
name|bhndb_pci_eio
block|{
name|struct
name|bhnd_erom_io
name|eio
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
comment|/**< bridge device */
name|device_t
name|pci_dev
decl_stmt|;
comment|/**< parent PCI device */
name|struct
name|bhndb_host_resources
modifier|*
name|hr
decl_stmt|;
comment|/**< borrowed reference to host resources */
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|win
decl_stmt|;
comment|/**< mapped register window, or NULL */
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
comment|/**< resource containing the register window, or NULL if no window mapped */
name|bhnd_addr_t
name|res_target
decl_stmt|;
comment|/**< current target address (if mapped) */
name|bool
name|mapped
decl_stmt|;
comment|/**< true if a valid mapping exists, false otherwise */
name|bhnd_addr_t
name|addr
decl_stmt|;
comment|/**< mapped address */
name|bhnd_size_t
name|size
decl_stmt|;
comment|/**< mapped size */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|bhndb_pci_quirk
name|bhndb_pci_quirks
index|[]
init|=
block|{
comment|/* Backplane interrupt flags must be routed via siba-specific 	 * SIBA_CFG0_INTVEC configuration register; the BHNDB_PCI_INT_MASK 	 * PCI configuration register is unsupported. */
block|{
block|{
name|BHND_MATCH_CHIP_TYPE
argument_list|(
argument|SIBA
argument_list|)
block|}
block|,
block|{
name|BHND_MATCH_CORE_REV
argument_list|(
argument|HWREV_LTE(
literal|5
argument|)
argument_list|)
block|}
block|,
name|BHNDB_PCI_QUIRK_SIBA_INTVEC
block|}
block|,
comment|/* All PCI core revisions require the SRSH work-around */
name|BHNDB_PCI_QUIRK
argument_list|(
name|HWREV_ANY
argument_list|,
name|BHNDB_PCI_QUIRK_SRSH_WAR
argument_list|)
block|,
name|BHNDB_PCI_QUIRK_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bhndb_pci_quirk
name|bhndb_pcie_quirks
index|[]
init|=
block|{
comment|/* All PCIe-G1 core revisions require the SRSH work-around */
name|BHNDB_PCI_QUIRK
argument_list|(
name|HWREV_ANY
argument_list|,
name|BHNDB_PCI_QUIRK_SRSH_WAR
argument_list|)
block|,
name|BHNDB_PCI_QUIRK_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bhndb_pci_quirk
name|bhndb_pcie2_quirks
index|[]
init|=
block|{
comment|/* All PCIe-G2 core revisions require the SRSH work-around */
name|BHNDB_PCI_QUIRK
argument_list|(
name|HWREV_ANY
argument_list|,
name|BHNDB_PCI_QUIRK_SRSH_WAR
argument_list|)
block|,
name|BHNDB_PCI_QUIRK_END
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Return the device table entry for @p ci, or NULL if none.  */
end_comment

begin_function
specifier|static
name|struct
name|bhndb_pci_core
modifier|*
name|bhndb_pci_find_core
parameter_list|(
name|struct
name|bhnd_core_info
modifier|*
name|ci
parameter_list|)
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
operator|!
name|BHNDB_PCI_IS_CORE_END
argument_list|(
operator|&
name|bhndb_pci_cores
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bhndb_pci_core
modifier|*
name|entry
init|=
operator|&
name|bhndb_pci_cores
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|bhnd_core_matches
argument_list|(
name|ci
argument_list|,
operator|&
name|entry
operator|->
name|match
argument_list|)
condition|)
return|return
operator|(
name|entry
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return all quirk flags for the given @p cid and @p ci.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|bhndb_pci_get_core_quirks
parameter_list|(
name|struct
name|bhnd_chipid
modifier|*
name|cid
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|ci
parameter_list|)
block|{
name|struct
name|bhndb_pci_core
modifier|*
name|entry
decl_stmt|;
name|struct
name|bhndb_pci_quirk
modifier|*
name|qtable
decl_stmt|;
name|uint32_t
name|quirks
decl_stmt|;
name|quirks
operator|=
literal|0
expr_stmt|;
comment|/* No core entry? */
if|if
condition|(
operator|(
name|entry
operator|=
name|bhndb_pci_find_core
argument_list|(
name|ci
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|quirks
operator|)
return|;
comment|/* No quirks? */
if|if
condition|(
operator|(
name|qtable
operator|=
name|entry
operator|->
name|quirks
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|quirks
operator|)
return|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
operator|!
name|BHNDB_PCI_IS_QUIRK_END
argument_list|(
operator|&
name|qtable
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bhndb_pci_quirk
modifier|*
name|q
init|=
operator|&
name|qtable
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|bhnd_chip_matches
argument_list|(
name|cid
argument_list|,
operator|&
name|q
operator|->
name|chip_desc
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|bhnd_core_matches
argument_list|(
name|ci
argument_list|,
operator|&
name|q
operator|->
name|core_desc
argument_list|)
condition|)
continue|continue;
name|quirks
operator||=
name|q
operator|->
name|quirks
expr_stmt|;
block|}
return|return
operator|(
name|quirks
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   * Default bhndb_pci implementation of device_probe().  *   * Verifies that the parent is a PCI/PCIe device.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhnd_chipid
name|cid
decl_stmt|;
name|struct
name|bhnd_core_info
modifier|*
name|cores
decl_stmt|,
name|hostb_core
decl_stmt|;
name|struct
name|bhndb_pci_core
modifier|*
name|entry
decl_stmt|;
name|bhnd_devclass_t
name|hostb_devclass
decl_stmt|;
name|u_int
name|ncores
decl_stmt|;
name|device_t
name|parent
decl_stmt|;
name|devclass_t
name|parent_bus
decl_stmt|,
name|pci
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cores
operator|=
name|NULL
expr_stmt|;
comment|/* Our parent must be a PCI/PCIe device. */
name|pci
operator|=
name|devclass_find
argument_list|(
literal|"pci"
argument_list|)
expr_stmt|;
name|parent
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|parent_bus
operator|=
name|device_get_devclass
argument_list|(
name|device_get_parent
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent_bus
operator|!=
name|pci
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Enable clocks */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_enable_pci_clocks
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Identify the chip and enumerate the bridged cores */
name|error
operator|=
name|bhndb_pci_read_core_table
argument_list|(
name|dev
argument_list|,
operator|&
name|cid
argument_list|,
operator|&
name|cores
argument_list|,
operator|&
name|ncores
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Search our core table for the host bridge core */
name|hostb_devclass
operator|=
name|bhndb_expected_pci_devclass
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|bhndb_find_hostb_core
argument_list|(
name|cores
argument_list|,
name|ncores
argument_list|,
name|hostb_devclass
argument_list|,
operator|&
name|hostb_core
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Look for a matching core table entry */
if|if
condition|(
operator|(
name|entry
operator|=
name|bhndb_pci_find_core
argument_list|(
operator|&
name|hostb_core
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PCI-BHND bridge"
argument_list|)
expr_stmt|;
comment|/* fall-through */
name|error
operator|=
name|BUS_PROBE_DEFAULT
expr_stmt|;
name|cleanup
label|:
name|bhndb_disable_pci_clocks
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cores
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cores
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Attempt to allocate MSI interrupts, returning the count in @p msi_count  * on success.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_alloc_msi
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|,
name|int
modifier|*
name|msi_count
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|count
decl_stmt|;
comment|/* Is MSI available? */
if|if
condition|(
name|pci_msi_count
argument_list|(
name|sc
operator|->
name|parent
argument_list|)
operator|<
name|BHNDB_PCI_MSI_COUNT
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Allocate expected message count */
name|count
operator|=
name|BHNDB_PCI_MSI_COUNT
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pci_alloc_msi
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
operator|&
name|count
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate MSI interrupts: "
literal|"%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|count
operator|<
name|BHNDB_PCI_MSI_COUNT
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
operator|*
name|msi_count
operator|=
name|count
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bhnd_chipid
name|cid
decl_stmt|;
name|struct
name|bhnd_core_info
modifier|*
name|cores
decl_stmt|,
name|hostb_core
decl_stmt|;
name|bhnd_erom_class_t
modifier|*
name|erom_class
decl_stmt|;
name|u_int
name|ncores
decl_stmt|;
name|int
name|irq_rid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|parent
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pci_devclass
operator|=
name|bhndb_expected_pci_devclass
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pci_quirks
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|set_regwin
operator|=
name|NULL
expr_stmt|;
name|BHNDB_PCI_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cores
operator|=
name|NULL
expr_stmt|;
comment|/* Enable PCI bus mastering */
name|pci_enable_busmaster
argument_list|(
name|sc
operator|->
name|parent
argument_list|)
expr_stmt|;
comment|/* Set up PCI interrupt handling */
if|if
condition|(
name|bhndb_pci_alloc_msi
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|msi_count
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* MSI uses resource IDs starting at 1 */
name|irq_rid
operator|=
literal|1
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Using MSI interrupts on %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|msi_count
operator|=
literal|0
expr_stmt|;
name|irq_rid
operator|=
literal|0
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Using INTx interrupts on %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|isrc
operator|=
name|bhndb_alloc_intr_isrc
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|irq_rid
argument_list|,
literal|0
argument_list|,
name|RM_MAX_END
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|isrc
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate interrupt "
literal|"resource\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Enable clocks (if required by this hardware) */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_enable_pci_clocks
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Identify the chip and enumerate the bridged cores */
name|error
operator|=
name|bhndb_pci_read_core_table
argument_list|(
name|dev
argument_list|,
operator|&
name|cid
argument_list|,
operator|&
name|cores
argument_list|,
operator|&
name|ncores
argument_list|,
operator|&
name|erom_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Select the appropriate register window handler */
if|if
condition|(
name|cid
operator|.
name|chip_type
operator|==
name|BHND_CHIPTYPE_SIBA
condition|)
block|{
name|sc
operator|->
name|set_regwin
operator|=
name|bhndb_pci_compat_setregwin
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|set_regwin
operator|=
name|bhndb_pci_fast_setregwin
expr_stmt|;
block|}
comment|/* Determine our host bridge core and populate our quirk flags */
name|error
operator|=
name|bhndb_find_hostb_core
argument_list|(
name|cores
argument_list|,
name|ncores
argument_list|,
name|sc
operator|->
name|pci_devclass
argument_list|,
operator|&
name|hostb_core
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
name|sc
operator|->
name|pci_quirks
operator|=
name|bhndb_pci_get_core_quirks
argument_list|(
operator|&
name|cid
argument_list|,
operator|&
name|hostb_core
argument_list|)
expr_stmt|;
comment|/* Perform bridge attach */
name|error
operator|=
name|bhndb_attach
argument_list|(
name|dev
argument_list|,
operator|&
name|cid
argument_list|,
name|cores
argument_list|,
name|ncores
argument_list|,
operator|&
name|hostb_core
argument_list|,
name|erom_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Fix-up power on defaults for SROM-less devices. */
name|bhndb_init_sromless_pci_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Add any additional child devices */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_pci_add_children
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Probe and attach our children */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
name|free
argument_list|(
name|cores
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|cleanup
label|:
name|device_delete_children
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bhndb_disable_pci_clocks
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|isrc
operator|!=
name|NULL
condition|)
name|bhndb_free_intr_isrc
argument_list|(
name|sc
operator|->
name|isrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msi_count
operator|>
literal|0
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cores
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cores
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
name|pci_disable_busmaster
argument_list|(
name|sc
operator|->
name|parent
argument_list|)
expr_stmt|;
name|BHNDB_PCI_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Attempt to detach our children */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Perform generic bridge detach */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_generic_detach
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Disable clocks (if required by this hardware) */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_disable_pci_clocks
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Free our interrupt resources */
name|bhndb_free_intr_isrc
argument_list|(
name|sc
operator|->
name|isrc
argument_list|)
expr_stmt|;
comment|/* Release MSI interrupts */
if|if
condition|(
name|sc
operator|->
name|msi_count
operator|>
literal|0
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Disable PCI bus mastering */
name|pci_disable_busmaster
argument_list|(
name|sc
operator|->
name|parent
argument_list|)
expr_stmt|;
name|BHNDB_PCI_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Use the generic PCI bridge hardware configuration to enumerate the bridged  * bhnd(4) bus' core table.  *   * @note This function may be safely called prior to device attach, (e.g.  * from DEVICE_PROBE).  * @note This function requires exclusive ownership over allocating and   * configuring host bridge resources, and should only be called prior to  * completion of device attach and full configuration of the bridge.  *   * @param	dev		The bhndb_pci bridge device.  * @param[out]	chipid		On success, the parsed chip identification.  * @param[out]	cores		On success, the enumerated core table. The  *				caller is responsible for freeing this table via  *				bhndb_pci_free_core_table().  * @param[out]	ncores		On success, the number of cores found in  *				@p cores.  * @param[out]	eromcls		On success, a pointer to the erom class used to  *				parse the device enumeration table. This  *				argument may be NULL if the class is not  *				desired.  *   * @retval 0		success  * @retval non-zero	if enumerating the bridged bhnd(4) bus fails, a regular  * 			unix error code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_read_core_table
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|bhnd_chipid
modifier|*
name|chipid
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
modifier|*
name|cores
parameter_list|,
name|u_int
modifier|*
name|ncores
parameter_list|,
name|bhnd_erom_class_t
modifier|*
modifier|*
name|eromcls
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_hwcfg
modifier|*
name|cfg
decl_stmt|;
name|struct
name|bhndb_host_resources
modifier|*
name|hr
decl_stmt|;
name|struct
name|bhndb_pci_eio
name|pio
decl_stmt|;
name|struct
name|bhnd_core_info
modifier|*
name|erom_cores
decl_stmt|;
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|hint
decl_stmt|;
name|struct
name|bhnd_chipid
name|cid
decl_stmt|;
name|bhnd_erom_class_t
modifier|*
name|erom_class
decl_stmt|;
name|bhnd_erom_t
modifier|*
name|erom
decl_stmt|;
name|device_t
name|parent_dev
decl_stmt|;
name|u_int
name|erom_ncores
decl_stmt|;
name|int
name|error
decl_stmt|;
name|parent_dev
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|erom
operator|=
name|NULL
expr_stmt|;
name|erom_cores
operator|=
name|NULL
expr_stmt|;
comment|/* Fetch our chipid hint (if any) and generic hardware configuration */
name|cfg
operator|=
name|BHNDB_BUS_GET_GENERIC_HWCFG
argument_list|(
name|parent_dev
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|hint
operator|=
name|BHNDB_BUS_GET_CHIPID
argument_list|(
name|parent_dev
argument_list|,
name|dev
argument_list|)
expr_stmt|;
comment|/* Allocate our host resources */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_alloc_host_resources
argument_list|(
operator|&
name|hr
argument_list|,
name|dev
argument_list|,
name|parent_dev
argument_list|,
name|cfg
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Initialize our erom I/O state */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_pci_eio_init
argument_list|(
operator|&
name|pio
argument_list|,
name|dev
argument_list|,
name|parent_dev
argument_list|,
name|hr
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
comment|/* Map the first bus core from our bridged bhnd(4) bus */
name|error
operator|=
name|bhndb_pci_eio_map
argument_list|(
operator|&
name|pio
operator|.
name|eio
argument_list|,
name|BHND_DEFAULT_CHIPC_ADDR
argument_list|,
name|BHND_DEFAULT_CORE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
comment|/* Probe for a usable EROM class, and read the chip identifier */
name|erom_class
operator|=
name|bhnd_erom_probe_driver_classes
argument_list|(
name|device_get_devclass
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|&
name|pio
operator|.
name|eio
argument_list|,
name|hint
argument_list|,
operator|&
name|cid
argument_list|)
expr_stmt|;
if|if
condition|(
name|erom_class
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"device enumeration unsupported; no "
literal|"compatible driver found\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* Allocate EROM parser */
if|if
condition|(
operator|(
name|erom
operator|=
name|bhnd_erom_alloc
argument_list|(
name|erom_class
argument_list|,
operator|&
name|cid
argument_list|,
operator|&
name|pio
operator|.
name|eio
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate device enumeration "
literal|"table parser\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* Read the full core table */
name|error
operator|=
name|bhnd_erom_get_core_table
argument_list|(
name|erom
argument_list|,
operator|&
name|erom_cores
argument_list|,
operator|&
name|erom_ncores
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"error fetching core table: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* Provide the results to our caller */
operator|*
name|cores
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|erom_cores
index|[
literal|0
index|]
argument_list|)
operator|*
name|erom_ncores
argument_list|,
name|M_BHND
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|cores
argument_list|,
name|erom_cores
argument_list|,
sizeof|sizeof
argument_list|(
name|erom_cores
index|[
literal|0
index|]
argument_list|)
operator|*
name|erom_ncores
argument_list|)
expr_stmt|;
operator|*
name|ncores
operator|=
name|erom_ncores
expr_stmt|;
operator|*
name|chipid
operator|=
name|cid
expr_stmt|;
if|if
condition|(
name|eromcls
operator|!=
name|NULL
condition|)
operator|*
name|eromcls
operator|=
name|erom_class
expr_stmt|;
comment|/* Clean up */
name|bhnd_erom_free_core_table
argument_list|(
name|erom
argument_list|,
name|erom_cores
argument_list|)
expr_stmt|;
name|bhnd_erom_free
argument_list|(
name|erom
argument_list|)
expr_stmt|;
name|bhndb_release_host_resources
argument_list|(
name|hr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
if|if
condition|(
name|erom_cores
operator|!=
name|NULL
condition|)
name|bhnd_erom_free_core_table
argument_list|(
name|erom
argument_list|,
name|erom_cores
argument_list|)
expr_stmt|;
if|if
condition|(
name|erom
operator|!=
name|NULL
condition|)
name|bhnd_erom_free
argument_list|(
name|erom
argument_list|)
expr_stmt|;
name|bhndb_release_host_resources
argument_list|(
name|hr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_add_children
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bus_size_t
name|nv_sz
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/** 	 * If SPROM is mapped directly into BAR0, add child NVRAM 	 * device. 	 */
name|nv_sz
operator|=
name|bhndb_pci_sprom_size
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nv_sz
operator|>
literal|0
condition|)
block|{
name|struct
name|bhndb_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|device_t
name|child
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"found SPROM (%ju bytes)\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|nv_sz
argument_list|)
expr_stmt|;
block|}
comment|/* Add sprom device, ordered early enough to be available 		 * before the bridged bhnd(4) bus is attached. */
name|child
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|BHND_PROBE_ROOT
operator|+
name|BHND_PROBE_ORDER_EARLY
argument_list|,
literal|"bhnd_nvram"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to add sprom device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Initialize device address space and resource covering the 		 * BAR0 SPROM shadow. */
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|addrspace
operator|=
name|BHNDB_ADDRSPACE_NATIVE
expr_stmt|;
name|error
operator|=
name|bus_set_resource
argument_list|(
name|child
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|bhndb_pci_sprom_addr
argument_list|(
name|sc
argument_list|)
argument_list|,
name|nv_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to register sprom resources\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|bhndb_pci_sprom_regwin
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bhndb_resources
modifier|*
name|bres
decl_stmt|;
specifier|const
name|struct
name|bhndb_hwcfg
modifier|*
name|cfg
decl_stmt|;
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|sprom_win
decl_stmt|;
name|bres
operator|=
name|sc
operator|->
name|bhndb
operator|.
name|bus_res
expr_stmt|;
name|cfg
operator|=
name|bres
operator|->
name|cfg
expr_stmt|;
name|sprom_win
operator|=
name|bhndb_regwin_find_type
argument_list|(
name|cfg
operator|->
name|register_windows
argument_list|,
name|BHNDB_REGWIN_T_SPROM
argument_list|,
name|BHNDB_PCI_V0_BAR0_SPROM_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|sprom_win
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bus_addr_t
name|bhndb_pci_sprom_addr
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|sprom_win
decl_stmt|;
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
comment|/* Fetch the SPROM register window */
name|sprom_win
operator|=
name|bhndb_pci_sprom_regwin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sprom_win
operator|!=
name|NULL
argument_list|,
operator|(
literal|"requested sprom address on PCI_V2+"
operator|)
argument_list|)
expr_stmt|;
comment|/* Fetch the associated resource */
name|r
operator|=
name|bhndb_host_resource_for_regwin
argument_list|(
name|sc
operator|->
name|bhndb
operator|.
name|bus_res
operator|->
name|res
argument_list|,
name|sprom_win
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|r
operator|!=
name|NULL
argument_list|,
operator|(
literal|"missing resource for sprom window\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rman_get_start
argument_list|(
name|r
argument_list|)
operator|+
name|sprom_win
operator|->
name|win_offset
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bus_size_t
name|bhndb_pci_sprom_size
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|sprom_win
decl_stmt|;
name|uint32_t
name|sctl
decl_stmt|;
name|bus_size_t
name|sprom_sz
decl_stmt|;
name|sprom_win
operator|=
name|bhndb_pci_sprom_regwin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* PCI_V2 and later devices map SPROM/OTP via ChipCommon */
if|if
condition|(
name|sprom_win
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Determine SPROM size */
name|sctl
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|BHNDB_PCI_SPROM_CONTROL
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctl
operator|&
name|BHNDB_PCI_SPROM_BLANK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|sctl
operator|&
name|BHNDB_PCI_SPROM_SZ_MASK
condition|)
block|{
case|case
name|BHNDB_PCI_SPROM_SZ_1KB
case|:
name|sprom_sz
operator|=
operator|(
literal|1
operator|*
literal|1024
operator|)
expr_stmt|;
break|break;
case|case
name|BHNDB_PCI_SPROM_SZ_4KB
case|:
name|sprom_sz
operator|=
operator|(
literal|4
operator|*
literal|1024
operator|)
expr_stmt|;
break|break;
case|case
name|BHNDB_PCI_SPROM_SZ_16KB
case|:
name|sprom_sz
operator|=
operator|(
literal|16
operator|*
literal|1024
operator|)
expr_stmt|;
break|break;
case|case
name|BHNDB_PCI_SPROM_SZ_RESERVED
case|:
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"invalid PCI sprom size 0x%x\n"
argument_list|,
name|sctl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sprom_sz
operator|>
name|sprom_win
operator|->
name|win_size
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"PCI sprom size (0x%x) overruns defined register window\n"
argument_list|,
name|sctl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|sprom_sz
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the host resource providing a static mapping of the PCI core's  * registers.  *   * @param	sc	bhndb PCI driver state.  * @param[out]	res	On success, the host resource containing our PCI  *			core's register window.  * @param[out]	offset	On success, the offset of the PCI core registers within  * 			@p res.  *  * @retval 0		success  * @retval ENXIO	if a valid static register window mapping the PCI core  *			registers is not available.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_get_core_regs
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|resource
modifier|*
modifier|*
name|res
parameter_list|,
name|bus_size_t
modifier|*
name|offset
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|win
decl_stmt|;
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
comment|/* Locate the static register window mapping the PCI core */
name|win
operator|=
name|bhndb_regwin_find_core
argument_list|(
name|sc
operator|->
name|bhndb
operator|.
name|bus_res
operator|->
name|cfg
operator|->
name|register_windows
argument_list|,
name|sc
operator|->
name|pci_devclass
argument_list|,
literal|0
argument_list|,
name|BHND_PORT_DEVICE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"missing PCI core register window\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Fetch the resource containing the register window */
name|r
operator|=
name|bhndb_host_resource_for_regwin
argument_list|(
name|sc
operator|->
name|bhndb
operator|.
name|bus_res
operator|->
name|res
argument_list|,
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"missing PCI core register resource\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
operator|*
name|res
operator|=
name|r
expr_stmt|;
operator|*
name|offset
operator|=
name|win
operator|->
name|win_offset
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Write a 1, 2, or 4 byte data item to the PCI core's registers at @p offset.  *   * @param sc		bhndb PCI driver state.  * @param offset	register write offset.  * @param value		value to be written.  * @param width		item width (1, 2, or 4 bytes).  */
end_comment

begin_function
specifier|static
name|void
name|bhndb_pci_write_core
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|uint32_t
name|value
parameter_list|,
name|u_int
name|width
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
name|bus_size_t
name|r_offset
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_pci_get_core_regs
argument_list|(
name|sc
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|r_offset
argument_list|)
operator|)
condition|)
name|panic
argument_list|(
literal|"no PCI core registers: %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|1
case|:
name|bus_write_1
argument_list|(
name|r
argument_list|,
name|r_offset
operator|+
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bus_write_2
argument_list|(
name|r
argument_list|,
name|r_offset
operator|+
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bus_write_4
argument_list|(
name|r
argument_list|,
name|r_offset
operator|+
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"invalid width: %u"
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Read a 1, 2, or 4 byte data item from the PCI core's registers  * at @p offset.  *   * @param sc		bhndb PCI driver state.  * @param offset	register read offset.  * @param width		item width (1, 2, or 4 bytes).  */
end_comment

begin_function
specifier|static
name|uint32_t
name|bhndb_pci_read_core
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|u_int
name|width
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
name|bus_size_t
name|r_offset
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_pci_get_core_regs
argument_list|(
name|sc
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|r_offset
argument_list|)
operator|)
condition|)
name|panic
argument_list|(
literal|"no PCI core registers: %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|(
name|bus_read_1
argument_list|(
name|r
argument_list|,
name|r_offset
operator|+
name|offset
argument_list|)
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
name|bus_read_2
argument_list|(
name|r
argument_list|,
name|r_offset
operator|+
name|offset
argument_list|)
operator|)
return|;
case|case
literal|4
case|:
return|return
operator|(
name|bus_read_4
argument_list|(
name|r
argument_list|,
name|r_offset
operator|+
name|offset
argument_list|)
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"invalid width: %u"
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * On devices without a SROM, the PCI(e) cores will be initialized with  * their Power-on-Reset defaults; this can leave two of the BAR0 PCI windows  * mapped to the wrong core.  *   * This function updates the SROM shadow to point the BAR0 windows at the  * current PCI core.  *   * Applies to all PCI/PCIe revisions.  */
end_comment

begin_function
specifier|static
name|void
name|bhndb_init_sromless_pci_config
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_pci_core
modifier|*
name|pci_core
decl_stmt|;
name|bus_size_t
name|srsh_offset
decl_stmt|;
name|u_int
name|pci_cidx
decl_stmt|,
name|sprom_cidx
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|pci_quirks
operator|&
name|BHNDB_PCI_QUIRK_SRSH_WAR
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* Determine the correct register offset for our PCI core */
name|pci_core
operator|=
name|bhndb_pci_find_core
argument_list|(
operator|&
name|sc
operator|->
name|bhndb
operator|.
name|bridge_core
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pci_core
operator|!=
name|NULL
argument_list|,
operator|(
literal|"missing core table entry"
operator|)
argument_list|)
expr_stmt|;
name|srsh_offset
operator|=
name|pci_core
operator|->
name|srsh_offset
expr_stmt|;
comment|/* Fetch the SPROM's configured core index */
name|val
operator|=
name|bhndb_pci_read_core
argument_list|(
name|sc
argument_list|,
name|srsh_offset
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|sprom_cidx
operator|=
operator|(
name|val
operator|&
name|BHND_PCI_SRSH_PI_MASK
operator|)
operator|>>
name|BHND_PCI_SRSH_PI_SHIFT
expr_stmt|;
comment|/* If it doesn't match host bridge's core index, update the index 	 * value */
name|pci_cidx
operator|=
name|sc
operator|->
name|bhndb
operator|.
name|bridge_core
operator|.
name|core_idx
expr_stmt|;
if|if
condition|(
name|sprom_cidx
operator|!=
name|pci_cidx
condition|)
block|{
name|val
operator|&=
operator|~
name|BHND_PCI_SRSH_PI_MASK
expr_stmt|;
name|val
operator||=
operator|(
name|pci_cidx
operator|<<
name|BHND_PCI_SRSH_PI_SHIFT
operator|)
expr_stmt|;
name|bhndb_pci_write_core
argument_list|(
name|sc
argument_list|,
name|srsh_offset
argument_list|,
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Enable clocks (if supported by this hardware) */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_enable_pci_clocks
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Perform resume */
return|return
operator|(
name|bhndb_generic_resume
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Disable clocks (if supported by this hardware) */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_disable_pci_clocks
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Perform suspend */
return|return
operator|(
name|bhndb_generic_suspend
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_set_window_addr
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|sc
operator|->
name|set_regwin
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|parent
argument_list|,
name|rw
argument_list|,
name|addr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * A siba(4) and bcma(4)-compatible bhndb_set_window_addr implementation.  *   * On siba(4) devices, it's possible that writing a PCI window register may  * not succeed; it's necessary to immediately read the configuration register  * and retry if not set to the desired value.  *   * This is not necessary on bcma(4) devices, but other than the overhead of  * validating the register, there's no harm in performing the verification.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_compat_setregwin
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|pci_dev
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|rw
operator|->
name|win_type
operator|!=
name|BHNDB_REGWIN_T_DYN
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|reg
operator|=
name|rw
operator|->
name|d
operator|.
name|dyn
operator|.
name|cfg_offset
expr_stmt|;
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BHNDB_PCI_BARCTRL_WRITE_RETRY
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_pci_fast_setregwin
argument_list|(
name|dev
argument_list|,
name|pci_dev
argument_list|,
name|rw
argument_list|,
name|addr
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|pci_read_config
argument_list|(
name|pci_dev
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
operator|==
name|addr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/* Unable to set window */
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * A bcma(4)-only bhndb_set_window_addr implementation.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_fast_setregwin
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|pci_dev
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|)
block|{
comment|/* The PCI bridge core only supports 32-bit addressing, regardless 	 * of the bus' support for 64-bit addressing */
if|if
condition|(
name|addr
operator|>
name|UINT32_MAX
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
switch|switch
condition|(
name|rw
operator|->
name|win_type
condition|)
block|{
case|case
name|BHNDB_REGWIN_T_DYN
case|:
comment|/* Addresses must be page aligned */
if|if
condition|(
name|addr
operator|%
name|rw
operator|->
name|win_size
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pci_write_config
argument_list|(
name|pci_dev
argument_list|,
name|rw
operator|->
name|d
operator|.
name|dyn
operator|.
name|cfg_offset
argument_list|,
name|addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_populate_board_info
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|bhnd_board_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/*  	 * On a subset of Apple BCM4360 modules, always prefer the 	 * PCI subdevice to the SPROM-supplied boardtype. 	 *  	 * TODO: 	 *  	 * Broadcom's own drivers implement this override, and then later use 	 * the remapped BCM4360 board type to determine the required 	 * board-specific workarounds. 	 *  	 * Without access to this hardware, it's unclear why this mapping 	 * is done, and we must do the same. If we can survey the hardware 	 * in question, it may be possible to replace this behavior with 	 * explicit references to the SPROM-supplied boardtype(s) in our 	 * quirk definitions. 	 */
if|if
condition|(
name|pci_get_subvendor
argument_list|(
name|sc
operator|->
name|parent
argument_list|)
operator|==
name|PCI_VENDOR_APPLE
condition|)
block|{
switch|switch
condition|(
name|info
operator|->
name|board_type
condition|)
block|{
case|case
name|BHND_BOARD_BCM94360X29C
case|:
case|case
name|BHND_BOARD_BCM94360X29CP2
case|:
case|case
name|BHND_BOARD_BCM94360X51
case|:
case|case
name|BHND_BOARD_BCM94360X51P2
case|:
name|info
operator|->
name|board_type
operator|=
literal|0
expr_stmt|;
comment|/* allow override below */
break|break;
default|default:
break|break;
block|}
block|}
comment|/* If NVRAM did not supply vendor/type info, provide the PCI 	 * subvendor/subdevice values. */
if|if
condition|(
name|info
operator|->
name|board_vendor
operator|==
literal|0
condition|)
name|info
operator|->
name|board_vendor
operator|=
name|pci_get_subvendor
argument_list|(
name|sc
operator|->
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|board_type
operator|==
literal|0
condition|)
name|info
operator|->
name|board_type
operator|=
name|pci_get_subdevice
argument_list|(
name|sc
operator|->
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Examine the bridge device @p dev and return the expected host bridge  * device class.  *  * @param dev The bhndb bridge device  */
end_comment

begin_function
specifier|static
name|bhnd_devclass_t
name|bhndb_expected_pci_devclass
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|bhndb_is_pcie_attached
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|BHND_DEVCLASS_PCIE
operator|)
return|;
else|else
return|return
operator|(
name|BHND_DEVCLASS_PCI
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if the bridge device @p dev is attached via PCIe,  * false otherwise.  *  * @param dev The bhndb bridge device  */
end_comment

begin_function
specifier|static
name|bool
name|bhndb_is_pcie_attached
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|pci_find_cap
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Enable externally managed clocks, if required.  *   * Some PCI chipsets (BCM4306, possibly others) chips do not support  * the idle low-power clock. Clocking must be bootstrapped at  * attach/resume by directly adjusting GPIO registers exposed in the  * PCI config space, and correspondingly, explicitly shutdown at  * detach/suspend.  *  * @note This function may be safely called prior to device attach, (e.g.  * from DEVICE_PROBE).  *  * @param dev The bhndb bridge device  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_enable_pci_clocks
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|pci_dev
decl_stmt|;
name|uint32_t
name|gpio_in
decl_stmt|,
name|gpio_out
decl_stmt|,
name|gpio_en
decl_stmt|;
name|uint32_t
name|gpio_flags
decl_stmt|;
name|uint16_t
name|pci_status
decl_stmt|;
name|pci_dev
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Only supported and required on PCI devices */
if|if
condition|(
operator|!
name|bhndb_is_pcie_attached
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Read state of XTAL pin */
name|gpio_in
operator|=
name|pci_read_config
argument_list|(
name|pci_dev
argument_list|,
name|BHNDB_PCI_GPIO_IN
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|gpio_in
operator|&
name|BHNDB_PCI_GPIO_XTAL_ON
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* already enabled */
comment|/* Fetch current config */
name|gpio_out
operator|=
name|pci_read_config
argument_list|(
name|pci_dev
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gpio_en
operator|=
name|pci_read_config
argument_list|(
name|pci_dev
argument_list|,
name|BHNDB_PCI_GPIO_OUTEN
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Set PLL_OFF/XTAL_ON pins to HIGH and enable both pins */
name|gpio_flags
operator|=
operator|(
name|BHNDB_PCI_GPIO_PLL_OFF
operator||
name|BHNDB_PCI_GPIO_XTAL_ON
operator|)
expr_stmt|;
name|gpio_out
operator||=
name|gpio_flags
expr_stmt|;
name|gpio_en
operator||=
name|gpio_flags
expr_stmt|;
name|pci_write_config
argument_list|(
name|pci_dev
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
name|gpio_out
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|pci_dev
argument_list|,
name|BHNDB_PCI_GPIO_OUTEN
argument_list|,
name|gpio_en
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Reset PLL_OFF */
name|gpio_out
operator|&=
operator|~
name|BHNDB_PCI_GPIO_PLL_OFF
expr_stmt|;
name|pci_write_config
argument_list|(
name|pci_dev
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
name|gpio_out
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* Clear any PCI 'sent target-abort' flag. */
name|pci_status
operator|=
name|pci_read_config
argument_list|(
name|pci_dev
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_status
operator|&=
operator|~
name|PCIM_STATUS_STABORT
expr_stmt|;
name|pci_write_config
argument_list|(
name|pci_dev
argument_list|,
name|PCIR_STATUS
argument_list|,
name|pci_status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Disable externally managed clocks, if required.  *  * This function may be safely called prior to device attach, (e.g.  * from DEVICE_PROBE).  *  * @param dev The bhndb bridge device  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_disable_pci_clocks
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|pci_dev
decl_stmt|;
name|uint32_t
name|gpio_out
decl_stmt|,
name|gpio_en
decl_stmt|;
name|pci_dev
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Only supported and required on PCI devices */
if|if
condition|(
name|bhndb_is_pcie_attached
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Fetch current config */
name|gpio_out
operator|=
name|pci_read_config
argument_list|(
name|pci_dev
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gpio_en
operator|=
name|pci_read_config
argument_list|(
name|pci_dev
argument_list|,
name|BHNDB_PCI_GPIO_OUTEN
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Set PLL_OFF to HIGH, XTAL_ON to LOW. */
name|gpio_out
operator|&=
operator|~
name|BHNDB_PCI_GPIO_XTAL_ON
expr_stmt|;
name|gpio_out
operator||=
name|BHNDB_PCI_GPIO_PLL_OFF
expr_stmt|;
name|pci_write_config
argument_list|(
name|pci_dev
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
name|gpio_out
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Enable both output pins */
name|gpio_en
operator||=
operator|(
name|BHNDB_PCI_GPIO_PLL_OFF
operator||
name|BHNDB_PCI_GPIO_XTAL_ON
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|pci_dev
argument_list|,
name|BHNDB_PCI_GPIO_OUTEN
argument_list|,
name|gpio_en
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bhnd_clksrc
name|bhndb_pci_pwrctl_get_clksrc
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|bhnd_clock
name|clock
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|gpio_out
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Only supported on PCI devices */
if|if
condition|(
name|bhndb_is_pcie_attached
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Only ILP is supported */
if|if
condition|(
name|clock
operator|!=
name|BHND_CLOCK_ILP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|gpio_out
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|gpio_out
operator|&
name|BHNDB_PCI_GPIO_SCS
condition|)
return|return
operator|(
name|BHND_CLKSRC_PCI
operator|)
return|;
else|else
return|return
operator|(
name|BHND_CLKSRC_XTAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_pwrctl_gate_clock
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|bhnd_clock
name|clock
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Only supported on PCI devices */
if|if
condition|(
name|bhndb_is_pcie_attached
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Only HT is supported */
if|if
condition|(
name|clock
operator|!=
name|BHND_CLOCK_HT
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|bhndb_disable_pci_clocks
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_pwrctl_ungate_clock
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|bhnd_clock
name|clock
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Only supported on PCI devices */
if|if
condition|(
name|bhndb_is_pcie_attached
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Only HT is supported */
if|if
condition|(
name|clock
operator|!=
name|BHND_CLOCK_HT
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|bhndb_enable_pci_clocks
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * BHNDB_MAP_INTR_ISRC()  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_map_intr_isrc
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|struct
name|bhndb_intr_isrc
modifier|*
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* There's only one bridged interrupt to choose from */
operator|*
name|isrc
operator|=
name|sc
operator|->
name|isrc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* siba-specific implementation of BHNDB_ROUTE_INTERRUPTS() */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_route_siba_interrupts
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|uint32_t
name|sbintvec
decl_stmt|;
name|u_int
name|ivec
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|pci_quirks
operator|&
name|BHNDB_PCI_QUIRK_SIBA_INTVEC
argument_list|,
operator|(
literal|"route_siba_interrupts not supported by this hardware"
operator|)
argument_list|)
expr_stmt|;
comment|/* Fetch the sbflag# for the child */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_get_intr_ivec
argument_list|(
name|child
argument_list|,
literal|0
argument_list|,
operator|&
name|ivec
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|ivec
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|sbintvec
argument_list|)
operator|*
literal|8
operator|)
operator|-
literal|1
comment|/* aka '31' */
condition|)
block|{
comment|/* This should never be an issue in practice */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot route interrupts to high "
literal|"sbflag# %u\n"
argument_list|,
name|ivec
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|BHNDB_PCI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sbintvec
operator|=
name|bhndb_pci_read_core
argument_list|(
name|sc
argument_list|,
name|SB0_REG_ABS
argument_list|(
name|SIBA_CFG0_INTVEC
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sbintvec
operator||=
operator|(
literal|1
operator|<<
name|ivec
operator|)
expr_stmt|;
name|bhndb_pci_write_core
argument_list|(
name|sc
argument_list|,
name|SB0_REG_ABS
argument_list|(
name|SIBA_CFG0_INTVEC
argument_list|)
argument_list|,
name|sbintvec
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|BHNDB_PCI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* BHNDB_ROUTE_INTERRUPTS() */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_route_interrupts
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bhnd_core_info
name|core
decl_stmt|;
name|uint32_t
name|core_bit
decl_stmt|;
name|uint32_t
name|intmask
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pci_quirks
operator|&
name|BHNDB_PCI_QUIRK_SIBA_INTVEC
condition|)
return|return
operator|(
name|bhndb_pci_route_siba_interrupts
argument_list|(
name|sc
argument_list|,
name|child
argument_list|)
operator|)
return|;
name|core
operator|=
name|bhnd_get_core_info
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|core
operator|.
name|core_idx
operator|>
name|BHNDB_PCI_SBIM_COREIDX_MAX
condition|)
block|{
comment|/* This should never be an issue in practice */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot route interrupts to high core "
literal|"index %u\n"
argument_list|,
name|core
operator|.
name|core_idx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|BHNDB_PCI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|core_bit
operator|=
operator|(
literal|1
operator|<<
name|core
operator|.
name|core_idx
operator|)
operator|<<
name|BHNDB_PCI_SBIM_SHIFT
expr_stmt|;
name|intmask
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|BHNDB_PCI_INT_MASK
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|intmask
operator||=
name|core_bit
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|BHNDB_PCI_INT_MASK
argument_list|,
name|intmask
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|BHNDB_PCI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize a new bhndb PCI bridge EROM I/O instance. This EROM I/O  * implementation supports mapping of the device enumeration table via the  * @p hr host resources.  *   * @param pio		The instance to be initialized.  * @param dev		The bridge device.  * @param pci_dev	The bridge's parent PCI device.  * @param hr		The host resources to be used to map the device  *			enumeration table.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_eio_init
parameter_list|(
name|struct
name|bhndb_pci_eio
modifier|*
name|pio
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|device_t
name|pci_dev
parameter_list|,
name|struct
name|bhndb_host_resources
modifier|*
name|hr
parameter_list|)
block|{
name|memset
argument_list|(
operator|&
name|pio
operator|->
name|eio
argument_list|,
sizeof|sizeof
argument_list|(
name|pio
operator|->
name|eio
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pio
operator|->
name|eio
operator|.
name|map
operator|=
name|bhndb_pci_eio_map
expr_stmt|;
name|pio
operator|->
name|eio
operator|.
name|read
operator|=
name|bhndb_pci_eio_read
expr_stmt|;
name|pio
operator|->
name|eio
operator|.
name|fini
operator|=
name|NULL
expr_stmt|;
name|pio
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|pio
operator|->
name|pci_dev
operator|=
name|pci_dev
expr_stmt|;
name|pio
operator|->
name|hr
operator|=
name|hr
expr_stmt|;
name|pio
operator|->
name|win
operator|=
name|NULL
expr_stmt|;
name|pio
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Attempt to adjust the dynamic register window backing @p pio to permit  * reading @p size bytes at @p addr.  *   * If @p addr or @p size fall outside the existing mapped range, or if  * @p pio is not backed by a dynamic register window, ENXIO will be returned.  *   * @param pio	The bhndb PCI erom I/O state to be modified.  * @param addr	The address to be include  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_eio_adjust_mapping
parameter_list|(
name|struct
name|bhndb_pci_eio
modifier|*
name|pio
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|,
name|bhnd_size_t
name|size
parameter_list|)
block|{
name|bhnd_addr_t
name|target
decl_stmt|;
name|bhnd_size_t
name|offset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|pio
operator|->
name|win
operator|!=
name|NULL
argument_list|,
operator|(
literal|"missing register window"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pio
operator|->
name|res
operator|!=
name|NULL
argument_list|,
operator|(
literal|"missing regwin resource"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pio
operator|->
name|win
operator|->
name|win_type
operator|==
name|BHNDB_REGWIN_T_DYN
argument_list|,
operator|(
literal|"unexpected window type %d"
operator|,
name|pio
operator|->
name|win
operator|->
name|win_type
operator|)
argument_list|)
expr_stmt|;
comment|/* The requested subrange must fall within the total mapped range */
if|if
condition|(
name|addr
operator|<
name|pio
operator|->
name|addr
operator|||
operator|(
name|addr
operator|-
name|pio
operator|->
name|addr
operator|)
operator|>
name|pio
operator|->
name|size
operator|||
name|size
operator|>
name|pio
operator|->
name|size
operator|||
operator|(
name|addr
operator|-
name|pio
operator|->
name|addr
operator|)
operator|-
name|pio
operator|->
name|size
operator|<
name|size
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Do we already have a useable mapping? */
if|if
condition|(
name|addr
operator|>=
name|pio
operator|->
name|res_target
operator|&&
name|addr
operator|<=
name|pio
operator|->
name|res_target
operator|+
name|pio
operator|->
name|win
operator|->
name|win_size
operator|&&
operator|(
name|pio
operator|->
name|res_target
operator|+
name|pio
operator|->
name|win
operator|->
name|win_size
operator|)
operator|-
name|addr
operator|>=
name|size
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Page-align the target address */
name|offset
operator|=
name|addr
operator|%
name|pio
operator|->
name|win
operator|->
name|win_size
expr_stmt|;
name|target
operator|=
name|addr
operator|-
name|offset
expr_stmt|;
comment|/* Configure the register window */
name|error
operator|=
name|bhndb_pci_compat_setregwin
argument_list|(
name|pio
operator|->
name|dev
argument_list|,
name|pio
operator|->
name|pci_dev
argument_list|,
name|pio
operator|->
name|win
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|pio
operator|->
name|dev
argument_list|,
literal|"failed to configure dynamic register "
literal|"window: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|pio
operator|->
name|res_target
operator|=
name|target
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* bhnd_erom_io_map() implementation */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_eio_map
parameter_list|(
name|struct
name|bhnd_erom_io
modifier|*
name|eio
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|,
name|bhnd_size_t
name|size
parameter_list|)
block|{
name|struct
name|bhndb_pci_eio
modifier|*
name|pio
decl_stmt|;
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|regwin
decl_stmt|;
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
name|bhnd_addr_t
name|target
decl_stmt|;
name|bhnd_size_t
name|offset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pio
operator|=
operator|(
expr|struct
name|bhndb_pci_eio
operator|*
operator|)
name|eio
expr_stmt|;
comment|/* Locate a useable dynamic register window */
name|regwin
operator|=
name|bhndb_regwin_find_type
argument_list|(
name|pio
operator|->
name|hr
operator|->
name|cfg
operator|->
name|register_windows
argument_list|,
name|BHNDB_REGWIN_T_DYN
argument_list|,
name|MIN
argument_list|(
name|size
argument_list|,
name|BHND_DEFAULT_CORE_SIZE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regwin
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|pio
operator|->
name|dev
argument_list|,
literal|"unable to map %#jx+%#jx; no "
literal|"usable dynamic register window found\n"
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Locate the host resource mapping our register window */
if|if
condition|(
operator|(
name|r
operator|=
name|bhndb_host_resource_for_regwin
argument_list|(
name|pio
operator|->
name|hr
argument_list|,
name|regwin
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|pio
operator|->
name|dev
argument_list|,
literal|"unable to map %#jx+%#jx; no "
literal|"usable register resource found\n"
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Page-align the target address */
name|offset
operator|=
name|addr
operator|%
name|regwin
operator|->
name|win_size
expr_stmt|;
name|target
operator|=
name|addr
operator|-
name|offset
expr_stmt|;
comment|/* Configure the register window */
name|error
operator|=
name|bhndb_pci_compat_setregwin
argument_list|(
name|pio
operator|->
name|dev
argument_list|,
name|pio
operator|->
name|pci_dev
argument_list|,
name|regwin
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|pio
operator|->
name|dev
argument_list|,
literal|"failed to configure dynamic register "
literal|"window: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Update our mapping state */
name|pio
operator|->
name|win
operator|=
name|regwin
expr_stmt|;
name|pio
operator|->
name|res
operator|=
name|r
expr_stmt|;
name|pio
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|pio
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|pio
operator|->
name|res_target
operator|=
name|target
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* bhnd_erom_io_read() implementation */
end_comment

begin_function
specifier|static
name|uint32_t
name|bhndb_pci_eio_read
parameter_list|(
name|struct
name|bhnd_erom_io
modifier|*
name|eio
parameter_list|,
name|bhnd_size_t
name|offset
parameter_list|,
name|u_int
name|width
parameter_list|)
block|{
name|struct
name|bhndb_pci_eio
modifier|*
name|pio
decl_stmt|;
name|bhnd_addr_t
name|addr
decl_stmt|;
name|bus_size_t
name|res_offset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pio
operator|=
operator|(
expr|struct
name|bhndb_pci_eio
operator|*
operator|)
name|eio
expr_stmt|;
comment|/* Calculate absolute address */
if|if
condition|(
name|BHND_SIZE_MAX
operator|-
name|offset
operator|<
name|pio
operator|->
name|addr
condition|)
block|{
name|device_printf
argument_list|(
name|pio
operator|->
name|dev
argument_list|,
literal|"invalid offset %#jx+%#jx\n"
argument_list|,
name|pio
operator|->
name|addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|UINT32_MAX
operator|)
return|;
block|}
name|addr
operator|=
name|pio
operator|->
name|addr
operator|+
name|offset
expr_stmt|;
comment|/* Adjust the mapping for our read */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_pci_eio_adjust_mapping
argument_list|(
name|pio
argument_list|,
name|addr
argument_list|,
name|width
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|pio
operator|->
name|dev
argument_list|,
literal|"failed to adjust register mapping: "
literal|"%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|UINT32_MAX
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|pio
operator|->
name|res_target
operator|<=
name|addr
argument_list|,
operator|(
literal|"invalid mapping (%#jx vs. %#jx)"
operator|,
name|pio
operator|->
name|res_target
operator|,
name|addr
operator|)
argument_list|)
expr_stmt|;
comment|/* Determine the actual read offset within our register window 	 * resource */
name|res_offset
operator|=
operator|(
name|addr
operator|-
name|pio
operator|->
name|res_target
operator|)
operator|+
name|pio
operator|->
name|win
operator|->
name|win_offset
expr_stmt|;
comment|/* Perform our read */
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|(
name|bus_read_1
argument_list|(
name|pio
operator|->
name|res
argument_list|,
name|res_offset
argument_list|)
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
name|bus_read_2
argument_list|(
name|pio
operator|->
name|res
argument_list|,
name|res_offset
argument_list|)
operator|)
return|;
case|case
literal|4
case|:
return|return
operator|(
name|bus_read_4
argument_list|(
name|pio
operator|->
name|res
argument_list|,
name|res_offset
argument_list|)
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"unsupported width: %u"
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|bhndb_pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|bhndb_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|bhndb_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bhndb_pci_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bhndb_pci_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bhndb_pci_detach
argument_list|)
block|,
comment|/* BHND interface */
name|DEVMETHOD
argument_list|(
name|bhnd_bus_pwrctl_get_clksrc
argument_list|,
name|bhndb_pci_pwrctl_get_clksrc
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_pwrctl_gate_clock
argument_list|,
name|bhndb_pci_pwrctl_gate_clock
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_pwrctl_ungate_clock
argument_list|,
name|bhndb_pci_pwrctl_ungate_clock
argument_list|)
block|,
comment|/* BHNDB interface */
name|DEVMETHOD
argument_list|(
name|bhndb_set_window_addr
argument_list|,
name|bhndb_pci_set_window_addr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhndb_populate_board_info
argument_list|,
name|bhndb_pci_populate_board_info
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhndb_map_intr_isrc
argument_list|,
name|bhndb_pci_map_intr_isrc
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhndb_route_interrupts
argument_list|,
name|bhndb_pci_route_interrupts
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_1
argument_list|(
name|bhndb
argument_list|,
name|bhndb_pci_driver
argument_list|,
name|bhndb_pci_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bhndb_pci_softc
argument_list|)
argument_list|,
name|bhndb_driver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|bhndb_pci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bhndb_pci
argument_list|,
name|bhnd_pci_hostb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bhndb_pci
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bhndb_pci
argument_list|,
name|bhndb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bhndb_pci
argument_list|,
name|bhnd
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

