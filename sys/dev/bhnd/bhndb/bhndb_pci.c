begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Landon Fuller<landon@landonf.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * PCI-specific implementation for the BHNDB bridge driver.  *   * Provides support for bridging from a PCI parent bus to a BHND-compatible  * bus (e.g. bcma or siba) via a Broadcom PCI core configured in end-point  * mode.  *   * This driver handles all initial generic host-level PCI interactions with a  * PCI/PCIe bridge core operating in endpoint mode. Once the bridged bhnd(4)  * bus has been enumerated, this driver works in tandem with a core-specific  * bhnd_pci_hostb driver to manage the PCI core.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhnd.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/pci/bhnd_pcireg.h>
end_include

begin_include
include|#
directive|include
file|"bhndb_pcireg.h"
end_include

begin_include
include|#
directive|include
file|"bhndb_pcivar.h"
end_include

begin_include
include|#
directive|include
file|"bhndb_private.h"
end_include

begin_function_decl
specifier|static
name|int
name|bhndb_pci_init_msi
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_pci_add_children
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_enable_pci_clocks
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_disable_pci_clocks
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_pci_compat_setregwin
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
parameter_list|,
name|bhnd_addr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_pci_fast_setregwin
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
parameter_list|,
name|bhnd_addr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bhndb_init_sromless_pci_config
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bus_addr_t
name|bhndb_pci_sprom_addr
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bus_size_t
name|bhndb_pci_sprom_size
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|BHNDB_PCI_MSI_COUNT
value|1
end_define

begin_comment
comment|/**   * Default bhndb_pci implementation of device_probe().  *   * Verifies that the parent is a PCI/PCIe device.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|parent
decl_stmt|;
name|devclass_t
name|parent_bus
decl_stmt|;
name|devclass_t
name|pci
decl_stmt|;
comment|/* Our parent must be a PCI/PCIe device. */
name|pci
operator|=
name|devclass_find
argument_list|(
literal|"pci"
argument_list|)
expr_stmt|;
name|parent
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|parent_bus
operator|=
name|device_get_devclass
argument_list|(
name|device_get_parent
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent_bus
operator|!=
name|pci
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PCI-BHND bridge"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Configure MSI interrupts */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_init_msi
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Is MSI available? */
if|if
condition|(
name|pci_msi_count
argument_list|(
name|sc
operator|->
name|parent
argument_list|)
operator|<
name|BHNDB_PCI_MSI_COUNT
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Allocate expected message count */
name|sc
operator|->
name|intr
operator|.
name|msi_count
operator|=
name|BHNDB_PCI_MSI_COUNT
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pci_alloc_msi
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
operator|&
name|sc
operator|->
name|intr
operator|.
name|msi_count
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate MSI interrupts: "
literal|"%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|intr
operator|.
name|msi_count
operator|<
name|BHNDB_PCI_MSI_COUNT
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* MSI uses resource IDs starting at 1 */
name|sc
operator|->
name|intr
operator|.
name|intr_rid
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|reg
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|parent
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|set_regwin
operator|=
name|bhndb_pci_compat_setregwin
expr_stmt|;
comment|/* Enable PCI bus mastering */
name|pci_enable_busmaster
argument_list|(
name|sc
operator|->
name|parent
argument_list|)
expr_stmt|;
comment|/* Set up interrupt handling */
if|if
condition|(
name|bhndb_pci_init_msi
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Using MSI interrupts on %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Using INTx interrupts on %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intr
operator|.
name|intr_rid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Determine our bridge device class */
name|sc
operator|->
name|pci_devclass
operator|=
name|BHND_DEVCLASS_PCI
expr_stmt|;
if|if
condition|(
name|pci_find_cap
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|pci_devclass
operator|=
name|BHND_DEVCLASS_PCIE
expr_stmt|;
else|else
name|sc
operator|->
name|pci_devclass
operator|=
name|BHND_DEVCLASS_PCI
expr_stmt|;
comment|/* Enable clocks (if required by this hardware) */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_enable_pci_clocks
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Perform bridge attach, fully initializing the bridge 	 * configuration. */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_attach
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|pci_devclass
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
comment|/* If supported, switch to faster regwin handling */
if|if
condition|(
name|sc
operator|->
name|bhndb
operator|.
name|chipid
operator|.
name|chip_type
operator|!=
name|BHND_CHIPTYPE_SIBA
condition|)
block|{
name|atomic_store_rel_ptr
argument_list|(
operator|(
specifier|volatile
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|set_regwin
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|&
name|bhndb_pci_fast_setregwin
argument_list|)
expr_stmt|;
block|}
comment|/* Enable PCI bus mastering */
name|pci_enable_busmaster
argument_list|(
name|sc
operator|->
name|parent
argument_list|)
expr_stmt|;
comment|/* Fix-up power on defaults for SROM-less devices. */
name|bhndb_init_sromless_pci_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Add any additional child devices */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_pci_add_children
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Probe and attach our children */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|cleanup
label|:
name|device_delete_children
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bhndb_disable_pci_clocks
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr
operator|.
name|msi_count
operator|>
literal|0
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_disable_busmaster
argument_list|(
name|sc
operator|->
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Attempt to detach our children */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Perform generic bridge detach */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_generic_detach
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Disable clocks (if required by this hardware) */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_disable_pci_clocks
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Release MSI interrupts */
if|if
condition|(
name|sc
operator|->
name|intr
operator|.
name|msi_count
operator|>
literal|0
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Disable PCI bus mastering */
name|pci_disable_busmaster
argument_list|(
name|sc
operator|->
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_add_children
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bus_size_t
name|nv_sz
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/** 	 * If SPROM is mapped directly into BAR0, add child NVRAM 	 * device. 	 */
name|nv_sz
operator|=
name|bhndb_pci_sprom_size
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nv_sz
operator|>
literal|0
condition|)
block|{
name|struct
name|bhndb_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|device_t
name|child
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"found SPROM (%ju bytes)\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|nv_sz
argument_list|)
expr_stmt|;
block|}
comment|/* Add sprom device, ordered early enough to be available 		 * before the bridged bhnd(4) bus is attached. */
name|child
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|BHND_PROBE_ROOT
operator|+
name|BHND_PROBE_ORDER_EARLY
argument_list|,
literal|"bhnd_nvram"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to add sprom device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Initialize device address space and resource covering the 		 * BAR0 SPROM shadow. */
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|addrspace
operator|=
name|BHNDB_ADDRSPACE_NATIVE
expr_stmt|;
name|error
operator|=
name|bus_set_resource
argument_list|(
name|child
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|bhndb_pci_sprom_addr
argument_list|(
name|sc
argument_list|)
argument_list|,
name|nv_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to register sprom resources\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|bhndb_pci_sprom_regwin
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bhndb_resources
modifier|*
name|bres
decl_stmt|;
specifier|const
name|struct
name|bhndb_hwcfg
modifier|*
name|cfg
decl_stmt|;
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|sprom_win
decl_stmt|;
name|bres
operator|=
name|sc
operator|->
name|bhndb
operator|.
name|bus_res
expr_stmt|;
name|cfg
operator|=
name|bres
operator|->
name|cfg
expr_stmt|;
name|sprom_win
operator|=
name|bhndb_regwin_find_type
argument_list|(
name|cfg
operator|->
name|register_windows
argument_list|,
name|BHNDB_REGWIN_T_SPROM
argument_list|,
name|BHNDB_PCI_V0_BAR0_SPROM_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|sprom_win
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bus_addr_t
name|bhndb_pci_sprom_addr
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|sprom_win
decl_stmt|;
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
comment|/* Fetch the SPROM register window */
name|sprom_win
operator|=
name|bhndb_pci_sprom_regwin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sprom_win
operator|!=
name|NULL
argument_list|,
operator|(
literal|"requested sprom address on PCI_V2+"
operator|)
argument_list|)
expr_stmt|;
comment|/* Fetch the associated resource */
name|r
operator|=
name|bhndb_find_regwin_resource
argument_list|(
name|sc
operator|->
name|bhndb
operator|.
name|bus_res
argument_list|,
name|sprom_win
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|r
operator|!=
name|NULL
argument_list|,
operator|(
literal|"missing resource for sprom window\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rman_get_start
argument_list|(
name|r
argument_list|)
operator|+
name|sprom_win
operator|->
name|win_offset
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bus_size_t
name|bhndb_pci_sprom_size
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|sprom_win
decl_stmt|;
name|uint32_t
name|sctl
decl_stmt|;
name|bus_size_t
name|sprom_sz
decl_stmt|;
name|sprom_win
operator|=
name|bhndb_pci_sprom_regwin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* PCI_V2 and later devices map SPROM/OTP via ChipCommon */
if|if
condition|(
name|sprom_win
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Determine SPROM size */
name|sctl
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|BHNDB_PCI_SPROM_CONTROL
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctl
operator|&
name|BHNDB_PCI_SPROM_BLANK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|sctl
operator|&
name|BHNDB_PCI_SPROM_SZ_MASK
condition|)
block|{
case|case
name|BHNDB_PCI_SPROM_SZ_1KB
case|:
name|sprom_sz
operator|=
operator|(
literal|1
operator|*
literal|1024
operator|)
expr_stmt|;
break|break;
case|case
name|BHNDB_PCI_SPROM_SZ_4KB
case|:
name|sprom_sz
operator|=
operator|(
literal|4
operator|*
literal|1024
operator|)
expr_stmt|;
break|break;
case|case
name|BHNDB_PCI_SPROM_SZ_16KB
case|:
name|sprom_sz
operator|=
operator|(
literal|16
operator|*
literal|1024
operator|)
expr_stmt|;
break|break;
case|case
name|BHNDB_PCI_SPROM_SZ_RESERVED
case|:
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"invalid PCI sprom size 0x%x\n"
argument_list|,
name|sctl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sprom_sz
operator|>
name|sprom_win
operator|->
name|win_size
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"PCI sprom size (0x%x) overruns defined register window\n"
argument_list|,
name|sctl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|sprom_sz
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * On devices without a SROM, the PCI(e) cores will be initialized with  * their Power-on-Reset defaults; this can leave two of the BAR0 PCI windows  * mapped to the wrong core.  *   * This function updates the SROM shadow to point the BAR0 windows at the  * current PCI core.  *   * Applies to all PCI/PCIe revisions.  */
end_comment

begin_function
specifier|static
name|void
name|bhndb_init_sromless_pci_config
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bhndb_resources
modifier|*
name|bres
decl_stmt|;
specifier|const
name|struct
name|bhndb_hwcfg
modifier|*
name|cfg
decl_stmt|;
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|win
decl_stmt|;
name|struct
name|bhnd_core_info
name|hostb_core
decl_stmt|;
name|struct
name|resource
modifier|*
name|core_regs
decl_stmt|;
name|bus_size_t
name|srom_offset
decl_stmt|;
name|u_int
name|pci_cidx
decl_stmt|,
name|sprom_cidx
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bres
operator|=
name|sc
operator|->
name|bhndb
operator|.
name|bus_res
expr_stmt|;
name|cfg
operator|=
name|bres
operator|->
name|cfg
expr_stmt|;
comment|/* Find our hostb core */
name|error
operator|=
name|BHNDB_GET_HOSTB_CORE
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|bhndb
operator|.
name|bus_dev
argument_list|,
operator|&
name|hostb_core
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"no host bridge device found\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hostb_core
operator|.
name|vendor
operator|!=
name|BHND_MFGID_BCM
condition|)
return|return;
switch|switch
condition|(
name|hostb_core
operator|.
name|device
condition|)
block|{
case|case
name|BHND_COREID_PCI
case|:
name|srom_offset
operator|=
name|BHND_PCI_SRSH_PI_OFFSET
expr_stmt|;
break|break;
case|case
name|BHND_COREID_PCIE
case|:
name|srom_offset
operator|=
name|BHND_PCIE_SRSH_PI_OFFSET
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unsupported PCI host bridge device\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Locate the static register window mapping the PCI core */
name|win
operator|=
name|bhndb_regwin_find_core
argument_list|(
name|cfg
operator|->
name|register_windows
argument_list|,
name|sc
operator|->
name|pci_devclass
argument_list|,
literal|0
argument_list|,
name|BHND_PORT_DEVICE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"missing PCI core register window\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Fetch the resource containing the register window */
name|core_regs
operator|=
name|bhndb_find_regwin_resource
argument_list|(
name|bres
argument_list|,
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_regs
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"missing PCI core register resource\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Fetch the SPROM's configured core index */
name|val
operator|=
name|bus_read_2
argument_list|(
name|core_regs
argument_list|,
name|win
operator|->
name|win_offset
operator|+
name|srom_offset
argument_list|)
expr_stmt|;
name|sprom_cidx
operator|=
operator|(
name|val
operator|&
name|BHND_PCI_SRSH_PI_MASK
operator|)
operator|>>
name|BHND_PCI_SRSH_PI_SHIFT
expr_stmt|;
comment|/* If it doesn't match host bridge's core index, update the index 	 * value */
name|pci_cidx
operator|=
name|hostb_core
operator|.
name|core_idx
expr_stmt|;
if|if
condition|(
name|sprom_cidx
operator|!=
name|pci_cidx
condition|)
block|{
name|val
operator|&=
operator|~
name|BHND_PCI_SRSH_PI_MASK
expr_stmt|;
name|val
operator||=
operator|(
name|pci_cidx
operator|<<
name|BHND_PCI_SRSH_PI_SHIFT
operator|)
expr_stmt|;
name|bus_write_2
argument_list|(
name|core_regs
argument_list|,
name|win
operator|->
name|win_offset
operator|+
name|srom_offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Enable clocks (if supported by this hardware) */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_enable_pci_clocks
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Perform resume */
return|return
operator|(
name|bhndb_generic_resume
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Disable clocks (if supported by this hardware) */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_disable_pci_clocks
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Perform suspend */
return|return
operator|(
name|bhndb_generic_suspend
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_set_window_addr
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|sc
operator|->
name|set_regwin
argument_list|(
name|sc
argument_list|,
name|rw
argument_list|,
name|addr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * A siba(4) and bcma(4)-compatible bhndb_set_window_addr implementation.  *   * On siba(4) devices, it's possible that writing a PCI window register may  * not succeed; it's necessary to immediately read the configuration register  * and retry if not set to the desired value.  *   * This is not necessary on bcma(4) devices, but other than the overhead of  * validating the register, there's no harm in performing the verification.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_compat_setregwin
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|rw
operator|->
name|win_type
operator|!=
name|BHNDB_REGWIN_T_DYN
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|reg
operator|=
name|rw
operator|->
name|d
operator|.
name|dyn
operator|.
name|cfg_offset
expr_stmt|;
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BHNDB_PCI_BARCTRL_WRITE_RETRY
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_pci_fast_setregwin
argument_list|(
name|sc
argument_list|,
name|rw
argument_list|,
name|addr
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|pci_read_config
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
operator|==
name|addr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/* Unable to set window */
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * A bcma(4)-only bhndb_set_window_addr implementation.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_fast_setregwin
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|)
block|{
comment|/* The PCI bridge core only supports 32-bit addressing, regardless 	 * of the bus' support for 64-bit addressing */
if|if
condition|(
name|addr
operator|>
name|UINT32_MAX
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
switch|switch
condition|(
name|rw
operator|->
name|win_type
condition|)
block|{
case|case
name|BHNDB_REGWIN_T_DYN
case|:
comment|/* Addresses must be page aligned */
if|if
condition|(
name|addr
operator|%
name|rw
operator|->
name|win_size
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|rw
operator|->
name|d
operator|.
name|dyn
operator|.
name|cfg_offset
argument_list|,
name|addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_populate_board_info
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|bhnd_board_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/*  	 * On a subset of Apple BCM4360 modules, always prefer the 	 * PCI subdevice to the SPROM-supplied boardtype. 	 *  	 * TODO: 	 *  	 * Broadcom's own drivers implement this override, and then later use 	 * the remapped BCM4360 board type to determine the required 	 * board-specific workarounds. 	 *  	 * Without access to this hardware, it's unclear why this mapping 	 * is done, and we must do the same. If we can survey the hardware 	 * in question, it may be possible to replace this behavior with 	 * explicit references to the SPROM-supplied boardtype(s) in our 	 * quirk definitions. 	 */
if|if
condition|(
name|pci_get_subvendor
argument_list|(
name|sc
operator|->
name|parent
argument_list|)
operator|==
name|PCI_VENDOR_APPLE
condition|)
block|{
switch|switch
condition|(
name|info
operator|->
name|board_type
condition|)
block|{
case|case
name|BHND_BOARD_BCM94360X29C
case|:
case|case
name|BHND_BOARD_BCM94360X29CP2
case|:
case|case
name|BHND_BOARD_BCM94360X51
case|:
case|case
name|BHND_BOARD_BCM94360X51P2
case|:
name|info
operator|->
name|board_type
operator|=
literal|0
expr_stmt|;
comment|/* allow override below */
break|break;
default|default:
break|break;
block|}
block|}
comment|/* If NVRAM did not supply vendor/type info, provide the PCI 	 * subvendor/subdevice values. */
if|if
condition|(
name|info
operator|->
name|board_vendor
operator|==
literal|0
condition|)
name|info
operator|->
name|board_vendor
operator|=
name|pci_get_subvendor
argument_list|(
name|sc
operator|->
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|board_type
operator|==
literal|0
condition|)
name|info
operator|->
name|board_type
operator|=
name|pci_get_subdevice
argument_list|(
name|sc
operator|->
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Enable externally managed clocks, if required.  *   * Some PCI chipsets (BCM4306, possibly others) chips do not support  * the idle low-power clock. Clocking must be bootstrapped at  * attach/resume by directly adjusting GPIO registers exposed in the  * PCI config space, and correspondingly, explicitly shutdown at  * detach/suspend.  *   * @param sc Bridge driver state.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_enable_pci_clocks
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|gpio_in
decl_stmt|,
name|gpio_out
decl_stmt|,
name|gpio_en
decl_stmt|;
name|uint32_t
name|gpio_flags
decl_stmt|;
name|uint16_t
name|pci_status
decl_stmt|;
comment|/* Only supported and required on PCI devices */
if|if
condition|(
name|sc
operator|->
name|pci_devclass
operator|!=
name|BHND_DEVCLASS_PCI
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Read state of XTAL pin */
name|gpio_in
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|BHNDB_PCI_GPIO_IN
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|gpio_in
operator|&
name|BHNDB_PCI_GPIO_XTAL_ON
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* already enabled */
comment|/* Fetch current config */
name|gpio_out
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gpio_en
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|BHNDB_PCI_GPIO_OUTEN
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Set PLL_OFF/XTAL_ON pins to HIGH and enable both pins */
name|gpio_flags
operator|=
operator|(
name|BHNDB_PCI_GPIO_PLL_OFF
operator||
name|BHNDB_PCI_GPIO_XTAL_ON
operator|)
expr_stmt|;
name|gpio_out
operator||=
name|gpio_flags
expr_stmt|;
name|gpio_en
operator||=
name|gpio_flags
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
name|gpio_out
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|BHNDB_PCI_GPIO_OUTEN
argument_list|,
name|gpio_en
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Reset PLL_OFF */
name|gpio_out
operator|&=
operator|~
name|BHNDB_PCI_GPIO_PLL_OFF
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
name|gpio_out
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* Clear any PCI 'sent target-abort' flag. */
name|pci_status
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_status
operator|&=
operator|~
name|PCIM_STATUS_STABORT
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|PCIR_STATUS
argument_list|,
name|pci_status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Disable externally managed clocks, if required.  *   * @param sc Bridge driver state.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_disable_pci_clocks
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|gpio_out
decl_stmt|,
name|gpio_en
decl_stmt|;
comment|/* Only supported and required on PCI devices */
if|if
condition|(
name|sc
operator|->
name|pci_devclass
operator|!=
name|BHND_DEVCLASS_PCI
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Fetch current config */
name|gpio_out
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gpio_en
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|BHNDB_PCI_GPIO_OUTEN
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Set PLL_OFF to HIGH, XTAL_ON to LOW. */
name|gpio_out
operator|&=
operator|~
name|BHNDB_PCI_GPIO_XTAL_ON
expr_stmt|;
name|gpio_out
operator||=
name|BHNDB_PCI_GPIO_PLL_OFF
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
name|gpio_out
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Enable both output pins */
name|gpio_en
operator||=
operator|(
name|BHNDB_PCI_GPIO_PLL_OFF
operator||
name|BHNDB_PCI_GPIO_XTAL_ON
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|BHNDB_PCI_GPIO_OUTEN
argument_list|,
name|gpio_en
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bhnd_clksrc
name|bhndb_pci_pwrctl_get_clksrc
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|bhnd_clock
name|clock
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|gpio_out
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Only supported on PCI devices */
if|if
condition|(
name|sc
operator|->
name|pci_devclass
operator|!=
name|BHND_DEVCLASS_PCI
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Only ILP is supported */
if|if
condition|(
name|clock
operator|!=
name|BHND_CLOCK_ILP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|gpio_out
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|gpio_out
operator|&
name|BHNDB_PCI_GPIO_SCS
condition|)
return|return
operator|(
name|BHND_CLKSRC_PCI
operator|)
return|;
else|else
return|return
operator|(
name|BHND_CLKSRC_XTAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_pwrctl_gate_clock
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|bhnd_clock
name|clock
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Only supported on PCI devices */
if|if
condition|(
name|sc
operator|->
name|pci_devclass
operator|!=
name|BHND_DEVCLASS_PCI
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Only HT is supported */
if|if
condition|(
name|clock
operator|!=
name|BHND_CLOCK_HT
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|bhndb_disable_pci_clocks
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_pwrctl_ungate_clock
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|bhnd_clock
name|clock
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Only supported on PCI devices */
if|if
condition|(
name|sc
operator|->
name|pci_devclass
operator|!=
name|BHND_DEVCLASS_PCI
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Only HT is supported */
if|if
condition|(
name|clock
operator|!=
name|BHND_CLOCK_HT
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|bhndb_enable_pci_clocks
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_assign_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|rid
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|rman_res_t
name|start
decl_stmt|,
name|count
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Is the rid valid? */
if|if
condition|(
name|rid
operator|>=
name|bhnd_get_intr_count
argument_list|(
name|child
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Fetch our common PCI interrupt's start/count. */
name|error
operator|=
name|bus_get_resource
argument_list|(
name|sc
operator|->
name|parent
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|intr
operator|.
name|intr_rid
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Add to child's resource list */
return|return
operator|(
name|bus_set_resource
argument_list|(
name|child
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|count
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|bhndb_pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|bhndb_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|bhndb_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bhndb_pci_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bhndb_pci_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bhndb_pci_detach
argument_list|)
block|,
comment|/* BHND interface */
name|DEVMETHOD
argument_list|(
name|bhnd_bus_assign_intr
argument_list|,
name|bhndb_pci_assign_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_pwrctl_get_clksrc
argument_list|,
name|bhndb_pci_pwrctl_get_clksrc
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_pwrctl_gate_clock
argument_list|,
name|bhndb_pci_pwrctl_gate_clock
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_pwrctl_ungate_clock
argument_list|,
name|bhndb_pci_pwrctl_ungate_clock
argument_list|)
block|,
comment|/* BHNDB interface */
name|DEVMETHOD
argument_list|(
name|bhndb_set_window_addr
argument_list|,
name|bhndb_pci_set_window_addr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhndb_populate_board_info
argument_list|,
name|bhndb_pci_populate_board_info
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_1
argument_list|(
name|bhndb
argument_list|,
name|bhndb_pci_driver
argument_list|,
name|bhndb_pci_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bhndb_pci_softc
argument_list|)
argument_list|,
name|bhndb_driver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|bhndb_pci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bhndb_pci
argument_list|,
name|bhnd_pci_hostb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bhndb_pci
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bhndb_pci
argument_list|,
name|bhndb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bhndb_pci
argument_list|,
name|bhnd
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

