begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Landon Fuller<landon@landonf.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * PCI-specific implementation for the BHNDB bridge driver.  *   * Provides support for bridging from a PCI parent bus to a BHND-compatible  * bus (e.g. bcma or siba) via a Broadcom PCI core configured in end-point  * mode.  *   * This driver handles all host-level PCI interactions with a PCI/PCIe bridge  * core operating in endpoint mode. On the bridged bhnd bus, the PCI core  * device will be managed by a bhnd_pci_hostb driver.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhnd.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/pci/bhnd_pcireg.h>
end_include

begin_include
include|#
directive|include
file|"bhndb_pcireg.h"
end_include

begin_include
include|#
directive|include
file|"bhndb_pcivar.h"
end_include

begin_include
include|#
directive|include
file|"bhndb_private.h"
end_include

begin_function_decl
specifier|static
name|int
name|bhndb_enable_pci_clocks
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_disable_pci_clocks
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_pci_compat_setregwin
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
parameter_list|,
name|bhnd_addr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_pci_fast_setregwin
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
parameter_list|,
name|bhnd_addr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bhndb_init_sromless_pci_config
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**   * Default bhndb_pci implementation of device_probe().  *   * Verifies that the parent is a PCI/PCIe device.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|parent
decl_stmt|;
name|devclass_t
name|parent_bus
decl_stmt|;
name|devclass_t
name|pci
decl_stmt|;
comment|/* Our parent must be a PCI/PCIe device. */
name|pci
operator|=
name|devclass_find
argument_list|(
literal|"pci"
argument_list|)
expr_stmt|;
name|parent
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|parent_bus
operator|=
name|device_get_devclass
argument_list|(
name|device_get_parent
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent_bus
operator|!=
name|pci
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PCI-BHND bridge"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|reg
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/* Enable PCI bus mastering */
name|pci_enable_busmaster
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine our bridge device class */
name|sc
operator|->
name|pci_devclass
operator|=
name|BHND_DEVCLASS_PCI
expr_stmt|;
if|if
condition|(
name|pci_find_cap
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|pci_devclass
operator|=
name|BHND_DEVCLASS_PCIE
expr_stmt|;
comment|/* Enable clocks (if supported by this hardware) */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_enable_pci_clocks
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Use siba(4)-compatible regwin handling until we know 	 * what kind of bus is attached */
name|sc
operator|->
name|set_regwin
operator|=
name|bhndb_pci_compat_setregwin
expr_stmt|;
comment|/* Perform full bridge attach. This should call back into our 	 * bhndb_pci_init_full_config() implementation once the bridged 	 * bhnd(4) bus has been enumerated, but before any devices have been 	 * probed or attached. */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_attach
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|pci_devclass
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* If supported, switch to the faster regwin handling */
if|if
condition|(
name|sc
operator|->
name|bhndb
operator|.
name|chipid
operator|.
name|chip_type
operator|!=
name|BHND_CHIPTYPE_SIBA
condition|)
block|{
name|atomic_store_rel_ptr
argument_list|(
operator|(
specifier|volatile
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|set_regwin
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|&
name|bhndb_pci_fast_setregwin
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_init_full_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
specifier|const
name|struct
name|bhndb_hw_priority
modifier|*
name|hw_prio_table
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Let our parent perform standard initialization first */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_generic_init_full_config
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|hw_prio_table
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Fix-up power on defaults for SROM-less devices. */
name|bhndb_init_sromless_pci_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * On devices without a SROM, the PCI(e) cores will be initialized with  * their Power-on-Reset defaults; this can leave two of the BAR0 PCI windows  * mapped to the wrong core.  *   * This function updates the SROM shadow to point the BAR0 windows at the  * current PCI core.  *   * Applies to all PCI/PCIe revisions.  */
end_comment

begin_function
specifier|static
name|void
name|bhndb_init_sromless_pci_config
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bhndb_resources
modifier|*
name|bres
decl_stmt|;
specifier|const
name|struct
name|bhndb_hwcfg
modifier|*
name|cfg
decl_stmt|;
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|win
decl_stmt|;
name|struct
name|resource
modifier|*
name|core_regs
decl_stmt|;
name|bus_size_t
name|srom_offset
decl_stmt|;
name|u_int
name|pci_cidx
decl_stmt|,
name|sprom_cidx
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|bres
operator|=
name|sc
operator|->
name|bhndb
operator|.
name|bus_res
expr_stmt|;
name|cfg
operator|=
name|bres
operator|->
name|cfg
expr_stmt|;
if|if
condition|(
name|bhnd_get_vendor
argument_list|(
name|sc
operator|->
name|bhndb
operator|.
name|hostb_dev
argument_list|)
operator|!=
name|BHND_MFGID_BCM
condition|)
return|return;
switch|switch
condition|(
name|bhnd_get_device
argument_list|(
name|sc
operator|->
name|bhndb
operator|.
name|hostb_dev
argument_list|)
condition|)
block|{
case|case
name|BHND_COREID_PCI
case|:
name|srom_offset
operator|=
name|BHND_PCI_SRSH_PI_OFFSET
expr_stmt|;
break|break;
case|case
name|BHND_COREID_PCIE
case|:
name|srom_offset
operator|=
name|BHND_PCIE_SRSH_PI_OFFSET
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unsupported PCI host bridge device\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Locate the static register window mapping the PCI core */
name|win
operator|=
name|bhndb_regwin_find_core
argument_list|(
name|cfg
operator|->
name|register_windows
argument_list|,
name|sc
operator|->
name|pci_devclass
argument_list|,
literal|0
argument_list|,
name|BHND_PORT_DEVICE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"missing PCI core register window\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Fetch the resource containing the register window */
name|core_regs
operator|=
name|bhndb_find_regwin_resource
argument_list|(
name|bres
argument_list|,
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_regs
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"missing PCI core register resource\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Fetch the SPROM's configured core index */
name|val
operator|=
name|bus_read_2
argument_list|(
name|core_regs
argument_list|,
name|win
operator|->
name|win_offset
operator|+
name|srom_offset
argument_list|)
expr_stmt|;
name|sprom_cidx
operator|=
operator|(
name|val
operator|&
name|BHND_PCI_SRSH_PI_MASK
operator|)
operator|>>
name|BHND_PCI_SRSH_PI_SHIFT
expr_stmt|;
comment|/* If it doesn't match host bridge's core index, update the index 	 * value */
name|pci_cidx
operator|=
name|bhnd_get_core_index
argument_list|(
name|sc
operator|->
name|bhndb
operator|.
name|hostb_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sprom_cidx
operator|!=
name|pci_cidx
condition|)
block|{
name|val
operator|&=
operator|~
name|BHND_PCI_SRSH_PI_MASK
expr_stmt|;
name|val
operator||=
operator|(
name|pci_cidx
operator|<<
name|BHND_PCI_SRSH_PI_SHIFT
operator|)
expr_stmt|;
name|bus_write_2
argument_list|(
name|core_regs
argument_list|,
name|win
operator|->
name|win_offset
operator|+
name|srom_offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Enable clocks (if supported by this hardware) */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_enable_pci_clocks
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Perform resume */
return|return
operator|(
name|bhndb_generic_resume
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Disable clocks (if supported by this hardware) */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_disable_pci_clocks
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Perform suspend */
return|return
operator|(
name|bhndb_generic_suspend
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Disable clocks (if supported by this hardware) */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_disable_pci_clocks
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Perform detach */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_generic_detach
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Disable PCI bus mastering */
name|pci_disable_busmaster
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_pci_set_window_addr
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|)
block|{
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|sc
operator|->
name|set_regwin
argument_list|(
name|sc
argument_list|,
name|rw
argument_list|,
name|addr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * A siba(4) and bcma(4)-compatible bhndb_set_window_addr implementation.  *   * On siba(4) devices, it's possible that writing a PCI window register may  * not succeed; it's necessary to immediately read the configuration register  * and retry if not set to the desired value.  *   * This is not necessary on bcma(4) devices, but other than the overhead of  * validating the register, there's no harm in performing the verification.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_compat_setregwin
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|)
block|{
name|device_t
name|parent
decl_stmt|;
name|int
name|error
decl_stmt|;
name|parent
operator|=
name|sc
operator|->
name|bhndb
operator|.
name|parent_dev
expr_stmt|;
if|if
condition|(
name|rw
operator|->
name|win_type
operator|!=
name|BHNDB_REGWIN_T_DYN
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BHNDB_PCI_BARCTRL_WRITE_RETRY
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_pci_fast_setregwin
argument_list|(
name|sc
argument_list|,
name|rw
argument_list|,
name|addr
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|pci_read_config
argument_list|(
name|parent
argument_list|,
name|rw
operator|->
name|dyn
operator|.
name|cfg_offset
argument_list|,
literal|4
argument_list|)
operator|==
name|addr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/* Unable to set window */
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * A bcma(4)-only bhndb_set_window_addr implementation.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_pci_fast_setregwin
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|)
block|{
name|device_t
name|parent
init|=
name|sc
operator|->
name|bhndb
operator|.
name|parent_dev
decl_stmt|;
comment|/* The PCI bridge core only supports 32-bit addressing, regardless 	 * of the bus' support for 64-bit addressing */
if|if
condition|(
name|addr
operator|>
name|UINT32_MAX
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
switch|switch
condition|(
name|rw
operator|->
name|win_type
condition|)
block|{
case|case
name|BHNDB_REGWIN_T_DYN
case|:
comment|/* Addresses must be page aligned */
if|if
condition|(
name|addr
operator|%
name|rw
operator|->
name|win_size
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pci_write_config
argument_list|(
name|parent
argument_list|,
name|rw
operator|->
name|dyn
operator|.
name|cfg_offset
argument_list|,
name|addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Enable externally managed clocks, if required.  *   * Some PCI chipsets (BCM4306, possibly others) chips do not support  * the idle low-power clock. Clocking must be bootstrapped at  * attach/resume by directly adjusting GPIO registers exposed in the  * PCI config space, and correspondingly, explicitly shutdown at  * detach/suspend.  *   * @param sc Bridge driver state.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_enable_pci_clocks
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|pci_parent
decl_stmt|;
name|uint32_t
name|gpio_in
decl_stmt|,
name|gpio_out
decl_stmt|,
name|gpio_en
decl_stmt|;
name|uint32_t
name|gpio_flags
decl_stmt|;
name|uint16_t
name|pci_status
decl_stmt|;
comment|/* Only supported and required on PCI devices */
if|if
condition|(
name|sc
operator|->
name|pci_devclass
operator|!=
name|BHND_DEVCLASS_PCI
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pci_parent
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|/* Read state of XTAL pin */
name|gpio_in
operator|=
name|pci_read_config
argument_list|(
name|pci_parent
argument_list|,
name|BHNDB_PCI_GPIO_IN
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|gpio_in
operator|&
name|BHNDB_PCI_GPIO_XTAL_ON
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* already enabled */
comment|/* Fetch current config */
name|gpio_out
operator|=
name|pci_read_config
argument_list|(
name|pci_parent
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gpio_en
operator|=
name|pci_read_config
argument_list|(
name|pci_parent
argument_list|,
name|BHNDB_PCI_GPIO_OUTEN
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Set PLL_OFF/XTAL_ON pins to HIGH and enable both pins */
name|gpio_flags
operator|=
operator|(
name|BHNDB_PCI_GPIO_PLL_OFF
operator||
name|BHNDB_PCI_GPIO_XTAL_ON
operator|)
expr_stmt|;
name|gpio_out
operator||=
name|gpio_flags
expr_stmt|;
name|gpio_en
operator||=
name|gpio_flags
expr_stmt|;
name|pci_write_config
argument_list|(
name|pci_parent
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
name|gpio_out
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|pci_parent
argument_list|,
name|BHNDB_PCI_GPIO_OUTEN
argument_list|,
name|gpio_en
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Reset PLL_OFF */
name|gpio_out
operator|&=
operator|~
name|BHNDB_PCI_GPIO_PLL_OFF
expr_stmt|;
name|pci_write_config
argument_list|(
name|pci_parent
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
name|gpio_out
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* Clear any PCI 'sent target-abort' flag. */
name|pci_status
operator|=
name|pci_read_config
argument_list|(
name|pci_parent
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_status
operator|&=
operator|~
name|PCIM_STATUS_STABORT
expr_stmt|;
name|pci_write_config
argument_list|(
name|pci_parent
argument_list|,
name|PCIR_STATUS
argument_list|,
name|pci_status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Disable externally managed clocks, if required.  *   * @param sc Bridge driver state.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_disable_pci_clocks
parameter_list|(
name|struct
name|bhndb_pci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|parent_dev
decl_stmt|;
name|uint32_t
name|gpio_out
decl_stmt|,
name|gpio_en
decl_stmt|;
comment|/* Only supported and required on PCI devices */
if|if
condition|(
name|sc
operator|->
name|pci_devclass
operator|!=
name|BHND_DEVCLASS_PCI
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|parent_dev
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|// TODO: Check board flags for BFL2_XTALBUFOUTEN?
comment|// TODO: Check PCI core revision?
comment|// TODO: Switch to 'slow' clock?
comment|/* Fetch current config */
name|gpio_out
operator|=
name|pci_read_config
argument_list|(
name|parent_dev
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gpio_en
operator|=
name|pci_read_config
argument_list|(
name|parent_dev
argument_list|,
name|BHNDB_PCI_GPIO_OUTEN
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Set PLL_OFF to HIGH, XTAL_ON to LOW. */
name|gpio_out
operator|&=
operator|~
name|BHNDB_PCI_GPIO_XTAL_ON
expr_stmt|;
name|gpio_out
operator||=
name|BHNDB_PCI_GPIO_PLL_OFF
expr_stmt|;
name|pci_write_config
argument_list|(
name|parent_dev
argument_list|,
name|BHNDB_PCI_GPIO_OUT
argument_list|,
name|gpio_out
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Enable both output pins */
name|gpio_en
operator||=
operator|(
name|BHNDB_PCI_GPIO_PLL_OFF
operator||
name|BHNDB_PCI_GPIO_XTAL_ON
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|parent_dev
argument_list|,
name|BHNDB_PCI_GPIO_OUTEN
argument_list|,
name|gpio_en
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|bhndb_pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|bhndb_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|bhndb_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bhndb_pci_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bhndb_pci_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bhndb_pci_detach
argument_list|)
block|,
comment|/* BHNDB interface */
name|DEVMETHOD
argument_list|(
name|bhndb_init_full_config
argument_list|,
name|bhndb_pci_init_full_config
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhndb_set_window_addr
argument_list|,
name|bhndb_pci_set_window_addr
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_1
argument_list|(
name|bhndb
argument_list|,
name|bhndb_pci_driver
argument_list|,
name|bhndb_pci_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bhndb_pci_softc
argument_list|)
argument_list|,
name|bhndb_driver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|bhndb_pci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bhndb_pci
argument_list|,
name|bhnd_pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bhndb_pci
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bhndb_pci
argument_list|,
name|bhndb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

