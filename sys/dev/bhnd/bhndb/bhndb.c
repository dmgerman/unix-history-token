begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 Landon Fuller<landon@landonf.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Abstract BHND Bridge Device Driver  *   * Provides generic support for bridging from a parent bus (such as PCI) to  * a BHND-compatible bus (e.g. bcma or siba).  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhndvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhndreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/bhnd_erom.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/cores/chipc/chipcreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/bhnd/nvram/bhnd_nvram.h>
end_include

begin_include
include|#
directive|include
file|"bhnd_chipc_if.h"
end_include

begin_include
include|#
directive|include
file|"bhnd_nvram_if.h"
end_include

begin_include
include|#
directive|include
file|"bhndbvar.h"
end_include

begin_include
include|#
directive|include
file|"bhndb_bus_if.h"
end_include

begin_include
include|#
directive|include
file|"bhndb_hwdata.h"
end_include

begin_include
include|#
directive|include
file|"bhndb_private.h"
end_include

begin_comment
comment|/* Debugging flags */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|bhndb_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_ULONG
argument_list|(
literal|"hw.bhndb.debug"
argument_list|,
operator|&
name|bhndb_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
block|{
name|BHNDB_DEBUG_PRIO
init|=
literal|1
operator|<<
literal|0
block|, }
enum|;
end_enum

begin_define
define|#
directive|define
name|BHNDB_DEBUG
parameter_list|(
name|_type
parameter_list|)
value|(BHNDB_DEBUG_ ## _type& bhndb_debug)
end_define

begin_function_decl
specifier|static
name|int
name|bhndb_find_hostb_core
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|bhnd_erom_t
modifier|*
name|erom
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|core
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bhnd_erom_class_t
modifier|*
name|bhndb_probe_erom_class
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bhnd_chipid
modifier|*
name|cid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_init_full_config
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|bhnd_erom_class_t
modifier|*
name|eromcls
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|bhnd_core_info
modifier|*
name|bhndb_get_bridge_core
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|bhndb_hw_matches
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|cores
parameter_list|,
name|u_int
name|ncores
parameter_list|,
specifier|const
name|struct
name|bhndb_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_init_region_cfg
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|bhnd_erom_t
modifier|*
name|erom
parameter_list|,
name|struct
name|bhndb_resources
modifier|*
name|r
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|cores
parameter_list|,
name|u_int
name|ncores
parameter_list|,
specifier|const
name|struct
name|bhndb_hw_priority
modifier|*
name|table
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_find_hwspec
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|cores
parameter_list|,
name|u_int
name|ncores
parameter_list|,
specifier|const
name|struct
name|bhndb_hw
modifier|*
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bhndb_addrspace
name|bhndb_get_addrspace
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|child
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|rman
modifier|*
name|bhndb_get_rman
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_init_child_resource
parameter_list|(
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|struct
name|resource
modifier|*
name|parent
parameter_list|,
name|bhnd_size_t
name|offset
parameter_list|,
name|bhnd_size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_activate_static_region
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bhndb_region
modifier|*
name|region
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bhndb_try_activate_resource
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|bool
modifier|*
name|indirect
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|struct
name|bhndb_dw_alloc
modifier|*
name|bhndb_io_resource
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|addr
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|bus_size_t
modifier|*
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Default bhndb(4) implementation of DEVICE_PROBE().  *   * This function provides the default bhndb implementation of DEVICE_PROBE(),  * and is compatible with bhndb(4) bridges attached via bhndb_attach_bridge().  */
end_comment

begin_function
name|int
name|bhndb_generic_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|BUS_PROBE_NOWILDCARD
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bhndb_probe_nomatch
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|device_get_name
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
literal|"unknown device"
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"<%s> (no driver attached)\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_print_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|bhndb_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|rl
operator|=
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"mem"
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|"%#jx"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"irq"
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|"%jd"
argument_list|)
expr_stmt|;
block|}
name|retval
operator|+=
name|bus_print_child_domain
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_child_pnpinfo_str
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bhndb_child_location_str
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|struct
name|bhndb_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"base=0x%llx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|sc
operator|->
name|chipid
operator|.
name|enum_addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the bridge core info. Will panic if the bridge core info has not yet  * been populated during full bridge configuration.  *   * @param sc BHNDB device state.  */
end_comment

begin_function
specifier|static
name|struct
name|bhnd_core_info
modifier|*
name|bhndb_get_bridge_core
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|have_br_core
condition|)
name|panic
argument_list|(
literal|"bridge not yet fully configured; no bridge core!"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|sc
operator|->
name|bridge_core
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if @p cores matches the @p hw specification.  *  * @param sc BHNDB device state.  * @param cores A device table to match against.  * @param ncores The number of cores in @p cores.  * @param hw The hardware description to be matched against.  */
end_comment

begin_function
specifier|static
name|bool
name|bhndb_hw_matches
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|cores
parameter_list|,
name|u_int
name|ncores
parameter_list|,
specifier|const
name|struct
name|bhndb_hw
modifier|*
name|hw
parameter_list|)
block|{
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|num_hw_reqs
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|bhnd_core_match
modifier|*
name|match
decl_stmt|;
name|bool
name|found
decl_stmt|;
name|match
operator|=
operator|&
name|hw
operator|->
name|hw_reqs
index|[
name|i
index|]
expr_stmt|;
name|found
operator|=
name|false
expr_stmt|;
for|for
control|(
name|u_int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|ncores
condition|;
name|d
operator|++
control|)
block|{
name|struct
name|bhnd_core_info
modifier|*
name|core
init|=
operator|&
name|cores
index|[
name|d
index|]
decl_stmt|;
if|if
condition|(
name|BHNDB_IS_CORE_DISABLED
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|bus_dev
argument_list|,
name|core
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|bhnd_core_matches
argument_list|(
name|core
argument_list|,
name|match
argument_list|)
condition|)
continue|continue;
name|found
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|found
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize the region maps and priority configuration in @p br using  * the priority @p table and the set of cores enumerated by @p erom.  *   * @param sc The bhndb device state.  * @param br The resource state to be configured.  * @param erom EROM parser used to enumerate @p cores.  * @param cores All cores enumerated on the bridged bhnd bus.  * @param ncores The length of @p cores.  * @param table Hardware priority table to be used to determine the relative  * priorities of per-core port resources.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_init_region_cfg
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|bhnd_erom_t
modifier|*
name|erom
parameter_list|,
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|cores
parameter_list|,
name|u_int
name|ncores
parameter_list|,
specifier|const
name|struct
name|bhndb_hw_priority
modifier|*
name|table
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_hw_priority
modifier|*
name|hp
decl_stmt|;
name|bhnd_addr_t
name|addr
decl_stmt|;
name|bhnd_size_t
name|size
decl_stmt|;
name|size_t
name|prio_low
decl_stmt|,
name|prio_default
decl_stmt|,
name|prio_high
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* The number of port regions per priority band that must be accessible 	 * via dynamic register windows */
name|prio_low
operator|=
literal|0
expr_stmt|;
name|prio_default
operator|=
literal|0
expr_stmt|;
name|prio_high
operator|=
literal|0
expr_stmt|;
comment|/*  	 * Register bridge regions covering all statically mapped ports. 	 */
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncores
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|regw
decl_stmt|;
name|struct
name|bhnd_core_info
modifier|*
name|core
decl_stmt|;
name|struct
name|bhnd_core_match
name|md
decl_stmt|;
name|core
operator|=
operator|&
name|cores
index|[
name|i
index|]
expr_stmt|;
name|md
operator|=
name|bhnd_core_get_match_desc
argument_list|(
name|core
argument_list|)
expr_stmt|;
for|for
control|(
name|regw
operator|=
name|br
operator|->
name|cfg
operator|->
name|register_windows
init|;
name|regw
operator|->
name|win_type
operator|!=
name|BHNDB_REGWIN_T_INVALID
condition|;
name|regw
operator|++
control|)
block|{
comment|/* Only core windows are supported */
if|if
condition|(
name|regw
operator|->
name|win_type
operator|!=
name|BHNDB_REGWIN_T_CORE
condition|)
continue|continue;
comment|/* Skip non-matching cores. */
if|if
condition|(
operator|!
name|bhndb_regwin_match_core
argument_list|(
name|regw
argument_list|,
name|core
argument_list|)
condition|)
continue|continue;
comment|/* Fetch the base address of the mapped port */
name|error
operator|=
name|bhnd_erom_lookup_core_addr
argument_list|(
name|erom
argument_list|,
operator|&
name|md
argument_list|,
name|regw
operator|->
name|d
operator|.
name|core
operator|.
name|port_type
argument_list|,
name|regw
operator|->
name|d
operator|.
name|core
operator|.
name|port
argument_list|,
name|regw
operator|->
name|d
operator|.
name|core
operator|.
name|region
argument_list|,
name|NULL
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* Skip non-applicable register windows */
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
continue|continue;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 			 * Always defer to the register window's size. 			 *  			 * If the port size is smaller than the window size, 			 * this ensures that we fully utilize register windows 			 * larger than the referenced port. 			 *  			 * If the port size is larger than the window size, this 			 * ensures that we do not directly map the allocations 			 * within the region to a too-small window. 			 */
name|size
operator|=
name|regw
operator|->
name|win_size
expr_stmt|;
comment|/* 			 * Add to the bus region list. 			 *  			 * The window priority for a statically mapped 			 * region is always HIGH. 			 */
name|error
operator|=
name|bhndb_add_resource_region
argument_list|(
name|br
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|BHNDB_PRIORITY_HIGH
argument_list|,
name|regw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Perform priority accounting and register bridge regions for all 	 * ports defined in the priority table 	 */
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncores
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bhndb_region
modifier|*
name|region
decl_stmt|;
name|struct
name|bhnd_core_info
modifier|*
name|core
decl_stmt|;
name|struct
name|bhnd_core_match
name|md
decl_stmt|;
name|core
operator|=
operator|&
name|cores
index|[
name|i
index|]
expr_stmt|;
name|md
operator|=
name|bhnd_core_get_match_desc
argument_list|(
name|core
argument_list|)
expr_stmt|;
comment|/*  		 * Skip priority accounting for cores that ... 		 */
comment|/* ... do not require bridge resources */
if|if
condition|(
name|BHNDB_IS_CORE_DISABLED
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|bus_dev
argument_list|,
name|core
argument_list|)
condition|)
continue|continue;
comment|/* ... do not have a priority table entry */
name|hp
operator|=
name|bhndb_hw_priority_find_core
argument_list|(
name|table
argument_list|,
name|core
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
continue|continue;
comment|/* ... are explicitly disabled in the priority table. */
if|if
condition|(
name|hp
operator|->
name|priority
operator|==
name|BHNDB_PRIORITY_NONE
condition|)
continue|continue;
comment|/* Determine the number of dynamic windows required and 		 * register their bus_region entries. */
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hp
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|bhndb_port_priority
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
operator|&
name|hp
operator|->
name|ports
index|[
name|i
index|]
expr_stmt|;
comment|/* Fetch the address+size of the mapped port. */
name|error
operator|=
name|bhnd_erom_lookup_core_addr
argument_list|(
name|erom
argument_list|,
operator|&
name|md
argument_list|,
name|pp
operator|->
name|type
argument_list|,
name|pp
operator|->
name|port
argument_list|,
name|pp
operator|->
name|region
argument_list|,
name|NULL
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* Skip ports not defined on this device */
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
continue|continue;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Skip ports with an existing static mapping */
name|region
operator|=
name|bhndb_find_resource_region
argument_list|(
name|br
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|!=
name|NULL
operator|&&
name|region
operator|->
name|static_regwin
operator|!=
name|NULL
condition|)
continue|continue;
comment|/* Define a dynamic region for this port */
name|error
operator|=
name|bhndb_add_resource_region
argument_list|(
name|br
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|pp
operator|->
name|priority
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Update port mapping counts */
switch|switch
condition|(
name|pp
operator|->
name|priority
condition|)
block|{
case|case
name|BHNDB_PRIORITY_NONE
case|:
break|break;
case|case
name|BHNDB_PRIORITY_LOW
case|:
name|prio_low
operator|++
expr_stmt|;
break|break;
case|case
name|BHNDB_PRIORITY_DEFAULT
case|:
name|prio_default
operator|++
expr_stmt|;
break|break;
case|case
name|BHNDB_PRIORITY_HIGH
case|:
name|prio_high
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Determine the minimum priority at which we'll allocate direct 	 * register windows from our dynamic pool */
name|size_t
name|prio_total
init|=
name|prio_low
operator|+
name|prio_default
operator|+
name|prio_high
decl_stmt|;
if|if
condition|(
name|prio_total
operator|<=
name|br
operator|->
name|dwa_count
condition|)
block|{
comment|/* low+default+high priority regions get windows */
name|br
operator|->
name|min_prio
operator|=
name|BHNDB_PRIORITY_LOW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prio_default
operator|+
name|prio_high
operator|<=
name|br
operator|->
name|dwa_count
condition|)
block|{
comment|/* default+high priority regions get windows */
name|br
operator|->
name|min_prio
operator|=
name|BHNDB_PRIORITY_DEFAULT
expr_stmt|;
block|}
else|else
block|{
comment|/* high priority regions get windows */
name|br
operator|->
name|min_prio
operator|=
name|BHNDB_PRIORITY_HIGH
expr_stmt|;
block|}
if|if
condition|(
name|BHNDB_DEBUG
argument_list|(
name|PRIO
argument_list|)
condition|)
block|{
name|struct
name|bhndb_region
modifier|*
name|region
decl_stmt|;
specifier|const
name|char
modifier|*
name|direct_msg
decl_stmt|,
modifier|*
name|type_msg
decl_stmt|;
name|bhndb_priority_t
name|prio
decl_stmt|,
name|prio_min
decl_stmt|;
name|prio_min
operator|=
name|br
operator|->
name|min_prio
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"min_prio: %d\n"
argument_list|,
name|prio_min
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|region
argument_list|,
argument|&br->bus_regions
argument_list|,
argument|link
argument_list|)
block|{
name|prio
operator|=
name|region
operator|->
name|priority
expr_stmt|;
name|direct_msg
operator|=
name|prio
operator|>=
name|prio_min
condition|?
literal|"direct"
else|:
literal|"indirect"
expr_stmt|;
name|type_msg
operator|=
name|region
operator|->
name|static_regwin
condition|?
literal|"static"
else|:
literal|"dynamic"
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"region 0x%llx+0x%llx priority "
literal|"%u %s/%s\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|region
operator|->
name|addr
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|region
operator|->
name|size
argument_list|,
name|region
operator|->
name|priority
argument_list|,
name|direct_msg
argument_list|,
name|type_msg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find a hardware specification for @p dev.  *   * @param sc The bhndb device state.  * @param cores All cores enumerated on the bridged bhnd bus.  * @param ncores The length of @p cores.  * @param[out] hw On success, the matched hardware specification.  * with @p dev.  *   * @retval 0 success  * @retval non-zero if an error occurs fetching device info for comparison.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_find_hwspec
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|cores
parameter_list|,
name|u_int
name|ncores
parameter_list|,
specifier|const
name|struct
name|bhndb_hw
modifier|*
modifier|*
name|hw
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_hw
modifier|*
name|next
decl_stmt|,
modifier|*
name|hw_table
decl_stmt|;
comment|/* Search for the first matching hardware config. */
name|hw_table
operator|=
name|BHNDB_BUS_GET_HARDWARE_TABLE
argument_list|(
name|sc
operator|->
name|parent_dev
argument_list|,
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|next
operator|=
name|hw_table
init|;
name|next
operator|->
name|hw_reqs
operator|!=
name|NULL
condition|;
name|next
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bhndb_hw_matches
argument_list|(
name|sc
argument_list|,
name|cores
argument_list|,
name|ncores
argument_list|,
name|next
argument_list|)
condition|)
continue|continue;
comment|/* Found */
operator|*
name|hw
operator|=
name|next
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function that must be called by subclass bhndb(4) drivers  * when implementing DEVICE_ATTACH() before calling any bhnd(4) or bhndb(4)  * APIs on the bridge device.  *   * This function will add a bridged bhnd(4) child device with a device order of  * BHND_PROBE_BUS. Any subclass bhndb(4) driver may use the BHND_PROBE_*  * priority bands to add additional devices that will be attached in  * their preferred order relative to the bridged bhnd(4) bus.  *   * @param dev The bridge device to attach.  * @param bridge_devclass The device class of the bridging core. This is used  * to automatically detect the bridge core, and to disable additional bridge  * cores (e.g. PCMCIA on a PCIe device).  */
end_comment

begin_function
name|int
name|bhndb_attach
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|bhnd_devclass_t
name|bridge_devclass
parameter_list|)
block|{
name|struct
name|bhndb_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|bhndb_softc
modifier|*
name|sc
decl_stmt|;
specifier|const
name|struct
name|bhndb_hwcfg
modifier|*
name|cfg
decl_stmt|;
name|bhnd_erom_class_t
modifier|*
name|eromcls
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|parent_dev
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bridge_class
operator|=
name|bridge_devclass
expr_stmt|;
name|BHNDB_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Populate generic resource allocation state. */
name|cfg
operator|=
name|BHNDB_BUS_GET_GENERIC_HWCFG
argument_list|(
name|sc
operator|->
name|parent_dev
argument_list|,
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bus_res
operator|=
name|bhndb_alloc_resources
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|parent_dev
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bus_res
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Allocate our host resources */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_alloc_host_resources
argument_list|(
name|sc
operator|->
name|bus_res
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
comment|/* Probe for a usable EROM class for our bridged bhnd(4) bus and 	 * populate our chip identifier. */
name|BHNDB_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|eromcls
operator|=
name|bhndb_probe_erom_class
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|chipid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|BHNDB_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"device enumeration unsupported; no "
literal|"compatible driver found\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|BHNDB_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Add our bridged bus device */
name|sc
operator|->
name|bus_dev
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|dev
argument_list|,
name|BHND_PROBE_BUS
argument_list|,
literal|"bhnd"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bus_dev
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|sc
operator|->
name|bus_dev
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|addrspace
operator|=
name|BHNDB_ADDRSPACE_BRIDGED
expr_stmt|;
comment|/* Enumerate the bridged device and fully initialize our bridged 	 * resource configuration */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_init_full_config
argument_list|(
name|sc
argument_list|,
name|eromcls
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"initializing full bridge "
literal|"configuration failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
name|BHNDB_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bus_res
operator|!=
name|NULL
condition|)
name|bhndb_free_resources
argument_list|(
name|sc
operator|->
name|bus_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return a borrowed reference to the host resource mapping at least  * BHND_DEFAULT_CORE_SIZE bytes at the first bus core, for use with  * bhnd_erom_probe().  *   * This may return a borrowed reference to a bhndb_dw_alloc-managed  * resource; any additional resource mapping requests may invalidate this  * borrowed reference.  *   * @param sc BHNDB driver state.  * @param[out] offset On success, the offset within the returned resource  * at which the first bus core can be found.  *   * @retval non-NULL success.  * @retval NULL If no usable mapping could be found.  */
end_comment

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|bhndb_erom_chipc_resource
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
modifier|*
name|offset
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_hwcfg
modifier|*
name|cfg
decl_stmt|;
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|win
decl_stmt|;
name|BHNDB_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|cfg
operator|=
name|sc
operator|->
name|bus_res
operator|->
name|cfg
expr_stmt|;
comment|/* Find a static register window mapping ChipCommon. */
name|win
operator|=
name|bhndb_regwin_find_core
argument_list|(
name|cfg
operator|->
name|register_windows
argument_list|,
name|BHND_DEVCLASS_CC
argument_list|,
literal|0
argument_list|,
name|BHND_PORT_DEVICE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|win
operator|->
name|win_size
operator|<
name|BHND_DEFAULT_CORE_SIZE
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"chipcommon register window too small\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|res
operator|=
name|bhndb_find_regwin_resource
argument_list|(
name|sc
operator|->
name|bus_res
argument_list|,
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"chipcommon register window not allocated\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|offset
operator|=
name|win
operator|->
name|win_offset
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
comment|/* We'll need to fetch and configure a dynamic window. We can assume a 	 * device without a static ChipCommon mapping uses the default siba(4) 	 * base address. */
name|dwa
operator|=
name|bhndb_io_resource
argument_list|(
name|sc
argument_list|,
name|BHND_DEFAULT_CHIPC_ADDR
argument_list|,
name|BHND_DEFAULT_CORE_SIZE
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwa
operator|!=
name|NULL
condition|)
return|return
operator|(
name|dwa
operator|->
name|parent_res
operator|)
return|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unable to map chipcommon registers; no usable "
literal|"register window found\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Probe all supported EROM classes, returning the best matching class  * (or NULL if not found), writing the probed chip identifier to @p cid.  *   * @param sc BHNDB driver state.  * @param cid On success, the bridged chipset's chip identifier.  */
end_comment

begin_function
specifier|static
name|bhnd_erom_class_t
modifier|*
name|bhndb_probe_erom_class
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bhnd_chipid
modifier|*
name|cid
parameter_list|)
block|{
name|devclass_t
name|bhndb_devclass
decl_stmt|;
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|hint
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|bus_size_t
name|res_offset
decl_stmt|;
name|driver_t
modifier|*
modifier|*
name|drivers
decl_stmt|;
name|int
name|drv_count
decl_stmt|;
name|bhnd_erom_class_t
modifier|*
name|erom_cls
decl_stmt|;
name|int
name|prio
decl_stmt|,
name|result
decl_stmt|;
name|BHNDB_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|erom_cls
operator|=
name|NULL
expr_stmt|;
name|prio
operator|=
literal|0
expr_stmt|;
comment|/* Let our parent device provide a chipid hint */
name|hint
operator|=
name|BHNDB_BUS_GET_CHIPID
argument_list|(
name|sc
operator|->
name|parent_dev
argument_list|,
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|/* Fetch a borrowed reference to the resource mapping ChipCommon. */
name|res
operator|=
name|bhndb_erom_chipc_resource
argument_list|(
name|sc
argument_list|,
operator|&
name|res_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Fetch all available drivers */
name|bhndb_devclass
operator|=
name|device_get_devclass
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|devclass_get_drivers
argument_list|(
name|bhndb_devclass
argument_list|,
operator|&
name|drivers
argument_list|,
operator|&
name|drv_count
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Enumerate the drivers looking for the best available EROM class */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|drv_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bhnd_chipid
name|pcid
decl_stmt|;
name|bhnd_erom_class_t
modifier|*
name|cls
decl_stmt|;
name|cls
operator|=
name|bhnd_driver_get_erom_class
argument_list|(
name|drivers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cls
operator|==
name|NULL
condition|)
continue|continue;
name|kobj_class_compile
argument_list|(
name|cls
argument_list|)
expr_stmt|;
comment|/* Probe the bus */
name|result
operator|=
name|bhnd_erom_probe
argument_list|(
name|cls
argument_list|,
operator|&
name|BHND_DIRECT_RESOURCE
argument_list|(
name|res
argument_list|)
argument_list|,
name|res_offset
argument_list|,
name|hint
argument_list|,
operator|&
name|pcid
argument_list|)
expr_stmt|;
comment|/* The parser did not match if an error was returned */
if|if
condition|(
name|result
operator|>
literal|0
condition|)
continue|continue;
comment|/* Check for a new highest priority match */
if|if
condition|(
name|erom_cls
operator|==
name|NULL
operator|||
name|result
operator|>
name|prio
condition|)
block|{
name|prio
operator|=
name|result
expr_stmt|;
operator|*
name|cid
operator|=
name|pcid
expr_stmt|;
name|erom_cls
operator|=
name|cls
expr_stmt|;
block|}
comment|/* Terminate immediately on BUS_PROBE_SPECIFIC */
if|if
condition|(
name|result
operator|==
name|BUS_PROBE_SPECIFIC
condition|)
break|break;
block|}
return|return
operator|(
name|erom_cls
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ascending core index comparison used by bhndb_find_hostb_core() */
end_comment

begin_function
specifier|static
name|int
name|compare_core_index
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
name|u_int
name|left
init|=
operator|(
operator|(
specifier|const
expr|struct
name|bhnd_core_info
operator|*
operator|)
name|lhs
operator|)
operator|->
name|core_idx
decl_stmt|;
name|u_int
name|right
init|=
operator|(
operator|(
specifier|const
expr|struct
name|bhnd_core_info
operator|*
operator|)
name|rhs
operator|)
operator|->
name|core_idx
decl_stmt|;
if|if
condition|(
name|left
operator|<
name|right
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|left
operator|>
name|right
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Search @p erom for the core serving as the bhnd host bridge.  *   * This function uses a heuristic valid on all known PCI/PCIe/PCMCIA-bridged  * bhnd(4) devices to determine the hostb core:  *   * - The core must have a Broadcom vendor ID.  * - The core devclass must match the bridge type.  * - The core must be the first device on the bus with the bridged device  *   class.  *   * @param sc BHNDB device state.  * @param erom The device enumeration table parser to be used to fetch  * core info.  * @param[out] core If found, the matching core info.  *   * @retval 0 success  * @retval ENOENT not found  * @retval non-zero if an error occured fetching core info.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_find_hostb_core
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|bhnd_erom_t
modifier|*
name|erom
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|core
parameter_list|)
block|{
name|struct
name|bhnd_core_match
name|md
decl_stmt|;
name|struct
name|bhnd_core_info
modifier|*
name|cores
decl_stmt|;
name|u_int
name|ncores
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_erom_get_core_table
argument_list|(
name|erom
argument_list|,
operator|&
name|cores
argument_list|,
operator|&
name|ncores
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Set up a match descriptor for the required device class. */
name|md
operator|=
operator|(
expr|struct
name|bhnd_core_match
operator|)
block|{
name|BHND_MATCH_CORE_CLASS
argument_list|(
name|sc
operator|->
name|bridge_class
argument_list|)
block|,
name|BHND_MATCH_CORE_UNIT
argument_list|(
literal|0
argument_list|)
block|}
expr_stmt|;
comment|/* Ensure the table is sorted by core index value, ascending; 	 * the host bridge must be the absolute first matching device on the 	 * bus. */
name|qsort
argument_list|(
name|cores
argument_list|,
name|ncores
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cores
argument_list|)
argument_list|,
name|compare_core_index
argument_list|)
expr_stmt|;
comment|/* Find the hostb core */
name|error
operator|=
name|ENOENT
expr_stmt|;
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncores
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bhnd_core_matches
argument_list|(
operator|&
name|cores
index|[
name|i
index|]
argument_list|,
operator|&
name|md
argument_list|)
condition|)
block|{
comment|/* Found! */
operator|*
name|core
operator|=
name|cores
index|[
name|i
index|]
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* Clean up */
name|bhnd_erom_free_core_table
argument_list|(
name|erom
argument_list|,
name|cores
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Identify the bridged device and perform final bridge resource configuration  * based on capabilities of the enumerated device.  *   * Any bridged resources allocated using the generic brige hardware  * configuration must be released prior to calling this function.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_init_full_config
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|bhnd_erom_class_t
modifier|*
name|eromcls
parameter_list|)
block|{
name|struct
name|bhnd_core_info
modifier|*
name|cores
decl_stmt|;
name|struct
name|bhndb_resources
modifier|*
name|br
decl_stmt|;
specifier|const
name|struct
name|bhndb_hw_priority
modifier|*
name|hwprio
decl_stmt|;
name|bhnd_erom_t
modifier|*
name|erom
decl_stmt|;
specifier|const
name|struct
name|bhndb_hw
modifier|*
name|hw
decl_stmt|;
name|u_int
name|ncores
decl_stmt|;
name|int
name|error
decl_stmt|;
name|erom
operator|=
name|NULL
expr_stmt|;
name|cores
operator|=
name|NULL
expr_stmt|;
name|br
operator|=
name|NULL
expr_stmt|;
comment|/* Allocate EROM parser instance */
name|erom
operator|=
name|bhnd_erom_alloc
argument_list|(
name|eromcls
argument_list|,
operator|&
name|sc
operator|->
name|chipid
argument_list|,
name|sc
operator|->
name|bus_dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|erom
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate device enumeration "
literal|"table parser\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Look for our host bridge core */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_find_hostb_core
argument_list|(
name|sc
argument_list|,
name|erom
argument_list|,
operator|&
name|sc
operator|->
name|bridge_core
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"no host bridge core found\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
else|else
block|{
name|sc
operator|->
name|have_br_core
operator|=
name|true
expr_stmt|;
block|}
comment|/* Fetch the bridged device's core table */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_erom_get_core_table
argument_list|(
name|erom
argument_list|,
operator|&
name|cores
argument_list|,
operator|&
name|ncores
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"error fetching core table: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Find our full register window configuration */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_find_hwspec
argument_list|(
name|sc
argument_list|,
name|cores
argument_list|,
name|ncores
argument_list|,
operator|&
name|hw
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unable to identify device, "
literal|" using generic bridge resource definitions\n"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|bootverbose
operator|||
name|BHNDB_DEBUG
argument_list|(
name|PRIO
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s resource configuration\n"
argument_list|,
name|hw
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Allocate new bridge resource state using the discovered hardware 	 * configuration */
name|br
operator|=
name|bhndb_alloc_resources
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|parent_dev
argument_list|,
name|hw
operator|->
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|br
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate new resource state\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Populate our resource priority configuration */
name|hwprio
operator|=
name|BHNDB_BUS_GET_HARDWARE_PRIO
argument_list|(
name|sc
operator|->
name|parent_dev
argument_list|,
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|bhndb_init_region_cfg
argument_list|(
name|sc
argument_list|,
name|erom
argument_list|,
name|br
argument_list|,
name|cores
argument_list|,
name|ncores
argument_list|,
name|hwprio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to initialize resource "
literal|"priority configuration: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* The EROM parser holds a reference to the resource state we're 	 * about to invalidate */
name|bhnd_erom_free_core_table
argument_list|(
name|erom
argument_list|,
name|cores
argument_list|)
expr_stmt|;
name|bhnd_erom_free
argument_list|(
name|erom
argument_list|)
expr_stmt|;
name|cores
operator|=
name|NULL
expr_stmt|;
name|erom
operator|=
name|NULL
expr_stmt|;
comment|/* Replace existing resource state */
name|bhndb_free_resources
argument_list|(
name|sc
operator|->
name|bus_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bus_res
operator|=
name|br
expr_stmt|;
comment|/* Pointer is now owned by sc->bus_res */
name|br
operator|=
name|NULL
expr_stmt|;
comment|/* Re-allocate host resources */
if|if
condition|(
operator|(
name|error
operator|=
name|bhndb_alloc_host_resources
argument_list|(
name|sc
operator|->
name|bus_res
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to reallocate bridge host "
literal|"resources: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|cleanup
label|:
if|if
condition|(
name|cores
operator|!=
name|NULL
condition|)
name|bhnd_erom_free_core_table
argument_list|(
name|erom
argument_list|,
name|cores
argument_list|)
expr_stmt|;
if|if
condition|(
name|erom
operator|!=
name|NULL
condition|)
name|bhnd_erom_free
argument_list|(
name|erom
argument_list|)
expr_stmt|;
if|if
condition|(
name|br
operator|!=
name|NULL
condition|)
name|bhndb_free_resources
argument_list|(
name|br
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhndb(4) implementation of DEVICE_DETACH().  *   * This function detaches any child devices, and if successful, releases all  * resources held by the bridge device.  */
end_comment

begin_function
name|int
name|bhndb_generic_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhndb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Detach children */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Clean up our driver state. */
name|bhndb_free_resources
argument_list|(
name|sc
operator|->
name|bus_res
argument_list|)
expr_stmt|;
name|BHNDB_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhndb(4) implementation of DEVICE_SUSPEND().  *   * This function calls bus_generic_suspend() (or implements equivalent  * behavior).  */
end_comment

begin_function
name|int
name|bhndb_generic_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhndb(4) implementation of DEVICE_RESUME().  *   * This function calls bus_generic_resume() (or implements equivalent  * behavior).  */
end_comment

begin_function
name|int
name|bhndb_generic_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bhndb_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bhndb_resources
modifier|*
name|bus_res
decl_stmt|;
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_res
operator|=
name|sc
operator|->
name|bus_res
expr_stmt|;
comment|/* Guarantee that all in-use dynamic register windows are mapped to 	 * their previously configured target address. */
name|BHNDB_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bus_res
operator|->
name|dwa_count
condition|;
name|i
operator|++
control|)
block|{
name|dwa
operator|=
operator|&
name|bus_res
operator|->
name|dw_alloc
index|[
name|i
index|]
expr_stmt|;
comment|/* Skip regions that were not previously used */
if|if
condition|(
name|bhndb_dw_is_free
argument_list|(
name|bus_res
argument_list|,
name|dwa
argument_list|)
operator|&&
name|dwa
operator|->
name|target
operator|==
literal|0x0
condition|)
continue|continue;
comment|/* Otherwise, ensure the register window is correct before 		 * any children attempt MMIO */
name|error
operator|=
name|BHNDB_SET_WINDOW_ADDR
argument_list|(
name|dev
argument_list|,
name|dwa
operator|->
name|win
argument_list|,
name|dwa
operator|->
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|BHNDB_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Error restoring hardware state; children cannot be safely resumed */
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to restore hardware configuration; "
literal|"cannot resume: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|bus_generic_resume
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default implementation of BHNDB_SUSPEND_RESOURCE.  */
end_comment

begin_function
specifier|static
name|void
name|bhndb_suspend_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|bhndb_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|// TODO: IRQs?
if|if
condition|(
name|type
operator|!=
name|SYS_RES_MEMORY
condition|)
return|return;
name|BHNDB_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|dwa
operator|=
name|bhndb_dw_find_resource
argument_list|(
name|sc
operator|->
name|bus_res
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwa
operator|==
name|NULL
condition|)
block|{
name|BHNDB_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|BHNDB_DEBUG
argument_list|(
name|PRIO
argument_list|)
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"suspend resource type=%d 0x%jx+0x%jx\n"
argument_list|,
name|type
argument_list|,
name|rman_get_start
argument_list|(
name|r
argument_list|)
argument_list|,
name|rman_get_size
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Release the resource's window reference */
name|bhndb_dw_release
argument_list|(
name|sc
operator|->
name|bus_res
argument_list|,
name|dwa
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|BHNDB_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Default implementation of BHNDB_RESUME_RESOURCE.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_resume_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|bhndb_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|// TODO: IRQs?
if|if
condition|(
name|type
operator|!=
name|SYS_RES_MEMORY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Inactive resources don't require reallocation of bridge resources */
if|if
condition|(
operator|!
operator|(
name|rman_get_flags
argument_list|(
name|r
argument_list|)
operator|&
name|RF_ACTIVE
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|BHNDB_DEBUG
argument_list|(
name|PRIO
argument_list|)
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"resume resource type=%d 0x%jx+0x%jx\n"
argument_list|,
name|type
argument_list|,
name|rman_get_start
argument_list|(
name|r
argument_list|)
argument_list|,
name|rman_get_size
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bhndb_try_activate_resource
argument_list|(
name|sc
argument_list|,
name|rman_get_device
argument_list|(
name|r
argument_list|)
argument_list|,
name|type
argument_list|,
name|rman_get_rid
argument_list|(
name|r
argument_list|)
argument_list|,
name|r
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhndb(4) implementation of BUS_READ_IVAR().  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhndb(4) implementation of BUS_WRITE_IVAR().  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the address space for the given @p child device.  */
end_comment

begin_function
name|bhndb_addrspace
name|bhndb_get_addrspace
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|bhndb_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|device_t
name|imd_dev
decl_stmt|;
comment|/* Find the directly attached parent of the requesting device */
name|imd_dev
operator|=
name|child
expr_stmt|;
while|while
condition|(
name|imd_dev
operator|!=
name|NULL
operator|&&
name|device_get_parent
argument_list|(
name|imd_dev
argument_list|)
operator|!=
name|sc
operator|->
name|dev
condition|)
name|imd_dev
operator|=
name|device_get_parent
argument_list|(
name|imd_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|imd_dev
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"bhndb address space request for non-child device %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|imd_dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|dinfo
operator|->
name|addrspace
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the rman instance for a given resource @p type, if any.  *   * @param sc The bhndb device state.  * @param child The requesting child.  * @param type The resource type (e.g. SYS_RES_MEMORY, SYS_RES_IRQ, ...)  */
end_comment

begin_function
specifier|static
name|struct
name|rman
modifier|*
name|bhndb_get_rman
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|bhndb_get_addrspace
argument_list|(
name|sc
argument_list|,
name|child
argument_list|)
condition|)
block|{
case|case
name|BHNDB_ADDRSPACE_NATIVE
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_MEMORY
case|:
return|return
operator|(
operator|&
name|sc
operator|->
name|bus_res
operator|->
name|ht_mem_rman
operator|)
return|;
case|case
name|SYS_RES_IRQ
case|:
return|return
operator|(
name|NULL
operator|)
return|;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
empty_stmt|;
case|case
name|BHNDB_ADDRSPACE_BRIDGED
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_MEMORY
case|:
return|return
operator|(
operator|&
name|sc
operator|->
name|bus_res
operator|->
name|br_mem_rman
operator|)
return|;
case|case
name|SYS_RES_IRQ
case|:
comment|// TODO
comment|// return&sc->irq_rman;
return|return
operator|(
name|NULL
operator|)
return|;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
empty_stmt|;
block|}
comment|/* Quieten gcc */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default implementation of BUS_ADD_CHILD()  */
end_comment

begin_function
specifier|static
name|device_t
name|bhndb_add_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|order
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|bhndb_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|child
operator|=
name|device_add_child_ordered
argument_list|(
name|dev
argument_list|,
name|order
argument_list|,
name|name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dinfo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bhndb_devinfo
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|==
name|NULL
condition|)
block|{
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dinfo
operator|->
name|addrspace
operator|=
name|BHNDB_ADDRSPACE_NATIVE
expr_stmt|;
name|resource_list_init
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|child
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default implementation of BUS_CHILD_DELETED().  */
end_comment

begin_function
specifier|static
name|void
name|bhndb_child_deleted
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|bhndb_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|dinfo
operator|!=
name|NULL
condition|)
block|{
name|resource_list_free
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dinfo
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Default implementation of BHNDB_GET_CHIPID().  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|bhnd_chipid
modifier|*
name|bhndb_get_chipid
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|bhndb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
operator|&
name|sc
operator|->
name|chipid
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default implementation of BHNDB_IS_CORE_DISABLED().  */
end_comment

begin_function
specifier|static
name|bool
name|bhndb_is_core_disabled
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|core
parameter_list|)
block|{
name|struct
name|bhndb_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bhnd_core_info
modifier|*
name|bridge_core
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Try to defer to the bhndb bus parent */
if|if
condition|(
name|BHNDB_BUS_IS_CORE_DISABLED
argument_list|(
name|sc
operator|->
name|parent_dev
argument_list|,
name|dev
argument_list|,
name|core
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
comment|/* Otherwise, we treat bridge-capable cores as unpopulated if they're 	 * not the configured host bridge */
name|bridge_core
operator|=
name|bhndb_get_bridge_core
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|BHND_DEVCLASS_SUPPORTS_HOSTB
argument_list|(
name|bhnd_core_class
argument_list|(
name|core
argument_list|)
argument_list|)
condition|)
return|return
operator|(
operator|!
name|bhnd_cores_equal
argument_list|(
name|core
argument_list|,
name|bridge_core
argument_list|)
operator|)
return|;
comment|/* Assume the core is populated */
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhndb(4) implementation of BHNDB_GET_HOSTB_CORE().  *   * This function uses a heuristic valid on all known PCI/PCIe/PCMCIA-bridged  * bhnd(4) devices.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_get_hostb_core
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|core
parameter_list|)
block|{
name|struct
name|bhndb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
operator|*
name|core
operator|=
operator|*
name|bhndb_get_bridge_core
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhndb(4) implementation of BUS_ALLOC_RESOURCE().  */
end_comment

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|bhndb_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|bhndb_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|struct
name|resource
modifier|*
name|rv
decl_stmt|;
name|struct
name|rman
modifier|*
name|rm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bool
name|passthrough
decl_stmt|,
name|isdefault
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|passthrough
operator|=
operator|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
operator|)
expr_stmt|;
name|isdefault
operator|=
name|RMAN_IS_DEFAULT_RANGE
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|rle
operator|=
name|NULL
expr_stmt|;
comment|/* Populate defaults */
if|if
condition|(
operator|!
name|passthrough
operator|&&
name|isdefault
condition|)
block|{
comment|/* Fetch the resource list entry. */
name|rle
operator|=
name|resource_list_find
argument_list|(
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"default resource %#x type %d for child %s "
literal|"not found\n"
argument_list|,
operator|*
name|rid
argument_list|,
name|type
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|rle
operator|->
name|res
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"resource entry %#x type %d for child %s is busy\n"
argument_list|,
operator|*
name|rid
argument_list|,
name|type
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|start
operator|=
name|rle
operator|->
name|start
expr_stmt|;
name|end
operator|=
name|rle
operator|->
name|end
expr_stmt|;
name|count
operator|=
name|ulmax
argument_list|(
name|count
argument_list|,
name|rle
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
comment|/* Validate resource addresses */
if|if
condition|(
name|start
operator|>
name|end
operator|||
name|count
operator|>
operator|(
operator|(
name|end
operator|-
name|start
operator|)
operator|+
literal|1
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Fetch the resource manager */
name|rm
operator|=
name|bhndb_get_rman
argument_list|(
name|sc
argument_list|,
name|child
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Make our reservation */
name|rv
operator|=
name|rman_reserve_resource
argument_list|(
name|rm
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
operator|&
operator|~
name|RF_ACTIVE
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|rman_set_rid
argument_list|(
name|rv
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
comment|/* Activate */
if|if
condition|(
name|flags
operator|&
name|RF_ACTIVE
condition|)
block|{
name|error
operator|=
name|bus_activate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|rv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to activate entry %#x type %d for "
literal|"child %s: %d\n"
argument_list|,
operator|*
name|rid
argument_list|,
name|type
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|rman_release_resource
argument_list|(
name|rv
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* Update child's resource list entry */
if|if
condition|(
name|rle
operator|!=
name|NULL
condition|)
block|{
name|rle
operator|->
name|res
operator|=
name|rv
expr_stmt|;
name|rle
operator|->
name|start
operator|=
name|rman_get_start
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|rle
operator|->
name|end
operator|=
name|rman_get_end
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|rle
operator|->
name|count
operator|=
name|rman_get_size
argument_list|(
name|rv
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhndb(4) implementation of BUS_RELEASE_RESOURCE().  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_release_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|bool
name|passthrough
decl_stmt|;
name|int
name|error
decl_stmt|;
name|passthrough
operator|=
operator|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
operator|)
expr_stmt|;
comment|/* Deactivate resources */
if|if
condition|(
name|rman_get_flags
argument_list|(
name|r
argument_list|)
operator|&
name|RF_ACTIVE
condition|)
block|{
name|error
operator|=
name|BUS_DEACTIVATE_RESOURCE
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|rman_release_resource
argument_list|(
name|r
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|passthrough
condition|)
block|{
comment|/* Clean resource list entry */
name|rle
operator|=
name|resource_list_find
argument_list|(
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|!=
name|NULL
condition|)
name|rle
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhndb(4) implementation of BUS_ADJUST_RESOURCE().  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_adjust_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|)
block|{
name|struct
name|bhndb_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|rman
modifier|*
name|rm
decl_stmt|;
name|rman_res_t
name|mstart
decl_stmt|,
name|mend
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Verify basic constraints */
if|if
condition|(
name|end
operator|<=
name|start
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Fetch resource manager */
name|rm
operator|=
name|bhndb_get_rman
argument_list|(
name|sc
argument_list|,
name|child
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
name|rman_is_region_manager
argument_list|(
name|r
argument_list|,
name|rm
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|BHNDB_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If not active, allow any range permitted by the resource manager */
if|if
condition|(
operator|!
operator|(
name|rman_get_flags
argument_list|(
name|r
argument_list|)
operator|&
name|RF_ACTIVE
operator|)
condition|)
goto|goto
name|done
goto|;
comment|/* Otherwise, the range is limited to the existing register window 	 * mapping */
name|error
operator|=
name|bhndb_find_resource_limits
argument_list|(
name|sc
operator|->
name|bus_res
argument_list|,
name|r
argument_list|,
operator|&
name|mstart
argument_list|,
operator|&
name|mend
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|start
operator|<
name|mstart
operator|||
name|end
operator|>
name|mend
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Fall through */
name|done
label|:
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|rman_adjust_resource
argument_list|(
name|r
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|BHNDB_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize child resource @p r with a virtual address, tag, and handle  * copied from @p parent, adjusted to contain only the range defined by  * @p offsize and @p size.  *   * @param r The register to be initialized.  * @param parent The parent bus resource that fully contains the subregion.  * @param offset The subregion offset within @p parent.  * @param size The subregion size.  * @p r.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_init_child_resource
parameter_list|(
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|struct
name|resource
modifier|*
name|parent
parameter_list|,
name|bhnd_size_t
name|offset
parameter_list|,
name|bhnd_size_t
name|size
parameter_list|)
block|{
name|bus_space_handle_t
name|bh
decl_stmt|,
name|child_bh
decl_stmt|;
name|bus_space_tag_t
name|bt
decl_stmt|;
name|uintptr_t
name|vaddr
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Fetch the parent resource's real bus values */
name|vaddr
operator|=
operator|(
name|uintptr_t
operator|)
name|rman_get_virtual
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|bt
operator|=
name|rman_get_bustag
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|bh
operator|=
name|rman_get_bushandle
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|/* Configure child resource with window-adjusted real bus values */
name|vaddr
operator|+=
name|offset
expr_stmt|;
name|error
operator|=
name|bus_space_subregion
argument_list|(
name|bt
argument_list|,
name|bh
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
operator|&
name|child_bh
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|rman_set_virtual
argument_list|(
name|r
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vaddr
argument_list|)
expr_stmt|;
name|rman_set_bustag
argument_list|(
name|r
argument_list|,
name|bt
argument_list|)
expr_stmt|;
name|rman_set_bushandle
argument_list|(
name|r
argument_list|,
name|child_bh
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Attempt activation of a fixed register window mapping for @p child.  *   * @param sc BHNDB device state.  * @param region The static region definition capable of mapping @p r.  * @param child A child requesting resource activation.  * @param type Resource type.  * @param rid Resource identifier.  * @param r Resource to be activated.  *   * @retval 0 if @p r was activated successfully  * @retval ENOENT if no fixed register window was found.  * @retval non-zero if @p r could not be activated.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_activate_static_region
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bhndb_region
modifier|*
name|region
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|bridge_res
decl_stmt|;
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|win
decl_stmt|;
name|bhnd_size_t
name|parent_offset
decl_stmt|;
name|rman_res_t
name|r_start
decl_stmt|,
name|r_size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|win
operator|=
name|region
operator|->
name|static_regwin
expr_stmt|;
name|KASSERT
argument_list|(
name|win
operator|!=
name|NULL
operator|&&
name|BHNDB_REGWIN_T_IS_STATIC
argument_list|(
name|win
operator|->
name|win_type
argument_list|)
argument_list|,
operator|(
literal|"can't activate non-static region"
operator|)
argument_list|)
expr_stmt|;
name|r_start
operator|=
name|rman_get_start
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r_size
operator|=
name|rman_get_size
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* Find the corresponding bridge resource */
name|bridge_res
operator|=
name|bhndb_find_regwin_resource
argument_list|(
name|sc
operator|->
name|bus_res
argument_list|,
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|bridge_res
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Calculate subregion offset within the parent resource */
name|parent_offset
operator|=
name|r_start
operator|-
name|region
operator|->
name|addr
expr_stmt|;
name|parent_offset
operator|+=
name|win
operator|->
name|win_offset
expr_stmt|;
comment|/* Configure resource with its real bus values. */
name|error
operator|=
name|bhndb_init_child_resource
argument_list|(
name|r
argument_list|,
name|bridge_res
argument_list|,
name|parent_offset
argument_list|,
name|r_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Mark active */
if|if
condition|(
operator|(
name|error
operator|=
name|rman_activate_resource
argument_list|(
name|r
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Attempt to allocate/retain a dynamic register window for @p r, returning  * the retained window.  *   * @param sc The bhndb driver state.  * @param r The resource for which a window will be retained.  */
end_comment

begin_function
specifier|static
name|struct
name|bhndb_dw_alloc
modifier|*
name|bhndb_retain_dynamic_window
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
decl_stmt|;
name|rman_res_t
name|r_start
decl_stmt|,
name|r_size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|BHNDB_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|r_start
operator|=
name|rman_get_start
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r_size
operator|=
name|rman_get_size
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* Look for an existing dynamic window we can reference */
name|dwa
operator|=
name|bhndb_dw_find_mapping
argument_list|(
name|sc
operator|->
name|bus_res
argument_list|,
name|r_start
argument_list|,
name|r_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwa
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bhndb_dw_retain
argument_list|(
name|sc
operator|->
name|bus_res
argument_list|,
name|dwa
argument_list|,
name|r
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|dwa
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Otherwise, try to reserve a free window */
name|dwa
operator|=
name|bhndb_dw_next_free
argument_list|(
name|sc
operator|->
name|bus_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwa
operator|==
name|NULL
condition|)
block|{
comment|/* No free windows */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Window must be large enough to map the entire resource */
if|if
condition|(
name|dwa
operator|->
name|win
operator|->
name|win_size
operator|<
name|rman_get_size
argument_list|(
name|r
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Set the window target */
name|error
operator|=
name|bhndb_dw_set_addr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|bus_res
argument_list|,
name|dwa
argument_list|,
name|rman_get_start
argument_list|(
name|r
argument_list|)
argument_list|,
name|rman_get_size
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"dynamic window initialization "
literal|"for 0x%llx-0x%llx failed: %d\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|r_start
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|r_start
operator|+
name|r_size
operator|-
literal|1
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Add our reservation */
if|if
condition|(
name|bhndb_dw_retain
argument_list|(
name|sc
operator|->
name|bus_res
argument_list|,
name|dwa
argument_list|,
name|r
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|dwa
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Activate a resource using any viable static or dynamic register window.  *   * @param sc The bhndb driver state.  * @param child The child holding ownership of @p r.  * @param type The type of the resource to be activated.  * @param rid The resource ID of @p r.  * @param r The resource to be activated  * @param[out] indirect On error and if not NULL, will be set to 'true' if  * the caller should instead use an indirect resource mapping.  *   * @retval 0 success  * @retval non-zero activation failed.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_try_activate_resource
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|bool
modifier|*
name|indirect
parameter_list|)
block|{
name|struct
name|bhndb_region
modifier|*
name|region
decl_stmt|;
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
decl_stmt|;
name|bhndb_priority_t
name|dw_priority
decl_stmt|;
name|rman_res_t
name|r_start
decl_stmt|,
name|r_size
decl_stmt|;
name|rman_res_t
name|parent_offset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|BHNDB_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
comment|// TODO - IRQs
if|if
condition|(
name|type
operator|!=
name|SYS_RES_MEMORY
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|indirect
condition|)
operator|*
name|indirect
operator|=
name|false
expr_stmt|;
name|r_start
operator|=
name|rman_get_start
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r_size
operator|=
name|rman_get_size
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* Activate native addrspace resources using the host address space */
if|if
condition|(
name|bhndb_get_addrspace
argument_list|(
name|sc
argument_list|,
name|child
argument_list|)
operator|==
name|BHNDB_ADDRSPACE_NATIVE
condition|)
block|{
name|struct
name|resource
modifier|*
name|parent
decl_stmt|;
comment|/* Find the bridge resource referenced by the child */
name|parent
operator|=
name|bhndb_find_resource_range
argument_list|(
name|sc
operator|->
name|bus_res
argument_list|,
name|r_start
argument_list|,
name|r_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"host resource not found "
literal|"for 0x%llx-0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|r_start
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|r_start
operator|+
name|r_size
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* Initialize child resource with the real bus values */
name|error
operator|=
name|bhndb_init_child_resource
argument_list|(
name|r
argument_list|,
name|parent
argument_list|,
name|r_start
operator|-
name|rman_get_start
argument_list|(
name|parent
argument_list|)
argument_list|,
name|r_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Try to activate child resource */
return|return
operator|(
name|rman_activate_resource
argument_list|(
name|r
argument_list|)
operator|)
return|;
block|}
comment|/* Default to low priority */
name|dw_priority
operator|=
name|BHNDB_PRIORITY_LOW
expr_stmt|;
comment|/* Look for a bus region matching the resource's address range */
name|region
operator|=
name|bhndb_find_resource_region
argument_list|(
name|sc
operator|->
name|bus_res
argument_list|,
name|r_start
argument_list|,
name|r_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|!=
name|NULL
condition|)
name|dw_priority
operator|=
name|region
operator|->
name|priority
expr_stmt|;
comment|/* Prefer static mappings over consuming a dynamic windows. */
if|if
condition|(
name|region
operator|&&
name|region
operator|->
name|static_regwin
condition|)
block|{
name|error
operator|=
name|bhndb_activate_static_region
argument_list|(
name|sc
argument_list|,
name|region
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"static window allocation "
literal|"for 0x%llx-0x%llx failed\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|r_start
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|r_start
operator|+
name|r_size
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* A dynamic window will be required; is this resource high enough 	 * priority to be reserved a dynamic window? */
if|if
condition|(
name|dw_priority
operator|<
name|sc
operator|->
name|bus_res
operator|->
name|min_prio
condition|)
block|{
if|if
condition|(
name|indirect
condition|)
operator|*
name|indirect
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Find and retain a usable window */
name|BHNDB_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|{
name|dwa
operator|=
name|bhndb_retain_dynamic_window
argument_list|(
name|sc
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
name|BHNDB_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwa
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|indirect
condition|)
operator|*
name|indirect
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Configure resource with its real bus values. */
name|parent_offset
operator|=
name|dwa
operator|->
name|win
operator|->
name|win_offset
expr_stmt|;
name|parent_offset
operator|+=
name|r_start
operator|-
name|dwa
operator|->
name|target
expr_stmt|;
name|error
operator|=
name|bhndb_init_child_resource
argument_list|(
name|r
argument_list|,
name|dwa
operator|->
name|parent_res
argument_list|,
name|parent_offset
argument_list|,
name|dwa
operator|->
name|win
operator|->
name|win_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
comment|/* Mark active */
if|if
condition|(
operator|(
name|error
operator|=
name|rman_activate_resource
argument_list|(
name|r
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
comment|/* Release our region allocation. */
name|BHNDB_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bhndb_dw_release
argument_list|(
name|sc
operator|->
name|bus_res
argument_list|,
name|dwa
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|BHNDB_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhndb(4) implementation of BUS_ACTIVATE_RESOURCE().  *  * Maps resource activation requests to a viable static or dynamic  * register window, if any.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_activate_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|bhndb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|bhndb_try_activate_resource
argument_list|(
name|sc
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhndb(4) implementation of BUS_DEACTIVATE_RESOURCE().  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_deactivate_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
decl_stmt|;
name|struct
name|bhndb_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|rman
modifier|*
name|rm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rm
operator|=
name|bhndb_get_rman
argument_list|(
name|sc
argument_list|,
name|child
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Mark inactive */
if|if
condition|(
operator|(
name|error
operator|=
name|rman_deactivate_resource
argument_list|(
name|r
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Free any dynamic window allocation. */
if|if
condition|(
name|bhndb_get_addrspace
argument_list|(
name|sc
argument_list|,
name|child
argument_list|)
operator|==
name|BHNDB_ADDRSPACE_BRIDGED
condition|)
block|{
name|BHNDB_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|dwa
operator|=
name|bhndb_dw_find_resource
argument_list|(
name|sc
operator|->
name|bus_res
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwa
operator|!=
name|NULL
condition|)
name|bhndb_dw_release
argument_list|(
name|sc
operator|->
name|bus_res
argument_list|,
name|dwa
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|BHNDB_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhndb(4) implementation of BUS_GET_RESOURCE_LIST().  */
end_comment

begin_function
specifier|static
name|struct
name|resource_list
modifier|*
name|bhndb_get_resource_list
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|bhndb_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
return|return
operator|(
operator|&
name|dinfo
operator|->
name|resources
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhndb(4) implementation of BHND_BUS_ACTIVATE_RESOURCE().  *  * For BHNDB_ADDRSPACE_NATIVE children, all resources may be assumed to  * be activated by the bridge.  *   * For BHNDB_ADDRSPACE_BRIDGED children, attempts to activate a static register  * window, a dynamic register window, or configures @p r as an indirect  * resource -- in that order.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_activate_bhnd_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|bhnd_resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|bhndb_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bhndb_region
modifier|*
name|region
decl_stmt|;
name|rman_res_t
name|r_start
decl_stmt|,
name|r_size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bool
name|indirect
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
name|r
operator|->
name|direct
argument_list|,
operator|(
literal|"direct flag set on inactive resource"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|rman_get_flags
argument_list|(
name|r
operator|->
name|res
argument_list|)
operator|&
name|RF_ACTIVE
operator|)
argument_list|,
operator|(
literal|"RF_ACTIVE set on inactive resource"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|r_start
operator|=
name|rman_get_start
argument_list|(
name|r
operator|->
name|res
argument_list|)
expr_stmt|;
name|r_size
operator|=
name|rman_get_size
argument_list|(
name|r
operator|->
name|res
argument_list|)
expr_stmt|;
comment|/* Verify bridged address range's resource priority, and skip direct 	 * allocation if the priority is too low. */
if|if
condition|(
name|bhndb_get_addrspace
argument_list|(
name|sc
argument_list|,
name|child
argument_list|)
operator|==
name|BHNDB_ADDRSPACE_BRIDGED
condition|)
block|{
name|bhndb_priority_t
name|r_prio
decl_stmt|;
name|region
operator|=
name|bhndb_find_resource_region
argument_list|(
name|sc
operator|->
name|bus_res
argument_list|,
name|r_start
argument_list|,
name|r_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|!=
name|NULL
condition|)
name|r_prio
operator|=
name|region
operator|->
name|priority
expr_stmt|;
else|else
name|r_prio
operator|=
name|BHNDB_PRIORITY_NONE
expr_stmt|;
comment|/* If less than the minimum dynamic window priority, this 		 * resource should always be indirect. */
if|if
condition|(
name|r_prio
operator|<
name|sc
operator|->
name|bus_res
operator|->
name|min_prio
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Attempt direct activation */
name|error
operator|=
name|bhndb_try_activate_resource
argument_list|(
name|sc
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
operator|->
name|res
argument_list|,
operator|&
name|indirect
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|r
operator|->
name|direct
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|indirect
condition|)
block|{
comment|/* The request was valid, but no viable register window is 		 * available; indirection must be employed. */
name|error
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|direct
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|BHNDB_DEBUG
argument_list|(
name|PRIO
argument_list|)
operator|&&
name|bhndb_get_addrspace
argument_list|(
name|sc
argument_list|,
name|child
argument_list|)
operator|==
name|BHNDB_ADDRSPACE_BRIDGED
condition|)
block|{
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"activated 0x%llx-0x%llx as %s "
literal|"resource\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|r_start
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|r_start
operator|+
name|r_size
operator|-
literal|1
argument_list|,
name|r
operator|->
name|direct
condition|?
literal|"direct"
else|:
literal|"indirect"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/**  * Default bhndb(4) implementation of BHND_BUS_DEACTIVATE_RESOURCE().  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_deactivate_bhnd_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|bhnd_resource
modifier|*
name|r
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Indirect resources don't require activation */
if|if
condition|(
operator|!
name|r
operator|->
name|direct
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|KASSERT
argument_list|(
name|rman_get_flags
argument_list|(
name|r
operator|->
name|res
argument_list|)
operator|&
name|RF_ACTIVE
argument_list|,
operator|(
literal|"RF_ACTIVE not set on direct resource"
operator|)
argument_list|)
expr_stmt|;
comment|/* Perform deactivation */
name|error
operator|=
name|bus_deactivate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
operator|->
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|r
operator|->
name|direct
operator|=
name|false
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/**  * Slow path for bhndb_io_resource().  *  * Iterates over the existing allocated dynamic windows looking for a viable  * in-use region; the first matching region is returned.  */
end_comment

begin_function
specifier|static
name|struct
name|bhndb_dw_alloc
modifier|*
name|bhndb_io_resource_slow
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|addr
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|bus_size_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|bhndb_resources
modifier|*
name|br
decl_stmt|;
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
decl_stmt|;
name|BHNDB_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|br
operator|=
name|sc
operator|->
name|bus_res
expr_stmt|;
comment|/* Search for an existing dynamic mapping of this address range. 	 * Static regions are not searched, as a statically mapped 	 * region would never be allocated as an indirect resource. */
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|br
operator|->
name|dwa_count
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|win
decl_stmt|;
name|dwa
operator|=
operator|&
name|br
operator|->
name|dw_alloc
index|[
name|i
index|]
expr_stmt|;
name|win
operator|=
name|dwa
operator|->
name|win
expr_stmt|;
name|KASSERT
argument_list|(
name|win
operator|->
name|win_type
operator|==
name|BHNDB_REGWIN_T_DYN
argument_list|,
operator|(
literal|"invalid register window type"
operator|)
argument_list|)
expr_stmt|;
comment|/* Verify the range */
if|if
condition|(
name|addr
operator|<
name|dwa
operator|->
name|target
condition|)
continue|continue;
if|if
condition|(
name|addr
operator|+
name|size
operator|>
name|dwa
operator|->
name|target
operator|+
name|win
operator|->
name|win_size
condition|)
continue|continue;
comment|/* Found */
operator|*
name|offset
operator|=
name|dwa
operator|->
name|win
operator|->
name|win_offset
expr_stmt|;
operator|*
name|offset
operator|+=
name|addr
operator|-
name|dwa
operator|->
name|target
expr_stmt|;
return|return
operator|(
name|dwa
operator|)
return|;
block|}
comment|/* not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return a borrowed reference to a bridge resource allocation record capable  * of handling bus I/O requests of @p size at @p addr.  *   * This will either return a  reference to an existing allocation  * record mapping the requested space, or will configure and return a free  * allocation record.  *   * Will panic if a usable record cannot be found.  *   * @param sc Bridge driver state.  * @param addr The I/O target address.  * @param size The size of the I/O operation to be performed at @p addr.   * @param[out] offset The offset within the returned resource at which  * to perform the I/O request.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|bhndb_dw_alloc
modifier|*
name|bhndb_io_resource
parameter_list|(
name|struct
name|bhndb_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|addr
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|bus_size_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|bhndb_resources
modifier|*
name|br
decl_stmt|;
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
decl_stmt|;
name|int
name|error
decl_stmt|;
name|BHNDB_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|br
operator|=
name|sc
operator|->
name|bus_res
expr_stmt|;
comment|/* Try to fetch a free window */
name|dwa
operator|=
name|bhndb_dw_next_free
argument_list|(
name|br
argument_list|)
expr_stmt|;
comment|/* 	 * If no dynamic windows are available, look for an existing 	 * region that maps the target range.  	 *  	 * If none are found, this is a child driver bug -- our window 	 * over-commit should only fail in the case where a child driver leaks 	 * resources, or perform operations out-of-order. 	 *  	 * Broadcom HND chipsets are designed to not require register window 	 * swapping during execution; as long as the child devices are 	 * attached/detached correctly, using the hardware's required order 	 * of operations, there should always be a window available for the 	 * current operation. 	 */
if|if
condition|(
name|dwa
operator|==
name|NULL
condition|)
block|{
name|dwa
operator|=
name|bhndb_io_resource_slow
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwa
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"register windows exhausted attempting to map "
literal|"0x%llx-0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|addr
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|addr
operator|+
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dwa
operator|)
return|;
block|}
comment|/* Adjust the window if the I/O request won't fit in the current 	 * target range. */
if|if
condition|(
name|addr
operator|<
name|dwa
operator|->
name|target
operator|||
name|addr
operator|>
name|dwa
operator|->
name|target
operator|+
name|dwa
operator|->
name|win
operator|->
name|win_size
operator|||
operator|(
name|dwa
operator|->
name|target
operator|+
name|dwa
operator|->
name|win
operator|->
name|win_size
operator|)
operator|-
name|addr
operator|<
name|size
condition|)
block|{
name|error
operator|=
name|bhndb_dw_set_addr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|bus_res
argument_list|,
name|dwa
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|panic
argument_list|(
literal|"failed to set register window target mapping "
literal|"0x%llx-0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|addr
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|addr
operator|+
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Calculate the offset and return */
operator|*
name|offset
operator|=
operator|(
name|addr
operator|-
name|dwa
operator|->
name|target
operator|)
operator|+
name|dwa
operator|->
name|win
operator|->
name|win_offset
expr_stmt|;
return|return
operator|(
name|dwa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * BHND_BUS_(READ|WRITE_* implementations  */
end_comment

begin_comment
comment|/* bhndb_bus_(read|write) common implementation */
end_comment

begin_define
define|#
directive|define
name|BHNDB_IO_COMMON_SETUP
parameter_list|(
name|_io_size
parameter_list|)
define|\
value|struct bhndb_softc	*sc;				\ 	struct bhndb_dw_alloc	*dwa;				\ 	struct resource		*io_res;			\ 	bus_size_t		 io_offset;			\ 								\ 	sc = device_get_softc(dev);				\ 								\ 	BHNDB_LOCK(sc);						\ 	dwa = bhndb_io_resource(sc, rman_get_start(r->res) +	\ 	    offset, _io_size,&io_offset);			\ 	io_res = dwa->parent_res;				\ 								\ 	KASSERT(!r->direct,					\ 	    ("bhnd_bus slow path used for direct resource"));	\ 								\ 	KASSERT(rman_get_flags(io_res)& RF_ACTIVE,		\ 	    ("i/o resource is not active"));
end_define

begin_define
define|#
directive|define
name|BHNDB_IO_COMMON_TEARDOWN
parameter_list|()
define|\
value|BHNDB_UNLOCK(sc);
end_define

begin_comment
comment|/* Defines a bhndb_bus_read_* method implementation */
end_comment

begin_define
define|#
directive|define
name|BHNDB_IO_READ
parameter_list|(
name|_type
parameter_list|,
name|_name
parameter_list|)
define|\
value|static _type							\ bhndb_bus_read_ ## _name (device_t dev, device_t child,		\     struct bhnd_resource *r, bus_size_t offset)			\ {								\ 	_type v;						\ 	BHNDB_IO_COMMON_SETUP(sizeof(_type));			\ 	v = bus_read_ ## _name (io_res, io_offset);		\ 	BHNDB_IO_COMMON_TEARDOWN();				\ 								\ 	return (v);						\ }
end_define

begin_comment
comment|/* Defines a bhndb_bus_write_* method implementation */
end_comment

begin_define
define|#
directive|define
name|BHNDB_IO_WRITE
parameter_list|(
name|_type
parameter_list|,
name|_name
parameter_list|)
define|\
value|static void							\ bhndb_bus_write_ ## _name (device_t dev, device_t child,	\     struct bhnd_resource *r, bus_size_t offset, _type value)	\ {								\ 	BHNDB_IO_COMMON_SETUP(sizeof(_type));			\ 	bus_write_ ## _name (io_res, io_offset, value);		\ 	BHNDB_IO_COMMON_TEARDOWN();				\ }
end_define

begin_comment
comment|/* Defines a bhndb_bus_(read|write|set)_(multi|region)_* method */
end_comment

begin_define
define|#
directive|define
name|BHNDB_IO_MISC
parameter_list|(
name|_type
parameter_list|,
name|_ptr
parameter_list|,
name|_op
parameter_list|,
name|_size
parameter_list|)
define|\
value|static void							\ bhndb_bus_ ## _op ## _ ## _size (device_t dev,			\     device_t child, struct bhnd_resource *r, bus_size_t offset,	\     _type _ptr datap, bus_size_t count)				\ {								\ 	BHNDB_IO_COMMON_SETUP(sizeof(_type) * count);		\ 	bus_ ## _op ## _ ## _size (io_res, io_offset,		\ 	    datap, count);					\ 	BHNDB_IO_COMMON_TEARDOWN();				\ }
end_define

begin_comment
comment|/* Defines a complete set of read/write methods */
end_comment

begin_define
define|#
directive|define
name|BHNDB_IO_METHODS
parameter_list|(
name|_type
parameter_list|,
name|_size
parameter_list|)
define|\
value|BHNDB_IO_READ(_type, _size)				\ 	BHNDB_IO_WRITE(_type, _size)				\ 								\ 	BHNDB_IO_READ(_type, stream_ ## _size)			\ 	BHNDB_IO_WRITE(_type, stream_ ## _size)			\ 								\ 	BHNDB_IO_MISC(_type, *, read_multi, _size)		\ 	BHNDB_IO_MISC(_type, *, write_multi, _size)		\ 								\ 	BHNDB_IO_MISC(_type, *, read_multi_stream, _size)	\ 	BHNDB_IO_MISC(_type, *, write_multi_stream, _size)	\ 								\ 	BHNDB_IO_MISC(_type,  , set_multi, _size)		\ 	BHNDB_IO_MISC(_type,  , set_region, _size)		\ 	BHNDB_IO_MISC(_type, *, read_region, _size)		\ 	BHNDB_IO_MISC(_type, *, write_region, _size)		\ 								\ 	BHNDB_IO_MISC(_type, *, read_region_stream, _size)	\ 	BHNDB_IO_MISC(_type, *, write_region_stream, _size)
end_define

begin_expr_stmt
name|BHNDB_IO_METHODS
argument_list|(
name|uint8_t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BHNDB_IO_METHODS
argument_list|(
name|uint16_t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BHNDB_IO_METHODS
argument_list|(
name|uint32_t
argument_list|,
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * Default bhndb(4) implementation of BHND_BUS_BARRIER().  */
end_comment

begin_function
specifier|static
name|void
name|bhndb_bus_barrier
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|bhnd_resource
modifier|*
name|r
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|bus_size_t
name|length
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|BHNDB_IO_COMMON_SETUP
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|bus_barrier
argument_list|(
name|io_res
argument_list|,
name|io_offset
operator|+
name|offset
argument_list|,
name|length
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|BHNDB_IO_COMMON_TEARDOWN
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Default bhndb(4) implementation of BUS_SETUP_INTR().  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_filter_t
name|filter
parameter_list|,
name|driver_intr_t
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
comment|// TODO
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhndb(4) implementation of BUS_TEARDOWN_INTR().  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
comment|// TODO
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhndb(4) implementation of BUS_CONFIG_INTR().  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_config_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|irq
parameter_list|,
name|enum
name|intr_trigger
name|trig
parameter_list|,
name|enum
name|intr_polarity
name|pol
parameter_list|)
block|{
comment|// TODO
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhndb(4) implementation of BUS_BIND_INTR().  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_bind_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
comment|// TODO
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhndb(4) implementation of BUS_DESCRIBE_INTR().  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_describe_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|,
specifier|const
name|char
modifier|*
name|descr
parameter_list|)
block|{
comment|// TODO
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Default bhndb(4) implementation of BUS_GET_DMA_TAG().  */
end_comment

begin_function
specifier|static
name|bus_dma_tag_t
name|bhndb_get_dma_tag
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
comment|// TODO
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|bhndb_methods
index|[]
init|=
block|{
comment|/* Device interface */
block|\
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|bhndb_generic_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bhndb_generic_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bhndb_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bhndb_generic_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_probe_nomatch
argument_list|,
name|bhndb_probe_nomatch
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bhndb_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_pnpinfo_str
argument_list|,
name|bhndb_child_pnpinfo_str
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_location_str
argument_list|,
name|bhndb_child_location_str
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_add_child
argument_list|,
name|bhndb_add_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_deleted
argument_list|,
name|bhndb_child_deleted
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|bhndb_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|bhndb_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bhndb_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|bhndb_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|bhndb_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|bhndb_teardown_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_config_intr
argument_list|,
name|bhndb_config_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_bind_intr
argument_list|,
name|bhndb_bind_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_describe_intr
argument_list|,
name|bhndb_describe_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_dma_tag
argument_list|,
name|bhndb_get_dma_tag
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_adjust_resource
argument_list|,
name|bhndb_adjust_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_set_resource
argument_list|,
name|bus_generic_rl_set_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource
argument_list|,
name|bus_generic_rl_get_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_delete_resource
argument_list|,
name|bus_generic_rl_delete_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource_list
argument_list|,
name|bhndb_get_resource_list
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|bhndb_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|bhndb_write_ivar
argument_list|)
block|,
comment|/* BHNDB interface */
name|DEVMETHOD
argument_list|(
name|bhndb_get_chipid
argument_list|,
name|bhndb_get_chipid
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhndb_is_core_disabled
argument_list|,
name|bhndb_is_core_disabled
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhndb_get_hostb_core
argument_list|,
name|bhndb_get_hostb_core
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhndb_suspend_resource
argument_list|,
name|bhndb_suspend_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhndb_resume_resource
argument_list|,
name|bhndb_resume_resource
argument_list|)
block|,
comment|/* BHND interface */
name|DEVMETHOD
argument_list|(
name|bhnd_bus_get_chipid
argument_list|,
name|bhndb_get_chipid
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_activate_resource
argument_list|,
name|bhndb_activate_bhnd_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_deactivate_resource
argument_list|,
name|bhndb_deactivate_bhnd_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_get_nvram_var
argument_list|,
name|bhnd_bus_generic_get_nvram_var
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_1
argument_list|,
name|bhndb_bus_read_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_2
argument_list|,
name|bhndb_bus_read_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_4
argument_list|,
name|bhndb_bus_read_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_1
argument_list|,
name|bhndb_bus_write_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_2
argument_list|,
name|bhndb_bus_write_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_4
argument_list|,
name|bhndb_bus_write_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_stream_1
argument_list|,
name|bhndb_bus_read_stream_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_stream_2
argument_list|,
name|bhndb_bus_read_stream_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_stream_4
argument_list|,
name|bhndb_bus_read_stream_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_stream_1
argument_list|,
name|bhndb_bus_write_stream_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_stream_2
argument_list|,
name|bhndb_bus_write_stream_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_stream_4
argument_list|,
name|bhndb_bus_write_stream_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_multi_1
argument_list|,
name|bhndb_bus_read_multi_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_multi_2
argument_list|,
name|bhndb_bus_read_multi_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_multi_4
argument_list|,
name|bhndb_bus_read_multi_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_multi_1
argument_list|,
name|bhndb_bus_write_multi_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_multi_2
argument_list|,
name|bhndb_bus_write_multi_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_multi_4
argument_list|,
name|bhndb_bus_write_multi_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_multi_stream_1
argument_list|,
name|bhndb_bus_read_multi_stream_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_multi_stream_2
argument_list|,
name|bhndb_bus_read_multi_stream_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_multi_stream_4
argument_list|,
name|bhndb_bus_read_multi_stream_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_multi_stream_1
argument_list|,
name|bhndb_bus_write_multi_stream_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_multi_stream_2
argument_list|,
name|bhndb_bus_write_multi_stream_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_multi_stream_4
argument_list|,
name|bhndb_bus_write_multi_stream_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_set_multi_1
argument_list|,
name|bhndb_bus_set_multi_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_set_multi_2
argument_list|,
name|bhndb_bus_set_multi_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_set_multi_4
argument_list|,
name|bhndb_bus_set_multi_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_set_region_1
argument_list|,
name|bhndb_bus_set_region_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_set_region_2
argument_list|,
name|bhndb_bus_set_region_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_set_region_4
argument_list|,
name|bhndb_bus_set_region_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_region_1
argument_list|,
name|bhndb_bus_read_region_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_region_2
argument_list|,
name|bhndb_bus_read_region_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_region_4
argument_list|,
name|bhndb_bus_read_region_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_region_1
argument_list|,
name|bhndb_bus_write_region_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_region_2
argument_list|,
name|bhndb_bus_write_region_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_region_4
argument_list|,
name|bhndb_bus_write_region_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_region_stream_1
argument_list|,
name|bhndb_bus_read_region_stream_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_region_stream_2
argument_list|,
name|bhndb_bus_read_region_stream_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_read_region_stream_4
argument_list|,
name|bhndb_bus_read_region_stream_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_region_stream_1
argument_list|,
name|bhndb_bus_write_region_stream_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_region_stream_2
argument_list|,
name|bhndb_bus_write_region_stream_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_write_region_stream_4
argument_list|,
name|bhndb_bus_write_region_stream_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bhnd_bus_barrier
argument_list|,
name|bhndb_bus_barrier
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|bhndb_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|bhndb
argument_list|,
name|bhndb_driver
argument_list|,
name|bhndb_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bhndb_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|bhndb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bhndb
argument_list|,
name|bhnd
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

