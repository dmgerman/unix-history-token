begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 Landon Fuller<landon@landonf.org>  * Copyright (c) 2017 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by Landon Fuller  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|"bhndb_private.h"
end_include

begin_include
include|#
directive|include
file|"bhndbvar.h"
end_include

begin_function_decl
specifier|static
name|int
name|bhndb_dma_tag_create
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|bus_dma_tag_t
name|parent_dmat
parameter_list|,
specifier|const
name|struct
name|bhnd_dma_translation
modifier|*
name|translation
parameter_list|,
name|bus_dma_tag_t
modifier|*
name|dmat
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Attach a BHND bridge device to @p parent.  *   * @param parent A parent PCI device.  * @param[out] bhndb On success, the probed and attached bhndb bridge device.  * @param unit The device unit number, or -1 to select the next available unit  * number.  *   * @retval 0 success  * @retval non-zero Failed to attach the bhndb device.  */
end_comment

begin_function
name|int
name|bhndb_attach_bridge
parameter_list|(
name|device_t
name|parent
parameter_list|,
name|device_t
modifier|*
name|bhndb
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
operator|*
name|bhndb
operator|=
name|device_add_child
argument_list|(
name|parent
argument_list|,
literal|"bhndb"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bhndb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|error
operator|=
name|device_probe_and_attach
argument_list|(
operator|*
name|bhndb
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|device_delete_child
argument_list|(
name|parent
argument_list|,
operator|*
name|bhndb
argument_list|)
operator|)
condition|)
name|device_printf
argument_list|(
name|parent
argument_list|,
literal|"failed to detach bhndb child\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Call BHNDB_SUSPEND_RESOURCE() for all resources in @p rl.  */
end_comment

begin_function
specifier|static
name|void
name|bhndb_do_suspend_resources
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|resource_list
modifier|*
name|rl
parameter_list|)
block|{
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
comment|/* Suspend all child resources. */
name|STAILQ_FOREACH
argument_list|(
argument|rle
argument_list|,
argument|rl
argument_list|,
argument|link
argument_list|)
block|{
comment|/* Skip non-allocated resources */
if|if
condition|(
name|rle
operator|->
name|res
operator|==
name|NULL
condition|)
continue|continue;
name|BHNDB_SUSPEND_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|rle
operator|->
name|type
argument_list|,
name|rle
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BUS_RESUME_CHILD() on bridged  * bhnd(4) buses.  *   * This implementation of BUS_RESUME_CHILD() uses BUS_GET_RESOURCE_LIST()  * to find the child's resources and call BHNDB_SUSPEND_RESOURCE() for all  * child resources, ensuring that the device's allocated bridge resources  * will be available to other devices during bus resumption.  *   * Before suspending any resources, @p child is suspended by   * calling bhnd_generic_suspend_child().  *   * If @p child is not a direct child of @p dev, suspension is delegated to  * the @p dev parent.  */
end_comment

begin_function
name|int
name|bhnd_generic_br_suspend_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
name|BUS_SUSPEND_CHILD
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_is_suspended
argument_list|(
name|child
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Suspend the child device */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_generic_suspend_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Fetch the resource list. If none, there's nothing else to do */
name|rl
operator|=
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Suspend all child resources. */
name|bhndb_do_suspend_resources
argument_list|(
name|dev
argument_list|,
name|rl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BUS_RESUME_CHILD() on bridged  * bhnd(4) bus devices.  *   * This implementation of BUS_RESUME_CHILD() uses BUS_GET_RESOURCE_LIST()  * to find the child's resources and call BHNDB_RESUME_RESOURCE() for all  * child resources, before delegating to bhnd_generic_resume_child().  *   * If resource resumption fails, @p child will not be resumed.  *   * If @p child is not a direct child of @p dev, suspension is delegated to  * the @p dev parent.  */
end_comment

begin_function
name|int
name|bhnd_generic_br_resume_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
name|BUS_RESUME_CHILD
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|device_is_suspended
argument_list|(
name|child
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Fetch the resource list. If none, there's nothing else to do */
name|rl
operator|=
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|==
name|NULL
condition|)
return|return
operator|(
name|bhnd_generic_resume_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
operator|)
return|;
comment|/* Resume all resources */
name|STAILQ_FOREACH
argument_list|(
argument|rle
argument_list|,
argument|rl
argument_list|,
argument|link
argument_list|)
block|{
comment|/* Skip non-allocated resources */
if|if
condition|(
name|rle
operator|->
name|res
operator|==
name|NULL
condition|)
continue|continue;
name|error
operator|=
name|BHNDB_RESUME_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|rle
operator|->
name|type
argument_list|,
name|rle
operator|->
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* Put all resources back into a suspend state */
name|bhndb_do_suspend_resources
argument_list|(
name|dev
argument_list|,
name|rl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* Now that all resources are resumed, resume child */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_generic_resume_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
operator|)
condition|)
block|{
comment|/* Put all resources back into a suspend state */
name|bhndb_do_suspend_resources
argument_list|(
name|dev
argument_list|,
name|rl
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find a host resource of @p type that maps the given range.  *   * @param hr The resource state to search.  * @param type The resource type to search for (see SYS_RES_*).  * @param start The start address of the range to search for.  * @param count The size of the range to search for.  *   * @retval resource the host resource containing the requested range.  * @retval NULL if no resource containing the requested range can be found.  */
end_comment

begin_function
name|struct
name|resource
modifier|*
name|bhndb_host_resource_for_range
parameter_list|(
name|struct
name|bhndb_host_resources
modifier|*
name|hr
parameter_list|,
name|int
name|type
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|count
parameter_list|)
block|{
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|hr
operator|->
name|resource_specs
index|[
name|i
index|]
operator|.
name|type
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|resource
modifier|*
name|r
init|=
name|hr
operator|->
name|resources
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|hr
operator|->
name|resource_specs
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|type
condition|)
continue|continue;
comment|/* Verify range */
if|if
condition|(
name|rman_get_start
argument_list|(
name|r
argument_list|)
operator|>
name|start
condition|)
continue|continue;
if|if
condition|(
name|rman_get_end
argument_list|(
name|r
argument_list|)
operator|<
operator|(
name|start
operator|+
name|count
operator|-
literal|1
operator|)
condition|)
continue|continue;
return|return
operator|(
name|r
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find a host resource of that matches the given register window definition.  *   * @param hr The resource state to search.  * @param win A register window definition.  *   * @retval resource the host resource corresponding to @p win.  * @retval NULL if no resource corresponding to @p win can be found.  */
end_comment

begin_function
name|struct
name|resource
modifier|*
name|bhndb_host_resource_for_regwin
parameter_list|(
name|struct
name|bhndb_host_resources
modifier|*
name|hr
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|win
parameter_list|)
block|{
specifier|const
name|struct
name|resource_spec
modifier|*
name|rspecs
decl_stmt|;
name|rspecs
operator|=
name|hr
operator|->
name|resource_specs
expr_stmt|;
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|rspecs
index|[
name|i
index|]
operator|.
name|type
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|win
operator|->
name|res
operator|.
name|type
operator|!=
name|rspecs
index|[
name|i
index|]
operator|.
name|type
condition|)
continue|continue;
if|if
condition|(
name|win
operator|->
name|res
operator|.
name|rid
operator|!=
name|rspecs
index|[
name|i
index|]
operator|.
name|rid
condition|)
continue|continue;
comment|/* Found declared resource */
return|return
operator|(
name|hr
operator|->
name|resources
index|[
name|i
index|]
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|hr
operator|->
name|owner
argument_list|,
literal|"missing regwin resource spec "
literal|"(type=%d, rid=%d)\n"
argument_list|,
name|win
operator|->
name|res
operator|.
name|type
argument_list|,
name|win
operator|->
name|res
operator|.
name|rid
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Allocate and initialize a new resource state structure.  *   * @param dev The bridge device.  * @param parent_dev The parent device from which host resources should be   * allocated.  * @param cfg The hardware configuration to be used.  */
end_comment

begin_function
name|struct
name|bhndb_resources
modifier|*
name|bhndb_alloc_resources
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|parent_dev
parameter_list|,
specifier|const
name|struct
name|bhndb_hwcfg
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|bhndb_resources
modifier|*
name|r
decl_stmt|;
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|win
decl_stmt|;
name|bus_size_t
name|last_window_size
decl_stmt|;
name|int
name|rnid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bool
name|free_ht_mem
decl_stmt|,
name|free_br_mem
decl_stmt|,
name|free_br_irq
decl_stmt|;
name|free_ht_mem
operator|=
name|false
expr_stmt|;
name|free_br_mem
operator|=
name|false
expr_stmt|;
name|free_br_irq
operator|=
name|false
expr_stmt|;
name|r
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Basic initialization */
name|r
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|r
operator|->
name|cfg
operator|=
name|cfg
expr_stmt|;
name|r
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|min_prio
operator|=
name|BHNDB_PRIORITY_NONE
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|r
operator|->
name|bus_regions
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|r
operator|->
name|bus_intrs
argument_list|)
expr_stmt|;
comment|/* Initialize host address space resource manager. */
name|r
operator|->
name|ht_mem_rman
operator|.
name|rm_start
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|ht_mem_rman
operator|.
name|rm_end
operator|=
operator|~
literal|0
expr_stmt|;
name|r
operator|->
name|ht_mem_rman
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|r
operator|->
name|ht_mem_rman
operator|.
name|rm_descr
operator|=
literal|"BHNDB host memory"
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|rman_init
argument_list|(
operator|&
name|r
operator|->
name|ht_mem_rman
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|r
operator|->
name|dev
argument_list|,
literal|"could not initialize ht_mem_rman\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|free_ht_mem
operator|=
name|true
expr_stmt|;
comment|/* Initialize resource manager for the bridged address space. */
name|r
operator|->
name|br_mem_rman
operator|.
name|rm_start
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|br_mem_rman
operator|.
name|rm_end
operator|=
name|BUS_SPACE_MAXADDR_32BIT
expr_stmt|;
name|r
operator|->
name|br_mem_rman
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|r
operator|->
name|br_mem_rman
operator|.
name|rm_descr
operator|=
literal|"BHNDB bridged memory"
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|rman_init
argument_list|(
operator|&
name|r
operator|->
name|br_mem_rman
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|r
operator|->
name|dev
argument_list|,
literal|"could not initialize br_mem_rman\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|free_br_mem
operator|=
name|true
expr_stmt|;
name|error
operator|=
name|rman_manage_region
argument_list|(
operator|&
name|r
operator|->
name|br_mem_rman
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|r
operator|->
name|dev
argument_list|,
literal|"could not configure br_mem_rman\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* Initialize resource manager for the bridged interrupt controller. */
name|r
operator|->
name|br_irq_rman
operator|.
name|rm_start
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|br_irq_rman
operator|.
name|rm_end
operator|=
name|RM_MAX_END
expr_stmt|;
name|r
operator|->
name|br_irq_rman
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|r
operator|->
name|br_irq_rman
operator|.
name|rm_descr
operator|=
literal|"BHNDB bridged interrupts"
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|rman_init
argument_list|(
operator|&
name|r
operator|->
name|br_irq_rman
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|r
operator|->
name|dev
argument_list|,
literal|"could not initialize br_irq_rman\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|free_br_irq
operator|=
name|true
expr_stmt|;
name|error
operator|=
name|rman_manage_region
argument_list|(
operator|&
name|r
operator|->
name|br_irq_rman
argument_list|,
literal|0
argument_list|,
name|RM_MAX_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|r
operator|->
name|dev
argument_list|,
literal|"could not configure br_irq_rman\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* Fetch the dynamic regwin count and verify that it does not exceed 	 * what is representable via our freelist bitstring. */
name|r
operator|->
name|dwa_count
operator|=
name|bhndb_regwin_count
argument_list|(
name|cfg
operator|->
name|register_windows
argument_list|,
name|BHNDB_REGWIN_T_DYN
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|dwa_count
operator|>=
name|INT_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|r
operator|->
name|dev
argument_list|,
literal|"max dynamic regwin count exceeded\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* Allocate the dynamic window allocation table. */
name|r
operator|->
name|dw_alloc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|r
operator|->
name|dw_alloc
index|[
literal|0
index|]
argument_list|)
operator|*
name|r
operator|->
name|dwa_count
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|dw_alloc
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
comment|/* Allocate the dynamic window allocation freelist */
name|r
operator|->
name|dwa_freelist
operator|=
name|bit_alloc
argument_list|(
name|r
operator|->
name|dwa_count
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|dwa_freelist
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
comment|/* Initialize the dynamic window table */
name|rnid
operator|=
literal|0
expr_stmt|;
name|last_window_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|win
operator|=
name|cfg
operator|->
name|register_windows
init|;
name|win
operator|->
name|win_type
operator|!=
name|BHNDB_REGWIN_T_INVALID
condition|;
name|win
operator|++
control|)
block|{
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
decl_stmt|;
comment|/* Skip non-DYN windows */
if|if
condition|(
name|win
operator|->
name|win_type
operator|!=
name|BHNDB_REGWIN_T_DYN
condition|)
continue|continue;
comment|/* Validate the window size */
if|if
condition|(
name|win
operator|->
name|win_size
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|r
operator|->
name|dev
argument_list|,
literal|"ignoring zero-length dynamic "
literal|"register window\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|last_window_size
operator|==
literal|0
condition|)
block|{
name|last_window_size
operator|=
name|win
operator|->
name|win_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_window_size
operator|!=
name|win
operator|->
name|win_size
condition|)
block|{
comment|/*  			 * No existing hardware should trigger this. 			 *  			 * If you run into this in the future, the dynamic 			 * window allocator and the resource priority system 			 * will need to be extended to support multiple register 			 * window allocation pools.  			 */
name|device_printf
argument_list|(
name|r
operator|->
name|dev
argument_list|,
literal|"devices that vend multiple "
literal|"dynamic register window sizes are not currently "
literal|"supported\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|dwa
operator|=
operator|&
name|r
operator|->
name|dw_alloc
index|[
name|rnid
index|]
expr_stmt|;
name|dwa
operator|->
name|win
operator|=
name|win
expr_stmt|;
name|dwa
operator|->
name|parent_res
operator|=
name|NULL
expr_stmt|;
name|dwa
operator|->
name|rnid
operator|=
name|rnid
expr_stmt|;
name|dwa
operator|->
name|target
operator|=
literal|0x0
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|dwa
operator|->
name|refs
argument_list|)
expr_stmt|;
name|rnid
operator|++
expr_stmt|;
block|}
comment|/* Allocate host resources */
name|error
operator|=
name|bhndb_alloc_host_resources
argument_list|(
operator|&
name|r
operator|->
name|res
argument_list|,
name|dev
argument_list|,
name|parent_dev
argument_list|,
name|r
operator|->
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|r
operator|->
name|dev
argument_list|,
literal|"could not allocate host resources on %s: %d\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|parent_dev
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* Populate (and validate) parent resource references for all 	 * dynamic windows */
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|r
operator|->
name|dwa_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
decl_stmt|;
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|win
decl_stmt|;
name|dwa
operator|=
operator|&
name|r
operator|->
name|dw_alloc
index|[
name|i
index|]
expr_stmt|;
name|win
operator|=
name|dwa
operator|->
name|win
expr_stmt|;
comment|/* Find and validate corresponding resource. */
name|dwa
operator|->
name|parent_res
operator|=
name|bhndb_host_resource_for_regwin
argument_list|(
name|r
operator|->
name|res
argument_list|,
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwa
operator|->
name|parent_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|r
operator|->
name|dev
argument_list|,
literal|"no host resource found for %u "
literal|"register window with offset %#jx and "
literal|"size %#jx\n"
argument_list|,
name|win
operator|->
name|win_type
argument_list|,
operator|(
name|uintmax_t
operator|)
name|win
operator|->
name|win_offset
argument_list|,
operator|(
name|uintmax_t
operator|)
name|win
operator|->
name|win_size
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
name|rman_get_size
argument_list|(
name|dwa
operator|->
name|parent_res
argument_list|)
operator|<
name|win
operator|->
name|win_offset
operator|+
name|win
operator|->
name|win_size
condition|)
block|{
name|device_printf
argument_list|(
name|r
operator|->
name|dev
argument_list|,
literal|"resource %d too small for "
literal|"register window with offset %llx and size %llx\n"
argument_list|,
name|rman_get_rid
argument_list|(
name|dwa
operator|->
name|parent_res
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|win
operator|->
name|win_offset
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|win
operator|->
name|win_size
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
block|}
comment|/* Add allocated memory resources to our host memory resource manager */
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|r
operator|->
name|res
operator|->
name|resource_specs
index|[
name|i
index|]
operator|.
name|type
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
comment|/* skip non-memory resources */
if|if
condition|(
name|r
operator|->
name|res
operator|->
name|resource_specs
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|SYS_RES_MEMORY
condition|)
continue|continue;
comment|/* add host resource to set of managed regions */
name|res
operator|=
name|r
operator|->
name|res
operator|->
name|resources
index|[
name|i
index|]
expr_stmt|;
name|error
operator|=
name|rman_manage_region
argument_list|(
operator|&
name|r
operator|->
name|ht_mem_rman
argument_list|,
name|rman_get_start
argument_list|(
name|res
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|r
operator|->
name|dev
argument_list|,
literal|"could not register host memory region with "
literal|"ht_mem_rman: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
block|}
return|return
operator|(
name|r
operator|)
return|;
name|failed
label|:
if|if
condition|(
name|free_ht_mem
condition|)
name|rman_fini
argument_list|(
operator|&
name|r
operator|->
name|ht_mem_rman
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_br_mem
condition|)
name|rman_fini
argument_list|(
operator|&
name|r
operator|->
name|br_mem_rman
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_br_irq
condition|)
name|rman_fini
argument_list|(
operator|&
name|r
operator|->
name|br_irq_rman
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|dw_alloc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|r
operator|->
name|dw_alloc
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|dwa_freelist
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|r
operator|->
name|dwa_freelist
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bhndb_release_host_resources
argument_list|(
name|r
operator|->
name|res
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Create a new DMA tag for the given @p translation.  *  * @param	dev		The bridge device.  * @param	parent_dmat	The parent DMA tag, or NULL if none.  * @param	translation	The DMA translation for which a DMA tag will  *				be created.  * @param[out]	dmat		On success, the newly created DMA tag.  *   * @retval 0		success  * @retval non-zero	if creating the new DMA tag otherwise fails, a regular  *			unix error code will be returned.  */
end_comment

begin_function
specifier|static
name|int
name|bhndb_dma_tag_create
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|bus_dma_tag_t
name|parent_dmat
parameter_list|,
specifier|const
name|struct
name|bhnd_dma_translation
modifier|*
name|translation
parameter_list|,
name|bus_dma_tag_t
modifier|*
name|dmat
parameter_list|)
block|{
name|bus_dma_tag_t
name|translation_tag
decl_stmt|;
name|bhnd_addr_t
name|dt_mask
decl_stmt|;
name|bus_addr_t
name|boundary
decl_stmt|;
name|bus_addr_t
name|lowaddr
decl_stmt|,
name|highaddr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|highaddr
operator|=
name|BUS_SPACE_MAXADDR
expr_stmt|;
name|boundary
operator|=
literal|0
expr_stmt|;
comment|/* Determine full addressable mask */
name|dt_mask
operator|=
operator|(
name|translation
operator|->
name|addr_mask
operator||
name|translation
operator|->
name|addrext_mask
operator|)
expr_stmt|;
name|KASSERT
argument_list|(
name|dt_mask
operator|!=
literal|0
argument_list|,
operator|(
literal|"DMA addr_mask invalid: %#jx"
operator|,
operator|(
name|uintmax_t
operator|)
name|dt_mask
operator|)
argument_list|)
expr_stmt|;
comment|/* (addr_mask|addrext_mask) is our maximum supported address */
name|lowaddr
operator|=
name|MIN
argument_list|(
name|dt_mask
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|)
expr_stmt|;
comment|/* Do we need to to avoid crossing a DMA translation window boundary? */
if|if
condition|(
name|translation
operator|->
name|addr_mask
operator|<
name|BUS_SPACE_MAXADDR
condition|)
block|{
comment|/* round down to nearest power of two */
name|boundary
operator|=
name|translation
operator|->
name|addr_mask
operator|&
operator|(
operator|~
literal|1ULL
operator|)
expr_stmt|;
block|}
comment|/* Create our DMA tag */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|parent_dmat
argument_list|,
literal|1
argument_list|,
comment|/* alignment */
name|boundary
argument_list|,
name|lowaddr
argument_list|,
name|highaddr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE
argument_list|,
literal|0
argument_list|,
comment|/* maxsize, nsegments */
name|BUS_SPACE_MAXSIZE
argument_list|,
literal|0
argument_list|,
comment|/* maxsegsize, flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|translation_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to create bridge DMA tag: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|dmat
operator|=
name|translation_tag
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Deallocate the given bridge resource structure and any associated resources.  *   * @param br Resource state to be deallocated.  */
end_comment

begin_function
name|void
name|bhndb_free_resources
parameter_list|(
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|)
block|{
name|struct
name|bhndb_region
modifier|*
name|region
decl_stmt|,
modifier|*
name|r_next
decl_stmt|;
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
decl_stmt|;
name|struct
name|bhndb_dw_rentry
modifier|*
name|dwr
decl_stmt|,
modifier|*
name|dwr_next
decl_stmt|;
name|struct
name|bhndb_intr_handler
modifier|*
name|ih
decl_stmt|;
name|bool
name|leaked_regions
decl_stmt|,
name|leaked_intrs
decl_stmt|;
name|leaked_regions
operator|=
name|false
expr_stmt|;
name|leaked_intrs
operator|=
name|false
expr_stmt|;
comment|/* No window regions may still be held */
if|if
condition|(
operator|!
name|bhndb_dw_all_free
argument_list|(
name|br
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|br
operator|->
name|dwa_count
condition|;
name|i
operator|++
control|)
block|{
name|dwa
operator|=
operator|&
name|br
operator|->
name|dw_alloc
index|[
name|i
index|]
expr_stmt|;
comment|/* Skip free dynamic windows */
if|if
condition|(
name|bhndb_dw_is_free
argument_list|(
name|br
argument_list|,
name|dwa
argument_list|)
condition|)
continue|continue;
name|device_printf
argument_list|(
name|br
operator|->
name|dev
argument_list|,
literal|"leaked dynamic register window %d\n"
argument_list|,
name|dwa
operator|->
name|rnid
argument_list|)
expr_stmt|;
name|leaked_regions
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* There should be no interrupt handlers still registered */
name|STAILQ_FOREACH
argument_list|(
argument|ih
argument_list|,
argument|&br->bus_intrs
argument_list|,
argument|ih_link
argument_list|)
block|{
name|device_printf
argument_list|(
name|br
operator|->
name|dev
argument_list|,
literal|"interrupt handler leaked %p\n"
argument_list|,
name|ih
operator|->
name|ih_cookiep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|leaked_intrs
operator|||
name|leaked_regions
condition|)
block|{
name|panic
argument_list|(
literal|"leaked%s%s"
argument_list|,
name|leaked_intrs
condition|?
literal|" active interrupts"
else|:
literal|""
argument_list|,
name|leaked_regions
condition|?
literal|" active register windows"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* Release host resources allocated through our parent. */
if|if
condition|(
name|br
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bhndb_release_host_resources
argument_list|(
name|br
operator|->
name|res
argument_list|)
expr_stmt|;
comment|/* Clean up resource reservations */
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|br
operator|->
name|dwa_count
condition|;
name|i
operator|++
control|)
block|{
name|dwa
operator|=
operator|&
name|br
operator|->
name|dw_alloc
index|[
name|i
index|]
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|dwr
argument_list|,
argument|&dwa->refs
argument_list|,
argument|dw_link
argument_list|,
argument|dwr_next
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|dwr
argument_list|,
name|dw_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dwr
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Release bus regions */
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|region
argument_list|,
argument|&br->bus_regions
argument_list|,
argument|link
argument_list|,
argument|r_next
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|br
operator|->
name|bus_regions
argument_list|,
name|region
argument_list|,
name|bhndb_region
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|region
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
comment|/* Release our resource managers */
name|rman_fini
argument_list|(
operator|&
name|br
operator|->
name|ht_mem_rman
argument_list|)
expr_stmt|;
name|rman_fini
argument_list|(
operator|&
name|br
operator|->
name|br_mem_rman
argument_list|)
expr_stmt|;
name|rman_fini
argument_list|(
operator|&
name|br
operator|->
name|br_irq_rman
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|br
operator|->
name|dw_alloc
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|br
operator|->
name|dwa_freelist
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Allocate host bus resources defined by @p hwcfg.  *   * On success, the caller assumes ownership of the allocated host resources,  * which must be freed via bhndb_release_host_resources().  *  * @param[out]	resources	On success, the allocated host resources.  * @param	dev		The bridge device.  * @param	parent_dev	The parent device from which host resources  *				should be allocated (e.g. via  *				bus_alloc_resources()).  * @param	hwcfg		The hardware configuration defining the host  *				resources to be allocated  */
end_comment

begin_function
name|int
name|bhndb_alloc_host_resources
parameter_list|(
name|struct
name|bhndb_host_resources
modifier|*
modifier|*
name|resources
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|device_t
name|parent_dev
parameter_list|,
specifier|const
name|struct
name|bhndb_hwcfg
modifier|*
name|hwcfg
parameter_list|)
block|{
name|struct
name|bhndb_host_resources
modifier|*
name|hr
decl_stmt|;
specifier|const
name|struct
name|bhnd_dma_translation
modifier|*
name|dt
decl_stmt|;
name|bus_dma_tag_t
name|parent_dmat
decl_stmt|;
name|size_t
name|nres
decl_stmt|,
name|ndt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|parent_dmat
operator|=
name|bus_get_dma_tag
argument_list|(
name|parent_dev
argument_list|)
expr_stmt|;
name|hr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hr
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|hr
operator|->
name|owner
operator|=
name|parent_dev
expr_stmt|;
name|hr
operator|->
name|cfg
operator|=
name|hwcfg
expr_stmt|;
name|hr
operator|->
name|resource_specs
operator|=
name|NULL
expr_stmt|;
name|hr
operator|->
name|resources
operator|=
name|NULL
expr_stmt|;
name|hr
operator|->
name|dma_tags
operator|=
name|NULL
expr_stmt|;
name|hr
operator|->
name|num_dma_tags
operator|=
literal|0
expr_stmt|;
comment|/* Determine our bridge resource count from the hardware config. */
name|nres
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|hwcfg
operator|->
name|resource_specs
index|[
name|i
index|]
operator|.
name|type
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|nres
operator|++
expr_stmt|;
comment|/* Determine the total count and validate our DMA translation table. */
name|ndt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dt
operator|=
name|hwcfg
operator|->
name|dma_translations
init|;
name|dt
operator|!=
name|NULL
operator|&&
operator|!
name|BHND_DMA_IS_TRANSLATION_TABLE_END
argument_list|(
name|dt
argument_list|)
condition|;
name|dt
operator|++
control|)
block|{
comment|/* Validate the defined translation */
if|if
condition|(
operator|(
name|dt
operator|->
name|base_addr
operator|&
name|dt
operator|->
name|addr_mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid DMA translation; base "
literal|"address %#jx overlaps address mask %#jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dt
operator|->
name|base_addr
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dt
operator|->
name|addr_mask
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
operator|(
name|dt
operator|->
name|addrext_mask
operator|&
name|dt
operator|->
name|addr_mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid DMA translation; addrext "
literal|"mask %#jx overlaps address mask %#jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dt
operator|->
name|addrext_mask
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dt
operator|->
name|addr_mask
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* Increment our entry count */
name|ndt
operator|++
expr_stmt|;
block|}
comment|/* Allocate our DMA tags */
name|hr
operator|->
name|dma_tags
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hr
operator|->
name|dma_tags
argument_list|)
operator|*
name|ndt
argument_list|,
name|M_BHND
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ndt
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|bhndb_dma_tag_create
argument_list|(
name|dev
argument_list|,
name|parent_dmat
argument_list|,
operator|&
name|hwcfg
operator|->
name|dma_translations
index|[
name|i
index|]
argument_list|,
operator|&
name|hr
operator|->
name|dma_tags
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
name|hr
operator|->
name|num_dma_tags
operator|++
expr_stmt|;
block|}
comment|/* Allocate space for a non-const copy of our resource_spec 	 * table; this will be updated with the RIDs assigned by 	 * bus_alloc_resources. */
name|hr
operator|->
name|resource_specs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hr
operator|->
name|resource_specs
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
name|nres
operator|+
literal|1
operator|)
argument_list|,
name|M_BHND
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* Initialize and terminate the table */
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nres
condition|;
name|i
operator|++
control|)
name|hr
operator|->
name|resource_specs
index|[
name|i
index|]
operator|=
name|hwcfg
operator|->
name|resource_specs
index|[
name|i
index|]
expr_stmt|;
name|hr
operator|->
name|resource_specs
index|[
name|nres
index|]
operator|.
name|type
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Allocate space for our resource references */
name|hr
operator|->
name|resources
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hr
operator|->
name|resources
index|[
literal|0
index|]
argument_list|)
operator|*
name|nres
argument_list|,
name|M_BHND
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* Allocate host resources */
name|error
operator|=
name|bus_alloc_resources
argument_list|(
name|hr
operator|->
name|owner
argument_list|,
name|hr
operator|->
name|resource_specs
argument_list|,
name|hr
operator|->
name|resources
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate bridge resources via "
literal|"%s: %d\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|parent_dev
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
operator|*
name|resources
operator|=
name|hr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
if|if
condition|(
name|hr
operator|->
name|resource_specs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hr
operator|->
name|resource_specs
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
if|if
condition|(
name|hr
operator|->
name|resources
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hr
operator|->
name|resources
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hr
operator|->
name|num_dma_tags
condition|;
name|i
operator|++
control|)
name|bus_dma_tag_destroy
argument_list|(
name|hr
operator|->
name|dma_tags
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hr
operator|->
name|dma_tags
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hr
operator|->
name|dma_tags
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hr
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Deallocate a set of bridge host resources.  *   * @param hr The resources to be freed.  */
end_comment

begin_function
name|void
name|bhndb_release_host_resources
parameter_list|(
name|struct
name|bhndb_host_resources
modifier|*
name|hr
parameter_list|)
block|{
name|bus_release_resources
argument_list|(
name|hr
operator|->
name|owner
argument_list|,
name|hr
operator|->
name|resource_specs
argument_list|,
name|hr
operator|->
name|resources
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hr
operator|->
name|num_dma_tags
condition|;
name|i
operator|++
control|)
name|bus_dma_tag_destroy
argument_list|(
name|hr
operator|->
name|dma_tags
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hr
operator|->
name|resources
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hr
operator|->
name|resource_specs
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hr
operator|->
name|dma_tags
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hr
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Search @p cores for the core serving as the bhnd host bridge.  *   * This function uses a heuristic valid on all known PCI/PCIe/PCMCIA-bridged  * bhnd(4) devices to determine the hostb core:  *   * - The core must have a Broadcom vendor ID.  * - The core devclass must match the bridge type.  * - The core must be the first device on the bus with the bridged device  *   class.  *   * @param	cores		The core table to search.  * @param	ncores		The number of cores in @p cores.  * @param	bridge_devclass	The expected device class of the bridge core.  * @param[out]	core		If found, the matching host bridge core info.  *   * @retval 0		success  * @retval ENOENT	not found  */
end_comment

begin_function
name|int
name|bhndb_find_hostb_core
parameter_list|(
name|struct
name|bhnd_core_info
modifier|*
name|cores
parameter_list|,
name|u_int
name|ncores
parameter_list|,
name|bhnd_devclass_t
name|bridge_devclass
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|core
parameter_list|)
block|{
name|struct
name|bhnd_core_match
name|md
decl_stmt|;
name|struct
name|bhnd_core_info
modifier|*
name|match
decl_stmt|;
name|u_int
name|match_core_idx
decl_stmt|;
comment|/* Set up a match descriptor for the required device class. */
name|md
operator|=
operator|(
expr|struct
name|bhnd_core_match
operator|)
block|{
name|BHND_MATCH_CORE_CLASS
argument_list|(
name|bridge_devclass
argument_list|)
block|,
name|BHND_MATCH_CORE_UNIT
argument_list|(
literal|0
argument_list|)
block|}
expr_stmt|;
comment|/* Find the matching core with the lowest core index */
name|match
operator|=
name|NULL
expr_stmt|;
name|match_core_idx
operator|=
name|UINT_MAX
expr_stmt|;
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncores
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bhnd_core_matches
argument_list|(
operator|&
name|cores
index|[
name|i
index|]
argument_list|,
operator|&
name|md
argument_list|)
condition|)
continue|continue;
comment|/* Lower core indices take precedence */
if|if
condition|(
name|match
operator|!=
name|NULL
operator|&&
name|match_core_idx
operator|<
name|match
operator|->
name|core_idx
condition|)
continue|continue;
name|match
operator|=
operator|&
name|cores
index|[
name|i
index|]
expr_stmt|;
name|match_core_idx
operator|=
name|match
operator|->
name|core_idx
expr_stmt|;
block|}
if|if
condition|(
name|match
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
operator|*
name|core
operator|=
operator|*
name|match
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Allocate a host interrupt source and its backing SYS_RES_IRQ host resource.  *   * @param owner	The device to be used to allocate a SYS_RES_IRQ  *		resource with @p rid.  * @param rid	The resource ID of the IRQ to be allocated.  * @param start	The start value to be passed to bus_alloc_resource().  * @param end	The end value to be passed to bus_alloc_resource().  * @param count	The count to be passed to bus_alloc_resource().  * @param flags	The flags to be passed to bus_alloc_resource().  *   * @retval non-NULL	success  * @retval NULL		if allocation fails.  */
end_comment

begin_function
name|struct
name|bhndb_intr_isrc
modifier|*
name|bhndb_alloc_intr_isrc
parameter_list|(
name|device_t
name|owner
parameter_list|,
name|int
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|bhndb_intr_isrc
modifier|*
name|isrc
decl_stmt|;
name|isrc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|isrc
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|isrc
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|isrc
operator|->
name|is_owner
operator|=
name|owner
expr_stmt|;
name|isrc
operator|->
name|is_rid
operator|=
name|rid
expr_stmt|;
name|isrc
operator|->
name|is_res
operator|=
name|bus_alloc_resource
argument_list|(
name|owner
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|isrc
operator|->
name|is_rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|isrc
operator|->
name|is_res
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|isrc
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|isrc
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Free a host interrupt source and its backing host resource.  *   * @param isrc	The interrupt source to be freed.  */
end_comment

begin_function
name|void
name|bhndb_free_intr_isrc
parameter_list|(
name|struct
name|bhndb_intr_isrc
modifier|*
name|isrc
parameter_list|)
block|{
name|bus_release_resource
argument_list|(
name|isrc
operator|->
name|is_owner
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|isrc
operator|->
name|is_rid
argument_list|,
name|isrc
operator|->
name|is_res
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|isrc
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Allocate and initialize a new interrupt handler entry.  *   * @param owner	The child device that owns this entry.  * @param r	The child's interrupt resource.  * @param isrc	The isrc mapped for this entry.  *   * @retval non-NULL	success  * @retval NULL		if allocation fails.  */
end_comment

begin_function
name|struct
name|bhndb_intr_handler
modifier|*
name|bhndb_alloc_intr_handler
parameter_list|(
name|device_t
name|owner
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|struct
name|bhndb_intr_isrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|bhndb_intr_handler
modifier|*
name|ih
decl_stmt|;
name|ih
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ih
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ih
operator|->
name|ih_owner
operator|=
name|owner
expr_stmt|;
name|ih
operator|->
name|ih_res
operator|=
name|r
expr_stmt|;
name|ih
operator|->
name|ih_isrc
operator|=
name|isrc
expr_stmt|;
name|ih
operator|->
name|ih_cookiep
operator|=
name|NULL
expr_stmt|;
name|ih
operator|->
name|ih_active
operator|=
name|false
expr_stmt|;
return|return
operator|(
name|ih
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Free an interrupt handler entry.  *  * @param br The resource state owning @p ih.  * @param ih The interrupt handler entry to be removed.  */
end_comment

begin_function
name|void
name|bhndb_free_intr_handler
parameter_list|(
name|struct
name|bhndb_intr_handler
modifier|*
name|ih
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|!
name|ih
operator|->
name|ih_active
argument_list|,
operator|(
literal|"free of active interrupt handler %p"
operator|,
name|ih
operator|->
name|ih_cookiep
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ih
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Add an active interrupt handler to the given resource state.   *   * @param br The resource state to be modified.  * @param ih The interrupt handler entry to be added.  */
end_comment

begin_function
name|void
name|bhndb_register_intr_handler
parameter_list|(
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|,
name|struct
name|bhndb_intr_handler
modifier|*
name|ih
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|!
name|ih
operator|->
name|ih_active
argument_list|,
operator|(
literal|"duplicate registration of interrupt "
literal|"handler %p"
operator|,
name|ih
operator|->
name|ih_cookiep
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ih
operator|->
name|ih_cookiep
operator|!=
name|NULL
argument_list|,
operator|(
literal|"missing cookiep"
operator|)
argument_list|)
expr_stmt|;
name|ih
operator|->
name|ih_active
operator|=
name|true
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|br
operator|->
name|bus_intrs
argument_list|,
name|ih
argument_list|,
name|ih_link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Remove an interrupt handler from the given resource state.  *   * @param br The resource state containing @p ih.  * @param ih The interrupt handler entry to be removed.  */
end_comment

begin_function
name|void
name|bhndb_deregister_intr_handler
parameter_list|(
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|,
name|struct
name|bhndb_intr_handler
modifier|*
name|ih
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|!
name|ih
operator|->
name|ih_active
argument_list|,
operator|(
literal|"duplicate deregistration of interrupt "
literal|"handler %p"
operator|,
name|ih
operator|->
name|ih_cookiep
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bhndb_find_intr_handler
argument_list|(
name|br
argument_list|,
name|ih
argument_list|)
operator|==
name|ih
argument_list|,
operator|(
literal|"unknown interrupt handler %p"
operator|,
name|ih
operator|)
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|br
operator|->
name|bus_intrs
argument_list|,
name|ih
argument_list|,
name|bhndb_intr_handler
argument_list|,
name|ih_link
argument_list|)
expr_stmt|;
name|ih
operator|->
name|ih_active
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Return the interrupt handler entry corresponding to @p cookiep, or NULL  * if no entry is found.  *   * @param br The resource state to search for the given @p cookiep.  * @param cookiep The interrupt handler's bus-assigned cookiep value.  */
end_comment

begin_function
name|struct
name|bhndb_intr_handler
modifier|*
name|bhndb_find_intr_handler
parameter_list|(
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|bhndb_intr_handler
modifier|*
name|ih
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|ih
argument_list|,
argument|&br->bus_intrs
argument_list|,
argument|ih_link
argument_list|)
block|{
if|if
condition|(
name|ih
operator|==
name|cookiep
condition|)
return|return
operator|(
name|ih
operator|)
return|;
block|}
comment|/* Not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find the maximum start and end limits of the bridged resource @p r.  *   * If the resource is not currently mapped by the bridge, ENOENT will be  * returned.  *   * @param	br		The resource state to search.  * @param	type The resource type (see SYS_RES_*).  * @param	r The resource to search for in @p br.  * @param[out]	start	On success, the minimum supported start address.  * @param[out]	end	On success, the maximum supported end address.  *   * @retval 0		success  * @retval ENOENT	no active mapping found for @p r of @p type  */
end_comment

begin_function
name|int
name|bhndb_find_resource_limits
parameter_list|(
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|rman_res_t
modifier|*
name|start
parameter_list|,
name|rman_res_t
modifier|*
name|end
parameter_list|)
block|{
name|struct
name|bhndb_dw_alloc
modifier|*
name|dynamic
decl_stmt|;
name|struct
name|bhndb_region
modifier|*
name|sregion
decl_stmt|;
name|struct
name|bhndb_intr_handler
modifier|*
name|ih
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IRQ
case|:
comment|/* Is this one of ours? */
name|STAILQ_FOREACH
argument_list|(
argument|ih
argument_list|,
argument|&br->bus_intrs
argument_list|,
argument|ih_link
argument_list|)
block|{
if|if
condition|(
name|ih
operator|->
name|ih_res
operator|==
name|r
condition|)
continue|continue;
comment|/* We don't support adjusting IRQ resource limits */
operator|*
name|start
operator|=
name|rman_get_start
argument_list|(
name|r
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|rman_get_end
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Not found */
return|return
operator|(
name|ENOENT
operator|)
return|;
case|case
name|SYS_RES_MEMORY
case|:
block|{
comment|/* Check for an enclosing dynamic register window */
if|if
condition|(
operator|(
name|dynamic
operator|=
name|bhndb_dw_find_resource
argument_list|(
name|br
argument_list|,
name|r
argument_list|)
operator|)
condition|)
block|{
operator|*
name|start
operator|=
name|dynamic
operator|->
name|target
expr_stmt|;
operator|*
name|end
operator|=
name|dynamic
operator|->
name|target
operator|+
name|dynamic
operator|->
name|win
operator|->
name|win_size
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Check for a static region */
name|sregion
operator|=
name|bhndb_find_resource_region
argument_list|(
name|br
argument_list|,
name|rman_get_start
argument_list|(
name|r
argument_list|)
argument_list|,
name|rman_get_size
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sregion
operator|!=
name|NULL
operator|&&
name|sregion
operator|->
name|static_regwin
operator|!=
name|NULL
condition|)
block|{
operator|*
name|start
operator|=
name|sregion
operator|->
name|addr
expr_stmt|;
operator|*
name|end
operator|=
name|sregion
operator|->
name|addr
operator|+
name|sregion
operator|->
name|size
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Not found */
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
default|default:
name|device_printf
argument_list|(
name|br
operator|->
name|dev
argument_list|,
literal|"unknown resource type: %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Add a bus region entry to @p r for the given base @p addr and @p size.  *   * @param br The resource state to which the bus region entry will be added.  * @param addr The base address of this region.  * @param size The size of this region.  * @param priority The resource priority to be assigned to allocations  * made within this bus region.  * @param static_regwin If available, a static register window mapping this  * bus region entry. If not available, NULL.  *   * @retval 0 success  * @retval non-zero if adding the bus region fails.  */
end_comment

begin_function
name|int
name|bhndb_add_resource_region
parameter_list|(
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|,
name|bhnd_size_t
name|size
parameter_list|,
name|bhndb_priority_t
name|priority
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|static_regwin
parameter_list|)
block|{
name|struct
name|bhndb_region
modifier|*
name|reg
decl_stmt|;
comment|/* Insert in the bus resource list */
name|reg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|reg
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
operator|*
name|reg
operator|=
operator|(
expr|struct
name|bhndb_region
operator|)
block|{
operator|.
name|addr
operator|=
name|addr
block|,
operator|.
name|size
operator|=
name|size
block|,
operator|.
name|priority
operator|=
name|priority
block|,
operator|.
name|static_regwin
operator|=
name|static_regwin
block|}
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|br
operator|->
name|bus_regions
argument_list|,
name|reg
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find the bus region that maps @p size bytes at @p addr.  *   * @param br The resource state to search.  * @param addr The requested starting address.  * @param size The requested size.  *   * @retval bhndb_region A region that fully contains the requested range.  * @retval NULL If no mapping region can be found.  */
end_comment

begin_function
name|struct
name|bhndb_region
modifier|*
name|bhndb_find_resource_region
parameter_list|(
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|,
name|bhnd_size_t
name|size
parameter_list|)
block|{
name|struct
name|bhndb_region
modifier|*
name|region
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|region
argument_list|,
argument|&br->bus_regions
argument_list|,
argument|link
argument_list|)
block|{
comment|/* Request must fit within the region's mapping  */
if|if
condition|(
name|addr
operator|<
name|region
operator|->
name|addr
condition|)
continue|continue;
if|if
condition|(
name|addr
operator|+
name|size
operator|>
name|region
operator|->
name|addr
operator|+
name|region
operator|->
name|size
condition|)
continue|continue;
return|return
operator|(
name|region
operator|)
return|;
block|}
comment|/* Not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find the entry matching @p r in @p dwa's references, if any.  *   * @param dwa The dynamic window allocation to search  * @param r The resource to search for in @p dwa.  */
end_comment

begin_function
specifier|static
name|struct
name|bhndb_dw_rentry
modifier|*
name|bhndb_dw_find_resource_entry
parameter_list|(
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|bhndb_dw_rentry
modifier|*
name|rentry
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|rentry
argument_list|,
argument|&dwa->refs
argument_list|,
argument|dw_link
argument_list|)
block|{
name|struct
name|resource
modifier|*
name|dw_res
init|=
name|rentry
operator|->
name|dw_res
decl_stmt|;
comment|/* Match dev/rid/addr/size */
if|if
condition|(
name|rman_get_device
argument_list|(
name|dw_res
argument_list|)
operator|!=
name|rman_get_device
argument_list|(
name|r
argument_list|)
operator|||
name|rman_get_rid
argument_list|(
name|dw_res
argument_list|)
operator|!=
name|rman_get_rid
argument_list|(
name|r
argument_list|)
operator|||
name|rman_get_start
argument_list|(
name|dw_res
argument_list|)
operator|!=
name|rman_get_start
argument_list|(
name|r
argument_list|)
operator|||
name|rman_get_size
argument_list|(
name|dw_res
argument_list|)
operator|!=
name|rman_get_size
argument_list|(
name|r
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|/* Matching allocation found */
return|return
operator|(
name|rentry
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find the dynamic region allocated for @p r, if any.  *   * @param br The resource state to search.  * @param r The resource to search for.  *   * @retval bhndb_dw_alloc The allocation record for @p r.  * @retval NULL if no dynamic window is allocated for @p r.  */
end_comment

begin_function
name|struct
name|bhndb_dw_alloc
modifier|*
name|bhndb_dw_find_resource
parameter_list|(
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|br
operator|->
name|dwa_count
condition|;
name|i
operator|++
control|)
block|{
name|dwa
operator|=
operator|&
name|br
operator|->
name|dw_alloc
index|[
name|i
index|]
expr_stmt|;
comment|/* Skip free dynamic windows */
if|if
condition|(
name|bhndb_dw_is_free
argument_list|(
name|br
argument_list|,
name|dwa
argument_list|)
condition|)
continue|continue;
comment|/* Matching allocation found? */
if|if
condition|(
name|bhndb_dw_find_resource_entry
argument_list|(
name|dwa
argument_list|,
name|r
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|dwa
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find an existing dynamic window mapping @p size bytes  * at @p addr. The window may or may not be free.  *   * @param br The resource state to search.  * @param addr The requested starting address.  * @param size The requested size.  *   * @retval bhndb_dw_alloc A window allocation that fully contains the requested  * range.  * @retval NULL If no mapping region can be found.  */
end_comment

begin_function
name|struct
name|bhndb_dw_alloc
modifier|*
name|bhndb_dw_find_mapping
parameter_list|(
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|,
name|bhnd_size_t
name|size
parameter_list|)
block|{
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwr
decl_stmt|;
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|win
decl_stmt|;
comment|/* Search for an existing dynamic mapping of this address range. */
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|br
operator|->
name|dwa_count
condition|;
name|i
operator|++
control|)
block|{
name|dwr
operator|=
operator|&
name|br
operator|->
name|dw_alloc
index|[
name|i
index|]
expr_stmt|;
name|win
operator|=
name|dwr
operator|->
name|win
expr_stmt|;
comment|/* Verify the range */
if|if
condition|(
name|addr
operator|<
name|dwr
operator|->
name|target
condition|)
continue|continue;
if|if
condition|(
name|addr
operator|+
name|size
operator|>
name|dwr
operator|->
name|target
operator|+
name|win
operator|->
name|win_size
condition|)
continue|continue;
comment|/* Found a usable mapping */
return|return
operator|(
name|dwr
operator|)
return|;
block|}
comment|/* not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Retain a reference to @p dwa for use by @p res.  *   * @param br The resource state owning @p dwa.  * @param dwa The allocation record to be retained.  * @param res The resource that will own a reference to @p dwa.  *   * @retval 0 success  * @retval ENOMEM Failed to allocate a new reference structure.  */
end_comment

begin_function
name|int
name|bhndb_dw_retain
parameter_list|(
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|,
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|bhndb_dw_rentry
modifier|*
name|rentry
decl_stmt|;
name|KASSERT
argument_list|(
name|bhndb_dw_find_resource_entry
argument_list|(
name|dwa
argument_list|,
name|res
argument_list|)
operator|==
name|NULL
argument_list|,
operator|(
literal|"double-retain of dynamic window for same resource"
operator|)
argument_list|)
expr_stmt|;
comment|/* Insert a reference entry; we use M_NOWAIT to allow use from 	 * within a non-sleepable lock */
name|rentry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rentry
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rentry
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rentry
operator|->
name|dw_res
operator|=
name|res
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|dwa
operator|->
name|refs
argument_list|,
name|rentry
argument_list|,
name|dw_link
argument_list|)
expr_stmt|;
comment|/* Update the free list */
name|bit_set
argument_list|(
name|br
operator|->
name|dwa_freelist
argument_list|,
name|dwa
operator|->
name|rnid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Release a reference to @p dwa previously retained by @p res. If the  * reference count of @p dwa reaches zero, it will be added to the  * free list.  *   * @param br The resource state owning @p dwa.  * @param dwa The allocation record to be released.  * @param res The resource that currently owns a reference to @p dwa.  */
end_comment

begin_function
name|void
name|bhndb_dw_release
parameter_list|(
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|,
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|bhndb_dw_rentry
modifier|*
name|rentry
decl_stmt|;
comment|/* Find the rentry */
name|rentry
operator|=
name|bhndb_dw_find_resource_entry
argument_list|(
name|dwa
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rentry
operator|!=
name|NULL
argument_list|,
operator|(
literal|"over release of resource entry"
operator|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|rentry
argument_list|,
name|dw_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rentry
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
comment|/* If this was the last reference, update the free list */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|dwa
operator|->
name|refs
argument_list|)
condition|)
name|bit_clear
argument_list|(
name|br
operator|->
name|dwa_freelist
argument_list|,
name|dwa
operator|->
name|rnid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Attempt to set (or reset) the target address of @p dwa to map @p size bytes  * at @p addr.  *   * This will apply any necessary window alignment and verify that  * the window is capable of mapping the requested range prior to modifying  * therecord.  *   * @param dev The device on which to issue the BHNDB_SET_WINDOW_ADDR() request.  * @param br The resource state owning @p dwa.  * @param dwa The allocation record to be configured.  * @param addr The address to be mapped via @p dwa.  * @param size The number of bytes to be mapped at @p addr.  *  * @retval 0 success  * @retval non-zero no usable register window available.  */
end_comment

begin_function
name|int
name|bhndb_dw_set_addr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|,
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
parameter_list|,
name|bus_addr_t
name|addr
parameter_list|,
name|bus_size_t
name|size
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
decl_stmt|;
name|bus_addr_t
name|offset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|rw
operator|=
name|dwa
operator|->
name|win
expr_stmt|;
name|KASSERT
argument_list|(
name|bhndb_dw_is_free
argument_list|(
name|br
argument_list|,
name|dwa
argument_list|)
argument_list|,
operator|(
literal|"attempting to set the target address on an in-use window"
operator|)
argument_list|)
expr_stmt|;
comment|/* Page-align the target address */
name|offset
operator|=
name|addr
operator|%
name|rw
operator|->
name|win_size
expr_stmt|;
name|dwa
operator|->
name|target
operator|=
name|addr
operator|-
name|offset
expr_stmt|;
comment|/* Verify that the window is large enough for the full target */
if|if
condition|(
name|rw
operator|->
name|win_size
operator|-
name|offset
operator|<
name|size
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Update the window target */
name|error
operator|=
name|BHNDB_SET_WINDOW_ADDR
argument_list|(
name|dev
argument_list|,
name|dwa
operator|->
name|win
argument_list|,
name|dwa
operator|->
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dwa
operator|->
name|target
operator|=
literal|0x0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the count of @p type register windows in @p table.  *   * @param table The table to search.  * @param type The required window type, or BHNDB_REGWIN_T_INVALID to  * count all register window types.  */
end_comment

begin_function
name|size_t
name|bhndb_regwin_count
parameter_list|(
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|table
parameter_list|,
name|bhndb_regwin_type_t
name|type
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|rw
operator|=
name|table
init|;
name|rw
operator|->
name|win_type
operator|!=
name|BHNDB_REGWIN_T_INVALID
condition|;
name|rw
operator|++
control|)
block|{
if|if
condition|(
name|type
operator|==
name|BHNDB_REGWIN_T_INVALID
operator|||
name|rw
operator|->
name|win_type
operator|==
name|type
condition|)
name|count
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Search @p table for the first window with the given @p type.  *   * @param table The table to search.  * @param type The required window type.  * @param min_size The minimum window size.  *   * @retval bhndb_regwin The first matching window.  * @retval NULL If no window of the requested type could be found.   */
end_comment

begin_function
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|bhndb_regwin_find_type
parameter_list|(
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|table
parameter_list|,
name|bhndb_regwin_type_t
name|type
parameter_list|,
name|bus_size_t
name|min_size
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
decl_stmt|;
for|for
control|(
name|rw
operator|=
name|table
init|;
name|rw
operator|->
name|win_type
operator|!=
name|BHNDB_REGWIN_T_INVALID
condition|;
name|rw
operator|++
control|)
block|{
if|if
condition|(
name|rw
operator|->
name|win_type
operator|==
name|type
operator|&&
name|rw
operator|->
name|win_size
operator|>=
name|min_size
condition|)
return|return
operator|(
name|rw
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Search @p windows for the first matching core window.  *   * @param table The table to search.  * @param class The required core class.  * @param unit The required core unit, or -1.  * @param port_type The required port type.  * @param port The required port.  * @param region The required region.  *  * @retval bhndb_regwin The first matching window.  * @retval NULL If no matching window was found.   */
end_comment

begin_function
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|bhndb_regwin_find_core
parameter_list|(
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|table
parameter_list|,
name|bhnd_devclass_t
name|class
parameter_list|,
name|int
name|unit
parameter_list|,
name|bhnd_port_type
name|port_type
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|region
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
decl_stmt|;
for|for
control|(
name|rw
operator|=
name|table
init|;
name|rw
operator|->
name|win_type
operator|!=
name|BHNDB_REGWIN_T_INVALID
condition|;
name|rw
operator|++
control|)
block|{
if|if
condition|(
name|rw
operator|->
name|win_type
operator|!=
name|BHNDB_REGWIN_T_CORE
condition|)
continue|continue;
if|if
condition|(
name|rw
operator|->
name|d
operator|.
name|core
operator|.
name|class
operator|!=
name|class
condition|)
continue|continue;
if|if
condition|(
name|unit
operator|!=
operator|-
literal|1
operator|&&
name|rw
operator|->
name|d
operator|.
name|core
operator|.
name|unit
operator|!=
name|unit
condition|)
continue|continue;
if|if
condition|(
name|rw
operator|->
name|d
operator|.
name|core
operator|.
name|port_type
operator|!=
name|port_type
condition|)
continue|continue;
if|if
condition|(
name|rw
operator|->
name|d
operator|.
name|core
operator|.
name|port
operator|!=
name|port
condition|)
continue|continue;
if|if
condition|(
name|rw
operator|->
name|d
operator|.
name|core
operator|.
name|region
operator|!=
name|region
condition|)
continue|continue;
return|return
operator|(
name|rw
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Search @p windows for the best available window of at least @p min_size.  *   * Search order:  * - BHND_REGWIN_T_CORE  * - BHND_REGWIN_T_DYN  *   * @param table The table to search.  * @param class The required core class.  * @param unit The required core unit, or -1.  * @param port_type The required port type.  * @param port The required port.  * @param region The required region.  * @param min_size The minimum window size.  *  * @retval bhndb_regwin The first matching window.  * @retval NULL If no matching window was found.   */
end_comment

begin_function
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|bhndb_regwin_find_best
parameter_list|(
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|table
parameter_list|,
name|bhnd_devclass_t
name|class
parameter_list|,
name|int
name|unit
parameter_list|,
name|bhnd_port_type
name|port_type
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|region
parameter_list|,
name|bus_size_t
name|min_size
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
decl_stmt|;
comment|/* Prefer a fixed core mapping */
name|rw
operator|=
name|bhndb_regwin_find_core
argument_list|(
name|table
argument_list|,
name|class
argument_list|,
name|unit
argument_list|,
name|port_type
argument_list|,
name|port
argument_list|,
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|!=
name|NULL
condition|)
return|return
operator|(
name|rw
operator|)
return|;
comment|/* Fall back on a generic dynamic window */
return|return
operator|(
name|bhndb_regwin_find_type
argument_list|(
name|table
argument_list|,
name|BHNDB_REGWIN_T_DYN
argument_list|,
name|min_size
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if @p regw defines a BHNDB_REGWIN_T_CORE register window  * that matches against @p core.  *   * @param regw A register window to match against.  * @param core The bhnd(4) core info to match against @p regw.  */
end_comment

begin_function
name|bool
name|bhndb_regwin_match_core
parameter_list|(
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|regw
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|core
parameter_list|)
block|{
comment|/* Only core windows are supported */
if|if
condition|(
name|regw
operator|->
name|win_type
operator|!=
name|BHNDB_REGWIN_T_CORE
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Device class must match */
if|if
condition|(
name|bhnd_core_class
argument_list|(
name|core
argument_list|)
operator|!=
name|regw
operator|->
name|d
operator|.
name|core
operator|.
name|class
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Device unit must match */
if|if
condition|(
name|core
operator|->
name|unit
operator|!=
name|regw
operator|->
name|d
operator|.
name|core
operator|.
name|unit
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Matches */
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Search for a core resource priority descriptor in @p table that matches  * @p core.  *   * @param table The table to search.  * @param core The core to match against @p table.  */
end_comment

begin_function
specifier|const
name|struct
name|bhndb_hw_priority
modifier|*
name|bhndb_hw_priority_find_core
parameter_list|(
specifier|const
name|struct
name|bhndb_hw_priority
modifier|*
name|table
parameter_list|,
name|struct
name|bhnd_core_info
modifier|*
name|core
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_hw_priority
modifier|*
name|hp
decl_stmt|;
for|for
control|(
name|hp
operator|=
name|table
init|;
name|hp
operator|->
name|ports
operator|!=
name|NULL
condition|;
name|hp
operator|++
control|)
block|{
if|if
condition|(
name|bhnd_core_matches
argument_list|(
name|core
argument_list|,
operator|&
name|hp
operator|->
name|match
argument_list|)
condition|)
return|return
operator|(
name|hp
operator|)
return|;
block|}
comment|/* not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

end_unit

