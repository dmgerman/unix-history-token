begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 Landon Fuller<landon@landonf.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|"bhndb_private.h"
end_include

begin_include
include|#
directive|include
file|"bhndbvar.h"
end_include

begin_comment
comment|/**  * Attach a BHND bridge device to @p parent.  *   * @param parent A parent PCI device.  * @param[out] bhndb On success, the probed and attached bhndb bridge device.  * @param unit The device unit number, or -1 to select the next available unit  * number.  *   * @retval 0 success  * @retval non-zero Failed to attach the bhndb device.  */
end_comment

begin_function
name|int
name|bhndb_attach_bridge
parameter_list|(
name|device_t
name|parent
parameter_list|,
name|device_t
modifier|*
name|bhndb
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
operator|*
name|bhndb
operator|=
name|device_add_child
argument_list|(
name|parent
argument_list|,
name|devclass_get_name
argument_list|(
name|bhndb_devclass
argument_list|)
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bhndb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|error
operator|=
name|device_probe_and_attach
argument_list|(
operator|*
name|bhndb
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|device_delete_child
argument_list|(
name|parent
argument_list|,
operator|*
name|bhndb
argument_list|)
operator|)
condition|)
name|device_printf
argument_list|(
name|parent
argument_list|,
literal|"failed to detach bhndb child\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Call BHNDB_SUSPEND_RESOURCE() for all resources in @p rl.  */
end_comment

begin_function
specifier|static
name|void
name|bhndb_do_suspend_resources
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|resource_list
modifier|*
name|rl
parameter_list|)
block|{
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
comment|/* Suspend all child resources. */
name|STAILQ_FOREACH
argument_list|(
argument|rle
argument_list|,
argument|rl
argument_list|,
argument|link
argument_list|)
block|{
comment|/* Skip non-allocated resources */
if|if
condition|(
name|rle
operator|->
name|res
operator|==
name|NULL
condition|)
continue|continue;
name|BHNDB_SUSPEND_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|rle
operator|->
name|type
argument_list|,
name|rle
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BUS_RESUME_CHILD() on bridged  * bhnd(4) buses.  *   * This implementation of BUS_RESUME_CHILD() uses BUS_GET_RESOURCE_LIST()  * to find the child's resources and call BHNDB_SUSPEND_RESOURCE() for all  * child resources, ensuring that the device's allocated bridge resources  * will be available to other devices during bus resumption.  *   * Before suspending any resources, @p child is suspended by   * calling bhnd_generic_suspend_child().  *   * If @p child is not a direct child of @p dev, suspension is delegated to  * the @p dev parent.  */
end_comment

begin_function
name|int
name|bhnd_generic_br_suspend_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
name|BUS_SUSPEND_CHILD
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_is_suspended
argument_list|(
name|child
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Suspend the child device */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_generic_suspend_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Fetch the resource list. If none, there's nothing else to do */
name|rl
operator|=
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Suspend all child resources. */
name|bhndb_do_suspend_resources
argument_list|(
name|dev
argument_list|,
name|rl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function for implementing BUS_RESUME_CHILD() on bridged  * bhnd(4) bus devices.  *   * This implementation of BUS_RESUME_CHILD() uses BUS_GET_RESOURCE_LIST()  * to find the child's resources and call BHNDB_RESUME_RESOURCE() for all  * child resources, before delegating to bhnd_generic_resume_child().  *   * If resource resumption fails, @p child will not be resumed.  *   * If @p child is not a direct child of @p dev, suspension is delegated to  * the @p dev parent.  */
end_comment

begin_function
name|int
name|bhnd_generic_br_resume_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
name|BUS_RESUME_CHILD
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|device_is_suspended
argument_list|(
name|child
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Fetch the resource list. If none, there's nothing else to do */
name|rl
operator|=
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|==
name|NULL
condition|)
return|return
operator|(
name|bhnd_generic_resume_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
operator|)
return|;
comment|/* Resume all resources */
name|STAILQ_FOREACH
argument_list|(
argument|rle
argument_list|,
argument|rl
argument_list|,
argument|link
argument_list|)
block|{
comment|/* Skip non-allocated resources */
if|if
condition|(
name|rle
operator|->
name|res
operator|==
name|NULL
condition|)
continue|continue;
name|error
operator|=
name|BHNDB_RESUME_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|rle
operator|->
name|type
argument_list|,
name|rle
operator|->
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* Put all resources back into a suspend state */
name|bhndb_do_suspend_resources
argument_list|(
name|dev
argument_list|,
name|rl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* Now that all resources are resumed, resume child */
if|if
condition|(
operator|(
name|error
operator|=
name|bhnd_generic_resume_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
operator|)
condition|)
block|{
comment|/* Put all resources back into a suspend state */
name|bhndb_do_suspend_resources
argument_list|(
name|dev
argument_list|,
name|rl
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find the resource containing @p win.  *   * @param br The bhndb resource state to search.  * @param win A register window.  *   * @retval resource the resource containing @p win.  * @retval NULL if no resource containing @p win can be found.  */
end_comment

begin_function
name|struct
name|resource
modifier|*
name|bhndb_find_regwin_resource
parameter_list|(
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|win
parameter_list|)
block|{
specifier|const
name|struct
name|resource_spec
modifier|*
name|rspecs
decl_stmt|;
name|rspecs
operator|=
name|br
operator|->
name|cfg
operator|->
name|resource_specs
expr_stmt|;
for|for
control|(
name|u_int
name|i
init|=
literal|0
init|;
name|rspecs
index|[
name|i
index|]
operator|.
name|type
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|win
operator|->
name|res
operator|.
name|type
operator|!=
name|rspecs
index|[
name|i
index|]
operator|.
name|type
condition|)
continue|continue;
if|if
condition|(
name|win
operator|->
name|res
operator|.
name|rid
operator|!=
name|rspecs
index|[
name|i
index|]
operator|.
name|rid
condition|)
continue|continue;
comment|/* Found declared resource */
return|return
operator|(
name|br
operator|->
name|res
index|[
name|i
index|]
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|br
operator|->
name|dev
argument_list|,
literal|"missing regwin resource spec (type=%d, rid=%d)\n"
argument_list|,
name|win
operator|->
name|res
operator|.
name|type
argument_list|,
name|win
operator|->
name|res
operator|.
name|rid
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Allocate and initialize a new resource state structure, allocating  * bus resources from @p parent_dev according to @p cfg.  *   * @param dev The bridge device.  * @param parent_dev The parent device from which resources will be allocated.  * @param cfg The hardware configuration to be used.  */
end_comment

begin_function
name|struct
name|bhndb_resources
modifier|*
name|bhndb_alloc_resources
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|parent_dev
parameter_list|,
specifier|const
name|struct
name|bhndb_hwcfg
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|bhndb_resources
modifier|*
name|r
decl_stmt|;
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|win
decl_stmt|;
name|bus_size_t
name|last_window_size
decl_stmt|;
name|size_t
name|res_num
decl_stmt|;
name|u_int
name|rnid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bool
name|free_parent_res
decl_stmt|;
name|free_parent_res
operator|=
name|false
expr_stmt|;
name|r
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Basic initialization */
name|r
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|r
operator|->
name|parent_dev
operator|=
name|parent_dev
expr_stmt|;
name|r
operator|->
name|cfg
operator|=
name|cfg
expr_stmt|;
name|r
operator|->
name|min_prio
operator|=
name|BHNDB_PRIORITY_NONE
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|r
operator|->
name|bus_regions
argument_list|)
expr_stmt|;
comment|/* Determine our bridge resource count from the hardware config. */
name|res_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|cfg
operator|->
name|resource_specs
index|[
name|i
index|]
operator|.
name|type
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|res_num
operator|++
expr_stmt|;
comment|/* Allocate space for a non-const copy of our resource_spec 	 * table; this will be updated with the RIDs assigned by 	 * bus_alloc_resources. */
name|r
operator|->
name|res_spec
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|r
operator|->
name|res_spec
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
name|res_num
operator|+
literal|1
operator|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|res_spec
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
comment|/* Initialize and terminate the table */
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res_num
condition|;
name|i
operator|++
control|)
name|r
operator|->
name|res_spec
index|[
name|i
index|]
operator|=
name|cfg
operator|->
name|resource_specs
index|[
name|i
index|]
expr_stmt|;
name|r
operator|->
name|res_spec
index|[
name|res_num
index|]
operator|.
name|type
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Allocate space for our resource references */
name|r
operator|->
name|res
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|r
operator|->
name|res
index|[
literal|0
index|]
argument_list|)
operator|*
name|res_num
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|res
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
comment|/* Allocate resources */
name|error
operator|=
name|bus_alloc_resources
argument_list|(
name|r
operator|->
name|parent_dev
argument_list|,
name|r
operator|->
name|res_spec
argument_list|,
name|r
operator|->
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|r
operator|->
name|dev
argument_list|,
literal|"could not allocate bridge resources on %s: %d\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|r
operator|->
name|parent_dev
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
else|else
block|{
name|free_parent_res
operator|=
name|true
expr_stmt|;
block|}
comment|/* Fetch the dynamic regwin count and verify that it does not exceed 	 * what is representable via our freelist bitmask. */
name|r
operator|->
name|dwa_count
operator|=
name|bhndb_regwin_count
argument_list|(
name|cfg
operator|->
name|register_windows
argument_list|,
name|BHNDB_REGWIN_T_DYN
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|dwa_count
operator|>=
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|r
operator|->
name|dwa_freelist
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|r
operator|->
name|dev
argument_list|,
literal|"max dynamic regwin count exceeded\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* Allocate the dynamic window allocation table. */
name|r
operator|->
name|dw_alloc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|r
operator|->
name|dw_alloc
index|[
literal|0
index|]
argument_list|)
operator|*
name|r
operator|->
name|dwa_count
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|dw_alloc
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
comment|/* Initialize the dynamic window table and freelist. */
name|r
operator|->
name|dwa_freelist
operator|=
literal|0
expr_stmt|;
name|rnid
operator|=
literal|0
expr_stmt|;
name|last_window_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|win
operator|=
name|cfg
operator|->
name|register_windows
init|;
name|win
operator|->
name|win_type
operator|!=
name|BHNDB_REGWIN_T_INVALID
condition|;
name|win
operator|++
control|)
block|{
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
decl_stmt|;
comment|/* Skip non-DYN windows */
if|if
condition|(
name|win
operator|->
name|win_type
operator|!=
name|BHNDB_REGWIN_T_DYN
condition|)
continue|continue;
comment|/* Validate the window size */
if|if
condition|(
name|win
operator|->
name|win_size
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|r
operator|->
name|dev
argument_list|,
literal|"ignoring zero-length dynamic "
literal|"register window\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|last_window_size
operator|==
literal|0
condition|)
block|{
name|last_window_size
operator|=
name|win
operator|->
name|win_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_window_size
operator|!=
name|win
operator|->
name|win_size
condition|)
block|{
comment|/*  			 * No existing hardware should trigger this. 			 *  			 * If you run into this in the future, the dynamic 			 * window allocator and the resource priority system 			 * will need to be extended to support multiple register 			 * window allocation pools.  			 */
name|device_printf
argument_list|(
name|r
operator|->
name|dev
argument_list|,
literal|"devices that vend multiple "
literal|"dynamic register window sizes are not currently "
literal|"supported\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|dwa
operator|=
operator|&
name|r
operator|->
name|dw_alloc
index|[
name|rnid
index|]
expr_stmt|;
name|dwa
operator|->
name|win
operator|=
name|win
expr_stmt|;
name|dwa
operator|->
name|parent_res
operator|=
name|NULL
expr_stmt|;
name|dwa
operator|->
name|rnid
operator|=
name|rnid
expr_stmt|;
name|dwa
operator|->
name|target
operator|=
literal|0x0
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|dwa
operator|->
name|refs
argument_list|)
expr_stmt|;
comment|/* Find and validate corresponding resource. */
name|dwa
operator|->
name|parent_res
operator|=
name|bhndb_find_regwin_resource
argument_list|(
name|r
argument_list|,
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwa
operator|->
name|parent_res
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|rman_get_size
argument_list|(
name|dwa
operator|->
name|parent_res
argument_list|)
operator|<
name|win
operator|->
name|win_offset
operator|+
name|win
operator|->
name|win_size
condition|)
block|{
name|device_printf
argument_list|(
name|r
operator|->
name|dev
argument_list|,
literal|"resource %d too small for "
literal|"register window with offset %llx and size %llx\n"
argument_list|,
name|rman_get_rid
argument_list|(
name|dwa
operator|->
name|parent_res
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|win
operator|->
name|win_offset
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|win
operator|->
name|win_size
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* Add to freelist */
name|r
operator|->
name|dwa_freelist
operator||=
operator|(
literal|1
operator|<<
name|rnid
operator|)
expr_stmt|;
name|rnid
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
name|failed
label|:
if|if
condition|(
name|free_parent_res
condition|)
name|bus_release_resources
argument_list|(
name|r
operator|->
name|parent_dev
argument_list|,
name|r
operator|->
name|res_spec
argument_list|,
name|r
operator|->
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|res
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|r
operator|->
name|res
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|res_spec
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|r
operator|->
name|res_spec
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|dw_alloc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|r
operator|->
name|dw_alloc
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Deallocate the given bridge resource structure and any associated resources.  *   * @param br Resource state to be deallocated.  */
end_comment

begin_function
name|void
name|bhndb_free_resources
parameter_list|(
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|)
block|{
name|struct
name|bhndb_region
modifier|*
name|region
decl_stmt|,
modifier|*
name|r_next
decl_stmt|;
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
decl_stmt|;
name|struct
name|bhndb_dw_rentry
modifier|*
name|dwr
decl_stmt|,
modifier|*
name|dwr_next
decl_stmt|;
comment|/* No window regions may still be held */
if|if
condition|(
name|__builtin_popcount
argument_list|(
name|br
operator|->
name|dwa_freelist
argument_list|)
operator|!=
name|br
operator|->
name|dwa_count
condition|)
block|{
name|device_printf
argument_list|(
name|br
operator|->
name|dev
argument_list|,
literal|"leaked %llu dynamic register regions\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|br
operator|->
name|dwa_count
operator|-
name|br
operator|->
name|dwa_freelist
argument_list|)
expr_stmt|;
block|}
comment|/* Release resources allocated through our parent. */
name|bus_release_resources
argument_list|(
name|br
operator|->
name|parent_dev
argument_list|,
name|br
operator|->
name|res_spec
argument_list|,
name|br
operator|->
name|res
argument_list|)
expr_stmt|;
comment|/* Clean up resource reservations */
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|br
operator|->
name|dwa_count
condition|;
name|i
operator|++
control|)
block|{
name|dwa
operator|=
operator|&
name|br
operator|->
name|dw_alloc
index|[
name|i
index|]
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|dwr
argument_list|,
argument|&dwa->refs
argument_list|,
argument|dw_link
argument_list|,
argument|dwr_next
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|dwr
argument_list|,
name|dw_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dwr
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Release bus regions */
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|region
argument_list|,
argument|&br->bus_regions
argument_list|,
argument|link
argument_list|,
argument|r_next
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|br
operator|->
name|bus_regions
argument_list|,
name|region
argument_list|,
name|bhndb_region
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|region
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
comment|/* Free backing resource state structures */
name|free
argument_list|(
name|br
operator|->
name|res
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|br
operator|->
name|res_spec
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|br
operator|->
name|dw_alloc
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Add a bus region entry to @p r for the given base @p addr and @p size.  *   * @param br The resource state to which the bus region entry will be added.  * @param addr The base address of this region.  * @param size The size of this region.  * @param priority The resource priority to be assigned to allocations  * made within this bus region.  * @param static_regwin If available, a static register window mapping this  * bus region entry. If not available, NULL.  *   * @retval 0 success  * @retval non-zero if adding the bus region fails.  */
end_comment

begin_function
name|int
name|bhndb_add_resource_region
parameter_list|(
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|,
name|bhnd_size_t
name|size
parameter_list|,
name|bhndb_priority_t
name|priority
parameter_list|,
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|static_regwin
parameter_list|)
block|{
name|struct
name|bhndb_region
modifier|*
name|reg
decl_stmt|;
comment|/* Insert in the bus resource list */
name|reg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|reg
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
operator|*
name|reg
operator|=
operator|(
expr|struct
name|bhndb_region
operator|)
block|{
operator|.
name|addr
operator|=
name|addr
block|,
operator|.
name|size
operator|=
name|size
block|,
operator|.
name|priority
operator|=
name|priority
block|,
operator|.
name|static_regwin
operator|=
name|static_regwin
block|}
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|br
operator|->
name|bus_regions
argument_list|,
name|reg
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find a bus region that maps @p size bytes at @p addr.  *   * @param br The resource state to search.  * @param addr The requested starting address.  * @param size The requested size.  *   * @retval bhndb_region A region that fully contains the requested range.  * @retval NULL If no mapping region can be found.  */
end_comment

begin_function
name|struct
name|bhndb_region
modifier|*
name|bhndb_find_resource_region
parameter_list|(
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|,
name|bhnd_size_t
name|size
parameter_list|)
block|{
name|struct
name|bhndb_region
modifier|*
name|region
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|region
argument_list|,
argument|&br->bus_regions
argument_list|,
argument|link
argument_list|)
block|{
comment|/* Request must fit within the region's mapping  */
if|if
condition|(
name|addr
operator|<
name|region
operator|->
name|addr
condition|)
continue|continue;
if|if
condition|(
name|addr
operator|+
name|size
operator|>
name|region
operator|->
name|addr
operator|+
name|region
operator|->
name|size
condition|)
continue|continue;
return|return
operator|(
name|region
operator|)
return|;
block|}
comment|/* Not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find the entry matching @p r in @p dwa's references, if any.  *   * @param dwa The dynamic window allocation to search  * @param r The resource to search for in @p dwa.  */
end_comment

begin_function
specifier|static
name|struct
name|bhndb_dw_rentry
modifier|*
name|bhndb_dw_find_resource_entry
parameter_list|(
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|bhndb_dw_rentry
modifier|*
name|rentry
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|rentry
argument_list|,
argument|&dwa->refs
argument_list|,
argument|dw_link
argument_list|)
block|{
name|struct
name|resource
modifier|*
name|dw_res
init|=
name|rentry
operator|->
name|dw_res
decl_stmt|;
comment|/* Match dev/rid/addr/size */
if|if
condition|(
name|rman_get_device
argument_list|(
name|dw_res
argument_list|)
operator|!=
name|rman_get_device
argument_list|(
name|r
argument_list|)
operator|||
name|rman_get_rid
argument_list|(
name|dw_res
argument_list|)
operator|!=
name|rman_get_rid
argument_list|(
name|r
argument_list|)
operator|||
name|rman_get_start
argument_list|(
name|dw_res
argument_list|)
operator|!=
name|rman_get_start
argument_list|(
name|r
argument_list|)
operator|||
name|rman_get_size
argument_list|(
name|dw_res
argument_list|)
operator|!=
name|rman_get_size
argument_list|(
name|r
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|/* Matching allocation found */
return|return
operator|(
name|rentry
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find the dynamic region allocated for @p r, if any.  *   * @param br The resource state to search.  * @param r The resource to search for.  *   * @retval bhndb_dw_alloc The allocation record for @p r.  * @retval NULL if no dynamic window is allocated for @p r.  */
end_comment

begin_function
name|struct
name|bhndb_dw_alloc
modifier|*
name|bhndb_dw_find_resource
parameter_list|(
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|br
operator|->
name|dwa_count
condition|;
name|i
operator|++
control|)
block|{
name|dwa
operator|=
operator|&
name|br
operator|->
name|dw_alloc
index|[
name|i
index|]
expr_stmt|;
comment|/* Skip free dynamic windows */
if|if
condition|(
name|bhndb_dw_is_free
argument_list|(
name|br
argument_list|,
name|dwa
argument_list|)
condition|)
continue|continue;
comment|/* Matching allocation found? */
if|if
condition|(
name|bhndb_dw_find_resource_entry
argument_list|(
name|dwa
argument_list|,
name|r
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|dwa
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find an existing dynamic window mapping @p size bytes  * at @p addr. The window may or may not be free.  *   * @param br The resource state to search.  * @param addr The requested starting address.  * @param size The requested size.  *   * @retval bhndb_dw_alloc A window allocation that fully contains the requested  * range.  * @retval NULL If no mapping region can be found.  */
end_comment

begin_function
name|struct
name|bhndb_dw_alloc
modifier|*
name|bhndb_dw_find_mapping
parameter_list|(
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|,
name|bhnd_addr_t
name|addr
parameter_list|,
name|bhnd_size_t
name|size
parameter_list|)
block|{
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwr
decl_stmt|;
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|win
decl_stmt|;
comment|/* Search for an existing dynamic mapping of this address range. */
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|br
operator|->
name|dwa_count
condition|;
name|i
operator|++
control|)
block|{
name|dwr
operator|=
operator|&
name|br
operator|->
name|dw_alloc
index|[
name|i
index|]
expr_stmt|;
name|win
operator|=
name|dwr
operator|->
name|win
expr_stmt|;
comment|/* Verify the range */
if|if
condition|(
name|addr
operator|<
name|dwr
operator|->
name|target
condition|)
continue|continue;
if|if
condition|(
name|addr
operator|+
name|size
operator|>
name|dwr
operator|->
name|target
operator|+
name|win
operator|->
name|win_size
condition|)
continue|continue;
comment|/* Found a usable mapping */
return|return
operator|(
name|dwr
operator|)
return|;
block|}
comment|/* not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Retain a reference to @p dwa for use by @p res.  *   * @param br The resource state owning @p dwa.  * @param dwa The allocation record to be retained.  * @param res The resource that will own a reference to @p dwa.  *   * @retval 0 success  * @retval ENOMEM Failed to allocate a new reference structure.  */
end_comment

begin_function
name|int
name|bhndb_dw_retain
parameter_list|(
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|,
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|bhndb_dw_rentry
modifier|*
name|rentry
decl_stmt|;
name|KASSERT
argument_list|(
name|bhndb_dw_find_resource_entry
argument_list|(
name|dwa
argument_list|,
name|res
argument_list|)
operator|==
name|NULL
argument_list|,
operator|(
literal|"double-retain of dynamic window for same resource"
operator|)
argument_list|)
expr_stmt|;
comment|/* Insert a reference entry; we use M_NOWAIT to allow use from 	 * within a non-sleepable lock */
name|rentry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rentry
argument_list|)
argument_list|,
name|M_BHND
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rentry
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rentry
operator|->
name|dw_res
operator|=
name|res
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|dwa
operator|->
name|refs
argument_list|,
name|rentry
argument_list|,
name|dw_link
argument_list|)
expr_stmt|;
comment|/* Update the free list */
name|br
operator|->
name|dwa_freelist
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|dwa
operator|->
name|rnid
operator|)
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Release a reference to @p dwa previously retained by @p res. If the  * reference count of @p dwa reaches zero, it will be added to the  * free list.  *   * @param br The resource state owning @p dwa.  * @param dwa The allocation record to be released.  * @param res The resource that currently owns a reference to @p dwa.  */
end_comment

begin_function
name|void
name|bhndb_dw_release
parameter_list|(
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|,
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|bhndb_dw_rentry
modifier|*
name|rentry
decl_stmt|;
comment|/* Find the rentry */
name|rentry
operator|=
name|bhndb_dw_find_resource_entry
argument_list|(
name|dwa
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rentry
operator|!=
name|NULL
argument_list|,
operator|(
literal|"over release of resource entry"
operator|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|rentry
argument_list|,
name|dw_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rentry
argument_list|,
name|M_BHND
argument_list|)
expr_stmt|;
comment|/* If this was the last reference, update the free list */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|dwa
operator|->
name|refs
argument_list|)
condition|)
name|br
operator|->
name|dwa_freelist
operator||=
operator|(
literal|1
operator|<<
operator|(
name|dwa
operator|->
name|rnid
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Attempt to set (or reset) the target address of @p dwa to map @p size bytes  * at @p addr.  *   * This will apply any necessary window alignment and verify that  * the window is capable of mapping the requested range prior to modifying  * therecord.  *   * @param dev The device on which to issue the BHNDB_SET_WINDOW_ADDR() request.  * @param br The resource state owning @p dwa.  * @param dwa The allocation record to be configured.  * @param addr The address to be mapped via @p dwa.  * @param size The number of bytes to be mapped at @p addr.  *  * @retval 0 success  * @retval non-zero no usable register window available.  */
end_comment

begin_function
name|int
name|bhndb_dw_set_addr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|bhndb_resources
modifier|*
name|br
parameter_list|,
name|struct
name|bhndb_dw_alloc
modifier|*
name|dwa
parameter_list|,
name|bus_addr_t
name|addr
parameter_list|,
name|bus_size_t
name|size
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
decl_stmt|;
name|bus_addr_t
name|offset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|rw
operator|=
name|dwa
operator|->
name|win
expr_stmt|;
name|KASSERT
argument_list|(
name|bhndb_dw_is_free
argument_list|(
name|br
argument_list|,
name|dwa
argument_list|)
argument_list|,
operator|(
literal|"attempting to set the target address on an in-use window"
operator|)
argument_list|)
expr_stmt|;
comment|/* Page-align the target address */
name|offset
operator|=
name|addr
operator|%
name|rw
operator|->
name|win_size
expr_stmt|;
name|dwa
operator|->
name|target
operator|=
name|addr
operator|-
name|offset
expr_stmt|;
comment|/* Verify that the window is large enough for the full target */
if|if
condition|(
name|rw
operator|->
name|win_size
operator|-
name|offset
operator|<
name|size
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Update the window target */
name|error
operator|=
name|BHNDB_SET_WINDOW_ADDR
argument_list|(
name|dev
argument_list|,
name|dwa
operator|->
name|win
argument_list|,
name|dwa
operator|->
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dwa
operator|->
name|target
operator|=
literal|0x0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the count of @p type register windows in @p table.  *   * @param table The table to search.  * @param type The required window type, or BHNDB_REGWIN_T_INVALID to  * count all register window types.  */
end_comment

begin_function
name|size_t
name|bhndb_regwin_count
parameter_list|(
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|table
parameter_list|,
name|bhndb_regwin_type_t
name|type
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|rw
operator|=
name|table
init|;
name|rw
operator|->
name|win_type
operator|!=
name|BHNDB_REGWIN_T_INVALID
condition|;
name|rw
operator|++
control|)
block|{
if|if
condition|(
name|type
operator|==
name|BHNDB_REGWIN_T_INVALID
operator|||
name|rw
operator|->
name|win_type
operator|==
name|type
condition|)
name|count
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Search @p table for the first window with the given @p type.  *   * @param table The table to search.  * @param type The required window type.  * @param min_size The minimum window size.  *   * @retval bhndb_regwin The first matching window.  * @retval NULL If no window of the requested type could be found.   */
end_comment

begin_function
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|bhndb_regwin_find_type
parameter_list|(
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|table
parameter_list|,
name|bhndb_regwin_type_t
name|type
parameter_list|,
name|bus_size_t
name|min_size
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
decl_stmt|;
for|for
control|(
name|rw
operator|=
name|table
init|;
name|rw
operator|->
name|win_type
operator|!=
name|BHNDB_REGWIN_T_INVALID
condition|;
name|rw
operator|++
control|)
block|{
if|if
condition|(
name|rw
operator|->
name|win_type
operator|==
name|type
operator|&&
name|rw
operator|->
name|win_size
operator|>=
name|min_size
condition|)
return|return
operator|(
name|rw
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Search @p windows for the first matching core window.  *   * @param table The table to search.  * @param class The required core class.  * @param unit The required core unit, or -1.  * @param port_type The required port type.  * @param port The required port.  * @param region The required region.  *  * @retval bhndb_regwin The first matching window.  * @retval NULL If no matching window was found.   */
end_comment

begin_function
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|bhndb_regwin_find_core
parameter_list|(
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|table
parameter_list|,
name|bhnd_devclass_t
name|class
parameter_list|,
name|int
name|unit
parameter_list|,
name|bhnd_port_type
name|port_type
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|region
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
decl_stmt|;
for|for
control|(
name|rw
operator|=
name|table
init|;
name|rw
operator|->
name|win_type
operator|!=
name|BHNDB_REGWIN_T_INVALID
condition|;
name|rw
operator|++
control|)
block|{
if|if
condition|(
name|rw
operator|->
name|win_type
operator|!=
name|BHNDB_REGWIN_T_CORE
condition|)
continue|continue;
if|if
condition|(
name|rw
operator|->
name|core
operator|.
name|class
operator|!=
name|class
condition|)
continue|continue;
if|if
condition|(
name|unit
operator|!=
operator|-
literal|1
operator|&&
name|rw
operator|->
name|core
operator|.
name|unit
operator|!=
name|unit
condition|)
continue|continue;
if|if
condition|(
name|rw
operator|->
name|core
operator|.
name|port_type
operator|!=
name|port_type
condition|)
continue|continue;
if|if
condition|(
name|rw
operator|->
name|core
operator|.
name|port
operator|!=
name|port
condition|)
continue|continue;
if|if
condition|(
name|rw
operator|->
name|core
operator|.
name|region
operator|!=
name|region
condition|)
continue|continue;
return|return
operator|(
name|rw
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Search @p windows for the best available window of at least @p min_size.  *   * Search order:  * - BHND_REGWIN_T_CORE  * - BHND_REGWIN_T_DYN  *   * @param table The table to search.  * @param class The required core class.  * @param unit The required core unit, or -1.  * @param port_type The required port type.  * @param port The required port.  * @param region The required region.  * @param min_size The minimum window size.  *  * @retval bhndb_regwin The first matching window.  * @retval NULL If no matching window was found.   */
end_comment

begin_function
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|bhndb_regwin_find_best
parameter_list|(
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|table
parameter_list|,
name|bhnd_devclass_t
name|class
parameter_list|,
name|int
name|unit
parameter_list|,
name|bhnd_port_type
name|port_type
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|region
parameter_list|,
name|bus_size_t
name|min_size
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|rw
decl_stmt|;
comment|/* Prefer a fixed core mapping */
name|rw
operator|=
name|bhndb_regwin_find_core
argument_list|(
name|table
argument_list|,
name|class
argument_list|,
name|unit
argument_list|,
name|port_type
argument_list|,
name|port
argument_list|,
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|!=
name|NULL
condition|)
return|return
operator|(
name|rw
operator|)
return|;
comment|/* Fall back on a generic dynamic window */
return|return
operator|(
name|bhndb_regwin_find_type
argument_list|(
name|table
argument_list|,
name|BHNDB_REGWIN_T_DYN
argument_list|,
name|min_size
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if @p regw defines a static port register window, and  * the mapped port is actually defined on @p dev.  *   * @param regw A register window to match against.  * @param dev A bhnd(4) bus device.  */
end_comment

begin_function
name|bool
name|bhndb_regwin_matches_device
parameter_list|(
specifier|const
name|struct
name|bhndb_regwin
modifier|*
name|regw
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
comment|/* Only core windows are supported */
if|if
condition|(
name|regw
operator|->
name|win_type
operator|!=
name|BHNDB_REGWIN_T_CORE
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Device class must match */
if|if
condition|(
name|bhnd_get_class
argument_list|(
name|dev
argument_list|)
operator|!=
name|regw
operator|->
name|core
operator|.
name|class
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Device unit must match */
if|if
condition|(
name|bhnd_get_core_unit
argument_list|(
name|dev
argument_list|)
operator|!=
name|regw
operator|->
name|core
operator|.
name|unit
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* The regwin port/region must be defined. */
if|if
condition|(
operator|!
name|bhnd_is_region_valid
argument_list|(
name|dev
argument_list|,
name|regw
operator|->
name|core
operator|.
name|port_type
argument_list|,
name|regw
operator|->
name|core
operator|.
name|port
argument_list|,
name|regw
operator|->
name|core
operator|.
name|region
argument_list|)
condition|)
block|{
return|return
operator|(
name|false
operator|)
return|;
block|}
comment|/* Matches */
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Search for a core resource priority descriptor in @p table that matches  * @p device.  *   * @param table The table to search.  * @param device A bhnd(4) bus device.  */
end_comment

begin_function
specifier|const
name|struct
name|bhndb_hw_priority
modifier|*
name|bhndb_hw_priority_find_device
parameter_list|(
specifier|const
name|struct
name|bhndb_hw_priority
modifier|*
name|table
parameter_list|,
name|device_t
name|device
parameter_list|)
block|{
specifier|const
name|struct
name|bhndb_hw_priority
modifier|*
name|hp
decl_stmt|;
for|for
control|(
name|hp
operator|=
name|table
init|;
name|hp
operator|->
name|ports
operator|!=
name|NULL
condition|;
name|hp
operator|++
control|)
block|{
if|if
condition|(
name|bhnd_device_matches
argument_list|(
name|device
argument_list|,
operator|&
name|hp
operator|->
name|match
argument_list|)
condition|)
return|return
operator|(
name|hp
operator|)
return|;
block|}
comment|/* not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

end_unit

