begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 Hidetoshi Shimokawa  * Copyright (c) 1998-2002 Katsushi Kobayashi and Hidetoshi Shimokawa  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the acknowledgement as bellow:  *  *    This product includes software developed by K. Kobayashi and H. Shimokawa  *  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *   * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewire.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewirereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/fwdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/iec13213.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/sbp.h>
end_include

begin_define
define|#
directive|define
name|ccb_sdev_ptr
value|spriv_ptr0
end_define

begin_define
define|#
directive|define
name|ccb_sbp_ptr
value|spriv_ptr1
end_define

begin_define
define|#
directive|define
name|SBP_NUM_TARGETS
value|8
end_define

begin_comment
comment|/* MAX 64 */
end_comment

begin_comment
comment|/*  * Scan_bus doesn't work for more than 8 LUNs  * because of CAM_SCSI2_MAXLUN in cam_xpt.c  */
end_comment

begin_define
define|#
directive|define
name|SBP_NUM_LUNS
value|64
end_define

begin_define
define|#
directive|define
name|SBP_MAXPHYS
value|MIN(MAXPHYS, (512*1024)
comment|/* 512KB */
value|)
end_define

begin_define
define|#
directive|define
name|SBP_DMA_SIZE
value|PAGE_SIZE
end_define

begin_define
define|#
directive|define
name|SBP_LOGIN_SIZE
value|sizeof(struct sbp_login_res)
end_define

begin_define
define|#
directive|define
name|SBP_QUEUE_LEN
value|((SBP_DMA_SIZE - SBP_LOGIN_SIZE) / sizeof(struct sbp_ocb))
end_define

begin_define
define|#
directive|define
name|SBP_NUM_OCB
value|(SBP_QUEUE_LEN * SBP_NUM_TARGETS)
end_define

begin_comment
comment|/*   * STATUS FIFO addressing  *   bit  * -----------------------  *  0- 1( 2): 0 (alignment)  *  2- 7( 6): target  *  8-15( 8): lun  * 16-31( 8): reserved  * 32-47(16): SBP_BIND_HI   * 48-64(16): bus_id, node_id   */
end_comment

begin_define
define|#
directive|define
name|SBP_BIND_HI
value|0x1
end_define

begin_define
define|#
directive|define
name|SBP_DEV2ADDR
parameter_list|(
name|t
parameter_list|,
name|l
parameter_list|)
define|\
value|(((u_int64_t)SBP_BIND_HI<< 32) \ 	| (((l)& 0xff)<< 8) \ 	| (((t)& 0x3f)<< 2))
end_define

begin_define
define|#
directive|define
name|SBP_ADDR2TRG
parameter_list|(
name|a
parameter_list|)
value|(((a)>> 2)& 0x3f)
end_define

begin_define
define|#
directive|define
name|SBP_ADDR2LUN
parameter_list|(
name|a
parameter_list|)
value|(((a)>> 8)& 0xff)
end_define

begin_define
define|#
directive|define
name|SBP_INITIATOR
value|7
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|orb_fun_name
index|[]
init|=
block|{
name|ORB_FUN_NAMES
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|auto_login
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_speed
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sbp_cold
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ex_login
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|login_delay
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* msec */
end_comment

begin_decl_stmt
specifier|static
name|int
name|scan_delay
init|=
literal|500
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* msec */
end_comment

begin_decl_stmt
specifier|static
name|int
name|use_doorbell
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sbp_tags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_firewire
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw_firewire
argument_list|,
name|OID_AUTO
argument_list|,
name|sbp
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"SBP-II Subsystem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|sbp_debug
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|debug
argument_list|,
literal|0
argument_list|,
literal|"SBP debug flag"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_sbp
argument_list|,
name|OID_AUTO
argument_list|,
name|auto_login
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|auto_login
argument_list|,
literal|0
argument_list|,
literal|"SBP perform login automatically"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_sbp
argument_list|,
name|OID_AUTO
argument_list|,
name|max_speed
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|max_speed
argument_list|,
literal|0
argument_list|,
literal|"SBP transfer max speed"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_sbp
argument_list|,
name|OID_AUTO
argument_list|,
name|exclusive_login
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|ex_login
argument_list|,
literal|0
argument_list|,
literal|"SBP enable exclusive login"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_sbp
argument_list|,
name|OID_AUTO
argument_list|,
name|login_delay
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|login_delay
argument_list|,
literal|0
argument_list|,
literal|"SBP login delay in msec"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_sbp
argument_list|,
name|OID_AUTO
argument_list|,
name|scan_delay
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|scan_delay
argument_list|,
literal|0
argument_list|,
literal|"SBP scan delay in msec"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_sbp
argument_list|,
name|OID_AUTO
argument_list|,
name|use_doorbell
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|use_doorbell
argument_list|,
literal|0
argument_list|,
literal|"SBP use doorbell request"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_sbp
argument_list|,
name|OID_AUTO
argument_list|,
name|tags
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|sbp_tags
argument_list|,
literal|0
argument_list|,
literal|"SBP tagged queuing support"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NEED_RESPONSE
value|0
end_define

begin_define
define|#
directive|define
name|SBP_SEG_MAX
value|rounddown(0xffff, PAGE_SIZE)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__sparc64__
end_ifdef

begin_comment
comment|/* iommu */
end_comment

begin_define
define|#
directive|define
name|SBP_IND_MAX
value|howmany(SBP_MAXPHYS, SBP_SEG_MAX)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SBP_IND_MAX
value|howmany(SBP_MAXPHYS, PAGE_SIZE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|sbp_ocb
block|{
name|STAILQ_ENTRY
argument_list|(
argument|sbp_ocb
argument_list|)
name|ocb
expr_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|bus_addr_t
name|bus_addr
decl_stmt|;
name|uint32_t
name|orb
index|[
literal|8
index|]
decl_stmt|;
define|#
directive|define
name|IND_PTR_OFFSET
value|(8*sizeof(uint32_t))
name|struct
name|ind_ptr
name|ind_ptr
index|[
name|SBP_IND_MAX
index|]
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* XXX should be removed */
name|bus_dmamap_t
name|dmamap
decl_stmt|;
name|struct
name|callout
name|timer
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|OCB_ACT_MGM
value|0
end_define

begin_define
define|#
directive|define
name|OCB_ACT_CMD
value|1
end_define

begin_define
define|#
directive|define
name|OCB_MATCH
parameter_list|(
name|o
parameter_list|,
name|s
parameter_list|)
value|((o)->bus_addr == ntohl((s)->orb_lo))
end_define

begin_struct
struct|struct
name|sbp_dev
block|{
define|#
directive|define
name|SBP_DEV_RESET
value|0
comment|/* accept login */
define|#
directive|define
name|SBP_DEV_LOGIN
value|1
comment|/* to login */
if|#
directive|if
literal|0
define|#
directive|define
name|SBP_DEV_RECONN
value|2
comment|/* to reconnect */
endif|#
directive|endif
define|#
directive|define
name|SBP_DEV_TOATTACH
value|3
comment|/* to attach */
define|#
directive|define
name|SBP_DEV_PROBE
value|4
comment|/* scan lun */
define|#
directive|define
name|SBP_DEV_ATTACHED
value|5
comment|/* in operation */
define|#
directive|define
name|SBP_DEV_DEAD
value|6
comment|/* unavailable unit */
define|#
directive|define
name|SBP_DEV_RETRY
value|7
comment|/* unavailable unit */
name|uint8_t
name|status
range|:
literal|4
decl_stmt|,
name|timeout
range|:
literal|4
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
name|uint16_t
name|lun_id
decl_stmt|;
name|uint16_t
name|freeze
decl_stmt|;
define|#
directive|define
name|ORB_LINK_DEAD
value|(1<< 0)
define|#
directive|define
name|VALID_LUN
value|(1<< 1)
define|#
directive|define
name|ORB_POINTER_ACTIVE
value|(1<< 2)
define|#
directive|define
name|ORB_POINTER_NEED
value|(1<< 3)
define|#
directive|define
name|ORB_DOORBELL_ACTIVE
value|(1<< 4)
define|#
directive|define
name|ORB_DOORBELL_NEED
value|(1<< 5)
define|#
directive|define
name|ORB_SHORTAGE
value|(1<< 6)
name|uint16_t
name|flags
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|struct
name|fwdma_alloc
name|dma
decl_stmt|;
name|struct
name|sbp_login_res
modifier|*
name|login
decl_stmt|;
name|struct
name|callout
name|login_callout
decl_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|sbp_ocb
argument_list|)
name|ocbs
expr_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|sbp_ocb
argument_list|)
name|free_ocbs
expr_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|last_ocb
decl_stmt|;
name|char
name|vendor
index|[
literal|32
index|]
decl_stmt|;
name|char
name|product
index|[
literal|32
index|]
decl_stmt|;
name|char
name|revision
index|[
literal|10
index|]
decl_stmt|;
name|char
name|bustgtlun
index|[
literal|32
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sbp_target
block|{
name|int
name|target_id
decl_stmt|;
name|int
name|num_lun
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
modifier|*
name|luns
decl_stmt|;
name|struct
name|sbp_softc
modifier|*
name|sbp
decl_stmt|;
name|struct
name|fw_device
modifier|*
name|fwdev
decl_stmt|;
name|uint32_t
name|mgm_hi
decl_stmt|,
name|mgm_lo
decl_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|mgm_ocb_cur
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|sbp_ocb
argument_list|)
name|mgm_ocb_queue
expr_stmt|;
name|struct
name|callout
name|mgm_ocb_timeout
decl_stmt|;
name|struct
name|callout
name|scan_callout
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|fw_xfer
argument_list|)
name|xferlist
expr_stmt|;
name|int
name|n_xfer
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sbp_softc
block|{
name|struct
name|firewire_dev_comm
name|fd
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|sbp_target
name|targets
index|[
name|SBP_NUM_TARGETS
index|]
decl_stmt|;
name|struct
name|fw_bind
name|fwb
decl_stmt|;
name|bus_dma_tag_t
name|dmat
decl_stmt|;
name|struct
name|timeval
name|last_busreset
decl_stmt|;
define|#
directive|define
name|SIMQ_FREEZED
value|1
name|int
name|flags
decl_stmt|;
name|struct
name|mtx
name|mtx
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SBP_LOCK
parameter_list|(
name|sbp
parameter_list|)
value|mtx_lock(&(sbp)->mtx)
end_define

begin_define
define|#
directive|define
name|SBP_UNLOCK
parameter_list|(
name|sbp
parameter_list|)
value|mtx_unlock(&(sbp)->mtx)
end_define

begin_define
define|#
directive|define
name|SBP_LOCK_ASSERT
parameter_list|(
name|sbp
parameter_list|)
value|mtx_assert(&(sbp)->mtx, MA_OWNED)
end_define

begin_function_decl
specifier|static
name|void
name|sbp_post_explore
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_recv
parameter_list|(
name|struct
name|fw_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_mgm_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void sbp_cmd_callback (struct fw_xfer *);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|sbp_orb_pointer
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|,
name|struct
name|sbp_ocb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_doorbell
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_execute_ocb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_free_ocb
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|,
name|struct
name|sbp_ocb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_abort_ocb
parameter_list|(
name|struct
name|sbp_ocb
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_abort_all_ocbs
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|fw_xfer
modifier|*
name|sbp_write_cmd
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|sbp_ocb
modifier|*
name|sbp_get_ocb
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|sbp_ocb
modifier|*
name|sbp_enqueue_ocb
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|,
name|struct
name|sbp_ocb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|sbp_ocb
modifier|*
name|sbp_dequeue_ocb
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|,
name|struct
name|sbp_status
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_cam_detach_sdev
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_free_sdev
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_cam_detach_target
parameter_list|(
name|struct
name|sbp_target
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_free_target
parameter_list|(
name|struct
name|sbp_target
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_mgm_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_mgm_orb
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|sbp_ocb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_SBP
argument_list|,
literal|"sbp"
argument_list|,
literal|"SBP-II/FireWire"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* cam related functions */
end_comment

begin_function_decl
specifier|static
name|void
name|sbp_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_cam_scan_lun
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_cam_scan_target
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|orb_status0
index|[]
init|=
block|{
comment|/* 0 */
literal|"No additional information to report"
block|,
comment|/* 1 */
literal|"Request type not supported"
block|,
comment|/* 2 */
literal|"Speed not supported"
block|,
comment|/* 3 */
literal|"Page size not supported"
block|,
comment|/* 4 */
literal|"Access denied"
block|,
comment|/* 5 */
literal|"Logical unit not supported"
block|,
comment|/* 6 */
literal|"Maximum payload too small"
block|,
comment|/* 7 */
literal|"Reserved for future standardization"
block|,
comment|/* 8 */
literal|"Resources unavailable"
block|,
comment|/* 9 */
literal|"Function rejected"
block|,
comment|/* A */
literal|"Login ID not recognized"
block|,
comment|/* B */
literal|"Dummy ORB completed"
block|,
comment|/* C */
literal|"Request aborted"
block|,
comment|/* FF */
literal|"Unspecified error"
define|#
directive|define
name|MAX_ORB_STATUS0
value|0xd
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|orb_status1_object
index|[]
init|=
block|{
comment|/* 0 */
literal|"Operation request block (ORB)"
block|,
comment|/* 1 */
literal|"Data buffer"
block|,
comment|/* 2 */
literal|"Page table"
block|,
comment|/* 3 */
literal|"Unable to specify"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|orb_status1_serial_bus_error
index|[]
init|=
block|{
comment|/* 0 */
literal|"Missing acknowledge"
block|,
comment|/* 1 */
literal|"Reserved; not to be used"
block|,
comment|/* 2 */
literal|"Time-out error"
block|,
comment|/* 3 */
literal|"Reserved; not to be used"
block|,
comment|/* 4 */
literal|"Busy retry limit exceeded(X)"
block|,
comment|/* 5 */
literal|"Busy retry limit exceeded(A)"
block|,
comment|/* 6 */
literal|"Busy retry limit exceeded(B)"
block|,
comment|/* 7 */
literal|"Reserved for future standardization"
block|,
comment|/* 8 */
literal|"Reserved for future standardization"
block|,
comment|/* 9 */
literal|"Reserved for future standardization"
block|,
comment|/* A */
literal|"Reserved for future standardization"
block|,
comment|/* B */
literal|"Tardy retry limit exceeded"
block|,
comment|/* C */
literal|"Conflict error"
block|,
comment|/* D */
literal|"Data error"
block|,
comment|/* E */
literal|"Type error"
block|,
comment|/* F */
literal|"Address error"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sbp_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"sbp_identify\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|device_find_child
argument_list|(
name|parent
argument_list|,
literal|"sbp"
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|NULL
condition|)
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|"sbp"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sbp_probe()  */
end_comment

begin_function
specifier|static
name|int
name|sbp_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"sbp_probe\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"SBP-2/SCSI over FireWire"
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
block|if (bootverbose) 		debug = bootverbose;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Display device characteristics on the console  */
end_comment

begin_function
specifier|static
name|void
name|sbp_show_sdev_info
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|struct
name|fw_device
modifier|*
name|fwdev
decl_stmt|;
name|fwdev
operator|=
name|sdev
operator|->
name|target
operator|->
name|fwdev
expr_stmt|;
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s: %s: ordered:%d type:%d EUI:%08x%08x node:%d "
literal|"speed:%d maxrec:%d\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|,
operator|(
name|sdev
operator|->
name|type
operator|&
literal|0x40
operator|)
operator|>>
literal|6
argument_list|,
operator|(
name|sdev
operator|->
name|type
operator|&
literal|0x1f
operator|)
argument_list|,
name|fwdev
operator|->
name|eui
operator|.
name|hi
argument_list|,
name|fwdev
operator|->
name|eui
operator|.
name|lo
argument_list|,
name|fwdev
operator|->
name|dst
argument_list|,
name|fwdev
operator|->
name|speed
argument_list|,
name|fwdev
operator|->
name|maxrec
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s: %s '%s' '%s' '%s'\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|,
name|sdev
operator|->
name|vendor
argument_list|,
name|sdev
operator|->
name|product
argument_list|,
name|sdev
operator|->
name|revision
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
name|int
name|bus
decl_stmt|;
name|int
name|target
decl_stmt|;
name|struct
name|fw_eui64
name|eui
decl_stmt|;
block|}
name|wired
index|[]
init|=
block|{
comment|/* Bus	Target	EUI64 */
if|#
directive|if
literal|0
block|{0,	2,	{0x00018ea0, 0x01fd0154}},
comment|/* Logitec HDD */
block|{0,	0,	{0x00018ea6, 0x00100682}},
comment|/* Logitec DVD */
block|{0,	1,	{0x00d03200, 0xa412006a}},
comment|/* Yano HDD */
endif|#
directive|endif
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|sbp_new_target
parameter_list|(
name|struct
name|sbp_softc
modifier|*
name|sbp
parameter_list|,
name|struct
name|fw_device
modifier|*
name|fwdev
parameter_list|)
block|{
name|int
name|bus
decl_stmt|,
name|i
decl_stmt|,
name|target
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|w
index|[
name|SBP_NUM_TARGETS
index|]
decl_stmt|;
name|bzero
argument_list|(
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
name|bus
operator|=
name|device_get_unit
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
expr_stmt|;
comment|/* XXX wired-down configuration should be gotten from 					tunable or device hint */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|wired
index|[
name|i
index|]
operator|.
name|bus
operator|>=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wired
index|[
name|i
index|]
operator|.
name|bus
operator|==
name|bus
condition|)
block|{
name|w
index|[
name|wired
index|[
name|i
index|]
operator|.
name|target
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|wired
index|[
name|i
index|]
operator|.
name|eui
operator|.
name|hi
operator|==
name|fwdev
operator|->
name|eui
operator|.
name|hi
operator|&&
name|wired
index|[
name|i
index|]
operator|.
name|eui
operator|.
name|lo
operator|==
name|fwdev
operator|->
name|eui
operator|.
name|lo
condition|)
name|target
operator|=
name|wired
index|[
name|i
index|]
operator|.
name|target
expr_stmt|;
block|}
block|}
if|if
condition|(
name|target
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|target
operator|<
name|SBP_NUM_TARGETS
operator|&&
name|sbp
operator|->
name|targets
index|[
name|target
index|]
operator|.
name|fwdev
operator|==
name|NULL
condition|)
return|return
operator|(
name|target
operator|)
return|;
name|device_printf
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"target %d is not free for %08x:%08x\n"
argument_list|,
name|target
argument_list|,
name|fwdev
operator|->
name|eui
operator|.
name|hi
argument_list|,
name|fwdev
operator|->
name|eui
operator|.
name|lo
argument_list|)
expr_stmt|;
name|target
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* non-wired target */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBP_NUM_TARGETS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sbp
operator|->
name|targets
index|[
name|i
index|]
operator|.
name|fwdev
operator|==
name|NULL
operator|&&
name|w
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|target
operator|=
name|i
expr_stmt|;
break|break;
block|}
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_alloc_lun
parameter_list|(
name|struct
name|sbp_target
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|crom_context
name|cc
decl_stmt|;
name|struct
name|csrreg
modifier|*
name|reg
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|,
modifier|*
modifier|*
name|newluns
decl_stmt|;
name|struct
name|sbp_softc
modifier|*
name|sbp
decl_stmt|;
name|int
name|maxlun
decl_stmt|,
name|lun
decl_stmt|,
name|i
decl_stmt|;
name|sbp
operator|=
name|target
operator|->
name|sbp
expr_stmt|;
name|SBP_LOCK_ASSERT
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|crom_init_context
argument_list|(
operator|&
name|cc
argument_list|,
name|target
operator|->
name|fwdev
operator|->
name|csrrom
argument_list|)
expr_stmt|;
comment|/* XXX shoud parse appropriate unit directories only */
name|maxlun
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|cc
operator|.
name|depth
operator|>=
literal|0
condition|)
block|{
name|reg
operator|=
name|crom_search_key
argument_list|(
operator|&
name|cc
argument_list|,
name|CROM_LUN
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
break|break;
name|lun
operator|=
name|reg
operator|->
name|val
operator|&
literal|0xffff
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"target %d lun %d found\n"
argument_list|,
name|target
operator|->
name|target_id
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|maxlun
operator|<
name|lun
condition|)
name|maxlun
operator|=
name|lun
expr_stmt|;
name|crom_next
argument_list|(
operator|&
name|cc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxlun
operator|<
literal|0
condition|)
name|device_printf
argument_list|(
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%d no LUN found\n"
argument_list|,
name|target
operator|->
name|target_id
argument_list|)
expr_stmt|;
name|maxlun
operator|++
expr_stmt|;
if|if
condition|(
name|maxlun
operator|>=
name|SBP_NUM_LUNS
condition|)
name|maxlun
operator|=
name|SBP_NUM_LUNS
expr_stmt|;
comment|/* Invalidiate stale devices */
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<
name|target
operator|->
name|num_lun
condition|;
name|lun
operator|++
control|)
block|{
name|sdev
operator|=
name|target
operator|->
name|luns
index|[
name|lun
index|]
expr_stmt|;
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
continue|continue;
name|sdev
operator|->
name|flags
operator|&=
operator|~
name|VALID_LUN
expr_stmt|;
if|if
condition|(
name|lun
operator|>=
name|maxlun
condition|)
block|{
comment|/* lost device */
name|sbp_cam_detach_sdev
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
name|sbp_free_sdev
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
name|target
operator|->
name|luns
index|[
name|lun
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Reallocate */
if|if
condition|(
name|maxlun
operator|!=
name|target
operator|->
name|num_lun
condition|)
block|{
name|newluns
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|target
operator|->
name|luns
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbp_dev
operator|*
argument_list|)
operator|*
name|maxlun
argument_list|,
name|M_SBP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|newluns
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: realloc failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|newluns
operator|=
name|target
operator|->
name|luns
expr_stmt|;
name|maxlun
operator|=
name|target
operator|->
name|num_lun
expr_stmt|;
block|}
comment|/* 		 * We must zero the extended region for the case 		 * realloc() doesn't allocate new buffer. 		 */
if|if
condition|(
name|maxlun
operator|>
name|target
operator|->
name|num_lun
condition|)
name|bzero
argument_list|(
operator|&
name|newluns
index|[
name|target
operator|->
name|num_lun
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbp_dev
operator|*
argument_list|)
operator|*
operator|(
name|maxlun
operator|-
name|target
operator|->
name|num_lun
operator|)
argument_list|)
expr_stmt|;
name|target
operator|->
name|luns
operator|=
name|newluns
expr_stmt|;
name|target
operator|->
name|num_lun
operator|=
name|maxlun
expr_stmt|;
block|}
name|crom_init_context
argument_list|(
operator|&
name|cc
argument_list|,
name|target
operator|->
name|fwdev
operator|->
name|csrrom
argument_list|)
expr_stmt|;
while|while
condition|(
name|cc
operator|.
name|depth
operator|>=
literal|0
condition|)
block|{
name|int
name|new
init|=
literal|0
decl_stmt|;
name|reg
operator|=
name|crom_search_key
argument_list|(
operator|&
name|cc
argument_list|,
name|CROM_LUN
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
break|break;
name|lun
operator|=
name|reg
operator|->
name|val
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|lun
operator|>=
name|SBP_NUM_LUNS
condition|)
block|{
name|printf
argument_list|(
literal|"too large lun %d\n"
argument_list|,
name|lun
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|sdev
operator|=
name|target
operator|->
name|luns
index|[
name|lun
index|]
expr_stmt|;
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
block|{
name|sdev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sbp_dev
argument_list|)
argument_list|,
name|M_SBP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: malloc failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|target
operator|->
name|luns
index|[
name|lun
index|]
operator|=
name|sdev
expr_stmt|;
name|sdev
operator|->
name|lun_id
operator|=
name|lun
expr_stmt|;
name|sdev
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sdev
operator|->
name|ocbs
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sdev
operator|->
name|login_callout
argument_list|,
operator|&
name|sbp
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_RESET
expr_stmt|;
name|new
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|sdev
operator|->
name|bustgtlun
argument_list|,
literal|32
argument_list|,
literal|"%s:%d:%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|sdev
operator|->
name|target
operator|->
name|target_id
argument_list|,
name|sdev
operator|->
name|lun_id
argument_list|)
expr_stmt|;
block|}
name|sdev
operator|->
name|flags
operator||=
name|VALID_LUN
expr_stmt|;
name|sdev
operator|->
name|type
operator|=
operator|(
name|reg
operator|->
name|val
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
goto|goto
name|next
goto|;
name|fwdma_malloc
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|fc
argument_list|,
comment|/* alignment */
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|SBP_DMA_SIZE
argument_list|,
operator|&
name|sdev
operator|->
name|dma
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_COHERENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdev
operator|->
name|dma
operator|.
name|v_addr
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: dma space allocation failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sdev
argument_list|,
name|M_SBP
argument_list|)
expr_stmt|;
name|target
operator|->
name|luns
index|[
name|lun
index|]
operator|=
name|NULL
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|sdev
operator|->
name|login
operator|=
operator|(
expr|struct
name|sbp_login_res
operator|*
operator|)
name|sdev
operator|->
name|dma
operator|.
name|v_addr
expr_stmt|;
name|sdev
operator|->
name|ocb
operator|=
operator|(
expr|struct
name|sbp_ocb
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|sdev
operator|->
name|dma
operator|.
name|v_addr
operator|+
name|SBP_LOGIN_SIZE
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sdev
operator|->
name|ocb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbp_ocb
argument_list|)
operator|*
name|SBP_QUEUE_LEN
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sdev
operator|->
name|free_ocbs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBP_QUEUE_LEN
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|ocb
operator|=
operator|&
name|sdev
operator|->
name|ocb
index|[
name|i
index|]
expr_stmt|;
name|ocb
operator|->
name|bus_addr
operator|=
name|sdev
operator|->
name|dma
operator|.
name|bus_addr
operator|+
name|SBP_LOGIN_SIZE
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sbp_ocb
argument_list|)
operator|*
name|i
operator|+
name|offsetof
argument_list|(
expr|struct
name|sbp_ocb
argument_list|,
name|orb
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sbp
operator|->
name|dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|ocb
operator|->
name|dmamap
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_attach: cannot create dmamap\n"
argument_list|)
expr_stmt|;
comment|/* XXX */
goto|goto
name|next
goto|;
block|}
name|callout_init_mtx
argument_list|(
operator|&
name|ocb
operator|->
name|timer
argument_list|,
operator|&
name|sbp
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sbp_free_ocb
argument_list|(
name|sdev
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
block|}
name|next
label|:
name|crom_next
argument_list|(
operator|&
name|cc
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<
name|target
operator|->
name|num_lun
condition|;
name|lun
operator|++
control|)
block|{
name|sdev
operator|=
name|target
operator|->
name|luns
index|[
name|lun
index|]
expr_stmt|;
if|if
condition|(
name|sdev
operator|!=
name|NULL
operator|&&
operator|(
name|sdev
operator|->
name|flags
operator|&
name|VALID_LUN
operator|)
operator|==
literal|0
condition|)
block|{
name|sbp_cam_detach_sdev
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
name|sbp_free_sdev
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
name|target
operator|->
name|luns
index|[
name|lun
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|sbp_target
modifier|*
name|sbp_alloc_target
parameter_list|(
name|struct
name|sbp_softc
modifier|*
name|sbp
parameter_list|,
name|struct
name|fw_device
modifier|*
name|fwdev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|struct
name|crom_context
name|cc
decl_stmt|;
name|struct
name|csrreg
modifier|*
name|reg
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"sbp_alloc_target\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|i
init|=
name|sbp_new_target
argument_list|(
name|sbp
argument_list|,
name|fwdev
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"increase SBP_NUM_TARGETS!\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* new target */
name|target
operator|=
operator|&
name|sbp
operator|->
name|targets
index|[
name|i
index|]
expr_stmt|;
name|target
operator|->
name|fwdev
operator|=
name|fwdev
expr_stmt|;
name|target
operator|->
name|target_id
operator|=
name|i
expr_stmt|;
comment|/* XXX we may want to reload mgm port after each bus reset */
comment|/* XXX there might be multiple management agents */
name|crom_init_context
argument_list|(
operator|&
name|cc
argument_list|,
name|target
operator|->
name|fwdev
operator|->
name|csrrom
argument_list|)
expr_stmt|;
name|reg
operator|=
name|crom_search_key
argument_list|(
operator|&
name|cc
argument_list|,
name|CROM_MGM
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
operator|||
name|reg
operator|->
name|val
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"NULL management address\n"
argument_list|)
expr_stmt|;
name|target
operator|->
name|fwdev
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|target
operator|->
name|mgm_hi
operator|=
literal|0xffff
expr_stmt|;
name|target
operator|->
name|mgm_lo
operator|=
literal|0xf0000000
operator||
operator|(
name|reg
operator|->
name|val
operator|<<
literal|2
operator|)
expr_stmt|;
name|target
operator|->
name|mgm_ocb_cur
operator|=
name|NULL
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"target:%d mgm_port: %x\n"
argument_list|,
name|i
argument_list|,
name|target
operator|->
name|mgm_lo
argument_list|)
expr_stmt|;
name|END_DEBUG
name|STAILQ_INIT
argument_list|(
operator|&
name|target
operator|->
name|xferlist
argument_list|)
decl_stmt|;
name|target
operator|->
name|n_xfer
operator|=
literal|0
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|target
operator|->
name|mgm_ocb_queue
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|target
operator|->
name|mgm_ocb_timeout
argument_list|,
operator|&
name|sbp
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|target
operator|->
name|scan_callout
argument_list|,
operator|&
name|sbp
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|target
operator|->
name|luns
operator|=
name|NULL
expr_stmt|;
name|target
operator|->
name|num_lun
operator|=
literal|0
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_probe_lun
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|struct
name|fw_device
modifier|*
name|fwdev
decl_stmt|;
name|struct
name|crom_context
name|c
decl_stmt|,
modifier|*
name|cc
init|=
operator|&
name|c
decl_stmt|;
name|struct
name|csrreg
modifier|*
name|reg
decl_stmt|;
name|bzero
argument_list|(
name|sdev
operator|->
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|sdev
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sdev
operator|->
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|sdev
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|fwdev
operator|=
name|sdev
operator|->
name|target
operator|->
name|fwdev
expr_stmt|;
name|crom_init_context
argument_list|(
name|cc
argument_list|,
name|fwdev
operator|->
name|csrrom
argument_list|)
expr_stmt|;
comment|/* get vendor string */
name|crom_search_key
argument_list|(
name|cc
argument_list|,
name|CSRKEY_VENDOR
argument_list|)
expr_stmt|;
name|crom_next
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|crom_parse_text
argument_list|(
name|cc
argument_list|,
name|sdev
operator|->
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|sdev
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
comment|/* skip to the unit directory for SBP-2 */
while|while
condition|(
operator|(
name|reg
operator|=
name|crom_search_key
argument_list|(
name|cc
argument_list|,
name|CSRKEY_VER
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|reg
operator|->
name|val
operator|==
name|CSRVAL_T10SBP2
condition|)
break|break;
name|crom_next
argument_list|(
name|cc
argument_list|)
expr_stmt|;
block|}
comment|/* get firmware revision */
name|reg
operator|=
name|crom_search_key
argument_list|(
name|cc
argument_list|,
name|CSRKEY_FIRM_VER
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|NULL
condition|)
name|snprintf
argument_list|(
name|sdev
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|sdev
operator|->
name|revision
argument_list|)
argument_list|,
literal|"%06x"
argument_list|,
name|reg
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/* get product string */
name|crom_search_key
argument_list|(
name|cc
argument_list|,
name|CSRKEY_MODEL
argument_list|)
expr_stmt|;
name|crom_next
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|crom_parse_text
argument_list|(
name|cc
argument_list|,
name|sdev
operator|->
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|sdev
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_login_callout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
init|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|arg
decl_stmt|;
name|SBP_LOCK_ASSERT
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
name|sbp_mgm_orb
argument_list|(
name|sdev
argument_list|,
name|ORB_FUN_LGI
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_login
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|struct
name|timeval
name|delta
decl_stmt|;
name|struct
name|timeval
name|t
decl_stmt|;
name|int
name|ticks
init|=
literal|0
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|delta
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|last_busreset
argument_list|)
expr_stmt|;
name|t
operator|.
name|tv_sec
operator|=
name|login_delay
operator|/
literal|1000
expr_stmt|;
name|t
operator|.
name|tv_usec
operator|=
operator|(
name|login_delay
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|tv_sec
operator|>=
literal|0
operator|&&
name|t
operator|.
name|tv_usec
operator|>
literal|0
condition|)
name|ticks
operator|=
operator|(
name|t
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
name|t
operator|.
name|tv_usec
operator|/
literal|1000
operator|)
operator|*
name|hz
operator|/
literal|1000
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"%s: sec = %jd usec = %ld ticks = %d\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|intmax_t
operator|)
name|t
operator|.
name|tv_sec
argument_list|,
name|t
operator|.
name|tv_usec
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
name|END_DEBUG
name|callout_reset
argument_list|(
operator|&
name|sdev
operator|->
name|login_callout
argument_list|,
name|ticks
argument_list|,
name|sbp_login_callout
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|sdev
operator|)
argument_list|)
decl_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SBP_FWDEV_ALIVE
parameter_list|(
name|fwdev
parameter_list|)
value|(((fwdev)->status == FWDEVATTACHED) \&& crom_has_specver((fwdev)->csrrom, CSRVAL_ANSIT10, CSRVAL_T10SBP2))
end_define

begin_function
specifier|static
name|void
name|sbp_probe_target
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sbp_target
modifier|*
name|target
init|=
operator|(
expr|struct
name|sbp_target
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|sbp_softc
modifier|*
name|sbp
init|=
name|target
operator|->
name|sbp
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|int
name|i
decl_stmt|,
name|alive
decl_stmt|;
name|alive
operator|=
name|SBP_FWDEV_ALIVE
argument_list|(
name|target
operator|->
name|fwdev
argument_list|)
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|device_printf
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s %d%salive\n"
argument_list|,
name|__func__
argument_list|,
name|target
operator|->
name|target_id
argument_list|,
operator|(
operator|!
name|alive
operator|)
condition|?
literal|" not "
else|:
literal|""
argument_list|)
expr_stmt|;
name|END_DEBUG
name|sbp
init|=
name|target
operator|->
name|sbp
decl_stmt|;
name|SBP_LOCK_ASSERT
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|sbp_alloc_lun
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|/* XXX untimeout mgm_ocb and dequeue */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|target
operator|->
name|num_lun
condition|;
name|i
operator|++
control|)
block|{
name|sdev
operator|=
name|target
operator|->
name|luns
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|alive
operator|&&
operator|(
name|sdev
operator|->
name|status
operator|!=
name|SBP_DEV_DEAD
operator|)
condition|)
block|{
if|if
condition|(
name|sdev
operator|->
name|path
operator|!=
name|NULL
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|freeze
operator|++
expr_stmt|;
block|}
name|sbp_probe_lun
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
name|sbp_abort_all_ocbs
argument_list|(
name|sdev
argument_list|,
name|CAM_SCSI_BUS_RESET
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sdev
operator|->
name|status
condition|)
block|{
case|case
name|SBP_DEV_RESET
case|:
comment|/* new or revived target */
if|if
condition|(
name|auto_login
condition|)
name|sbp_login
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
break|break;
case|case
name|SBP_DEV_TOATTACH
case|:
case|case
name|SBP_DEV_PROBE
case|:
case|case
name|SBP_DEV_ATTACHED
case|:
case|case
name|SBP_DEV_RETRY
case|:
default|default:
name|sbp_mgm_orb
argument_list|(
name|sdev
argument_list|,
name|ORB_FUN_RCN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|sdev
operator|->
name|status
condition|)
block|{
case|case
name|SBP_DEV_ATTACHED
case|:
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
comment|/* the device has gone */
name|device_printf
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s: lost target\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|sdev
operator|->
name|path
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|freeze
operator|++
expr_stmt|;
block|}
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_RETRY
expr_stmt|;
name|sbp_cam_detach_sdev
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
name|sbp_free_sdev
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
name|target
operator|->
name|luns
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|SBP_DEV_PROBE
case|:
case|case
name|SBP_DEV_TOATTACH
case|:
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_RESET
expr_stmt|;
break|break;
case|case
name|SBP_DEV_RETRY
case|:
case|case
name|SBP_DEV_RESET
case|:
case|case
name|SBP_DEV_DEAD
case|:
break|break;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_post_busreset
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sbp_softc
modifier|*
name|sbp
decl_stmt|;
name|sbp
operator|=
operator|(
expr|struct
name|sbp_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"sbp_post_busreset\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|SBP_LOCK
argument_list|(
name|sbp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|sbp
operator|->
name|sim
operator|->
name|flags
operator|&
name|SIMQ_FREEZED
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|sbp
operator|->
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|sim
operator|->
name|flags
operator||=
name|SIMQ_FREEZED
expr_stmt|;
block|}
name|microtime
argument_list|(
operator|&
name|sbp
operator|->
name|last_busreset
argument_list|)
expr_stmt|;
name|SBP_UNLOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_post_explore
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sbp_softc
modifier|*
name|sbp
init|=
operator|(
expr|struct
name|sbp_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|struct
name|fw_device
modifier|*
name|fwdev
decl_stmt|;
name|int
name|i
decl_stmt|,
name|alive
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"sbp_post_explore (sbp_cold=%d)\n"
argument_list|,
name|sbp_cold
argument_list|)
expr_stmt|;
name|END_DEBUG
comment|/* We need physical access */
if|if
condition|(
operator|!
name|firewire_phydma_enable
condition|)
return|return;
if|if
condition|(
name|sbp_cold
operator|>
literal|0
condition|)
name|sbp_cold
operator|--
expr_stmt|;
name|SBP_LOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * XXX don't let CAM the bus rest. 	 * CAM tries to do something with freezed (DEV_RETRY) devices. 	 */
block|xpt_async(AC_BUS_RESET, sbp->path,
comment|/*arg*/
block|NULL);
endif|#
directive|endif
comment|/* Garbage Collection */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBP_NUM_TARGETS
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
operator|&
name|sbp
operator|->
name|targets
index|[
name|i
index|]
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|fwdev
argument_list|,
argument|&sbp->fd.fc->devices
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|target
operator|->
name|fwdev
operator|==
name|NULL
operator|||
name|target
operator|->
name|fwdev
operator|==
name|fwdev
condition|)
break|break;
if|if
condition|(
name|fwdev
operator|==
name|NULL
condition|)
block|{
comment|/* device has removed in lower driver */
name|sbp_cam_detach_target
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|sbp_free_target
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* traverse device list */
name|STAILQ_FOREACH
argument_list|(
argument|fwdev
argument_list|,
argument|&sbp->fd.fc->devices
argument_list|,
argument|link
argument_list|)
block|{
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|device_printf
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:: EUI:%08x%08x %s attached, state=%d\n"
argument_list|,
name|__func__
argument_list|,
name|fwdev
operator|->
name|eui
operator|.
name|hi
argument_list|,
name|fwdev
operator|->
name|eui
operator|.
name|lo
argument_list|,
operator|(
name|fwdev
operator|->
name|status
operator|!=
name|FWDEVATTACHED
operator|)
condition|?
literal|"not"
else|:
literal|""
argument_list|,
name|fwdev
operator|->
name|status
argument_list|)
expr_stmt|;
name|END_DEBUG
name|alive
init|=
name|SBP_FWDEV_ALIVE
argument_list|(
name|fwdev
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBP_NUM_TARGETS
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
operator|&
name|sbp
operator|->
name|targets
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|fwdev
operator|==
name|fwdev
condition|)
block|{
comment|/* known target */
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|SBP_NUM_TARGETS
condition|)
block|{
if|if
condition|(
name|alive
condition|)
block|{
comment|/* new target */
name|target
operator|=
name|sbp_alloc_target
argument_list|(
name|sbp
argument_list|,
name|fwdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
continue|continue;
block|}
else|else
block|{
continue|continue;
block|}
block|}
name|sbp_probe_target
argument_list|(
operator|(
name|void
operator|*
operator|)
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|num_lun
operator|==
literal|0
condition|)
name|sbp_free_target
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
name|xpt_release_simq
argument_list|(
name|sbp
operator|->
name|sim
argument_list|,
comment|/*run queue*/
name|TRUE
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|sim
operator|->
name|flags
operator|&=
operator|~
name|SIMQ_FREEZED
expr_stmt|;
name|SBP_UNLOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NEED_RESPONSE
end_if

begin_function
specifier|static
name|void
name|sbp_loginres_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|END_DEBUG
comment|/* recycle */
name|SBP_LOCK
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
decl_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fwb
operator|.
name|xferlist
argument_list|,
name|xfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|SBP_UNLOCK
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|__inline
name|void
name|sbp_xfer_free
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|fw_xfer_unload
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|SBP_LOCK_ASSERT
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sdev
operator|->
name|target
operator|->
name|xferlist
argument_list|,
name|xfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_reset_start_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|tsdev
decl_stmt|,
modifier|*
name|sdev
init|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
init|=
name|sdev
operator|->
name|target
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|xfer
operator|->
name|resp
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s: %s failed: resp=%d\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|,
name|xfer
operator|->
name|resp
argument_list|)
expr_stmt|;
block|}
name|SBP_LOCK
argument_list|(
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|target
operator|->
name|num_lun
condition|;
name|i
operator|++
control|)
block|{
name|tsdev
operator|=
name|target
operator|->
name|luns
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|tsdev
operator|!=
name|NULL
operator|&&
name|tsdev
operator|->
name|status
operator|==
name|SBP_DEV_LOGIN
condition|)
name|sbp_login
argument_list|(
name|tsdev
argument_list|)
expr_stmt|;
block|}
name|SBP_UNLOCK
argument_list|(
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_reset_start
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|)
expr_stmt|;
name|END_DEBUG
name|xfer
init|=
name|sbp_write_cmd
argument_list|(
name|sdev
argument_list|,
name|FWTCODE_WREQQ
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|xfer
operator|->
name|hand
operator|=
name|sbp_reset_start_callback
expr_stmt|;
name|fp
operator|=
operator|&
name|xfer
operator|->
name|send
operator|.
name|hdr
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|dest_hi
operator|=
literal|0xffff
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|dest_lo
operator|=
literal|0xf0000000
operator||
name|RESET_START
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|data
operator|=
name|htonl
argument_list|(
literal|0xf
argument_list|)
expr_stmt|;
name|fw_asyreq
argument_list|(
name|xfer
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_mgm_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|int
name|resp
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|)
expr_stmt|;
name|END_DEBUG
name|resp
init|=
name|xfer
operator|->
name|resp
decl_stmt|;
name|SBP_LOCK
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
name|sbp_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|SBP_UNLOCK
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sbp_dev
modifier|*
name|sbp_next_dev
parameter_list|(
name|struct
name|sbp_target
modifier|*
name|target
parameter_list|,
name|int
name|lun
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
modifier|*
name|sdevp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|lun
operator|,
name|sdevp
operator|=
operator|&
name|target
operator|->
name|luns
index|[
name|lun
index|]
init|;
name|i
operator|<
name|target
operator|->
name|num_lun
condition|;
name|i
operator|++
operator|,
name|sdevp
operator|++
control|)
if|if
condition|(
operator|*
name|sdevp
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|sdevp
operator|)
operator|->
name|status
operator|==
name|SBP_DEV_PROBE
condition|)
return|return
operator|(
operator|*
name|sdevp
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SCAN_PRI
value|1
end_define

begin_function
specifier|static
name|void
name|sbp_cam_scan_lun
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_sdev_ptr
expr_stmt|;
name|target
operator|=
name|sdev
operator|->
name|target
expr_stmt|;
name|SBP_LOCK_ASSERT
argument_list|(
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_ATTACHED
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s failed\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|)
expr_stmt|;
block|}
name|sdev
operator|=
name|sbp_next_dev
argument_list|(
name|target
argument_list|,
name|sdev
operator|->
name|lun_id
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ccb
argument_list|,
name|M_SBP
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* reuse ccb */
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sdev
operator|->
name|path
argument_list|,
name|SCAN_PRI
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_sdev_ptr
operator|=
name|sdev
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|xpt_release_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
name|sdev
operator|->
name|freeze
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|freeze
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_cam_scan_target
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sbp_target
modifier|*
name|target
init|=
operator|(
expr|struct
name|sbp_target
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|SBP_LOCK_ASSERT
argument_list|(
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
name|sdev
operator|=
name|sbp_next_dev
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_cam_scan_target: nothing to do for target%d\n"
argument_list|,
name|target
operator|->
name|target_id
argument_list|)
expr_stmt|;
return|return;
block|}
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|)
expr_stmt|;
name|END_DEBUG
name|ccb
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|,
name|M_SBP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
decl_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_cam_scan_target: malloc failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sdev
operator|->
name|path
argument_list|,
name|SCAN_PRI
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_LUN
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|sbp_cam_scan_lun
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFREEZE
expr_stmt|;
name|ccb
operator|->
name|crcn
operator|.
name|flags
operator|=
name|CAM_FLAG_NONE
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_sdev_ptr
operator|=
name|sdev
expr_stmt|;
comment|/* The scan is in progress now. */
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|xpt_release_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
name|sdev
operator|->
name|freeze
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|freeze
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|sbp_scan_dev
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_PROBE
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sdev
operator|->
name|target
operator|->
name|scan_callout
argument_list|,
name|scan_delay
operator|*
name|hz
operator|/
literal|1000
argument_list|,
name|sbp_cam_scan_target
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sdev
operator|->
name|target
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_do_attach
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|struct
name|sbp_softc
modifier|*
name|sbp
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|target
operator|=
name|sdev
operator|->
name|target
expr_stmt|;
name|sbp
operator|=
name|target
operator|->
name|sbp
expr_stmt|;
name|SBP_LOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|)
expr_stmt|;
name|END_DEBUG
name|sbp_xfer_free
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
if|if
condition|(
name|sdev
operator|->
name|path
operator|==
name|NULL
condition|)
name|xpt_create_path
argument_list|(
operator|&
name|sdev
operator|->
name|path
argument_list|,
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|target
operator|->
name|sbp
operator|->
name|sim
argument_list|)
argument_list|,
name|target
operator|->
name|target_id
argument_list|,
name|sdev
operator|->
name|lun_id
argument_list|)
expr_stmt|;
comment|/* 	 * Let CAM scan the bus if we are in the boot process. 	 * XXX xpt_scan_bus cannot detect LUN larger than 0 	 * if LUN 0 doesn't exist. 	 */
if|if
condition|(
name|sbp_cold
operator|>
literal|0
condition|)
block|{
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_ATTACHED
expr_stmt|;
name|SBP_UNLOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
return|return;
block|}
name|sbp_scan_dev
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
name|SBP_UNLOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_agent_reset_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|xfer
operator|->
name|resp
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s resp=%d\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|,
name|xfer
operator|->
name|resp
argument_list|)
expr_stmt|;
block|}
name|SBP_LOCK
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
name|sbp_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdev
operator|->
name|path
condition|)
block|{
name|xpt_release_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
name|sdev
operator|->
name|freeze
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|freeze
operator|=
literal|0
expr_stmt|;
block|}
name|SBP_UNLOCK
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_agent_reset
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|SBP_LOCK_ASSERT
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|)
expr_stmt|;
name|END_DEBUG
name|xfer
init|=
name|sbp_write_cmd
argument_list|(
name|sdev
argument_list|,
name|FWTCODE_WREQQ
argument_list|,
literal|0x04
argument_list|)
decl_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|sdev
operator|->
name|status
operator|==
name|SBP_DEV_ATTACHED
operator|||
name|sdev
operator|->
name|status
operator|==
name|SBP_DEV_PROBE
condition|)
name|xfer
operator|->
name|hand
operator|=
name|sbp_agent_reset_callback
expr_stmt|;
else|else
name|xfer
operator|->
name|hand
operator|=
name|sbp_do_attach
expr_stmt|;
name|fp
operator|=
operator|&
name|xfer
operator|->
name|send
operator|.
name|hdr
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|data
operator|=
name|htonl
argument_list|(
literal|0xf
argument_list|)
expr_stmt|;
name|fw_asyreq
argument_list|(
name|xfer
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|sbp_abort_all_ocbs
argument_list|(
name|sdev
argument_list|,
name|CAM_BDR_SENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_busy_timeout_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|)
expr_stmt|;
name|END_DEBUG
name|SBP_LOCK
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
decl_stmt|;
name|sbp_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|sbp_agent_reset
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
name|SBP_UNLOCK
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_busy_timeout
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|)
expr_stmt|;
name|END_DEBUG
name|xfer
init|=
name|sbp_write_cmd
argument_list|(
name|sdev
argument_list|,
name|FWTCODE_WREQQ
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|xfer
operator|->
name|hand
operator|=
name|sbp_busy_timeout_callback
expr_stmt|;
name|fp
operator|=
operator|&
name|xfer
operator|->
name|send
operator|.
name|hdr
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|dest_hi
operator|=
literal|0xffff
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|dest_lo
operator|=
literal|0xf0000000
operator||
name|BUSY_TIMEOUT
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|data
operator|=
name|htonl
argument_list|(
operator|(
literal|1
operator|<<
operator|(
literal|13
operator|+
literal|12
operator|)
operator|)
operator||
literal|0xf
argument_list|)
expr_stmt|;
name|fw_asyreq
argument_list|(
name|xfer
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_orb_pointer_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|2
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|xfer
operator|->
name|resp
operator|!=
literal|0
condition|)
block|{
comment|/* XXX */
name|printf
argument_list|(
literal|"%s: xfer->resp = %d\n"
argument_list|,
name|__func__
argument_list|,
name|xfer
operator|->
name|resp
argument_list|)
expr_stmt|;
block|}
name|SBP_LOCK
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
name|sbp_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|flags
operator|&=
operator|~
name|ORB_POINTER_ACTIVE
expr_stmt|;
if|if
condition|(
operator|(
name|sdev
operator|->
name|flags
operator|&
name|ORB_POINTER_NEED
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|sdev
operator|->
name|flags
operator|&=
operator|~
name|ORB_POINTER_NEED
expr_stmt|;
name|ocb
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sdev
operator|->
name|ocbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ocb
operator|!=
name|NULL
condition|)
name|sbp_orb_pointer
argument_list|(
name|sdev
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
block|}
name|SBP_UNLOCK
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_orb_pointer
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|,
name|struct
name|sbp_ocb
modifier|*
name|ocb
parameter_list|)
block|{
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|,
operator|(
name|uint32_t
operator|)
name|ocb
operator|->
name|bus_addr
argument_list|)
expr_stmt|;
name|END_DEBUG
name|SBP_LOCK_ASSERT
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|sdev
operator|->
name|flags
operator|&
name|ORB_POINTER_ACTIVE
operator|)
operator|!=
literal|0
condition|)
block|{
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"%s: orb pointer active\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|END_DEBUG
name|sdev
operator|->
name|flags
operator||=
name|ORB_POINTER_NEED
expr_stmt|;
return|return;
block|}
name|sdev
operator|->
name|flags
operator||=
name|ORB_POINTER_ACTIVE
expr_stmt|;
name|xfer
operator|=
name|sbp_write_cmd
argument_list|(
name|sdev
argument_list|,
name|FWTCODE_WREQB
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
return|return;
name|xfer
operator|->
name|hand
operator|=
name|sbp_orb_pointer_callback
expr_stmt|;
name|fp
operator|=
operator|&
name|xfer
operator|->
name|send
operator|.
name|hdr
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|len
operator|=
literal|8
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|extcode
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|send
operator|.
name|payload
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
operator|(
operator|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|fc
operator|->
name|nodeid
operator||
name|FWLOCALBUS
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|send
operator|.
name|payload
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
operator|(
name|uint32_t
operator|)
name|ocb
operator|->
name|bus_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_asyreq
argument_list|(
name|xfer
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sbp_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ocb
operator|->
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_doorbell_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|xfer
operator|->
name|resp
operator|!=
literal|0
condition|)
block|{
comment|/* XXX */
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s: xfer->resp = %d\n"
argument_list|,
name|__func__
argument_list|,
name|xfer
operator|->
name|resp
argument_list|)
expr_stmt|;
block|}
name|SBP_LOCK
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
name|sbp_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|flags
operator|&=
operator|~
name|ORB_DOORBELL_ACTIVE
expr_stmt|;
if|if
condition|(
operator|(
name|sdev
operator|->
name|flags
operator|&
name|ORB_DOORBELL_NEED
operator|)
operator|!=
literal|0
condition|)
block|{
name|sdev
operator|->
name|flags
operator|&=
operator|~
name|ORB_DOORBELL_NEED
expr_stmt|;
name|sbp_doorbell
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
block|}
name|SBP_UNLOCK
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_doorbell
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
operator|(
name|sdev
operator|->
name|flags
operator|&
name|ORB_DOORBELL_ACTIVE
operator|)
operator|!=
literal|0
condition|)
block|{
name|sdev
operator|->
name|flags
operator||=
name|ORB_DOORBELL_NEED
expr_stmt|;
return|return;
block|}
name|sdev
operator|->
name|flags
operator||=
name|ORB_DOORBELL_ACTIVE
expr_stmt|;
name|xfer
operator|=
name|sbp_write_cmd
argument_list|(
name|sdev
argument_list|,
name|FWTCODE_WREQQ
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
return|return;
name|xfer
operator|->
name|hand
operator|=
name|sbp_doorbell_callback
expr_stmt|;
name|fp
operator|=
operator|&
name|xfer
operator|->
name|send
operator|.
name|hdr
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|data
operator|=
name|htonl
argument_list|(
literal|0xf
argument_list|)
expr_stmt|;
name|fw_asyreq
argument_list|(
name|xfer
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|fw_xfer
modifier|*
name|sbp_write_cmd
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|,
name|int
name|tcode
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|int
name|new
init|=
literal|0
decl_stmt|;
name|SBP_LOCK_ASSERT
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
name|target
operator|=
name|sdev
operator|->
name|target
expr_stmt|;
name|xfer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|target
operator|->
name|xferlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|target
operator|->
name|n_xfer
operator|>
literal|5
comment|/* XXX */
condition|)
block|{
name|printf
argument_list|(
literal|"sbp: no more xfer for this target\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|xfer
operator|=
name|fw_xfer_alloc_buf
argument_list|(
name|M_SBP
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sbp: fw_xfer_alloc_buf failed\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|target
operator|->
name|n_xfer
operator|++
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"sbp: alloc %d xfer\n"
argument_list|,
name|target
operator|->
name|n_xfer
argument_list|)
expr_stmt|;
name|new
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|target
operator|->
name|xferlist
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new
condition|)
block|{
name|xfer
operator|->
name|recv
operator|.
name|pay_len
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|send
operator|.
name|spd
operator|=
name|min
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|fwdev
operator|->
name|speed
argument_list|,
name|max_speed
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|fc
operator|=
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|fc
expr_stmt|;
block|}
if|if
condition|(
name|tcode
operator|==
name|FWTCODE_WREQB
condition|)
name|xfer
operator|->
name|send
operator|.
name|pay_len
operator|=
literal|8
expr_stmt|;
else|else
name|xfer
operator|->
name|send
operator|.
name|pay_len
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|sc
operator|=
operator|(
name|caddr_t
operator|)
name|sdev
expr_stmt|;
name|fp
operator|=
operator|&
name|xfer
operator|->
name|send
operator|.
name|hdr
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|dest_hi
operator|=
name|sdev
operator|->
name|login
operator|->
name|cmd_hi
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|dest_lo
operator|=
name|sdev
operator|->
name|login
operator|->
name|cmd_lo
operator|+
name|offset
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|tlrt
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|tcode
operator|=
name|tcode
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|pri
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|dst
operator|=
name|FWLOCALBUS
operator||
name|sdev
operator|->
name|target
operator|->
name|fwdev
operator|->
name|dst
expr_stmt|;
return|return
name|xfer
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_mgm_orb
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|,
name|int
name|func
parameter_list|,
name|struct
name|sbp_ocb
modifier|*
name|aocb
parameter_list|)
block|{
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|int
name|nid
decl_stmt|;
name|target
operator|=
name|sdev
operator|->
name|target
expr_stmt|;
name|nid
operator|=
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|fc
operator|->
name|nodeid
operator||
name|FWLOCALBUS
expr_stmt|;
name|SBP_LOCK_ASSERT
argument_list|(
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|ORB_FUN_RUNQUEUE
condition|)
block|{
name|ocb
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|target
operator|->
name|mgm_ocb_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|mgm_ocb_cur
operator|!=
name|NULL
operator|||
name|ocb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|target
operator|->
name|mgm_ocb_queue
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
goto|goto
name|start
goto|;
block|}
if|if
condition|(
operator|(
name|ocb
operator|=
name|sbp_get_ocb
argument_list|(
name|sdev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* XXX */
return|return;
block|}
name|ocb
operator|->
name|flags
operator|=
name|OCB_ACT_MGM
expr_stmt|;
name|ocb
operator|->
name|sdev
operator|=
name|sdev
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ocb
operator|->
name|orb
argument_list|,
sizeof|sizeof
argument_list|(
name|ocb
operator|->
name|orb
argument_list|)
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|6
index|]
operator|=
name|htonl
argument_list|(
operator|(
name|nid
operator|<<
literal|16
operator|)
operator||
name|SBP_BIND_HI
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|7
index|]
operator|=
name|htonl
argument_list|(
name|SBP_DEV2ADDR
argument_list|(
name|target
operator|->
name|target_id
argument_list|,
name|sdev
operator|->
name|lun_id
argument_list|)
argument_list|)
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s %s\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|,
name|orb_fun_name
index|[
operator|(
name|func
operator|>>
literal|16
operator|)
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
name|END_DEBUG
switch|switch
condition|(
name|func
condition|)
block|{
case|case
name|ORB_FUN_LGI
case|:
name|ocb
operator|->
name|orb
index|[
literal|0
index|]
operator|=
name|ocb
operator|->
name|orb
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* password */
name|ocb
operator|->
name|orb
index|[
literal|2
index|]
operator|=
name|htonl
argument_list|(
name|nid
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|3
index|]
operator|=
name|htonl
argument_list|(
name|sdev
operator|->
name|dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
operator|=
name|htonl
argument_list|(
name|ORB_NOTIFY
operator||
name|sdev
operator|->
name|lun_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex_login
condition|)
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
operator||=
name|htonl
argument_list|(
name|ORB_EXV
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|5
index|]
operator|=
name|htonl
argument_list|(
name|SBP_LOGIN_SIZE
argument_list|)
expr_stmt|;
name|fwdma_sync
argument_list|(
operator|&
name|sdev
operator|->
name|dma
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORB_FUN_ATA
case|:
name|ocb
operator|->
name|orb
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
operator|(
literal|0
operator|<<
literal|16
operator|)
operator||
literal|0
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
name|aocb
operator|->
name|bus_addr
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|ORB_FUN_RCN
case|:
case|case
name|ORB_FUN_LGO
case|:
case|case
name|ORB_FUN_LUR
case|:
case|case
name|ORB_FUN_RST
case|:
case|case
name|ORB_FUN_ATS
case|:
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
operator|=
name|htonl
argument_list|(
name|ORB_NOTIFY
operator||
name|func
operator||
name|sdev
operator|->
name|login
operator|->
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|target
operator|->
name|mgm_ocb_cur
operator|!=
name|NULL
condition|)
block|{
comment|/* there is a standing ORB */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sdev
operator|->
name|target
operator|->
name|mgm_ocb_queue
argument_list|,
name|ocb
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
return|return;
block|}
name|start
label|:
name|target
operator|->
name|mgm_ocb_cur
operator|=
name|ocb
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|target
operator|->
name|mgm_ocb_timeout
argument_list|,
literal|5
operator|*
name|hz
argument_list|,
name|sbp_mgm_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ocb
argument_list|)
expr_stmt|;
name|xfer
operator|=
name|sbp_write_cmd
argument_list|(
name|sdev
argument_list|,
name|FWTCODE_WREQB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|xfer
operator|->
name|hand
operator|=
name|sbp_mgm_callback
expr_stmt|;
name|fp
operator|=
operator|&
name|xfer
operator|->
name|send
operator|.
name|hdr
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|dest_hi
operator|=
name|sdev
operator|->
name|target
operator|->
name|mgm_hi
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|dest_lo
operator|=
name|sdev
operator|->
name|target
operator|->
name|mgm_lo
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|len
operator|=
literal|8
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|extcode
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|send
operator|.
name|payload
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
name|nid
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|send
operator|.
name|payload
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
name|ocb
operator|->
name|bus_addr
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fw_asyreq
argument_list|(
name|xfer
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_print_scsi_cmd
parameter_list|(
name|struct
name|sbp_ocb
modifier|*
name|ocb
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|csio
operator|=
operator|&
name|ocb
operator|->
name|ccb
operator|->
name|csio
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%d:%jx XPT_SCSI_IO: "
literal|"cmd: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x"
literal|", flags: 0x%02x, "
literal|"%db cmd/%db data/%db sense\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|ocb
operator|->
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|1
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|2
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|3
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|4
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|5
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|6
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|7
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|8
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|9
index|]
argument_list|,
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|csio
operator|->
name|sense_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_scsi_status
parameter_list|(
name|struct
name|sbp_status
modifier|*
name|sbp_status
parameter_list|,
name|struct
name|sbp_ocb
modifier|*
name|ocb
parameter_list|)
block|{
name|struct
name|sbp_cmd_status
modifier|*
name|sbp_cmd_status
decl_stmt|;
name|struct
name|scsi_sense_data_fixed
modifier|*
name|sense
decl_stmt|;
name|sbp_cmd_status
operator|=
operator|(
expr|struct
name|sbp_cmd_status
operator|*
operator|)
name|sbp_status
operator|->
name|data
expr_stmt|;
name|sense
operator|=
operator|(
expr|struct
name|scsi_sense_data_fixed
operator|*
operator|)
operator|&
name|ocb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_print_scsi_cmd
argument_list|(
name|ocb
argument_list|)
expr_stmt|;
comment|/* XXX need decode status */
name|printf
argument_list|(
literal|"%s: SCSI status %x sfmt %x valid %x key %x code %x qlfr %x len %d\n"
argument_list|,
name|ocb
operator|->
name|sdev
operator|->
name|bustgtlun
argument_list|,
name|sbp_cmd_status
operator|->
name|status
argument_list|,
name|sbp_cmd_status
operator|->
name|sfmt
argument_list|,
name|sbp_cmd_status
operator|->
name|valid
argument_list|,
name|sbp_cmd_status
operator|->
name|s_key
argument_list|,
name|sbp_cmd_status
operator|->
name|s_code
argument_list|,
name|sbp_cmd_status
operator|->
name|s_qlfr
argument_list|,
name|sbp_status
operator|->
name|len
argument_list|)
expr_stmt|;
name|END_DEBUG
switch|switch
condition|(
name|sbp_cmd_status
operator|->
name|status
condition|)
block|{
case|case
name|SCSI_STATUS_CHECK_COND
case|:
case|case
name|SCSI_STATUS_BUSY
case|:
case|case
name|SCSI_STATUS_CMD_TERMINATED
case|:
if|if
condition|(
name|sbp_cmd_status
operator|->
name|sfmt
operator|==
name|SBP_SFMT_CURR
condition|)
block|{
name|sense
operator|->
name|error_code
operator|=
name|SSD_CURRENT_ERROR
expr_stmt|;
block|}
else|else
block|{
name|sense
operator|->
name|error_code
operator|=
name|SSD_DEFERRED_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|sbp_cmd_status
operator|->
name|valid
condition|)
name|sense
operator|->
name|error_code
operator||=
name|SSD_ERRCODE_VALID
expr_stmt|;
name|sense
operator|->
name|flags
operator|=
name|sbp_cmd_status
operator|->
name|s_key
expr_stmt|;
if|if
condition|(
name|sbp_cmd_status
operator|->
name|mark
condition|)
name|sense
operator|->
name|flags
operator||=
name|SSD_FILEMARK
expr_stmt|;
if|if
condition|(
name|sbp_cmd_status
operator|->
name|eom
condition|)
name|sense
operator|->
name|flags
operator||=
name|SSD_EOM
expr_stmt|;
if|if
condition|(
name|sbp_cmd_status
operator|->
name|ill_len
condition|)
name|sense
operator|->
name|flags
operator||=
name|SSD_ILI
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sbp_cmd_status
operator|->
name|info
argument_list|,
operator|&
name|sense
operator|->
name|info
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbp_status
operator|->
name|len
operator|<=
literal|1
condition|)
comment|/* XXX not scsi status. shouldn't be happened */
name|sense
operator|->
name|extra_len
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sbp_status
operator|->
name|len
operator|<=
literal|4
condition|)
comment|/* add_sense_code(_qual), info, cmd_spec_info */
name|sense
operator|->
name|extra_len
operator|=
literal|6
expr_stmt|;
else|else
comment|/* fru, sense_key_spec */
name|sense
operator|->
name|extra_len
operator|=
literal|10
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sbp_cmd_status
operator|->
name|cdb
argument_list|,
operator|&
name|sense
operator|->
name|cmd_spec_info
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sense
operator|->
name|add_sense_code
operator|=
name|sbp_cmd_status
operator|->
name|s_code
expr_stmt|;
name|sense
operator|->
name|add_sense_code_qual
operator|=
name|sbp_cmd_status
operator|->
name|s_qlfr
expr_stmt|;
name|sense
operator|->
name|fru
operator|=
name|sbp_cmd_status
operator|->
name|fru
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sbp_cmd_status
operator|->
name|s_keydep
index|[
literal|0
index|]
argument_list|,
operator|&
name|sense
operator|->
name|sense_key_spec
index|[
literal|0
index|]
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|sbp_cmd_status
operator|->
name|status
expr_stmt|;
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
operator||
name|CAM_AUTOSNS_VALID
expr_stmt|;
comment|/* { 		uint8_t j, *tmp; 		tmp = sense; 		for( j = 0 ; j< 32 ; j+=8){ 			printf("sense %02x%02x %02x%02x %02x%02x %02x%02x\n",  				tmp[j], tmp[j+1], tmp[j+2], tmp[j+3], 				tmp[j+4], tmp[j+5], tmp[j+6], tmp[j+7]); 		}  } */
break|break;
default|default:
name|device_printf
argument_list|(
name|ocb
operator|->
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s unknown scsi status 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ocb
operator|->
name|sdev
operator|->
name|bustgtlun
argument_list|,
name|sbp_cmd_status
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_fix_inq_data
parameter_list|(
name|struct
name|sbp_ocb
modifier|*
name|ocb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq
decl_stmt|;
name|ccb
operator|=
name|ocb
operator|->
name|ccb
expr_stmt|;
name|sdev
operator|=
name|ocb
operator|->
name|sdev
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|1
index|]
operator|&
name|SI_EVPD
condition|)
return|return;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|)
expr_stmt|;
name|END_DEBUG
name|inq
init|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
decl_stmt|;
switch|switch
condition|(
name|SID_TYPE
argument_list|(
name|inq
argument_list|)
condition|)
block|{
case|case
name|T_DIRECT
case|:
if|#
directive|if
literal|0
comment|/*  		 * XXX Convert Direct Access device to RBC. 		 * I've never seen FireWire DA devices which support READ_6. 		 */
block|if (SID_TYPE(inq) == T_DIRECT) 			inq->device |= T_RBC;
comment|/*  T_DIRECT == 0 */
endif|#
directive|endif
comment|/* fall through */
case|case
name|T_RBC
case|:
comment|/* 		 * Override vendor/product/revision information. 		 * Some devices sometimes return strange strings. 		 */
if|#
directive|if
literal|1
name|bcopy
argument_list|(
name|sdev
operator|->
name|vendor
argument_list|,
name|inq
operator|->
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sdev
operator|->
name|product
argument_list|,
name|inq
operator|->
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sdev
operator|->
name|revision
operator|+
literal|2
argument_list|,
name|inq
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
comment|/* 	 * Force to enable/disable tagged queuing. 	 * XXX CAM also checks SCP_QUEUE_DQUE flag in the control mode page. 	 */
if|if
condition|(
name|sbp_tags
operator|>
literal|0
condition|)
name|inq
operator|->
name|flags
operator||=
name|SID_CmdQue
expr_stmt|;
elseif|else
if|if
condition|(
name|sbp_tags
operator|<
literal|0
condition|)
name|inq
operator|->
name|flags
operator|&=
operator|~
name|SID_CmdQue
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_recv1
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|fw_pkt
modifier|*
name|rfp
decl_stmt|;
if|#
directive|if
name|NEED_RESPONSE
name|struct
name|fw_pkt
modifier|*
name|sfp
decl_stmt|;
endif|#
directive|endif
name|struct
name|sbp_softc
modifier|*
name|sbp
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|struct
name|sbp_login_res
modifier|*
name|login_res
init|=
name|NULL
decl_stmt|;
name|struct
name|sbp_status
modifier|*
name|sbp_status
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|int
name|orb_fun
decl_stmt|,
name|status_valid0
decl_stmt|,
name|status_valid
decl_stmt|,
name|t
decl_stmt|,
name|l
decl_stmt|,
name|reset_agent
init|=
literal|0
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|;
comment|/* 	uint32_t *ld; 	ld = xfer->recv.buf; printf("sbp %x %d %d %08x %08x %08x %08x\n", 			xfer->resp, xfer->recv.len, xfer->recv.off, ntohl(ld[0]), ntohl(ld[1]), ntohl(ld[2]), ntohl(ld[3])); printf("sbp %08x %08x %08x %08x\n", ntohl(ld[4]), ntohl(ld[5]), ntohl(ld[6]), ntohl(ld[7])); printf("sbp %08x %08x %08x %08x\n", ntohl(ld[8]), ntohl(ld[9]), ntohl(ld[10]), ntohl(ld[11])); */
name|sbp
operator|=
operator|(
expr|struct
name|sbp_softc
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|SBP_LOCK_ASSERT
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|resp
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_recv: xfer->resp = %d\n"
argument_list|,
name|xfer
operator|->
name|resp
argument_list|)
expr_stmt|;
goto|goto
name|done0
goto|;
block|}
if|if
condition|(
name|xfer
operator|->
name|recv
operator|.
name|payload
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_recv: xfer->recv.payload == NULL\n"
argument_list|)
expr_stmt|;
goto|goto
name|done0
goto|;
block|}
name|rfp
operator|=
operator|&
name|xfer
operator|->
name|recv
operator|.
name|hdr
expr_stmt|;
if|if
condition|(
name|rfp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|tcode
operator|!=
name|FWTCODE_WREQB
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_recv: tcode = %d\n"
argument_list|,
name|rfp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|tcode
argument_list|)
expr_stmt|;
goto|goto
name|done0
goto|;
block|}
name|sbp_status
operator|=
operator|(
expr|struct
name|sbp_status
operator|*
operator|)
name|xfer
operator|->
name|recv
operator|.
name|payload
expr_stmt|;
name|addr
operator|=
name|rfp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|dest_lo
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|2
argument_list|)
name|printf
argument_list|(
literal|"received address 0x%x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|END_DEBUG
name|t
init|=
name|SBP_ADDR2TRG
argument_list|(
name|addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|>=
name|SBP_NUM_TARGETS
condition|)
block|{
name|device_printf
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"sbp_recv1: invalid target %d\n"
argument_list|,
name|t
argument_list|)
expr_stmt|;
goto|goto
name|done0
goto|;
block|}
name|target
operator|=
operator|&
name|sbp
operator|->
name|targets
index|[
name|t
index|]
expr_stmt|;
name|l
operator|=
name|SBP_ADDR2LUN
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>=
name|target
operator|->
name|num_lun
operator|||
name|target
operator|->
name|luns
index|[
name|l
index|]
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"sbp_recv1: invalid lun %d (target=%d)\n"
argument_list|,
name|l
argument_list|,
name|t
argument_list|)
expr_stmt|;
goto|goto
name|done0
goto|;
block|}
name|sdev
operator|=
name|target
operator|->
name|luns
index|[
name|l
index|]
expr_stmt|;
name|ocb
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|sbp_status
operator|->
name|src
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
comment|/* check mgm_ocb_cur first */
name|ocb
operator|=
name|target
operator|->
name|mgm_ocb_cur
expr_stmt|;
if|if
condition|(
name|ocb
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|OCB_MATCH
argument_list|(
name|ocb
argument_list|,
name|sbp_status
argument_list|)
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|target
operator|->
name|mgm_ocb_timeout
argument_list|)
expr_stmt|;
name|target
operator|->
name|mgm_ocb_cur
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
name|ocb
operator|=
name|sbp_dequeue_ocb
argument_list|(
name|sdev
argument_list|,
name|sbp_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ocb
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s No ocb(%x) on the queue\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|,
name|ntohl
argument_list|(
name|sbp_status
operator|->
name|orb_lo
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* unsolicit */
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s unsolicit status received\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s unknown sbp_status->src\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|)
expr_stmt|;
block|}
name|status_valid0
operator|=
operator|(
name|sbp_status
operator|->
name|src
operator|<
literal|2
operator|&&
name|sbp_status
operator|->
name|resp
operator|==
name|ORB_RES_CMPL
operator|&&
name|sbp_status
operator|->
name|dead
operator|==
literal|0
operator|)
expr_stmt|;
name|status_valid
operator|=
operator|(
name|status_valid0
operator|&&
name|sbp_status
operator|->
name|status
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|status_valid0
operator|||
name|debug
operator|>
literal|2
condition|)
block|{
name|int
name|status
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s ORB status src:%x resp:%x dead:%x"
literal|" len:%x stat:%x orb:%x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|,
name|sbp_status
operator|->
name|src
argument_list|,
name|sbp_status
operator|->
name|resp
argument_list|,
name|sbp_status
operator|->
name|dead
argument_list|,
name|sbp_status
operator|->
name|len
argument_list|,
name|sbp_status
operator|->
name|status
argument_list|,
name|ntohs
argument_list|(
name|sbp_status
operator|->
name|orb_hi
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|sbp_status
operator|->
name|orb_lo
argument_list|)
argument_list|)
expr_stmt|;
name|END_DEBUG
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s\n"
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|)
decl_stmt|;
name|status
operator|=
name|sbp_status
operator|->
name|status
expr_stmt|;
switch|switch
condition|(
name|sbp_status
operator|->
name|resp
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|status
operator|>
name|MAX_ORB_STATUS0
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|orb_status0
index|[
name|MAX_ORB_STATUS0
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|orb_status0
index|[
name|status
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"Obj: %s, Error: %s\n"
argument_list|,
name|orb_status1_object
index|[
operator|(
name|status
operator|>>
literal|6
operator|)
operator|&
literal|3
index|]
argument_list|,
name|orb_status1_serial_bus_error
index|[
name|status
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"Illegal request\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"Vendor dependent\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown respose code %d\n"
argument_list|,
name|sbp_status
operator|->
name|resp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* we have to reset the fetch agent if it's dead */
if|if
condition|(
name|sbp_status
operator|->
name|dead
condition|)
block|{
if|if
condition|(
name|sdev
operator|->
name|path
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|freeze
operator|++
expr_stmt|;
block|}
name|reset_agent
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ocb
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
switch|switch
condition|(
name|ntohl
argument_list|(
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
argument_list|)
operator|&
name|ORB_FMT_MSK
condition|)
block|{
case|case
name|ORB_FMT_NOP
case|:
break|break;
case|case
name|ORB_FMT_VED
case|:
break|break;
case|case
name|ORB_FMT_STD
case|:
switch|switch
condition|(
name|ocb
operator|->
name|flags
condition|)
block|{
case|case
name|OCB_ACT_MGM
case|:
name|orb_fun
operator|=
name|ntohl
argument_list|(
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
argument_list|)
operator|&
name|ORB_FUN_MSK
expr_stmt|;
name|reset_agent
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|orb_fun
condition|)
block|{
case|case
name|ORB_FUN_LGI
case|:
name|fwdma_sync
argument_list|(
operator|&
name|sdev
operator|->
name|dma
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|login_res
operator|=
name|sdev
operator|->
name|login
expr_stmt|;
name|login_res
operator|->
name|len
operator|=
name|ntohs
argument_list|(
name|login_res
operator|->
name|len
argument_list|)
expr_stmt|;
name|login_res
operator|->
name|id
operator|=
name|ntohs
argument_list|(
name|login_res
operator|->
name|id
argument_list|)
expr_stmt|;
name|login_res
operator|->
name|cmd_hi
operator|=
name|ntohs
argument_list|(
name|login_res
operator|->
name|cmd_hi
argument_list|)
expr_stmt|;
name|login_res
operator|->
name|cmd_lo
operator|=
name|ntohl
argument_list|(
name|login_res
operator|->
name|cmd_lo
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_valid
condition|)
block|{
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s login: len %d, ID %d, cmd %08x%08x, recon_hold %d\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|,
name|login_res
operator|->
name|len
argument_list|,
name|login_res
operator|->
name|id
argument_list|,
name|login_res
operator|->
name|cmd_hi
argument_list|,
name|login_res
operator|->
name|cmd_lo
argument_list|,
name|ntohs
argument_list|(
name|login_res
operator|->
name|recon_hold
argument_list|)
argument_list|)
expr_stmt|;
name|END_DEBUG
name|sbp_busy_timeout
argument_list|(
name|sdev
argument_list|)
decl_stmt|;
block|}
else|else
block|{
comment|/* forgot logout? */
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s login failed\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_RESET
expr_stmt|;
block|}
break|break;
case|case
name|ORB_FUN_RCN
case|:
name|login_res
operator|=
name|sdev
operator|->
name|login
expr_stmt|;
if|if
condition|(
name|status_valid
condition|)
block|{
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s reconnect: len %d, ID %d, cmd %08x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|,
name|login_res
operator|->
name|len
argument_list|,
name|login_res
operator|->
name|id
argument_list|,
name|login_res
operator|->
name|cmd_hi
argument_list|,
name|login_res
operator|->
name|cmd_lo
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|sdev
operator|->
name|status
operator|==
name|SBP_DEV_ATTACHED
condition|)
name|sbp_scan_dev
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
else|else
name|sbp_agent_reset
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* reconnection hold time exceed? */
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s reconnect failed\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|)
expr_stmt|;
name|END_DEBUG
name|sbp_login
argument_list|(
name|sdev
argument_list|)
decl_stmt|;
block|}
break|break;
case|case
name|ORB_FUN_LGO
case|:
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_RESET
expr_stmt|;
break|break;
case|case
name|ORB_FUN_RST
case|:
name|sbp_busy_timeout
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORB_FUN_LUR
case|:
case|case
name|ORB_FUN_ATA
case|:
case|case
name|ORB_FUN_ATS
case|:
name|sbp_agent_reset
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s unknown function %d\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|,
name|orb_fun
argument_list|)
expr_stmt|;
break|break;
block|}
name|sbp_mgm_orb
argument_list|(
name|sdev
argument_list|,
name|ORB_FUN_RUNQUEUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|OCB_ACT_CMD
case|:
name|sdev
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ocb
operator|->
name|ccb
operator|!=
name|NULL
condition|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|ccb
operator|=
name|ocb
operator|->
name|ccb
expr_stmt|;
if|if
condition|(
name|sbp_status
operator|->
name|len
operator|>
literal|1
condition|)
block|{
name|sbp_scsi_status
argument_list|(
name|sbp_status
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sbp_status
operator|->
name|resp
operator|!=
name|ORB_RES_CMPL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
block|}
comment|/* fix up inq data */
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|==
name|INQUIRY
condition|)
name|sbp_fix_inq_data
argument_list|(
name|ocb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|use_doorbell
condition|)
name|sbp_free_ocb
argument_list|(
name|sdev
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|reset_agent
condition|)
name|sbp_agent_reset
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
name|done0
label|:
name|xfer
operator|->
name|recv
operator|.
name|pay_len
operator|=
name|SBP_RECV_LEN
expr_stmt|;
comment|/* The received packet is usually small enough to be stored within  * the buffer. In that case, the controller return ack_complete and  * no respose is necessary.  *  * XXX fwohci.c and firewire.c should inform event_code such as   * ack_complete or ack_pending to upper driver.  */
if|#
directive|if
name|NEED_RESPONSE
name|xfer
operator|->
name|send
operator|.
name|off
operator|=
literal|0
expr_stmt|;
name|sfp
operator|=
operator|(
expr|struct
name|fw_pkt
operator|*
operator|)
name|xfer
operator|->
name|send
operator|.
name|buf
expr_stmt|;
name|sfp
operator|->
name|mode
operator|.
name|wres
operator|.
name|dst
operator|=
name|rfp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|src
expr_stmt|;
name|xfer
operator|->
name|dst
operator|=
name|sfp
operator|->
name|mode
operator|.
name|wres
operator|.
name|dst
expr_stmt|;
name|xfer
operator|->
name|spd
operator|=
name|min
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|fwdev
operator|->
name|speed
argument_list|,
name|max_speed
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|hand
operator|=
name|sbp_loginres_callback
expr_stmt|;
name|sfp
operator|->
name|mode
operator|.
name|wres
operator|.
name|tlrt
operator|=
name|rfp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|tlrt
expr_stmt|;
name|sfp
operator|->
name|mode
operator|.
name|wres
operator|.
name|tcode
operator|=
name|FWTCODE_WRES
expr_stmt|;
name|sfp
operator|->
name|mode
operator|.
name|wres
operator|.
name|rtcode
operator|=
literal|0
expr_stmt|;
name|sfp
operator|->
name|mode
operator|.
name|wres
operator|.
name|pri
operator|=
literal|0
expr_stmt|;
name|fw_asyreq
argument_list|(
name|xfer
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* recycle */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sbp
operator|->
name|fwb
operator|.
name|xferlist
argument_list|,
name|xfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_recv
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_softc
modifier|*
name|sbp
decl_stmt|;
name|sbp
operator|=
operator|(
expr|struct
name|sbp_softc
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|SBP_LOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|sbp_recv1
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|SBP_UNLOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sbp_attach()  */
end_comment

begin_function
specifier|static
name|int
name|sbp_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sbp_softc
modifier|*
name|sbp
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|DFLTPHYS
operator|>
name|SBP_MAXPHYS
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Warning, DFLTPHYS(%dKB) is larger than "
literal|"SBP_MAXPHYS(%dKB).\n"
argument_list|,
name|DFLTPHYS
operator|/
literal|1024
argument_list|,
name|SBP_MAXPHYS
operator|/
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|firewire_phydma_enable
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Warning, hw.firewire.phydma_enable must be 1 "
literal|"for SBP over FireWire.\n"
argument_list|)
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"sbp_attach (cold=%d)\n"
argument_list|,
name|cold
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|cold
condition|)
name|sbp_cold
operator|++
expr_stmt|;
name|sbp
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|fd
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|sbp
operator|->
name|fd
operator|.
name|fc
operator|=
name|fc
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sbp
operator|->
name|mtx
argument_list|,
literal|"sbp"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_speed
operator|<
literal|0
condition|)
name|max_speed
operator|=
name|fc
operator|->
name|speed
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|fc
operator|->
name|dmat
argument_list|,
comment|/* XXX shoud be 4 for sane backend? */
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
literal|0x100000
argument_list|,
comment|/*nsegments*/
name|SBP_IND_MAX
argument_list|,
comment|/*maxsegsz*/
name|SBP_SEG_MAX
argument_list|,
comment|/*flags*/
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/*lockfunc*/
name|busdma_lock_mutex
argument_list|,
comment|/*lockarg*/
operator|&
name|sbp
operator|->
name|mtx
argument_list|,
operator|&
name|sbp
operator|->
name|dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_attach: Could not allocate DMA tag "
literal|"- error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
comment|/*maxopenings*/
name|SBP_NUM_OCB
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBP_NUM_TARGETS
condition|;
name|i
operator|++
control|)
block|{
name|sbp
operator|->
name|targets
index|[
name|i
index|]
operator|.
name|fwdev
operator|=
name|NULL
expr_stmt|;
name|sbp
operator|->
name|targets
index|[
name|i
index|]
operator|.
name|luns
operator|=
name|NULL
expr_stmt|;
name|sbp
operator|->
name|targets
index|[
name|i
index|]
operator|.
name|sbp
operator|=
name|sbp
expr_stmt|;
block|}
name|sbp
operator|->
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|sbp_action
argument_list|,
name|sbp_poll
argument_list|,
literal|"sbp"
argument_list|,
name|sbp
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|&
name|sbp
operator|->
name|mtx
argument_list|,
comment|/*untagged*/
literal|1
argument_list|,
comment|/*tagged*/
name|SBP_QUEUE_LEN
operator|-
literal|1
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbp
operator|->
name|sim
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|SBP_LOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sbp
operator|->
name|sim
argument_list|,
name|dev
argument_list|,
comment|/*bus*/
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|sbp
operator|->
name|path
argument_list|,
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sbp
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sbp
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|SBP_UNLOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
comment|/* We reserve 16 bit space (4 bytes X 64 targets X 256 luns) */
name|sbp
operator|->
name|fwb
operator|.
name|start
operator|=
operator|(
operator|(
name|u_int64_t
operator|)
name|SBP_BIND_HI
operator|<<
literal|32
operator|)
operator||
name|SBP_DEV2ADDR
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|fwb
operator|.
name|end
operator|=
name|sbp
operator|->
name|fwb
operator|.
name|start
operator|+
literal|0xffff
expr_stmt|;
comment|/* pre-allocate xfer */
name|STAILQ_INIT
argument_list|(
operator|&
name|sbp
operator|->
name|fwb
operator|.
name|xferlist
argument_list|)
expr_stmt|;
name|fw_xferlist_add
argument_list|(
operator|&
name|sbp
operator|->
name|fwb
operator|.
name|xferlist
argument_list|,
name|M_SBP
argument_list|,
comment|/*send*/
literal|0
argument_list|,
comment|/*recv*/
name|SBP_RECV_LEN
argument_list|,
name|SBP_NUM_OCB
operator|/
literal|2
argument_list|,
name|fc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sbp
argument_list|,
name|sbp_recv
argument_list|)
expr_stmt|;
name|fw_bindadd
argument_list|(
name|fc
argument_list|,
operator|&
name|sbp
operator|->
name|fwb
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|fd
operator|.
name|post_busreset
operator|=
name|sbp_post_busreset
expr_stmt|;
name|sbp
operator|->
name|fd
operator|.
name|post_explore
operator|=
name|sbp_post_explore
expr_stmt|;
if|if
condition|(
name|fc
operator|->
name|status
operator|!=
operator|-
literal|1
condition|)
block|{
name|sbp_post_busreset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sbp
argument_list|)
expr_stmt|;
name|sbp_post_explore
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sbp
argument_list|)
expr_stmt|;
block|}
name|SBP_LOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|sbp
operator|->
name|path
argument_list|,
comment|/*arg*/
name|NULL
argument_list|)
expr_stmt|;
name|SBP_UNLOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|SBP_UNLOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sbp
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbp_logout_all
parameter_list|(
name|struct
name|sbp_softc
modifier|*
name|sbp
parameter_list|)
block|{
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"sbp_logout_all\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|SBP_LOCK_ASSERT
argument_list|(
name|sbp
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBP_NUM_TARGETS
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
operator|&
name|sbp
operator|->
name|targets
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|luns
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|target
operator|->
name|num_lun
condition|;
name|j
operator|++
control|)
block|{
name|sdev
operator|=
name|target
operator|->
name|luns
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
continue|continue;
name|callout_stop
argument_list|(
operator|&
name|sdev
operator|->
name|login_callout
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdev
operator|->
name|status
operator|>=
name|SBP_DEV_TOATTACH
operator|&&
name|sdev
operator|->
name|status
operator|<=
name|SBP_DEV_ATTACHED
condition|)
name|sbp_mgm_orb
argument_list|(
name|sdev
argument_list|,
name|ORB_FUN_LGO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbp_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sbp_softc
modifier|*
name|sbp
init|=
operator|(
operator|(
expr|struct
name|sbp_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
operator|)
decl_stmt|;
name|SBP_LOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|sbp_logout_all
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|SBP_UNLOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_free_sdev
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|struct
name|sbp_softc
modifier|*
name|sbp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
return|return;
name|sbp
operator|=
name|sdev
operator|->
name|target
operator|->
name|sbp
expr_stmt|;
name|SBP_UNLOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sdev
operator|->
name|login_callout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBP_QUEUE_LEN
condition|;
name|i
operator|++
control|)
block|{
name|callout_drain
argument_list|(
operator|&
name|sdev
operator|->
name|ocb
index|[
name|i
index|]
operator|.
name|timer
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sbp
operator|->
name|dmat
argument_list|,
name|sdev
operator|->
name|ocb
index|[
name|i
index|]
operator|.
name|dmamap
argument_list|)
expr_stmt|;
block|}
name|fwdma_free
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|fc
argument_list|,
operator|&
name|sdev
operator|->
name|dma
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sdev
argument_list|,
name|M_SBP
argument_list|)
expr_stmt|;
name|SBP_LOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_free_target
parameter_list|(
name|struct
name|sbp_target
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|sbp_softc
modifier|*
name|sbp
decl_stmt|;
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|target
operator|->
name|luns
operator|==
name|NULL
condition|)
return|return;
name|sbp
operator|=
name|target
operator|->
name|sbp
expr_stmt|;
name|SBP_LOCK_ASSERT
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|SBP_UNLOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|target
operator|->
name|mgm_ocb_timeout
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|target
operator|->
name|scan_callout
argument_list|)
expr_stmt|;
name|SBP_LOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|target
operator|->
name|num_lun
condition|;
name|i
operator|++
control|)
name|sbp_free_sdev
argument_list|(
name|target
operator|->
name|luns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|xfer
argument_list|,
argument|&target->xferlist
argument_list|,
argument|link
argument_list|,
argument|next
argument_list|)
block|{
name|fw_xfer_free_buf
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INIT
argument_list|(
operator|&
name|target
operator|->
name|xferlist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|target
operator|->
name|luns
argument_list|,
name|M_SBP
argument_list|)
expr_stmt|;
name|target
operator|->
name|num_lun
operator|=
literal|0
expr_stmt|;
name|target
operator|->
name|luns
operator|=
name|NULL
expr_stmt|;
name|target
operator|->
name|fwdev
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbp_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sbp_softc
modifier|*
name|sbp
init|=
operator|(
operator|(
expr|struct
name|sbp_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
operator|)
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
init|=
name|sbp
operator|->
name|fd
operator|.
name|fc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"sbp_detach\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|SBP_LOCK
argument_list|(
name|sbp
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBP_NUM_TARGETS
condition|;
name|i
operator|++
control|)
name|sbp_cam_detach_target
argument_list|(
operator|&
name|sbp
operator|->
name|targets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|sbp
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|sbp
operator|->
name|path
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sbp
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sbp
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|sbp_logout_all
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|SBP_UNLOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
comment|/* XXX wait for logout completion */
name|pause
argument_list|(
literal|"sbpdtc"
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
name|SBP_LOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBP_NUM_TARGETS
condition|;
name|i
operator|++
control|)
name|sbp_free_target
argument_list|(
operator|&
name|sbp
operator|->
name|targets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SBP_UNLOCK
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|fw_bindremove
argument_list|(
name|fc
argument_list|,
operator|&
name|sbp
operator|->
name|fwb
argument_list|)
expr_stmt|;
name|fw_xferlist_remove
argument_list|(
operator|&
name|sbp
operator|->
name|fwb
operator|.
name|xferlist
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sbp
operator|->
name|dmat
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sbp
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_cam_detach_sdev
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|sdev
operator|->
name|status
operator|==
name|SBP_DEV_DEAD
condition|)
return|return;
if|if
condition|(
name|sdev
operator|->
name|status
operator|==
name|SBP_DEV_RESET
condition|)
return|return;
name|SBP_LOCK_ASSERT
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
name|sbp_abort_all_ocbs
argument_list|(
name|sdev
argument_list|,
name|CAM_DEV_NOT_THERE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdev
operator|->
name|path
condition|)
block|{
name|xpt_release_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
name|sdev
operator|->
name|freeze
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|freeze
operator|=
literal|0
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|sdev
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|sdev
operator|->
name|path
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|path
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_cam_detach_target
parameter_list|(
name|struct
name|sbp_target
modifier|*
name|target
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|SBP_LOCK_ASSERT
argument_list|(
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|luns
operator|!=
name|NULL
condition|)
block|{
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"sbp_detach_target %d\n"
argument_list|,
name|target
operator|->
name|target_id
argument_list|)
expr_stmt|;
name|END_DEBUG
name|callout_stop
argument_list|(
operator|&
name|target
operator|->
name|scan_callout
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|target
operator|->
name|num_lun
condition|;
name|i
operator|++
control|)
name|sbp_cam_detach_sdev
argument_list|(
name|target
operator|->
name|luns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_target_reset
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|,
name|int
name|method
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
init|=
name|sdev
operator|->
name|target
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|tsdev
decl_stmt|;
name|SBP_LOCK_ASSERT
argument_list|(
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|target
operator|->
name|num_lun
condition|;
name|i
operator|++
control|)
block|{
name|tsdev
operator|=
name|target
operator|->
name|luns
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|tsdev
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|tsdev
operator|->
name|status
operator|==
name|SBP_DEV_DEAD
condition|)
continue|continue;
if|if
condition|(
name|tsdev
operator|->
name|status
operator|==
name|SBP_DEV_RESET
condition|)
continue|continue;
name|xpt_freeze_devq
argument_list|(
name|tsdev
operator|->
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tsdev
operator|->
name|freeze
operator|++
expr_stmt|;
name|sbp_abort_all_ocbs
argument_list|(
name|tsdev
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
operator|==
literal|2
condition|)
name|tsdev
operator|->
name|status
operator|=
name|SBP_DEV_LOGIN
expr_stmt|;
block|}
switch|switch
condition|(
name|method
condition|)
block|{
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"target reset\n"
argument_list|)
expr_stmt|;
name|sbp_mgm_orb
argument_list|(
name|sdev
argument_list|,
name|ORB_FUN_RST
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"reset start\n"
argument_list|)
expr_stmt|;
name|sbp_reset_start
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_mgm_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sbp_ocb
modifier|*
name|ocb
init|=
operator|(
expr|struct
name|sbp_ocb
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
init|=
name|ocb
operator|->
name|sdev
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
init|=
name|sdev
operator|->
name|target
decl_stmt|;
name|SBP_LOCK_ASSERT
argument_list|(
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s request timeout(mgm orb:0x%08x)\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|,
operator|(
name|uint32_t
operator|)
name|ocb
operator|->
name|bus_addr
argument_list|)
expr_stmt|;
name|target
operator|->
name|mgm_ocb_cur
operator|=
name|NULL
expr_stmt|;
name|sbp_free_ocb
argument_list|(
name|sdev
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX */
block|printf("run next request\n"); 	sbp_mgm_orb(sdev, ORB_FUN_RUNQUEUE, NULL);
endif|#
directive|endif
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s reset start\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|)
expr_stmt|;
name|sbp_reset_start
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sbp_ocb
modifier|*
name|ocb
init|=
operator|(
expr|struct
name|sbp_ocb
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
init|=
name|ocb
operator|->
name|sdev
decl_stmt|;
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s request timeout(cmd orb:0x%08x) ... "
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|,
operator|(
name|uint32_t
operator|)
name|ocb
operator|->
name|bus_addr
argument_list|)
expr_stmt|;
name|SBP_LOCK_ASSERT
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|timeout
operator|++
expr_stmt|;
switch|switch
condition|(
name|sdev
operator|->
name|timeout
condition|)
block|{
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"agent reset\n"
argument_list|)
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|freeze
operator|++
expr_stmt|;
name|sbp_abort_all_ocbs
argument_list|(
name|sdev
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
name|sbp_agent_reset
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|3
case|:
name|sbp_target_reset
argument_list|(
name|sdev
argument_list|,
name|sdev
operator|->
name|timeout
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|default:
comment|/* XXX give up */
block|sbp_cam_detach_target(target); 		if (target->luns != NULL) 			free(target->luns, M_SBP); 		target->num_lun = 0; 		target->luns = NULL; 		target->fwdev = NULL;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|sbp_softc
modifier|*
name|sbp
init|=
operator|(
expr|struct
name|sbp_softc
operator|*
operator|)
name|sim
operator|->
name|softc
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
init|=
name|NULL
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|sbp
operator|!=
name|NULL
condition|)
name|SBP_LOCK_ASSERT
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
comment|/* target:lun -> sdev mapping */
if|if
condition|(
name|sbp
operator|!=
name|NULL
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|!=
name|CAM_TARGET_WILDCARD
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|<
name|SBP_NUM_TARGETS
condition|)
block|{
name|target
operator|=
operator|&
name|sbp
operator|->
name|targets
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|fwdev
operator|!=
name|NULL
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|!=
name|CAM_LUN_WILDCARD
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|<
name|target
operator|->
name|num_lun
condition|)
block|{
name|sdev
operator|=
name|target
operator|->
name|luns
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
index|]
expr_stmt|;
if|if
condition|(
name|sdev
operator|!=
name|NULL
operator|&&
name|sdev
operator|->
name|status
operator|!=
name|SBP_DEV_ATTACHED
operator|&&
name|sdev
operator|->
name|status
operator|!=
name|SBP_DEV_PROBE
condition|)
name|sdev
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"invalid target %d lun %jx\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
name|END_DEBUG
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
case|case
name|XPT_RESET_DEV
case|:
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
case|case
name|XPT_CALC_GEOMETRY
case|:
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
block|{
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"%s:%d:%jx:func_code 0x%04x: "
literal|"Invalid target (target needed)\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
name|END_DEBUG
name|ccb
operator|->
name|ccb_h
operator|.
name|status
init|=
name|CAM_DEV_NOT_THERE
decl_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|XPT_PATH_INQ
case|:
case|case
name|XPT_NOOP
case|:
comment|/* The opcodes sometimes aimed at a target (sc is valid), 		 * sometimes aimed at the SIM (sc is invalid and target is 		 * CAM_TARGET_WILDCARD) 		 */
if|if
condition|(
name|sbp
operator|==
name|NULL
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|!=
name|CAM_TARGET_WILDCARD
condition|)
block|{
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"%s:%d:%jx func_code 0x%04x: "
literal|"Invalid target (no wildcard)\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
name|END_DEBUG
name|ccb
operator|->
name|ccb_h
operator|.
name|status
init|=
name|CAM_DEV_NOT_THERE
decl_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
comment|/* XXX Hm, we should check the input parameters */
break|break;
block|}
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|int
name|speed
decl_stmt|;
name|void
modifier|*
name|cdb
decl_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|mtx_assert
argument_list|(
name|sim
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|2
argument_list|)
name|printf
argument_list|(
literal|"%s:%d:%jx XPT_SCSI_IO: "
literal|"cmd: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x"
literal|", flags: 0x%02x, "
literal|"%db cmd/%db data/%db sense\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|1
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|2
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|3
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|4
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|5
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|6
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|7
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|8
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|9
index|]
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|csio
operator|->
name|sense_len
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
comment|/* if we are in probe stage, pass only probe commands */
block|if (sdev->status == SBP_DEV_PROBE) { 			char *name; 			name = xpt_path_periph(ccb->ccb_h.path)->periph_name; 			printf("probe stage, periph name: %s\n", name); 			if (strcmp(name, "probe") != 0) { 				ccb->ccb_h.status = CAM_REQUEUE_REQ; 				xpt_done(ccb); 				return; 			} 		}
endif|#
directive|endif
if|if
condition|(
operator|(
name|ocb
operator|=
name|sbp_get_ocb
argument_list|(
name|sdev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
if|if
condition|(
name|sdev
operator|->
name|freeze
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|freeze
operator|++
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|ocb
operator|->
name|flags
operator|=
name|OCB_ACT_CMD
expr_stmt|;
name|ocb
operator|->
name|sdev
operator|=
name|sdev
expr_stmt|;
name|ocb
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_sdev_ptr
operator|=
name|sdev
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
literal|1U
operator|<<
literal|31
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|2
index|]
operator|=
name|htonl
argument_list|(
operator|(
operator|(
name|sbp
operator|->
name|fd
operator|.
name|fc
operator|->
name|nodeid
operator||
name|FWLOCALBUS
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|3
index|]
operator|=
name|htonl
argument_list|(
name|ocb
operator|->
name|bus_addr
operator|+
name|IND_PTR_OFFSET
argument_list|)
expr_stmt|;
name|speed
operator|=
name|min
argument_list|(
name|target
operator|->
name|fwdev
operator|->
name|speed
argument_list|,
name|max_speed
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
operator|=
name|htonl
argument_list|(
name|ORB_NOTIFY
operator||
name|ORB_CMD_SPD
argument_list|(
name|speed
argument_list|)
operator||
name|ORB_CMD_MAXP
argument_list|(
name|speed
operator|+
literal|7
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
operator||=
name|htonl
argument_list|(
name|ORB_CMD_IN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
name|cdb
operator|=
operator|(
name|void
operator|*
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
expr_stmt|;
else|else
name|cdb
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bcopy
argument_list|(
name|cdb
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ocb
operator|->
name|orb
index|[
literal|5
index|]
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
comment|/* printf("ORB %08x %08x %08x %08x\n", ntohl(ocb->orb[0]), ntohl(ocb->orb[1]), ntohl(ocb->orb[2]), ntohl(ocb->orb[3])); printf("ORB %08x %08x %08x %08x\n", ntohl(ocb->orb[4]), ntohl(ocb->orb[5]), ntohl(ocb->orb[6]), ntohl(ocb->orb[7])); */
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|>
literal|0
condition|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|bus_dmamap_load_ccb
argument_list|(
comment|/*dma tag*/
name|sbp
operator|->
name|dmat
argument_list|,
comment|/*dma map*/
name|ocb
operator|->
name|dmamap
argument_list|,
name|ccb
argument_list|,
name|sbp_execute_ocb
argument_list|,
name|ocb
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"sbp: bus_dmamap_load error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
name|sbp_execute_ocb
argument_list|(
name|ocb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
decl_stmt|;
name|ccg
operator|=
operator|&
name|ccb
operator|->
name|ccg
expr_stmt|;
if|if
condition|(
name|ccg
operator|->
name|block_size
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_action: block_size is 0.\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"%s:%d:%d:%jx:XPT_CALC_GEOMETRY: "
literal|"Volume size = %jd\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|cam_sim_path
argument_list|(
name|sbp
operator|->
name|sim
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ccg
operator|->
name|volume_size
argument_list|)
expr_stmt|;
name|END_DEBUG
name|cam_calc_geometry
argument_list|(
name|ccg
argument_list|,
comment|/*extended*/
literal|1
argument_list|)
decl_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
block|{
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"%s:%d:XPT_RESET_BUS: \n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|cam_sim_path
argument_list|(
name|sbp
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|END_DEBUG
name|ccb
operator|->
name|ccb_h
operator|.
name|status
init|=
name|CAM_REQ_INVALID
decl_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"%s:%d:%jx XPT_PATH_INQ:.\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
name|END_DEBUG
name|cpi
operator|->
name|version_num
init|=
literal|1
decl_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_TAG_ABLE
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_NOBUSRESET
operator||
name|PIM_NO_6_BYTE
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|SBP_NUM_TARGETS
operator|-
literal|1
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
name|SBP_NUM_LUNS
operator|-
literal|1
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|SBP_INITIATOR
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|sim
operator|->
name|bus_id
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|400
operator|*
literal|1000
operator|/
literal|8
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"SBP"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|sim
operator|->
name|sim_name
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|sim
operator|->
name|unit_number
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
comment|/* XX should have a FireWire */
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
decl_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
comment|/* should have a FireWire */
name|cts
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_DISC
expr_stmt|;
name|spi
operator|->
name|flags
operator|=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|scsi
operator|->
name|flags
operator|=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"%s:%d:%jx XPT_GET_TRAN_SETTINGS:.\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
name|END_DEBUG
name|cts
operator|->
name|ccb_h
operator|.
name|status
init|=
name|CAM_REQ_CMP
decl_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_ABORT
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UA_ABORT
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
comment|/* XXX */
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_execute_ocb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segments
parameter_list|,
name|int
name|seg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|prev
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"sbp_execute_ocb: error=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ocb
operator|=
operator|(
expr|struct
name|sbp_ocb
operator|*
operator|)
name|arg
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|2
argument_list|)
name|printf
argument_list|(
literal|"sbp_execute_ocb: seg %d"
argument_list|,
name|seg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seg
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|", %jx:%jd"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|segments
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|,
operator|(
name|uintmax_t
operator|)
name|segments
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|seg
operator|==
literal|1
condition|)
block|{
comment|/* direct pointer */
name|s
operator|=
operator|&
name|segments
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|ds_len
operator|>
name|SBP_SEG_MAX
condition|)
name|panic
argument_list|(
literal|"ds_len> SBP_SEG_MAX, fix busdma code"
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|3
index|]
operator|=
name|htonl
argument_list|(
name|s
operator|->
name|ds_addr
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
operator||=
name|htonl
argument_list|(
name|s
operator|->
name|ds_len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seg
operator|>
literal|1
condition|)
block|{
comment|/* page table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seg
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|segments
index|[
name|i
index|]
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
comment|/* XXX LSI Logic "< 16 byte" bug might be hit */
if|if
condition|(
name|s
operator|->
name|ds_len
operator|<
literal|16
condition|)
name|printf
argument_list|(
literal|"sbp_execute_ocb: warning, "
literal|"segment length(%zd) is less than 16."
literal|"(seg=%d/%d)\n"
argument_list|,
operator|(
name|size_t
operator|)
name|s
operator|->
name|ds_len
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|seg
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|s
operator|->
name|ds_len
operator|>
name|SBP_SEG_MAX
condition|)
name|panic
argument_list|(
literal|"ds_len> SBP_SEG_MAX, fix busdma code"
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|ind_ptr
index|[
name|i
index|]
operator|.
name|hi
operator|=
name|htonl
argument_list|(
name|s
operator|->
name|ds_len
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|ind_ptr
index|[
name|i
index|]
operator|.
name|lo
operator|=
name|htonl
argument_list|(
name|s
operator|->
name|ds_addr
argument_list|)
expr_stmt|;
block|}
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
operator||=
name|htonl
argument_list|(
name|ORB_CMD_PTBL
operator||
name|seg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seg
operator|>
literal|0
condition|)
name|bus_dmamap_sync
argument_list|(
name|ocb
operator|->
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|dmat
argument_list|,
name|ocb
operator|->
name|dmamap
argument_list|,
operator|(
name|ntohl
argument_list|(
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
argument_list|)
operator|&
name|ORB_CMD_IN
operator|)
condition|?
name|BUS_DMASYNC_PREREAD
else|:
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|prev
operator|=
name|sbp_enqueue_ocb
argument_list|(
name|ocb
operator|->
name|sdev
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
name|fwdma_sync
argument_list|(
operator|&
name|ocb
operator|->
name|sdev
operator|->
name|dma
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_doorbell
condition|)
block|{
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ocb
operator|->
name|sdev
operator|->
name|last_ocb
operator|!=
name|NULL
condition|)
name|sbp_doorbell
argument_list|(
name|ocb
operator|->
name|sdev
argument_list|)
expr_stmt|;
else|else
name|sbp_orb_pointer
argument_list|(
name|ocb
operator|->
name|sdev
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|prev
operator|==
name|NULL
operator|||
operator|(
name|ocb
operator|->
name|sdev
operator|->
name|flags
operator|&
name|ORB_LINK_DEAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|ocb
operator|->
name|sdev
operator|->
name|flags
operator|&=
operator|~
name|ORB_LINK_DEAD
expr_stmt|;
name|sbp_orb_pointer
argument_list|(
name|ocb
operator|->
name|sdev
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|struct
name|sbp_softc
modifier|*
name|sbp
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
decl_stmt|;
name|sbp
operator|=
operator|(
expr|struct
name|sbp_softc
operator|*
operator|)
name|sim
operator|->
name|softc
expr_stmt|;
name|fc
operator|=
name|sbp
operator|->
name|fd
operator|.
name|fc
expr_stmt|;
name|fc
operator|->
name|poll
argument_list|(
name|fc
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|struct
name|sbp_ocb
modifier|*
name|sbp_dequeue_ocb
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|,
name|struct
name|sbp_status
modifier|*
name|sbp_status
parameter_list|)
block|{
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|next
decl_stmt|;
name|int
name|order
init|=
literal|0
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s 0x%08x src %d\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|,
name|ntohl
argument_list|(
name|sbp_status
operator|->
name|orb_lo
argument_list|)
argument_list|,
name|sbp_status
operator|->
name|src
argument_list|)
expr_stmt|;
name|END_DEBUG
name|SBP_LOCK_ASSERT
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
decl_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|ocb
argument_list|,
argument|&sdev->ocbs
argument_list|,
argument|ocb
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|OCB_MATCH
argument_list|(
name|ocb
argument_list|,
name|sbp_status
argument_list|)
condition|)
block|{
comment|/* found */
name|STAILQ_REMOVE
argument_list|(
operator|&
name|sdev
operator|->
name|ocbs
argument_list|,
name|ocb
argument_list|,
name|sbp_ocb
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ocb
operator|->
name|ccb
operator|!=
name|NULL
condition|)
name|callout_stop
argument_list|(
operator|&
name|ocb
operator|->
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntohl
argument_list|(
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
argument_list|)
operator|&
literal|0xffff
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|dmat
argument_list|,
name|ocb
operator|->
name|dmamap
argument_list|,
operator|(
name|ntohl
argument_list|(
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
argument_list|)
operator|&
name|ORB_CMD_IN
operator|)
condition|?
name|BUS_DMASYNC_POSTREAD
else|:
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|dmat
argument_list|,
name|ocb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|use_doorbell
condition|)
block|{
if|if
condition|(
name|sbp_status
operator|->
name|src
operator|==
name|SRC_NO_NEXT
condition|)
block|{
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
name|sbp_orb_pointer
argument_list|(
name|sdev
argument_list|,
name|next
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|order
operator|>
literal|0
condition|)
block|{
comment|/* 						 * Unordered execution 						 * We need to send pointer for 						 * next ORB 						 */
name|sdev
operator|->
name|flags
operator||=
name|ORB_LINK_DEAD
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 				 * XXX this is not correct for unordered 				 * execution.  				 */
if|if
condition|(
name|sdev
operator|->
name|last_ocb
operator|!=
name|NULL
condition|)
block|{
name|sbp_free_ocb
argument_list|(
name|sdev
argument_list|,
name|sdev
operator|->
name|last_ocb
argument_list|)
expr_stmt|;
block|}
name|sdev
operator|->
name|last_ocb
operator|=
name|ocb
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
operator|&&
name|sbp_status
operator|->
name|src
operator|==
name|SRC_NO_NEXT
condition|)
name|sbp_doorbell
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
else|else
name|order
operator|++
expr_stmt|;
block|}
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
if|if
condition|(
name|ocb
operator|&&
name|order
operator|>
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s unordered execution order:%d\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|,
name|order
argument_list|)
expr_stmt|;
block|}
name|END_DEBUG
return|return
operator|(
name|ocb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sbp_ocb
modifier|*
name|sbp_enqueue_ocb
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|,
name|struct
name|sbp_ocb
modifier|*
name|ocb
parameter_list|)
block|{
name|struct
name|sbp_ocb
modifier|*
name|prev
decl_stmt|,
modifier|*
name|prev2
decl_stmt|;
name|SBP_LOCK_ASSERT
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s 0x%08jx\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ocb
operator|->
name|bus_addr
argument_list|)
expr_stmt|;
name|END_DEBUG
name|prev2
init|=
name|prev
operator|=
name|STAILQ_LAST
argument_list|(
operator|&
name|sdev
operator|->
name|ocbs
argument_list|,
name|sbp_ocb
argument_list|,
name|ocb
argument_list|)
decl_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sdev
operator|->
name|ocbs
argument_list|,
name|ocb
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ocb
operator|->
name|ccb
operator|!=
name|NULL
condition|)
name|callout_reset
argument_list|(
operator|&
name|ocb
operator|->
name|timer
argument_list|,
operator|(
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|,
name|sbp_timeout
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_doorbell
operator|&&
name|prev
operator|==
name|NULL
condition|)
name|prev2
operator|=
name|sdev
operator|->
name|last_ocb
expr_stmt|;
if|if
condition|(
name|prev2
operator|!=
name|NULL
operator|&&
operator|(
name|ocb
operator|->
name|sdev
operator|->
name|flags
operator|&
name|ORB_LINK_DEAD
operator|)
operator|==
literal|0
condition|)
block|{
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"linking chain 0x%jx -> 0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|prev2
operator|->
name|bus_addr
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ocb
operator|->
name|bus_addr
argument_list|)
expr_stmt|;
name|END_DEBUG
comment|/* 		 * Suppress compiler optimization so that orb[1] must be written first. 		 * XXX We may need an explicit memory barrier for other architectures 		 * other than i386/amd64. 		 */
argument_list|*
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|&
name|prev2
operator|->
name|orb
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
name|ocb
operator|->
name|bus_addr
argument_list|)
argument_list|;
operator|*
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|&
name|prev2
operator|->
name|orb
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sbp_ocb
modifier|*
name|sbp_get_ocb
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|SBP_LOCK_ASSERT
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
name|ocb
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sdev
operator|->
name|free_ocbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ocb
operator|==
name|NULL
condition|)
block|{
name|sdev
operator|->
name|flags
operator||=
name|ORB_SHORTAGE
expr_stmt|;
name|printf
argument_list|(
literal|"ocb shortage!!!\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sdev
operator|->
name|free_ocbs
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ocb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_free_ocb
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|,
name|struct
name|sbp_ocb
modifier|*
name|ocb
parameter_list|)
block|{
name|ocb
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ocb
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
name|SBP_LOCK_ASSERT
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sdev
operator|->
name|free_ocbs
argument_list|,
name|ocb
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sdev
operator|->
name|flags
operator|&
name|ORB_SHORTAGE
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|count
decl_stmt|;
name|sdev
operator|->
name|flags
operator|&=
operator|~
name|ORB_SHORTAGE
expr_stmt|;
name|count
operator|=
name|sdev
operator|->
name|freeze
expr_stmt|;
name|sdev
operator|->
name|freeze
operator|=
literal|0
expr_stmt|;
name|xpt_release_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
name|count
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_abort_ocb
parameter_list|(
name|struct
name|sbp_ocb
modifier|*
name|ocb
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
name|ocb
operator|->
name|sdev
expr_stmt|;
name|SBP_LOCK_ASSERT
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|device_printf
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"%s:%s 0x%jx\n"
argument_list|,
name|__func__
argument_list|,
name|sdev
operator|->
name|bustgtlun
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ocb
operator|->
name|bus_addr
argument_list|)
expr_stmt|;
name|END_DEBUG
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
decl|if
argument_list|(
name|ocb
operator|->
name|ccb
operator|!=
name|NULL
argument_list|)
name|sbp_print_scsi_cmd
argument_list|(
name|ocb
argument_list|)
decl_stmt|;
name|END_DEBUG
if|if
condition|(
name|ntohl
argument_list|(
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
argument_list|)
operator|&
literal|0xffff
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|dmat
argument_list|,
name|ocb
operator|->
name|dmamap
argument_list|,
operator|(
name|ntohl
argument_list|(
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
argument_list|)
operator|&
name|ORB_CMD_IN
operator|)
condition|?
name|BUS_DMASYNC_POSTREAD
else|:
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|dmat
argument_list|,
name|ocb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ocb
operator|->
name|ccb
operator|!=
name|NULL
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|ocb
operator|->
name|timer
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|xpt_done
argument_list|(
name|ocb
operator|->
name|ccb
argument_list|)
expr_stmt|;
block|}
name|sbp_free_ocb
argument_list|(
name|sdev
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_abort_all_ocbs
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|sbp_ocb
argument_list|)
name|temp
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|SBP_LOCK_ASSERT
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
expr_stmt|;
name|STAILQ_CONCAT
argument_list|(
operator|&
name|temp
argument_list|,
operator|&
name|sdev
operator|->
name|ocbs
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sdev
operator|->
name|ocbs
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|ocb
argument_list|,
argument|&temp
argument_list|,
argument|ocb
argument_list|,
argument|next
argument_list|)
block|{
name|sbp_abort_ocb
argument_list|(
name|ocb
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sdev
operator|->
name|last_ocb
operator|!=
name|NULL
condition|)
block|{
name|sbp_free_ocb
argument_list|(
name|sdev
argument_list|,
name|sdev
operator|->
name|last_ocb
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|last_ocb
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|devclass_t
name|sbp_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|sbp_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|sbp_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|sbp_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|sbp_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|sbp_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|sbp_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|sbp_driver
init|=
block|{
literal|"sbp"
block|,
name|sbp_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbp_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|sbp
argument_list|,
name|firewire
argument_list|,
name|sbp_driver
argument_list|,
name|sbp_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|sbp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|sbp
argument_list|,
name|firewire
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|sbp
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

