begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 Hidetoshi Shimokawa  * Copyright (c) 1998-2002 Katsushi Kobayashi and Hidetoshi Shimokawa  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the acknowledgement as bellow:  *  *    This product includes software developed by K. Kobayashi and H. Shimokawa  *  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *   * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|501102
end_if

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500106
end_if

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_comment
comment|/* for struct devstat */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__DragonFly__
end_ifdef

begin_include
include|#
directive|include
file|<bus/cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<bus/cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<bus/cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<bus/cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<bus/cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<bus/cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<bus/cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<bus/firewire/firewire.h>
end_include

begin_include
include|#
directive|include
file|<bus/firewire/firewirereg.h>
end_include

begin_include
include|#
directive|include
file|<bus/firewire/fwdma.h>
end_include

begin_include
include|#
directive|include
file|<bus/firewire/iec13213.h>
end_include

begin_include
include|#
directive|include
file|"sbp.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewire.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewirereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/fwdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/iec13213.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/sbp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ccb_sdev_ptr
value|spriv_ptr0
end_define

begin_define
define|#
directive|define
name|ccb_sbp_ptr
value|spriv_ptr1
end_define

begin_define
define|#
directive|define
name|SBP_NUM_TARGETS
value|8
end_define

begin_comment
comment|/* MAX 64 */
end_comment

begin_comment
comment|/*  * Scan_bus doesn't work for more than 8 LUNs  * because of CAM_SCSI2_MAXLUN in cam_xpt.c  */
end_comment

begin_define
define|#
directive|define
name|SBP_NUM_LUNS
value|64
end_define

begin_define
define|#
directive|define
name|SBP_MAXPHYS
value|MIN(MAXPHYS, (512*1024)
comment|/* 512KB */
value|)
end_define

begin_define
define|#
directive|define
name|SBP_DMA_SIZE
value|PAGE_SIZE
end_define

begin_define
define|#
directive|define
name|SBP_LOGIN_SIZE
value|sizeof(struct sbp_login_res)
end_define

begin_define
define|#
directive|define
name|SBP_QUEUE_LEN
value|((SBP_DMA_SIZE - SBP_LOGIN_SIZE) / sizeof(struct sbp_ocb))
end_define

begin_define
define|#
directive|define
name|SBP_NUM_OCB
value|(SBP_QUEUE_LEN * SBP_NUM_TARGETS)
end_define

begin_comment
comment|/*   * STATUS FIFO addressing  *   bit  * -----------------------  *  0- 1( 2): 0 (alignment)  *  2- 7( 6): target  *  8-15( 8): lun  * 16-31( 8): reserved  * 32-47(16): SBP_BIND_HI   * 48-64(16): bus_id, node_id   */
end_comment

begin_define
define|#
directive|define
name|SBP_BIND_HI
value|0x1
end_define

begin_define
define|#
directive|define
name|SBP_DEV2ADDR
parameter_list|(
name|t
parameter_list|,
name|l
parameter_list|)
define|\
value|(((u_int64_t)SBP_BIND_HI<< 32) \ 	| (((l)& 0xff)<< 8) \ 	| (((t)& 0x3f)<< 2))
end_define

begin_define
define|#
directive|define
name|SBP_ADDR2TRG
parameter_list|(
name|a
parameter_list|)
value|(((a)>> 2)& 0x3f)
end_define

begin_define
define|#
directive|define
name|SBP_ADDR2LUN
parameter_list|(
name|a
parameter_list|)
value|(((a)>> 8)& 0xff)
end_define

begin_define
define|#
directive|define
name|SBP_INITIATOR
value|7
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|orb_fun_name
index|[]
init|=
block|{
name|ORB_FUN_NAMES
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|auto_login
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_speed
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sbp_cold
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ex_login
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|login_delay
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* msec */
end_comment

begin_decl_stmt
specifier|static
name|int
name|scan_delay
init|=
literal|500
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* msec */
end_comment

begin_decl_stmt
specifier|static
name|int
name|use_doorbell
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sbp_tags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_firewire
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_firewire
argument_list|,
name|OID_AUTO
argument_list|,
name|sbp
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"SBP-II Subsystem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|sbp_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|debug
argument_list|,
literal|0
argument_list|,
literal|"SBP debug flag"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_sbp
argument_list|,
name|OID_AUTO
argument_list|,
name|auto_login
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|auto_login
argument_list|,
literal|0
argument_list|,
literal|"SBP perform login automatically"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_sbp
argument_list|,
name|OID_AUTO
argument_list|,
name|max_speed
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|max_speed
argument_list|,
literal|0
argument_list|,
literal|"SBP transfer max speed"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_sbp
argument_list|,
name|OID_AUTO
argument_list|,
name|exclusive_login
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ex_login
argument_list|,
literal|0
argument_list|,
literal|"SBP enable exclusive login"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_sbp
argument_list|,
name|OID_AUTO
argument_list|,
name|login_delay
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|login_delay
argument_list|,
literal|0
argument_list|,
literal|"SBP login delay in msec"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_sbp
argument_list|,
name|OID_AUTO
argument_list|,
name|scan_delay
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|scan_delay
argument_list|,
literal|0
argument_list|,
literal|"SBP scan delay in msec"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_sbp
argument_list|,
name|OID_AUTO
argument_list|,
name|use_doorbell
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|use_doorbell
argument_list|,
literal|0
argument_list|,
literal|"SBP use doorbell request"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_sbp
argument_list|,
name|OID_AUTO
argument_list|,
name|tags
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sbp_tags
argument_list|,
literal|0
argument_list|,
literal|"SBP tagged queuing support"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.firewire.sbp.auto_login"
argument_list|,
operator|&
name|auto_login
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.firewire.sbp.max_speed"
argument_list|,
operator|&
name|max_speed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.firewire.sbp.exclusive_login"
argument_list|,
operator|&
name|ex_login
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.firewire.sbp.login_delay"
argument_list|,
operator|&
name|login_delay
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.firewire.sbp.scan_delay"
argument_list|,
operator|&
name|scan_delay
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.firewire.sbp.use_doorbell"
argument_list|,
operator|&
name|use_doorbell
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.firewire.sbp.tags"
argument_list|,
operator|&
name|sbp_tags
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NEED_RESPONSE
value|0
end_define

begin_define
define|#
directive|define
name|SBP_SEG_MAX
value|rounddown(0xffff, PAGE_SIZE)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__sparc64__
end_ifdef

begin_comment
comment|/* iommu */
end_comment

begin_define
define|#
directive|define
name|SBP_IND_MAX
value|howmany(SBP_MAXPHYS, SBP_SEG_MAX)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SBP_IND_MAX
value|howmany(SBP_MAXPHYS, PAGE_SIZE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|sbp_ocb
block|{
name|STAILQ_ENTRY
argument_list|(
argument|sbp_ocb
argument_list|)
name|ocb
expr_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|bus_addr_t
name|bus_addr
decl_stmt|;
name|uint32_t
name|orb
index|[
literal|8
index|]
decl_stmt|;
define|#
directive|define
name|IND_PTR_OFFSET
value|(8*sizeof(uint32_t))
name|struct
name|ind_ptr
name|ind_ptr
index|[
name|SBP_IND_MAX
index|]
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* XXX should be removed */
name|bus_dmamap_t
name|dmamap
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|OCB_ACT_MGM
value|0
end_define

begin_define
define|#
directive|define
name|OCB_ACT_CMD
value|1
end_define

begin_define
define|#
directive|define
name|OCB_MATCH
parameter_list|(
name|o
parameter_list|,
name|s
parameter_list|)
value|((o)->bus_addr == ntohl((s)->orb_lo))
end_define

begin_struct
struct|struct
name|sbp_dev
block|{
define|#
directive|define
name|SBP_DEV_RESET
value|0
comment|/* accept login */
define|#
directive|define
name|SBP_DEV_LOGIN
value|1
comment|/* to login */
if|#
directive|if
literal|0
define|#
directive|define
name|SBP_DEV_RECONN
value|2
comment|/* to reconnect */
endif|#
directive|endif
define|#
directive|define
name|SBP_DEV_TOATTACH
value|3
comment|/* to attach */
define|#
directive|define
name|SBP_DEV_PROBE
value|4
comment|/* scan lun */
define|#
directive|define
name|SBP_DEV_ATTACHED
value|5
comment|/* in operation */
define|#
directive|define
name|SBP_DEV_DEAD
value|6
comment|/* unavailable unit */
define|#
directive|define
name|SBP_DEV_RETRY
value|7
comment|/* unavailable unit */
name|uint8_t
name|status
range|:
literal|4
decl_stmt|,
name|timeout
range|:
literal|4
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
name|uint16_t
name|lun_id
decl_stmt|;
name|uint16_t
name|freeze
decl_stmt|;
define|#
directive|define
name|ORB_LINK_DEAD
value|(1<< 0)
define|#
directive|define
name|VALID_LUN
value|(1<< 1)
define|#
directive|define
name|ORB_POINTER_ACTIVE
value|(1<< 2)
define|#
directive|define
name|ORB_POINTER_NEED
value|(1<< 3)
define|#
directive|define
name|ORB_DOORBELL_ACTIVE
value|(1<< 4)
define|#
directive|define
name|ORB_DOORBELL_NEED
value|(1<< 5)
define|#
directive|define
name|ORB_SHORTAGE
value|(1<< 6)
name|uint16_t
name|flags
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|struct
name|fwdma_alloc
name|dma
decl_stmt|;
name|struct
name|sbp_login_res
modifier|*
name|login
decl_stmt|;
name|struct
name|callout
name|login_callout
decl_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|sbp_ocb
argument_list|)
name|ocbs
expr_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|sbp_ocb
argument_list|)
name|free_ocbs
expr_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|last_ocb
decl_stmt|;
name|char
name|vendor
index|[
literal|32
index|]
decl_stmt|;
name|char
name|product
index|[
literal|32
index|]
decl_stmt|;
name|char
name|revision
index|[
literal|10
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sbp_target
block|{
name|int
name|target_id
decl_stmt|;
name|int
name|num_lun
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
modifier|*
name|luns
decl_stmt|;
name|struct
name|sbp_softc
modifier|*
name|sbp
decl_stmt|;
name|struct
name|fw_device
modifier|*
name|fwdev
decl_stmt|;
name|uint32_t
name|mgm_hi
decl_stmt|,
name|mgm_lo
decl_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|mgm_ocb_cur
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|sbp_ocb
argument_list|)
name|mgm_ocb_queue
expr_stmt|;
name|struct
name|callout
name|mgm_ocb_timeout
decl_stmt|;
name|struct
name|callout
name|scan_callout
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|fw_xfer
argument_list|)
name|xferlist
expr_stmt|;
name|int
name|n_xfer
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sbp_softc
block|{
name|struct
name|firewire_dev_comm
name|fd
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|sbp_target
name|targets
index|[
name|SBP_NUM_TARGETS
index|]
decl_stmt|;
name|struct
name|fw_bind
name|fwb
decl_stmt|;
name|bus_dma_tag_t
name|dmat
decl_stmt|;
name|struct
name|timeval
name|last_busreset
decl_stmt|;
define|#
directive|define
name|SIMQ_FREEZED
value|1
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|sbp_post_explore
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_recv
parameter_list|(
name|struct
name|fw_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_mgm_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void sbp_cmd_callback (struct fw_xfer *);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|sbp_orb_pointer
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|,
name|struct
name|sbp_ocb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_doorbell
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_execute_ocb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_free_ocb
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|,
name|struct
name|sbp_ocb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_abort_ocb
parameter_list|(
name|struct
name|sbp_ocb
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_abort_all_ocbs
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|fw_xfer
modifier|*
name|sbp_write_cmd
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|sbp_ocb
modifier|*
name|sbp_get_ocb
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|sbp_ocb
modifier|*
name|sbp_enqueue_ocb
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|,
name|struct
name|sbp_ocb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|sbp_ocb
modifier|*
name|sbp_dequeue_ocb
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|,
name|struct
name|sbp_status
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_cam_detach_sdev
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_free_sdev
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_cam_detach_target
parameter_list|(
name|struct
name|sbp_target
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_free_target
parameter_list|(
name|struct
name|sbp_target
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_mgm_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_mgm_orb
parameter_list|(
name|struct
name|sbp_dev
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|sbp_ocb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_SBP
argument_list|,
literal|"sbp"
argument_list|,
literal|"SBP-II/FireWire"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* cam related functions */
end_comment

begin_function_decl
specifier|static
name|void
name|sbp_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_cam_scan_lun
parameter_list|(
name|struct
name|cam_periph
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_cam_scan_target
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|orb_status0
index|[]
init|=
block|{
comment|/* 0 */
literal|"No additional information to report"
block|,
comment|/* 1 */
literal|"Request type not supported"
block|,
comment|/* 2 */
literal|"Speed not supported"
block|,
comment|/* 3 */
literal|"Page size not supported"
block|,
comment|/* 4 */
literal|"Access denied"
block|,
comment|/* 5 */
literal|"Logical unit not supported"
block|,
comment|/* 6 */
literal|"Maximum payload too small"
block|,
comment|/* 7 */
literal|"Reserved for future standardization"
block|,
comment|/* 8 */
literal|"Resources unavailable"
block|,
comment|/* 9 */
literal|"Function rejected"
block|,
comment|/* A */
literal|"Login ID not recognized"
block|,
comment|/* B */
literal|"Dummy ORB completed"
block|,
comment|/* C */
literal|"Request aborted"
block|,
comment|/* FF */
literal|"Unspecified error"
define|#
directive|define
name|MAX_ORB_STATUS0
value|0xd
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|orb_status1_object
index|[]
init|=
block|{
comment|/* 0 */
literal|"Operation request block (ORB)"
block|,
comment|/* 1 */
literal|"Data buffer"
block|,
comment|/* 2 */
literal|"Page table"
block|,
comment|/* 3 */
literal|"Unable to specify"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|orb_status1_serial_bus_error
index|[]
init|=
block|{
comment|/* 0 */
literal|"Missing acknowledge"
block|,
comment|/* 1 */
literal|"Reserved; not to be used"
block|,
comment|/* 2 */
literal|"Time-out error"
block|,
comment|/* 3 */
literal|"Reserved; not to be used"
block|,
comment|/* 4 */
literal|"Busy retry limit exceeded(X)"
block|,
comment|/* 5 */
literal|"Busy retry limit exceeded(A)"
block|,
comment|/* 6 */
literal|"Busy retry limit exceeded(B)"
block|,
comment|/* 7 */
literal|"Reserved for future standardization"
block|,
comment|/* 8 */
literal|"Reserved for future standardization"
block|,
comment|/* 9 */
literal|"Reserved for future standardization"
block|,
comment|/* A */
literal|"Reserved for future standardization"
block|,
comment|/* B */
literal|"Tardy retry limit exceeded"
block|,
comment|/* C */
literal|"Conflict error"
block|,
comment|/* D */
literal|"Data error"
block|,
comment|/* E */
literal|"Type error"
block|,
comment|/* F */
literal|"Address error"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sbp_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"sbp_identify\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|child
init|=
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|"sbp"
argument_list|,
name|device_get_unit
argument_list|(
name|parent
argument_list|)
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|/*  * sbp_probe()  */
end_comment

begin_function
specifier|static
name|int
name|sbp_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|pa
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"sbp_probe\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|pa
init|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|!=
name|device_get_unit
argument_list|(
name|pa
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"SBP-2/SCSI over FireWire"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (bootverbose) 		debug = bootverbose;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_show_sdev_info
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|,
name|int
name|new
parameter_list|)
block|{
name|struct
name|fw_device
modifier|*
name|fwdev
decl_stmt|;
name|printf
argument_list|(
literal|"%s:%d:%d "
argument_list|,
name|device_get_nameunit
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|sdev
operator|->
name|target
operator|->
name|target_id
argument_list|,
name|sdev
operator|->
name|lun_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|2
condition|)
block|{
return|return;
block|}
name|fwdev
operator|=
name|sdev
operator|->
name|target
operator|->
name|fwdev
expr_stmt|;
name|printf
argument_list|(
literal|"ordered:%d type:%d EUI:%08x%08x node:%d "
literal|"speed:%d maxrec:%d"
argument_list|,
operator|(
name|sdev
operator|->
name|type
operator|&
literal|0x40
operator|)
operator|>>
literal|6
argument_list|,
operator|(
name|sdev
operator|->
name|type
operator|&
literal|0x1f
operator|)
argument_list|,
name|fwdev
operator|->
name|eui
operator|.
name|hi
argument_list|,
name|fwdev
operator|->
name|eui
operator|.
name|lo
argument_list|,
name|fwdev
operator|->
name|dst
argument_list|,
name|fwdev
operator|->
name|speed
argument_list|,
name|fwdev
operator|->
name|maxrec
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
name|printf
argument_list|(
literal|" new!\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"'%s' '%s' '%s'\n"
argument_list|,
name|sdev
operator|->
name|vendor
argument_list|,
name|sdev
operator|->
name|product
argument_list|,
name|sdev
operator|->
name|revision
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
name|int
name|bus
decl_stmt|;
name|int
name|target
decl_stmt|;
name|struct
name|fw_eui64
name|eui
decl_stmt|;
block|}
name|wired
index|[]
init|=
block|{
comment|/* Bus	Target	EUI64 */
if|#
directive|if
literal|0
block|{0,	2,	{0x00018ea0, 0x01fd0154}},
comment|/* Logitec HDD */
block|{0,	0,	{0x00018ea6, 0x00100682}},
comment|/* Logitec DVD */
block|{0,	1,	{0x00d03200, 0xa412006a}},
comment|/* Yano HDD */
endif|#
directive|endif
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|sbp_new_target
parameter_list|(
name|struct
name|sbp_softc
modifier|*
name|sbp
parameter_list|,
name|struct
name|fw_device
modifier|*
name|fwdev
parameter_list|)
block|{
name|int
name|bus
decl_stmt|,
name|i
decl_stmt|,
name|target
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|w
index|[
name|SBP_NUM_TARGETS
index|]
decl_stmt|;
name|bzero
argument_list|(
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
name|bus
operator|=
name|device_get_unit
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
expr_stmt|;
comment|/* XXX wired-down configuration should be gotten from 					tunable or device hint */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|wired
index|[
name|i
index|]
operator|.
name|bus
operator|>=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wired
index|[
name|i
index|]
operator|.
name|bus
operator|==
name|bus
condition|)
block|{
name|w
index|[
name|wired
index|[
name|i
index|]
operator|.
name|target
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|wired
index|[
name|i
index|]
operator|.
name|eui
operator|.
name|hi
operator|==
name|fwdev
operator|->
name|eui
operator|.
name|hi
operator|&&
name|wired
index|[
name|i
index|]
operator|.
name|eui
operator|.
name|lo
operator|==
name|fwdev
operator|->
name|eui
operator|.
name|lo
condition|)
name|target
operator|=
name|wired
index|[
name|i
index|]
operator|.
name|target
expr_stmt|;
block|}
block|}
if|if
condition|(
name|target
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|target
operator|<
name|SBP_NUM_TARGETS
operator|&&
name|sbp
operator|->
name|targets
index|[
name|target
index|]
operator|.
name|fwdev
operator|==
name|NULL
condition|)
return|return
operator|(
name|target
operator|)
return|;
name|device_printf
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"target %d is not free for %08x:%08x\n"
argument_list|,
name|target
argument_list|,
name|fwdev
operator|->
name|eui
operator|.
name|hi
argument_list|,
name|fwdev
operator|->
name|eui
operator|.
name|lo
argument_list|)
expr_stmt|;
name|target
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* non-wired target */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBP_NUM_TARGETS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sbp
operator|->
name|targets
index|[
name|i
index|]
operator|.
name|fwdev
operator|==
name|NULL
operator|&&
name|w
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|target
operator|=
name|i
expr_stmt|;
break|break;
block|}
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_alloc_lun
parameter_list|(
name|struct
name|sbp_target
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|crom_context
name|cc
decl_stmt|;
name|struct
name|csrreg
modifier|*
name|reg
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|,
modifier|*
modifier|*
name|newluns
decl_stmt|;
name|struct
name|sbp_softc
modifier|*
name|sbp
decl_stmt|;
name|int
name|maxlun
decl_stmt|,
name|lun
decl_stmt|,
name|i
decl_stmt|;
name|sbp
operator|=
name|target
operator|->
name|sbp
expr_stmt|;
name|crom_init_context
argument_list|(
operator|&
name|cc
argument_list|,
name|target
operator|->
name|fwdev
operator|->
name|csrrom
argument_list|)
expr_stmt|;
comment|/* XXX shoud parse appropriate unit directories only */
name|maxlun
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|cc
operator|.
name|depth
operator|>=
literal|0
condition|)
block|{
name|reg
operator|=
name|crom_search_key
argument_list|(
operator|&
name|cc
argument_list|,
name|CROM_LUN
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
break|break;
name|lun
operator|=
name|reg
operator|->
name|val
operator|&
literal|0xffff
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"target %d lun %d found\n"
argument_list|,
name|target
operator|->
name|target_id
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|maxlun
operator|<
name|lun
condition|)
name|maxlun
operator|=
name|lun
expr_stmt|;
name|crom_next
argument_list|(
operator|&
name|cc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxlun
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"%s:%d no LUN found\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|target
operator|->
name|target_id
argument_list|)
expr_stmt|;
name|maxlun
operator|++
expr_stmt|;
if|if
condition|(
name|maxlun
operator|>=
name|SBP_NUM_LUNS
condition|)
name|maxlun
operator|=
name|SBP_NUM_LUNS
expr_stmt|;
comment|/* Invalidiate stale devices */
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<
name|target
operator|->
name|num_lun
condition|;
name|lun
operator|++
control|)
block|{
name|sdev
operator|=
name|target
operator|->
name|luns
index|[
name|lun
index|]
expr_stmt|;
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
continue|continue;
name|sdev
operator|->
name|flags
operator|&=
operator|~
name|VALID_LUN
expr_stmt|;
if|if
condition|(
name|lun
operator|>=
name|maxlun
condition|)
block|{
comment|/* lost device */
name|sbp_cam_detach_sdev
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
name|sbp_free_sdev
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reallocate */
if|if
condition|(
name|maxlun
operator|!=
name|target
operator|->
name|num_lun
condition|)
block|{
name|newluns
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|target
operator|->
name|luns
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbp_dev
operator|*
argument_list|)
operator|*
name|maxlun
argument_list|,
name|M_SBP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|newluns
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: realloc failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|newluns
operator|=
name|target
operator|->
name|luns
expr_stmt|;
name|maxlun
operator|=
name|target
operator|->
name|num_lun
expr_stmt|;
block|}
comment|/* 		 * We must zero the extended region for the case 		 * realloc() doesn't allocate new buffer. 		 */
if|if
condition|(
name|maxlun
operator|>
name|target
operator|->
name|num_lun
condition|)
name|bzero
argument_list|(
operator|&
name|newluns
index|[
name|target
operator|->
name|num_lun
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbp_dev
operator|*
argument_list|)
operator|*
operator|(
name|maxlun
operator|-
name|target
operator|->
name|num_lun
operator|)
argument_list|)
expr_stmt|;
name|target
operator|->
name|luns
operator|=
name|newluns
expr_stmt|;
name|target
operator|->
name|num_lun
operator|=
name|maxlun
expr_stmt|;
block|}
name|crom_init_context
argument_list|(
operator|&
name|cc
argument_list|,
name|target
operator|->
name|fwdev
operator|->
name|csrrom
argument_list|)
expr_stmt|;
while|while
condition|(
name|cc
operator|.
name|depth
operator|>=
literal|0
condition|)
block|{
name|int
name|new
init|=
literal|0
decl_stmt|;
name|reg
operator|=
name|crom_search_key
argument_list|(
operator|&
name|cc
argument_list|,
name|CROM_LUN
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
break|break;
name|lun
operator|=
name|reg
operator|->
name|val
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|lun
operator|>=
name|SBP_NUM_LUNS
condition|)
block|{
name|printf
argument_list|(
literal|"too large lun %d\n"
argument_list|,
name|lun
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|sdev
operator|=
name|target
operator|->
name|luns
index|[
name|lun
index|]
expr_stmt|;
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
block|{
name|sdev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sbp_dev
argument_list|)
argument_list|,
name|M_SBP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: malloc failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|target
operator|->
name|luns
index|[
name|lun
index|]
operator|=
name|sdev
expr_stmt|;
name|sdev
operator|->
name|lun_id
operator|=
name|lun
expr_stmt|;
name|sdev
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sdev
operator|->
name|ocbs
argument_list|)
expr_stmt|;
name|CALLOUT_INIT
argument_list|(
operator|&
name|sdev
operator|->
name|login_callout
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_RESET
expr_stmt|;
name|new
operator|=
literal|1
expr_stmt|;
block|}
name|sdev
operator|->
name|flags
operator||=
name|VALID_LUN
expr_stmt|;
name|sdev
operator|->
name|type
operator|=
operator|(
name|reg
operator|->
name|val
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
goto|goto
name|next
goto|;
name|fwdma_malloc
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|fc
argument_list|,
comment|/* alignment */
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|SBP_DMA_SIZE
argument_list|,
operator|&
name|sdev
operator|->
name|dma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdev
operator|->
name|dma
operator|.
name|v_addr
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: dma space allocation failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sdev
argument_list|,
name|M_SBP
argument_list|)
expr_stmt|;
name|target
operator|->
name|luns
index|[
name|lun
index|]
operator|=
name|NULL
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|sdev
operator|->
name|login
operator|=
operator|(
expr|struct
name|sbp_login_res
operator|*
operator|)
name|sdev
operator|->
name|dma
operator|.
name|v_addr
expr_stmt|;
name|sdev
operator|->
name|ocb
operator|=
operator|(
expr|struct
name|sbp_ocb
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|sdev
operator|->
name|dma
operator|.
name|v_addr
operator|+
name|SBP_LOGIN_SIZE
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sdev
operator|->
name|ocb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbp_ocb
argument_list|)
operator|*
name|SBP_QUEUE_LEN
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sdev
operator|->
name|free_ocbs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBP_QUEUE_LEN
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|ocb
operator|=
operator|&
name|sdev
operator|->
name|ocb
index|[
name|i
index|]
expr_stmt|;
name|ocb
operator|->
name|bus_addr
operator|=
name|sdev
operator|->
name|dma
operator|.
name|bus_addr
operator|+
name|SBP_LOGIN_SIZE
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sbp_ocb
argument_list|)
operator|*
name|i
operator|+
name|offsetof
argument_list|(
expr|struct
name|sbp_ocb
argument_list|,
name|orb
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sbp
operator|->
name|dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|ocb
operator|->
name|dmamap
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_attach: cannot create dmamap\n"
argument_list|)
expr_stmt|;
comment|/* XXX */
goto|goto
name|next
goto|;
block|}
name|sbp_free_ocb
argument_list|(
name|sdev
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
block|}
name|next
label|:
name|crom_next
argument_list|(
operator|&
name|cc
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<
name|target
operator|->
name|num_lun
condition|;
name|lun
operator|++
control|)
block|{
name|sdev
operator|=
name|target
operator|->
name|luns
index|[
name|lun
index|]
expr_stmt|;
if|if
condition|(
name|sdev
operator|!=
name|NULL
operator|&&
operator|(
name|sdev
operator|->
name|flags
operator|&
name|VALID_LUN
operator|)
operator|==
literal|0
condition|)
block|{
name|sbp_cam_detach_sdev
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
name|sbp_free_sdev
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
name|target
operator|->
name|luns
index|[
name|lun
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|sbp_target
modifier|*
name|sbp_alloc_target
parameter_list|(
name|struct
name|sbp_softc
modifier|*
name|sbp
parameter_list|,
name|struct
name|fw_device
modifier|*
name|fwdev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|struct
name|crom_context
name|cc
decl_stmt|;
name|struct
name|csrreg
modifier|*
name|reg
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"sbp_alloc_target\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|i
init|=
name|sbp_new_target
argument_list|(
name|sbp
argument_list|,
name|fwdev
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"increase SBP_NUM_TARGETS!\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* new target */
name|target
operator|=
operator|&
name|sbp
operator|->
name|targets
index|[
name|i
index|]
expr_stmt|;
name|target
operator|->
name|sbp
operator|=
name|sbp
expr_stmt|;
name|target
operator|->
name|fwdev
operator|=
name|fwdev
expr_stmt|;
name|target
operator|->
name|target_id
operator|=
name|i
expr_stmt|;
comment|/* XXX we may want to reload mgm port after each bus reset */
comment|/* XXX there might be multiple management agents */
name|crom_init_context
argument_list|(
operator|&
name|cc
argument_list|,
name|target
operator|->
name|fwdev
operator|->
name|csrrom
argument_list|)
expr_stmt|;
name|reg
operator|=
name|crom_search_key
argument_list|(
operator|&
name|cc
argument_list|,
name|CROM_MGM
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
operator|||
name|reg
operator|->
name|val
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"NULL management address\n"
argument_list|)
expr_stmt|;
name|target
operator|->
name|fwdev
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|target
operator|->
name|mgm_hi
operator|=
literal|0xffff
expr_stmt|;
name|target
operator|->
name|mgm_lo
operator|=
literal|0xf0000000
operator||
operator|(
name|reg
operator|->
name|val
operator|<<
literal|2
operator|)
expr_stmt|;
name|target
operator|->
name|mgm_ocb_cur
operator|=
name|NULL
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"target:%d mgm_port: %x\n"
argument_list|,
name|i
argument_list|,
name|target
operator|->
name|mgm_lo
argument_list|)
expr_stmt|;
name|END_DEBUG
name|STAILQ_INIT
argument_list|(
operator|&
name|target
operator|->
name|xferlist
argument_list|)
decl_stmt|;
name|target
operator|->
name|n_xfer
operator|=
literal|0
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|target
operator|->
name|mgm_ocb_queue
argument_list|)
expr_stmt|;
name|CALLOUT_INIT
argument_list|(
operator|&
name|target
operator|->
name|mgm_ocb_timeout
argument_list|)
expr_stmt|;
name|CALLOUT_INIT
argument_list|(
operator|&
name|target
operator|->
name|scan_callout
argument_list|)
expr_stmt|;
name|target
operator|->
name|luns
operator|=
name|NULL
expr_stmt|;
name|target
operator|->
name|num_lun
operator|=
literal|0
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_probe_lun
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|struct
name|fw_device
modifier|*
name|fwdev
decl_stmt|;
name|struct
name|crom_context
name|c
decl_stmt|,
modifier|*
name|cc
init|=
operator|&
name|c
decl_stmt|;
name|struct
name|csrreg
modifier|*
name|reg
decl_stmt|;
name|bzero
argument_list|(
name|sdev
operator|->
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|sdev
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sdev
operator|->
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|sdev
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|fwdev
operator|=
name|sdev
operator|->
name|target
operator|->
name|fwdev
expr_stmt|;
name|crom_init_context
argument_list|(
name|cc
argument_list|,
name|fwdev
operator|->
name|csrrom
argument_list|)
expr_stmt|;
comment|/* get vendor string */
name|crom_search_key
argument_list|(
name|cc
argument_list|,
name|CSRKEY_VENDOR
argument_list|)
expr_stmt|;
name|crom_next
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|crom_parse_text
argument_list|(
name|cc
argument_list|,
name|sdev
operator|->
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|sdev
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
comment|/* skip to the unit directory for SBP-2 */
while|while
condition|(
operator|(
name|reg
operator|=
name|crom_search_key
argument_list|(
name|cc
argument_list|,
name|CSRKEY_VER
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|reg
operator|->
name|val
operator|==
name|CSRVAL_T10SBP2
condition|)
break|break;
name|crom_next
argument_list|(
name|cc
argument_list|)
expr_stmt|;
block|}
comment|/* get firmware revision */
name|reg
operator|=
name|crom_search_key
argument_list|(
name|cc
argument_list|,
name|CSRKEY_FIRM_VER
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|NULL
condition|)
name|snprintf
argument_list|(
name|sdev
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|sdev
operator|->
name|revision
argument_list|)
argument_list|,
literal|"%06x"
argument_list|,
name|reg
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/* get product string */
name|crom_search_key
argument_list|(
name|cc
argument_list|,
name|CSRKEY_MODEL
argument_list|)
expr_stmt|;
name|crom_next
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|crom_parse_text
argument_list|(
name|cc
argument_list|,
name|sdev
operator|->
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|sdev
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_login_callout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
init|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|arg
decl_stmt|;
name|sbp_mgm_orb
argument_list|(
name|sdev
argument_list|,
name|ORB_FUN_LGI
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_login
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|struct
name|timeval
name|delta
decl_stmt|;
name|struct
name|timeval
name|t
decl_stmt|;
name|int
name|ticks
init|=
literal|0
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|delta
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|last_busreset
argument_list|)
expr_stmt|;
name|t
operator|.
name|tv_sec
operator|=
name|login_delay
operator|/
literal|1000
expr_stmt|;
name|t
operator|.
name|tv_usec
operator|=
operator|(
name|login_delay
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|tv_sec
operator|>=
literal|0
operator|&&
name|t
operator|.
name|tv_usec
operator|>
literal|0
condition|)
name|ticks
operator|=
operator|(
name|t
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
name|t
operator|.
name|tv_usec
operator|/
literal|1000
operator|)
operator|*
name|hz
operator|/
literal|1000
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"%s: sec = %jd usec = %ld ticks = %d\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|intmax_t
operator|)
name|t
operator|.
name|tv_sec
argument_list|,
name|t
operator|.
name|tv_usec
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
name|END_DEBUG
name|callout_reset
argument_list|(
operator|&
name|sdev
operator|->
name|login_callout
argument_list|,
name|ticks
argument_list|,
name|sbp_login_callout
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|sdev
operator|)
argument_list|)
decl_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SBP_FWDEV_ALIVE
parameter_list|(
name|fwdev
parameter_list|)
value|(((fwdev)->status == FWDEVATTACHED) \&& crom_has_specver((fwdev)->csrrom, CSRVAL_ANSIT10, CSRVAL_T10SBP2))
end_define

begin_function
specifier|static
name|void
name|sbp_probe_target
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sbp_target
modifier|*
name|target
init|=
operator|(
expr|struct
name|sbp_target
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|sbp_softc
modifier|*
name|sbp
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|alive
decl_stmt|;
name|alive
operator|=
name|SBP_FWDEV_ALIVE
argument_list|(
name|target
operator|->
name|fwdev
argument_list|)
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"sbp_probe_target %d\n"
argument_list|,
name|target
operator|->
name|target_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alive
condition|)
name|printf
argument_list|(
literal|"not alive\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|sbp
init|=
name|target
operator|->
name|sbp
decl_stmt|;
name|fc
operator|=
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|fc
expr_stmt|;
name|sbp_alloc_lun
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|/* XXX untimeout mgm_ocb and dequeue */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|target
operator|->
name|num_lun
condition|;
name|i
operator|++
control|)
block|{
name|sdev
operator|=
name|target
operator|->
name|luns
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|alive
operator|&&
operator|(
name|sdev
operator|->
name|status
operator|!=
name|SBP_DEV_DEAD
operator|)
condition|)
block|{
if|if
condition|(
name|sdev
operator|->
name|path
operator|!=
name|NULL
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|freeze
operator|++
expr_stmt|;
block|}
name|sbp_probe_lun
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
operator|(
name|sdev
operator|->
name|status
operator|==
name|SBP_DEV_RESET
operator|)
argument_list|)
expr_stmt|;
name|END_DEBUG
name|sbp_abort_all_ocbs
argument_list|(
name|sdev
argument_list|,
name|CAM_SCSI_BUS_RESET
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sdev
operator|->
name|status
condition|)
block|{
case|case
name|SBP_DEV_RESET
case|:
comment|/* new or revived target */
if|if
condition|(
name|auto_login
condition|)
name|sbp_login
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
break|break;
case|case
name|SBP_DEV_TOATTACH
case|:
case|case
name|SBP_DEV_PROBE
case|:
case|case
name|SBP_DEV_ATTACHED
case|:
case|case
name|SBP_DEV_RETRY
case|:
default|default:
name|sbp_mgm_orb
argument_list|(
name|sdev
argument_list|,
name|ORB_FUN_RCN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|sdev
operator|->
name|status
condition|)
block|{
case|case
name|SBP_DEV_ATTACHED
case|:
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
comment|/* the device has gone */
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lost target\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|sdev
operator|->
name|path
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|freeze
operator|++
expr_stmt|;
block|}
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_RETRY
expr_stmt|;
name|sbp_abort_all_ocbs
argument_list|(
name|sdev
argument_list|,
name|CAM_SCSI_BUS_RESET
argument_list|)
expr_stmt|;
break|break;
case|case
name|SBP_DEV_PROBE
case|:
case|case
name|SBP_DEV_TOATTACH
case|:
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_RESET
expr_stmt|;
break|break;
case|case
name|SBP_DEV_RETRY
case|:
case|case
name|SBP_DEV_RESET
case|:
case|case
name|SBP_DEV_DEAD
case|:
break|break;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_post_busreset
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sbp_softc
modifier|*
name|sbp
decl_stmt|;
name|sbp
operator|=
operator|(
expr|struct
name|sbp_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"sbp_post_busreset\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
operator|(
name|sbp
operator|->
name|sim
operator|->
name|flags
operator|&
name|SIMQ_FREEZED
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|sbp
operator|->
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|sim
operator|->
name|flags
operator||=
name|SIMQ_FREEZED
expr_stmt|;
block|}
name|microtime
argument_list|(
operator|&
name|sbp
operator|->
name|last_busreset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_post_explore
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sbp_softc
modifier|*
name|sbp
init|=
operator|(
expr|struct
name|sbp_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|struct
name|fw_device
modifier|*
name|fwdev
decl_stmt|;
name|int
name|i
decl_stmt|,
name|alive
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"sbp_post_explore (sbp_cold=%d)\n"
argument_list|,
name|sbp_cold
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|sbp_cold
operator|>
literal|0
condition|)
name|sbp_cold
operator|--
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * XXX don't let CAM the bus rest. 	 * CAM tries to do something with freezed (DEV_RETRY) devices. 	 */
block|xpt_async(AC_BUS_RESET, sbp->path,
comment|/*arg*/
block|NULL);
endif|#
directive|endif
comment|/* Garbage Collection */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBP_NUM_TARGETS
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
operator|&
name|sbp
operator|->
name|targets
index|[
name|i
index|]
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|fwdev
argument_list|,
argument|&sbp->fd.fc->devices
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|target
operator|->
name|fwdev
operator|==
name|NULL
operator|||
name|target
operator|->
name|fwdev
operator|==
name|fwdev
condition|)
break|break;
if|if
condition|(
name|fwdev
operator|==
name|NULL
condition|)
block|{
comment|/* device has removed in lower driver */
name|sbp_cam_detach_target
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|sbp_free_target
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* traverse device list */
name|STAILQ_FOREACH
argument_list|(
argument|fwdev
argument_list|,
argument|&sbp->fd.fc->devices
argument_list|,
argument|link
argument_list|)
block|{
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"sbp_post_explore: EUI:%08x%08x "
argument_list|,
name|fwdev
operator|->
name|eui
operator|.
name|hi
argument_list|,
name|fwdev
operator|->
name|eui
operator|.
name|lo
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwdev
operator|->
name|status
operator|!=
name|FWDEVATTACHED
condition|)
name|printf
argument_list|(
literal|"not attached, state=%d.\n"
argument_list|,
name|fwdev
operator|->
name|status
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"attached\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|alive
init|=
name|SBP_FWDEV_ALIVE
argument_list|(
name|fwdev
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBP_NUM_TARGETS
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
operator|&
name|sbp
operator|->
name|targets
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|fwdev
operator|==
name|fwdev
condition|)
block|{
comment|/* known target */
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|SBP_NUM_TARGETS
condition|)
block|{
if|if
condition|(
name|alive
condition|)
block|{
comment|/* new target */
name|target
operator|=
name|sbp_alloc_target
argument_list|(
name|sbp
argument_list|,
name|fwdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
continue|continue;
block|}
else|else
block|{
continue|continue;
block|}
block|}
name|sbp_probe_target
argument_list|(
operator|(
name|void
operator|*
operator|)
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|num_lun
operator|==
literal|0
condition|)
name|sbp_free_target
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
name|xpt_release_simq
argument_list|(
name|sbp
operator|->
name|sim
argument_list|,
comment|/*run queue*/
name|TRUE
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|sim
operator|->
name|flags
operator|&=
operator|~
name|SIMQ_FREEZED
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NEED_RESPONSE
end_if

begin_function
specifier|static
name|void
name|sbp_loginres_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_loginres_callback\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
comment|/* recycle */
name|s
init|=
name|splfw
argument_list|()
decl_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fwb
operator|.
name|xferlist
argument_list|,
name|xfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|__inline
name|void
name|sbp_xfer_free
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|int
name|s
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|fw_xfer_unload
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sdev
operator|->
name|target
operator|->
name|xferlist
argument_list|,
name|xfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_reset_start_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|tsdev
decl_stmt|,
modifier|*
name|sdev
init|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
init|=
name|sdev
operator|->
name|target
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|xfer
operator|->
name|resp
operator|!=
literal|0
condition|)
block|{
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_reset_start failed: resp=%d\n"
argument_list|,
name|xfer
operator|->
name|resp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|target
operator|->
name|num_lun
condition|;
name|i
operator|++
control|)
block|{
name|tsdev
operator|=
name|target
operator|->
name|luns
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|tsdev
operator|!=
name|NULL
operator|&&
name|tsdev
operator|->
name|status
operator|==
name|SBP_DEV_LOGIN
condition|)
name|sbp_login
argument_list|(
name|tsdev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_reset_start
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_reset_start\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|xfer
init|=
name|sbp_write_cmd
argument_list|(
name|sdev
argument_list|,
name|FWTCODE_WREQQ
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|xfer
operator|->
name|hand
operator|=
name|sbp_reset_start_callback
expr_stmt|;
name|fp
operator|=
operator|&
name|xfer
operator|->
name|send
operator|.
name|hdr
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|dest_hi
operator|=
literal|0xffff
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|dest_lo
operator|=
literal|0xf0000000
operator||
name|RESET_START
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|data
operator|=
name|htonl
argument_list|(
literal|0xf
argument_list|)
expr_stmt|;
name|fw_asyreq
argument_list|(
name|xfer
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_mgm_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|int
name|resp
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_mgm_callback\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|resp
init|=
name|xfer
operator|->
name|resp
decl_stmt|;
name|sbp_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (resp != 0) { 		sbp_show_sdev_info(sdev, 2); 		printf("management ORB failed(%d) ... RESET_START\n", resp); 		sbp_reset_start(sdev); 	}
endif|#
directive|endif
return|return;
block|}
end_function

begin_function
specifier|static
name|struct
name|sbp_dev
modifier|*
name|sbp_next_dev
parameter_list|(
name|struct
name|sbp_target
modifier|*
name|target
parameter_list|,
name|int
name|lun
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
modifier|*
name|sdevp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|lun
operator|,
name|sdevp
operator|=
operator|&
name|target
operator|->
name|luns
index|[
name|lun
index|]
init|;
name|i
operator|<
name|target
operator|->
name|num_lun
condition|;
name|i
operator|++
operator|,
name|sdevp
operator|++
control|)
if|if
condition|(
operator|*
name|sdevp
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|sdevp
operator|)
operator|->
name|status
operator|==
name|SBP_DEV_PROBE
condition|)
return|return
operator|(
operator|*
name|sdevp
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SCAN_PRI
value|1
end_define

begin_function
specifier|static
name|void
name|sbp_cam_scan_lun
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_sdev_ptr
expr_stmt|;
name|target
operator|=
name|sdev
operator|->
name|target
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_cam_scan_lun\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_ATTACHED
expr_stmt|;
block|}
else|else
block|{
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"scan failed\n"
argument_list|)
expr_stmt|;
block|}
name|sdev
operator|=
name|sbp_next_dev
argument_list|(
name|target
argument_list|,
name|sdev
operator|->
name|lun_id
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ccb
argument_list|,
name|M_SBP
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* reuse ccb */
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sdev
operator|->
name|path
argument_list|,
name|SCAN_PRI
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_sdev_ptr
operator|=
name|sdev
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|xpt_release_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
name|sdev
operator|->
name|freeze
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|freeze
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_cam_scan_target
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sbp_target
modifier|*
name|target
init|=
operator|(
expr|struct
name|sbp_target
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|sdev
operator|=
name|sbp_next_dev
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_cam_scan_target: nothing to do for target%d\n"
argument_list|,
name|target
operator|->
name|target_id
argument_list|)
expr_stmt|;
return|return;
block|}
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_cam_scan_target\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|ccb
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|,
name|M_SBP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
decl_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_cam_scan_target: malloc failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sdev
operator|->
name|path
argument_list|,
name|SCAN_PRI
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_LUN
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|sbp_cam_scan_lun
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFREEZE
expr_stmt|;
name|ccb
operator|->
name|crcn
operator|.
name|flags
operator|=
name|CAM_FLAG_NONE
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_sdev_ptr
operator|=
name|sdev
expr_stmt|;
comment|/* The scan is in progress now. */
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|xpt_release_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
name|sdev
operator|->
name|freeze
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|freeze
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|sbp_scan_dev
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_PROBE
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sdev
operator|->
name|target
operator|->
name|scan_callout
argument_list|,
name|scan_delay
operator|*
name|hz
operator|/
literal|1000
argument_list|,
name|sbp_cam_scan_target
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sdev
operator|->
name|target
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_do_attach
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|struct
name|sbp_softc
modifier|*
name|sbp
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|target
operator|=
name|sdev
operator|->
name|target
expr_stmt|;
name|sbp
operator|=
name|target
operator|->
name|sbp
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_do_attach\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|sbp_xfer_free
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
if|if
condition|(
name|sdev
operator|->
name|path
operator|==
name|NULL
condition|)
name|xpt_create_path
argument_list|(
operator|&
name|sdev
operator|->
name|path
argument_list|,
name|xpt_periph
argument_list|,
name|cam_sim_path
argument_list|(
name|target
operator|->
name|sbp
operator|->
name|sim
argument_list|)
argument_list|,
name|target
operator|->
name|target_id
argument_list|,
name|sdev
operator|->
name|lun_id
argument_list|)
expr_stmt|;
comment|/* 	 * Let CAM scan the bus if we are in the boot process. 	 * XXX xpt_scan_bus cannot detect LUN larger than 0 	 * if LUN 0 doesn't exists. 	 */
if|if
condition|(
name|sbp_cold
operator|>
literal|0
condition|)
block|{
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_ATTACHED
expr_stmt|;
return|return;
block|}
name|sbp_scan_dev
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_agent_reset_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|xfer
operator|->
name|resp
operator|!=
literal|0
condition|)
block|{
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: resp=%d\n"
argument_list|,
name|__func__
argument_list|,
name|xfer
operator|->
name|resp
argument_list|)
expr_stmt|;
block|}
name|sbp_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdev
operator|->
name|path
condition|)
block|{
name|xpt_release_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
name|sdev
operator|->
name|freeze
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|freeze
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_agent_reset
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_agent_reset\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|xfer
init|=
name|sbp_write_cmd
argument_list|(
name|sdev
argument_list|,
name|FWTCODE_WREQQ
argument_list|,
literal|0x04
argument_list|)
decl_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|sdev
operator|->
name|status
operator|==
name|SBP_DEV_ATTACHED
operator|||
name|sdev
operator|->
name|status
operator|==
name|SBP_DEV_PROBE
condition|)
name|xfer
operator|->
name|hand
operator|=
name|sbp_agent_reset_callback
expr_stmt|;
else|else
name|xfer
operator|->
name|hand
operator|=
name|sbp_do_attach
expr_stmt|;
name|fp
operator|=
operator|&
name|xfer
operator|->
name|send
operator|.
name|hdr
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|data
operator|=
name|htonl
argument_list|(
literal|0xf
argument_list|)
expr_stmt|;
name|fw_asyreq
argument_list|(
name|xfer
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|sbp_abort_all_ocbs
argument_list|(
name|sdev
argument_list|,
name|CAM_BDR_SENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_busy_timeout_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_busy_timeout_callback\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|sbp_xfer_free
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|sbp_agent_reset
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_busy_timeout
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_busy_timeout\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|xfer
init|=
name|sbp_write_cmd
argument_list|(
name|sdev
argument_list|,
name|FWTCODE_WREQQ
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|xfer
operator|->
name|hand
operator|=
name|sbp_busy_timeout_callback
expr_stmt|;
name|fp
operator|=
operator|&
name|xfer
operator|->
name|send
operator|.
name|hdr
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|dest_hi
operator|=
literal|0xffff
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|dest_lo
operator|=
literal|0xf0000000
operator||
name|BUSY_TIMEOUT
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|data
operator|=
name|htonl
argument_list|(
operator|(
literal|1
operator|<<
operator|(
literal|13
operator|+
literal|12
operator|)
operator|)
operator||
literal|0xf
argument_list|)
expr_stmt|;
name|fw_asyreq
argument_list|(
name|xfer
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_orb_pointer_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|xfer
operator|->
name|resp
operator|!=
literal|0
condition|)
block|{
comment|/* XXX */
name|printf
argument_list|(
literal|"%s: xfer->resp = %d\n"
argument_list|,
name|__func__
argument_list|,
name|xfer
operator|->
name|resp
argument_list|)
expr_stmt|;
block|}
name|sbp_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|flags
operator|&=
operator|~
name|ORB_POINTER_ACTIVE
expr_stmt|;
if|if
condition|(
operator|(
name|sdev
operator|->
name|flags
operator|&
name|ORB_POINTER_NEED
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|sdev
operator|->
name|flags
operator|&=
operator|~
name|ORB_POINTER_NEED
expr_stmt|;
name|ocb
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sdev
operator|->
name|ocbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ocb
operator|!=
name|NULL
condition|)
name|sbp_orb_pointer
argument_list|(
name|sdev
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_orb_pointer
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|,
name|struct
name|sbp_ocb
modifier|*
name|ocb
parameter_list|)
block|{
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uint32_t
operator|)
name|ocb
operator|->
name|bus_addr
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
operator|(
name|sdev
operator|->
name|flags
operator|&
name|ORB_POINTER_ACTIVE
operator|)
operator|!=
literal|0
condition|)
block|{
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"%s: orb pointer active\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|END_DEBUG
name|sdev
operator|->
name|flags
operator||=
name|ORB_POINTER_NEED
expr_stmt|;
return|return;
block|}
name|sdev
operator|->
name|flags
operator||=
name|ORB_POINTER_ACTIVE
expr_stmt|;
name|xfer
operator|=
name|sbp_write_cmd
argument_list|(
name|sdev
argument_list|,
name|FWTCODE_WREQB
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
return|return;
name|xfer
operator|->
name|hand
operator|=
name|sbp_orb_pointer_callback
expr_stmt|;
name|fp
operator|=
operator|&
name|xfer
operator|->
name|send
operator|.
name|hdr
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|len
operator|=
literal|8
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|extcode
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|send
operator|.
name|payload
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
operator|(
operator|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|fc
operator|->
name|nodeid
operator||
name|FWLOCALBUS
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|send
operator|.
name|payload
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
operator|(
name|uint32_t
operator|)
name|ocb
operator|->
name|bus_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_asyreq
argument_list|(
name|xfer
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sbp_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ocb
operator|->
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_doorbell_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_doorbell_callback\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|xfer
operator|->
name|resp
operator|!=
literal|0
condition|)
block|{
comment|/* XXX */
name|printf
argument_list|(
literal|"%s: xfer->resp = %d\n"
argument_list|,
name|__func__
argument_list|,
name|xfer
operator|->
name|resp
argument_list|)
expr_stmt|;
block|}
name|sbp_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|flags
operator|&=
operator|~
name|ORB_DOORBELL_ACTIVE
expr_stmt|;
if|if
condition|(
operator|(
name|sdev
operator|->
name|flags
operator|&
name|ORB_DOORBELL_NEED
operator|)
operator|!=
literal|0
condition|)
block|{
name|sdev
operator|->
name|flags
operator|&=
operator|~
name|ORB_DOORBELL_NEED
expr_stmt|;
name|sbp_doorbell
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_doorbell
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_doorbell\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
operator|(
name|sdev
operator|->
name|flags
operator|&
name|ORB_DOORBELL_ACTIVE
operator|)
operator|!=
literal|0
condition|)
block|{
name|sdev
operator|->
name|flags
operator||=
name|ORB_DOORBELL_NEED
expr_stmt|;
return|return;
block|}
name|sdev
operator|->
name|flags
operator||=
name|ORB_DOORBELL_ACTIVE
expr_stmt|;
name|xfer
operator|=
name|sbp_write_cmd
argument_list|(
name|sdev
argument_list|,
name|FWTCODE_WREQQ
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
return|return;
name|xfer
operator|->
name|hand
operator|=
name|sbp_doorbell_callback
expr_stmt|;
name|fp
operator|=
operator|&
name|xfer
operator|->
name|send
operator|.
name|hdr
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|data
operator|=
name|htonl
argument_list|(
literal|0xf
argument_list|)
expr_stmt|;
name|fw_asyreq
argument_list|(
name|xfer
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|fw_xfer
modifier|*
name|sbp_write_cmd
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|,
name|int
name|tcode
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|int
name|s
decl_stmt|,
name|new
init|=
literal|0
decl_stmt|;
name|target
operator|=
name|sdev
operator|->
name|target
expr_stmt|;
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|xfer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|target
operator|->
name|xferlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|target
operator|->
name|n_xfer
operator|>
literal|5
comment|/* XXX */
condition|)
block|{
name|printf
argument_list|(
literal|"sbp: no more xfer for this target\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|xfer
operator|=
name|fw_xfer_alloc_buf
argument_list|(
name|M_SBP
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sbp: fw_xfer_alloc_buf failed\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|target
operator|->
name|n_xfer
operator|++
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"sbp: alloc %d xfer\n"
argument_list|,
name|target
operator|->
name|n_xfer
argument_list|)
expr_stmt|;
name|new
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|target
operator|->
name|xferlist
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|xfer
operator|->
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|xfer
operator|->
name|recv
operator|.
name|pay_len
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|send
operator|.
name|spd
operator|=
name|min
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|fwdev
operator|->
name|speed
argument_list|,
name|max_speed
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|fc
operator|=
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|fc
expr_stmt|;
block|}
if|if
condition|(
name|tcode
operator|==
name|FWTCODE_WREQB
condition|)
name|xfer
operator|->
name|send
operator|.
name|pay_len
operator|=
literal|8
expr_stmt|;
else|else
name|xfer
operator|->
name|send
operator|.
name|pay_len
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|sc
operator|=
operator|(
name|caddr_t
operator|)
name|sdev
expr_stmt|;
name|fp
operator|=
operator|&
name|xfer
operator|->
name|send
operator|.
name|hdr
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|dest_hi
operator|=
name|sdev
operator|->
name|login
operator|->
name|cmd_hi
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|dest_lo
operator|=
name|sdev
operator|->
name|login
operator|->
name|cmd_lo
operator|+
name|offset
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|tlrt
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|tcode
operator|=
name|tcode
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|pri
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|dst
operator|=
name|FWLOCALBUS
operator||
name|sdev
operator|->
name|target
operator|->
name|fwdev
operator|->
name|dst
expr_stmt|;
return|return
name|xfer
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_mgm_orb
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|,
name|int
name|func
parameter_list|,
name|struct
name|sbp_ocb
modifier|*
name|aocb
parameter_list|)
block|{
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|int
name|s
decl_stmt|,
name|nid
decl_stmt|;
name|target
operator|=
name|sdev
operator|->
name|target
expr_stmt|;
name|nid
operator|=
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|fc
operator|->
name|nodeid
operator||
name|FWLOCALBUS
expr_stmt|;
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|ORB_FUN_RUNQUEUE
condition|)
block|{
name|ocb
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|target
operator|->
name|mgm_ocb_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|mgm_ocb_cur
operator|!=
name|NULL
operator|||
name|ocb
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|target
operator|->
name|mgm_ocb_queue
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
goto|goto
name|start
goto|;
block|}
if|if
condition|(
operator|(
name|ocb
operator|=
name|sbp_get_ocb
argument_list|(
name|sdev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return;
block|}
name|ocb
operator|->
name|flags
operator|=
name|OCB_ACT_MGM
expr_stmt|;
name|ocb
operator|->
name|sdev
operator|=
name|sdev
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ocb
operator|->
name|orb
argument_list|,
sizeof|sizeof
argument_list|(
name|ocb
operator|->
name|orb
argument_list|)
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|6
index|]
operator|=
name|htonl
argument_list|(
operator|(
name|nid
operator|<<
literal|16
operator|)
operator||
name|SBP_BIND_HI
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|7
index|]
operator|=
name|htonl
argument_list|(
name|SBP_DEV2ADDR
argument_list|(
name|target
operator|->
name|target_id
argument_list|,
name|sdev
operator|->
name|lun_id
argument_list|)
argument_list|)
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|orb_fun_name
index|[
operator|(
name|func
operator|>>
literal|16
operator|)
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
name|END_DEBUG
switch|switch
condition|(
name|func
condition|)
block|{
case|case
name|ORB_FUN_LGI
case|:
name|ocb
operator|->
name|orb
index|[
literal|0
index|]
operator|=
name|ocb
operator|->
name|orb
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* password */
name|ocb
operator|->
name|orb
index|[
literal|2
index|]
operator|=
name|htonl
argument_list|(
name|nid
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|3
index|]
operator|=
name|htonl
argument_list|(
name|sdev
operator|->
name|dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
operator|=
name|htonl
argument_list|(
name|ORB_NOTIFY
operator||
name|sdev
operator|->
name|lun_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex_login
condition|)
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
operator||=
name|htonl
argument_list|(
name|ORB_EXV
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|5
index|]
operator|=
name|htonl
argument_list|(
name|SBP_LOGIN_SIZE
argument_list|)
expr_stmt|;
name|fwdma_sync
argument_list|(
operator|&
name|sdev
operator|->
name|dma
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORB_FUN_ATA
case|:
name|ocb
operator|->
name|orb
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
operator|(
literal|0
operator|<<
literal|16
operator|)
operator||
literal|0
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
name|aocb
operator|->
name|bus_addr
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|ORB_FUN_RCN
case|:
case|case
name|ORB_FUN_LGO
case|:
case|case
name|ORB_FUN_LUR
case|:
case|case
name|ORB_FUN_RST
case|:
case|case
name|ORB_FUN_ATS
case|:
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
operator|=
name|htonl
argument_list|(
name|ORB_NOTIFY
operator||
name|func
operator||
name|sdev
operator|->
name|login
operator|->
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|target
operator|->
name|mgm_ocb_cur
operator|!=
name|NULL
condition|)
block|{
comment|/* there is a standing ORB */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sdev
operator|->
name|target
operator|->
name|mgm_ocb_queue
argument_list|,
name|ocb
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|start
label|:
name|target
operator|->
name|mgm_ocb_cur
operator|=
name|ocb
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|target
operator|->
name|mgm_ocb_timeout
argument_list|,
literal|5
operator|*
name|hz
argument_list|,
name|sbp_mgm_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ocb
argument_list|)
expr_stmt|;
name|xfer
operator|=
name|sbp_write_cmd
argument_list|(
name|sdev
argument_list|,
name|FWTCODE_WREQB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|xfer
operator|->
name|hand
operator|=
name|sbp_mgm_callback
expr_stmt|;
name|fp
operator|=
operator|&
name|xfer
operator|->
name|send
operator|.
name|hdr
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|dest_hi
operator|=
name|sdev
operator|->
name|target
operator|->
name|mgm_hi
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|dest_lo
operator|=
name|sdev
operator|->
name|target
operator|->
name|mgm_lo
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|len
operator|=
literal|8
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|extcode
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|send
operator|.
name|payload
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
name|nid
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|send
operator|.
name|payload
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
name|ocb
operator|->
name|bus_addr
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mgm orb: %08x\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|ocb
operator|->
name|bus_addr
argument_list|)
expr_stmt|;
name|END_DEBUG
name|fw_asyreq
argument_list|(
name|xfer
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_print_scsi_cmd
parameter_list|(
name|struct
name|sbp_ocb
modifier|*
name|ocb
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|csio
operator|=
operator|&
name|ocb
operator|->
name|ccb
operator|->
name|csio
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%d:%d XPT_SCSI_IO: "
literal|"cmd: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x"
literal|", flags: 0x%02x, "
literal|"%db cmd/%db data/%db sense\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|ocb
operator|->
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|1
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|2
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|3
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|4
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|5
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|6
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|7
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|8
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|9
index|]
argument_list|,
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|csio
operator|->
name|sense_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_scsi_status
parameter_list|(
name|struct
name|sbp_status
modifier|*
name|sbp_status
parameter_list|,
name|struct
name|sbp_ocb
modifier|*
name|ocb
parameter_list|)
block|{
name|struct
name|sbp_cmd_status
modifier|*
name|sbp_cmd_status
decl_stmt|;
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|sbp_cmd_status
operator|=
operator|(
expr|struct
name|sbp_cmd_status
operator|*
operator|)
name|sbp_status
operator|->
name|data
expr_stmt|;
name|sense
operator|=
operator|&
name|ocb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_print_scsi_cmd
argument_list|(
name|ocb
argument_list|)
expr_stmt|;
comment|/* XXX need decode status */
name|sbp_show_sdev_info
argument_list|(
name|ocb
operator|->
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSI status %x sfmt %x valid %x key %x code %x qlfr %x len %d\n"
argument_list|,
name|sbp_cmd_status
operator|->
name|status
argument_list|,
name|sbp_cmd_status
operator|->
name|sfmt
argument_list|,
name|sbp_cmd_status
operator|->
name|valid
argument_list|,
name|sbp_cmd_status
operator|->
name|s_key
argument_list|,
name|sbp_cmd_status
operator|->
name|s_code
argument_list|,
name|sbp_cmd_status
operator|->
name|s_qlfr
argument_list|,
name|sbp_status
operator|->
name|len
argument_list|)
expr_stmt|;
name|END_DEBUG
switch|switch
condition|(
name|sbp_cmd_status
operator|->
name|status
condition|)
block|{
case|case
name|SCSI_STATUS_CHECK_COND
case|:
case|case
name|SCSI_STATUS_BUSY
case|:
case|case
name|SCSI_STATUS_CMD_TERMINATED
case|:
if|if
condition|(
name|sbp_cmd_status
operator|->
name|sfmt
operator|==
name|SBP_SFMT_CURR
condition|)
block|{
name|sense
operator|->
name|error_code
operator|=
name|SSD_CURRENT_ERROR
expr_stmt|;
block|}
else|else
block|{
name|sense
operator|->
name|error_code
operator|=
name|SSD_DEFERRED_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|sbp_cmd_status
operator|->
name|valid
condition|)
name|sense
operator|->
name|error_code
operator||=
name|SSD_ERRCODE_VALID
expr_stmt|;
name|sense
operator|->
name|flags
operator|=
name|sbp_cmd_status
operator|->
name|s_key
expr_stmt|;
if|if
condition|(
name|sbp_cmd_status
operator|->
name|mark
condition|)
name|sense
operator|->
name|flags
operator||=
name|SSD_FILEMARK
expr_stmt|;
if|if
condition|(
name|sbp_cmd_status
operator|->
name|eom
condition|)
name|sense
operator|->
name|flags
operator||=
name|SSD_EOM
expr_stmt|;
if|if
condition|(
name|sbp_cmd_status
operator|->
name|ill_len
condition|)
name|sense
operator|->
name|flags
operator||=
name|SSD_ILI
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sbp_cmd_status
operator|->
name|info
argument_list|,
operator|&
name|sense
operator|->
name|info
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbp_status
operator|->
name|len
operator|<=
literal|1
condition|)
comment|/* XXX not scsi status. shouldn't be happened */
name|sense
operator|->
name|extra_len
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sbp_status
operator|->
name|len
operator|<=
literal|4
condition|)
comment|/* add_sense_code(_qual), info, cmd_spec_info */
name|sense
operator|->
name|extra_len
operator|=
literal|6
expr_stmt|;
else|else
comment|/* fru, sense_key_spec */
name|sense
operator|->
name|extra_len
operator|=
literal|10
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sbp_cmd_status
operator|->
name|cdb
argument_list|,
operator|&
name|sense
operator|->
name|cmd_spec_info
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sense
operator|->
name|add_sense_code
operator|=
name|sbp_cmd_status
operator|->
name|s_code
expr_stmt|;
name|sense
operator|->
name|add_sense_code_qual
operator|=
name|sbp_cmd_status
operator|->
name|s_qlfr
expr_stmt|;
name|sense
operator|->
name|fru
operator|=
name|sbp_cmd_status
operator|->
name|fru
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sbp_cmd_status
operator|->
name|s_keydep
index|[
literal|0
index|]
argument_list|,
operator|&
name|sense
operator|->
name|sense_key_spec
index|[
literal|0
index|]
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|sbp_cmd_status
operator|->
name|status
expr_stmt|;
empty_stmt|;
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
operator||
name|CAM_AUTOSNS_VALID
expr_stmt|;
comment|/* { 		uint8_t j, *tmp; 		tmp = sense; 		for( j = 0 ; j< 32 ; j+=8){ 			printf("sense %02x%02x %02x%02x %02x%02x %02x%02x\n",  				tmp[j], tmp[j+1], tmp[j+2], tmp[j+3], 				tmp[j+4], tmp[j+5], tmp[j+6], tmp[j+7]); 		}  } */
break|break;
default|default:
name|sbp_show_sdev_info
argument_list|(
name|ocb
operator|->
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_scsi_status: unknown scsi status 0x%x\n"
argument_list|,
name|sbp_cmd_status
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_fix_inq_data
parameter_list|(
name|struct
name|sbp_ocb
modifier|*
name|ocb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq
decl_stmt|;
name|ccb
operator|=
name|ocb
operator|->
name|ccb
expr_stmt|;
name|sdev
operator|=
name|ocb
operator|->
name|sdev
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|1
index|]
operator|&
name|SI_EVPD
condition|)
return|return;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_fix_inq_data\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|inq
init|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
decl_stmt|;
switch|switch
condition|(
name|SID_TYPE
argument_list|(
name|inq
argument_list|)
condition|)
block|{
case|case
name|T_DIRECT
case|:
if|#
directive|if
literal|0
comment|/*  		 * XXX Convert Direct Access device to RBC. 		 * I've never seen FireWire DA devices which support READ_6. 		 */
block|if (SID_TYPE(inq) == T_DIRECT) 			inq->device |= T_RBC;
comment|/*  T_DIRECT == 0 */
endif|#
directive|endif
comment|/* fall through */
case|case
name|T_RBC
case|:
comment|/* 		 * Override vendor/product/revision information. 		 * Some devices sometimes return strange strings. 		 */
if|#
directive|if
literal|1
name|bcopy
argument_list|(
name|sdev
operator|->
name|vendor
argument_list|,
name|inq
operator|->
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sdev
operator|->
name|product
argument_list|,
name|inq
operator|->
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sdev
operator|->
name|revision
operator|+
literal|2
argument_list|,
name|inq
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
comment|/* 	 * Force to enable/disable tagged queuing. 	 * XXX CAM also checks SCP_QUEUE_DQUE flag in the control mode page. 	 */
if|if
condition|(
name|sbp_tags
operator|>
literal|0
condition|)
name|inq
operator|->
name|flags
operator||=
name|SID_CmdQue
expr_stmt|;
elseif|else
if|if
condition|(
name|sbp_tags
operator|<
literal|0
condition|)
name|inq
operator|->
name|flags
operator|&=
operator|~
name|SID_CmdQue
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_recv1
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|fw_pkt
modifier|*
name|rfp
decl_stmt|;
if|#
directive|if
name|NEED_RESPONSE
name|struct
name|fw_pkt
modifier|*
name|sfp
decl_stmt|;
endif|#
directive|endif
name|struct
name|sbp_softc
modifier|*
name|sbp
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|struct
name|sbp_login_res
modifier|*
name|login_res
init|=
name|NULL
decl_stmt|;
name|struct
name|sbp_status
modifier|*
name|sbp_status
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|int
name|orb_fun
decl_stmt|,
name|status_valid0
decl_stmt|,
name|status_valid
decl_stmt|,
name|t
decl_stmt|,
name|l
decl_stmt|,
name|reset_agent
init|=
literal|0
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|;
comment|/* 	uint32_t *ld; 	ld = xfer->recv.buf; printf("sbp %x %d %d %08x %08x %08x %08x\n", 			xfer->resp, xfer->recv.len, xfer->recv.off, ntohl(ld[0]), ntohl(ld[1]), ntohl(ld[2]), ntohl(ld[3])); printf("sbp %08x %08x %08x %08x\n", ntohl(ld[4]), ntohl(ld[5]), ntohl(ld[6]), ntohl(ld[7])); printf("sbp %08x %08x %08x %08x\n", ntohl(ld[8]), ntohl(ld[9]), ntohl(ld[10]), ntohl(ld[11])); */
name|sbp
operator|=
operator|(
expr|struct
name|sbp_softc
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|resp
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_recv: xfer->resp = %d\n"
argument_list|,
name|xfer
operator|->
name|resp
argument_list|)
expr_stmt|;
goto|goto
name|done0
goto|;
block|}
if|if
condition|(
name|xfer
operator|->
name|recv
operator|.
name|payload
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_recv: xfer->recv.payload == NULL\n"
argument_list|)
expr_stmt|;
goto|goto
name|done0
goto|;
block|}
name|rfp
operator|=
operator|&
name|xfer
operator|->
name|recv
operator|.
name|hdr
expr_stmt|;
if|if
condition|(
name|rfp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|tcode
operator|!=
name|FWTCODE_WREQB
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_recv: tcode = %d\n"
argument_list|,
name|rfp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|tcode
argument_list|)
expr_stmt|;
goto|goto
name|done0
goto|;
block|}
name|sbp_status
operator|=
operator|(
expr|struct
name|sbp_status
operator|*
operator|)
name|xfer
operator|->
name|recv
operator|.
name|payload
expr_stmt|;
name|addr
operator|=
name|rfp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|dest_lo
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|2
argument_list|)
name|printf
argument_list|(
literal|"received address 0x%x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|END_DEBUG
name|t
init|=
name|SBP_ADDR2TRG
argument_list|(
name|addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|>=
name|SBP_NUM_TARGETS
condition|)
block|{
name|device_printf
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"sbp_recv1: invalid target %d\n"
argument_list|,
name|t
argument_list|)
expr_stmt|;
goto|goto
name|done0
goto|;
block|}
name|target
operator|=
operator|&
name|sbp
operator|->
name|targets
index|[
name|t
index|]
expr_stmt|;
name|l
operator|=
name|SBP_ADDR2LUN
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>=
name|target
operator|->
name|num_lun
operator|||
name|target
operator|->
name|luns
index|[
name|l
index|]
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|,
literal|"sbp_recv1: invalid lun %d (target=%d)\n"
argument_list|,
name|l
argument_list|,
name|t
argument_list|)
expr_stmt|;
goto|goto
name|done0
goto|;
block|}
name|sdev
operator|=
name|target
operator|->
name|luns
index|[
name|l
index|]
expr_stmt|;
name|ocb
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|sbp_status
operator|->
name|src
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
comment|/* check mgm_ocb_cur first */
name|ocb
operator|=
name|target
operator|->
name|mgm_ocb_cur
expr_stmt|;
if|if
condition|(
name|ocb
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|OCB_MATCH
argument_list|(
name|ocb
argument_list|,
name|sbp_status
argument_list|)
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|target
operator|->
name|mgm_ocb_timeout
argument_list|)
expr_stmt|;
name|target
operator|->
name|mgm_ocb_cur
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
name|ocb
operator|=
name|sbp_dequeue_ocb
argument_list|(
name|sdev
argument_list|,
name|sbp_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ocb
operator|==
name|NULL
condition|)
block|{
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
name|printf
argument_list|(
literal|"No ocb(%lx) on the queue\n"
argument_list|,
else|#
directive|else
argument|printf(
literal|"No ocb(%x) on the queue\n"
argument|,
endif|#
directive|endif
argument|ntohl(sbp_status->orb_lo)); 		} 		break; 	case
literal|2
argument|:
comment|/* unsolicit */
argument|sbp_show_sdev_info(sdev,
literal|2
argument|); 		printf(
literal|"unsolicit status received\n"
argument|); 		break; 	default: 		sbp_show_sdev_info(sdev,
literal|2
argument|); 		printf(
literal|"unknown sbp_status->src\n"
argument|); 	}  	status_valid0 = (sbp_status->src<
literal|2
argument|&& sbp_status->resp == ORB_RES_CMPL&& sbp_status->dead ==
literal|0
argument|); 	status_valid = (status_valid0&& sbp_status->status ==
literal|0
argument|);  	if (!status_valid0 || debug>
literal|2
argument|){ 		int status; SBP_DEBUG(
literal|0
argument|) 		sbp_show_sdev_info(sdev,
literal|2
argument|); 		printf(
literal|"ORB status src:%x resp:%x dead:%x"
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
literal|" len:%x stat:%x orb:%x%08lx\n"
argument|,
else|#
directive|else
literal|" len:%x stat:%x orb:%x%08x\n"
argument|,
endif|#
directive|endif
argument|sbp_status->src, sbp_status->resp, sbp_status->dead, 			sbp_status->len, sbp_status->status, 			ntohs(sbp_status->orb_hi), ntohl(sbp_status->orb_lo)); END_DEBUG 		sbp_show_sdev_info(sdev,
literal|2
argument|); 		status = sbp_status->status; 		switch(sbp_status->resp) { 		case
literal|0
argument|: 			if (status> MAX_ORB_STATUS0) 				printf(
literal|"%s\n"
argument|, orb_status0[MAX_ORB_STATUS0]); 			else 				printf(
literal|"%s\n"
argument|, orb_status0[status]); 			break; 		case
literal|1
argument|: 			printf(
literal|"Obj: %s, Error: %s\n"
argument|, 				orb_status1_object[(status>>
literal|6
argument|)&
literal|3
argument|], 				orb_status1_serial_bus_error[status&
literal|0xf
argument|]); 			break; 		case
literal|2
argument|: 			printf(
literal|"Illegal request\n"
argument|); 			break; 		case
literal|3
argument|: 			printf(
literal|"Vendor dependent\n"
argument|); 			break; 		default: 			printf(
literal|"unknown respose code %d\n"
argument|, sbp_status->resp); 		} 	}
comment|/* we have to reset the fetch agent if it's dead */
argument|if (sbp_status->dead) { 		if (sdev->path) { 			xpt_freeze_devq(sdev->path,
literal|1
argument|); 			sdev->freeze ++; 		} 		reset_agent =
literal|1
argument|; 	}  	if (ocb == NULL) 		goto done;  	switch(ntohl(ocb->orb[
literal|4
argument|])& ORB_FMT_MSK){ 	case ORB_FMT_NOP: 		break; 	case ORB_FMT_VED: 		break; 	case ORB_FMT_STD: 		switch(ocb->flags) { 		case OCB_ACT_MGM: 			orb_fun = ntohl(ocb->orb[
literal|4
argument|])& ORB_FUN_MSK; 			reset_agent =
literal|0
argument|; 			switch(orb_fun) { 			case ORB_FUN_LGI: 				fwdma_sync(&sdev->dma, BUS_DMASYNC_POSTREAD); 				login_res = sdev->login; 				login_res->len = ntohs(login_res->len); 				login_res->id = ntohs(login_res->id); 				login_res->cmd_hi = ntohs(login_res->cmd_hi); 				login_res->cmd_lo = ntohl(login_res->cmd_lo); 				if (status_valid) { SBP_DEBUG(
literal|0
argument|) sbp_show_sdev_info(sdev,
literal|2
argument|); printf(
literal|"login: len %d, ID %d, cmd %08x%08x, recon_hold %d\n"
argument|, login_res->len, login_res->id, login_res->cmd_hi, login_res->cmd_lo, ntohs(login_res->recon_hold)); END_DEBUG 					sbp_busy_timeout(sdev); 				} else {
comment|/* forgot logout? */
argument|sbp_show_sdev_info(sdev,
literal|2
argument|); 					printf(
literal|"login failed\n"
argument|); 					sdev->status = SBP_DEV_RESET; 				} 				break; 			case ORB_FUN_RCN: 				login_res = sdev->login; 				if (status_valid) { SBP_DEBUG(
literal|0
argument|) sbp_show_sdev_info(sdev,
literal|2
argument|); printf(
literal|"reconnect: len %d, ID %d, cmd %08x%08x\n"
argument|, login_res->len, login_res->id, login_res->cmd_hi, login_res->cmd_lo); END_DEBUG
if|#
directive|if
literal|1
argument|if (sdev->status == SBP_DEV_ATTACHED) 						sbp_scan_dev(sdev); 					else 						sbp_agent_reset(sdev);
else|#
directive|else
argument|sdev->status = SBP_DEV_ATTACHED; 					sbp_mgm_orb(sdev, ORB_FUN_ATS, NULL);
endif|#
directive|endif
argument|} else {
comment|/* reconnection hold time exceed? */
argument|SBP_DEBUG(
literal|0
argument|) 					sbp_show_sdev_info(sdev,
literal|2
argument|); 					printf(
literal|"reconnect failed\n"
argument|); END_DEBUG 					sbp_login(sdev); 				} 				break; 			case ORB_FUN_LGO: 				sdev->status = SBP_DEV_RESET; 				break; 			case ORB_FUN_RST: 				sbp_busy_timeout(sdev); 				break; 			case ORB_FUN_LUR: 			case ORB_FUN_ATA: 			case ORB_FUN_ATS: 				sbp_agent_reset(sdev); 				break; 			default: 				sbp_show_sdev_info(sdev,
literal|2
argument|); 				printf(
literal|"unknown function %d\n"
argument|, orb_fun); 				break; 			} 			sbp_mgm_orb(sdev, ORB_FUN_RUNQUEUE, NULL); 			break; 		case OCB_ACT_CMD: 			sdev->timeout =
literal|0
argument|; 			if(ocb->ccb != NULL){ 				union ccb *ccb;
comment|/* 				uint32_t *ld; 				ld = ocb->ccb->csio.data_ptr; 				if(ld != NULL&& ocb->ccb->csio.dxfer_len != 0) 					printf("ptr %08x %08x %08x %08x\n", ld[0], ld[1], ld[2], ld[3]); 				else 					printf("ptr NULL\n"); printf("len %d\n", sbp_status->len); */
argument|ccb = ocb->ccb; 				if(sbp_status->len>
literal|1
argument|){ 					sbp_scsi_status(sbp_status, ocb); 				}else{ 					if(sbp_status->resp != ORB_RES_CMPL){ 						ccb->ccb_h.status = CAM_REQ_CMP_ERR; 					}else{ 						ccb->ccb_h.status = CAM_REQ_CMP; 					} 				}
comment|/* fix up inq data */
argument|if (ccb->csio.cdb_io.cdb_bytes[
literal|0
argument|] == INQUIRY) 					sbp_fix_inq_data(ocb); 				xpt_done(ccb); 			} 			break; 		default: 			break; 		} 	}  	if (!use_doorbell) 		sbp_free_ocb(sdev, ocb); done: 	if (reset_agent) 		sbp_agent_reset(sdev);  done0: 	xfer->recv.pay_len = SBP_RECV_LEN;
comment|/* The received packet is usually small enough to be stored within  * the buffer. In that case, the controller return ack_complete and  * no respose is necessary.  *  * XXX fwohci.c and firewire.c should inform event_code such as   * ack_complete or ack_pending to upper driver.  */
if|#
directive|if
name|NEED_RESPONSE
argument|xfer->send.off =
literal|0
argument|; 	sfp = (struct fw_pkt *)xfer->send.buf; 	sfp->mode.wres.dst = rfp->mode.wreqb.src; 	xfer->dst = sfp->mode.wres.dst; 	xfer->spd = min(sdev->target->fwdev->speed, max_speed); 	xfer->hand = sbp_loginres_callback;  	sfp->mode.wres.tlrt = rfp->mode.wreqb.tlrt; 	sfp->mode.wres.tcode = FWTCODE_WRES; 	sfp->mode.wres.rtcode =
literal|0
argument|; 	sfp->mode.wres.pri =
literal|0
argument|;  	fw_asyreq(xfer->fc, -
literal|1
argument|, xfer);
else|#
directive|else
comment|/* recycle */
argument|STAILQ_INSERT_TAIL(&sbp->fwb.xferlist, xfer, link);
endif|#
directive|endif
argument|return;  }  static void sbp_recv(struct fw_xfer *xfer) { 	int s;  	s = splcam(); 	sbp_recv1(xfer); 	splx(s); }
comment|/*  * sbp_attach()  */
argument|static int sbp_attach(device_t dev) { 	struct sbp_softc *sbp; 	struct cam_devq *devq; 	int i
argument_list|,
argument|s
argument_list|,
argument|error;  	if (DFLTPHYS> SBP_MAXPHYS) 		device_printf(dev,
literal|"Warning, DFLTPHYS(%dKB) is larger than "
literal|"SBP_MAXPHYS(%dKB).\n"
argument|, DFLTPHYS /
literal|1024
argument|, 			SBP_MAXPHYS /
literal|1024
argument|);  SBP_DEBUG(
literal|0
argument|) 	printf(
literal|"sbp_attach (cold=%d)\n"
argument|, cold); END_DEBUG  	if (cold) 		sbp_cold ++; 	sbp = ((struct sbp_softc *)device_get_softc(dev)); 	bzero(sbp, sizeof(struct sbp_softc)); 	sbp->fd.dev = dev; 	sbp->fd.fc = device_get_ivars(dev);  	if (max_speed<
literal|0
argument|) 		max_speed = sbp->fd.fc->speed;  	error = bus_dma_tag_create(
comment|/*parent*/
argument|sbp->fd.fc->dmat,
comment|/* XXX shoud be 4 for sane backend? */
comment|/*alignment*/
literal|1
argument|,
comment|/*boundary*/
literal|0
argument|,
comment|/*lowaddr*/
argument|BUS_SPACE_MAXADDR_32BIT,
comment|/*highaddr*/
argument|BUS_SPACE_MAXADDR,
comment|/*filter*/
argument|NULL,
comment|/*filterarg*/
argument|NULL,
comment|/*maxsize*/
literal|0x100000
argument|,
comment|/*nsegments*/
argument|SBP_IND_MAX,
comment|/*maxsegsz*/
argument|SBP_SEG_MAX,
comment|/*flags*/
argument|BUS_DMA_ALLOCNOW,
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|501102
comment|/*lockfunc*/
argument|busdma_lock_mutex,
comment|/*lockarg*/
argument|&Giant,
endif|#
directive|endif
argument|&sbp->dmat); 	if (error !=
literal|0
argument|) { 		printf(
literal|"sbp_attach: Could not allocate DMA tag "
literal|"- error %d\n"
argument|, error); 			return (ENOMEM); 	}  	devq = cam_simq_alloc(
comment|/*maxopenings*/
argument|SBP_NUM_OCB); 	if (devq == NULL) 		return (ENXIO);  	for( i =
literal|0
argument|; i< SBP_NUM_TARGETS ; i++){ 		sbp->targets[i].fwdev = NULL; 		sbp->targets[i].luns = NULL; 	}  	sbp->sim = cam_sim_alloc(sbp_action, sbp_poll,
literal|"sbp"
argument|, sbp, 				 device_get_unit(dev),&Giant,
comment|/*untagged*/
literal|1
argument|,
comment|/*tagged*/
argument|SBP_QUEUE_LEN -
literal|1
argument|, 				 devq);  	if (sbp->sim == NULL) { 		cam_simq_free(devq); 		return (ENXIO); 	}   	if (xpt_bus_register(sbp->sim,
comment|/*bus*/
literal|0
argument|) != CAM_SUCCESS) 		goto fail;  	if (xpt_create_path(&sbp->path, xpt_periph, cam_sim_path(sbp->sim), 	    CAM_TARGET_WILDCARD, CAM_LUN_WILDCARD) != CAM_REQ_CMP) { 		xpt_bus_deregister(cam_sim_path(sbp->sim)); 		goto fail; 	}
comment|/* We reserve 16 bit space (4 bytes X 64 targets X 256 luns) */
argument|sbp->fwb.start = ((u_int64_t)SBP_BIND_HI<<
literal|32
argument|) | SBP_DEV2ADDR(
literal|0
argument|,
literal|0
argument|); 	sbp->fwb.end = sbp->fwb.start +
literal|0xffff
argument|;
comment|/* pre-allocate xfer */
argument|STAILQ_INIT(&sbp->fwb.xferlist); 	fw_xferlist_add(&sbp->fwb.xferlist, M_SBP,
comment|/*send*/
literal|0
argument|,
comment|/*recv*/
argument|SBP_RECV_LEN, SBP_NUM_OCB/
literal|2
argument|, 	    sbp->fd.fc, (void *)sbp, sbp_recv); 	fw_bindadd(sbp->fd.fc,&sbp->fwb);  	sbp->fd.post_busreset = sbp_post_busreset; 	sbp->fd.post_explore = sbp_post_explore;  	if (sbp->fd.fc->status != -
literal|1
argument|) { 		s = splfw(); 		sbp_post_busreset((void *)sbp); 		sbp_post_explore((void *)sbp); 		splx(s); 	} 	xpt_async(AC_BUS_RESET, sbp->path,
comment|/*arg*/
argument|NULL);  	return (
literal|0
argument|); fail: 	cam_sim_free(sbp->sim,
comment|/*free_devq*/
argument|TRUE); 	return (ENXIO); }  static int sbp_logout_all(struct sbp_softc *sbp) { 	struct sbp_target *target; 	struct sbp_dev *sdev; 	int i
argument_list|,
argument|j;  SBP_DEBUG(
literal|0
argument|) 	printf(
literal|"sbp_logout_all\n"
argument|); END_DEBUG 	for (i =
literal|0
argument|; i< SBP_NUM_TARGETS ; i ++) { 		target =&sbp->targets[i]; 		if (target->luns == NULL) 			continue; 		for (j =
literal|0
argument|; j< target->num_lun; j++) { 			sdev = target->luns[j]; 			if (sdev == NULL) 				continue; 			callout_stop(&sdev->login_callout); 			if (sdev->status>= SBP_DEV_TOATTACH&& 					sdev->status<= SBP_DEV_ATTACHED) 				sbp_mgm_orb(sdev, ORB_FUN_LGO, NULL); 		} 	}  	return
literal|0
argument|; }  static int sbp_shutdown(device_t dev) { 	struct sbp_softc *sbp = ((struct sbp_softc *)device_get_softc(dev));  	sbp_logout_all(sbp); 	return (
literal|0
argument|); }  static void sbp_free_sdev(struct sbp_dev *sdev) { 	int i;  	if (sdev == NULL) 		return; 	for (i =
literal|0
argument|; i< SBP_QUEUE_LEN; i++) 		bus_dmamap_destroy(sdev->target->sbp->dmat, 		    sdev->ocb[i].dmamap); 	fwdma_free(sdev->target->sbp->fd.fc,&sdev->dma); 	free(sdev, M_SBP); }  static void sbp_free_target(struct sbp_target *target) { 	struct sbp_softc *sbp; 	struct fw_xfer *xfer
argument_list|,
argument|*next; 	int i;  	if (target->luns == NULL) 		return; 	callout_stop(&target->mgm_ocb_timeout); 	sbp = target->sbp; 	for (i =
literal|0
argument|; i< target->num_lun; i++) 		sbp_free_sdev(target->luns[i]);  	for (xfer = STAILQ_FIRST(&target->xferlist); 			xfer != NULL; xfer = next) { 		next = STAILQ_NEXT(xfer, link); 		fw_xfer_free_buf(xfer); 	} 	STAILQ_INIT(&target->xferlist); 	free(target->luns, M_SBP); 	target->num_lun =
literal|0
argument|;; 	target->luns = NULL; 	target->fwdev = NULL; }  static int sbp_detach(device_t dev) { 	struct sbp_softc *sbp = ((struct sbp_softc *)device_get_softc(dev)); 	struct firewire_comm *fc = sbp->fd.fc; 	int i;  SBP_DEBUG(
literal|0
argument|) 	printf(
literal|"sbp_detach\n"
argument|); END_DEBUG  	for (i =
literal|0
argument|; i< SBP_NUM_TARGETS; i ++)  		sbp_cam_detach_target(&sbp->targets[i]); 	xpt_async(AC_LOST_DEVICE, sbp->path, NULL); 	xpt_free_path(sbp->path); 	xpt_bus_deregister(cam_sim_path(sbp->sim)); 	cam_sim_free(sbp->sim,
comment|/*free_devq*/
argument|TRUE)
argument_list|,
argument|sbp_logout_all(sbp);
comment|/* XXX wait for logout completion */
argument|pause(
literal|"sbpdtc"
argument|, hz/
literal|2
argument|);  	for (i =
literal|0
argument|; i< SBP_NUM_TARGETS ; i ++) 		sbp_free_target(&sbp->targets[i]);  	fw_bindremove(fc,&sbp->fwb); 	fw_xferlist_remove(&sbp->fwb.xferlist);  	bus_dma_tag_destroy(sbp->dmat);  	return (
literal|0
argument|); }  static void sbp_cam_detach_sdev(struct sbp_dev *sdev) { 	if (sdev == NULL) 		return; 	if (sdev->status == SBP_DEV_DEAD) 		return; 	if (sdev->status == SBP_DEV_RESET) 		return; 	if (sdev->path) { 		xpt_release_devq(sdev->path, 				 sdev->freeze, TRUE); 		sdev->freeze =
literal|0
argument|; 		xpt_async(AC_LOST_DEVICE, sdev->path, NULL); 		xpt_free_path(sdev->path); 		sdev->path = NULL; 	} 	sbp_abort_all_ocbs(sdev, CAM_DEV_NOT_THERE); }  static void sbp_cam_detach_target(struct sbp_target *target) { 	int i;  	if (target->luns != NULL) { SBP_DEBUG(
literal|0
argument|) 		printf(
literal|"sbp_detach_target %d\n"
argument|, target->target_id); END_DEBUG 		callout_stop(&target->scan_callout); 		for (i =
literal|0
argument|; i< target->num_lun; i++) 			sbp_cam_detach_sdev(target->luns[i]); 	} }  static void sbp_target_reset(struct sbp_dev *sdev, int method) { 	int i; 	struct sbp_target *target = sdev->target; 	struct sbp_dev *tsdev;  	for (i =
literal|0
argument|; i< target->num_lun; i++) { 		tsdev = target->luns[i]; 		if (tsdev == NULL) 			continue; 		if (tsdev->status == SBP_DEV_DEAD) 			continue; 		if (tsdev->status == SBP_DEV_RESET) 			continue; 		xpt_freeze_devq(tsdev->path,
literal|1
argument|); 		tsdev->freeze ++; 		sbp_abort_all_ocbs(tsdev, CAM_CMD_TIMEOUT); 		if (method ==
literal|2
argument|) 			tsdev->status = SBP_DEV_LOGIN; 	} 	switch(method) { 	case
literal|1
argument|: 		printf(
literal|"target reset\n"
argument|); 		sbp_mgm_orb(sdev, ORB_FUN_RST, NULL); 		break; 	case
literal|2
argument|: 		printf(
literal|"reset start\n"
argument|); 		sbp_reset_start(sdev); 		break; 	} 			 }  static void sbp_mgm_timeout(void *arg) { 	struct sbp_ocb *ocb = (struct sbp_ocb *)arg; 	struct sbp_dev *sdev = ocb->sdev; 	struct sbp_target *target = sdev->target;  	sbp_show_sdev_info(sdev,
literal|2
argument|); 	printf(
literal|"request timeout(mgm orb:0x%08x) ... "
argument|, 	    (uint32_t)ocb->bus_addr); 	target->mgm_ocb_cur = NULL; 	sbp_free_ocb(sdev, ocb);
if|#
directive|if
literal|0
comment|/* XXX */
argument|printf("run next request\n"); 	sbp_mgm_orb(sdev, ORB_FUN_RUNQUEUE, NULL);
endif|#
directive|endif
if|#
directive|if
literal|1
argument|printf(
literal|"reset start\n"
argument|); 	sbp_reset_start(sdev);
endif|#
directive|endif
argument|}  static void sbp_timeout(void *arg) { 	struct sbp_ocb *ocb = (struct sbp_ocb *)arg; 	struct sbp_dev *sdev = ocb->sdev;  	sbp_show_sdev_info(sdev,
literal|2
argument|); 	printf(
literal|"request timeout(cmd orb:0x%08x) ... "
argument|, 	    (uint32_t)ocb->bus_addr);  	sdev->timeout ++; 	switch(sdev->timeout) { 	case
literal|1
argument|: 		printf(
literal|"agent reset\n"
argument|); 		xpt_freeze_devq(sdev->path,
literal|1
argument|); 		sdev->freeze ++; 		sbp_abort_all_ocbs(sdev, CAM_CMD_TIMEOUT); 		sbp_agent_reset(sdev); 		break; 	case
literal|2
argument|: 	case
literal|3
argument|: 		sbp_target_reset(sdev, sdev->timeout -
literal|1
argument|); 		break;
if|#
directive|if
literal|0
argument|default:
comment|/* XXX give up */
argument|sbp_cam_detach_target(target); 		if (target->luns != NULL) 			free(target->luns, M_SBP); 		target->num_lun = 0;; 		target->luns = NULL; 		target->fwdev = NULL;
endif|#
directive|endif
argument|} }  static void sbp_action1(struct cam_sim *sim, union ccb *ccb) {  	struct sbp_softc *sbp = (struct sbp_softc *)sim->softc; 	struct sbp_target *target = NULL; 	struct sbp_dev *sdev = NULL;
comment|/* target:lun -> sdev mapping */
argument|if (sbp != NULL&& ccb->ccb_h.target_id != CAM_TARGET_WILDCARD&& ccb->ccb_h.target_id< SBP_NUM_TARGETS) { 		target =&sbp->targets[ccb->ccb_h.target_id]; 		if (target->fwdev != NULL&& ccb->ccb_h.target_lun != CAM_LUN_WILDCARD&& ccb->ccb_h.target_lun< target->num_lun) { 			sdev = target->luns[ccb->ccb_h.target_lun]; 			if (sdev != NULL&& sdev->status != SBP_DEV_ATTACHED&& 				sdev->status != SBP_DEV_PROBE) 				sdev = NULL; 		} 	}  SBP_DEBUG(
literal|1
argument|) 	if (sdev == NULL) 		printf(
literal|"invalid target %d lun %d\n"
argument|, 			ccb->ccb_h.target_id, ccb->ccb_h.target_lun); END_DEBUG  	switch (ccb->ccb_h.func_code) { 	case XPT_SCSI_IO: 	case XPT_RESET_DEV: 	case XPT_GET_TRAN_SETTINGS: 	case XPT_SET_TRAN_SETTINGS: 	case XPT_CALC_GEOMETRY: 		if (sdev == NULL) { SBP_DEBUG(
literal|1
argument|) 			printf(
literal|"%s:%d:%d:func_code 0x%04x: "
literal|"Invalid target (target needed)\n"
argument|, 				device_get_nameunit(sbp->fd.dev), 				ccb->ccb_h.target_id, ccb->ccb_h.target_lun, 				ccb->ccb_h.func_code); END_DEBUG  			ccb->ccb_h.status = CAM_DEV_NOT_THERE; 			xpt_done(ccb); 			return; 		} 		break; 	case XPT_PATH_INQ: 	case XPT_NOOP:
comment|/* The opcodes sometimes aimed at a target (sc is valid), 		 * sometimes aimed at the SIM (sc is invalid and target is 		 * CAM_TARGET_WILDCARD) 		 */
argument|if (sbp == NULL&&  			ccb->ccb_h.target_id != CAM_TARGET_WILDCARD) { SBP_DEBUG(
literal|0
argument|) 			printf(
literal|"%s:%d:%d func_code 0x%04x: "
literal|"Invalid target (no wildcard)\n"
argument|, 				device_get_nameunit(sbp->fd.dev), 				ccb->ccb_h.target_id, ccb->ccb_h.target_lun, 				ccb->ccb_h.func_code); END_DEBUG 			ccb->ccb_h.status = CAM_DEV_NOT_THERE; 			xpt_done(ccb); 			return; 		} 		break; 	default:
comment|/* XXX Hm, we should check the input parameters */
argument|break; 	}  	switch (ccb->ccb_h.func_code) { 	case XPT_SCSI_IO: 	{ 		struct ccb_scsiio *csio; 		struct sbp_ocb *ocb; 		int speed; 		void *cdb;  		csio =&ccb->csio;  SBP_DEBUG(
literal|2
argument|) 		printf(
literal|"%s:%d:%d XPT_SCSI_IO: "
literal|"cmd: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x"
literal|", flags: 0x%02x, "
literal|"%db cmd/%db data/%db sense\n"
argument|, 			device_get_nameunit(sbp->fd.dev), 			ccb->ccb_h.target_id, ccb->ccb_h.target_lun, 			csio->cdb_io.cdb_bytes[
literal|0
argument|], 			csio->cdb_io.cdb_bytes[
literal|1
argument|], 			csio->cdb_io.cdb_bytes[
literal|2
argument|], 			csio->cdb_io.cdb_bytes[
literal|3
argument|], 			csio->cdb_io.cdb_bytes[
literal|4
argument|], 			csio->cdb_io.cdb_bytes[
literal|5
argument|], 			csio->cdb_io.cdb_bytes[
literal|6
argument|], 			csio->cdb_io.cdb_bytes[
literal|7
argument|], 			csio->cdb_io.cdb_bytes[
literal|8
argument|], 			csio->cdb_io.cdb_bytes[
literal|9
argument|], 			ccb->ccb_h.flags& CAM_DIR_MASK, 			csio->cdb_len, csio->dxfer_len, 			csio->sense_len); END_DEBUG 		if(sdev == NULL){ 			ccb->ccb_h.status = CAM_DEV_NOT_THERE; 			xpt_done(ccb); 			return; 		}
if|#
directive|if
literal|0
comment|/* if we are in probe stage, pass only probe commands */
argument|if (sdev->status == SBP_DEV_PROBE) { 			char *name; 			name = xpt_path_periph(ccb->ccb_h.path)->periph_name; 			printf("probe stage, periph name: %s\n", name); 			if (strcmp(name, "probe") != 0) { 				ccb->ccb_h.status = CAM_REQUEUE_REQ; 				xpt_done(ccb); 				return; 			} 		}
endif|#
directive|endif
argument|if ((ocb = sbp_get_ocb(sdev)) == NULL) { 			ccb->ccb_h.status = CAM_REQUEUE_REQ; 			if (sdev->freeze ==
literal|0
argument|) { 				xpt_freeze_devq(sdev->path,
literal|1
argument|); 				sdev->freeze ++; 			} 			xpt_done(ccb); 			return; 		}  		ocb->flags = OCB_ACT_CMD; 		ocb->sdev = sdev; 		ocb->ccb = ccb; 		ccb->ccb_h.ccb_sdev_ptr = sdev; 		ocb->orb[
literal|0
argument|] = htonl(
literal|1
argument|<<
literal|31
argument|); 		ocb->orb[
literal|1
argument|] =
literal|0
argument|; 		ocb->orb[
literal|2
argument|] = htonl(((sbp->fd.fc->nodeid | FWLOCALBUS )<<
literal|16
argument|) ); 		ocb->orb[
literal|3
argument|] = htonl(ocb->bus_addr + IND_PTR_OFFSET); 		speed = min(target->fwdev->speed, max_speed); 		ocb->orb[
literal|4
argument|] = htonl(ORB_NOTIFY | ORB_CMD_SPD(speed) 						| ORB_CMD_MAXP(speed +
literal|7
argument|)); 		if((ccb->ccb_h.flags& CAM_DIR_MASK) == CAM_DIR_IN){ 			ocb->orb[
literal|4
argument|] |= htonl(ORB_CMD_IN); 		}  		if (csio->ccb_h.flags& CAM_SCATTER_VALID) 			printf(
literal|"sbp: CAM_SCATTER_VALID\n"
argument|); 		if (csio->ccb_h.flags& CAM_DATA_PHYS) 			printf(
literal|"sbp: CAM_DATA_PHYS\n"
argument|);  		if (csio->ccb_h.flags& CAM_CDB_POINTER) 			cdb = (void *)csio->cdb_io.cdb_ptr; 		else 			cdb = (void *)&csio->cdb_io.cdb_bytes; 		bcopy(cdb, (void *)&ocb->orb[
literal|5
argument|], csio->cdb_len);
comment|/* printf("ORB %08x %08x %08x %08x\n", ntohl(ocb->orb[0]), ntohl(ocb->orb[1]), ntohl(ocb->orb[2]), ntohl(ocb->orb[3])); printf("ORB %08x %08x %08x %08x\n", ntohl(ocb->orb[4]), ntohl(ocb->orb[5]), ntohl(ocb->orb[6]), ntohl(ocb->orb[7])); */
argument|if (ccb->csio.dxfer_len>
literal|0
argument|) { 			int s
argument_list|,
argument|error;  			s = splsoftvm(); 			error = bus_dmamap_load(
comment|/*dma tag*/
argument|sbp->dmat,
comment|/*dma map*/
argument|ocb->dmamap, 					ccb->csio.data_ptr, 					ccb->csio.dxfer_len, 					sbp_execute_ocb, 					ocb,
comment|/*flags*/
literal|0
argument|); 			splx(s); 			if (error) 				printf(
literal|"sbp: bus_dmamap_load error %d\n"
argument|, error); 		} else 			sbp_execute_ocb(ocb, NULL,
literal|0
argument|,
literal|0
argument|); 		break; 	} 	case XPT_CALC_GEOMETRY: 	{ 		struct ccb_calc_geometry *ccg;
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|501100
argument|uint32_t size_mb; 		uint32_t secs_per_cylinder; 		int extended =
literal|1
argument|;
endif|#
directive|endif
argument|ccg =&ccb->ccg; 		if (ccg->block_size ==
literal|0
argument|) { 			printf(
literal|"sbp_action1: block_size is 0.\n"
argument|); 			ccb->ccb_h.status = CAM_REQ_INVALID; 			xpt_done(ccb); 			break; 		} SBP_DEBUG(
literal|1
argument|) 		printf(
literal|"%s:%d:%d:%d:XPT_CALC_GEOMETRY: "
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
literal|"Volume size = %d\n"
argument|,
else|#
directive|else
literal|"Volume size = %jd\n"
argument|,
endif|#
directive|endif
argument|device_get_nameunit(sbp->fd.dev), 			cam_sim_path(sbp->sim), 			ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|500000
argument|(uintmax_t)
endif|#
directive|endif
argument|ccg->volume_size); END_DEBUG
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|501100
argument|size_mb = ccg->volume_size 			/ ((
literal|1024L
argument|*
literal|1024L
argument|) / ccg->block_size);  		if (size_mb>
literal|1024
argument|&& extended) { 			ccg->heads =
literal|255
argument|; 			ccg->secs_per_track =
literal|63
argument|; 		} else { 			ccg->heads =
literal|64
argument|; 			ccg->secs_per_track =
literal|32
argument|; 		} 		secs_per_cylinder = ccg->heads * ccg->secs_per_track; 		ccg->cylinders = ccg->volume_size / secs_per_cylinder; 		ccb->ccb_h.status = CAM_REQ_CMP;
else|#
directive|else
argument|cam_calc_geometry(ccg,
comment|/*extended*/
literal|1
argument|);
endif|#
directive|endif
argument|xpt_done(ccb); 		break; 	} 	case XPT_RESET_BUS:
comment|/* Reset the specified SCSI bus */
argument|{  SBP_DEBUG(
literal|1
argument|) 		printf(
literal|"%s:%d:XPT_RESET_BUS: \n"
argument|, 			device_get_nameunit(sbp->fd.dev), cam_sim_path(sbp->sim)); END_DEBUG  		ccb->ccb_h.status = CAM_REQ_INVALID; 		xpt_done(ccb); 		break; 	} 	case XPT_PATH_INQ:
comment|/* Path routing inquiry */
argument|{ 		struct ccb_pathinq *cpi =&ccb->cpi; 		 SBP_DEBUG(
literal|1
argument|) 		printf(
literal|"%s:%d:%d XPT_PATH_INQ:.\n"
argument|, 			device_get_nameunit(sbp->fd.dev), 			ccb->ccb_h.target_id, ccb->ccb_h.target_lun); END_DEBUG 		cpi->version_num =
literal|1
argument|;
comment|/* XXX??? */
argument|cpi->hba_inquiry = PI_TAG_ABLE; 		cpi->target_sprt =
literal|0
argument|; 		cpi->hba_misc = PIM_NOBUSRESET | PIM_NO_6_BYTE; 		cpi->hba_eng_cnt =
literal|0
argument|; 		cpi->max_target = SBP_NUM_TARGETS -
literal|1
argument|; 		cpi->max_lun = SBP_NUM_LUNS -
literal|1
argument|; 		cpi->initiator_id = SBP_INITIATOR; 		cpi->bus_id = sim->bus_id; 		cpi->base_transfer_speed =
literal|400
argument|*
literal|1000
argument|/
literal|8
argument|; 		strncpy(cpi->sim_vid,
literal|"FreeBSD"
argument|, SIM_IDLEN); 		strncpy(cpi->hba_vid,
literal|"SBP"
argument|, HBA_IDLEN); 		strncpy(cpi->dev_name, sim->sim_name, DEV_IDLEN); 		cpi->unit_number = sim->unit_number;                 cpi->transport = XPORT_SPI;
comment|/* XX should have a FireWire */
argument|cpi->transport_version =
literal|2
argument|;                 cpi->protocol = PROTO_SCSI;                 cpi->protocol_version = SCSI_REV_2;  		cpi->ccb_h.status = CAM_REQ_CMP; 		xpt_done(ccb); 		break; 	} 	case XPT_GET_TRAN_SETTINGS: 	{ 		struct ccb_trans_settings *cts =&ccb->cts; 		struct ccb_trans_settings_scsi *scsi =&cts->proto_specific.scsi; 		struct ccb_trans_settings_spi *spi =&cts->xport_specific.spi;  		cts->protocol = PROTO_SCSI; 		cts->protocol_version = SCSI_REV_2; 		cts->transport = XPORT_SPI;
comment|/* should have a FireWire */
argument|cts->transport_version =
literal|2
argument|; 		spi->valid = CTS_SPI_VALID_DISC; 		spi->flags = CTS_SPI_FLAGS_DISC_ENB; 		scsi->valid = CTS_SCSI_VALID_TQ; 		scsi->flags = CTS_SCSI_FLAGS_TAG_ENB; SBP_DEBUG(
literal|1
argument|) 		printf(
literal|"%s:%d:%d XPT_GET_TRAN_SETTINGS:.\n"
argument|, 			device_get_nameunit(sbp->fd.dev), 			ccb->ccb_h.target_id, ccb->ccb_h.target_lun); END_DEBUG 		cts->ccb_h.status = CAM_REQ_CMP; 		xpt_done(ccb); 		break; 	} 	case XPT_ABORT: 		ccb->ccb_h.status = CAM_UA_ABORT; 		xpt_done(ccb); 		break; 	case XPT_SET_TRAN_SETTINGS:
comment|/* XXX */
argument|default: 		ccb->ccb_h.status = CAM_REQ_INVALID; 		xpt_done(ccb); 		break; 	} 	return; }  static void sbp_action(struct cam_sim *sim, union ccb *ccb) { 	int s;  	s = splfw(); 	sbp_action1(sim, ccb); 	splx(s); }  static void sbp_execute_ocb(void *arg,  bus_dma_segment_t *segments, int seg, int error) { 	int i; 	struct sbp_ocb *ocb; 	struct sbp_ocb *prev; 	bus_dma_segment_t *s;  	if (error) 		printf(
literal|"sbp_execute_ocb: error=%d\n"
argument|, error);  	ocb = (struct sbp_ocb *)arg;  SBP_DEBUG(
literal|2
argument|) 	printf(
literal|"sbp_execute_ocb: seg %d"
argument|, seg); 	for (i =
literal|0
argument|; i< seg; i++)
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
argument|printf(
literal|", %x:%d"
argument|, segments[i].ds_addr, segments[i].ds_len);
else|#
directive|else
argument|printf(
literal|", %jx:%jd"
argument|, (uintmax_t)segments[i].ds_addr, 					(uintmax_t)segments[i].ds_len);
endif|#
directive|endif
argument|printf(
literal|"\n"
argument|); END_DEBUG  	if (seg ==
literal|1
argument|) {
comment|/* direct pointer */
argument|s =&segments[
literal|0
argument|]; 		if (s->ds_len> SBP_SEG_MAX) 			panic(
literal|"ds_len> SBP_SEG_MAX, fix busdma code"
argument|); 		ocb->orb[
literal|3
argument|] = htonl(s->ds_addr); 		ocb->orb[
literal|4
argument|] |= htonl(s->ds_len); 	} else if(seg>
literal|1
argument|) {
comment|/* page table */
argument|for (i =
literal|0
argument|; i< seg; i++) { 			s =&segments[i]; SBP_DEBUG(
literal|0
argument|)
comment|/* XXX LSI Logic "< 16 byte" bug might be hit */
argument|if (s->ds_len<
literal|16
argument|) 				printf(
literal|"sbp_execute_ocb: warning, "
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
literal|"segment length(%d) is less than 16."
else|#
directive|else
literal|"segment length(%zd) is less than 16."
endif|#
directive|endif
literal|"(seg=%d/%d)\n"
argument|, s->ds_len, i+
literal|1
argument|, seg); END_DEBUG 			if (s->ds_len> SBP_SEG_MAX) 				panic(
literal|"ds_len> SBP_SEG_MAX, fix busdma code"
argument|); 			ocb->ind_ptr[i].hi = htonl(s->ds_len<<
literal|16
argument|); 			ocb->ind_ptr[i].lo = htonl(s->ds_addr); 		} 		ocb->orb[
literal|4
argument|] |= htonl(ORB_CMD_PTBL | seg); 	} 	 	if (seg>
literal|0
argument|) 		bus_dmamap_sync(ocb->sdev->target->sbp->dmat, ocb->dmamap, 			(ntohl(ocb->orb[
literal|4
argument|])& ORB_CMD_IN) ? 			BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE); 	prev = sbp_enqueue_ocb(ocb->sdev, ocb); 	fwdma_sync(&ocb->sdev->dma, BUS_DMASYNC_PREWRITE); 	if (use_doorbell) { 		if (prev == NULL) { 			if (ocb->sdev->last_ocb != NULL) 				sbp_doorbell(ocb->sdev); 			else 				sbp_orb_pointer(ocb->sdev, ocb);  		} 	} else { 		if (prev == NULL || (ocb->sdev->flags& ORB_LINK_DEAD) !=
literal|0
argument|) { 			ocb->sdev->flags&= ~ORB_LINK_DEAD; 			sbp_orb_pointer(ocb->sdev, ocb);  		} 	} }  static void sbp_poll(struct cam_sim *sim) {        	struct sbp_softc *sbp; 	struct firewire_comm *fc;  	sbp = (struct sbp_softc *)sim->softc; 	fc = sbp->fd.fc;  	fc->poll(fc,
literal|0
argument|, -
literal|1
argument|);  	return; }  static struct sbp_ocb * sbp_dequeue_ocb(struct sbp_dev *sdev, struct sbp_status *sbp_status) { 	struct sbp_ocb *ocb; 	struct sbp_ocb *next; 	int s = splfw()
argument_list|,
argument|order =
literal|0
argument|; 	int flags;  SBP_DEBUG(
literal|1
argument|) 	sbp_show_sdev_info(sdev,
literal|2
argument|);
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
argument|printf(
literal|"%s: 0x%08lx src %d\n"
argument|,
else|#
directive|else
argument|printf(
literal|"%s: 0x%08x src %d\n"
argument|,
endif|#
directive|endif
argument|__func__, ntohl(sbp_status->orb_lo), sbp_status->src); END_DEBUG 	for (ocb = STAILQ_FIRST(&sdev->ocbs); ocb != NULL; ocb = next) { 		next = STAILQ_NEXT(ocb, ocb); 		flags = ocb->flags; 		if (OCB_MATCH(ocb, sbp_status)) {
comment|/* found */
argument|STAILQ_REMOVE(&sdev->ocbs, ocb, sbp_ocb, ocb); 			if (ocb->ccb != NULL) 				untimeout(sbp_timeout, (caddr_t)ocb, 						ocb->ccb->ccb_h.timeout_ch); 			if (ntohl(ocb->orb[
literal|4
argument|])&
literal|0xffff
argument|) { 				bus_dmamap_sync(sdev->target->sbp->dmat, 					ocb->dmamap, 					(ntohl(ocb->orb[
literal|4
argument|])& ORB_CMD_IN) ? 					BUS_DMASYNC_POSTREAD : 					BUS_DMASYNC_POSTWRITE); 				bus_dmamap_unload(sdev->target->sbp->dmat, 					ocb->dmamap); 			} 			if (!use_doorbell) { 				if (sbp_status->src == SRC_NO_NEXT) { 					if (next != NULL) 						sbp_orb_pointer(sdev, next);  					else if (order>
literal|0
argument|) {
comment|/* 						 * Unordered execution 						 * We need to send pointer for 						 * next ORB 						 */
argument|sdev->flags |= ORB_LINK_DEAD; 					} 				} 			} else {
comment|/* 				 * XXX this is not correct for unordered 				 * execution.  				 */
argument|if (sdev->last_ocb != NULL) 					sbp_free_ocb(sdev, sdev->last_ocb); 				sdev->last_ocb = ocb; 				if (next != NULL&& 				    sbp_status->src == SRC_NO_NEXT) 					sbp_doorbell(sdev); 			} 			break; 		} else 			order ++; 	} 	splx(s); SBP_DEBUG(
literal|0
argument|) 	if (ocb&& order>
literal|0
argument|) { 		sbp_show_sdev_info(sdev,
literal|2
argument|); 		printf(
literal|"unordered execution order:%d\n"
argument|, order); 	} END_DEBUG 	return (ocb); }  static struct sbp_ocb * sbp_enqueue_ocb(struct sbp_dev *sdev, struct sbp_ocb *ocb) { 	int s = splfw(); 	struct sbp_ocb *prev, *prev2;  SBP_DEBUG(
literal|1
argument|) 	sbp_show_sdev_info(sdev,
literal|2
argument|);
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
argument|printf(
literal|"%s: 0x%08x\n"
argument|, __func__, ocb->bus_addr);
else|#
directive|else
argument|printf(
literal|"%s: 0x%08jx\n"
argument|, __func__, (uintmax_t)ocb->bus_addr);
endif|#
directive|endif
argument|END_DEBUG 	prev2 = prev = STAILQ_LAST(&sdev->ocbs, sbp_ocb, ocb); 	STAILQ_INSERT_TAIL(&sdev->ocbs, ocb, ocb);  	if (ocb->ccb != NULL) 		ocb->ccb->ccb_h.timeout_ch = timeout(sbp_timeout, (caddr_t)ocb, 					(ocb->ccb->ccb_h.timeout * hz) /
literal|1000
argument|);  	if (use_doorbell&& prev == NULL) 		prev2 = sdev->last_ocb;  	if (prev2 != NULL) { SBP_DEBUG(
literal|2
argument|)
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
argument|printf(
literal|"linking chain 0x%x -> 0x%x\n"
argument|, 		    prev2->bus_addr, ocb->bus_addr);
else|#
directive|else
argument|printf(
literal|"linking chain 0x%jx -> 0x%jx\n"
argument|, 		    (uintmax_t)prev2->bus_addr, (uintmax_t)ocb->bus_addr);
endif|#
directive|endif
argument|END_DEBUG 		prev2->orb[
literal|1
argument|] = htonl(ocb->bus_addr); 		prev2->orb[
literal|0
argument|] =
literal|0
argument|; 	} 	splx(s);  	return prev; }  static struct sbp_ocb * sbp_get_ocb(struct sbp_dev *sdev) { 	struct sbp_ocb *ocb; 	int s = splfw(); 	ocb = STAILQ_FIRST(&sdev->free_ocbs); 	if (ocb == NULL) { 		sdev->flags |= ORB_SHORTAGE; 		printf(
literal|"ocb shortage!!!\n"
argument|); 		splx(s); 		return NULL; 	} 	STAILQ_REMOVE_HEAD(&sdev->free_ocbs, ocb); 	splx(s); 	ocb->ccb = NULL; 	return (ocb); }  static void sbp_free_ocb(struct sbp_dev *sdev, struct sbp_ocb *ocb) { 	ocb->flags =
literal|0
argument|; 	ocb->ccb = NULL; 	STAILQ_INSERT_TAIL(&sdev->free_ocbs, ocb, ocb); 	if ((sdev->flags& ORB_SHORTAGE) !=
literal|0
argument|) { 		int count;  		sdev->flags&= ~ORB_SHORTAGE; 		count = sdev->freeze; 		sdev->freeze =
literal|0
argument|; 		xpt_release_devq(sdev->path, count, TRUE); 	} }  static void sbp_abort_ocb(struct sbp_ocb *ocb, int status) { 	struct sbp_dev *sdev;  	sdev = ocb->sdev; SBP_DEBUG(
literal|0
argument|) 	sbp_show_sdev_info(sdev,
literal|2
argument|);
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
argument|printf(
literal|"sbp_abort_ocb 0x%x\n"
argument|, ocb->bus_addr);
else|#
directive|else
argument|printf(
literal|"sbp_abort_ocb 0x%jx\n"
argument|, (uintmax_t)ocb->bus_addr);
endif|#
directive|endif
argument|END_DEBUG SBP_DEBUG(
literal|1
argument|) 	if (ocb->ccb != NULL) 		sbp_print_scsi_cmd(ocb); END_DEBUG 	if (ntohl(ocb->orb[
literal|4
argument|])&
literal|0xffff
argument|) { 		bus_dmamap_sync(sdev->target->sbp->dmat, ocb->dmamap, 			(ntohl(ocb->orb[
literal|4
argument|])& ORB_CMD_IN) ? 			BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE); 		bus_dmamap_unload(sdev->target->sbp->dmat, ocb->dmamap); 	} 	if (ocb->ccb != NULL) { 		untimeout(sbp_timeout, (caddr_t)ocb, 					ocb->ccb->ccb_h.timeout_ch); 		ocb->ccb->ccb_h.status = status; 		xpt_done(ocb->ccb); 	} 	sbp_free_ocb(sdev, ocb); }  static void sbp_abort_all_ocbs(struct sbp_dev *sdev, int status) { 	int s; 	struct sbp_ocb *ocb, *next; 	STAILQ_HEAD(, sbp_ocb) temp;  	s = splfw();  	bcopy(&sdev->ocbs,&temp, sizeof(temp)); 	STAILQ_INIT(&sdev->ocbs); 	for (ocb = STAILQ_FIRST(&temp); ocb != NULL; ocb = next) { 		next = STAILQ_NEXT(ocb, ocb); 		sbp_abort_ocb(ocb, status); 	} 	if (sdev->last_ocb != NULL) { 		sbp_free_ocb(sdev, sdev->last_ocb); 		sdev->last_ocb = NULL; 	}  	splx(s); }  static devclass_t sbp_devclass;  static device_method_t sbp_methods[] = {
comment|/* device interface */
argument|DEVMETHOD(device_identify,	sbp_identify), 	DEVMETHOD(device_probe,		sbp_probe), 	DEVMETHOD(device_attach,	sbp_attach), 	DEVMETHOD(device_detach,	sbp_detach), 	DEVMETHOD(device_shutdown,	sbp_shutdown),  	{
literal|0
argument|,
literal|0
argument|} };  static driver_t sbp_driver = {
literal|"sbp"
argument|, 	sbp_methods, 	sizeof(struct sbp_softc), };
ifdef|#
directive|ifdef
name|__DragonFly__
argument|DECLARE_DUMMY_MODULE(sbp);
endif|#
directive|endif
argument|DRIVER_MODULE(sbp, firewire, sbp_driver, sbp_devclass,
literal|0
argument|,
literal|0
argument|); MODULE_VERSION(sbp,
literal|1
argument|); MODULE_DEPEND(sbp, firewire,
literal|1
argument|,
literal|1
argument|,
literal|1
argument|); MODULE_DEPEND(sbp, cam,
literal|1
argument|,
literal|1
argument|,
literal|1
argument|);
end_function

end_unit

