begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998,1999,2000,2001 Katsushi Kobayashi and Hidetosh Shimokawa  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the acknowledgement as bellow:  *  *    This product includes software developed by K. Kobayashi and H. Shimokawa  *  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *   * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_comment
comment|/* for struct devstat */
end_comment

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_da.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewire.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewirereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/iec13213.h>
end_include

begin_define
define|#
directive|define
name|ccb_sdev_ptr
value|spriv_ptr0
end_define

begin_define
define|#
directive|define
name|ccb_sbp_ptr
value|spriv_ptr1
end_define

begin_define
define|#
directive|define
name|SBP_NUM_TARGETS
value|8
end_define

begin_define
define|#
directive|define
name|SBP_NUM_LUNS
value|8
end_define

begin_comment
comment|/* limited by CAM_SCSI2_MAXLUN in cam_xpt.c */
end_comment

begin_define
define|#
directive|define
name|SBP_QUEUE_LEN
value|4
end_define

begin_define
define|#
directive|define
name|SBP_NUM_OCB
value|(SBP_QUEUE_LEN * SBP_NUM_TARGETS)
end_define

begin_define
define|#
directive|define
name|SBP_INITIATOR
value|7
end_define

begin_define
define|#
directive|define
name|SBP_ESELECT_TIMEOUT
value|1
end_define

begin_define
define|#
directive|define
name|SBP_BIND_HI
value|0x1
end_define

begin_define
define|#
directive|define
name|SBP_DEV2ADDR
parameter_list|(
name|u
parameter_list|,
name|t
parameter_list|,
name|l
parameter_list|)
define|\
value|((((u)& 0xff)<< 16) | (((l)& 0xff)<< 8) | (((t)& 0x3f)<< 2))
end_define

begin_define
define|#
directive|define
name|SBP_ADDR2TRG
parameter_list|(
name|a
parameter_list|)
value|(((a)>> 2)& 0x3f)
end_define

begin_define
define|#
directive|define
name|SBP_ADDR2LUN
parameter_list|(
name|a
parameter_list|)
value|(((a)>> 8)& 0xff)
end_define

begin_define
define|#
directive|define
name|ORB_NOTIFY
value|(1<< 31)
end_define

begin_define
define|#
directive|define
name|ORB_FMT_STD
value|(0<< 29)
end_define

begin_define
define|#
directive|define
name|ORB_FMT_VED
value|(2<< 29)
end_define

begin_define
define|#
directive|define
name|ORB_FMT_NOP
value|(3<< 29)
end_define

begin_define
define|#
directive|define
name|ORB_FMT_MSK
value|(3<< 29)
end_define

begin_define
define|#
directive|define
name|ORB_EXV
value|(1<< 28)
end_define

begin_comment
comment|/* */
end_comment

begin_define
define|#
directive|define
name|ORB_CMD_IN
value|(1<< 27)
end_define

begin_comment
comment|/* */
end_comment

begin_define
define|#
directive|define
name|ORB_CMD_SPD
parameter_list|(
name|x
parameter_list|)
value|((x)<< 24)
end_define

begin_define
define|#
directive|define
name|ORB_CMD_MAXP
parameter_list|(
name|x
parameter_list|)
value|((x)<< 20)
end_define

begin_define
define|#
directive|define
name|ORB_RCN_TMO
parameter_list|(
name|x
parameter_list|)
value|((x)<< 20)
end_define

begin_define
define|#
directive|define
name|ORB_CMD_PTBL
value|(1<< 19)
end_define

begin_define
define|#
directive|define
name|ORB_CMD_PSZ
parameter_list|(
name|x
parameter_list|)
value|((x)<< 16)
end_define

begin_define
define|#
directive|define
name|ORB_FUN_LGI
value|(0<< 16)
end_define

begin_define
define|#
directive|define
name|ORB_FUN_QLG
value|(1<< 16)
end_define

begin_define
define|#
directive|define
name|ORB_FUN_RCN
value|(3<< 16)
end_define

begin_define
define|#
directive|define
name|ORB_FUN_LGO
value|(7<< 16)
end_define

begin_define
define|#
directive|define
name|ORB_FUN_ATA
value|(0xb<< 16)
end_define

begin_define
define|#
directive|define
name|ORB_FUN_ATS
value|(0xc<< 16)
end_define

begin_define
define|#
directive|define
name|ORB_FUN_LUR
value|(0xe<< 16)
end_define

begin_define
define|#
directive|define
name|ORB_FUN_RST
value|(0xf<< 16)
end_define

begin_define
define|#
directive|define
name|ORB_FUN_MSK
value|(0xf<< 16)
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|orb_fun_name
index|[]
init|=
block|{
comment|/* 0 */
literal|"LOGIN"
block|,
comment|/* 1 */
literal|"QUERY LOGINS"
block|,
comment|/* 2 */
literal|"Reserved"
block|,
comment|/* 3 */
literal|"RECONNECT"
block|,
comment|/* 4 */
literal|"SET PASSWORD"
block|,
comment|/* 5 */
literal|"Reserved"
block|,
comment|/* 6 */
literal|"Reserved"
block|,
comment|/* 7 */
literal|"LOGOUT"
block|,
comment|/* 8 */
literal|"Reserved"
block|,
comment|/* 9 */
literal|"Reserved"
block|,
comment|/* A */
literal|"Reserved"
block|,
comment|/* B */
literal|"ABORT TASK"
block|,
comment|/* C */
literal|"ABORT TASK SET"
block|,
comment|/* D */
literal|"Reserved"
block|,
comment|/* E */
literal|"LOGICAL UNIT RESET"
block|,
comment|/* F */
literal|"TARGET RESET"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ORB_RES_CMPL
value|0
end_define

begin_define
define|#
directive|define
name|ORB_RES_FAIL
value|1
end_define

begin_define
define|#
directive|define
name|ORB_RES_ILLE
value|2
end_define

begin_define
define|#
directive|define
name|ORB_RES_VEND
value|3
end_define

begin_decl_stmt
specifier|static
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|auto_login
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_speed
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_firewire
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_firewire
argument_list|,
name|OID_AUTO
argument_list|,
name|sbp
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"SBP-II Subsystem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|sbp_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|debug
argument_list|,
literal|0
argument_list|,
literal|"SBP debug flag"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_sbp
argument_list|,
name|OID_AUTO
argument_list|,
name|auto_login
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|auto_login
argument_list|,
literal|0
argument_list|,
literal|"SBP perform login automatically"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_sbp
argument_list|,
name|OID_AUTO
argument_list|,
name|max_speed
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|max_speed
argument_list|,
literal|0
argument_list|,
literal|"SBP transfer max speed"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|SBP_DEBUG
parameter_list|(
name|x
parameter_list|)
value|if (debug> x) {
end_define

begin_define
define|#
directive|define
name|END_DEBUG
value|}
end_define

begin_define
define|#
directive|define
name|NEED_RESPONSE
value|0
end_define

begin_struct
struct|struct
name|ind_ptr
block|{
name|u_int32_t
name|hi
decl_stmt|,
name|lo
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SBP_IND_MAX
value|0x20
end_define

begin_struct
struct|struct
name|sbp_ocb
block|{
name|STAILQ_ENTRY
argument_list|(
argument|sbp_ocb
argument_list|)
name|ocb
expr_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
specifier|volatile
name|u_int32_t
name|orb
index|[
literal|8
index|]
decl_stmt|;
specifier|volatile
name|struct
name|ind_ptr
name|ind_ptr
index|[
name|SBP_IND_MAX
index|]
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|bus_dmamap_t
name|dmamap
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|OCB_ACT_MGM
value|0
end_define

begin_define
define|#
directive|define
name|OCB_ACT_CMD
value|1
end_define

begin_define
define|#
directive|define
name|OCB_ACT_MASK
value|3
end_define

begin_define
define|#
directive|define
name|OCB_RESERVED
value|0x10
end_define

begin_define
define|#
directive|define
name|OCB_DONE
value|0x20
end_define

begin_define
define|#
directive|define
name|SBP_RESOURCE_SHORTAGE
value|0x10
end_define

begin_struct
struct|struct
name|sbp_login_res
block|{
if|#
directive|if
name|FW_ENDIANSWAP
operator|==
literal|0
operator|&&
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
name|u_int16_t
name|len
decl_stmt|;
name|u_int16_t
name|id
decl_stmt|;
name|u_int16_t
name|res0
decl_stmt|;
name|u_int16_t
name|cmd_hi
decl_stmt|;
name|u_int32_t
name|cmd_lo
decl_stmt|;
name|u_int16_t
name|res1
decl_stmt|;
name|u_int16_t
name|recon_hold
decl_stmt|;
else|#
directive|else
name|u_int16_t
name|id
decl_stmt|;
name|u_int16_t
name|len
decl_stmt|;
name|u_int16_t
name|cmd_hi
decl_stmt|;
name|u_int16_t
name|res0
decl_stmt|;
name|u_int32_t
name|cmd_lo
decl_stmt|;
name|u_int16_t
name|recon_hold
decl_stmt|;
name|u_int16_t
name|res1
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sbp_status
block|{
if|#
directive|if
name|FW_ENDIANSWAP
operator|==
literal|0
operator|&&
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
name|u_int8_t
name|len
range|:
literal|3
decl_stmt|,
name|dead
range|:
literal|1
decl_stmt|,
name|resp
range|:
literal|2
decl_stmt|,
name|src
range|:
literal|2
decl_stmt|;
name|u_int8_t
name|status
range|:
literal|8
decl_stmt|;
name|u_int16_t
name|orb_hi
decl_stmt|;
name|u_int32_t
name|orb_lo
decl_stmt|;
name|u_int32_t
name|data
index|[
literal|6
index|]
decl_stmt|;
else|#
directive|else
name|u_int16_t
name|orb_hi
decl_stmt|;
name|u_int8_t
name|status
range|:
literal|8
decl_stmt|;
name|u_int8_t
name|len
range|:
literal|3
decl_stmt|,
name|dead
range|:
literal|1
decl_stmt|,
name|resp
range|:
literal|2
decl_stmt|,
name|src
range|:
literal|2
decl_stmt|;
name|u_int32_t
name|orb_lo
decl_stmt|;
name|u_int32_t
name|data
index|[
literal|6
index|]
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sbp_cmd_status
block|{
define|#
directive|define
name|SBP_SFMT_CURR
value|0
define|#
directive|define
name|SBP_SFMT_DEFER
value|1
if|#
directive|if
name|FW_ENDIANSWAP
operator|==
literal|0
operator|&&
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
name|u_int8_t
name|status
range|:
literal|6
decl_stmt|,
name|sfmt
range|:
literal|2
decl_stmt|;
name|u_int8_t
name|s_key
range|:
literal|4
decl_stmt|,
name|ill_len
range|:
literal|1
decl_stmt|,
name|eom
range|:
literal|1
decl_stmt|,
name|mark
range|:
literal|1
decl_stmt|,
name|valid
range|:
literal|1
decl_stmt|;
name|u_int8_t
name|s_code
decl_stmt|;
name|u_int8_t
name|s_qlfr
decl_stmt|;
name|u_int32_t
name|info
decl_stmt|;
name|u_int32_t
name|cdb
decl_stmt|;
name|u_int32_t
name|fru
range|:
literal|8
decl_stmt|,
name|s_keydep
range|:
literal|24
decl_stmt|;
name|u_int32_t
name|vend
index|[
literal|2
index|]
decl_stmt|;
else|#
directive|else
name|u_int8_t
name|s_qlfr
decl_stmt|;
name|u_int8_t
name|s_code
decl_stmt|;
name|u_int8_t
name|s_key
range|:
literal|4
decl_stmt|,
name|ill_len
range|:
literal|1
decl_stmt|,
name|eom
range|:
literal|1
decl_stmt|,
name|mark
range|:
literal|1
decl_stmt|,
name|valid
range|:
literal|1
decl_stmt|;
name|u_int8_t
name|status
range|:
literal|6
decl_stmt|,
name|sfmt
range|:
literal|2
decl_stmt|;
name|u_int32_t
name|info
decl_stmt|;
name|u_int32_t
name|cdb
decl_stmt|;
name|u_int32_t
name|s_keydep
range|:
literal|24
decl_stmt|,
name|fru
range|:
literal|8
decl_stmt|;
name|u_int32_t
name|vend
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sbp_dev
block|{
define|#
directive|define
name|SBP_DEV_RESET
value|0
comment|/* accept login */
define|#
directive|define
name|SBP_DEV_LOGIN
value|1
comment|/* to login */
define|#
directive|define
name|SBP_DEV_RECONN
value|2
comment|/* to reconnect */
define|#
directive|define
name|SBP_DEV_TOATTACH
value|3
comment|/* to attach */
define|#
directive|define
name|SBP_DEV_PROBE
value|4
comment|/* scan lun */
define|#
directive|define
name|SBP_DEV_ATTACHED
value|5
comment|/* in operation */
define|#
directive|define
name|SBP_DEV_DEAD
value|6
comment|/* unavailable unit */
define|#
directive|define
name|SBP_DEV_RETRY
value|7
comment|/* unavailable unit */
name|int
name|status
decl_stmt|;
name|int
name|lun_id
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|struct
name|sbp_login_res
name|login
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|sbp_ocb
argument_list|)
name|ocbs
expr_stmt|;
name|char
name|vendor
index|[
literal|32
index|]
decl_stmt|;
name|char
name|product
index|[
literal|32
index|]
decl_stmt|;
name|char
name|revision
index|[
literal|10
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sbp_target
block|{
name|int
name|target_id
decl_stmt|;
name|int
name|num_lun
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|luns
decl_stmt|;
name|struct
name|sbp_softc
modifier|*
name|sbp
decl_stmt|;
name|struct
name|fw_device
modifier|*
name|fwdev
decl_stmt|;
name|u_int32_t
name|mgm_hi
decl_stmt|,
name|mgm_lo
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sbp_softc
block|{
name|struct
name|firewire_dev_comm
name|fd
decl_stmt|;
name|unsigned
name|char
name|flags
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|sbp_target
name|targets
index|[
name|SBP_NUM_TARGETS
index|]
decl_stmt|;
name|struct
name|fw_bind
name|fwb
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|sbp_ocb
argument_list|)
name|free_ocbs
expr_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|bus_dma_tag_t
name|dmat
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|sbp_post_explore
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sbp_recv
name|__P
argument_list|(
operator|(
expr|struct
name|fw_xfer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sbp_login_callback
name|__P
argument_list|(
operator|(
expr|struct
name|fw_xfer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sbp_cmd_callback
name|__P
argument_list|(
operator|(
expr|struct
name|fw_xfer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sbp_orb_pointer
name|__P
argument_list|(
operator|(
expr|struct
name|sbp_dev
operator|*
operator|,
expr|struct
name|sbp_ocb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sbp_execute_ocb
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|bus_dma_segment_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sbp_free_ocb
name|__P
argument_list|(
operator|(
expr|struct
name|sbp_softc
operator|*
operator|,
expr|struct
name|sbp_ocb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sbp_abort_ocb
name|__P
argument_list|(
operator|(
expr|struct
name|sbp_ocb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sbp_abort_all_ocbs
name|__P
argument_list|(
operator|(
expr|struct
name|sbp_dev
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fw_xfer
modifier|*
name|sbp_write_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|sbp_dev
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sbp_ocb
modifier|*
name|sbp_get_ocb
name|__P
argument_list|(
operator|(
expr|struct
name|sbp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sbp_ocb
modifier|*
name|sbp_enqueue_ocb
name|__P
argument_list|(
operator|(
expr|struct
name|sbp_dev
operator|*
operator|,
expr|struct
name|sbp_ocb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sbp_ocb
modifier|*
name|sbp_dequeue_ocb
name|__P
argument_list|(
operator|(
expr|struct
name|sbp_dev
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sbp_detach_target
name|__P
argument_list|(
operator|(
expr|struct
name|sbp_target
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sbp_timeout
name|__P
argument_list|(
operator|(
name|void
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sbp_mgm_orb
name|__P
argument_list|(
operator|(
expr|struct
name|sbp_dev
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_SBP
argument_list|,
literal|"sbp"
argument_list|,
literal|"SBP-II/Firewire"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* cam related functions */
end_comment

begin_function_decl
specifier|static
name|void
name|sbp_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_cam_callback
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbp_cam_scan_lun
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|orb_status0
index|[]
init|=
block|{
comment|/* 0 */
literal|"No additional information to report"
block|,
comment|/* 1 */
literal|"Request type not supported"
block|,
comment|/* 2 */
literal|"Speed not supported"
block|,
comment|/* 3 */
literal|"Page size not supported"
block|,
comment|/* 4 */
literal|"Access denied"
block|,
comment|/* 5 */
literal|"Logical unit not supported"
block|,
comment|/* 6 */
literal|"Maximum payload too small"
block|,
comment|/* 7 */
literal|"Reserved for future standardization"
block|,
comment|/* 8 */
literal|"Resources unavailable"
block|,
comment|/* 9 */
literal|"Function rejected"
block|,
comment|/* A */
literal|"Login ID not recognized"
block|,
comment|/* B */
literal|"Dummy ORB completed"
block|,
comment|/* C */
literal|"Request aborted"
block|,
comment|/* FF */
literal|"Unspecified error"
define|#
directive|define
name|MAX_ORB_STATUS0
value|0xd
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|orb_status1_object
index|[]
init|=
block|{
comment|/* 0 */
literal|"Operation request block (ORB)"
block|,
comment|/* 1 */
literal|"Data buffer"
block|,
comment|/* 2 */
literal|"Page table"
block|,
comment|/* 3 */
literal|"Unable to specify"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|orb_status1_serial_bus_error
index|[]
init|=
block|{
comment|/* 0 */
literal|"Missing acknowledge"
block|,
comment|/* 1 */
literal|"Reserved; not to be used"
block|,
comment|/* 2 */
literal|"Time-out error"
block|,
comment|/* 3 */
literal|"Reserved; not to be used"
block|,
comment|/* 4 */
literal|"Busy retry limit exceeded(X)"
block|,
comment|/* 5 */
literal|"Busy retry limit exceeded(A)"
block|,
comment|/* 6 */
literal|"Busy retry limit exceeded(B)"
block|,
comment|/* 7 */
literal|"Reserved for future standardization"
block|,
comment|/* 8 */
literal|"Reserved for future standardization"
block|,
comment|/* 9 */
literal|"Reserved for future standardization"
block|,
comment|/* A */
literal|"Reserved for future standardization"
block|,
comment|/* B */
literal|"Tardy retry limit exceeded"
block|,
comment|/* C */
literal|"Conflict error"
block|,
comment|/* D */
literal|"Data error"
block|,
comment|/* E */
literal|"Type error"
block|,
comment|/* F */
literal|"Address error"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sbp_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"sbp_identify\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|child
init|=
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|"sbp"
argument_list|,
name|device_get_unit
argument_list|(
name|parent
argument_list|)
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|/*  * sbp_probe()  */
end_comment

begin_function
specifier|static
name|int
name|sbp_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|pa
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"sbp_probe\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|pa
init|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|!=
name|device_get_unit
argument_list|(
name|pa
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"SBP2/SCSI over firewire"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_show_sdev_info
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|,
name|int
name|new
parameter_list|)
block|{
name|int
name|lun
decl_stmt|;
name|struct
name|fw_device
modifier|*
name|fwdev
decl_stmt|;
name|printf
argument_list|(
literal|"%s:%d:%d "
argument_list|,
name|device_get_nameunit
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|sdev
operator|->
name|target
operator|->
name|target_id
argument_list|,
name|sdev
operator|->
name|lun_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|2
condition|)
block|{
return|return;
block|}
name|fwdev
operator|=
name|sdev
operator|->
name|target
operator|->
name|fwdev
expr_stmt|;
name|lun
operator|=
name|getcsrdata
argument_list|(
name|fwdev
argument_list|,
literal|0x14
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ordered:%d type:%d EUI:%08x%08x node:%d "
literal|"speed:%d maxrec:%d"
argument_list|,
operator|(
name|lun
operator|&
literal|0x00400000
operator|)
operator|>>
literal|22
argument_list|,
operator|(
name|lun
operator|&
literal|0x001f0000
operator|)
operator|>>
literal|16
argument_list|,
name|fwdev
operator|->
name|eui
operator|.
name|hi
argument_list|,
name|fwdev
operator|->
name|eui
operator|.
name|lo
argument_list|,
name|fwdev
operator|->
name|dst
argument_list|,
name|fwdev
operator|->
name|speed
argument_list|,
name|fwdev
operator|->
name|maxrec
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
name|printf
argument_list|(
literal|" new!\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"'%s' '%s' '%s'\n"
argument_list|,
name|sdev
operator|->
name|vendor
argument_list|,
name|sdev
operator|->
name|product
argument_list|,
name|sdev
operator|->
name|revision
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sbp_target
modifier|*
name|sbp_alloc_target
parameter_list|(
name|struct
name|sbp_softc
modifier|*
name|sbp
parameter_list|,
name|struct
name|fw_device
modifier|*
name|fwdev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|lun
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"sbp_alloc_target\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBP_NUM_TARGETS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sbp
operator|->
name|targets
index|[
name|i
index|]
operator|.
name|fwdev
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|SBP_NUM_TARGETS
condition|)
block|{
name|printf
argument_list|(
literal|"increase SBP_NUM_TARGETS!\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* new target */
name|target
operator|=
operator|&
name|sbp
operator|->
name|targets
index|[
name|i
index|]
expr_stmt|;
name|target
operator|->
name|sbp
operator|=
name|sbp
expr_stmt|;
name|target
operator|->
name|fwdev
operator|=
name|fwdev
expr_stmt|;
name|target
operator|->
name|target_id
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|target
operator|->
name|mgm_lo
operator|=
name|getcsrdata
argument_list|(
name|fwdev
argument_list|,
literal|0x54
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* bad target */
name|printf
argument_list|(
literal|"NULL management address\n"
argument_list|)
expr_stmt|;
name|target
operator|->
name|fwdev
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|target
operator|->
name|mgm_hi
operator|=
literal|0xffff
expr_stmt|;
name|target
operator|->
name|mgm_lo
operator|=
literal|0xf0000000
operator||
name|target
operator|->
name|mgm_lo
operator|<<
literal|2
expr_stmt|;
comment|/* XXX should probe all luns */
comment|/* XXX num_lun may be changed. realloc luns? */
name|lun
operator|=
name|getcsrdata
argument_list|(
name|target
operator|->
name|fwdev
argument_list|,
literal|0x14
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|target
operator|->
name|num_lun
operator|=
name|lun
operator|+
literal|1
expr_stmt|;
name|target
operator|->
name|luns
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sbp_dev
argument_list|)
operator|*
name|target
operator|->
name|num_lun
argument_list|,
name|M_SBP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|target
operator|->
name|num_lun
condition|;
name|i
operator|++
control|)
block|{
name|sdev
operator|=
operator|&
name|target
operator|->
name|luns
index|[
name|i
index|]
expr_stmt|;
name|sdev
operator|->
name|lun_id
operator|=
name|i
expr_stmt|;
name|sdev
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sdev
operator|->
name|ocbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|lun
condition|)
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_RESET
expr_stmt|;
else|else
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_DEAD
expr_stmt|;
block|}
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_get_text_leaf
parameter_list|(
name|struct
name|fw_device
modifier|*
name|fwdev
parameter_list|,
name|int
name|key
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|nullstr
init|=
literal|"(null)"
decl_stmt|;
name|int
name|i
decl_stmt|,
name|clen
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
name|struct
name|csrhdr
modifier|*
name|chdr
decl_stmt|;
name|struct
name|csrreg
modifier|*
name|creg
decl_stmt|;
name|u_int32_t
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|chdr
operator|=
operator|(
expr|struct
name|csrhdr
operator|*
operator|)
operator|&
name|fwdev
operator|->
name|csrrom
index|[
literal|0
index|]
expr_stmt|;
name|creg
operator|=
operator|(
expr|struct
name|csrreg
operator|*
operator|)
name|chdr
expr_stmt|;
name|creg
operator|+=
name|chdr
operator|->
name|info_len
expr_stmt|;
for|for
control|(
name|i
operator|=
name|chdr
operator|->
name|info_len
operator|+
literal|4
init|;
name|i
operator|<=
name|fwdev
operator|->
name|rommax
condition|;
name|i
operator|+=
literal|4
control|)
block|{
if|if
condition|(
operator|(
name|creg
operator|++
operator|)
operator|->
name|key
operator|==
name|key
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|nullstr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
name|src
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|creg
operator|+
name|creg
operator|->
name|val
expr_stmt|;
name|clen
operator|=
operator|(
operator|(
operator|*
name|src
operator|>>
literal|16
operator|)
operator|-
literal|2
operator|)
operator|*
literal|4
expr_stmt|;
name|src
operator|+=
literal|3
expr_stmt|;
name|dst
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|clen
condition|)
name|clen
operator|=
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|clen
operator|/
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|dst
operator|++
operator|=
name|htonl
argument_list|(
operator|*
name|src
operator|++
argument_list|)
expr_stmt|;
name|buf
index|[
name|clen
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_probe_lun
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|struct
name|fw_device
modifier|*
name|fwdev
decl_stmt|;
name|int
name|rev
decl_stmt|;
name|fwdev
operator|=
name|sdev
operator|->
name|target
operator|->
name|fwdev
expr_stmt|;
name|bzero
argument_list|(
name|sdev
operator|->
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|sdev
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sdev
operator|->
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|sdev
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|sbp_get_text_leaf
argument_list|(
name|fwdev
argument_list|,
literal|0x03
argument_list|,
name|sdev
operator|->
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|sdev
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|sbp_get_text_leaf
argument_list|(
name|fwdev
argument_list|,
literal|0x17
argument_list|,
name|sdev
operator|->
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|sdev
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|rev
operator|=
name|getcsrdata
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|fwdev
argument_list|,
literal|0x3c
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sdev
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|sdev
operator|->
name|revision
argument_list|)
argument_list|,
literal|"%06x"
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_probe_target
parameter_list|(
name|struct
name|sbp_target
modifier|*
name|target
parameter_list|,
name|int
name|alive
parameter_list|)
block|{
name|struct
name|sbp_softc
modifier|*
name|sbp
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"sbp_probe_target %d\n"
argument_list|,
name|target
operator|->
name|target_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alive
condition|)
name|printf
argument_list|(
literal|"not alive\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|sbp
init|=
name|target
operator|->
name|sbp
decl_stmt|;
name|fc
operator|=
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|fc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|target
operator|->
name|num_lun
condition|;
name|i
operator|++
control|)
block|{
name|sdev
operator|=
operator|&
name|target
operator|->
name|luns
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|alive
operator|&&
operator|(
name|sdev
operator|->
name|status
operator|!=
name|SBP_DEV_DEAD
operator|)
condition|)
block|{
if|if
condition|(
name|sdev
operator|->
name|path
operator|!=
name|NULL
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|sbp_abort_all_ocbs
argument_list|(
name|sdev
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sdev
operator|->
name|status
condition|)
block|{
case|case
name|SBP_DEV_ATTACHED
case|:
name|sbp_mgm_orb
argument_list|(
name|sdev
argument_list|,
name|ORB_FUN_RCN
argument_list|)
expr_stmt|;
break|break;
case|case
name|SBP_DEV_RETRY
case|:
name|sbp_probe_lun
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
name|sbp_mgm_orb
argument_list|(
name|sdev
argument_list|,
name|ORB_FUN_LGI
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* new or revived target */
name|sbp_probe_lun
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|auto_login
condition|)
block|{
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_TOATTACH
expr_stmt|;
name|sbp_mgm_orb
argument_list|(
name|sdev
argument_list|,
name|ORB_FUN_LGI
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
operator|(
name|sdev
operator|->
name|status
operator|==
name|SBP_DEV_TOATTACH
operator|)
argument_list|)
expr_stmt|;
name|END_DEBUG
block|}
else|else
block|{
switch|switch
condition|(
name|sdev
operator|->
name|status
condition|)
block|{
case|case
name|SBP_DEV_ATTACHED
case|:
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
comment|/* the device has gone */
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lost target\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|sdev
operator|->
name|path
condition|)
name|xpt_freeze_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_RETRY
expr_stmt|;
name|sbp_abort_all_ocbs
argument_list|(
name|sdev
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|)
expr_stmt|;
break|break;
case|case
name|SBP_DEV_PROBE
case|:
case|case
name|SBP_DEV_TOATTACH
case|:
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_RESET
expr_stmt|;
break|break;
case|case
name|SBP_DEV_RETRY
case|:
case|case
name|SBP_DEV_RESET
case|:
case|case
name|SBP_DEV_DEAD
case|:
break|break;
block|}
block|}
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void sbp_release_queue(void *arg) { 	struct sbp_softc *sbp;  SBP_DEBUG(0) 	printf("sbp_release_queue\n"); END_DEBUG 	sbp = (struct sbp_softc *)arg; 	xpt_release_simq(sbp->sim, 1); }  static void sbp_release_devq(void *arg) { 	struct sbp_dev *sdev; 	int s;  	sdev = (struct sbp_dev *)arg; SBP_DEBUG(0) 	sbp_show_sdev_info(sdev, 2); 	printf("sbp_release_devq\n"); END_DEBUG 	s = splcam(); 	xpt_release_devq(sdev->path, 1, TRUE); 	splx(s); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|sbp_post_explore
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sbp_softc
modifier|*
name|sbp
init|=
operator|(
expr|struct
name|sbp_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|struct
name|fw_device
modifier|*
name|fwdev
decl_stmt|;
name|int
name|i
decl_stmt|,
name|alive
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"sbp_post_explore\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
if|#
directive|if
literal|0
block|xpt_freeze_simq(sbp->sim,
comment|/*count*/
block|1);
endif|#
directive|endif
comment|/* Gabage Collection */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBP_NUM_TARGETS
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
operator|&
name|sbp
operator|->
name|targets
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|fwdev
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sbp
operator|->
name|fd
operator|.
name|fc
operator|->
name|devices
argument_list|)
init|;
name|fwdev
operator|!=
name|NULL
condition|;
name|fwdev
operator|=
name|TAILQ_NEXT
argument_list|(
name|fwdev
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|target
operator|->
name|fwdev
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|target
operator|->
name|fwdev
operator|==
name|fwdev
condition|)
break|break;
block|}
if|if
condition|(
name|fwdev
operator|==
name|NULL
condition|)
block|{
comment|/* device has removed in lower driver */
name|sbp_detach_target
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* traverse device list */
for|for
control|(
name|fwdev
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sbp
operator|->
name|fd
operator|.
name|fc
operator|->
name|devices
argument_list|)
init|;
name|fwdev
operator|!=
name|NULL
condition|;
name|fwdev
operator|=
name|TAILQ_NEXT
argument_list|(
name|fwdev
argument_list|,
name|link
argument_list|)
control|)
block|{
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"sbp_post_explore: EUI:%08x%08x "
argument_list|,
name|fwdev
operator|->
name|eui
operator|.
name|hi
argument_list|,
name|fwdev
operator|->
name|eui
operator|.
name|lo
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwdev
operator|->
name|status
operator|==
name|FWDEVATTACHED
condition|)
block|{
name|printf
argument_list|(
literal|"spec=%d key=%d.\n"
argument_list|,
name|getcsrdata
argument_list|(
name|fwdev
argument_list|,
name|CSRKEY_SPEC
argument_list|)
operator|==
name|CSRVAL_ANSIT10
argument_list|,
name|getcsrdata
argument_list|(
name|fwdev
argument_list|,
name|CSRKEY_VER
argument_list|)
operator|==
name|CSRVAL_T10SBP2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"not attached, state=%d.\n"
argument_list|,
name|fwdev
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
name|END_DEBUG
name|alive
init|=
operator|(
name|fwdev
operator|->
name|status
operator|==
name|FWDEVATTACHED
operator|)
operator|&&
operator|(
name|getcsrdata
argument_list|(
name|fwdev
argument_list|,
name|CSRKEY_SPEC
argument_list|)
operator|==
name|CSRVAL_ANSIT10
operator|)
operator|&&
operator|(
name|getcsrdata
argument_list|(
name|fwdev
argument_list|,
name|CSRKEY_VER
argument_list|)
operator|==
name|CSRVAL_T10SBP2
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBP_NUM_TARGETS
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
operator|&
name|sbp
operator|->
name|targets
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|fwdev
operator|==
name|fwdev
condition|)
block|{
comment|/* known target */
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|SBP_NUM_TARGETS
condition|)
block|{
if|if
condition|(
name|alive
condition|)
block|{
comment|/* new target */
name|target
operator|=
name|sbp_alloc_target
argument_list|(
name|sbp
argument_list|,
name|fwdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
continue|continue;
block|}
else|else
block|{
continue|continue;
block|}
block|}
name|sbp_probe_target
argument_list|(
name|target
argument_list|,
name|alive
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|timeout(sbp_release_queue, (caddr_t)sbp, bus_reset_rest * hz / 1000);
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|NEED_RESPONSE
end_if

begin_function
specifier|static
name|void
name|sbp_loginres_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_loginres_callback\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|sbp_login_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_login_callback\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_cmd_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|SBP_DEBUG
argument_list|(
literal|2
argument_list|)
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_cmd_callback\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_cam_callback
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_sdev_ptr
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_cam_callback\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|sdev
operator|->
name|status
init|=
name|SBP_DEV_ATTACHED
decl_stmt|;
name|free
argument_list|(
name|ccb
argument_list|,
name|M_SBP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_cam_scan_lun
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|,
name|M_SBP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_cam_scan_lun\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sdev
operator|->
name|path
argument_list|,
literal|5
comment|/*priority (low)*/
argument_list|)
decl_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_LUN
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|cbfcnp
operator|=
name|sbp_cam_callback
expr_stmt|;
name|ccb
operator|->
name|crcn
operator|.
name|flags
operator|=
name|CAM_FLAG_NONE
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_sdev_ptr
operator|=
name|sdev
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/* The scan is in progress now. */
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_ping_unit_callback
parameter_list|(
name|struct
name|cam_periph
modifier|*
name|periph
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_sdev_ptr
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_ping_unit_callback\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
operator|--
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|==
literal|0
condition|)
block|{
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_tur_callback: retry count exceeded\n"
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_RETRY
expr_stmt|;
name|free
argument_list|(
name|ccb
argument_list|,
name|M_SBP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* requeue */
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|xpt_release_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|free
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|,
name|M_SBP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ccb
argument_list|,
name|M_SBP
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_ATTACHED
expr_stmt|;
name|xpt_release_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*   * XXX Some devices need to execute inquiry or read_capacity  * after bus_rest during busy transfer.  * Otherwise they return incorrect result for READ(and WRITE?)  * command without any SBP-II/SCSI error.  *  * e.g. Maxtor 3000XT, Yano A-dish.  */
end_comment

begin_function
specifier|static
name|void
name|sbp_ping_unit
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_buf
decl_stmt|;
name|ccb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|,
name|M_SBP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|inq_buf
operator|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|inq_buf
argument_list|)
argument_list|,
name|M_SBP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_ping_unit\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
comment|/* 	 * We need to execute this command before any other queued command. 	 * Make priority 0 and freeze queue after execution for retry. 	 * cam's scan_lun command doesn't provide this feature. 	 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sdev
operator|->
name|path
argument_list|,
literal|0
comment|/*priority (high)*/
argument_list|)
decl_stmt|;
name|scsi_inquiry
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|5
argument_list|,
name|sbp_ping_unit_callback
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|inq_buf
argument_list|,
name|SHORT_INQUIRY_LENGTH
argument_list|,
comment|/*evpd*/
name|FALSE
argument_list|,
comment|/*page_code*/
literal|0
argument_list|,
name|SSD_MIN_SIZE
argument_list|,
comment|/*timeout*/
literal|60000
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFREEZE
expr_stmt|;
name|xpt_action
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_do_attach
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_do_attach\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
if|if
condition|(
name|sdev
operator|->
name|path
operator|==
name|NULL
condition|)
name|xpt_create_path
argument_list|(
operator|&
name|sdev
operator|->
name|path
argument_list|,
name|xpt_periph
argument_list|,
name|cam_sim_path
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|sim
argument_list|)
argument_list|,
name|sdev
operator|->
name|target
operator|->
name|target_id
argument_list|,
name|sdev
operator|->
name|lun_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdev
operator|->
name|status
operator|==
name|SBP_DEV_RETRY
condition|)
block|{
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_PROBE
expr_stmt|;
name|sbp_ping_unit
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
comment|/* freezed twice */
name|xpt_release_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_PROBE
expr_stmt|;
name|sbp_cam_scan_lun
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
block|}
name|xpt_release_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_agent_reset_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_cmd_callback\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|sbp_abort_all_ocbs
argument_list|(
name|sdev
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdev
operator|->
name|path
condition|)
name|xpt_release_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_agent_reset
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|,
name|int
name|attach
parameter_list|)
block|{
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_agent_reset\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|xfer
init|=
name|sbp_write_cmd
argument_list|(
name|sdev
argument_list|,
name|FWTCODE_WREQQ
argument_list|,
literal|0x04
argument_list|)
decl_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|attach
condition|)
name|xfer
operator|->
name|act
operator|.
name|hand
operator|=
name|sbp_do_attach
expr_stmt|;
else|else
name|xfer
operator|->
name|act
operator|.
name|hand
operator|=
name|sbp_agent_reset_callback
expr_stmt|;
name|fp
operator|=
operator|(
expr|struct
name|fw_pkt
operator|*
operator|)
name|xfer
operator|->
name|send
operator|.
name|buf
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|data
operator|=
name|htonl
argument_list|(
literal|0xf
argument_list|)
expr_stmt|;
name|fw_asyreq
argument_list|(
name|xfer
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_busy_timeout_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
operator|(
expr|struct
name|sbp_dev
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_but_timeout_callback\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|sbp_agent_reset
argument_list|(
name|sdev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_busy_timeout
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_busy_timeout\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|xfer
init|=
name|sbp_write_cmd
argument_list|(
name|sdev
argument_list|,
name|FWTCODE_WREQQ
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|xfer
operator|->
name|act
operator|.
name|hand
operator|=
name|sbp_busy_timeout_callback
expr_stmt|;
name|fp
operator|=
operator|(
expr|struct
name|fw_pkt
operator|*
operator|)
name|xfer
operator|->
name|send
operator|.
name|buf
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|dest_hi
operator|=
name|htons
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|dest_lo
operator|=
name|htonl
argument_list|(
literal|0xf0000000
operator||
name|BUS_TIME
argument_list|)
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|data
operator|=
name|htonl
argument_list|(
literal|0xf
argument_list|)
expr_stmt|;
name|fw_asyreq
argument_list|(
name|xfer
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void sbp_reset_start(struct sbp_dev *sdev) { 	struct fw_xfer *xfer; 	struct fw_pkt *fp;  SBP_DEBUG(0) 	sbp_show_sdev_info(sdev, 2); 	printf("sbp_reset_start\n"); END_DEBUG 	xfer = sbp_write_cmd(sdev, FWTCODE_WREQQ, 0);  	xfer->act.hand = sbp_busy_timeout; 	fp = (struct fw_pkt *)xfer->send.buf; 	fp->mode.wreqq.dest_hi = htons(0xffff); 	fp->mode.wreqq.dest_lo = htonl(0xf0000000 | RESET_START); 	fp->mode.wreqq.data = htonl(0xf); 	fw_asyreq(xfer->fc, -1, xfer); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|sbp_orb_pointer
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|,
name|struct
name|sbp_ocb
modifier|*
name|ocb
parameter_list|)
block|{
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|2
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_orb_pointer\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|xfer
init|=
name|sbp_write_cmd
argument_list|(
name|sdev
argument_list|,
name|FWTCODE_WREQB
argument_list|,
literal|0x08
argument_list|)
decl_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
return|return;
name|xfer
operator|->
name|act
operator|.
name|hand
operator|=
name|sbp_cmd_callback
expr_stmt|;
name|fp
operator|=
operator|(
expr|struct
name|fw_pkt
operator|*
operator|)
name|xfer
operator|->
name|send
operator|.
name|buf
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|len
operator|=
name|htons
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|extcode
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|payload
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
operator|(
operator|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|fc
operator|->
name|nodeid
operator||
name|FWLOCALBUS
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|payload
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
operator|&
name|ocb
operator|->
name|orb
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_asyreq
argument_list|(
name|xfer
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ocb
operator|->
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_doorbell
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|)
block|{
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_doorbell\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|xfer
init|=
name|sbp_write_cmd
argument_list|(
name|sdev
argument_list|,
name|FWTCODE_WREQQ
argument_list|,
literal|0x10
argument_list|)
decl_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
return|return;
name|xfer
operator|->
name|act
operator|.
name|hand
operator|=
name|sbp_cmd_callback
expr_stmt|;
name|fp
operator|=
operator|(
expr|struct
name|fw_pkt
operator|*
operator|)
name|xfer
operator|->
name|send
operator|.
name|buf
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|data
operator|=
name|htonl
argument_list|(
literal|0xf
argument_list|)
expr_stmt|;
name|fw_asyreq
argument_list|(
name|xfer
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|fw_xfer
modifier|*
name|sbp_write_cmd
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|,
name|int
name|tcode
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|xfer
operator|=
name|fw_xfer_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|tcode
operator|==
name|FWTCODE_WREQQ
condition|)
name|xfer
operator|->
name|send
operator|.
name|len
operator|=
literal|16
expr_stmt|;
else|else
name|xfer
operator|->
name|send
operator|.
name|len
operator|=
literal|24
expr_stmt|;
name|xfer
operator|->
name|send
operator|.
name|buf
operator|=
name|malloc
argument_list|(
name|xfer
operator|->
name|send
operator|.
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|send
operator|.
name|buf
operator|==
name|NULL
condition|)
block|{
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|xfer
operator|->
name|send
operator|.
name|off
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|spd
operator|=
name|min
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|fwdev
operator|->
name|speed
argument_list|,
name|max_speed
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|sc
operator|=
operator|(
name|caddr_t
operator|)
name|sdev
expr_stmt|;
name|xfer
operator|->
name|fc
operator|=
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|fc
expr_stmt|;
name|xfer
operator|->
name|retry_req
operator|=
name|fw_asybusy
expr_stmt|;
name|fp
operator|=
operator|(
expr|struct
name|fw_pkt
operator|*
operator|)
name|xfer
operator|->
name|send
operator|.
name|buf
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|dest_hi
operator|=
name|htons
argument_list|(
name|sdev
operator|->
name|login
operator|.
name|cmd_hi
argument_list|)
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|dest_lo
operator|=
name|htonl
argument_list|(
name|sdev
operator|->
name|login
operator|.
name|cmd_lo
operator|+
name|offset
argument_list|)
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|tlrt
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|tcode
operator|=
name|tcode
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|pri
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|dst
operator|=
name|FWLOCALBUS
operator||
name|sdev
operator|->
name|target
operator|->
name|fwdev
operator|->
name|dst
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqq
operator|.
name|dst
operator|=
name|htons
argument_list|(
name|xfer
operator|->
name|dst
argument_list|)
expr_stmt|;
return|return
name|xfer
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_mgm_orb
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|,
name|int
name|func
parameter_list|)
block|{
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|int
name|s
decl_stmt|,
name|nid
decl_stmt|;
if|if
condition|(
operator|(
name|ocb
operator|=
name|sbp_get_ocb
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|flags
operator||=
name|SBP_RESOURCE_SHORTAGE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|ocb
operator|->
name|flags
operator|=
name|OCB_ACT_MGM
expr_stmt|;
name|ocb
operator|->
name|sdev
operator|=
name|sdev
expr_stmt|;
name|ocb
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
name|nid
operator|=
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|fc
operator|->
name|nodeid
operator||
name|FWLOCALBUS
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|ocb
operator|->
name|orb
argument_list|,
sizeof|sizeof
argument_list|(
name|ocb
operator|->
name|orb
argument_list|)
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|6
index|]
operator|=
name|htonl
argument_list|(
operator|(
name|nid
operator|<<
literal|16
operator|)
operator||
name|SBP_BIND_HI
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|7
index|]
operator|=
name|htonl
argument_list|(
name|SBP_DEV2ADDR
argument_list|(
name|device_get_unit
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|sdev
operator|->
name|target
operator|->
name|target_id
argument_list|,
name|sdev
operator|->
name|lun_id
argument_list|)
argument_list|)
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|orb_fun_name
index|[
operator|(
name|func
operator|>>
literal|16
operator|)
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
name|END_DEBUG
switch|switch
condition|(
name|func
condition|)
block|{
case|case
name|ORB_FUN_LGI
case|:
name|ocb
operator|->
name|orb
index|[
literal|2
index|]
operator|=
name|htonl
argument_list|(
name|nid
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|3
index|]
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
operator|&
name|sdev
operator|->
name|login
argument_list|)
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
operator|=
name|htonl
argument_list|(
name|ORB_NOTIFY
operator||
name|ORB_EXV
operator||
name|sdev
operator|->
name|lun_id
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|5
index|]
operator|=
name|htonl
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sbp_login_res
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORB_FUN_RCN
case|:
case|case
name|ORB_FUN_LGO
case|:
case|case
name|ORB_FUN_LUR
case|:
case|case
name|ORB_FUN_RST
case|:
case|case
name|ORB_FUN_ATA
case|:
case|case
name|ORB_FUN_ATS
case|:
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
operator|=
name|htonl
argument_list|(
name|ORB_NOTIFY
operator||
name|func
operator||
name|sdev
operator|->
name|login
operator|.
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
name|xfer
operator|=
name|sbp_write_cmd
argument_list|(
name|sdev
argument_list|,
name|FWTCODE_WREQB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|xfer
operator|->
name|act
operator|.
name|hand
operator|=
name|sbp_login_callback
expr_stmt|;
name|fp
operator|=
operator|(
expr|struct
name|fw_pkt
operator|*
operator|)
name|xfer
operator|->
name|send
operator|.
name|buf
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|dest_hi
operator|=
name|htons
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|mgm_hi
argument_list|)
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|dest_lo
operator|=
name|htonl
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|mgm_lo
argument_list|)
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|len
operator|=
name|htons
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|extcode
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|payload
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
operator|(
operator|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|fc
operator|->
name|nodeid
operator||
name|FWLOCALBUS
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|payload
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
operator|&
name|ocb
operator|->
name|orb
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sbp_enqueue_ocb
argument_list|(
name|sdev
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
name|fw_asyreq
argument_list|(
name|xfer
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_print_scsi_cmd
parameter_list|(
name|struct
name|sbp_ocb
modifier|*
name|ocb
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|csio
operator|=
operator|&
name|ocb
operator|->
name|ccb
operator|->
name|csio
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%d:%d XPT_SCSI_IO: "
literal|"cmd: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x"
literal|", flags: 0x%02x, "
literal|"%db cmd/%db data/%db sense\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|ocb
operator|->
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|1
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|2
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|3
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|4
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|5
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|6
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|7
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|8
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|9
index|]
argument_list|,
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|csio
operator|->
name|sense_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_scsi_status
parameter_list|(
name|struct
name|sbp_status
modifier|*
name|sbp_status
parameter_list|,
name|struct
name|sbp_ocb
modifier|*
name|ocb
parameter_list|)
block|{
name|struct
name|sbp_cmd_status
modifier|*
name|sbp_cmd_status
decl_stmt|;
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|sbp_cmd_status
operator|=
operator|(
expr|struct
name|sbp_cmd_status
operator|*
operator|)
name|sbp_status
operator|->
name|data
expr_stmt|;
name|sense
operator|=
operator|&
name|ocb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_print_scsi_cmd
argument_list|(
name|ocb
argument_list|)
expr_stmt|;
comment|/* XXX need decode status */
name|sbp_show_sdev_info
argument_list|(
name|ocb
operator|->
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSI status %x sfmt %x valid %x key %x code %x qlfr %x len %d"
argument_list|,
name|sbp_cmd_status
operator|->
name|status
argument_list|,
name|sbp_cmd_status
operator|->
name|sfmt
argument_list|,
name|sbp_cmd_status
operator|->
name|valid
argument_list|,
name|sbp_cmd_status
operator|->
name|s_key
argument_list|,
name|sbp_cmd_status
operator|->
name|s_code
argument_list|,
name|sbp_cmd_status
operator|->
name|s_qlfr
argument_list|,
name|sbp_status
operator|->
name|len
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX */
block|if (sbp_cmd_status->status == SCSI_STATUS_CHECK_COND) { 		printf(" %s\n", scsi_sense_key_text[sbp_cmd_status->s_key]); 			scsi_sense_desc( 				sbp_cmd_status->s_code, 				sbp_cmd_status->s_qlfr, 				ocb->ccb->ccb_h.path->device->inq_data 			) 	} else { 		printf("\n"); 	}
else|#
directive|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|END_DEBUG
if|if
condition|(
name|sbp_cmd_status
operator|->
name|status
operator|==
name|SCSI_STATUS_CHECK_COND
operator|||
name|sbp_cmd_status
operator|->
name|status
operator|==
name|SCSI_STATUS_CMD_TERMINATED
condition|)
block|{
if|if
condition|(
name|sbp_cmd_status
operator|->
name|sfmt
operator|==
name|SBP_SFMT_CURR
condition|)
block|{
name|sense
operator|->
name|error_code
operator|=
name|SSD_CURRENT_ERROR
expr_stmt|;
block|}
else|else
block|{
name|sense
operator|->
name|error_code
operator|=
name|SSD_DEFERRED_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|sbp_cmd_status
operator|->
name|valid
condition|)
name|sense
operator|->
name|error_code
operator||=
name|SSD_ERRCODE_VALID
expr_stmt|;
name|sense
operator|->
name|flags
operator|=
name|sbp_cmd_status
operator|->
name|s_key
expr_stmt|;
if|if
condition|(
name|sbp_cmd_status
operator|->
name|mark
condition|)
name|sense
operator|->
name|flags
operator||=
name|SSD_FILEMARK
expr_stmt|;
if|if
condition|(
name|sbp_cmd_status
operator|->
name|eom
condition|)
name|sense
operator|->
name|flags
operator||=
name|SSD_EOM
expr_stmt|;
if|if
condition|(
name|sbp_cmd_status
operator|->
name|ill_len
condition|)
name|sense
operator|->
name|flags
operator||=
name|SSD_ILI
expr_stmt|;
name|sense
operator|->
name|info
index|[
literal|0
index|]
operator|=
name|ntohl
argument_list|(
name|sbp_cmd_status
operator|->
name|info
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|sense
operator|->
name|info
index|[
literal|1
index|]
operator|=
operator|(
name|ntohl
argument_list|(
name|sbp_cmd_status
operator|->
name|info
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sense
operator|->
name|info
index|[
literal|2
index|]
operator|=
operator|(
name|ntohl
argument_list|(
name|sbp_cmd_status
operator|->
name|info
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sense
operator|->
name|info
index|[
literal|3
index|]
operator|=
operator|(
name|ntohl
argument_list|(
name|sbp_cmd_status
operator|->
name|info
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|sbp_status
operator|->
name|len
operator|<=
literal|1
condition|)
comment|/* XXX not scsi status. shouldn't be happened */
name|sense
operator|->
name|extra_len
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sbp_status
operator|->
name|len
operator|<=
literal|4
condition|)
comment|/* add_sense_code(_qual), info, cmd_spec_info */
name|sense
operator|->
name|extra_len
operator|=
literal|6
expr_stmt|;
else|else
comment|/* fru, sense_key_spec */
name|sense
operator|->
name|extra_len
operator|=
literal|10
expr_stmt|;
name|sense
operator|->
name|cmd_spec_info
index|[
literal|0
index|]
operator|=
name|ntohl
argument_list|(
name|sbp_cmd_status
operator|->
name|cdb
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|sense
operator|->
name|cmd_spec_info
index|[
literal|1
index|]
operator|=
operator|(
name|ntohl
argument_list|(
name|sbp_cmd_status
operator|->
name|cdb
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sense
operator|->
name|cmd_spec_info
index|[
literal|2
index|]
operator|=
operator|(
name|ntohl
argument_list|(
name|sbp_cmd_status
operator|->
name|cdb
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sense
operator|->
name|cmd_spec_info
index|[
literal|3
index|]
operator|=
operator|(
name|ntohl
argument_list|(
name|sbp_cmd_status
operator|->
name|cdb
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sense
operator|->
name|add_sense_code
operator|=
name|sbp_cmd_status
operator|->
name|s_code
expr_stmt|;
name|sense
operator|->
name|add_sense_code_qual
operator|=
name|sbp_cmd_status
operator|->
name|s_qlfr
expr_stmt|;
name|sense
operator|->
name|fru
operator|=
name|sbp_cmd_status
operator|->
name|fru
expr_stmt|;
name|sense
operator|->
name|sense_key_spec
index|[
literal|0
index|]
operator|=
name|ntohl
argument_list|(
name|sbp_cmd_status
operator|->
name|s_keydep
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|sense
operator|->
name|sense_key_spec
index|[
literal|1
index|]
operator|=
operator|(
name|ntohl
argument_list|(
name|sbp_cmd_status
operator|->
name|s_keydep
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sense
operator|->
name|sense_key_spec
index|[
literal|2
index|]
operator|=
operator|(
name|ntohl
argument_list|(
name|sbp_cmd_status
operator|->
name|s_keydep
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ocb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|sbp_cmd_status
operator|->
name|status
expr_stmt|;
empty_stmt|;
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
operator||
name|CAM_AUTOSNS_VALID
expr_stmt|;
comment|/* { 		u_int8_t j, *tmp; 		tmp = sense; 		for( j = 0 ; j< 32 ; j+=8){ 			printf("sense %02x%02x %02x%02x %02x%02x %02x%02x\n",  				tmp[j], tmp[j+1], tmp[j+2], tmp[j+3], 				tmp[j+4], tmp[j+5], tmp[j+6], tmp[j+7]); 		}  } */
block|}
else|else
block|{
name|printf
argument_list|(
literal|"sbp_scsi_status: unknown scsi status\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_fix_inq_data
parameter_list|(
name|struct
name|sbp_ocb
modifier|*
name|ocb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq
decl_stmt|;
name|ccb
operator|=
name|ocb
operator|->
name|ccb
expr_stmt|;
name|sdev
operator|=
name|ocb
operator|->
name|sdev
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|1
index|]
operator|&
name|SI_EVPD
condition|)
return|return;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_fix_inq_data\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|inq
init|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
decl_stmt|;
switch|switch
condition|(
name|SID_TYPE
argument_list|(
name|inq
argument_list|)
condition|)
block|{
case|case
name|T_DIRECT
case|:
comment|/*  		 * XXX Convert Direct Access device to RBC. 		 * I've never seen Firewire DA devices which support READ_6. 		 */
if|#
directive|if
literal|1
if|if
condition|(
name|SID_TYPE
argument_list|(
name|inq
argument_list|)
operator|==
name|T_DIRECT
condition|)
name|inq
operator|->
name|device
operator||=
name|T_RBC
expr_stmt|;
comment|/*  T_DIRECT == 0 */
endif|#
directive|endif
comment|/* fall through */
case|case
name|T_RBC
case|:
comment|/* disable tag queuing */
name|inq
operator|->
name|flags
operator|&=
operator|~
name|SID_CmdQue
expr_stmt|;
comment|/* 		 * Override vendor/product/revision information. 		 * Some devices sometimes return strange strings. 		 */
name|bcopy
argument_list|(
name|sdev
operator|->
name|vendor
argument_list|,
name|inq
operator|->
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sdev
operator|->
name|product
argument_list|,
name|inq
operator|->
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sdev
operator|->
name|revision
operator|+
literal|2
argument_list|,
name|inq
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|inq
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_recv1
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|fw_pkt
modifier|*
name|rfp
decl_stmt|;
if|#
directive|if
name|NEED_RESPONSE
name|struct
name|fw_pkt
modifier|*
name|sfp
decl_stmt|;
endif|#
directive|endif
name|struct
name|sbp_softc
modifier|*
name|sbp
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|struct
name|sbp_login_res
modifier|*
name|login_res
init|=
name|NULL
decl_stmt|;
name|struct
name|sbp_status
modifier|*
name|sbp_status
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
decl_stmt|;
name|int
name|orb_fun
decl_stmt|,
name|status_valid
decl_stmt|;
name|u_int32_t
name|addr
decl_stmt|;
comment|/* 	u_int32_t *ld; 	ld = xfer->recv.buf; printf("sbp %x %d %d %08x %08x %08x %08x\n", 			xfer->resp, xfer->recv.len, xfer->recv.off, ntohl(ld[0]), ntohl(ld[1]), ntohl(ld[2]), ntohl(ld[3])); printf("sbp %08x %08x %08x %08x\n", ntohl(ld[4]), ntohl(ld[5]), ntohl(ld[6]), ntohl(ld[7])); printf("sbp %08x %08x %08x %08x\n", ntohl(ld[8]), ntohl(ld[9]), ntohl(ld[10]), ntohl(ld[11])); */
if|if
condition|(
name|xfer
operator|->
name|resp
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_recv: xfer->resp != 0\n"
argument_list|)
expr_stmt|;
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xfer
operator|->
name|recv
operator|.
name|buf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_recv: xfer->recv.buf == NULL\n"
argument_list|)
expr_stmt|;
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
block|}
name|sbp
operator|=
operator|(
expr|struct
name|sbp_softc
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|rfp
operator|=
operator|(
expr|struct
name|fw_pkt
operator|*
operator|)
name|xfer
operator|->
name|recv
operator|.
name|buf
expr_stmt|;
if|if
condition|(
name|rfp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|tcode
operator|!=
name|FWTCODE_WREQB
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_recv: tcode = %d\n"
argument_list|,
name|rfp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|tcode
argument_list|)
expr_stmt|;
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
block|}
name|sbp_status
operator|=
operator|(
expr|struct
name|sbp_status
operator|*
operator|)
name|rfp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|payload
expr_stmt|;
name|addr
operator|=
name|ntohl
argument_list|(
name|rfp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|dest_lo
argument_list|)
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|2
argument_list|)
name|printf
argument_list|(
literal|"received address 0x%x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|END_DEBUG
name|target
init|=
operator|&
name|sbp
operator|->
name|targets
index|[
name|SBP_ADDR2TRG
argument_list|(
name|addr
argument_list|)
index|]
decl_stmt|;
name|sdev
operator|=
operator|&
name|target
operator|->
name|luns
index|[
name|SBP_ADDR2LUN
argument_list|(
name|addr
argument_list|)
index|]
expr_stmt|;
name|status_valid
operator|=
operator|(
name|sbp_status
operator|->
name|resp
operator|==
name|ORB_RES_CMPL
operator|&&
name|sbp_status
operator|->
name|dead
operator|==
literal|0
operator|&&
name|sbp_status
operator|->
name|status
operator|==
literal|0
operator|)
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
if|if
condition|(
operator|!
name|status_valid
operator|||
name|debug
operator|>
literal|1
condition|)
block|{
name|int
name|status
decl_stmt|;
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ORB status src:%x resp:%x dead:%x"
literal|" len:%x stat:%x orb:%x%08x\n"
argument_list|,
name|sbp_status
operator|->
name|src
argument_list|,
name|sbp_status
operator|->
name|resp
argument_list|,
name|sbp_status
operator|->
name|dead
argument_list|,
name|sbp_status
operator|->
name|len
argument_list|,
name|sbp_status
operator|->
name|status
argument_list|,
name|ntohl
argument_list|(
name|sbp_status
operator|->
name|orb_hi
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|sbp_status
operator|->
name|orb_lo
argument_list|)
argument_list|)
expr_stmt|;
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|status
operator|=
name|sbp_status
operator|->
name|status
expr_stmt|;
switch|switch
condition|(
name|sbp_status
operator|->
name|resp
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|status
operator|>
name|MAX_ORB_STATUS0
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|orb_status0
index|[
name|MAX_ORB_STATUS0
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|orb_status0
index|[
name|status
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"Object: %s, Serial Bus Error: %s\n"
argument_list|,
name|orb_status1_object
index|[
operator|(
name|status
operator|>>
literal|6
operator|)
operator|&
literal|3
index|]
argument_list|,
name|orb_status1_serial_bus_error
index|[
name|status
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown respose code\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|END_DEBUG
name|ocb
init|=
name|sbp_dequeue_ocb
argument_list|(
name|sdev
argument_list|,
name|ntohl
argument_list|(
name|sbp_status
operator|->
name|orb_lo
argument_list|)
argument_list|)
decl_stmt|;
comment|/* we have to reset the fetch agent if it's dead */
if|if
condition|(
name|sbp_status
operator|->
name|dead
condition|)
block|{
if|if
condition|(
name|sdev
operator|->
name|path
condition|)
name|xpt_freeze_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sbp_agent_reset
argument_list|(
name|sdev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ocb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"No ocb on the queue for target %d.\n"
argument_list|,
name|sdev
operator|->
name|target
operator|->
name|target_id
argument_list|)
expr_stmt|;
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|ntohl
argument_list|(
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
argument_list|)
operator|&
name|ORB_FMT_MSK
condition|)
block|{
case|case
name|ORB_FMT_NOP
case|:
break|break;
case|case
name|ORB_FMT_VED
case|:
break|break;
case|case
name|ORB_FMT_STD
case|:
switch|switch
condition|(
name|ocb
operator|->
name|flags
operator|&
name|OCB_ACT_MASK
condition|)
block|{
case|case
name|OCB_ACT_MGM
case|:
name|orb_fun
operator|=
name|ntohl
argument_list|(
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
argument_list|)
operator|&
name|ORB_FUN_MSK
expr_stmt|;
switch|switch
condition|(
name|orb_fun
condition|)
block|{
case|case
name|ORB_FUN_LGI
case|:
name|login_res
operator|=
operator|&
name|sdev
operator|->
name|login
expr_stmt|;
name|login_res
operator|->
name|len
operator|=
name|ntohs
argument_list|(
name|login_res
operator|->
name|len
argument_list|)
expr_stmt|;
name|login_res
operator|->
name|id
operator|=
name|ntohs
argument_list|(
name|login_res
operator|->
name|id
argument_list|)
expr_stmt|;
name|login_res
operator|->
name|cmd_hi
operator|=
name|ntohs
argument_list|(
name|login_res
operator|->
name|cmd_hi
argument_list|)
expr_stmt|;
name|login_res
operator|->
name|cmd_lo
operator|=
name|ntohl
argument_list|(
name|login_res
operator|->
name|cmd_lo
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_valid
condition|)
block|{
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"login: len %d, ID %d, cmd %08x%08x, recon_hold %d\n"
argument_list|,
name|login_res
operator|->
name|len
argument_list|,
name|login_res
operator|->
name|id
argument_list|,
name|login_res
operator|->
name|cmd_hi
argument_list|,
name|login_res
operator|->
name|cmd_lo
argument_list|,
name|ntohs
argument_list|(
name|login_res
operator|->
name|recon_hold
argument_list|)
argument_list|)
expr_stmt|;
name|END_DEBUG
if|#
directive|if
literal|1
name|sbp_busy_timeout
argument_list|(
name|sdev
argument_list|)
decl_stmt|;
else|#
directive|else
name|sbp_mgm_orb
argument_list|(
name|sdev
argument_list|,
name|ORB_FUN_ATS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* forgot logout ? */
name|printf
argument_list|(
literal|"login failed\n"
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_RESET
expr_stmt|;
block|}
break|break;
case|case
name|ORB_FUN_RCN
case|:
name|login_res
operator|=
operator|&
name|sdev
operator|->
name|login
expr_stmt|;
if|if
condition|(
name|status_valid
condition|)
block|{
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_ATTACHED
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"reconnect: len %d, ID %d, cmd %08x%08x\n"
argument_list|,
name|login_res
operator|->
name|len
argument_list|,
name|login_res
operator|->
name|id
argument_list|,
name|login_res
operator|->
name|cmd_hi
argument_list|,
name|login_res
operator|->
name|cmd_lo
argument_list|)
expr_stmt|;
name|END_DEBUG
if|#
directive|if
literal|1
name|sbp_ping_unit
argument_list|(
name|sdev
argument_list|)
decl_stmt|;
name|xpt_release_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|#
directive|else
name|sbp_mgm_orb
argument_list|(
name|sdev
argument_list|,
name|ORB_FUN_ATS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* reconnection hold time exceed? */
name|printf
argument_list|(
literal|"reconnect failed\n"
argument_list|)
expr_stmt|;
name|sbp_mgm_orb
argument_list|(
name|sdev
argument_list|,
name|ORB_FUN_LGI
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ORB_FUN_LGO
case|:
name|sdev
operator|->
name|status
operator|=
name|SBP_DEV_RESET
expr_stmt|;
break|break;
case|case
name|ORB_FUN_LUR
case|:
case|case
name|ORB_FUN_RST
case|:
case|case
name|ORB_FUN_ATA
case|:
case|case
name|ORB_FUN_ATS
case|:
if|if
condition|(
name|sdev
operator|->
name|status
operator|==
name|SBP_DEV_ATTACHED
condition|)
block|{
name|xpt_release_devq
argument_list|(
name|sdev
operator|->
name|path
argument_list|,
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbp_busy_timeout
argument_list|(
name|sdev
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|OCB_ACT_CMD
case|:
if|if
condition|(
name|ocb
operator|->
name|ccb
operator|!=
name|NULL
condition|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
comment|/* 				u_int32_t *ld; 				ld = ocb->ccb->csio.data_ptr; 				if(ld != NULL&& ocb->ccb->csio.dxfer_len != 0) 					printf("ptr %08x %08x %08x %08x\n", ld[0], ld[1], ld[2], ld[3]); 				else 					printf("ptr NULL\n"); printf("len %d\n", sbp_status->len); */
name|ccb
operator|=
name|ocb
operator|->
name|ccb
expr_stmt|;
if|if
condition|(
name|sbp_status
operator|->
name|len
operator|>
literal|1
condition|)
block|{
name|sbp_scsi_status
argument_list|(
name|sbp_status
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sbp_status
operator|->
name|resp
operator|!=
name|ORB_RES_CMPL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
block|}
comment|/* fix up inq data */
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|==
name|INQUIRY
condition|)
name|sbp_fix_inq_data
argument_list|(
name|ocb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|ocb
operator|->
name|flags
operator|&
name|OCB_RESERVED
operator|)
condition|)
name|sbp_free_ocb
argument_list|(
name|sbp
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
comment|/* The received packet is usually small enough to be stored within  * the buffer. In that case, the controller return ack_complete and  * no respose is necessary.  *  * XXX fwohci.c and firewire.c should inform event_code such as   * ack_complete or ack_pending to upper driver.  */
if|#
directive|if
name|NEED_RESPONSE
name|xfer
operator|->
name|send
operator|.
name|buf
operator|=
name|malloc
argument_list|(
literal|12
argument_list|,
name|M_SBP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|send
operator|.
name|len
operator|=
literal|12
expr_stmt|;
name|xfer
operator|->
name|send
operator|.
name|off
operator|=
literal|0
expr_stmt|;
name|sfp
operator|=
operator|(
expr|struct
name|fw_pkt
operator|*
operator|)
name|xfer
operator|->
name|send
operator|.
name|buf
expr_stmt|;
name|sfp
operator|->
name|mode
operator|.
name|wres
operator|.
name|dst
operator|=
name|rfp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|src
expr_stmt|;
name|xfer
operator|->
name|dst
operator|=
name|ntohs
argument_list|(
name|sfp
operator|->
name|mode
operator|.
name|wres
operator|.
name|dst
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|spd
operator|=
name|min
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|fwdev
operator|->
name|speed
argument_list|,
name|max_speed
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|act
operator|.
name|hand
operator|=
name|sbp_loginres_callback
expr_stmt|;
name|xfer
operator|->
name|retry_req
operator|=
name|fw_asybusy
expr_stmt|;
name|sfp
operator|->
name|mode
operator|.
name|wres
operator|.
name|tlrt
operator|=
name|rfp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|tlrt
expr_stmt|;
name|sfp
operator|->
name|mode
operator|.
name|wres
operator|.
name|tcode
operator|=
name|FWTCODE_WRES
expr_stmt|;
name|sfp
operator|->
name|mode
operator|.
name|wres
operator|.
name|rtcode
operator|=
literal|0
expr_stmt|;
name|sfp
operator|->
name|mode
operator|.
name|wres
operator|.
name|pri
operator|=
literal|0
expr_stmt|;
name|fw_asyreq
argument_list|(
name|xfer
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
else|#
directive|else
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_recv
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|sbp_recv1
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sbp_attach()  */
end_comment

begin_function
specifier|static
name|int
name|sbp_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sbp_softc
modifier|*
name|sbp
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|error
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"sbp_attach\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
name|sbp
init|=
operator|(
operator|(
expr|struct
name|sbp_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
operator|)
decl_stmt|;
name|bzero
argument_list|(
name|sbp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbp_softc
argument_list|)
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|fd
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|sbp
operator|->
name|fd
operator|.
name|fc
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|NULL
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
literal|0x100000
argument_list|,
comment|/*nsegments*/
name|SBP_IND_MAX
argument_list|,
comment|/*maxsegsz*/
literal|0x8000
argument_list|,
comment|/*flags*/
name|BUS_DMA_ALLOCNOW
argument_list|,
operator|&
name|sbp
operator|->
name|dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_attach: Could not allocate DMA tag "
literal|"- error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
comment|/*maxopenings*/
name|SBP_NUM_OCB
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBP_NUM_TARGETS
condition|;
name|i
operator|++
control|)
block|{
name|sbp
operator|->
name|targets
index|[
name|i
index|]
operator|.
name|fwdev
operator|=
name|NULL
expr_stmt|;
name|sbp
operator|->
name|targets
index|[
name|i
index|]
operator|.
name|luns
operator|=
name|NULL
expr_stmt|;
block|}
name|sbp
operator|->
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|sbp_action
argument_list|,
name|sbp_poll
argument_list|,
literal|"sbp"
argument_list|,
name|sbp
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/*untagged*/
name|SBP_QUEUE_LEN
argument_list|,
comment|/*tagged*/
literal|0
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbp
operator|->
name|sim
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sbp
operator|->
name|ocb
operator|=
operator|(
expr|struct
name|sbp_ocb
operator|*
operator|)
name|contigmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sbp_ocb
argument_list|)
operator|*
name|SBP_NUM_OCB
argument_list|,
name|M_SBP
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|0x10000
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0ul
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sbp
operator|->
name|ocb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbp_ocb
argument_list|)
operator|*
name|SBP_NUM_OCB
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbp
operator|->
name|ocb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sbp0: ocb alloction failure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|STAILQ_INIT
argument_list|(
operator|&
name|sbp
operator|->
name|free_ocbs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBP_NUM_OCB
condition|;
name|i
operator|++
control|)
block|{
name|sbp_free_ocb
argument_list|(
name|sbp
argument_list|,
operator|&
name|sbp
operator|->
name|ocb
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sbp
operator|->
name|sim
argument_list|,
comment|/*bus*/
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|sbp
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|sbp
operator|->
name|ocb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbp_ocb
argument_list|)
operator|*
name|SBP_NUM_OCB
argument_list|,
name|M_SBP
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|xfer
operator|=
name|fw_xfer_alloc
argument_list|()
expr_stmt|;
name|xfer
operator|->
name|act
operator|.
name|hand
operator|=
name|sbp_recv
expr_stmt|;
name|xfer
operator|->
name|act_type
operator|=
name|FWACT_XFER
expr_stmt|;
if|#
directive|if
name|NEED_RESPONSE
name|xfer
operator|->
name|fc
operator|=
name|sbp
operator|->
name|fd
operator|.
name|fc
expr_stmt|;
endif|#
directive|endif
name|xfer
operator|->
name|sc
operator|=
operator|(
name|caddr_t
operator|)
name|sbp
expr_stmt|;
name|sbp
operator|->
name|fwb
operator|.
name|start_hi
operator|=
name|SBP_BIND_HI
expr_stmt|;
name|sbp
operator|->
name|fwb
operator|.
name|start_lo
operator|=
name|SBP_DEV2ADDR
argument_list|(
name|device_get_unit
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We reserve 16 bit space (4 bytes X 64 targets X 256 luns) */
name|sbp
operator|->
name|fwb
operator|.
name|addrlen
operator|=
literal|0xffff
expr_stmt|;
name|sbp
operator|->
name|fwb
operator|.
name|xfer
operator|=
name|xfer
expr_stmt|;
name|fw_bindadd
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|fc
argument_list|,
operator|&
name|sbp
operator|->
name|fwb
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|fd
operator|.
name|post_explore
operator|=
name|sbp_post_explore
expr_stmt|;
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|sbp_post_explore
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sbp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbp_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sbp_softc
modifier|*
name|sbp
init|=
operator|(
operator|(
expr|struct
name|sbp_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
operator|)
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
init|=
name|sbp
operator|->
name|fd
operator|.
name|fc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"sbp_detach\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
comment|/* bus reset for logout */
name|sbp
operator|->
name|fd
operator|.
name|post_explore
init|=
name|NULL
decl_stmt|;
name|fc
operator|->
name|ibr
argument_list|(
name|fc
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|sbp
operator|->
name|ocb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbp_ocb
argument_list|)
operator|*
name|SBP_NUM_OCB
argument_list|,
name|M_SBP
argument_list|)
expr_stmt|;
name|fw_bindremove
argument_list|(
name|fc
argument_list|,
operator|&
name|sbp
operator|->
name|fwb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBP_NUM_TARGETS
condition|;
name|i
operator|++
control|)
name|sbp_detach_target
argument_list|(
operator|&
name|sbp
operator|->
name|targets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sbp
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sbp
operator|->
name|dmat
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_detach_target
parameter_list|(
name|struct
name|sbp_target
modifier|*
name|target
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
if|if
condition|(
name|target
operator|->
name|luns
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_detach_target %d\n"
argument_list|,
name|target
operator|->
name|target_id
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|target
operator|->
name|num_lun
condition|;
name|i
operator|++
control|)
block|{
name|sdev
operator|=
operator|&
name|target
operator|->
name|luns
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sdev
operator|->
name|status
operator|==
name|SBP_DEV_RESET
operator|||
name|sdev
operator|->
name|status
operator|==
name|SBP_DEV_DEAD
condition|)
continue|continue;
if|if
condition|(
name|sdev
operator|->
name|path
condition|)
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|sdev
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|sdev
operator|->
name|path
argument_list|)
expr_stmt|;
name|sdev
operator|->
name|path
operator|=
name|NULL
expr_stmt|;
name|sbp_abort_all_ocbs
argument_list|(
name|sdev
argument_list|,
name|CAM_DEV_NOT_THERE
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|target
operator|->
name|luns
argument_list|,
name|M_SBP
argument_list|)
expr_stmt|;
name|target
operator|->
name|luns
operator|=
name|NULL
expr_stmt|;
block|}
name|target
operator|->
name|fwdev
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sbp_ocb
modifier|*
name|ocb
init|=
operator|(
expr|struct
name|sbp_ocb
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
init|=
name|ocb
operator|->
name|sdev
decl_stmt|;
name|int
name|s
decl_stmt|;
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"request timeout ... requeue\n"
argument_list|)
expr_stmt|;
comment|/* XXX need reset? */
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|sbp_abort_all_ocbs
argument_list|(
name|sdev
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_action1
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|sbp_softc
modifier|*
name|sbp
init|=
operator|(
expr|struct
name|sbp_softc
operator|*
operator|)
name|sim
operator|->
name|softc
decl_stmt|;
name|struct
name|sbp_target
modifier|*
name|target
init|=
name|NULL
decl_stmt|;
name|struct
name|sbp_dev
modifier|*
name|sdev
init|=
name|NULL
decl_stmt|;
comment|/* target:lun -> sdev mapping */
if|if
condition|(
name|sbp
operator|!=
name|NULL
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|!=
name|CAM_TARGET_WILDCARD
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|<
name|SBP_NUM_TARGETS
condition|)
block|{
name|target
operator|=
operator|&
name|sbp
operator|->
name|targets
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|fwdev
operator|!=
name|NULL
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|!=
name|CAM_LUN_WILDCARD
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|<
name|target
operator|->
name|num_lun
condition|)
block|{
name|sdev
operator|=
operator|&
name|target
operator|->
name|luns
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
index|]
expr_stmt|;
if|if
condition|(
name|sdev
operator|->
name|status
operator|!=
name|SBP_DEV_ATTACHED
operator|&&
name|sdev
operator|->
name|status
operator|!=
name|SBP_DEV_PROBE
condition|)
name|sdev
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"invalid target %d lun %d\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
name|END_DEBUG
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
case|case
name|XPT_RESET_DEV
case|:
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
case|case
name|XPT_CALC_GEOMETRY
case|:
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
block|{
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"%s:%d:%d:func_code 0x%04x: "
literal|"Invalid target (target needed)\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
name|END_DEBUG
name|ccb
operator|->
name|ccb_h
operator|.
name|status
init|=
name|CAM_DEV_NOT_THERE
decl_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|XPT_PATH_INQ
case|:
case|case
name|XPT_NOOP
case|:
comment|/* The opcodes sometimes aimed at a target (sc is valid), 		 * sometimes aimed at the SIM (sc is invalid and target is 		 * CAM_TARGET_WILDCARD) 		 */
if|if
condition|(
name|sbp
operator|==
name|NULL
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|!=
name|CAM_TARGET_WILDCARD
condition|)
block|{
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|printf
argument_list|(
literal|"%s:%d:%d func_code 0x%04x: "
literal|"Invalid target (no wildcard)\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
name|END_DEBUG
name|ccb
operator|->
name|ccb_h
operator|.
name|status
init|=
name|CAM_DEV_NOT_THERE
decl_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
comment|/* XXX Hm, we should check the input parameters */
break|break;
block|}
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|int
name|s
decl_stmt|,
name|speed
decl_stmt|;
name|void
modifier|*
name|cdb
decl_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"%s:%d:%d XPT_SCSI_IO: "
literal|"cmd: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x"
literal|", flags: 0x%02x, "
literal|"%db cmd/%db data/%db sense\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|1
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|2
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|3
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|4
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|5
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|6
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|7
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|8
index|]
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|9
index|]
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|csio
operator|->
name|sense_len
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|sdev
operator|==
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
comment|/* if we are in probe stage, pass only probe commands */
block|if (sdev->status == SBP_DEV_PROBE) { 			char *name; 			name = xpt_path_periph(ccb->ccb_h.path)->periph_name; 			printf("probe stage, periph name: %s\n", name); 			if (strcmp(name, "probe") != 0) { 				ccb->ccb_h.status = CAM_REQUEUE_REQ; 				xpt_done(ccb); 				return; 			} 		}
endif|#
directive|endif
if|if
condition|(
operator|(
name|ocb
operator|=
name|sbp_get_ocb
argument_list|(
name|sbp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|sbp
operator|->
name|flags
operator||=
name|SBP_RESOURCE_SHORTAGE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|ocb
operator|->
name|flags
operator|=
name|OCB_ACT_CMD
expr_stmt|;
name|ocb
operator|->
name|sdev
operator|=
name|sdev
expr_stmt|;
name|ocb
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_sdev_ptr
operator|=
name|sdev
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
literal|1
operator|<<
literal|31
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|2
index|]
operator|=
name|htonl
argument_list|(
operator|(
operator|(
name|sbp
operator|->
name|fd
operator|.
name|fc
operator|->
name|nodeid
operator||
name|FWLOCALBUS
operator|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|3
index|]
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
name|ocb
operator|->
name|ind_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|speed
operator|=
name|min
argument_list|(
name|target
operator|->
name|fwdev
operator|->
name|speed
argument_list|,
name|max_speed
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
operator|=
name|htonl
argument_list|(
name|ORB_NOTIFY
operator||
name|ORB_CMD_SPD
argument_list|(
name|speed
argument_list|)
operator||
name|ORB_CMD_MAXP
argument_list|(
name|speed
operator|+
literal|7
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
operator||=
name|htonl
argument_list|(
name|ORB_CMD_IN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SCATTER_VALID
condition|)
name|printf
argument_list|(
literal|"sbp: CAM_SCATTER_VALID\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
condition|)
name|printf
argument_list|(
literal|"sbp: CAM_DATA_PHYS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
name|cdb
operator|=
operator|(
name|void
operator|*
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
expr_stmt|;
else|else
name|cdb
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|bcopy
argument_list|(
name|cdb
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
specifier|volatile
name|void
operator|*
argument_list|)
operator|&
name|ocb
operator|->
name|orb
index|[
literal|5
index|]
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
comment|/* printf("ORB %08x %08x %08x %08x\n", ntohl(ocb->orb[0]), ntohl(ocb->orb[1]), ntohl(ocb->orb[2]), ntohl(ocb->orb[3])); printf("ORB %08x %08x %08x %08x\n", ntohl(ocb->orb[4]), ntohl(ocb->orb[5]), ntohl(ocb->orb[6]), ntohl(ocb->orb[7])); */
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|>
literal|0
condition|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sbp
operator|->
name|dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|ocb
operator|->
name|dmamap
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_action1: cannot create dmamap\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|splsoftvm
argument_list|()
expr_stmt|;
name|bus_dmamap_load
argument_list|(
comment|/*dma tag*/
name|sbp
operator|->
name|dmat
argument_list|,
comment|/*dma map*/
name|ocb
operator|->
name|dmamap
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|,
name|sbp_execute_ocb
argument_list|,
name|ocb
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|sbp_execute_ocb
argument_list|(
name|ocb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
decl_stmt|;
name|u_int32_t
name|size_mb
decl_stmt|;
name|u_int32_t
name|secs_per_cylinder
decl_stmt|;
name|int
name|extended
init|=
literal|1
decl_stmt|;
name|ccg
operator|=
operator|&
name|ccb
operator|->
name|ccg
expr_stmt|;
if|if
condition|(
name|ccg
operator|->
name|block_size
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sbp_action1: block_size is 0.\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"%s:%d:%d:%d:XPT_CALC_GEOMETRY: "
literal|"Volume size = %d\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|cam_sim_path
argument_list|(
name|sbp
operator|->
name|sim
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|ccg
operator|->
name|volume_size
argument_list|)
expr_stmt|;
name|END_DEBUG
name|size_mb
init|=
name|ccg
operator|->
name|volume_size
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
decl_stmt|;
if|if
condition|(
name|size_mb
operator|>=
literal|1024
operator|&&
name|extended
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|255
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
literal|64
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
block|}
name|secs_per_cylinder
operator|=
name|ccg
operator|->
name|heads
operator|*
name|ccg
operator|->
name|secs_per_track
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ccg
operator|->
name|volume_size
operator|/
name|secs_per_cylinder
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
block|{
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"%s:%d:XPT_RESET_BUS: \n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|cam_sim_path
argument_list|(
name|sbp
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|END_DEBUG
name|ccb
operator|->
name|ccb_h
operator|.
name|status
init|=
name|CAM_REQ_INVALID
decl_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"%s:%d:%d XPT_PATH_INQ:.\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
name|END_DEBUG
name|cpi
operator|->
name|version_num
init|=
literal|1
decl_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|SBP_NUM_TARGETS
operator|-
literal|1
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
name|SBP_NUM_LUNS
operator|-
literal|1
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|SBP_INITIATOR
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|sim
operator|->
name|bus_id
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|400
operator|*
literal|1000
operator|/
literal|8
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"SBP"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|sim
operator|->
name|sim_name
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|sim
operator|->
name|unit_number
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"%s:%d:%d XPT_GET_TRAN_SETTINGS:.\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sbp
operator|->
name|fd
operator|.
name|dev
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
name|END_DEBUG
comment|/* Disable disconnect and tagged queuing */
name|cts
operator|->
name|valid
init|=
name|CCB_TRANS_DISC_VALID
operator||
name|CCB_TRANS_TQ_VALID
decl_stmt|;
name|cts
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cts
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_ABORT
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UA_ABORT
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|sbp_action1
argument_list|(
name|sim
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_execute_ocb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segments
parameter_list|,
name|int
name|seg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|prev
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"sbp_execute_ocb: error=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ocb
operator|=
operator|(
expr|struct
name|sbp_ocb
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|seg
operator|==
literal|1
condition|)
block|{
comment|/* direct pointer */
name|ocb
operator|->
name|orb
index|[
literal|3
index|]
operator|=
name|htonl
argument_list|(
name|segments
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
operator||=
name|htonl
argument_list|(
name|segments
index|[
literal|0
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seg
operator|>
literal|1
condition|)
block|{
comment|/* page table */
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"sbp_execute_ocb: seg %d"
argument_list|,
name|seg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seg
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|", %tx:%zd"
argument_list|,
name|segments
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|,
name|segments
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|END_DEBUG
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seg
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|segments
index|[
name|i
index|]
expr_stmt|;
if|#
directive|if
literal|1
comment|/* XXX LSI Logic "< 16 byte" bug might be hit */
if|if
condition|(
name|s
operator|->
name|ds_len
operator|<
literal|16
condition|)
name|printf
argument_list|(
literal|"sbp_execute_ocb: warning, "
literal|"segment length(%zd) is less than 16."
literal|"(seg=%d/%d)\n"
argument_list|,
name|s
operator|->
name|ds_len
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|seg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ocb
operator|->
name|ind_ptr
index|[
name|i
index|]
operator|.
name|hi
operator|=
name|htonl
argument_list|(
name|s
operator|->
name|ds_len
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|ind_ptr
index|[
name|i
index|]
operator|.
name|lo
operator|=
name|htonl
argument_list|(
name|s
operator|->
name|ds_addr
argument_list|)
expr_stmt|;
block|}
name|ocb
operator|->
name|orb
index|[
literal|4
index|]
operator||=
name|htonl
argument_list|(
name|ORB_CMD_PTBL
operator||
name|seg
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|=
name|ocb
operator|->
name|ccb
expr_stmt|;
name|prev
operator|=
name|sbp_enqueue_ocb
argument_list|(
name|ocb
operator|->
name|sdev
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|sbp_doorbell
argument_list|(
name|ocb
operator|->
name|sdev
argument_list|)
expr_stmt|;
else|else
name|sbp_orb_pointer
argument_list|(
name|ocb
operator|->
name|sdev
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
comment|/* should call fwohci_intr? */
return|return;
block|}
end_function

begin_function
specifier|static
name|struct
name|sbp_ocb
modifier|*
name|sbp_dequeue_ocb
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|,
name|u_int32_t
name|orb_lo
parameter_list|)
block|{
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|next
decl_stmt|;
name|int
name|s
init|=
name|splfw
argument_list|()
decl_stmt|,
name|order
init|=
literal|0
decl_stmt|;
name|int
name|flags
decl_stmt|;
for|for
control|(
name|ocb
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sdev
operator|->
name|ocbs
argument_list|)
init|;
name|ocb
operator|!=
name|NULL
condition|;
name|ocb
operator|=
name|next
control|)
block|{
name|next
operator|=
name|STAILQ_NEXT
argument_list|(
name|ocb
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
name|flags
operator|=
name|ocb
operator|->
name|flags
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"orb: 0x%tx next: 0x%x, flags %x\n"
argument_list|,
name|vtophys
argument_list|(
operator|&
name|ocb
operator|->
name|orb
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ocb
operator|->
name|orb
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|vtophys
argument_list|(
operator|&
name|ocb
operator|->
name|orb
index|[
literal|0
index|]
argument_list|)
operator|==
name|orb_lo
condition|)
block|{
comment|/* found */
if|if
condition|(
name|ocb
operator|->
name|flags
operator|&
name|OCB_RESERVED
condition|)
name|ocb
operator|->
name|flags
operator||=
name|OCB_DONE
expr_stmt|;
else|else
name|STAILQ_REMOVE
argument_list|(
operator|&
name|sdev
operator|->
name|ocbs
argument_list|,
name|ocb
argument_list|,
name|sbp_ocb
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ocb
operator|->
name|ccb
operator|!=
name|NULL
condition|)
name|untimeout
argument_list|(
name|sbp_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ocb
argument_list|,
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|ocb
operator|->
name|dmamap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|dmat
argument_list|,
name|ocb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|dmamap
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ocb
operator|->
name|flags
operator|&
name|OCB_RESERVED
operator|)
operator|&&
operator|(
name|ocb
operator|->
name|flags
operator|&
name|OCB_DONE
operator|)
condition|)
block|{
comment|/* next orb must be fetched already */
name|STAILQ_REMOVE
argument_list|(
operator|&
name|sdev
operator|->
name|ocbs
argument_list|,
name|ocb
argument_list|,
name|sbp_ocb
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
name|sbp_free_ocb
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
block|}
else|else
name|order
operator|++
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
if|if
condition|(
name|ocb
operator|&&
name|order
operator|>
literal|0
condition|)
block|{
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unordered execution order:%d\n"
argument_list|,
name|order
argument_list|)
expr_stmt|;
block|}
name|END_DEBUG
return|return
operator|(
name|ocb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sbp_ocb
modifier|*
name|sbp_enqueue_ocb
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|,
name|struct
name|sbp_ocb
modifier|*
name|ocb
parameter_list|)
block|{
name|int
name|s
init|=
name|splfw
argument_list|()
decl_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|prev
decl_stmt|;
name|SBP_DEBUG
argument_list|(
literal|2
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_enqueue_ocb orb=0x%tx in physical memory\n"
argument_list|,
name|vtophys
argument_list|(
operator|&
name|ocb
operator|->
name|orb
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|END_DEBUG
name|prev
init|=
name|STAILQ_LAST
argument_list|(
operator|&
name|sdev
operator|->
name|ocbs
argument_list|,
name|sbp_ocb
argument_list|,
name|ocb
argument_list|)
decl_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sdev
operator|->
name|ocbs
argument_list|,
name|ocb
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ocb
operator|->
name|ccb
operator|!=
name|NULL
condition|)
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|sbp_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ocb
argument_list|,
operator|(
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|prev
operator|->
name|flags
operator|&
name|OCB_ACT_MASK
operator|)
operator|==
name|OCB_ACT_CMD
operator|)
operator|&&
operator|(
operator|(
name|ocb
operator|->
name|flags
operator|&
name|OCB_ACT_MASK
operator|)
operator|==
name|OCB_ACT_CMD
operator|)
condition|)
block|{
name|SBP_DEBUG
argument_list|(
literal|1
argument_list|)
name|printf
argument_list|(
literal|"linking chain 0x%tx -> 0x%tx\n"
argument_list|,
name|vtophys
argument_list|(
operator|&
name|prev
operator|->
name|orb
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|vtophys
argument_list|(
operator|&
name|ocb
operator|->
name|orb
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|END_DEBUG
name|prev
operator|->
name|flags
operator||=
name|OCB_RESERVED
expr_stmt|;
name|prev
operator|->
name|orb
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
operator|&
name|ocb
operator|->
name|orb
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|prev
operator|->
name|orb
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|prev
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sbp_ocb
modifier|*
name|sbp_get_ocb
parameter_list|(
name|struct
name|sbp_softc
modifier|*
name|sbp
parameter_list|)
block|{
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|;
name|int
name|s
init|=
name|splfw
argument_list|()
decl_stmt|;
name|ocb
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sbp
operator|->
name|free_ocbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ocb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ocb shortage!!!\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|STAILQ_REMOVE
argument_list|(
operator|&
name|sbp
operator|->
name|free_ocbs
argument_list|,
name|ocb
argument_list|,
name|sbp_ocb
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ocb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_free_ocb
parameter_list|(
name|struct
name|sbp_softc
modifier|*
name|sbp
parameter_list|,
name|struct
name|sbp_ocb
modifier|*
name|ocb
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* XXX make sure that ocb has ccb */
block|if ((sbp->flags& SBP_RESOURCE_SHORTAGE) != 0&& 	    (ocb->ccb->ccb_h.status& CAM_RELEASE_SIMQ) == 0) { 		ocb->ccb->ccb_h.status |= CAM_RELEASE_SIMQ; 		sbp->flags&= ~SBP_RESOURCE_SHORTAGE; 	}
else|#
directive|else
if|if
condition|(
operator|(
name|sbp
operator|->
name|flags
operator|&
name|SBP_RESOURCE_SHORTAGE
operator|)
operator|!=
literal|0
condition|)
name|sbp
operator|->
name|flags
operator|&=
operator|~
name|SBP_RESOURCE_SHORTAGE
expr_stmt|;
endif|#
directive|endif
name|ocb
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ocb
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sbp
operator|->
name|free_ocbs
argument_list|,
name|ocb
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_abort_ocb
parameter_list|(
name|struct
name|sbp_ocb
modifier|*
name|ocb
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|struct
name|sbp_dev
modifier|*
name|sdev
decl_stmt|;
name|sdev
operator|=
name|ocb
operator|->
name|sdev
expr_stmt|;
name|SBP_DEBUG
argument_list|(
literal|0
argument_list|)
name|sbp_show_sdev_info
argument_list|(
name|sdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbp_abort_ocb 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ocb
operator|->
name|ccb
operator|!=
name|NULL
condition|)
name|sbp_print_scsi_cmd
argument_list|(
name|ocb
argument_list|)
expr_stmt|;
name|END_DEBUG
if|if
condition|(
name|ocb
operator|->
name|ccb
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|ocb
operator|->
name|flags
operator|&
name|OCB_DONE
operator|)
condition|)
block|{
if|if
condition|(
name|status
operator|!=
name|CAM_CMD_TIMEOUT
condition|)
name|untimeout
argument_list|(
name|sbp_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ocb
argument_list|,
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|xpt_done
argument_list|(
name|ocb
operator|->
name|ccb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ocb
operator|->
name|dmamap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
operator|->
name|dmat
argument_list|,
name|ocb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|ocb
operator|->
name|dmamap
operator|=
name|NULL
expr_stmt|;
block|}
name|sbp_free_ocb
argument_list|(
name|sdev
operator|->
name|target
operator|->
name|sbp
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbp_abort_all_ocbs
parameter_list|(
name|struct
name|sbp_dev
modifier|*
name|sdev
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|sbp_ocb
modifier|*
name|ocb
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|sbp_ocb
argument_list|)
name|temp
expr_stmt|;
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sdev
operator|->
name|ocbs
argument_list|,
operator|&
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sdev
operator|->
name|ocbs
argument_list|)
expr_stmt|;
for|for
control|(
name|ocb
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|temp
argument_list|)
init|;
name|ocb
operator|!=
name|NULL
condition|;
name|ocb
operator|=
name|next
control|)
block|{
name|next
operator|=
name|STAILQ_NEXT
argument_list|(
name|ocb
argument_list|,
name|ocb
argument_list|)
expr_stmt|;
name|sbp_abort_ocb
argument_list|(
name|ocb
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|devclass_t
name|sbp_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|sbp_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|sbp_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|sbp_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|sbp_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|sbp_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|sbp_driver
init|=
block|{
literal|"sbp"
block|,
name|sbp_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbp_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|sbp
argument_list|,
name|firewire
argument_list|,
name|sbp_driver
argument_list|,
name|sbp_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|sbp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|sbp
argument_list|,
name|firewire
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|sbp
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

