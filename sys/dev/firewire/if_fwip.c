begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004  *	Doug Rabson  * Copyright (c) 2002-2003  * 	Hidetoshi Shimokawa. All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *  *	This product includes software developed by Hidetoshi Shimokawa.  *  * 4. Neither the name of the author nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * $FreeBSD$  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_device_polling.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/firewire.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__DragonFly__
end_ifdef

begin_include
include|#
directive|include
file|<bus/firewire/firewire.h>
end_include

begin_include
include|#
directive|include
file|<bus/firewire/firewirereg.h>
end_include

begin_include
include|#
directive|include
file|"if_fwipvar.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dev/firewire/firewire.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewirereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/iec13213.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/if_fwipvar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * We really need a mechanism for allocating regions in the FIFO  * address space. We pick a address in the OHCI controller's 'middle'  * address space. This means that the controller will automatically  * send responses for us, which is fine since we don't have any  * important information to put in the response anyway.  */
end_comment

begin_define
define|#
directive|define
name|INET_FIFO
value|0xfffe00000000LL
end_define

begin_define
define|#
directive|define
name|FWIPDEBUG
value|if (fwipdebug) if_printf
end_define

begin_define
define|#
directive|define
name|TX_MAX_QUEUE
value|(FWMAXQUEUE - 1)
end_define

begin_comment
comment|/* network interface */
end_comment

begin_function_decl
specifier|static
name|void
name|fwip_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fwip_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwip_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwip_post_busreset
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwip_output_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwip_async_output
parameter_list|(
name|struct
name|fwip_softc
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwip_start_send
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwip_stream_input
parameter_list|(
name|struct
name|fw_xferq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwip_unicast_input
parameter_list|(
name|struct
name|fw_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|fwipdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|broadcast_channel
init|=
literal|0xc0
operator||
literal|0x1f
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  tag | channel(XXX) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tx_speed
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rx_queue_len
init|=
name|FWMAXQUEUE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_FWIP
argument_list|,
literal|"if_fwip"
argument_list|,
literal|"IP over FireWire interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|if_fwip_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fwipdebug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_firewire
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_firewire
argument_list|,
name|OID_AUTO
argument_list|,
name|fwip
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Firewire ip subsystem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_fwip
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_queue_len
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|rx_queue_len
argument_list|,
literal|0
argument_list|,
literal|"Length of the receive queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.firewire.fwip.rx_queue_len"
argument_list|,
operator|&
name|rx_queue_len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_decl_stmt
specifier|static
name|poll_handler_t
name|fwip_poll
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|fwip_poll
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|enum
name|poll_cmd
name|cmd
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|fwip_softc
modifier|*
name|fwip
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return;
name|fwip
operator|=
operator|(
operator|(
expr|struct
name|fwip_eth_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
operator|)
operator|->
name|fwip
expr_stmt|;
name|fc
operator|=
name|fwip
operator|->
name|fd
operator|.
name|fc
expr_stmt|;
name|fc
operator|->
name|poll
argument_list|(
name|fc
argument_list|,
operator|(
name|cmd
operator|==
name|POLL_AND_CHECK_STATUS
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVICE_POLLING */
end_comment

begin_function
specifier|static
name|void
name|fwip_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|"fwip"
argument_list|,
name|device_get_unit
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwip_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|pa
decl_stmt|;
name|pa
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|!=
name|device_get_unit
argument_list|(
name|pa
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"IP over FireWire"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwip_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fwip_softc
modifier|*
name|fwip
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|fw_hwaddr
modifier|*
name|hwaddr
decl_stmt|;
name|fwip
operator|=
operator|(
operator|(
expr|struct
name|fwip_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
operator|)
expr_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|fwip
operator|->
name|fw_softc
operator|.
name|fwip_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_IEEE1394
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* XXX */
name|fwip
operator|->
name|dma_ch
operator|=
operator|-
literal|1
expr_stmt|;
name|fwip
operator|->
name|fd
operator|.
name|fc
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_speed
operator|<
literal|0
condition|)
name|tx_speed
operator|=
name|fwip
operator|->
name|fd
operator|.
name|fc
operator|->
name|speed
expr_stmt|;
name|fwip
operator|->
name|fd
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|fwip
operator|->
name|fd
operator|.
name|post_explore
operator|=
name|NULL
expr_stmt|;
name|fwip
operator|->
name|fd
operator|.
name|post_busreset
operator|=
name|fwip_post_busreset
expr_stmt|;
name|fwip
operator|->
name|fw_softc
operator|.
name|fwip
operator|=
name|fwip
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|fwip
operator|->
name|start_send
argument_list|,
literal|0
argument_list|,
name|fwip_start_send
argument_list|,
name|fwip
argument_list|)
expr_stmt|;
comment|/* 	 * Encode our hardware the way that arp likes it. 	 */
name|hwaddr
operator|=
operator|&
name|IFP2FWC
argument_list|(
name|fwip
operator|->
name|fw_softc
operator|.
name|fwip_ifp
argument_list|)
operator|->
name|fc_hwaddr
expr_stmt|;
name|hwaddr
operator|->
name|sender_unique_ID_hi
operator|=
name|htonl
argument_list|(
name|fwip
operator|->
name|fd
operator|.
name|fc
operator|->
name|eui
operator|.
name|hi
argument_list|)
expr_stmt|;
name|hwaddr
operator|->
name|sender_unique_ID_lo
operator|=
name|htonl
argument_list|(
name|fwip
operator|->
name|fd
operator|.
name|fc
operator|->
name|eui
operator|.
name|lo
argument_list|)
expr_stmt|;
name|hwaddr
operator|->
name|sender_max_rec
operator|=
name|fwip
operator|->
name|fd
operator|.
name|fc
operator|->
name|maxrec
expr_stmt|;
name|hwaddr
operator|->
name|sspd
operator|=
name|fwip
operator|->
name|fd
operator|.
name|fc
operator|->
name|speed
expr_stmt|;
name|hwaddr
operator|->
name|sender_unicast_FIFO_hi
operator|=
name|htons
argument_list|(
call|(
name|uint16_t
call|)
argument_list|(
name|INET_FIFO
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|hwaddr
operator|->
name|sender_unicast_FIFO_lo
operator|=
name|htonl
argument_list|(
operator|(
name|uint32_t
operator|)
name|INET_FIFO
argument_list|)
expr_stmt|;
comment|/* fill the rest and attach interface */
name|ifp
operator|->
name|if_softc
operator|=
operator|&
name|fwip
operator|->
name|fw_softc
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|501113
operator|||
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|unit
argument_list|)
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"fwip"
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_init
operator|=
name|fwip_init
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|fwip_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|fwip_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
operator||
name|IFF_NEEDSGIANT
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|TX_MAX_QUEUE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_POLLING
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|firewire_ifattach
argument_list|(
name|ifp
argument_list|,
name|hwaddr
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|FWIPDEBUG
argument_list|(
name|ifp
argument_list|,
literal|"interface created\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwip_stop
parameter_list|(
name|struct
name|fwip_softc
modifier|*
name|fwip
parameter_list|)
block|{
name|struct
name|firewire_comm
modifier|*
name|fc
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|xferq
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|fwip
operator|->
name|fw_softc
operator|.
name|fwip_ifp
decl_stmt|;
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fc
operator|=
name|fwip
operator|->
name|fd
operator|.
name|fc
expr_stmt|;
if|if
condition|(
name|fwip
operator|->
name|dma_ch
operator|>=
literal|0
condition|)
block|{
name|xferq
operator|=
name|fc
operator|->
name|ir
index|[
name|fwip
operator|->
name|dma_ch
index|]
expr_stmt|;
if|if
condition|(
name|xferq
operator|->
name|flag
operator|&
name|FWXFERQ_RUNNING
condition|)
name|fc
operator|->
name|irx_disable
argument_list|(
name|fc
argument_list|,
name|fwip
operator|->
name|dma_ch
argument_list|)
expr_stmt|;
name|xferq
operator|->
name|flag
operator|&=
operator|~
operator|(
name|FWXFERQ_MODEMASK
operator||
name|FWXFERQ_OPEN
operator||
name|FWXFERQ_STREAM
operator||
name|FWXFERQ_EXTBUF
operator||
name|FWXFERQ_HANDLER
operator||
name|FWXFERQ_CHTAGMASK
operator|)
expr_stmt|;
name|xferq
operator|->
name|hand
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xferq
operator|->
name|bnchunk
condition|;
name|i
operator|++
control|)
name|m_freem
argument_list|(
name|xferq
operator|->
name|bulkxfer
index|[
name|i
index|]
operator|.
name|mbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xferq
operator|->
name|bulkxfer
argument_list|,
name|M_FWIP
argument_list|)
expr_stmt|;
name|fw_bindremove
argument_list|(
name|fc
argument_list|,
operator|&
name|fwip
operator|->
name|fwb
argument_list|)
expr_stmt|;
for|for
control|(
name|xfer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|fwip
operator|->
name|fwb
operator|.
name|xferlist
argument_list|)
init|;
name|xfer
operator|!=
name|NULL
condition|;
name|xfer
operator|=
name|next
control|)
block|{
name|next
operator|=
name|STAILQ_NEXT
argument_list|(
name|xfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|xfer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|fwip
operator|->
name|xferlist
argument_list|)
init|;
name|xfer
operator|!=
name|NULL
condition|;
name|xfer
operator|=
name|next
control|)
block|{
name|next
operator|=
name|STAILQ_NEXT
argument_list|(
name|xfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INIT
argument_list|(
operator|&
name|fwip
operator|->
name|xferlist
argument_list|)
expr_stmt|;
name|xferq
operator|->
name|bulkxfer
operator|=
name|NULL
expr_stmt|;
name|fwip
operator|->
name|dma_ch
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|fwip_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fwip_softc
modifier|*
name|fwip
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|fwip
operator|=
operator|(
expr|struct
name|fwip_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|fwip
operator|->
name|fw_softc
operator|.
name|fwip_ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|fwip_stop
argument_list|(
name|fwip
argument_list|)
expr_stmt|;
name|firewire_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwip_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|fwip_softc
modifier|*
name|fwip
init|=
operator|(
operator|(
expr|struct
name|fwip_eth_softc
operator|*
operator|)
name|arg
operator|)
operator|->
name|fwip
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|fwip
operator|->
name|fw_softc
operator|.
name|fwip_ifp
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|xferq
decl_stmt|;
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FWIPDEBUG
argument_list|(
name|ifp
argument_list|,
literal|"initializing\n"
argument_list|)
expr_stmt|;
name|fc
operator|=
name|fwip
operator|->
name|fd
operator|.
name|fc
expr_stmt|;
define|#
directive|define
name|START
value|0
if|if
condition|(
name|fwip
operator|->
name|dma_ch
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|START
init|;
name|i
operator|<
name|fc
operator|->
name|nisodma
condition|;
name|i
operator|++
control|)
block|{
name|xferq
operator|=
name|fc
operator|->
name|ir
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|xferq
operator|->
name|flag
operator|&
name|FWXFERQ_OPEN
operator|)
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
name|printf
argument_list|(
literal|"no free dma channel\n"
argument_list|)
expr_stmt|;
return|return;
name|found
label|:
name|fwip
operator|->
name|dma_ch
operator|=
name|i
expr_stmt|;
comment|/* allocate DMA channel and init packet mode */
name|xferq
operator|->
name|flag
operator||=
name|FWXFERQ_OPEN
operator||
name|FWXFERQ_EXTBUF
operator||
name|FWXFERQ_HANDLER
operator||
name|FWXFERQ_STREAM
expr_stmt|;
name|xferq
operator|->
name|flag
operator|&=
operator|~
literal|0xff
expr_stmt|;
name|xferq
operator|->
name|flag
operator||=
name|broadcast_channel
operator|&
literal|0xff
expr_stmt|;
comment|/* register fwip_input handler */
name|xferq
operator|->
name|sc
operator|=
operator|(
name|caddr_t
operator|)
name|fwip
expr_stmt|;
name|xferq
operator|->
name|hand
operator|=
name|fwip_stream_input
expr_stmt|;
name|xferq
operator|->
name|bnchunk
operator|=
name|rx_queue_len
expr_stmt|;
name|xferq
operator|->
name|bnpacket
operator|=
literal|1
expr_stmt|;
name|xferq
operator|->
name|psize
operator|=
name|MCLBYTES
expr_stmt|;
name|xferq
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
name|xferq
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|xferq
operator|->
name|bulkxfer
operator|=
operator|(
expr|struct
name|fw_bulkxfer
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fw_bulkxfer
argument_list|)
operator|*
name|xferq
operator|->
name|bnchunk
argument_list|,
name|M_FWIP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|xferq
operator|->
name|bulkxfer
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"if_fwip: malloc failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|STAILQ_INIT
argument_list|(
operator|&
name|xferq
operator|->
name|stvalid
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|xferq
operator|->
name|stfree
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|xferq
operator|->
name|stdma
argument_list|)
expr_stmt|;
name|xferq
operator|->
name|stproc
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xferq
operator|->
name|bnchunk
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
name|m_getcl
argument_list|(
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
else|#
directive|else
name|m_getcl
argument_list|(
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xferq
operator|->
name|bulkxfer
index|[
name|i
index|]
operator|.
name|mbuf
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|xferq
operator|->
name|stfree
argument_list|,
operator|&
name|xferq
operator|->
name|bulkxfer
index|[
name|i
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"fwip_as_input: m_getcl failed\n"
argument_list|)
expr_stmt|;
block|}
name|fwip
operator|->
name|fwb
operator|.
name|start
operator|=
name|INET_FIFO
expr_stmt|;
name|fwip
operator|->
name|fwb
operator|.
name|end
operator|=
name|INET_FIFO
operator|+
literal|16384
expr_stmt|;
comment|/* S3200 packet size */
name|fwip
operator|->
name|fwb
operator|.
name|act_type
operator|=
name|FWACT_XFER
expr_stmt|;
comment|/* pre-allocate xfer */
name|STAILQ_INIT
argument_list|(
operator|&
name|fwip
operator|->
name|fwb
operator|.
name|xferlist
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rx_queue_len
condition|;
name|i
operator|++
control|)
block|{
name|xfer
operator|=
name|fw_xfer_alloc
argument_list|(
name|M_FWIP
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
break|break;
name|m
operator|=
name|m_getcl
argument_list|(
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|recv
operator|.
name|payload
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint32_t
operator|*
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|recv
operator|.
name|pay_len
operator|=
name|MCLBYTES
expr_stmt|;
name|xfer
operator|->
name|hand
operator|=
name|fwip_unicast_input
expr_stmt|;
name|xfer
operator|->
name|fc
operator|=
name|fc
expr_stmt|;
name|xfer
operator|->
name|sc
operator|=
operator|(
name|caddr_t
operator|)
name|fwip
expr_stmt|;
name|xfer
operator|->
name|mbuf
operator|=
name|m
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|fwip
operator|->
name|fwb
operator|.
name|xferlist
argument_list|,
name|xfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|fw_bindadd
argument_list|(
name|fc
argument_list|,
operator|&
name|fwip
operator|->
name|fwb
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|fwip
operator|->
name|xferlist
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_MAX_QUEUE
condition|;
name|i
operator|++
control|)
block|{
name|xfer
operator|=
name|fw_xfer_alloc
argument_list|(
name|M_FWIP
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
break|break;
name|xfer
operator|->
name|send
operator|.
name|spd
operator|=
name|tx_speed
expr_stmt|;
name|xfer
operator|->
name|fc
operator|=
name|fwip
operator|->
name|fd
operator|.
name|fc
expr_stmt|;
name|xfer
operator|->
name|sc
operator|=
operator|(
name|caddr_t
operator|)
name|fwip
expr_stmt|;
name|xfer
operator|->
name|hand
operator|=
name|fwip_output_callback
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|fwip
operator|->
name|xferlist
argument_list|,
name|xfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|xferq
operator|=
name|fc
operator|->
name|ir
index|[
name|fwip
operator|->
name|dma_ch
index|]
expr_stmt|;
name|fwip
operator|->
name|last_dest
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|fwip
operator|->
name|last_dest
operator|.
name|lo
operator|=
literal|0
expr_stmt|;
comment|/* start dma */
if|if
condition|(
operator|(
name|xferq
operator|->
name|flag
operator|&
name|FWXFERQ_RUNNING
operator|)
operator|==
literal|0
condition|)
name|fc
operator|->
name|irx_enable
argument_list|(
name|fc
argument_list|,
name|fwip
operator|->
name|dma_ch
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* attempt to start output */
block|fwip_start(ifp);
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|fwip_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|fwip_softc
modifier|*
name|fwip
init|=
operator|(
operator|(
expr|struct
name|fwip_eth_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
operator|)
operator|->
name|fwip
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
endif|#
directive|endif
name|fwip_init
argument_list|(
operator|&
name|fwip
operator|->
name|fw_softc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
else|#
directive|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
endif|#
directive|endif
name|fwip_stop
argument_list|(
name|fwip
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
break|break;
case|case
name|SIOCSIFCAP
case|:
ifdef|#
directive|ifdef
name|DEVICE_POLLING
block|{
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
init|=
name|fc
operator|=
name|fwip
operator|->
name|fd
operator|.
name|fc
decl_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_reqcap
operator|&
name|IFCAP_POLLING
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
operator|)
condition|)
block|{
name|error
operator|=
name|ether_poll_register
argument_list|(
name|fwip_poll
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Disable interrupts */
name|fc
operator|->
name|set_intr
argument_list|(
name|fc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_POLLING
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|ifr
operator|->
name|ifr_reqcap
operator|&
name|IFCAP_POLLING
operator|)
operator|&&
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|error
operator|=
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Enable interrupts. */
name|fc
operator|->
name|set_intr
argument_list|(
name|fc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_POLLING
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* DEVICE_POLLING */
break|break;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|500000
default|default:
else|#
directive|else
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
endif|#
directive|endif
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|error
operator|=
name|firewire_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwip_post_busreset
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|fwip_softc
modifier|*
name|fwip
init|=
name|arg
decl_stmt|;
name|struct
name|crom_src
modifier|*
name|src
decl_stmt|;
name|struct
name|crom_chunk
modifier|*
name|root
decl_stmt|;
name|src
operator|=
name|fwip
operator|->
name|fd
operator|.
name|fc
operator|->
name|crom_src
expr_stmt|;
name|root
operator|=
name|fwip
operator|->
name|fd
operator|.
name|fc
operator|->
name|crom_root
expr_stmt|;
comment|/* RFC2734 IPv4 over IEEE1394 */
name|bzero
argument_list|(
operator|&
name|fwip
operator|->
name|unit4
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|crom_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|crom_add_chunk
argument_list|(
name|src
argument_list|,
name|root
argument_list|,
operator|&
name|fwip
operator|->
name|unit4
argument_list|,
name|CROM_UDIR
argument_list|)
expr_stmt|;
name|crom_add_entry
argument_list|(
operator|&
name|fwip
operator|->
name|unit4
argument_list|,
name|CSRKEY_SPEC
argument_list|,
name|CSRVAL_IETF
argument_list|)
expr_stmt|;
name|crom_add_simple_text
argument_list|(
name|src
argument_list|,
operator|&
name|fwip
operator|->
name|unit4
argument_list|,
operator|&
name|fwip
operator|->
name|spec4
argument_list|,
literal|"IANA"
argument_list|)
expr_stmt|;
name|crom_add_entry
argument_list|(
operator|&
name|fwip
operator|->
name|unit4
argument_list|,
name|CSRKEY_VER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|crom_add_simple_text
argument_list|(
name|src
argument_list|,
operator|&
name|fwip
operator|->
name|unit4
argument_list|,
operator|&
name|fwip
operator|->
name|ver4
argument_list|,
literal|"IPv4"
argument_list|)
expr_stmt|;
comment|/* RFC3146 IPv6 over IEEE1394 */
name|bzero
argument_list|(
operator|&
name|fwip
operator|->
name|unit6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|crom_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|crom_add_chunk
argument_list|(
name|src
argument_list|,
name|root
argument_list|,
operator|&
name|fwip
operator|->
name|unit6
argument_list|,
name|CROM_UDIR
argument_list|)
expr_stmt|;
name|crom_add_entry
argument_list|(
operator|&
name|fwip
operator|->
name|unit6
argument_list|,
name|CSRKEY_SPEC
argument_list|,
name|CSRVAL_IETF
argument_list|)
expr_stmt|;
name|crom_add_simple_text
argument_list|(
name|src
argument_list|,
operator|&
name|fwip
operator|->
name|unit6
argument_list|,
operator|&
name|fwip
operator|->
name|spec6
argument_list|,
literal|"IANA"
argument_list|)
expr_stmt|;
name|crom_add_entry
argument_list|(
operator|&
name|fwip
operator|->
name|unit6
argument_list|,
name|CSRKEY_VER
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|crom_add_simple_text
argument_list|(
name|src
argument_list|,
operator|&
name|fwip
operator|->
name|unit6
argument_list|,
operator|&
name|fwip
operator|->
name|ver6
argument_list|,
literal|"IPv6"
argument_list|)
expr_stmt|;
name|fwip
operator|->
name|last_dest
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|fwip
operator|->
name|last_dest
operator|.
name|lo
operator|=
literal|0
expr_stmt|;
name|firewire_busreset
argument_list|(
name|fwip
operator|->
name|fw_softc
operator|.
name|fwip_ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwip_output_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|fwip_softc
modifier|*
name|fwip
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|fwip
operator|=
operator|(
expr|struct
name|fwip_softc
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|ifp
operator|=
name|fwip
operator|->
name|fw_softc
operator|.
name|fwip_ifp
expr_stmt|;
comment|/* XXX error check */
name|FWIPDEBUG
argument_list|(
name|ifp
argument_list|,
literal|"resp = %d\n"
argument_list|,
name|xfer
operator|->
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|resp
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|xfer
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|fw_xfer_unload
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|fwip
operator|->
name|xferlist
argument_list|,
name|xfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* for queue full */
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
name|fwip_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwip_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|fwip_softc
modifier|*
name|fwip
init|=
operator|(
operator|(
expr|struct
name|fwip_eth_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
operator|)
operator|->
name|fwip
decl_stmt|;
name|int
name|s
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|FWIPDEBUG
argument_list|(
name|ifp
argument_list|,
literal|"starting\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwip
operator|->
name|dma_ch
operator|<
literal|0
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|FWIPDEBUG
argument_list|(
name|ifp
argument_list|,
literal|"not ready\n"
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
do|do
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|m
operator|!=
name|NULL
condition|)
do|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_len
operator|!=
literal|0
condition|)
name|fwip_async_output
argument_list|(
name|fwip
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Async. stream output */
end_comment

begin_function
specifier|static
name|void
name|fwip_async_output
parameter_list|(
name|struct
name|fwip_softc
modifier|*
name|fwip
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|firewire_comm
modifier|*
name|fc
init|=
name|fwip
operator|->
name|fd
operator|.
name|fc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|struct
name|fw_hwaddr
modifier|*
name|destfw
decl_stmt|;
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|xferq
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|uint16_t
name|nodeid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|xfer
operator|=
name|NULL
expr_stmt|;
name|xferq
operator|=
name|fwip
operator|->
name|fd
operator|.
name|fc
operator|->
name|atq
expr_stmt|;
while|while
condition|(
name|xferq
operator|->
name|queued
operator|<
name|xferq
operator|->
name|maxq
operator|-
literal|1
condition|)
block|{
name|xfer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|fwip
operator|->
name|xferlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"if_fwip: lack of xfer\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 * Dig out the link-level address which 		 * firewire_output got via arp or neighbour 		 * discovery. If we don't have a link-level address, 		 * just stick the thing on the broadcast channel. 		 */
name|mtag
operator|=
name|m_tag_locate
argument_list|(
name|m
argument_list|,
name|MTAG_FIREWIRE
argument_list|,
name|MTAG_FIREWIRE_HWADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|==
name|NULL
condition|)
name|destfw
operator|=
literal|0
expr_stmt|;
else|else
name|destfw
operator|=
operator|(
expr|struct
name|fw_hwaddr
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|fwip
operator|->
name|xferlist
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 		 * We don't do any bpf stuff here - the generic code 		 * in firewire_output gives the packet to bpf before 		 * it adds the link-level encapsulation. 		 */
comment|/* 		 * Put the mbuf in the xfer early in case we hit an 		 * error case below - fwip_output_callback will free 		 * the mbuf. 		 */
name|xfer
operator|->
name|mbuf
operator|=
name|m
expr_stmt|;
comment|/* 		 * We use the arp result (if any) to add a suitable firewire 		 * packet header before handing off to the bus. 		 */
name|fp
operator|=
operator|&
name|xfer
operator|->
name|send
operator|.
name|hdr
expr_stmt|;
name|nodeid
operator|=
name|FWLOCALBUS
operator||
name|fc
operator|->
name|nodeid
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_BCAST
operator|)
operator|||
operator|!
name|destfw
condition|)
block|{
comment|/* 			 * Broadcast packets are sent as GASP packets with 			 * specifier ID 0x00005e, version 1 on the broadcast 			 * channel. To be conservative, we send at the 			 * slowest possible speed. 			 */
name|uint32_t
modifier|*
name|p
decl_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint32_t
operator|*
argument_list|)
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|stream
operator|.
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|stream
operator|.
name|chtag
operator|=
name|broadcast_channel
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|stream
operator|.
name|tcode
operator|=
name|FWTCODE_STREAM
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|stream
operator|.
name|sy
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|send
operator|.
name|spd
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
name|nodeid
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
operator|(
literal|0x5e
operator|<<
literal|24
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Unicast packets are sent as block writes to the 			 * target's unicast fifo address. If we can't 			 * find the node address, we just give up. We 			 * could broadcast it but that might overflow 			 * the packet size limitations due to the 			 * extra GASP header. Note: the hardware 			 * address is stored in network byte order to 			 * make life easier for ARP. 			 */
name|struct
name|fw_device
modifier|*
name|fd
decl_stmt|;
name|struct
name|fw_eui64
name|eui
decl_stmt|;
name|eui
operator|.
name|hi
operator|=
name|ntohl
argument_list|(
name|destfw
operator|->
name|sender_unique_ID_hi
argument_list|)
expr_stmt|;
name|eui
operator|.
name|lo
operator|=
name|ntohl
argument_list|(
name|destfw
operator|->
name|sender_unique_ID_lo
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwip
operator|->
name|last_dest
operator|.
name|hi
operator|!=
name|eui
operator|.
name|hi
operator|||
name|fwip
operator|->
name|last_dest
operator|.
name|lo
operator|!=
name|eui
operator|.
name|lo
condition|)
block|{
name|fd
operator|=
name|fw_noderesolve_eui64
argument_list|(
name|fc
argument_list|,
operator|&
name|eui
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fd
condition|)
block|{
comment|/* error */
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
comment|/* XXX set error code */
name|fwip_output_callback
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fwip
operator|->
name|last_hdr
operator|.
name|mode
operator|.
name|wreqb
operator|.
name|dst
operator|=
name|FWLOCALBUS
operator||
name|fd
operator|->
name|dst
expr_stmt|;
name|fwip
operator|->
name|last_hdr
operator|.
name|mode
operator|.
name|wreqb
operator|.
name|tlrt
operator|=
literal|0
expr_stmt|;
name|fwip
operator|->
name|last_hdr
operator|.
name|mode
operator|.
name|wreqb
operator|.
name|tcode
operator|=
name|FWTCODE_WREQB
expr_stmt|;
name|fwip
operator|->
name|last_hdr
operator|.
name|mode
operator|.
name|wreqb
operator|.
name|pri
operator|=
literal|0
expr_stmt|;
name|fwip
operator|->
name|last_hdr
operator|.
name|mode
operator|.
name|wreqb
operator|.
name|src
operator|=
name|nodeid
expr_stmt|;
name|fwip
operator|->
name|last_hdr
operator|.
name|mode
operator|.
name|wreqb
operator|.
name|dest_hi
operator|=
name|ntohs
argument_list|(
name|destfw
operator|->
name|sender_unicast_FIFO_hi
argument_list|)
expr_stmt|;
name|fwip
operator|->
name|last_hdr
operator|.
name|mode
operator|.
name|wreqb
operator|.
name|dest_lo
operator|=
name|ntohl
argument_list|(
name|destfw
operator|->
name|sender_unicast_FIFO_lo
argument_list|)
expr_stmt|;
name|fwip
operator|->
name|last_hdr
operator|.
name|mode
operator|.
name|wreqb
operator|.
name|extcode
operator|=
literal|0
expr_stmt|;
name|fwip
operator|->
name|last_dest
operator|=
name|eui
expr_stmt|;
block|}
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|=
name|fwip
operator|->
name|last_hdr
operator|.
name|mode
operator|.
name|wreqb
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|xfer
operator|->
name|send
operator|.
name|spd
operator|=
name|min
argument_list|(
name|destfw
operator|->
name|sspd
argument_list|,
name|fc
operator|->
name|speed
argument_list|)
expr_stmt|;
block|}
name|xfer
operator|->
name|send
operator|.
name|pay_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|error
operator|=
name|fw_asyreq
argument_list|(
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EAGAIN
condition|)
block|{
comment|/* 			 * We ran out of tlabels - requeue the packet 			 * for later transmission. 			 */
name|xfer
operator|->
name|mbuf
operator|=
literal|0
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|fwip
operator|->
name|xferlist
argument_list|,
name|xfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* error */
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
comment|/* XXX set error code */
name|fwip_output_callback
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|if (i> 1) 		printf("%d queued\n", i);
endif|#
directive|endif
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|#
directive|if
literal|1
name|xferq
operator|->
name|start
argument_list|(
name|fc
argument_list|)
expr_stmt|;
else|#
directive|else
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi_giant
argument_list|,
operator|&
name|fwip
operator|->
name|start_send
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fwip_start_send
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|fwip_softc
modifier|*
name|fwip
init|=
name|arg
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|fwip
operator|->
name|fd
operator|.
name|fc
operator|->
name|atq
operator|->
name|start
argument_list|(
name|fwip
operator|->
name|fd
operator|.
name|fc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Async. stream output */
end_comment

begin_function
specifier|static
name|void
name|fwip_stream_input
parameter_list|(
name|struct
name|fw_xferq
modifier|*
name|xferq
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|fwip_softc
modifier|*
name|fwip
decl_stmt|;
name|struct
name|fw_bulkxfer
modifier|*
name|sxfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|uint16_t
name|src
decl_stmt|;
name|uint32_t
modifier|*
name|p
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|fwip
operator|=
operator|(
expr|struct
name|fwip_softc
operator|*
operator|)
name|xferq
operator|->
name|sc
expr_stmt|;
name|ifp
operator|=
name|fwip
operator|->
name|fw_softc
operator|.
name|fwip_ifp
expr_stmt|;
while|while
condition|(
operator|(
name|sxfer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|xferq
operator|->
name|stvalid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|xferq
operator|->
name|stvalid
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|fp
operator|=
name|mtod
argument_list|(
name|sxfer
operator|->
name|mbuf
argument_list|,
expr|struct
name|fw_pkt
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwip
operator|->
name|fd
operator|.
name|fc
operator|->
name|irx_post
operator|!=
name|NULL
condition|)
name|fwip
operator|->
name|fd
operator|.
name|fc
operator|->
name|irx_post
argument_list|(
name|fwip
operator|->
name|fd
operator|.
name|fc
argument_list|,
name|fp
operator|->
name|mode
operator|.
name|ld
argument_list|)
expr_stmt|;
name|m
operator|=
name|sxfer
operator|->
name|mbuf
expr_stmt|;
comment|/* insert new rbuf */
name|sxfer
operator|->
name|mbuf
operator|=
name|m0
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|!=
name|NULL
condition|)
block|{
name|m0
operator|->
name|m_len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m0
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|xferq
operator|->
name|stfree
argument_list|,
name|sxfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"fwip_as_input: m_getcl failed\n"
argument_list|)
expr_stmt|;
comment|/* 		 * We must have a GASP header - leave the 		 * encapsulation sanity checks to the generic 		 * code. Remeber that we also have the firewire async 		 * stream header even though that isn't accounted for 		 * in mode.stream.len. 		 */
if|if
condition|(
name|sxfer
operator|->
name|resp
operator|!=
literal|0
operator|||
name|fp
operator|->
name|mode
operator|.
name|stream
operator|.
name|len
operator|<
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
continue|continue;
block|}
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|fp
operator|->
name|mode
operator|.
name|stream
operator|.
name|len
operator|+
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|mode
operator|.
name|stream
argument_list|)
expr_stmt|;
comment|/* 		 * If we received the packet on the broadcast channel, 		 * mark it as broadcast, otherwise we assume it must 		 * be multicast. 		 */
if|if
condition|(
name|fp
operator|->
name|mode
operator|.
name|stream
operator|.
name|chtag
operator|==
name|broadcast_channel
condition|)
name|m
operator|->
name|m_flags
operator||=
name|M_BCAST
expr_stmt|;
else|else
name|m
operator|->
name|m_flags
operator||=
name|M_MCAST
expr_stmt|;
comment|/* 		 * Make sure we recognise the GASP specifier and 		 * version. 		 */
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint32_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|ntohl
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|&
literal|0xffff
operator|)
operator|<<
literal|8
operator|)
operator||
name|ntohl
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
operator|>>
literal|24
operator|)
operator|!=
literal|0x00005e
operator|||
operator|(
name|ntohl
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
operator|&
literal|0xffffff
operator|)
operator|!=
literal|1
condition|)
block|{
name|FWIPDEBUG
argument_list|(
name|ifp
argument_list|,
literal|"Unrecognised GASP header %#08x %#08x\n"
argument_list|,
name|ntohl
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Record the sender ID for possible BPF usage. 		 */
name|src
operator|=
name|ntohl
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|bpf_peers_present
argument_list|(
name|ifp
operator|->
name|if_bpf
argument_list|)
condition|)
block|{
name|mtag
operator|=
name|m_tag_alloc
argument_list|(
name|MTAG_FIREWIRE
argument_list|,
name|MTAG_FIREWIRE_SENDER_EUID
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
condition|)
block|{
comment|/* bpf wants it in network byte order */
name|struct
name|fw_device
modifier|*
name|fd
decl_stmt|;
name|uint32_t
modifier|*
name|p
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
decl_stmt|;
name|fd
operator|=
name|fw_noderesolve_nodeid
argument_list|(
name|fwip
operator|->
name|fd
operator|.
name|fc
argument_list|,
name|src
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
name|fd
operator|->
name|eui
operator|.
name|hi
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
name|fd
operator|->
name|eui
operator|.
name|lo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|m_tag_prepend
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Trim off the GASP header 		 */
name|m_adj
argument_list|(
name|m
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|firewire_input
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|xferq
operator|->
name|stfree
argument_list|)
operator|!=
name|NULL
condition|)
name|fwip
operator|->
name|fd
operator|.
name|fc
operator|->
name|irx_enable
argument_list|(
name|fwip
operator|->
name|fd
operator|.
name|fc
argument_list|,
name|fwip
operator|->
name|dma_ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|fwip_unicast_input_recycle
parameter_list|(
name|struct
name|fwip_softc
modifier|*
name|fwip
parameter_list|,
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
comment|/* 	 * We have finished with a unicast xfer. Allocate a new 	 * cluster and stick it on the back of the input queue. 	 */
name|m
operator|=
name|m_getcl
argument_list|(
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|mbuf
operator|=
name|m
expr_stmt|;
name|xfer
operator|->
name|recv
operator|.
name|payload
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint32_t
operator|*
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|recv
operator|.
name|pay_len
operator|=
name|MCLBYTES
expr_stmt|;
name|xfer
operator|->
name|mbuf
operator|=
name|m
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|fwip
operator|->
name|fwb
operator|.
name|xferlist
argument_list|,
name|xfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwip_unicast_input
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|uint64_t
name|address
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|fwip_softc
modifier|*
name|fwip
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
comment|//struct fw_pkt *sfp;
name|int
name|rtcode
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|fwip
operator|=
operator|(
expr|struct
name|fwip_softc
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|ifp
operator|=
name|fwip
operator|->
name|fw_softc
operator|.
name|fwip_ifp
expr_stmt|;
name|m
operator|=
name|xfer
operator|->
name|mbuf
expr_stmt|;
name|xfer
operator|->
name|mbuf
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
operator|&
name|xfer
operator|->
name|recv
operator|.
name|hdr
expr_stmt|;
comment|/* 	 * Check the fifo address - we only accept addresses of 	 * exactly INET_FIFO. 	 */
name|address
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|dest_hi
operator|<<
literal|32
operator|)
operator||
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|dest_lo
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|tcode
operator|!=
name|FWTCODE_WREQB
condition|)
block|{
name|rtcode
operator|=
name|FWRCODE_ER_TYPE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|address
operator|!=
name|INET_FIFO
condition|)
block|{
name|rtcode
operator|=
name|FWRCODE_ER_ADDR
expr_stmt|;
block|}
else|else
block|{
name|rtcode
operator|=
name|FWRCODE_COMPLETE
expr_stmt|;
block|}
comment|/* 	 * Pick up a new mbuf and stick it on the back of the receive 	 * queue. 	 */
name|fwip_unicast_input_recycle
argument_list|(
name|fwip
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
comment|/* 	 * If we've already rejected the packet, give up now. 	 */
if|if
condition|(
name|rtcode
operator|!=
name|FWRCODE_COMPLETE
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bpf_peers_present
argument_list|(
name|ifp
operator|->
name|if_bpf
argument_list|)
condition|)
block|{
comment|/* 		 * Record the sender ID for possible BPF usage. 		 */
name|mtag
operator|=
name|m_tag_alloc
argument_list|(
name|MTAG_FIREWIRE
argument_list|,
name|MTAG_FIREWIRE_SENDER_EUID
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
condition|)
block|{
comment|/* bpf wants it in network byte order */
name|struct
name|fw_device
modifier|*
name|fd
decl_stmt|;
name|uint32_t
modifier|*
name|p
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
decl_stmt|;
name|fd
operator|=
name|fw_noderesolve_nodeid
argument_list|(
name|fwip
operator|->
name|fd
operator|.
name|fc
argument_list|,
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|src
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
name|fd
operator|->
name|eui
operator|.
name|hi
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
name|fd
operator|->
name|eui
operator|.
name|lo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|m_tag_prepend
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Hand off to the generic encapsulation code. We don't use 	 * ifp->if_input so that we can pass the source nodeid as an 	 * argument to facilitate link-level fragment reassembly. 	 */
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|firewire_input
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|fp
operator|->
name|mode
operator|.
name|wreqb
operator|.
name|src
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|devclass_t
name|fwip_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|fwip_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|fwip_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|fwip_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|fwip_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|fwip_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|fwip_driver
init|=
block|{
literal|"fwip"
block|,
name|fwip_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|fwip_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__DragonFly__
end_ifdef

begin_expr_stmt
name|DECLARE_DUMMY_MODULE
argument_list|(
name|fwip
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|fwip
argument_list|,
name|firewire
argument_list|,
name|fwip_driver
argument_list|,
name|fwip_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|fwip
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|fwip
argument_list|,
name|firewire
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

