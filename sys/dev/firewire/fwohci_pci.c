begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 Hidetoshi Shimokawa  * Copyright (c) 1998-2002 Katsushi Kobayashi and Hidetoshi Shimokawa  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the acknowledgement as bellow:  *  *    This product includes software developed by K. Kobayashi and H. SHimokawa  *  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *   * $FreeBSD$  */
end_comment

begin_define
define|#
directive|define
name|BOUNCE_BUFFER_TEST
value|0
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|501102
end_if

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__DragonFly__
end_ifdef

begin_include
include|#
directive|include
file|<bus/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<bus/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|"firewire.h"
end_include

begin_include
include|#
directive|include
file|"firewirereg.h"
end_include

begin_include
include|#
directive|include
file|"fwdma.h"
end_include

begin_include
include|#
directive|include
file|"fwohcireg.h"
end_include

begin_include
include|#
directive|include
file|"fwohcivar.h"
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/firewire/firewire.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewirereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/fwdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/fwohcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/fwohcivar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|fwohci_pci_attach
parameter_list|(
name|device_t
name|self
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fwohci_pci_detach
parameter_list|(
name|device_t
name|self
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * The probe routine.  */
end_comment

begin_function
specifier|static
name|int
name|fwohci_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|#
directive|if
literal|1
name|uint32_t
name|id
decl_stmt|;
name|id
operator|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_NATSEMI
operator||
name|FW_DEVICE_CS4210
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"National Semiconductor CS4210"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_NEC
operator||
name|FW_DEVICE_UPD861
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"NEC uPD72861"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_NEC
operator||
name|FW_DEVICE_UPD871
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"NEC uPD72871/2"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_NEC
operator||
name|FW_DEVICE_UPD72870
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"NEC uPD72870"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_NEC
operator||
name|FW_DEVICE_UPD72873
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"NEC uPD72873"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_NEC
operator||
name|FW_DEVICE_UPD72874
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"NEC uPD72874"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_SIS
operator||
name|FW_DEVICE_7007
operator|)
condition|)
block|{
comment|/* It has no real identifier, using device id. */
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"SiS 7007"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_TI
operator||
name|FW_DEVICE_TITSB22
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Texas Instruments TSB12LV22"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_TI
operator||
name|FW_DEVICE_TITSB23
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Texas Instruments TSB12LV23"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_TI
operator||
name|FW_DEVICE_TITSB26
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Texas Instruments TSB12LV26"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_TI
operator||
name|FW_DEVICE_TITSB43
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Texas Instruments TSB43AA22"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_TI
operator||
name|FW_DEVICE_TITSB43A
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Texas Instruments TSB43AB22/A"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_TI
operator||
name|FW_DEVICE_TITSB43AB21
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Texas Instruments TSB43AB21/A/AI/A-EP"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_TI
operator||
name|FW_DEVICE_TITSB43AB23
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Texas Instruments TSB43AB23"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_TI
operator||
name|FW_DEVICE_TITSB82AA2
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Texas Instruments TSB82AA2"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_TI
operator||
name|FW_DEVICE_TIPCI4450
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Texas Instruments PCI4450"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_TI
operator||
name|FW_DEVICE_TIPCI4410A
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Texas Instruments PCI4410A"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_TI
operator||
name|FW_DEVICE_TIPCI4451
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Texas Instruments PCI4451"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_SONY
operator||
name|FW_DEVICE_CXD1947
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Sony i.LINK (CXD1947) not supported\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_SONY
operator||
name|FW_DEVICE_CXD3222
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Sony i.LINK (CXD3222)"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_VIA
operator||
name|FW_DEVICE_VT6306
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"VIA Fire II (VT6306)"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_RICOH
operator||
name|FW_DEVICE_R5C551
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Ricoh R5C551"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_RICOH
operator||
name|FW_DEVICE_R5C552
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Ricoh R5C552"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_APPLE
operator||
name|FW_DEVICE_PANGEA
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Apple Pangea"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_APPLE
operator||
name|FW_DEVICE_UNINORTH
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Apple UniNorth"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_LUCENT
operator||
name|FW_DEVICE_FW322
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Lucent FW322/323"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_INTEL
operator||
name|FW_DEVICE_82372FB
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Intel 82372FB"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_ADAPTEC
operator||
name|FW_DEVICE_AIC5800
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Adaptec AHA-894x/AIC-5800"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_SUN
operator||
name|FW_DEVICE_PCIO2FW
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Sun PCIO-2"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|pci_get_class
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIC_SERIALBUS
operator|&&
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIS_SERIALBUS_FW
operator|&&
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_INTERFACE_OHCI
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"vendor=%x, dev=%x\n"
argument_list|,
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_device
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"1394 Open Host Controller Interface"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_function
specifier|static
name|void
name|fwohci_dummy_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* XXX do nothing */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|fwohci_pci_init
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|int
name|olatency
decl_stmt|,
name|latency
decl_stmt|,
name|ocache_line
decl_stmt|,
name|cache_line
decl_stmt|;
name|uint16_t
name|cmd
decl_stmt|;
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|self
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator||
name|PCIM_CMD_MWRICEN
expr_stmt|;
if|#
directive|if
literal|1
comment|/* for broken hardware */
name|cmd
operator|&=
operator|~
name|PCIM_CMD_MWRICEN
expr_stmt|;
endif|#
directive|endif
name|pci_write_config
argument_list|(
name|self
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Some Sun PCIO-2 FireWire controllers have their intpin register 	 * bogusly set to 0, although it should be 3. Correct that. 	 */
if|if
condition|(
name|pci_get_devid
argument_list|(
name|self
argument_list|)
operator|==
operator|(
name|FW_VENDORID_SUN
operator||
name|FW_DEVICE_PCIO2FW
operator|)
operator|&&
name|pci_get_intpin
argument_list|(
name|self
argument_list|)
operator|==
literal|0
condition|)
name|pci_set_intpin
argument_list|(
name|self
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|latency
operator|=
name|olatency
operator|=
name|pci_read_config
argument_list|(
name|self
argument_list|,
name|PCIR_LATTIMER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
define|#
directive|define
name|DEF_LATENCY
value|0x20
if|if
condition|(
name|olatency
operator|<
name|DEF_LATENCY
condition|)
block|{
name|latency
operator|=
name|DEF_LATENCY
expr_stmt|;
name|pci_write_config
argument_list|(
name|self
argument_list|,
name|PCIR_LATTIMER
argument_list|,
name|latency
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|cache_line
operator|=
name|ocache_line
operator|=
name|pci_read_config
argument_list|(
name|self
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
define|#
directive|define
name|DEF_CACHE_LINE
value|8
if|if
condition|(
name|ocache_line
operator|<
name|DEF_CACHE_LINE
condition|)
block|{
name|cache_line
operator|=
name|DEF_CACHE_LINE
expr_stmt|;
name|pci_write_config
argument_list|(
name|self
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
name|cache_line
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|firewire_debug
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"latency timer %d -> %d.\n"
argument_list|,
name|olatency
argument_list|,
name|latency
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"cache size %d -> %d.\n"
argument_list|,
name|ocache_line
argument_list|,
name|cache_line
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_pci_attach
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|fwohci_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|self
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|rid
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
name|int
name|intr
decl_stmt|;
comment|/* For the moment, put in a message stating what is wrong */
name|intr
operator|=
name|pci_read_config
argument_list|(
name|self
argument_list|,
name|PCIR_INTLINE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|intr
operator|==
literal|0
operator|||
name|intr
operator|==
literal|255
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"Invalid irq %d\n"
argument_list|,
name|intr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__i386__
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"Please switch PNP-OS to 'No' in BIOS\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
if|#
directive|if
literal|0
block|if (bootverbose) 		firewire_debug = bootverbose;
endif|#
directive|endif
name|mtx_init
argument_list|(
name|FW_GMTX
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|)
argument_list|,
literal|"firewire"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|fwohci_pci_init
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|rid
operator|=
name|PCI_CBMEM
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502109
name|sc
operator|->
name|bsr
operator|=
name|bus_alloc_resource_any
argument_list|(
name|self
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|bsr
operator|=
name|bus_alloc_resource
argument_list|(
name|self
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|sc
operator|->
name|bsr
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"Could not map memory\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|sc
operator|->
name|bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|bsr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|bsr
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502109
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|self
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource
argument_list|(
name|self
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"Could not allocate irq\n"
argument_list|)
expr_stmt|;
name|fwohci_pci_detach
argument_list|(
name|self
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|self
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
operator|(
name|driver_intr_t
operator|*
operator|)
name|fwohci_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
comment|/* XXX splcam() should mask this irq for sbp.c*/
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|self
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_CAM
argument_list|,
operator|(
name|driver_intr_t
operator|*
operator|)
name|fwohci_dummy_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih_cam
argument_list|)
expr_stmt|;
comment|/* XXX splbio() should mask this irq for physio()/fwmem_strategy() */
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|self
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_BIO
argument_list|,
operator|(
name|driver_intr_t
operator|*
operator|)
name|fwohci_dummy_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih_bio
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"Could not setup irq, %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|fwohci_pci_detach
argument_list|(
name|self
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|700020
comment|/*parent*/
name|bus_get_dma_tag
argument_list|(
name|self
argument_list|)
argument_list|,
else|#
directive|else
comment|/*parent*/
name|NULL
argument_list|,
endif|#
directive|endif
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
if|#
directive|if
name|BOUNCE_BUFFER_TEST
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_24BIT
argument_list|,
else|#
directive|else
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
endif|#
directive|endif
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
literal|0x100000
argument_list|,
comment|/*nsegments*/
literal|0x20
argument_list|,
comment|/*maxsegsz*/
literal|0x8000
argument_list|,
comment|/*flags*/
name|BUS_DMA_ALLOCNOW
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|501102
comment|/*lockfunc*/
name|busdma_lock_mutex
argument_list|,
comment|/*lockarg*/
name|FW_GMTX
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|)
argument_list|,
endif|#
directive|endif
operator|&
name|sc
operator|->
name|fc
operator|.
name|dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"fwohci_pci_attach: Could not allocate DMA tag "
literal|"- error %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|err
operator|=
name|fwohci_init
argument_list|(
name|sc
argument_list|,
name|self
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"fwohci_init failed with err=%d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|fwohci_pci_detach
argument_list|(
name|self
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* probe and attach a child device(firewire) */
name|bus_generic_probe
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|self
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_pci_detach
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|fwohci_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|self
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bsr
condition|)
name|fwohci_stop
argument_list|(
name|sc
argument_list|,
name|self
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|self
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fc
operator|.
name|bdev
condition|)
block|{
name|device_delete_child
argument_list|(
name|self
argument_list|,
name|sc
operator|->
name|fc
operator|.
name|bdev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|bdev
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* disable interrupts that might have been switched on */
if|if
condition|(
name|sc
operator|->
name|bst
operator|&&
name|sc
operator|->
name|bsh
condition|)
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|bst
argument_list|,
name|sc
operator|->
name|bsh
argument_list|,
name|FWOHCI_INTMASKCLR
argument_list|,
name|OHCI_INT_EN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
condition|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|ih
condition|)
block|{
name|err
operator|=
name|bus_teardown_intr
argument_list|(
name|self
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"Could not tear down irq, %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
name|bus_teardown_intr
argument_list|(
name|self
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|ih_cam
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|self
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|ih_bio
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|ih
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_release_resource
argument_list|(
name|self
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|bsr
condition|)
block|{
name|bus_release_resource
argument_list|(
name|self
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCI_CBMEM
argument_list|,
name|sc
operator|->
name|bsr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bsr
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|bst
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bsh
operator|=
literal|0
expr_stmt|;
block|}
name|fwohci_detach
argument_list|(
name|sc
argument_list|,
name|self
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
name|FW_GMTX
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_pci_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|fwohci_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"fwohci_pci_suspend\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|fwohci_stop
argument_list|(
name|sc
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_pci_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|fwohci_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|fwohci_pci_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fwohci_resume
argument_list|(
name|sc
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_pci_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|fwohci_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_generic_shutdown
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fwohci_stop
argument_list|(
name|sc
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|device_t
name|fwohci_pci_add_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|order
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
name|name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
return|return
operator|(
name|child
operator|)
return|;
name|sc
operator|->
name|fc
operator|.
name|bdev
operator|=
name|child
expr_stmt|;
name|device_set_ivars
argument_list|(
name|child
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|fc
argument_list|)
expr_stmt|;
name|err
operator|=
name|device_probe_and_attach
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"probe_and_attach failed with err=%d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|fwohci_pci_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* XXX 	 * Clear the bus reset event flag to start transactions even when 	 * interrupt is disabled during the boot process. 	 */
if|if
condition|(
name|cold
condition|)
block|{
name|int
name|s
decl_stmt|;
name|DELAY
argument_list|(
literal|250
argument_list|)
expr_stmt|;
comment|/* 2 cycles */
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|fwohci_poll
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|child
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|fwohci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|fwohci_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|fwohci_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|fwohci_pci_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|fwohci_pci_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|fwohci_pci_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|fwohci_pci_shutdown
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_add_child
argument_list|,
name|fwohci_pci_add_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|fwohci_driver
init|=
block|{
literal|"fwohci"
block|,
name|fwohci_methods
block|,
sizeof|sizeof
argument_list|(
name|fwohci_softc_t
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|fwohci_devclass
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|FWOHCI_MODULE
end_ifdef

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|fwohci
argument_list|,
name|firewire
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|fwohci
argument_list|,
name|pci
argument_list|,
name|fwohci_driver
argument_list|,
name|fwohci_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

