begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998-2002 Katsushi Kobayashi and Hidetoshi Shimokawa  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the acknowledgement as bellow:  *  *    This product includes software developed by K. Kobayashi and H. SHimokawa  *  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *   * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewire.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewirereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/fwohcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/fwohcivar.h>
end_include

begin_function_decl
specifier|static
name|int
name|fwohci_pci_attach
parameter_list|(
name|device_t
name|self
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fwohci_pci_detach
parameter_list|(
name|device_t
name|self
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * The probe routine.  */
end_comment

begin_function
specifier|static
name|int
name|fwohci_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|#
directive|if
literal|1
name|u_int32_t
name|id
decl_stmt|;
name|id
operator|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_NEC
operator||
name|FW_DEVICE_UPD861
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"NEC uPD72861"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_NEC
operator||
name|FW_DEVICE_UPD871
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"NEC uPD72871/2"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_TI
operator||
name|FW_DEVICE_TITSB22
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Texas Instruments TSB12LV22"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_TI
operator||
name|FW_DEVICE_TITSB23
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Texas Instruments TSB12LV23"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_TI
operator||
name|FW_DEVICE_TITSB26
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Texas Instruments TSB12LV26"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_TI
operator||
name|FW_DEVICE_TITSB43
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Texas Instruments TSB43AA22"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_TI
operator||
name|FW_DEVICE_TITSB43A
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Texas Instruments TSB43AB22/A"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_TI
operator||
name|FW_DEVICE_TIPCI4450
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Texas Instruments PCI4450"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_TI
operator||
name|FW_DEVICE_TIPCI4410A
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Texas Instruments PCI4410A"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_SONY
operator||
name|FW_DEVICE_CX3022
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"SONY CX3022"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_VIA
operator||
name|FW_DEVICE_VT6306
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"VIA VT6306"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_RICOH
operator||
name|FW_DEVICE_R5C552
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Ricoh R5C552"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_APPLE
operator||
name|FW_DEVICE_PANGEA
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Apple Pangea"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_APPLE
operator||
name|FW_DEVICE_UNINORTH
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Apple UniNorth"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|id
operator|==
operator|(
name|FW_VENDORID_LUCENT
operator||
name|FW_DEVICE_FW322
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Lucent FW322/323"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|pci_get_class
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIC_SERIALBUS
operator|&&
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIS_SERIALBUS_FW
operator|&&
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_INTERFACE_OHCI
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"vendor=%x, dev=%x\n"
argument_list|,
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_device
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"1394 Open Host Controller Interface"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_function
specifier|static
name|void
name|fwohci_dummy_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* XXX do nothing */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|fwohci_pci_init
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|int
name|latency
decl_stmt|,
name|cache_line
decl_stmt|;
name|u_int16_t
name|cmd
decl_stmt|;
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|self
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator||
name|PCIM_CMD_MWRICEN
expr_stmt|;
if|#
directive|if
literal|1
name|cmd
operator|&=
operator|~
name|PCIM_CMD_MWRICEN
expr_stmt|;
endif|#
directive|endif
name|pci_write_config
argument_list|(
name|self
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|latency
operator|=
name|pci_read_config
argument_list|(
name|self
argument_list|,
name|PCIR_LATTIMER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
define|#
directive|define
name|DEF_LATENCY
value|0x20
if|if
condition|(
name|latency
operator|<
name|DEF_LATENCY
condition|)
block|{
name|latency
operator|=
name|DEF_LATENCY
expr_stmt|;
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"PCI bus latency was changing to"
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|self
argument_list|,
name|PCIR_LATTIMER
argument_list|,
name|latency
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"PCI bus latency is"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|latency
argument_list|)
expr_stmt|;
name|cache_line
operator|=
name|pci_read_config
argument_list|(
name|self
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
define|#
directive|define
name|DEF_CACHE_LINE
value|0xc
block|cache_line = DEF_CACHE_LINE; 	pci_write_config(self, PCIR_CACHELNSZ, cache_line, 1);
endif|#
directive|endif
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"cache size %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|cache_line
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_pci_attach
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|fwohci_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|self
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|s
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|int
name|intr
decl_stmt|;
comment|/* For the moment, put in a message stating what is wrong */
name|intr
operator|=
name|pci_read_config
argument_list|(
name|self
argument_list|,
name|PCIR_INTLINE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|intr
operator|==
literal|0
operator|||
name|intr
operator|==
literal|255
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"Invalid irq %d\n"
argument_list|,
name|intr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__i386__
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"Please switch PNP-OS to 'No' in BIOS\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|return ENXIO;
endif|#
directive|endif
block|}
endif|#
directive|endif
name|fwohci_pci_init
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|rid
operator|=
name|PCI_CBMEM
expr_stmt|;
name|sc
operator|->
name|bsr
operator|=
name|bus_alloc_resource
argument_list|(
name|self
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|bsr
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"Could not map memory\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|sc
operator|->
name|bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|bsr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|bsr
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource
argument_list|(
name|self
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"Could not allocate irq\n"
argument_list|)
expr_stmt|;
name|fwohci_pci_detach
argument_list|(
name|self
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|sc
operator|->
name|fc
operator|.
name|bdev
operator|=
name|device_add_child
argument_list|(
name|self
argument_list|,
literal|"firewire"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|fc
operator|.
name|bdev
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"Could not add firewire device\n"
argument_list|)
expr_stmt|;
name|fwohci_pci_detach
argument_list|(
name|self
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|device_set_ivars
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|bdev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|self
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_NET
argument_list|,
operator|(
name|driver_intr_t
operator|*
operator|)
name|fwohci_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
comment|/* XXX splcam() should mask this irq for sbp.c*/
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|self
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_CAM
argument_list|,
operator|(
name|driver_intr_t
operator|*
operator|)
name|fwohci_dummy_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih_cam
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"Could not setup irq, %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|fwohci_pci_detach
argument_list|(
name|self
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|err
operator|=
name|fwohci_init
argument_list|(
name|sc
argument_list|,
name|self
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|device_probe_and_attach
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|bdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"FireWire init failed\n"
argument_list|)
expr_stmt|;
name|fwohci_pci_detach
argument_list|(
name|self
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* XXX 	 * Clear the bus reset event flag to start transactions even when 	 * interrupt is disabled during the boot process. 	 */
if|#
directive|if
literal|0
block|DELAY(100);
endif|#
directive|endif
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|fwohci_intr
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_pci_detach
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|fwohci_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|self
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|fwohci_stop
argument_list|(
name|sc
argument_list|,
name|self
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|self
argument_list|)
expr_stmt|;
comment|/* disable interrupts that might have been switched on */
if|if
condition|(
name|sc
operator|->
name|bst
operator|&&
name|sc
operator|->
name|bsh
condition|)
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|bst
argument_list|,
name|sc
operator|->
name|bsh
argument_list|,
name|FWOHCI_INTMASKCLR
argument_list|,
name|OHCI_INT_EN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
condition|)
block|{
name|int
name|err
init|=
name|bus_teardown_intr
argument_list|(
name|self
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
comment|/* XXX or should we panic? */
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"Could not tear down irq, %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|err
operator|=
name|bus_teardown_intr
argument_list|(
name|self
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|ih_cam
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|ih
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|fc
operator|.
name|bdev
condition|)
block|{
name|device_delete_child
argument_list|(
name|self
argument_list|,
name|sc
operator|->
name|fc
operator|.
name|bdev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|bdev
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|irq_res
condition|)
block|{
name|bus_release_resource
argument_list|(
name|self
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|bsr
condition|)
block|{
name|bus_release_resource
argument_list|(
name|self
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCI_CBMEM
argument_list|,
name|sc
operator|->
name|bsr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bsr
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|bst
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bsh
operator|=
literal|0
expr_stmt|;
block|}
name|fwohci_detach
argument_list|(
name|sc
argument_list|,
name|self
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_pci_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"fwohci_pci_suspend\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* fwohci_stop(dev); */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_pci_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|fwohci_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"fwohci_pci_resume: power_state = 0x%08x\n"
argument_list|,
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|fwohci_pci_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fwohci_resume
argument_list|(
name|sc
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_pci_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|fwohci_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_generic_shutdown
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fwohci_stop
argument_list|(
name|sc
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|fwohci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|fwohci_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|fwohci_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|fwohci_pci_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|fwohci_pci_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|fwohci_pci_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|fwohci_pci_shutdown
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|fwohci_driver
init|=
block|{
literal|"fwohci"
block|,
name|fwohci_methods
block|,
sizeof|sizeof
argument_list|(
name|fwohci_softc_t
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|fwohci_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|fwohci
argument_list|,
name|pci
argument_list|,
name|fwohci_driver
argument_list|,
name|fwohci_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|fwohci
argument_list|,
name|cardbus
argument_list|,
name|fwohci_driver
argument_list|,
name|fwohci_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

