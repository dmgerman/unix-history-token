begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2003 Hidetoshi Shimokawa  * Copyright (c) 1998-2002 Katsushi Kobayashi and Hidetoshi Shimokawa  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the acknowledgement as bellow:  *  *    This product includes software developed by K. Kobayashi and H. Shimokawa  *  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *   * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewire.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewirereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/fwdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/fwmem.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/iec68113.h>
end_include

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|127
end_define

begin_define
define|#
directive|define
name|FWNODE_INVAL
value|0xffff
end_define

begin_decl_stmt
specifier|static
name|d_open_t
name|fw_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|fw_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|fw_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|fw_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|fw_read
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for Isochronous packet */
end_comment

begin_decl_stmt
specifier|static
name|d_write_t
name|fw_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_mmap_t
name|fw_mmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cdevsw
name|firewire_cdevsw
init|=
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500104
operator|.
name|d_open
operator|=
name|fw_open
block|,
operator|.
name|d_close
operator|=
name|fw_close
block|,
operator|.
name|d_read
operator|=
name|fw_read
block|,
operator|.
name|d_write
operator|=
name|fw_write
block|,
operator|.
name|d_ioctl
operator|=
name|fw_ioctl
block|,
operator|.
name|d_poll
operator|=
name|fw_poll
block|,
operator|.
name|d_mmap
operator|=
name|fw_mmap
block|,
operator|.
name|d_name
operator|=
literal|"fw"
block|,
operator|.
name|d_maj
operator|=
name|CDEV_MAJOR
block|,
operator|.
name|d_flags
operator|=
name|D_MEM
else|#
directive|else
name|fw_open
block|,
name|fw_close
block|,
name|fw_read
block|,
name|fw_write
block|,
name|fw_ioctl
block|,
name|fw_poll
block|,
name|fw_mmap
block|,
name|nostrategy
block|,
literal|"fw"
block|,
name|CDEV_MAJOR
block|,
name|nodump
block|,
name|nopsize
block|,
name|D_MEM
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|fw_drv1
block|{
name|struct
name|fw_xferq
modifier|*
name|ir
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|it
decl_stmt|;
name|struct
name|fw_isobufreq
name|bufreq
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|fwdev_allocbuf
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|struct
name|fw_xferq
modifier|*
name|q
parameter_list|,
name|struct
name|fw_bufspec
modifier|*
name|b
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|flag
operator|&
operator|(
name|FWXFERQ_RUNNING
operator||
name|FWXFERQ_EXTBUF
operator|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|q
operator|->
name|bulkxfer
operator|=
operator|(
expr|struct
name|fw_bulkxfer
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fw_bulkxfer
argument_list|)
operator|*
name|b
operator|->
name|nchunk
argument_list|,
name|M_FW
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|bulkxfer
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|b
operator|->
name|psize
operator|=
name|roundup2
argument_list|(
name|b
operator|->
name|psize
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|buf
operator|=
name|fwdma_malloc_multiseg
argument_list|(
name|fc
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
name|b
operator|->
name|psize
argument_list|,
name|b
operator|->
name|nchunk
operator|*
name|b
operator|->
name|npacket
argument_list|,
name|BUS_DMA_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|q
operator|->
name|bulkxfer
argument_list|,
name|M_FW
argument_list|)
expr_stmt|;
name|q
operator|->
name|bulkxfer
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|q
operator|->
name|bnchunk
operator|=
name|b
operator|->
name|nchunk
expr_stmt|;
name|q
operator|->
name|bnpacket
operator|=
name|b
operator|->
name|npacket
expr_stmt|;
name|q
operator|->
name|psize
operator|=
operator|(
name|b
operator|->
name|psize
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|q
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|q
operator|->
name|stvalid
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|q
operator|->
name|stfree
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|q
operator|->
name|stdma
argument_list|)
expr_stmt|;
name|q
operator|->
name|stproc
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|q
operator|->
name|bnchunk
condition|;
name|i
operator|++
control|)
block|{
name|q
operator|->
name|bulkxfer
index|[
name|i
index|]
operator|.
name|poffset
operator|=
name|i
operator|*
name|q
operator|->
name|bnpacket
expr_stmt|;
name|q
operator|->
name|bulkxfer
index|[
name|i
index|]
operator|.
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|q
operator|->
name|stfree
argument_list|,
operator|&
name|q
operator|->
name|bulkxfer
index|[
name|i
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|q
operator|->
name|flag
operator|&=
operator|~
name|FWXFERQ_MODEMASK
expr_stmt|;
name|q
operator|->
name|flag
operator||=
name|FWXFERQ_STREAM
expr_stmt|;
name|q
operator|->
name|flag
operator||=
name|FWXFERQ_EXTBUF
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwdev_freebuf
parameter_list|(
name|struct
name|fw_xferq
modifier|*
name|q
parameter_list|)
block|{
if|if
condition|(
name|q
operator|->
name|flag
operator|&
name|FWXFERQ_EXTBUF
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|buf
operator|!=
name|NULL
condition|)
name|fwdma_free_multiseg
argument_list|(
name|q
operator|->
name|buf
argument_list|)
expr_stmt|;
name|q
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|q
operator|->
name|bulkxfer
argument_list|,
name|M_FW
argument_list|)
expr_stmt|;
name|q
operator|->
name|bulkxfer
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|flag
operator|&=
operator|~
name|FWXFERQ_EXTBUF
expr_stmt|;
name|q
operator|->
name|psize
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|maxq
operator|=
name|FWMAXQUEUE
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fw_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|fw_proc
modifier|*
name|td
parameter_list|)
block|{
name|int
name|unit
init|=
name|DEV2UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|sub
init|=
name|DEV2SUB
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|si_drv1
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|DEV_FWMEM
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|fwmem_open
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|,
name|fmt
argument_list|,
name|td
argument_list|)
return|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
if|if
condition|(
operator|(
name|dev
operator|->
name|si_flags
operator|&
name|SI_NAMED
operator|)
operator|==
literal|0
condition|)
endif|#
directive|endif
name|make_dev
argument_list|(
operator|&
name|firewire_cdevsw
argument_list|,
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0660
argument_list|,
literal|"fw%d.%d"
argument_list|,
name|unit
argument_list|,
name|sub
argument_list|)
expr_stmt|;
name|dev
operator|->
name|si_drv1
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fw_drv1
argument_list|)
argument_list|,
name|M_FW
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fw_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|fw_proc
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|firewire_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
decl_stmt|;
name|struct
name|fw_drv1
modifier|*
name|d
decl_stmt|;
name|int
name|unit
init|=
name|DEV2UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_bind
modifier|*
name|fwb
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|DEV_FWMEM
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|fwmem_close
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|,
name|fmt
argument_list|,
name|td
argument_list|)
return|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|firewire_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|fc
operator|=
name|sc
operator|->
name|fc
expr_stmt|;
name|d
operator|=
operator|(
expr|struct
name|fw_drv1
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|ir
operator|!=
name|NULL
condition|)
block|{
name|struct
name|fw_xferq
modifier|*
name|ir
init|=
name|d
operator|->
name|ir
decl_stmt|;
if|if
condition|(
operator|(
name|ir
operator|->
name|flag
operator|&
name|FWXFERQ_OPEN
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ir
operator|->
name|flag
operator|&
name|FWXFERQ_RUNNING
condition|)
block|{
name|ir
operator|->
name|flag
operator|&=
operator|~
name|FWXFERQ_RUNNING
expr_stmt|;
name|fc
operator|->
name|irx_disable
argument_list|(
name|fc
argument_list|,
name|ir
operator|->
name|dmach
argument_list|)
expr_stmt|;
block|}
comment|/* free extbuf */
name|fwdev_freebuf
argument_list|(
name|ir
argument_list|)
expr_stmt|;
comment|/* drain receiving buffer */
for|for
control|(
name|xfer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ir
operator|->
name|q
argument_list|)
init|;
name|xfer
operator|!=
name|NULL
condition|;
name|xfer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ir
operator|->
name|q
argument_list|)
control|)
block|{
name|ir
operator|->
name|queued
operator|--
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ir
operator|->
name|q
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|resp
operator|=
literal|0
expr_stmt|;
name|fw_xfer_done
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
comment|/* remove binding */
for|for
control|(
name|fwb
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ir
operator|->
name|binds
argument_list|)
init|;
name|fwb
operator|!=
name|NULL
condition|;
name|fwb
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ir
operator|->
name|binds
argument_list|)
control|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|fc
operator|->
name|binds
argument_list|,
name|fwb
argument_list|,
name|fw_bind
argument_list|,
name|fclist
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ir
operator|->
name|binds
argument_list|,
name|chlist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fwb
argument_list|,
name|M_FW
argument_list|)
expr_stmt|;
block|}
name|ir
operator|->
name|flag
operator|&=
operator|~
operator|(
name|FWXFERQ_OPEN
operator||
name|FWXFERQ_MODEMASK
operator||
name|FWXFERQ_CHTAGMASK
operator|)
expr_stmt|;
name|d
operator|->
name|ir
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|it
operator|!=
name|NULL
condition|)
block|{
name|struct
name|fw_xferq
modifier|*
name|it
init|=
name|d
operator|->
name|it
decl_stmt|;
if|if
condition|(
operator|(
name|it
operator|->
name|flag
operator|&
name|FWXFERQ_OPEN
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|it
operator|->
name|flag
operator|&
name|FWXFERQ_RUNNING
condition|)
block|{
name|it
operator|->
name|flag
operator|&=
operator|~
name|FWXFERQ_RUNNING
expr_stmt|;
name|fc
operator|->
name|itx_disable
argument_list|(
name|fc
argument_list|,
name|it
operator|->
name|dmach
argument_list|)
expr_stmt|;
block|}
comment|/* free extbuf */
name|fwdev_freebuf
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|it
operator|->
name|flag
operator|&=
operator|~
operator|(
name|FWXFERQ_OPEN
operator||
name|FWXFERQ_MODEMASK
operator||
name|FWXFERQ_CHTAGMASK
operator|)
expr_stmt|;
name|d
operator|->
name|it
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|dev
operator|->
name|si_drv1
argument_list|,
name|M_FW
argument_list|)
expr_stmt|;
name|dev
operator|->
name|si_drv1
operator|=
name|NULL
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * read request.  */
end_comment

begin_function
specifier|static
name|int
name|fw_read
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|firewire_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|ir
decl_stmt|;
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|s
decl_stmt|,
name|slept
init|=
literal|0
decl_stmt|;
name|int
name|unit
init|=
name|DEV2UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|DEV_FWMEM
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|fwmem_read
argument_list|(
name|dev
argument_list|,
name|uio
argument_list|,
name|ioflag
argument_list|)
return|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|firewire_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ir
operator|=
operator|(
operator|(
expr|struct
name|fw_drv1
operator|*
operator|)
name|dev
operator|->
name|si_drv1
operator|)
operator|->
name|ir
expr_stmt|;
if|if
condition|(
name|ir
operator|==
name|NULL
operator|||
name|ir
operator|->
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|readloop
label|:
name|xfer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ir
operator|->
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|ir
operator|->
name|stproc
operator|==
name|NULL
condition|)
block|{
comment|/* iso bulkxfer */
name|ir
operator|->
name|stproc
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ir
operator|->
name|stvalid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ir
operator|->
name|stproc
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ir
operator|->
name|stvalid
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ir
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|xfer
operator|==
name|NULL
operator|&&
name|ir
operator|->
name|stproc
operator|==
name|NULL
condition|)
block|{
comment|/* no data avaliable */
if|if
condition|(
name|slept
operator|==
literal|0
condition|)
block|{
name|slept
operator|=
literal|1
expr_stmt|;
name|ir
operator|->
name|flag
operator||=
name|FWXFERQ_WAKEUP
expr_stmt|;
name|err
operator|=
name|tsleep
argument_list|(
name|ir
argument_list|,
name|FWPRI
argument_list|,
literal|"fw_read"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|ir
operator|->
name|flag
operator|&=
operator|~
name|FWXFERQ_WAKEUP
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
goto|goto
name|readloop
goto|;
block|}
elseif|else
if|if
condition|(
name|slept
operator|==
literal|1
condition|)
name|err
operator|=
name|EIO
expr_stmt|;
return|return
name|err
return|;
block|}
elseif|else
if|if
condition|(
name|xfer
operator|!=
name|NULL
condition|)
block|{
comment|/* per packet mode or FWACT_CH bind?*/
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|ir
operator|->
name|queued
operator|--
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ir
operator|->
name|q
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|(
expr|struct
name|fw_pkt
operator|*
operator|)
name|xfer
operator|->
name|recv
operator|.
name|buf
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fc
operator|->
name|irx_post
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|fc
operator|->
name|irx_post
argument_list|(
name|sc
operator|->
name|fc
argument_list|,
name|fp
operator|->
name|mode
operator|.
name|ld
argument_list|)
expr_stmt|;
name|err
operator|=
name|uiomove
argument_list|(
name|xfer
operator|->
name|recv
operator|.
name|buf
argument_list|,
name|xfer
operator|->
name|recv
operator|.
name|len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
comment|/* XXX we should recycle this xfer */
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ir
operator|->
name|stproc
operator|!=
name|NULL
condition|)
block|{
comment|/* iso bulkxfer */
name|fp
operator|=
operator|(
expr|struct
name|fw_pkt
operator|*
operator|)
name|fwdma_v_addr
argument_list|(
name|ir
operator|->
name|buf
argument_list|,
name|ir
operator|->
name|stproc
operator|->
name|poffset
operator|+
name|ir
operator|->
name|queued
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fc
operator|->
name|irx_post
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|fc
operator|->
name|irx_post
argument_list|(
name|sc
operator|->
name|fc
argument_list|,
name|fp
operator|->
name|mode
operator|.
name|ld
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|mode
operator|.
name|stream
operator|.
name|len
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|EIO
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|fp
argument_list|,
name|fp
operator|->
name|mode
operator|.
name|stream
operator|.
name|len
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|ir
operator|->
name|queued
operator|++
expr_stmt|;
if|if
condition|(
name|ir
operator|->
name|queued
operator|>=
name|ir
operator|->
name|bnpacket
condition|)
block|{
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ir
operator|->
name|stfree
argument_list|,
name|ir
operator|->
name|stproc
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fc
operator|->
name|irx_enable
argument_list|(
name|sc
operator|->
name|fc
argument_list|,
name|ir
operator|->
name|dmach
argument_list|)
expr_stmt|;
name|ir
operator|->
name|stproc
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>=
name|ir
operator|->
name|psize
condition|)
block|{
name|slept
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|readloop
goto|;
block|}
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fw_write
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|firewire_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|unit
init|=
name|DEV2UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|,
name|slept
init|=
literal|0
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|it
decl_stmt|;
if|if
condition|(
name|DEV_FWMEM
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|fwmem_write
argument_list|(
name|dev
argument_list|,
name|uio
argument_list|,
name|ioflag
argument_list|)
return|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|firewire_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|fc
operator|=
name|sc
operator|->
name|fc
expr_stmt|;
name|it
operator|=
operator|(
operator|(
expr|struct
name|fw_drv1
operator|*
operator|)
name|dev
operator|->
name|si_drv1
operator|)
operator|->
name|it
expr_stmt|;
if|if
condition|(
name|it
operator|==
name|NULL
operator|||
name|it
operator|->
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|isoloop
label|:
if|if
condition|(
name|it
operator|->
name|stproc
operator|==
name|NULL
condition|)
block|{
name|it
operator|->
name|stproc
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|it
operator|->
name|stfree
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|stproc
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|it
operator|->
name|stfree
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|it
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|slept
operator|==
literal|0
condition|)
block|{
name|slept
operator|=
literal|1
expr_stmt|;
name|err
operator|=
name|sc
operator|->
name|fc
operator|->
name|itx_enable
argument_list|(
name|sc
operator|->
name|fc
argument_list|,
name|it
operator|->
name|dmach
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|err
operator|=
name|tsleep
argument_list|(
name|it
argument_list|,
name|FWPRI
argument_list|,
literal|"fw_write"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
goto|goto
name|isoloop
goto|;
block|}
else|else
block|{
name|err
operator|=
name|EIO
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
name|fp
operator|=
operator|(
expr|struct
name|fw_pkt
operator|*
operator|)
name|fwdma_v_addr
argument_list|(
name|it
operator|->
name|buf
argument_list|,
name|it
operator|->
name|stproc
operator|->
name|poffset
operator|+
name|it
operator|->
name|queued
argument_list|)
expr_stmt|;
name|err
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fw_isohdr
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|err
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|fp
operator|->
name|mode
operator|.
name|stream
operator|.
name|payload
argument_list|,
name|fp
operator|->
name|mode
operator|.
name|stream
operator|.
name|len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|it
operator|->
name|queued
operator|++
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|queued
operator|>=
name|it
operator|->
name|bnpacket
condition|)
block|{
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|it
operator|->
name|stvalid
argument_list|,
name|it
operator|->
name|stproc
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|it
operator|->
name|stproc
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|sc
operator|->
name|fc
operator|->
name|itx_enable
argument_list|(
name|sc
operator|->
name|fc
argument_list|,
name|it
operator|->
name|dmach
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|fw_isohdr
argument_list|)
condition|)
block|{
name|slept
operator|=
literal|0
expr_stmt|;
goto|goto
name|isoloop
goto|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * ioctl support.  */
end_comment

begin_function
name|int
name|fw_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|fw_proc
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|firewire_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
decl_stmt|;
name|struct
name|fw_drv1
modifier|*
name|d
decl_stmt|;
name|int
name|unit
init|=
name|DEV2UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|fw_device
modifier|*
name|fwdev
decl_stmt|;
name|struct
name|fw_bind
modifier|*
name|fwb
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|ir
decl_stmt|,
modifier|*
name|it
decl_stmt|;
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|struct
name|fw_devinfo
modifier|*
name|devinfo
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|struct
name|fw_devlstreq
modifier|*
name|fwdevlst
init|=
operator|(
expr|struct
name|fw_devlstreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|fw_asyreq
modifier|*
name|asyreq
init|=
operator|(
expr|struct
name|fw_asyreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|fw_isochreq
modifier|*
name|ichreq
init|=
operator|(
expr|struct
name|fw_isochreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|fw_isobufreq
modifier|*
name|ibufreq
init|=
operator|(
expr|struct
name|fw_isobufreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|fw_asybindreq
modifier|*
name|bindreq
init|=
operator|(
expr|struct
name|fw_asybindreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|fw_crom_buf
modifier|*
name|crom_buf
init|=
operator|(
expr|struct
name|fw_crom_buf
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|DEV_FWMEM
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|fwmem_ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
return|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|firewire_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|fc
operator|=
name|sc
operator|->
name|fc
expr_stmt|;
name|d
operator|=
operator|(
expr|struct
name|fw_drv1
operator|*
operator|)
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|ir
operator|=
name|d
operator|->
name|ir
expr_stmt|;
name|it
operator|=
name|d
operator|->
name|it
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FW_STSTREAM
case|:
if|if
condition|(
name|it
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fc
operator|->
name|nisodma
condition|;
name|i
operator|++
control|)
block|{
name|it
operator|=
name|fc
operator|->
name|it
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|it
operator|->
name|flag
operator|&
name|FWXFERQ_OPEN
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|fc
operator|->
name|nisodma
condition|)
block|{
name|err
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|fwdev_allocbuf
argument_list|(
name|fc
argument_list|,
name|it
argument_list|,
operator|&
name|d
operator|->
name|bufreq
operator|.
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|it
operator|->
name|flag
operator||=
name|FWXFERQ_OPEN
expr_stmt|;
block|}
name|it
operator|->
name|flag
operator|&=
operator|~
literal|0xff
expr_stmt|;
name|it
operator|->
name|flag
operator||=
operator|(
literal|0x3f
operator|&
name|ichreq
operator|->
name|ch
operator|)
expr_stmt|;
name|it
operator|->
name|flag
operator||=
operator|(
operator|(
literal|0x3
operator|&
name|ichreq
operator|->
name|tag
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
name|d
operator|->
name|it
operator|=
name|it
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FW_GTSTREAM
case|:
if|if
condition|(
name|it
operator|!=
name|NULL
condition|)
block|{
name|ichreq
operator|->
name|ch
operator|=
name|it
operator|->
name|flag
operator|&
literal|0x3f
expr_stmt|;
name|ichreq
operator|->
name|tag
operator|=
name|it
operator|->
name|flag
operator|>>
literal|2
operator|&
literal|0x3
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|FW_SRSTREAM
case|:
if|if
condition|(
name|ir
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fc
operator|->
name|nisodma
condition|;
name|i
operator|++
control|)
block|{
name|ir
operator|=
name|fc
operator|->
name|ir
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ir
operator|->
name|flag
operator|&
name|FWXFERQ_OPEN
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|fc
operator|->
name|nisodma
condition|)
block|{
name|err
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|fwdev_allocbuf
argument_list|(
name|fc
argument_list|,
name|ir
argument_list|,
operator|&
name|d
operator|->
name|bufreq
operator|.
name|rx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|ir
operator|->
name|flag
operator||=
name|FWXFERQ_OPEN
expr_stmt|;
block|}
name|ir
operator|->
name|flag
operator|&=
operator|~
literal|0xff
expr_stmt|;
name|ir
operator|->
name|flag
operator||=
operator|(
literal|0x3f
operator|&
name|ichreq
operator|->
name|ch
operator|)
expr_stmt|;
name|ir
operator|->
name|flag
operator||=
operator|(
operator|(
literal|0x3
operator|&
name|ichreq
operator|->
name|tag
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
name|d
operator|->
name|ir
operator|=
name|ir
expr_stmt|;
name|err
operator|=
name|fc
operator|->
name|irx_enable
argument_list|(
name|fc
argument_list|,
name|ir
operator|->
name|dmach
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_GRSTREAM
case|:
if|if
condition|(
name|d
operator|->
name|ir
operator|!=
name|NULL
condition|)
block|{
name|ichreq
operator|->
name|ch
operator|=
name|ir
operator|->
name|flag
operator|&
literal|0x3f
expr_stmt|;
name|ichreq
operator|->
name|tag
operator|=
name|ir
operator|->
name|flag
operator|>>
literal|2
operator|&
literal|0x3
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|FW_SSTBUF
case|:
name|bcopy
argument_list|(
name|ibufreq
argument_list|,
operator|&
name|d
operator|->
name|bufreq
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|bufreq
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FW_GSTBUF
case|:
name|bzero
argument_list|(
operator|&
name|ibufreq
operator|->
name|rx
argument_list|,
sizeof|sizeof
argument_list|(
name|ibufreq
operator|->
name|rx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ir
operator|!=
name|NULL
condition|)
block|{
name|ibufreq
operator|->
name|rx
operator|.
name|nchunk
operator|=
name|ir
operator|->
name|bnchunk
expr_stmt|;
name|ibufreq
operator|->
name|rx
operator|.
name|npacket
operator|=
name|ir
operator|->
name|bnpacket
expr_stmt|;
name|ibufreq
operator|->
name|rx
operator|.
name|psize
operator|=
name|ir
operator|->
name|psize
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|ibufreq
operator|->
name|tx
argument_list|,
sizeof|sizeof
argument_list|(
name|ibufreq
operator|->
name|tx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|NULL
condition|)
block|{
name|ibufreq
operator|->
name|tx
operator|.
name|nchunk
operator|=
name|it
operator|->
name|bnchunk
expr_stmt|;
name|ibufreq
operator|->
name|tx
operator|.
name|npacket
operator|=
name|it
operator|->
name|bnpacket
expr_stmt|;
name|ibufreq
operator|->
name|tx
operator|.
name|psize
operator|=
name|it
operator|->
name|psize
expr_stmt|;
block|}
break|break;
case|case
name|FW_ASYREQ
case|:
name|xfer
operator|=
name|fw_xfer_alloc_buf
argument_list|(
name|M_FWXFER
argument_list|,
name|asyreq
operator|->
name|req
operator|.
name|len
argument_list|,
name|PAGE_SIZE
comment|/* XXX */
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|err
return|;
block|}
name|fp
operator|=
operator|&
name|asyreq
operator|->
name|pkt
expr_stmt|;
switch|switch
condition|(
name|asyreq
operator|->
name|req
operator|.
name|type
condition|)
block|{
case|case
name|FWASREQNODE
case|:
name|xfer
operator|->
name|dst
operator|=
name|fp
operator|->
name|mode
operator|.
name|hdr
operator|.
name|dst
expr_stmt|;
break|break;
case|case
name|FWASREQEUI
case|:
name|fwdev
operator|=
name|fw_noderesolve_eui64
argument_list|(
name|sc
operator|->
name|fc
argument_list|,
operator|&
name|asyreq
operator|->
name|req
operator|.
name|dst
operator|.
name|eui
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwdev
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|->
name|bdev
argument_list|,
literal|"cannot find node\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|xfer
operator|->
name|dst
operator|=
name|FWLOCALBUS
operator||
name|fwdev
operator|->
name|dst
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|hdr
operator|.
name|dst
operator|=
name|xfer
operator|->
name|dst
expr_stmt|;
break|break;
case|case
name|FWASRESTL
case|:
comment|/* XXX what's this? */
break|break;
case|case
name|FWASREQSTREAM
case|:
comment|/* nothing to do */
break|break;
block|}
name|xfer
operator|->
name|spd
operator|=
name|asyreq
operator|->
name|req
operator|.
name|sped
expr_stmt|;
name|bcopy
argument_list|(
name|fp
argument_list|,
name|xfer
operator|->
name|send
operator|.
name|buf
argument_list|,
name|xfer
operator|->
name|send
operator|.
name|len
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|act
operator|.
name|hand
operator|=
name|fw_asy_callback
expr_stmt|;
name|err
operator|=
name|fw_asyreq
argument_list|(
name|sc
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|tsleep
argument_list|(
name|xfer
argument_list|,
name|FWPRI
argument_list|,
literal|"asyreq"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|asyreq
operator|->
name|req
operator|.
name|len
operator|>=
name|xfer
operator|->
name|recv
operator|.
name|len
condition|)
block|{
name|asyreq
operator|->
name|req
operator|.
name|len
operator|=
name|xfer
operator|->
name|recv
operator|.
name|len
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|xfer
operator|->
name|recv
operator|.
name|buf
argument_list|,
name|fp
argument_list|,
name|asyreq
operator|->
name|req
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
name|error
label|:
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_IBUSRST
case|:
name|sc
operator|->
name|fc
operator|->
name|ibr
argument_list|(
name|sc
operator|->
name|fc
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_CBINDADDR
case|:
name|fwb
operator|=
name|fw_bindlookup
argument_list|(
name|sc
operator|->
name|fc
argument_list|,
name|bindreq
operator|->
name|start
operator|.
name|hi
argument_list|,
name|bindreq
operator|->
name|start
operator|.
name|lo
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwb
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|STAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|fc
operator|->
name|binds
argument_list|,
name|fwb
argument_list|,
name|fw_bind
argument_list|,
name|fclist
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|ir
operator|->
name|binds
argument_list|,
name|fwb
argument_list|,
name|fw_bind
argument_list|,
name|chlist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fwb
argument_list|,
name|M_FW
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_SBINDADDR
case|:
if|if
condition|(
name|bindreq
operator|->
name|len
operator|<=
literal|0
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bindreq
operator|->
name|start
operator|.
name|hi
operator|>
literal|0xffff
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|fwb
operator|=
operator|(
expr|struct
name|fw_bind
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fw_bind
argument_list|)
argument_list|,
name|M_FW
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwb
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|fwb
operator|->
name|start_hi
operator|=
name|bindreq
operator|->
name|start
operator|.
name|hi
expr_stmt|;
name|fwb
operator|->
name|start_lo
operator|=
name|bindreq
operator|->
name|start
operator|.
name|lo
expr_stmt|;
name|fwb
operator|->
name|addrlen
operator|=
name|bindreq
operator|->
name|len
expr_stmt|;
comment|/* XXX */
name|fwb
operator|->
name|sub
operator|=
name|ir
operator|->
name|dmach
expr_stmt|;
name|fwb
operator|->
name|act_type
operator|=
name|FWACT_CH
expr_stmt|;
name|xfer
operator|=
name|fw_xfer_alloc
argument_list|(
name|M_FWXFER
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|err
return|;
block|}
name|xfer
operator|->
name|fc
operator|=
name|sc
operator|->
name|fc
expr_stmt|;
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
comment|/* XXX broken. need multiple xfer */
name|STAILQ_INIT
argument_list|(
operator|&
name|fwb
operator|->
name|xferlist
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|fwb
operator|->
name|xferlist
argument_list|,
name|xfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|err
operator|=
name|fw_bindadd
argument_list|(
name|sc
operator|->
name|fc
argument_list|,
name|fwb
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_GDEVLST
case|:
name|i
operator|=
name|len
operator|=
literal|1
expr_stmt|;
comment|/* myself */
name|devinfo
operator|=
operator|&
name|fwdevlst
operator|->
name|dev
index|[
literal|0
index|]
expr_stmt|;
name|devinfo
operator|->
name|dst
operator|=
name|sc
operator|->
name|fc
operator|->
name|nodeid
expr_stmt|;
name|devinfo
operator|->
name|status
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|devinfo
operator|->
name|eui
operator|.
name|hi
operator|=
name|sc
operator|->
name|fc
operator|->
name|eui
operator|.
name|hi
expr_stmt|;
name|devinfo
operator|->
name|eui
operator|.
name|lo
operator|=
name|sc
operator|->
name|fc
operator|->
name|eui
operator|.
name|lo
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|fwdev
argument_list|,
argument|&sc->fc->devices
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|len
operator|<
name|FW_MAX_DEVLST
condition|)
block|{
name|devinfo
operator|=
operator|&
name|fwdevlst
operator|->
name|dev
index|[
name|len
operator|++
index|]
expr_stmt|;
name|devinfo
operator|->
name|dst
operator|=
name|fwdev
operator|->
name|dst
expr_stmt|;
name|devinfo
operator|->
name|status
operator|=
operator|(
name|fwdev
operator|->
name|status
operator|==
name|FWDEVINVAL
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|devinfo
operator|->
name|eui
operator|.
name|hi
operator|=
name|fwdev
operator|->
name|eui
operator|.
name|hi
expr_stmt|;
name|devinfo
operator|->
name|eui
operator|.
name|lo
operator|=
name|fwdev
operator|->
name|eui
operator|.
name|lo
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|fwdevlst
operator|->
name|n
operator|=
name|i
expr_stmt|;
name|fwdevlst
operator|->
name|info_len
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|FW_GTPMAP
case|:
name|bcopy
argument_list|(
name|sc
operator|->
name|fc
operator|->
name|topology_map
argument_list|,
name|data
argument_list|,
operator|(
name|sc
operator|->
name|fc
operator|->
name|topology_map
operator|->
name|crc_len
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_GCROM
case|:
name|STAILQ_FOREACH
argument_list|(
argument|fwdev
argument_list|,
argument|&sc->fc->devices
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|FW_EUI64_EQUAL
argument_list|(
name|fwdev
operator|->
name|eui
argument_list|,
name|crom_buf
operator|->
name|eui
argument_list|)
condition|)
break|break;
if|if
condition|(
name|fwdev
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|FW_EUI64_EQUAL
argument_list|(
name|sc
operator|->
name|fc
operator|->
name|eui
argument_list|,
name|crom_buf
operator|->
name|eui
argument_list|)
condition|)
block|{
name|err
operator|=
name|FWNODE_INVAL
expr_stmt|;
break|break;
block|}
comment|/* myself */
name|ptr
operator|=
name|malloc
argument_list|(
name|CROMSIZE
argument_list|,
name|M_FW
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|len
operator|=
name|CROMSIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CROMSIZE
operator|/
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|ptr
operator|)
index|[
name|i
index|]
operator|=
name|ntohl
argument_list|(
name|sc
operator|->
name|fc
operator|->
name|config_rom
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* found */
name|ptr
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|fwdev
operator|->
name|csrrom
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|fwdev
operator|->
name|rommax
operator|<
name|CSRROMOFF
condition|)
name|len
operator|=
literal|0
expr_stmt|;
else|else
name|len
operator|=
name|fwdev
operator|->
name|rommax
operator|-
name|CSRROMOFF
operator|+
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|crom_buf
operator|->
name|len
operator|<
name|len
condition|)
name|len
operator|=
name|crom_buf
operator|->
name|len
expr_stmt|;
else|else
name|crom_buf
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|err
operator|=
name|copyout
argument_list|(
name|ptr
argument_list|,
name|crom_buf
operator|->
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwdev
operator|==
name|NULL
condition|)
comment|/* myself */
name|free
argument_list|(
name|ptr
argument_list|,
name|M_FW
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|fc
operator|->
name|ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|fw_poll
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|fw_proc
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|firewire_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|ir
decl_stmt|;
name|int
name|revents
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|int
name|unit
init|=
name|DEV2UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|DEV_FWMEM
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|fwmem_poll
argument_list|(
name|dev
argument_list|,
name|events
argument_list|,
name|td
argument_list|)
return|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|firewire_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ir
operator|=
operator|(
operator|(
expr|struct
name|fw_drv1
operator|*
operator|)
name|dev
operator|->
name|si_drv1
operator|)
operator|->
name|ir
expr_stmt|;
name|revents
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|POLLIN
operator||
name|POLLRDNORM
expr_stmt|;
if|if
condition|(
name|events
operator|&
name|tmp
condition|)
block|{
if|if
condition|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|ir
operator|->
name|q
argument_list|)
operator|!=
name|NULL
condition|)
name|revents
operator||=
name|tmp
expr_stmt|;
else|else
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|ir
operator|->
name|rsel
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|POLLOUT
operator||
name|POLLWRNORM
expr_stmt|;
if|if
condition|(
name|events
operator|&
name|tmp
condition|)
block|{
comment|/* XXX should be fixed */
name|revents
operator||=
name|tmp
expr_stmt|;
block|}
return|return
name|revents
return|;
block|}
end_function

begin_function
specifier|static
name|int
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500102
name|fw_mmap
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|int
name|nproto
parameter_list|)
else|#
directive|else
function|fw_mmap
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nproto
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|firewire_softc
modifier|*
name|fc
decl_stmt|;
name|int
name|unit
init|=
name|DEV2UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|DEV_FWMEM
argument_list|(
name|dev
argument_list|)
condition|)
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500102
return|return
name|fwmem_mmap
argument_list|(
name|dev
argument_list|,
name|offset
argument_list|,
name|nproto
argument_list|)
return|;
else|#
directive|else
return|return
name|fwmem_mmap
argument_list|(
name|dev
argument_list|,
name|offset
argument_list|,
name|paddr
argument_list|,
name|nproto
argument_list|)
return|;
endif|#
directive|endif
name|fc
operator|=
name|devclass_get_softc
argument_list|(
name|firewire_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
end_function

end_unit

