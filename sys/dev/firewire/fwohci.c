begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998-2002 Katsushi Kobayashi and Hidetoshi Shimokawa  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the acknowledgement as bellow:  *  *    This product includes software developed by K. Kobayashi and H. Shimokawa  *  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *   * $FreeBSD$  *  */
end_comment

begin_define
define|#
directive|define
name|ATRQ_CH
value|0
end_define

begin_define
define|#
directive|define
name|ATRS_CH
value|1
end_define

begin_define
define|#
directive|define
name|ARRQ_CH
value|2
end_define

begin_define
define|#
directive|define
name|ARRS_CH
value|3
end_define

begin_define
define|#
directive|define
name|ITX_CH
value|4
end_define

begin_define
define|#
directive|define
name|IRX_CH
value|0x24
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_comment
comment|/* for rdtsc proto for clock.h below */
end_comment

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_comment
comment|/* for vtophys proto */
end_comment

begin_include
include|#
directive|include
file|<dev/firewire/firewire.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewirereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/fwohcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/fwohcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewire_phy.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/iec68113.h>
end_include

begin_undef
undef|#
directive|undef
name|OHCI_DEBUG
end_undef

begin_decl_stmt
specifier|static
name|char
name|dbcode
index|[
literal|16
index|]
index|[
literal|0x10
index|]
init|=
block|{
literal|"OUTM"
block|,
literal|"OUTL"
block|,
literal|"INPM"
block|,
literal|"INPL"
block|,
literal|"STOR"
block|,
literal|"LOAD"
block|,
literal|"NOP "
block|,
literal|"STOP"
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|dbkey
index|[
literal|8
index|]
index|[
literal|0x10
index|]
init|=
block|{
literal|"ST0"
block|,
literal|"ST1"
block|,
literal|"ST2"
block|,
literal|"ST3"
block|,
literal|"UNDEF"
block|,
literal|"REG"
block|,
literal|"SYS"
block|,
literal|"DEV"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|fwohcicode
index|[
literal|32
index|]
index|[
literal|0x20
index|]
init|=
block|{
literal|"No stat"
block|,
literal|"Undef"
block|,
literal|"long"
block|,
literal|"miss Ack err"
block|,
literal|"underrun"
block|,
literal|"overrun"
block|,
literal|"desc err"
block|,
literal|"data read err"
block|,
literal|"data write err"
block|,
literal|"bus reset"
block|,
literal|"timeout"
block|,
literal|"tcode err"
block|,
literal|"Undef"
block|,
literal|"Undef"
block|,
literal|"unknown event"
block|,
literal|"flushed"
block|,
literal|"Undef"
block|,
literal|"ack complete"
block|,
literal|"ack pend"
block|,
literal|"Undef"
block|,
literal|"ack busy_X"
block|,
literal|"ack busy_A"
block|,
literal|"ack busy_B"
block|,
literal|"Undef"
block|,
literal|"Undef"
block|,
literal|"Undef"
block|,
literal|"Undef"
block|,
literal|"ack tardy"
block|,
literal|"Undef"
block|,
literal|"ack data_err"
block|,
literal|"ack type_err"
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_SPEED
value|2
end_define

begin_decl_stmt
specifier|extern
name|char
name|linkspeed
index|[
name|MAX_SPEED
operator|+
literal|1
index|]
index|[
literal|0x10
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|dbcond
index|[
literal|4
index|]
index|[
literal|0x10
index|]
init|=
block|{
literal|"NEV"
block|,
literal|"C=1"
block|,
literal|"C=0"
block|,
literal|"ALL"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|tagbit
index|[
literal|4
index|]
init|=
block|{
literal|1
operator|<<
literal|28
block|,
literal|1
operator|<<
literal|29
block|,
literal|1
operator|<<
literal|30
block|,
literal|1
operator|<<
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tcode_info
name|tinfo
index|[]
init|=
block|{
comment|/*		hdr_len block 	flag*/
comment|/* 0 WREQQ  */
block|{
literal|16
block|,
name|FWTI_REQ
operator||
name|FWTI_TLABEL
block|}
block|,
comment|/* 1 WREQB  */
block|{
literal|16
block|,
name|FWTI_REQ
operator||
name|FWTI_TLABEL
operator||
name|FWTI_BLOCK_ASY
block|}
block|,
comment|/* 2 WRES   */
block|{
literal|12
block|,
name|FWTI_RES
block|}
block|,
comment|/* 3 XXX    */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* 4 RREQQ  */
block|{
literal|12
block|,
name|FWTI_REQ
operator||
name|FWTI_TLABEL
block|}
block|,
comment|/* 5 RREQB  */
block|{
literal|16
block|,
name|FWTI_REQ
operator||
name|FWTI_TLABEL
block|}
block|,
comment|/* 6 RRESQ  */
block|{
literal|16
block|,
name|FWTI_RES
block|}
block|,
comment|/* 7 RRESB  */
block|{
literal|16
block|,
name|FWTI_RES
operator||
name|FWTI_BLOCK_ASY
block|}
block|,
comment|/* 8 CYCS   */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* 9 LREQ   */
block|{
literal|16
block|,
name|FWTI_REQ
operator||
name|FWTI_TLABEL
operator||
name|FWTI_BLOCK_ASY
block|}
block|,
comment|/* a STREAM */
block|{
literal|4
block|,
name|FWTI_REQ
operator||
name|FWTI_BLOCK_STR
block|}
block|,
comment|/* b LRES   */
block|{
literal|16
block|,
name|FWTI_RES
operator||
name|FWTI_BLOCK_ASY
block|}
block|,
comment|/* c XXX    */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* d XXX    */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* e PHY    */
block|{
literal|12
block|,
name|FWTI_REQ
block|}
block|,
comment|/* f XXX    */
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OHCI_WRITE_SIGMASK
value|0xffff0000
end_define

begin_define
define|#
directive|define
name|OHCI_READ_SIGMASK
value|0xffff0000
end_define

begin_define
define|#
directive|define
name|OWRITE
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
value|bus_space_write_4((sc)->bst, (sc)->bsh, (r), (x))
end_define

begin_define
define|#
directive|define
name|OREAD
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|bus_space_read_4((sc)->bst, (sc)->bsh, (r))
end_define

begin_decl_stmt
specifier|static
name|void
name|fwohci_ibr
name|__P
argument_list|(
operator|(
expr|struct
name|firewire_comm
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwohci_db_init
name|__P
argument_list|(
operator|(
expr|struct
name|fwohci_dbch
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwohci_db_free
name|__P
argument_list|(
operator|(
expr|struct
name|fwohci_dbch
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwohci_arcv
name|__P
argument_list|(
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|,
expr|struct
name|fwohci_dbch
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwohci_ircv
name|__P
argument_list|(
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|,
expr|struct
name|fwohci_dbch
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwohci_txd
name|__P
argument_list|(
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|,
expr|struct
name|fwohci_dbch
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwohci_start_atq
name|__P
argument_list|(
operator|(
expr|struct
name|firewire_comm
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwohci_start_ats
name|__P
argument_list|(
operator|(
expr|struct
name|firewire_comm
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwohci_start
name|__P
argument_list|(
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|,
expr|struct
name|fwohci_dbch
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwohci_drain_atq
name|__P
argument_list|(
operator|(
expr|struct
name|firewire_comm
operator|*
operator|,
expr|struct
name|fw_xfer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwohci_drain_ats
name|__P
argument_list|(
operator|(
expr|struct
name|firewire_comm
operator|*
operator|,
expr|struct
name|fw_xfer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwohci_drain
name|__P
argument_list|(
operator|(
expr|struct
name|firewire_comm
operator|*
operator|,
expr|struct
name|fw_xfer
operator|*
operator|,
expr|struct
name|fwohci_dbch
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|fwphy_wrdata
name|__P
argument_list|(
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|,
name|u_int32_t
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|fwphy_rddata
name|__P
argument_list|(
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fwohci_rx_enable
name|__P
argument_list|(
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|,
expr|struct
name|fwohci_dbch
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fwohci_tx_enable
name|__P
argument_list|(
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|,
expr|struct
name|fwohci_dbch
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fwohci_irx_enable
name|__P
argument_list|(
operator|(
expr|struct
name|firewire_comm
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fwohci_irxpp_enable
name|__P
argument_list|(
operator|(
expr|struct
name|firewire_comm
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fwohci_irxbuf_enable
name|__P
argument_list|(
operator|(
expr|struct
name|firewire_comm
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fwohci_irx_disable
name|__P
argument_list|(
operator|(
expr|struct
name|firewire_comm
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwohci_irx_post
name|__P
argument_list|(
operator|(
expr|struct
name|firewire_comm
operator|*
operator|,
name|u_int32_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fwohci_itxbuf_enable
name|__P
argument_list|(
operator|(
expr|struct
name|firewire_comm
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fwohci_itx_disable
name|__P
argument_list|(
operator|(
expr|struct
name|firewire_comm
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwohci_timeout
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwohci_poll
name|__P
argument_list|(
operator|(
expr|struct
name|firewire_comm
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwohci_set_intr
name|__P
argument_list|(
operator|(
expr|struct
name|firewire_comm
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fwohci_add_rx_buf
name|__P
argument_list|(
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|,
name|unsigned
name|short
operator|,
name|int
operator|,
name|void
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fwohci_add_tx_buf
name|__P
argument_list|(
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|,
name|unsigned
name|short
operator|,
name|int
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_db
name|__P
argument_list|(
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_db
name|__P
argument_list|(
operator|(
specifier|volatile
expr|struct
name|fwohcidb
operator|*
operator|,
name|u_int32_t
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_dma
name|__P
argument_list|(
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|fwohci_cyctimer
name|__P
argument_list|(
operator|(
expr|struct
name|firewire_comm
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwohci_rbuf_update
name|__P
argument_list|(
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwohci_tbuf_update
name|__P
argument_list|(
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fwohci_txbufdb
name|__P
argument_list|(
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|,
name|int
operator|,
expr|struct
name|fw_bulkxfer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * memory allocated for DMA programs  */
end_comment

begin_define
define|#
directive|define
name|DMA_PROG_ALLOC
value|(8 * PAGE_SIZE)
end_define

begin_comment
comment|/* #define NDB 1024 */
end_comment

begin_define
define|#
directive|define
name|NDB
value|FWMAXQUEUE
end_define

begin_define
define|#
directive|define
name|NDVDB
value|(DVBUF * NDB)
end_define

begin_define
define|#
directive|define
name|OHCI_VERSION
value|0x00
end_define

begin_define
define|#
directive|define
name|OHCI_CROMHDR
value|0x18
end_define

begin_define
define|#
directive|define
name|OHCI_BUS_OPT
value|0x20
end_define

begin_define
define|#
directive|define
name|OHCI_BUSIRMC
value|(1<< 31)
end_define

begin_define
define|#
directive|define
name|OHCI_BUSCMC
value|(1<< 30)
end_define

begin_define
define|#
directive|define
name|OHCI_BUSISC
value|(1<< 29)
end_define

begin_define
define|#
directive|define
name|OHCI_BUSBMC
value|(1<< 28)
end_define

begin_define
define|#
directive|define
name|OHCI_BUSPMC
value|(1<< 27)
end_define

begin_define
define|#
directive|define
name|OHCI_BUSFNC
value|OHCI_BUSIRMC | OHCI_BUSCMC | OHCI_BUSISC |\ 				OHCI_BUSBMC | OHCI_BUSPMC
end_define

begin_define
define|#
directive|define
name|OHCI_EUID_HI
value|0x24
end_define

begin_define
define|#
directive|define
name|OHCI_EUID_LO
value|0x28
end_define

begin_define
define|#
directive|define
name|OHCI_CROMPTR
value|0x34
end_define

begin_define
define|#
directive|define
name|OHCI_HCCCTL
value|0x50
end_define

begin_define
define|#
directive|define
name|OHCI_HCCCTLCLR
value|0x54
end_define

begin_define
define|#
directive|define
name|OHCI_AREQHI
value|0x100
end_define

begin_define
define|#
directive|define
name|OHCI_AREQHICLR
value|0x104
end_define

begin_define
define|#
directive|define
name|OHCI_AREQLO
value|0x108
end_define

begin_define
define|#
directive|define
name|OHCI_AREQLOCLR
value|0x10c
end_define

begin_define
define|#
directive|define
name|OHCI_PREQHI
value|0x110
end_define

begin_define
define|#
directive|define
name|OHCI_PREQHICLR
value|0x114
end_define

begin_define
define|#
directive|define
name|OHCI_PREQLO
value|0x118
end_define

begin_define
define|#
directive|define
name|OHCI_PREQLOCLR
value|0x11c
end_define

begin_define
define|#
directive|define
name|OHCI_PREQUPPER
value|0x120
end_define

begin_define
define|#
directive|define
name|OHCI_SID_BUF
value|0x64
end_define

begin_define
define|#
directive|define
name|OHCI_SID_CNT
value|0x68
end_define

begin_define
define|#
directive|define
name|OHCI_SID_CNT_MASK
value|0xffc
end_define

begin_define
define|#
directive|define
name|OHCI_IT_STAT
value|0x90
end_define

begin_define
define|#
directive|define
name|OHCI_IT_STATCLR
value|0x94
end_define

begin_define
define|#
directive|define
name|OHCI_IT_MASK
value|0x98
end_define

begin_define
define|#
directive|define
name|OHCI_IT_MASKCLR
value|0x9c
end_define

begin_define
define|#
directive|define
name|OHCI_IR_STAT
value|0xa0
end_define

begin_define
define|#
directive|define
name|OHCI_IR_STATCLR
value|0xa4
end_define

begin_define
define|#
directive|define
name|OHCI_IR_MASK
value|0xa8
end_define

begin_define
define|#
directive|define
name|OHCI_IR_MASKCLR
value|0xac
end_define

begin_define
define|#
directive|define
name|OHCI_LNKCTL
value|0xe0
end_define

begin_define
define|#
directive|define
name|OHCI_LNKCTLCLR
value|0xe4
end_define

begin_define
define|#
directive|define
name|OHCI_PHYACCESS
value|0xec
end_define

begin_define
define|#
directive|define
name|OHCI_CYCLETIMER
value|0xf0
end_define

begin_define
define|#
directive|define
name|OHCI_DMACTL
parameter_list|(
name|off
parameter_list|)
value|(off)
end_define

begin_define
define|#
directive|define
name|OHCI_DMACTLCLR
parameter_list|(
name|off
parameter_list|)
value|(off + 4)
end_define

begin_define
define|#
directive|define
name|OHCI_DMACMD
parameter_list|(
name|off
parameter_list|)
value|(off + 0xc)
end_define

begin_define
define|#
directive|define
name|OHCI_DMAMATCH
parameter_list|(
name|off
parameter_list|)
value|(off + 0x10)
end_define

begin_define
define|#
directive|define
name|OHCI_ATQOFF
value|0x180
end_define

begin_define
define|#
directive|define
name|OHCI_ATQCTL
value|OHCI_ATQOFF
end_define

begin_define
define|#
directive|define
name|OHCI_ATQCTLCLR
value|(OHCI_ATQOFF + 4)
end_define

begin_define
define|#
directive|define
name|OHCI_ATQCMD
value|(OHCI_ATQOFF + 0xc)
end_define

begin_define
define|#
directive|define
name|OHCI_ATQMATCH
value|(OHCI_ATQOFF + 0x10)
end_define

begin_define
define|#
directive|define
name|OHCI_ATSOFF
value|0x1a0
end_define

begin_define
define|#
directive|define
name|OHCI_ATSCTL
value|OHCI_ATSOFF
end_define

begin_define
define|#
directive|define
name|OHCI_ATSCTLCLR
value|(OHCI_ATSOFF + 4)
end_define

begin_define
define|#
directive|define
name|OHCI_ATSCMD
value|(OHCI_ATSOFF + 0xc)
end_define

begin_define
define|#
directive|define
name|OHCI_ATSMATCH
value|(OHCI_ATSOFF + 0x10)
end_define

begin_define
define|#
directive|define
name|OHCI_ARQOFF
value|0x1c0
end_define

begin_define
define|#
directive|define
name|OHCI_ARQCTL
value|OHCI_ARQOFF
end_define

begin_define
define|#
directive|define
name|OHCI_ARQCTLCLR
value|(OHCI_ARQOFF + 4)
end_define

begin_define
define|#
directive|define
name|OHCI_ARQCMD
value|(OHCI_ARQOFF + 0xc)
end_define

begin_define
define|#
directive|define
name|OHCI_ARQMATCH
value|(OHCI_ARQOFF + 0x10)
end_define

begin_define
define|#
directive|define
name|OHCI_ARSOFF
value|0x1e0
end_define

begin_define
define|#
directive|define
name|OHCI_ARSCTL
value|OHCI_ARSOFF
end_define

begin_define
define|#
directive|define
name|OHCI_ARSCTLCLR
value|(OHCI_ARSOFF + 4)
end_define

begin_define
define|#
directive|define
name|OHCI_ARSCMD
value|(OHCI_ARSOFF + 0xc)
end_define

begin_define
define|#
directive|define
name|OHCI_ARSMATCH
value|(OHCI_ARSOFF + 0x10)
end_define

begin_define
define|#
directive|define
name|OHCI_ITOFF
parameter_list|(
name|CH
parameter_list|)
value|(0x200 + 0x10 * (CH))
end_define

begin_define
define|#
directive|define
name|OHCI_ITCTL
parameter_list|(
name|CH
parameter_list|)
value|(OHCI_ITOFF(CH))
end_define

begin_define
define|#
directive|define
name|OHCI_ITCTLCLR
parameter_list|(
name|CH
parameter_list|)
value|(OHCI_ITOFF(CH) + 4)
end_define

begin_define
define|#
directive|define
name|OHCI_ITCMD
parameter_list|(
name|CH
parameter_list|)
value|(OHCI_ITOFF(CH) + 0xc)
end_define

begin_define
define|#
directive|define
name|OHCI_IROFF
parameter_list|(
name|CH
parameter_list|)
value|(0x400 + 0x20 * (CH))
end_define

begin_define
define|#
directive|define
name|OHCI_IRCTL
parameter_list|(
name|CH
parameter_list|)
value|(OHCI_IROFF(CH))
end_define

begin_define
define|#
directive|define
name|OHCI_IRCTLCLR
parameter_list|(
name|CH
parameter_list|)
value|(OHCI_IROFF(CH) + 4)
end_define

begin_define
define|#
directive|define
name|OHCI_IRCMD
parameter_list|(
name|CH
parameter_list|)
value|(OHCI_IROFF(CH) + 0xc)
end_define

begin_define
define|#
directive|define
name|OHCI_IRMATCH
parameter_list|(
name|CH
parameter_list|)
value|(OHCI_IROFF(CH) + 0x10)
end_define

begin_decl_stmt
name|d_ioctl_t
name|fwohci_ioctl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Communication with PHY device  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|fwphy_wrdata
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|addr
parameter_list|,
name|u_int32_t
name|data
parameter_list|)
block|{
name|u_int32_t
name|fun
decl_stmt|;
name|addr
operator|&=
literal|0xf
expr_stmt|;
name|data
operator|&=
literal|0xff
expr_stmt|;
name|fun
operator|=
operator|(
name|PHYDEV_WRCMD
operator||
operator|(
name|addr
operator|<<
name|PHYDEV_REGADDR
operator|)
operator||
operator|(
name|data
operator|<<
name|PHYDEV_WRDATA
operator|)
operator|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_PHYACCESS
argument_list|,
name|fun
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
return|return
operator|(
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|fwohci_set_bus_manager
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|u_int
name|node
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int32_t
name|bm
decl_stmt|;
define|#
directive|define
name|OHCI_CSR_DATA
value|0x0c
define|#
directive|define
name|OHCI_CSR_COMP
value|0x10
define|#
directive|define
name|OHCI_CSR_CONT
value|0x14
define|#
directive|define
name|OHCI_BUS_MANAGER_ID
value|0
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_CSR_DATA
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_CSR_COMP
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_CSR_CONT
argument_list|,
name|OHCI_BUS_MANAGER_ID
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
operator|(
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_CSR_CONT
argument_list|)
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
operator|)
operator|&&
operator|(
name|i
operator|<
literal|1000
operator|)
condition|;
name|i
operator|++
control|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|bm
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_CSR_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bm
operator|&
literal|0x3f
operator|)
operator|==
literal|0x3f
condition|)
name|bm
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"fw_set_bus_manager: %d->%d (loop=%d)\n"
argument_list|,
name|bm
argument_list|,
name|node
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|bm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|fwphy_rddata
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|addr
parameter_list|)
block|{
name|u_int32_t
name|fun
decl_stmt|,
name|stat
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|retry
init|=
literal|0
decl_stmt|;
name|addr
operator|&=
literal|0xf
expr_stmt|;
define|#
directive|define
name|MAX_RETRY
value|100
name|again
label|:
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_REG_FAIL
argument_list|)
expr_stmt|;
name|fun
operator|=
name|PHYDEV_RDCMD
operator||
operator|(
name|addr
operator|<<
name|PHYDEV_REGADDR
operator|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_PHYACCESS
argument_list|,
name|fun
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_RETRY
condition|;
name|i
operator|++
control|)
block|{
name|fun
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_PHYACCESS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fun
operator|&
name|PHYDEV_RDCMD
operator|)
operator|==
literal|0
operator|&&
operator|(
name|fun
operator|&
name|PHYDEV_RDDONE
operator|)
operator|!=
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|MAX_RETRY
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"phy read failed(1).\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|retry
operator|<
name|MAX_RETRY
condition|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
comment|/* Make sure that SCLK is started */
name|stat
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_REG_FAIL
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|fun
operator|>>
name|PHYDEV_REGADDR
operator|)
operator|&
literal|0xf
operator|)
operator|!=
name|addr
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"phy read failed(2).\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|retry
operator|<
name|MAX_RETRY
condition|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
if|if
condition|(
name|bootverbose
operator|||
name|retry
operator|>=
name|MAX_RETRY
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"fwphy_rddata: loop=%d, retry=%d\n"
argument_list|,
name|i
argument_list|,
name|retry
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|MAX_RETRY
return|return
operator|(
operator|(
name|fun
operator|>>
name|PHYDEV_RDDATA
operator|)
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Device specific ioctl. */
end_comment

begin_function
name|int
name|fwohci_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|fw_proc
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|firewire_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|fwohci_softc
modifier|*
name|fc
decl_stmt|;
name|int
name|unit
init|=
name|DEV2UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|fw_reg_req_t
modifier|*
name|reg
init|=
operator|(
expr|struct
name|fw_reg_req_t
operator|*
operator|)
name|data
decl_stmt|;
name|u_int32_t
modifier|*
name|dmach
init|=
operator|(
name|u_int32_t
operator|*
operator|)
name|data
decl_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|firewire_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|fc
operator|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|sc
operator|->
name|fc
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FWOHCI_WRREG
case|:
define|#
directive|define
name|OHCI_MAX_REG
value|0x800
if|if
condition|(
name|reg
operator|->
name|addr
operator|<=
name|OHCI_MAX_REG
condition|)
block|{
name|OWRITE
argument_list|(
name|fc
argument_list|,
name|reg
operator|->
name|addr
argument_list|,
name|reg
operator|->
name|data
argument_list|)
expr_stmt|;
name|reg
operator|->
name|data
operator|=
name|OREAD
argument_list|(
name|fc
argument_list|,
name|reg
operator|->
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|FWOHCI_RDREG
case|:
if|if
condition|(
name|reg
operator|->
name|addr
operator|<=
name|OHCI_MAX_REG
condition|)
block|{
name|reg
operator|->
name|data
operator|=
name|OREAD
argument_list|(
name|fc
argument_list|,
name|reg
operator|->
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
comment|/* Read DMA descriptors for debug  */
case|case
name|DUMPDMA
case|:
if|if
condition|(
operator|*
name|dmach
operator|<=
name|OHCI_MAX_DMA_CH
condition|)
block|{
name|dump_dma
argument_list|(
name|fc
argument_list|,
operator|*
name|dmach
argument_list|)
expr_stmt|;
name|dump_db
argument_list|(
name|fc
argument_list|,
operator|*
name|dmach
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_probe_phy
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|u_int32_t
name|reg
decl_stmt|,
name|reg2
decl_stmt|;
name|int
name|e1394a
init|=
literal|1
decl_stmt|;
comment|/*  * probe PHY parameters  * 0. to prove PHY version, whether compliance of 1394a.  * 1. to probe maximum speed supported by the PHY and   *    number of port supported by core-logic.  *    It is not actually available port on your PC .  */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|,
name|OHCI_HCC_LPS
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX wait for SCLK. */
block|DELAY(100000);
endif|#
directive|endif
name|reg
operator|=
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
name|FW_PHY_SPD_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|>>
literal|5
operator|)
operator|!=
literal|7
condition|)
block|{
name|sc
operator|->
name|fc
operator|.
name|mode
operator|&=
operator|~
name|FWPHYASYST
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|nport
operator|=
name|reg
operator|&
name|FW_PHY_NP
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|speed
operator|=
name|reg
operator|&
name|FW_PHY_SPD
operator|>>
literal|6
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fc
operator|.
name|speed
operator|>
name|MAX_SPEED
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid speed %d (fixed to %d).\n"
argument_list|,
name|sc
operator|->
name|fc
operator|.
name|speed
argument_list|,
name|MAX_SPEED
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|speed
operator|=
name|MAX_SPEED
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Phy 1394 only %s, %d ports.\n"
argument_list|,
name|linkspeed
index|[
name|sc
operator|->
name|fc
operator|.
name|speed
index|]
argument_list|,
name|sc
operator|->
name|fc
operator|.
name|nport
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reg2
operator|=
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
name|FW_PHY_ESPD_REG
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|mode
operator||=
name|FWPHYASYST
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|nport
operator|=
name|reg
operator|&
name|FW_PHY_NP
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|speed
operator|=
operator|(
name|reg2
operator|&
name|FW_PHY_ESPD
operator|)
operator|>>
literal|5
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fc
operator|.
name|speed
operator|>
name|MAX_SPEED
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid speed %d (fixed to %d).\n"
argument_list|,
name|sc
operator|->
name|fc
operator|.
name|speed
argument_list|,
name|MAX_SPEED
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|speed
operator|=
name|MAX_SPEED
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Phy 1394a available %s, %d ports.\n"
argument_list|,
name|linkspeed
index|[
name|sc
operator|->
name|fc
operator|.
name|speed
index|]
argument_list|,
name|sc
operator|->
name|fc
operator|.
name|nport
argument_list|)
expr_stmt|;
comment|/* check programPhyEnable */
name|reg2
operator|=
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (e1394a&& (OREAD(sc, OHCI_HCCCTL)& OHCI_HCC_PRPHY)) {
else|#
directive|else
comment|/* XXX force to enable 1394a */
if|if
condition|(
name|e1394a
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Enable 1394a Enhancements\n"
argument_list|)
expr_stmt|;
comment|/* enable EAA EMC */
name|reg2
operator||=
literal|0x03
expr_stmt|;
comment|/* set aPhyEnhanceEnable */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|,
name|OHCI_HCC_PHYEN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTLCLR
argument_list|,
name|OHCI_HCC_PRPHY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* for safe */
name|reg2
operator|&=
operator|~
literal|0x83
expr_stmt|;
block|}
name|reg2
operator|=
name|fwphy_wrdata
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
block|}
name|reg
operator|=
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
name|FW_PHY_SPD_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|>>
literal|5
operator|)
operator|==
literal|7
condition|)
block|{
name|reg
operator|=
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|reg
operator||=
literal|1
operator|<<
literal|6
expr_stmt|;
name|fwphy_wrdata
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|fwohci_reset
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|max_rec
decl_stmt|,
name|speed
decl_stmt|;
name|u_int32_t
name|reg
decl_stmt|,
name|reg2
decl_stmt|;
name|struct
name|fwohcidb_tr
modifier|*
name|db_tr
decl_stmt|;
comment|/* Disable interrupt */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASKCLR
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
comment|/* Now stopping all DMA channel */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ARQCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ARSCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ATQCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ATSCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_MASKCLR
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|fc
operator|.
name|nisodma
condition|;
name|i
operator|++
control|)
block|{
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTLCLR
argument_list|(
name|i
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ITCTLCLR
argument_list|(
name|i
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
block|}
comment|/* FLUSH FIFO and reset Transmitter/Reciever */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|,
name|OHCI_HCC_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"resetting OHCI..."
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|)
operator|&
name|OHCI_HCC_RESET
condition|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
literal|100
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"done (loop=%d)\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Probe phy */
name|fwohci_probe_phy
argument_list|(
name|sc
argument_list|,
name|dev
argument_list|)
expr_stmt|;
comment|/* Probe link */
name|reg
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_BUS_OPT
argument_list|)
expr_stmt|;
name|reg2
operator|=
name|reg
operator||
name|OHCI_BUSFNC
expr_stmt|;
name|max_rec
operator|=
operator|(
name|reg
operator|&
literal|0x0000f000
operator|)
operator|>>
literal|12
expr_stmt|;
name|speed
operator|=
operator|(
name|reg
operator|&
literal|0x00000007
operator|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link %s, max_rec %d bytes.\n"
argument_list|,
name|linkspeed
index|[
name|speed
index|]
argument_list|,
name|MAXREC
argument_list|(
name|max_rec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX fix max_rec */
name|sc
operator|->
name|fc
operator|.
name|maxrec
operator|=
name|sc
operator|->
name|fc
operator|.
name|speed
operator|+
literal|8
expr_stmt|;
if|if
condition|(
name|max_rec
operator|!=
name|sc
operator|->
name|fc
operator|.
name|maxrec
condition|)
block|{
name|reg2
operator|=
operator|(
name|reg2
operator|&
literal|0xffff0fff
operator|)
operator||
operator|(
name|sc
operator|->
name|fc
operator|.
name|maxrec
operator|<<
literal|12
operator|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"max_rec %d -> %d\n"
argument_list|,
name|MAXREC
argument_list|(
name|max_rec
argument_list|)
argument_list|,
name|MAXREC
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|maxrec
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"BUS_OPT 0x%x -> 0x%x\n"
argument_list|,
name|reg
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_BUS_OPT
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
comment|/* Initialize registers */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_CROMHDR
argument_list|,
name|sc
operator|->
name|fc
operator|.
name|config_rom
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_CROMPTR
argument_list|,
name|vtophys
argument_list|(
operator|&
name|sc
operator|->
name|fc
operator|.
name|config_rom
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTLCLR
argument_list|,
name|OHCI_HCC_BIGEND
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|,
name|OHCI_HCC_POSTWR
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_SID_BUF
argument_list|,
name|vtophys
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|sid_buf
argument_list|)
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_LNKCTL
argument_list|,
name|OHCI_CNTL_SID
argument_list|)
expr_stmt|;
name|fw_busreset
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|)
expr_stmt|;
comment|/* Enable link */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|,
name|OHCI_HCC_LINKEN
argument_list|)
expr_stmt|;
comment|/* Force to start async RX DMA */
name|sc
operator|->
name|arrq
operator|.
name|xferq
operator|.
name|flag
operator|&=
operator|~
name|FWXFERQ_RUNNING
expr_stmt|;
name|sc
operator|->
name|arrs
operator|.
name|xferq
operator|.
name|flag
operator|&=
operator|~
name|FWXFERQ_RUNNING
expr_stmt|;
name|fwohci_rx_enable
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|arrq
argument_list|)
expr_stmt|;
name|fwohci_rx_enable
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|arrs
argument_list|)
expr_stmt|;
comment|/* Initialize async TX */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ATQCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
operator||
name|OHCI_CNTL_DMA_DEAD
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ATSCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
operator||
name|OHCI_CNTL_DMA_DEAD
argument_list|)
expr_stmt|;
comment|/* AT Retries */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_RETRY
argument_list|,
comment|/* CycleLimit   PhyRespRetries ATRespRetries ATReqRetries */
operator|(
literal|0xffff
operator|<<
literal|16
operator|)
operator||
operator|(
literal|0x0f
operator|<<
literal|8
operator|)
operator||
operator|(
literal|0x0f
operator|<<
literal|4
operator|)
operator||
literal|0x0f
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|db_tr
operator|=
name|sc
operator|->
name|atrq
operator|.
name|top
init|;
name|i
operator|<
name|sc
operator|->
name|atrq
operator|.
name|ndb
condition|;
name|i
operator|++
operator|,
name|db_tr
operator|=
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
control|)
block|{
name|db_tr
operator|->
name|xfer
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|db_tr
operator|=
name|sc
operator|->
name|atrs
operator|.
name|top
init|;
name|i
operator|<
name|sc
operator|->
name|atrs
operator|.
name|ndb
condition|;
name|i
operator|++
operator|,
name|db_tr
operator|=
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
control|)
block|{
name|db_tr
operator|->
name|xfer
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Enable interrupt */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASK
argument_list|,
name|OHCI_INT_ERR
operator||
name|OHCI_INT_PHY_SID
operator||
name|OHCI_INT_DMA_ATRQ
operator||
name|OHCI_INT_DMA_ATRS
operator||
name|OHCI_INT_DMA_PRRQ
operator||
name|OHCI_INT_DMA_PRRS
operator||
name|OHCI_INT_PHY_BUS_R
operator||
name|OHCI_INT_PW_ERR
argument_list|)
expr_stmt|;
name|fwohci_set_intr
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|fwohci_init
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int32_t
name|reg
decl_stmt|;
name|u_int8_t
name|ui
index|[
literal|8
index|]
decl_stmt|;
name|reg
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_VERSION
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"OHCI version %x.%x (ROM=%d)\n"
argument_list|,
operator|(
name|reg
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
name|reg
operator|&
literal|0xff
argument_list|,
operator|(
name|reg
operator|>>
literal|24
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
comment|/* Available Isochrounous DMA channel probe */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_MASK
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_MASK
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|reg
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_MASK
argument_list|)
operator|&
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_MASK
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_MASKCLR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_MASKCLR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x20
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|reg
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|sc
operator|->
name|fc
operator|.
name|nisodma
operator|=
name|i
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No. of Isochronous channel is %d.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|arq
operator|=
operator|&
name|sc
operator|->
name|arrq
operator|.
name|xferq
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|ars
operator|=
operator|&
name|sc
operator|->
name|arrs
operator|.
name|xferq
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|atq
operator|=
operator|&
name|sc
operator|->
name|atrq
operator|.
name|xferq
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|ats
operator|=
operator|&
name|sc
operator|->
name|atrs
operator|.
name|xferq
expr_stmt|;
name|sc
operator|->
name|arrq
operator|.
name|xferq
operator|.
name|start
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|arrs
operator|.
name|xferq
operator|.
name|start
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|atrq
operator|.
name|xferq
operator|.
name|start
operator|=
name|fwohci_start_atq
expr_stmt|;
name|sc
operator|->
name|atrs
operator|.
name|xferq
operator|.
name|start
operator|=
name|fwohci_start_ats
expr_stmt|;
name|sc
operator|->
name|arrq
operator|.
name|xferq
operator|.
name|drain
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|arrs
operator|.
name|xferq
operator|.
name|drain
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|atrq
operator|.
name|xferq
operator|.
name|drain
operator|=
name|fwohci_drain_atq
expr_stmt|;
name|sc
operator|->
name|atrs
operator|.
name|xferq
operator|.
name|drain
operator|=
name|fwohci_drain_ats
expr_stmt|;
name|sc
operator|->
name|arrq
operator|.
name|ndesc
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|arrs
operator|.
name|ndesc
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|atrq
operator|.
name|ndesc
operator|=
literal|6
expr_stmt|;
comment|/* equal to maximum of mbuf chains */
name|sc
operator|->
name|atrs
operator|.
name|ndesc
operator|=
literal|6
operator|/
literal|2
expr_stmt|;
name|sc
operator|->
name|arrq
operator|.
name|ndb
operator|=
name|NDB
expr_stmt|;
name|sc
operator|->
name|arrs
operator|.
name|ndb
operator|=
name|NDB
operator|/
literal|2
expr_stmt|;
name|sc
operator|->
name|atrq
operator|.
name|ndb
operator|=
name|NDB
expr_stmt|;
name|sc
operator|->
name|atrs
operator|.
name|ndb
operator|=
name|NDB
operator|/
literal|2
expr_stmt|;
name|sc
operator|->
name|arrq
operator|.
name|dummy
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|arrs
operator|.
name|dummy
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|atrq
operator|.
name|dummy
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|atrs
operator|.
name|dummy
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|fc
operator|.
name|nisodma
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|fc
operator|.
name|it
index|[
name|i
index|]
operator|=
operator|&
name|sc
operator|->
name|it
index|[
name|i
index|]
operator|.
name|xferq
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|ir
index|[
name|i
index|]
operator|=
operator|&
name|sc
operator|->
name|ir
index|[
name|i
index|]
operator|.
name|xferq
expr_stmt|;
name|sc
operator|->
name|it
index|[
name|i
index|]
operator|.
name|ndb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|ir
index|[
name|i
index|]
operator|.
name|ndb
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|fc
operator|.
name|tcode
operator|=
name|tinfo
expr_stmt|;
name|sc
operator|->
name|cromptr
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|malloc
argument_list|(
name|CROMSIZE
operator|*
literal|2
argument_list|,
name|M_FW
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cromptr
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cromptr alloc failed."
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|sc
operator|->
name|fc
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|config_rom
operator|=
operator|&
operator|(
name|sc
operator|->
name|cromptr
index|[
name|CROMSIZE
operator|/
literal|4
index|]
operator|)
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|config_rom
index|[
literal|1
index|]
operator|=
literal|0x31333934
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|config_rom
index|[
literal|2
index|]
operator|=
literal|0xf000a002
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|config_rom
index|[
literal|3
index|]
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_EUID_HI
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|config_rom
index|[
literal|4
index|]
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_EUID_LO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|config_rom
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|config_rom
index|[
literal|0
index|]
operator|=
operator|(
literal|4
operator|<<
literal|24
operator|)
operator||
operator|(
literal|5
operator|<<
literal|16
operator|)
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|config_rom
index|[
literal|0
index|]
operator||=
name|fw_crc16
argument_list|(
operator|&
name|sc
operator|->
name|fc
operator|.
name|config_rom
index|[
literal|1
index|]
argument_list|,
literal|5
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* SID recieve buffer must allign 2^11 */
define|#
directive|define
name|OHCI_SIDSIZE
value|(1<< 11)
name|sc
operator|->
name|fc
operator|.
name|sid_buf
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|malloc
argument_list|(
name|OHCI_SIDSIZE
argument_list|,
name|M_FW
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fc
operator|.
name|sid_buf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"sid_buf alloc failed.\n"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|vm_offset_t
operator|)
name|sc
operator|->
name|fc
operator|.
name|sid_buf
operator|&
operator|(
name|OHCI_SIDSIZE
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"sid_buf(%p) not aligned.\n"
argument_list|,
name|sc
operator|->
name|fc
operator|.
name|sid_buf
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|fwohci_db_init
argument_list|(
operator|&
name|sc
operator|->
name|arrq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|arrq
operator|.
name|flags
operator|&
name|FWOHCI_DBCH_INIT
operator|)
operator|==
literal|0
condition|)
return|return
name|ENOMEM
return|;
name|fwohci_db_init
argument_list|(
operator|&
name|sc
operator|->
name|arrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|arrs
operator|.
name|flags
operator|&
name|FWOHCI_DBCH_INIT
operator|)
operator|==
literal|0
condition|)
return|return
name|ENOMEM
return|;
name|fwohci_db_init
argument_list|(
operator|&
name|sc
operator|->
name|atrq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|atrq
operator|.
name|flags
operator|&
name|FWOHCI_DBCH_INIT
operator|)
operator|==
literal|0
condition|)
return|return
name|ENOMEM
return|;
name|fwohci_db_init
argument_list|(
operator|&
name|sc
operator|->
name|atrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|atrs
operator|.
name|flags
operator|&
name|FWOHCI_DBCH_INIT
operator|)
operator|==
literal|0
condition|)
return|return
name|ENOMEM
return|;
name|sc
operator|->
name|fc
operator|.
name|eui
operator|.
name|hi
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCIGUID_H
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|eui
operator|.
name|lo
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCIGUID_L
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|ui
index|[
name|i
index|]
operator|=
name|FW_EUI64_BYTE
argument_list|(
operator|&
name|sc
operator|->
name|fc
operator|.
name|eui
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"EUI64 %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n"
argument_list|,
name|ui
index|[
literal|0
index|]
argument_list|,
name|ui
index|[
literal|1
index|]
argument_list|,
name|ui
index|[
literal|2
index|]
argument_list|,
name|ui
index|[
literal|3
index|]
argument_list|,
name|ui
index|[
literal|4
index|]
argument_list|,
name|ui
index|[
literal|5
index|]
argument_list|,
name|ui
index|[
literal|6
index|]
argument_list|,
name|ui
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|ioctl
operator|=
name|fwohci_ioctl
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|cyctimer
operator|=
name|fwohci_cyctimer
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|set_bmr
operator|=
name|fwohci_set_bus_manager
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|ibr
operator|=
name|fwohci_ibr
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|irx_enable
operator|=
name|fwohci_irx_enable
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|irx_disable
operator|=
name|fwohci_irx_disable
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|itx_enable
operator|=
name|fwohci_itxbuf_enable
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|itx_disable
operator|=
name|fwohci_itx_disable
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|irx_post
operator|=
name|fwohci_irx_post
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|itx_post
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|timeout
operator|=
name|fwohci_timeout
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|poll
operator|=
name|fwohci_poll
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|set_intr
operator|=
name|fwohci_set_intr
expr_stmt|;
name|fw_init
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|)
expr_stmt|;
name|fwohci_reset
argument_list|(
name|sc
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|fwohci_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|fc
operator|.
name|timeout_callout
argument_list|,
name|FW_XFERTIMEOUT
operator|*
name|hz
operator|*
literal|10
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fwohci_timeout
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_int32_t
name|fwohci_cyctimer
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
decl_stmt|;
return|return
operator|(
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_CYCLETIMER
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fwohci_detach
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|fc
operator|.
name|sid_buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|sc
operator|->
name|fc
operator|.
name|sid_buf
argument_list|,
name|M_FW
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cromptr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|cromptr
argument_list|,
name|M_FW
argument_list|)
expr_stmt|;
name|fwohci_db_free
argument_list|(
operator|&
name|sc
operator|->
name|arrq
argument_list|)
expr_stmt|;
name|fwohci_db_free
argument_list|(
operator|&
name|sc
operator|->
name|arrs
argument_list|)
expr_stmt|;
name|fwohci_db_free
argument_list|(
operator|&
name|sc
operator|->
name|atrq
argument_list|)
expr_stmt|;
name|fwohci_db_free
argument_list|(
operator|&
name|sc
operator|->
name|atrs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|fc
operator|.
name|nisodma
condition|;
name|i
operator|++
control|)
block|{
name|fwohci_db_free
argument_list|(
operator|&
name|sc
operator|->
name|it
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fwohci_db_free
argument_list|(
operator|&
name|sc
operator|->
name|ir
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|LAST_DB
parameter_list|(
name|dbtr
parameter_list|,
name|db
parameter_list|)
value|do {						\ 	struct fwohcidb_tr *_dbtr = (dbtr);				\ 	int _cnt = _dbtr->dbcnt;					\ 	db =&_dbtr->db[ (_cnt> 2) ? (_cnt -1) : 0];			\ } while (0)
end_define

begin_function
specifier|static
name|void
name|fwohci_start
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|fwohci_dbch
modifier|*
name|dbch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|int
name|tcode
decl_stmt|,
name|hdr_len
decl_stmt|,
name|hdr_off
decl_stmt|,
name|len
decl_stmt|;
name|int
name|fsegment
init|=
operator|-
literal|1
decl_stmt|;
name|u_int32_t
name|off
decl_stmt|;
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
specifier|volatile
name|struct
name|fwohci_txpkthdr
modifier|*
name|ohcifp
decl_stmt|;
name|struct
name|fwohcidb_tr
modifier|*
name|db_tr
decl_stmt|;
specifier|volatile
name|struct
name|fwohcidb
modifier|*
name|db
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|tcode_info
modifier|*
name|info
decl_stmt|;
specifier|static
name|int
name|maxdesc
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|&
name|sc
operator|->
name|atrq
operator|==
name|dbch
condition|)
block|{
name|off
operator|=
name|OHCI_ATQOFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|&
name|sc
operator|->
name|atrs
operator|==
name|dbch
condition|)
block|{
name|off
operator|=
name|OHCI_ATSOFF
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
if|if
condition|(
name|dbch
operator|->
name|flags
operator|&
name|FWOHCI_DBCH_FULL
condition|)
return|return;
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|db_tr
operator|=
name|dbch
operator|->
name|top
expr_stmt|;
name|txloop
label|:
name|xfer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dbch
operator|->
name|xferq
operator|.
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
goto|goto
name|kick
goto|;
block|}
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|queued
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"TX queue empty\n"
argument_list|)
expr_stmt|;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|dbch
operator|->
name|xferq
operator|.
name|q
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|db_tr
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
name|xfer
operator|->
name|state
operator|=
name|FWXF_START
expr_stmt|;
name|dbch
operator|->
name|xferq
operator|.
name|packets
operator|++
expr_stmt|;
name|fp
operator|=
operator|(
expr|struct
name|fw_pkt
operator|*
operator|)
operator|(
name|xfer
operator|->
name|send
operator|.
name|buf
operator|+
name|xfer
operator|->
name|send
operator|.
name|off
operator|)
expr_stmt|;
name|tcode
operator|=
name|fp
operator|->
name|mode
operator|.
name|common
operator|.
name|tcode
expr_stmt|;
name|ohcifp
operator|=
operator|(
specifier|volatile
expr|struct
name|fwohci_txpkthdr
operator|*
operator|)
name|db_tr
operator|->
name|db
index|[
literal|1
index|]
operator|.
name|db
operator|.
name|immed
expr_stmt|;
name|info
operator|=
operator|&
name|tinfo
index|[
name|tcode
index|]
expr_stmt|;
name|hdr_len
operator|=
name|hdr_off
operator|=
name|info
operator|->
name|hdr_len
expr_stmt|;
comment|/* fw_asyreq must pass valid send.len */
name|len
operator|=
name|xfer
operator|->
name|send
operator|.
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr_off
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|ohcifp
operator|->
name|mode
operator|.
name|ld
index|[
name|i
operator|/
literal|4
index|]
operator|=
name|ntohl
argument_list|(
name|fp
operator|->
name|mode
operator|.
name|ld
index|[
name|i
operator|/
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
name|ohcifp
operator|->
name|mode
operator|.
name|common
operator|.
name|spd
operator|=
name|xfer
operator|->
name|spd
expr_stmt|;
if|if
condition|(
name|tcode
operator|==
name|FWTCODE_STREAM
condition|)
block|{
name|hdr_len
operator|=
literal|8
expr_stmt|;
name|ohcifp
operator|->
name|mode
operator|.
name|stream
operator|.
name|len
operator|=
name|ntohs
argument_list|(
name|fp
operator|->
name|mode
operator|.
name|stream
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tcode
operator|==
name|FWTCODE_PHY
condition|)
block|{
name|hdr_len
operator|=
literal|12
expr_stmt|;
name|ohcifp
operator|->
name|mode
operator|.
name|ld
index|[
literal|1
index|]
operator|=
name|ntohl
argument_list|(
name|fp
operator|->
name|mode
operator|.
name|ld
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ohcifp
operator|->
name|mode
operator|.
name|ld
index|[
literal|2
index|]
operator|=
name|ntohl
argument_list|(
name|fp
operator|->
name|mode
operator|.
name|ld
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ohcifp
operator|->
name|mode
operator|.
name|common
operator|.
name|spd
operator|=
literal|0
expr_stmt|;
name|ohcifp
operator|->
name|mode
operator|.
name|common
operator|.
name|tcode
operator|=
name|FWOHCITCODE_PHY
expr_stmt|;
block|}
else|else
block|{
name|ohcifp
operator|->
name|mode
operator|.
name|asycomm
operator|.
name|dst
operator|=
name|ntohs
argument_list|(
name|fp
operator|->
name|mode
operator|.
name|hdr
operator|.
name|dst
argument_list|)
expr_stmt|;
name|ohcifp
operator|->
name|mode
operator|.
name|asycomm
operator|.
name|srcbus
operator|=
name|OHCI_ASYSRCBUS
expr_stmt|;
name|ohcifp
operator|->
name|mode
operator|.
name|asycomm
operator|.
name|tlrt
operator||=
name|FWRETRY_X
expr_stmt|;
block|}
name|db
operator|=
operator|&
name|db_tr
operator|->
name|db
index|[
literal|0
index|]
expr_stmt|;
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|control
operator|=
name|OHCI_OUTPUT_MORE
operator||
name|OHCI_KEY_ST2
expr_stmt|;
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|reqcount
operator|=
name|hdr_len
expr_stmt|;
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|status
operator|=
literal|0
expr_stmt|;
comment|/* Specify bound timer of asy. responce */
if|if
condition|(
operator|&
name|sc
operator|->
name|atrs
operator|==
name|dbch
condition|)
block|{
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|count
operator|=
operator|(
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_CYCLETIMER
argument_list|)
operator|>>
literal|12
operator|)
operator|+
operator|(
literal|1
operator|<<
literal|13
operator|)
expr_stmt|;
block|}
name|db_tr
operator|->
name|dbcnt
operator|=
literal|2
expr_stmt|;
name|db
operator|=
operator|&
name|db_tr
operator|->
name|db
index|[
name|db_tr
operator|->
name|dbcnt
index|]
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|hdr_off
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|mbuf
operator|==
name|NULL
condition|)
block|{
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|addr
operator|=
name|vtophys
argument_list|(
name|xfer
operator|->
name|send
operator|.
name|buf
operator|+
name|xfer
operator|->
name|send
operator|.
name|off
argument_list|)
operator|+
name|hdr_off
expr_stmt|;
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|control
operator|=
name|OHCI_OUTPUT_MORE
expr_stmt|;
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|reqcount
operator|=
name|len
operator|-
name|hdr_off
expr_stmt|;
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|db_tr
operator|->
name|dbcnt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|int
name|mchain
init|=
literal|0
decl_stmt|;
comment|/* XXX we assume mbuf chain is shorter than ndesc */
for|for
control|(
name|m
operator|=
name|xfer
operator|->
name|mbuf
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
literal|0
condition|)
comment|/* unrecoverable error could occur. */
continue|continue;
name|mchain
operator|++
expr_stmt|;
if|if
condition|(
name|db_tr
operator|->
name|dbcnt
operator|>=
name|dbch
operator|->
name|ndesc
condition|)
continue|continue;
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|addr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|control
operator|=
name|OHCI_OUTPUT_MORE
expr_stmt|;
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|reqcount
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|db
operator|++
expr_stmt|;
name|db_tr
operator|->
name|dbcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mchain
operator|>
name|dbch
operator|->
name|ndesc
operator|-
literal|2
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"dbch->ndesc(%d) is too small for"
literal|" mbuf chain(%d), trancated.\n"
argument_list|,
name|dbch
operator|->
name|ndesc
argument_list|,
name|mchain
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|maxdesc
operator|<
name|db_tr
operator|->
name|dbcnt
condition|)
block|{
name|maxdesc
operator|=
name|db_tr
operator|->
name|dbcnt
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"maxdesc: %d\n"
argument_list|,
name|maxdesc
argument_list|)
expr_stmt|;
block|}
comment|/* last db */
name|LAST_DB
argument_list|(
name|db_tr
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|control
operator||=
name|OHCI_OUTPUT_LAST
operator||
name|OHCI_INTERRUPT_ALWAYS
operator||
name|OHCI_BRANCH_ALWAYS
expr_stmt|;
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|depend
operator|=
name|vtophys
argument_list|(
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsegment
operator|==
operator|-
literal|1
condition|)
name|fsegment
operator|=
name|db_tr
operator|->
name|dbcnt
expr_stmt|;
if|if
condition|(
name|dbch
operator|->
name|pdb_tr
operator|!=
name|NULL
condition|)
block|{
name|LAST_DB
argument_list|(
name|dbch
operator|->
name|pdb_tr
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|depend
operator||=
name|db_tr
operator|->
name|dbcnt
expr_stmt|;
block|}
name|dbch
operator|->
name|pdb_tr
operator|=
name|db_tr
expr_stmt|;
name|db_tr
operator|=
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_tr
operator|!=
name|dbch
operator|->
name|bottom
condition|)
block|{
goto|goto
name|txloop
goto|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"fwohci_start: lack of db_trq\n"
argument_list|)
expr_stmt|;
name|dbch
operator|->
name|flags
operator||=
name|FWOHCI_DBCH_FULL
expr_stmt|;
block|}
name|kick
label|:
if|if
condition|(
name|firewire_debug
condition|)
name|printf
argument_list|(
literal|"kick\n"
argument_list|)
expr_stmt|;
comment|/* kick asy q */
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_RUNNING
condition|)
block|{
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_DMACTL
argument_list|(
name|off
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_WAKE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"start AT DMA status=%x\n"
argument_list|,
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_DMACTL
argument_list|(
name|off
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_DMACMD
argument_list|(
name|off
argument_list|)
argument_list|,
name|vtophys
argument_list|(
name|dbch
operator|->
name|top
operator|->
name|db
argument_list|)
operator||
name|fsegment
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_DMACTL
argument_list|(
name|off
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator||=
name|FWXFERQ_RUNNING
expr_stmt|;
block|}
name|dbch
operator|->
name|top
operator|=
name|db_tr
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_drain_atq
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
decl_stmt|;
name|fwohci_drain
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|,
name|xfer
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|atrq
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_drain_ats
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
decl_stmt|;
name|fwohci_drain
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|,
name|xfer
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|atrs
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_start_atq
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
decl_stmt|;
name|fwohci_start
argument_list|(
name|sc
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|atrq
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_start_ats
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
decl_stmt|;
name|fwohci_start
argument_list|(
name|sc
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|atrs
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|fwohci_txd
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|fwohci_dbch
modifier|*
name|dbch
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|fwohcidb_tr
modifier|*
name|tr
decl_stmt|;
specifier|volatile
name|struct
name|fwohcidb
modifier|*
name|db
decl_stmt|;
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|u_int32_t
name|off
decl_stmt|;
name|u_int
name|stat
decl_stmt|;
name|int
name|packets
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
init|=
operator|(
expr|struct
name|firewire_comm
operator|*
operator|)
name|sc
decl_stmt|;
if|if
condition|(
operator|&
name|sc
operator|->
name|atrq
operator|==
name|dbch
condition|)
block|{
name|off
operator|=
name|OHCI_ATQOFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|&
name|sc
operator|->
name|atrs
operator|==
name|dbch
condition|)
block|{
name|off
operator|=
name|OHCI_ATSOFF
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|tr
operator|=
name|dbch
operator|->
name|bottom
expr_stmt|;
name|packets
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|queued
operator|>
literal|0
condition|)
block|{
name|LAST_DB
argument_list|(
name|tr
argument_list|,
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|status
operator|&
name|OHCI_CNTL_DMA_ACTIVE
operator|)
condition|)
block|{
if|if
condition|(
name|fc
operator|->
name|status
operator|!=
name|FWBUSRESET
condition|)
comment|/* maybe out of order?? */
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|status
operator|&
name|OHCI_CNTL_DMA_DEAD
condition|)
block|{
ifdef|#
directive|ifdef
name|OHCI_DEBUG
name|dump_dma
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|dump_db
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Stop DMA */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_DMACTLCLR
argument_list|(
name|off
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"force reset AT FIFO\n"
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTLCLR
argument_list|,
name|OHCI_HCC_LINKEN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|,
name|OHCI_HCC_LPS
operator||
name|OHCI_HCC_LINKEN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_DMACTLCLR
argument_list|(
name|off
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
block|}
name|stat
operator|=
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|status
operator|&
name|FWOHCIEV_MASK
expr_stmt|;
switch|switch
condition|(
name|stat
condition|)
block|{
case|case
name|FWOHCIEV_ACKCOMPL
case|:
case|case
name|FWOHCIEV_ACKPEND
case|:
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FWOHCIEV_ACKBSA
case|:
case|case
name|FWOHCIEV_ACKBSB
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"txd err=%2x %s\n"
argument_list|,
name|stat
argument_list|,
name|fwohcicode
index|[
name|stat
index|]
argument_list|)
expr_stmt|;
case|case
name|FWOHCIEV_ACKBSX
case|:
name|err
operator|=
name|EBUSY
expr_stmt|;
break|break;
case|case
name|FWOHCIEV_FLUSHED
case|:
case|case
name|FWOHCIEV_ACKTARD
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"txd err=%2x %s\n"
argument_list|,
name|stat
argument_list|,
name|fwohcicode
index|[
name|stat
index|]
argument_list|)
expr_stmt|;
name|err
operator|=
name|EAGAIN
expr_stmt|;
break|break;
case|case
name|FWOHCIEV_MISSACK
case|:
case|case
name|FWOHCIEV_UNDRRUN
case|:
case|case
name|FWOHCIEV_OVRRUN
case|:
case|case
name|FWOHCIEV_DESCERR
case|:
case|case
name|FWOHCIEV_DTRDERR
case|:
case|case
name|FWOHCIEV_TIMEOUT
case|:
case|case
name|FWOHCIEV_TCODERR
case|:
case|case
name|FWOHCIEV_UNKNOWN
case|:
case|case
name|FWOHCIEV_ACKDERR
case|:
case|case
name|FWOHCIEV_ACKTERR
case|:
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"txd err=%2x %s\n"
argument_list|,
name|stat
argument_list|,
name|fwohcicode
index|[
name|stat
index|]
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tr
operator|->
name|xfer
operator|!=
name|NULL
condition|)
block|{
name|xfer
operator|=
name|tr
operator|->
name|xfer
expr_stmt|;
name|xfer
operator|->
name|state
operator|=
name|FWXF_SENT
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EBUSY
operator|&&
name|fc
operator|->
name|status
operator|!=
name|FWBUSRESET
condition|)
block|{
name|xfer
operator|->
name|state
operator|=
name|FWXF_BUSY
expr_stmt|;
switch|switch
condition|(
name|xfer
operator|->
name|act_type
condition|)
block|{
case|case
name|FWACT_XFER
case|:
name|xfer
operator|->
name|resp
operator|=
name|err
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|retry_req
operator|!=
name|NULL
condition|)
block|{
name|xfer
operator|->
name|retry_req
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|stat
operator|!=
name|FWOHCIEV_ACKPEND
condition|)
block|{
if|if
condition|(
name|stat
operator|!=
name|FWOHCIEV_ACKCOMPL
condition|)
name|xfer
operator|->
name|state
operator|=
name|FWXF_SENTERR
expr_stmt|;
name|xfer
operator|->
name|resp
operator|=
name|err
expr_stmt|;
switch|switch
condition|(
name|xfer
operator|->
name|act_type
condition|)
block|{
case|case
name|FWACT_XFER
case|:
name|fw_xfer_done
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|dbch
operator|->
name|xferq
operator|.
name|queued
operator|--
expr_stmt|;
block|}
name|tr
operator|->
name|xfer
operator|=
name|NULL
expr_stmt|;
name|packets
operator|++
expr_stmt|;
name|tr
operator|=
name|STAILQ_NEXT
argument_list|(
name|tr
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dbch
operator|->
name|bottom
operator|=
name|tr
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
operator|(
name|dbch
operator|->
name|flags
operator|&
name|FWOHCI_DBCH_FULL
operator|)
operator|&&
name|packets
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"make free slot\n"
argument_list|)
expr_stmt|;
name|dbch
operator|->
name|flags
operator|&=
operator|~
name|FWOHCI_DBCH_FULL
expr_stmt|;
name|fwohci_start
argument_list|(
name|sc
argument_list|,
name|dbch
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_drain
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|,
name|struct
name|fwohci_dbch
modifier|*
name|dbch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|fwohcidb_tr
modifier|*
name|tr
decl_stmt|;
if|if
condition|(
name|xfer
operator|->
name|state
operator|!=
name|FWXF_START
condition|)
return|return;
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|tr
operator|=
name|dbch
operator|->
name|bottom
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|dbch
operator|->
name|xferq
operator|.
name|queued
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tr
operator|->
name|xfer
operator|==
name|xfer
condition|)
block|{
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|tr
operator|->
name|xfer
operator|=
name|NULL
expr_stmt|;
name|dbch
operator|->
name|xferq
operator|.
name|queued
operator|--
expr_stmt|;
if|#
directive|if
literal|1
comment|/* XXX */
if|if
condition|(
name|tr
operator|==
name|dbch
operator|->
name|bottom
condition|)
name|dbch
operator|->
name|bottom
operator|=
name|STAILQ_NEXT
argument_list|(
name|tr
argument_list|,
name|link
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dbch
operator|->
name|flags
operator|&
name|FWOHCI_DBCH_FULL
condition|)
block|{
name|printf
argument_list|(
literal|"fwohci_drain: make slot\n"
argument_list|)
expr_stmt|;
name|dbch
operator|->
name|flags
operator|&=
operator|~
name|FWOHCI_DBCH_FULL
expr_stmt|;
name|fwohci_start
argument_list|(
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
argument_list|,
name|dbch
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|tr
operator|=
name|STAILQ_NEXT
argument_list|(
name|tr
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_db_free
parameter_list|(
name|struct
name|fwohci_dbch
modifier|*
name|dbch
parameter_list|)
block|{
name|struct
name|fwohcidb_tr
modifier|*
name|db_tr
decl_stmt|;
name|int
name|idb
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|dbch
operator|->
name|flags
operator|&
name|FWOHCI_DBCH_INIT
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_EXTBUF
operator|)
condition|)
block|{
for|for
control|(
name|db_tr
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dbch
operator|->
name|db_trq
argument_list|)
operator|,
name|idb
operator|=
literal|0
init|;
name|idb
operator|<
name|dbch
operator|->
name|ndb
condition|;
name|db_tr
operator|=
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
operator|,
name|idb
operator|++
control|)
block|{
if|if
condition|(
name|db_tr
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|db_tr
operator|->
name|buf
argument_list|,
name|M_FW
argument_list|)
expr_stmt|;
name|db_tr
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|dbch
operator|->
name|ndb
operator|=
literal|0
expr_stmt|;
name|db_tr
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dbch
operator|->
name|db_trq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dbch
operator|->
name|npages
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|dbch
operator|->
name|pages
index|[
name|i
index|]
argument_list|,
name|M_FW
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|db_tr
argument_list|,
name|M_FW
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|dbch
operator|->
name|db_trq
argument_list|)
expr_stmt|;
name|dbch
operator|->
name|flags
operator|&=
operator|~
name|FWOHCI_DBCH_INIT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_db_init
parameter_list|(
name|struct
name|fwohci_dbch
modifier|*
name|dbch
parameter_list|)
block|{
name|int
name|idb
decl_stmt|;
name|struct
name|fwohcidb_tr
modifier|*
name|db_tr
decl_stmt|;
name|int
name|ndbpp
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|dbch
operator|->
name|flags
operator|&
name|FWOHCI_DBCH_INIT
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* allocate DB entries and attach one to each DMA channels */
comment|/* DB entry must start at 16 bytes bounary. */
name|STAILQ_INIT
argument_list|(
operator|&
name|dbch
operator|->
name|db_trq
argument_list|)
expr_stmt|;
name|db_tr
operator|=
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fwohcidb_tr
argument_list|)
operator|*
name|dbch
operator|->
name|ndb
argument_list|,
name|M_FW
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_tr
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"fwohci_db_init: malloc(1) failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ndbpp
operator|=
name|PAGE_SIZE
operator|/
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|fwohcidb
argument_list|)
operator|*
name|dbch
operator|->
name|ndesc
operator|)
expr_stmt|;
name|dbch
operator|->
name|npages
operator|=
operator|(
name|dbch
operator|->
name|ndb
operator|+
name|ndbpp
operator|-
literal|1
operator|)
operator|/
name|ndbpp
expr_stmt|;
if|if
condition|(
name|firewire_debug
condition|)
name|printf
argument_list|(
literal|"ndesc: %d, ndbpp: %d, ndb: %d, npages: %d\n"
argument_list|,
name|dbch
operator|->
name|ndesc
argument_list|,
name|ndbpp
argument_list|,
name|dbch
operator|->
name|ndb
argument_list|,
name|dbch
operator|->
name|npages
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbch
operator|->
name|npages
operator|>
name|FWOHCI_DBCH_MAX_PAGES
condition|)
block|{
name|printf
argument_list|(
literal|"npages(%d)> DBCH_MAX_PAGES(%d)\n"
argument_list|,
name|dbch
operator|->
name|npages
argument_list|,
name|FWOHCI_DBCH_MAX_PAGES
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dbch
operator|->
name|npages
condition|;
name|i
operator|++
control|)
block|{
name|dbch
operator|->
name|pages
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_FW
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbch
operator|->
name|pages
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"fwohci_db_init: malloc(2) failed\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|free
argument_list|(
name|dbch
operator|->
name|pages
index|[
name|j
index|]
argument_list|,
name|M_FW
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|db_tr
argument_list|,
name|M_FW
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Attach DB to DMA ch. */
for|for
control|(
name|idb
operator|=
literal|0
init|;
name|idb
operator|<
name|dbch
operator|->
name|ndb
condition|;
name|idb
operator|++
control|)
block|{
name|db_tr
operator|->
name|dbcnt
operator|=
literal|0
expr_stmt|;
name|db_tr
operator|->
name|db
operator|=
operator|(
expr|struct
name|fwohcidb
operator|*
operator|)
name|dbch
operator|->
name|pages
index|[
name|idb
operator|/
name|ndbpp
index|]
operator|+
name|dbch
operator|->
name|ndesc
operator|*
operator|(
name|idb
operator|%
name|ndbpp
operator|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dbch
operator|->
name|db_trq
argument_list|,
name|db_tr
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_PACKET
operator|)
operator|&&
name|dbch
operator|->
name|xferq
operator|.
name|bnpacket
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|idb
operator|%
name|dbch
operator|->
name|xferq
operator|.
name|bnpacket
operator|==
literal|0
condition|)
name|dbch
operator|->
name|xferq
operator|.
name|bulkxfer
index|[
name|idb
operator|/
name|dbch
operator|->
name|xferq
operator|.
name|bnpacket
index|]
operator|.
name|start
operator|=
operator|(
name|caddr_t
operator|)
name|db_tr
expr_stmt|;
if|if
condition|(
operator|(
name|idb
operator|+
literal|1
operator|)
operator|%
name|dbch
operator|->
name|xferq
operator|.
name|bnpacket
operator|==
literal|0
condition|)
name|dbch
operator|->
name|xferq
operator|.
name|bulkxfer
index|[
name|idb
operator|/
name|dbch
operator|->
name|xferq
operator|.
name|bnpacket
index|]
operator|.
name|end
operator|=
operator|(
name|caddr_t
operator|)
name|db_tr
expr_stmt|;
block|}
name|db_tr
operator|++
expr_stmt|;
block|}
name|STAILQ_LAST
argument_list|(
operator|&
name|dbch
operator|->
name|db_trq
argument_list|,
name|fwohcidb_tr
argument_list|,
name|link
argument_list|)
operator|->
name|link
operator|.
name|stqe_next
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dbch
operator|->
name|db_trq
argument_list|)
expr_stmt|;
name|out
label|:
name|dbch
operator|->
name|frag
operator|.
name|buf
operator|=
name|NULL
expr_stmt|;
name|dbch
operator|->
name|frag
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|dbch
operator|->
name|frag
operator|.
name|plen
operator|=
literal|0
expr_stmt|;
name|dbch
operator|->
name|xferq
operator|.
name|queued
operator|=
literal|0
expr_stmt|;
name|dbch
operator|->
name|pdb_tr
operator|=
name|NULL
expr_stmt|;
name|dbch
operator|->
name|top
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dbch
operator|->
name|db_trq
argument_list|)
expr_stmt|;
name|dbch
operator|->
name|bottom
operator|=
name|dbch
operator|->
name|top
expr_stmt|;
name|dbch
operator|->
name|flags
operator|=
name|FWOHCI_DBCH_INIT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_itx_disable
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|int
name|dmach
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ITCTLCLR
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_MASKCLR
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_STATCLR
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
comment|/* XXX we cannot free buffers until the DMA really stops */
name|tsleep
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|dummy
argument_list|,
name|FWPRI
argument_list|,
literal|"fwitxd"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|fwohci_db_free
argument_list|(
operator|&
name|sc
operator|->
name|it
index|[
name|dmach
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|it
index|[
name|dmach
index|]
operator|.
name|xferq
operator|.
name|flag
operator|&=
operator|~
name|FWXFERQ_RUNNING
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_irx_disable
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|int
name|dmach
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTLCLR
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_MASKCLR
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_STATCLR
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
comment|/* XXX we cannot free buffers until the DMA really stops */
name|tsleep
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|dummy
argument_list|,
name|FWPRI
argument_list|,
literal|"fwirxd"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|.
name|dummy
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|.
name|dummy
argument_list|,
name|M_FW
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|.
name|dummy
operator|=
name|NULL
expr_stmt|;
name|fwohci_db_free
argument_list|(
operator|&
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|.
name|xferq
operator|.
name|flag
operator|&=
operator|~
name|FWXFERQ_RUNNING
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_irx_post
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|u_int32_t
modifier|*
name|qld
parameter_list|)
block|{
name|qld
index|[
literal|0
index|]
operator|=
name|ntohl
argument_list|(
name|qld
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_irxpp_enable
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|int
name|dmach
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|unsigned
name|short
name|tag
decl_stmt|,
name|ich
decl_stmt|;
name|tag
operator|=
operator|(
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|.
name|xferq
operator|.
name|flag
operator|>>
literal|6
operator|)
operator|&
literal|3
expr_stmt|;
name|ich
operator|=
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|.
name|xferq
operator|.
name|flag
operator|&
literal|0x3f
expr_stmt|;
if|#
directive|if
literal|0
block|if(STAILQ_FIRST(&fc->ir[dmach]->q) != NULL){ 		wakeup(fc->ir[dmach]); 		return err; 	}
endif|#
directive|endif
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRMATCH
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|tagbit
index|[
name|tag
index|]
operator||
name|ich
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|.
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_RUNNING
operator|)
condition|)
block|{
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|.
name|xferq
operator|.
name|queued
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|.
name|ndb
operator|=
name|NDB
expr_stmt|;
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|.
name|xferq
operator|.
name|psize
operator|=
name|PAGE_SIZE
expr_stmt|;
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|.
name|ndesc
operator|=
literal|1
expr_stmt|;
name|fwohci_db_init
argument_list|(
operator|&
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|.
name|flags
operator|&
name|FWOHCI_DBCH_INIT
operator|)
operator|==
literal|0
condition|)
return|return
name|ENOMEM
return|;
name|err
operator|=
name|fwohci_rx_enable
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"err in IRX setting\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTL
argument_list|(
name|dmach
argument_list|)
argument_list|)
operator|&
name|OHCI_CNTL_DMA_ACTIVE
operator|)
condition|)
block|{
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTLCLR
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_MASKCLR
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_STATCLR
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_MASK
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTLCLR
argument_list|(
name|dmach
argument_list|)
argument_list|,
literal|0xf8000000
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTL
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|OHCI_CNTL_ISOHDR
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCMD
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|vtophys
argument_list|(
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|.
name|top
operator|->
name|db
argument_list|)
operator||
literal|1
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTL
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASK
argument_list|,
name|OHCI_INT_DMA_IR
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_tx_enable
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|fwohci_dbch
modifier|*
name|dbch
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|idb
decl_stmt|,
name|z
decl_stmt|,
name|i
decl_stmt|,
name|dmach
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|off
init|=
name|NULL
decl_stmt|;
name|struct
name|fwohcidb_tr
modifier|*
name|db_tr
decl_stmt|;
specifier|volatile
name|struct
name|fwohcidb
modifier|*
name|db
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_EXTBUF
operator|)
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
return|return
name|err
return|;
block|}
name|z
operator|=
name|dbch
operator|->
name|ndesc
expr_stmt|;
for|for
control|(
name|dmach
operator|=
literal|0
init|;
name|dmach
operator|<
name|sc
operator|->
name|fc
operator|.
name|nisodma
condition|;
name|dmach
operator|++
control|)
block|{
if|if
condition|(
operator|&
name|sc
operator|->
name|it
index|[
name|dmach
index|]
operator|==
name|dbch
condition|)
block|{
name|off
operator|=
name|OHCI_ITOFF
argument_list|(
name|dmach
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|off
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_RUNNING
condition|)
return|return
name|err
return|;
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator||=
name|FWXFERQ_RUNNING
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|dbch
operator|->
name|bottom
operator|=
name|dbch
operator|->
name|top
init|;
name|i
operator|<
operator|(
name|dbch
operator|->
name|ndb
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|dbch
operator|->
name|bottom
operator|=
name|STAILQ_NEXT
argument_list|(
name|dbch
operator|->
name|bottom
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|db_tr
operator|=
name|dbch
operator|->
name|top
expr_stmt|;
for|for
control|(
name|idb
operator|=
literal|0
init|;
name|idb
operator|<
name|dbch
operator|->
name|ndb
condition|;
name|idb
operator|++
control|)
block|{
name|fwohci_add_tx_buf
argument_list|(
name|db_tr
argument_list|,
name|dbch
operator|->
name|xferq
operator|.
name|psize
argument_list|,
name|dbch
operator|->
name|xferq
operator|.
name|flag
argument_list|,
name|dbch
operator|->
name|xferq
operator|.
name|buf
operator|+
name|dbch
operator|->
name|xferq
operator|.
name|psize
operator|*
name|idb
argument_list|)
expr_stmt|;
if|if
condition|(
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|db
operator|=
name|db_tr
operator|->
name|db
expr_stmt|;
name|db
index|[
literal|0
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
operator|=
name|db
index|[
name|db_tr
operator|->
name|dbcnt
operator|-
literal|1
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
operator|=
name|vtophys
argument_list|(
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
operator|->
name|db
argument_list|)
operator||
name|z
expr_stmt|;
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_EXTBUF
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|idb
operator|+
literal|1
operator|)
operator|%
name|dbch
operator|->
name|xferq
operator|.
name|bnpacket
operator|)
operator|==
literal|0
condition|)
block|{
name|db
index|[
name|db_tr
operator|->
name|dbcnt
operator|-
literal|1
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|control
operator||=
name|OHCI_INTERRUPT_ALWAYS
expr_stmt|;
comment|/* OHCI 1.1 and above */
name|db
index|[
literal|0
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|control
operator||=
name|OHCI_INTERRUPT_ALWAYS
expr_stmt|;
if|#
directive|if
literal|0
block|db[0].db.desc.depend&= ~0xf; 				db[db_tr->dbcnt - 1].db.desc.depend&= ~0xf;
endif|#
directive|endif
block|}
block|}
name|db_tr
operator|=
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|dbch
operator|->
name|bottom
operator|->
name|db
index|[
name|db_tr
operator|->
name|dbcnt
operator|-
literal|1
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
operator|&=
literal|0xfffffff0
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_rx_enable
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|fwohci_dbch
modifier|*
name|dbch
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|idb
decl_stmt|,
name|z
decl_stmt|,
name|i
decl_stmt|,
name|dmach
init|=
literal|0
decl_stmt|,
name|ldesc
decl_stmt|;
name|u_int32_t
name|off
init|=
name|NULL
decl_stmt|;
name|struct
name|fwohcidb_tr
modifier|*
name|db_tr
decl_stmt|;
specifier|volatile
name|struct
name|fwohcidb
modifier|*
name|db
decl_stmt|;
name|z
operator|=
name|dbch
operator|->
name|ndesc
expr_stmt|;
if|if
condition|(
operator|&
name|sc
operator|->
name|arrq
operator|==
name|dbch
condition|)
block|{
name|off
operator|=
name|OHCI_ARQOFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|&
name|sc
operator|->
name|arrs
operator|==
name|dbch
condition|)
block|{
name|off
operator|=
name|OHCI_ARSOFF
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|dmach
operator|=
literal|0
init|;
name|dmach
operator|<
name|sc
operator|->
name|fc
operator|.
name|nisodma
condition|;
name|dmach
operator|++
control|)
block|{
if|if
condition|(
operator|&
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|==
name|dbch
condition|)
block|{
name|off
operator|=
name|OHCI_IROFF
argument_list|(
name|dmach
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|off
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_STREAM
condition|)
block|{
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_RUNNING
condition|)
return|return
name|err
return|;
block|}
else|else
block|{
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_RUNNING
condition|)
block|{
name|err
operator|=
name|EBUSY
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator||=
name|FWXFERQ_RUNNING
expr_stmt|;
name|dbch
operator|->
name|top
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dbch
operator|->
name|db_trq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|dbch
operator|->
name|bottom
operator|=
name|dbch
operator|->
name|top
init|;
name|i
operator|<
operator|(
name|dbch
operator|->
name|ndb
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|dbch
operator|->
name|bottom
operator|=
name|STAILQ_NEXT
argument_list|(
name|dbch
operator|->
name|bottom
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|db_tr
operator|=
name|dbch
operator|->
name|top
expr_stmt|;
for|for
control|(
name|idb
operator|=
literal|0
init|;
name|idb
operator|<
name|dbch
operator|->
name|ndb
condition|;
name|idb
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_EXTBUF
operator|)
condition|)
block|{
name|fwohci_add_rx_buf
argument_list|(
name|db_tr
argument_list|,
name|dbch
operator|->
name|xferq
operator|.
name|psize
argument_list|,
name|dbch
operator|->
name|xferq
operator|.
name|flag
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fwohci_add_rx_buf
argument_list|(
name|db_tr
argument_list|,
name|dbch
operator|->
name|xferq
operator|.
name|psize
argument_list|,
name|dbch
operator|->
name|xferq
operator|.
name|flag
argument_list|,
name|dbch
operator|->
name|xferq
operator|.
name|buf
operator|+
name|dbch
operator|->
name|xferq
operator|.
name|psize
operator|*
name|idb
argument_list|,
name|dbch
operator|->
name|dummy
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|*
name|idb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|db
operator|=
name|db_tr
operator|->
name|db
expr_stmt|;
name|ldesc
operator|=
name|db_tr
operator|->
name|dbcnt
operator|-
literal|1
expr_stmt|;
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
operator|=
name|vtophys
argument_list|(
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
operator|->
name|db
argument_list|)
operator||
name|z
expr_stmt|;
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_EXTBUF
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|idb
operator|+
literal|1
operator|)
operator|%
name|dbch
operator|->
name|xferq
operator|.
name|bnpacket
operator|)
operator|==
literal|0
condition|)
block|{
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|control
operator||=
name|OHCI_INTERRUPT_ALWAYS
expr_stmt|;
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
operator|&=
operator|~
literal|0xf
expr_stmt|;
block|}
block|}
name|db_tr
operator|=
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|dbch
operator|->
name|bottom
operator|->
name|db
index|[
name|db_tr
operator|->
name|dbcnt
operator|-
literal|1
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
operator|&=
literal|0xfffffff0
expr_stmt|;
name|dbch
operator|->
name|buf_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_STREAM
condition|)
block|{
return|return
name|err
return|;
block|}
else|else
block|{
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_DMACMD
argument_list|(
name|off
argument_list|)
argument_list|,
name|vtophys
argument_list|(
name|dbch
operator|->
name|top
operator|->
name|db
argument_list|)
operator||
name|z
argument_list|)
expr_stmt|;
block|}
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_DMACTL
argument_list|(
name|off
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwochi_next_cycle
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|int
name|cycle_now
parameter_list|)
block|{
name|int
name|sec
decl_stmt|,
name|cycle
decl_stmt|,
name|cycle_match
decl_stmt|;
name|cycle
operator|=
name|cycle_now
operator|&
literal|0x1fff
expr_stmt|;
name|sec
operator|=
name|cycle_now
operator|>>
literal|13
expr_stmt|;
define|#
directive|define
name|CYCLE_MOD
value|0x10
define|#
directive|define
name|CYCLE_DELAY
value|8
comment|/* min delay to start DMA */
name|cycle
operator|=
name|cycle
operator|+
name|CYCLE_DELAY
expr_stmt|;
if|if
condition|(
name|cycle
operator|>=
literal|8000
condition|)
block|{
name|sec
operator|++
expr_stmt|;
name|cycle
operator|-=
literal|8000
expr_stmt|;
block|}
name|cycle
operator|=
operator|(
operator|(
name|cycle
operator|+
name|CYCLE_MOD
operator|-
literal|1
operator|)
operator|/
name|CYCLE_MOD
operator|)
operator|*
name|CYCLE_MOD
expr_stmt|;
if|if
condition|(
name|cycle
operator|>=
literal|8000
condition|)
block|{
name|sec
operator|++
expr_stmt|;
if|if
condition|(
name|cycle
operator|==
literal|8000
condition|)
name|cycle
operator|=
literal|0
expr_stmt|;
else|else
name|cycle
operator|=
name|CYCLE_MOD
expr_stmt|;
block|}
name|cycle_match
operator|=
operator|(
operator|(
name|sec
operator|<<
literal|13
operator|)
operator||
name|cycle
operator|)
operator|&
literal|0x7ffff
expr_stmt|;
return|return
operator|(
name|cycle_match
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_itxbuf_enable
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|int
name|dmach
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|unsigned
name|short
name|tag
decl_stmt|,
name|ich
decl_stmt|;
name|struct
name|fwohci_dbch
modifier|*
name|dbch
decl_stmt|;
name|int
name|cycle_match
decl_stmt|,
name|cycle_now
decl_stmt|,
name|s
decl_stmt|,
name|ldesc
decl_stmt|;
name|u_int32_t
name|stat
decl_stmt|;
name|struct
name|fw_bulkxfer
modifier|*
name|first
decl_stmt|,
modifier|*
name|chunk
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|it
decl_stmt|;
name|dbch
operator|=
operator|&
name|sc
operator|->
name|it
index|[
name|dmach
index|]
expr_stmt|;
name|it
operator|=
operator|&
name|dbch
operator|->
name|xferq
expr_stmt|;
name|tag
operator|=
operator|(
name|it
operator|->
name|flag
operator|>>
literal|6
operator|)
operator|&
literal|3
expr_stmt|;
name|ich
operator|=
name|it
operator|->
name|flag
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
operator|(
name|dbch
operator|->
name|flags
operator|&
name|FWOHCI_DBCH_INIT
operator|)
operator|==
literal|0
condition|)
block|{
name|dbch
operator|->
name|ndb
operator|=
name|it
operator|->
name|bnpacket
operator|*
name|it
operator|->
name|bnchunk
expr_stmt|;
name|dbch
operator|->
name|ndesc
operator|=
literal|3
expr_stmt|;
name|fwohci_db_init
argument_list|(
name|dbch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dbch
operator|->
name|flags
operator|&
name|FWOHCI_DBCH_INIT
operator|)
operator|==
literal|0
condition|)
return|return
name|ENOMEM
return|;
name|err
operator|=
name|fwohci_tx_enable
argument_list|(
name|sc
argument_list|,
name|dbch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|ldesc
operator|=
name|dbch
operator|->
name|ndesc
operator|-
literal|1
expr_stmt|;
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|prev
operator|=
name|STAILQ_LAST
argument_list|(
operator|&
name|it
operator|->
name|stdma
argument_list|,
name|fw_bulkxfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|chunk
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|it
operator|->
name|stvalid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|volatile
name|struct
name|fwohcidb
modifier|*
name|db
decl_stmt|;
name|fwohci_txbufdb
argument_list|(
name|sc
argument_list|,
name|dmach
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|db = ((struct fwohcidb_tr *)(chunk->end))->db; 		db[ldesc].db.desc.status = db[0].db.desc.status = 0; 		db[ldesc].db.desc.count = db[0].db.desc.count = 0; 		db[ldesc].db.desc.depend&= ~0xf; 		db[0].db.desc.depend&= ~0xf;
endif|#
directive|endif
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|db
operator|=
operator|(
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
operator|(
name|prev
operator|->
name|end
operator|)
operator|)
operator|->
name|db
expr_stmt|;
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|control
operator||=
name|OHCI_BRANCH_ALWAYS
expr_stmt|;
if|#
directive|if
literal|0
comment|/* if bulkxfer->npacket changes */
block|db[ldesc].db.desc.depend = db[0].db.desc.depend =  				vtophys(((struct fwohcidb_tr *) 					(chunk->start))->db) | dbch->ndesc;
else|#
directive|else
name|db
index|[
literal|0
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
operator||=
name|dbch
operator|->
name|ndesc
expr_stmt|;
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
operator||=
name|dbch
operator|->
name|ndesc
expr_stmt|;
endif|#
directive|endif
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|it
operator|->
name|stvalid
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|it
operator|->
name|stdma
argument_list|,
name|chunk
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|prev
operator|=
name|chunk
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|stat
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_ITCTL
argument_list|(
name|dmach
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
operator|(
name|OHCI_CNTL_DMA_ACTIVE
operator||
name|OHCI_CNTL_CYCMATCH_S
operator|)
condition|)
return|return
literal|0
return|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ITCTLCLR
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_MASKCLR
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_STATCLR
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_MASK
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
name|first
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|it
operator|->
name|stdma
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ITCMD
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|vtophys
argument_list|(
operator|(
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
operator|(
name|first
operator|->
name|start
operator|)
operator|)
operator|->
name|db
argument_list|)
operator||
name|dbch
operator|->
name|ndesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|firewire_debug
condition|)
name|printf
argument_list|(
literal|"fwohci_itxbuf_enable: kick 0x%08x\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_CNTL_DMA_RUN
operator|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|1
comment|/* Don't start until all chunks are buffered */
if|if
condition|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|it
operator|->
name|stfree
argument_list|)
operator|!=
name|NULL
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FWXFERQ_DV
define|#
directive|define
name|CYCLE_OFFSET
value|1
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_DV
condition|)
block|{
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|struct
name|fwohcidb_tr
modifier|*
name|db_tr
decl_stmt|;
name|db_tr
operator|=
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
name|dbch
operator|->
name|xferq
operator|.
name|stdma
operator|->
name|start
expr_stmt|;
name|fp
operator|=
operator|(
expr|struct
name|fw_pkt
operator|*
operator|)
name|db_tr
operator|->
name|buf
expr_stmt|;
name|dbch
operator|->
name|xferq
operator|.
name|dvoffset
operator|=
name|CYCLE_OFFSET
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|ld
index|[
literal|2
index|]
operator||=
name|htonl
argument_list|(
name|dbch
operator|->
name|xferq
operator|.
name|dvoffset
operator|<<
literal|12
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Clear cycle match counter bits */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ITCTLCLR
argument_list|(
name|dmach
argument_list|)
argument_list|,
literal|0xffff0000
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASK
argument_list|,
name|OHCI_INT_DMA_IT
argument_list|)
expr_stmt|;
comment|/* 2bit second + 13bit cycle */
name|cycle_now
operator|=
operator|(
name|fc
operator|->
name|cyctimer
argument_list|(
name|fc
argument_list|)
operator|>>
literal|12
operator|)
operator|&
literal|0x7fff
expr_stmt|;
name|cycle_match
operator|=
name|fwochi_next_cycle
argument_list|(
name|fc
argument_list|,
name|cycle_now
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ITCTL
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|OHCI_CNTL_CYCMATCH_S
operator||
operator|(
name|cycle_match
operator|<<
literal|16
operator|)
operator||
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
if|if
condition|(
name|firewire_debug
condition|)
name|printf
argument_list|(
literal|"cycle_match: 0x%04x->0x%04x\n"
argument_list|,
name|cycle_now
argument_list|,
name|cycle_match
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_CNTL_CYCMATCH_S
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"IT DMA underrun (0x%08x)\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ITCTL
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_irxbuf_enable
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|int
name|dmach
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|s
decl_stmt|,
name|ldesc
decl_stmt|;
name|unsigned
name|short
name|tag
decl_stmt|,
name|ich
decl_stmt|;
name|u_int32_t
name|stat
decl_stmt|;
name|struct
name|fwohci_dbch
modifier|*
name|dbch
decl_stmt|;
name|struct
name|fw_bulkxfer
modifier|*
name|first
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|chunk
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|ir
decl_stmt|;
name|dbch
operator|=
operator|&
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
expr_stmt|;
name|ir
operator|=
operator|&
name|dbch
operator|->
name|xferq
expr_stmt|;
name|ldesc
operator|=
name|dbch
operator|->
name|ndesc
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ir
operator|->
name|flag
operator|&
name|FWXFERQ_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|tag
operator|=
operator|(
name|ir
operator|->
name|flag
operator|>>
literal|6
operator|)
operator|&
literal|3
expr_stmt|;
name|ich
operator|=
name|ir
operator|->
name|flag
operator|&
literal|0x3f
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRMATCH
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|tagbit
index|[
name|tag
index|]
operator||
name|ich
argument_list|)
expr_stmt|;
name|ir
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
name|dbch
operator|->
name|ndb
operator|=
name|ir
operator|->
name|bnpacket
operator|*
name|ir
operator|->
name|bnchunk
expr_stmt|;
name|dbch
operator|->
name|dummy
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|*
name|dbch
operator|->
name|ndb
argument_list|,
name|M_FW
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbch
operator|->
name|dummy
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|err
return|;
block|}
name|dbch
operator|->
name|ndesc
operator|=
literal|2
expr_stmt|;
name|fwohci_db_init
argument_list|(
name|dbch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dbch
operator|->
name|flags
operator|&
name|FWOHCI_DBCH_INIT
operator|)
operator|==
literal|0
condition|)
return|return
name|ENOMEM
return|;
name|err
operator|=
name|fwohci_rx_enable
argument_list|(
name|sc
argument_list|,
name|dbch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|first
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ir
operator|->
name|stfree
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"IR DMA no free chunk\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|prev
operator|=
name|STAILQ_LAST
argument_list|(
operator|&
name|ir
operator|->
name|stdma
argument_list|,
name|fw_bulkxfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|chunk
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ir
operator|->
name|stfree
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|volatile
name|struct
name|fwohcidb
modifier|*
name|db
decl_stmt|;
name|db
operator|=
operator|(
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
operator|(
name|chunk
operator|->
name|end
operator|)
operator|)
operator|->
name|db
expr_stmt|;
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|status
operator|=
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
operator|&=
operator|~
literal|0xf
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|db
operator|=
operator|(
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
operator|(
name|prev
operator|->
name|end
operator|)
operator|)
operator|->
name|db
expr_stmt|;
if|#
directive|if
literal|0
block|db[ldesc].db.desc.depend = 				vtophys(((struct fwohcidb_tr *) 					(chunk->start))->db) | dbch->ndesc;
else|#
directive|else
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
operator||=
name|dbch
operator|->
name|ndesc
expr_stmt|;
endif|#
directive|endif
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ir
operator|->
name|stfree
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ir
operator|->
name|stdma
argument_list|,
name|chunk
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|prev
operator|=
name|chunk
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|stat
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTL
argument_list|(
name|dmach
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|OHCI_CNTL_DMA_ACTIVE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|stat
operator|&
name|OHCI_CNTL_DMA_RUN
condition|)
block|{
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTLCLR
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"IR DMA overrun (0x%08x)\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_MASKCLR
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_STATCLR
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_MASK
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTLCLR
argument_list|(
name|dmach
argument_list|)
argument_list|,
literal|0xf0000000
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTL
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|OHCI_CNTL_ISOHDR
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCMD
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|vtophys
argument_list|(
operator|(
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
operator|(
name|first
operator|->
name|start
operator|)
operator|)
operator|->
name|db
argument_list|)
operator||
name|dbch
operator|->
name|ndesc
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTL
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASK
argument_list|,
name|OHCI_INT_DMA_IR
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_irx_enable
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|int
name|dmach
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|.
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_PACKET
condition|)
block|{
name|err
operator|=
name|fwohci_irxpp_enable
argument_list|(
name|fc
argument_list|,
name|dmach
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
else|else
block|{
name|err
operator|=
name|fwohci_irxbuf_enable
argument_list|(
name|fc
argument_list|,
name|dmach
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
end_function

begin_function
name|int
name|fwohci_stop
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
comment|/* Now stopping all DMA channel */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ARQCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ARSCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ATQCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ATSCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|fc
operator|.
name|nisodma
condition|;
name|i
operator|++
control|)
block|{
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTLCLR
argument_list|(
name|i
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ITCTLCLR
argument_list|(
name|i
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
block|}
comment|/* FLUSH FIFO and reset Transmitter/Reciever */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|,
name|OHCI_HCC_RESET
argument_list|)
expr_stmt|;
comment|/* Stop interrupt */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASKCLR
argument_list|,
name|OHCI_INT_EN
operator||
name|OHCI_INT_ERR
operator||
name|OHCI_INT_PHY_SID
operator||
name|OHCI_INT_PHY_INT
operator||
name|OHCI_INT_DMA_ATRQ
operator||
name|OHCI_INT_DMA_ATRS
operator||
name|OHCI_INT_DMA_PRRQ
operator||
name|OHCI_INT_DMA_PRRS
operator||
name|OHCI_INT_DMA_ARRQ
operator||
name|OHCI_INT_DMA_ARRS
operator||
name|OHCI_INT_PHY_BUS_R
argument_list|)
expr_stmt|;
comment|/* XXX Link down?  Bus reset? */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fwohci_resume
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|fwohci_reset
argument_list|(
name|sc
argument_list|,
name|dev
argument_list|)
expr_stmt|;
comment|/* XXX resume isochronus receive automatically. (how about TX?) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|fc
operator|.
name|nisodma
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|ir
index|[
name|i
index|]
operator|.
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"resume iso receive ch: %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ir
index|[
name|i
index|]
operator|.
name|xferq
operator|.
name|flag
operator|&=
operator|~
name|FWXFERQ_RUNNING
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|irx_enable
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|bus_generic_resume
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|ibr
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ACK_ALL
end_define

begin_function
specifier|static
name|void
name|fwohci_intr_body
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|stat
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|u_int32_t
name|irstat
decl_stmt|,
name|itstat
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
init|=
operator|(
expr|struct
name|firewire_comm
operator|*
operator|)
name|sc
decl_stmt|;
ifdef|#
directive|ifdef
name|OHCI_DEBUG
if|if
condition|(
name|stat
operator|&
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASK
argument_list|)
condition|)
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"INTERRUPT< %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s> 0x%08x, 0x%08x\n"
argument_list|,
name|stat
operator|&
name|OHCI_INT_EN
condition|?
literal|"DMA_EN "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_PHY_REG
condition|?
literal|"PHY_REG "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_CYC_LONG
condition|?
literal|"CYC_LONG "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_ERR
condition|?
literal|"INT_ERR "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_CYC_ERR
condition|?
literal|"CYC_ERR "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_CYC_LOST
condition|?
literal|"CYC_LOST "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_CYC_64SECOND
condition|?
literal|"CYC_64SECOND "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_CYC_START
condition|?
literal|"CYC_START "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_PHY_INT
condition|?
literal|"PHY_INT "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_PHY_BUS_R
condition|?
literal|"BUS_RESET "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_PHY_SID
condition|?
literal|"SID "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_LR_ERR
condition|?
literal|"DMA_LR_ERR "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_PW_ERR
condition|?
literal|"DMA_PW_ERR "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_IR
condition|?
literal|"DMA_IR "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_IT
condition|?
literal|"DMA_IT "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_PRRS
condition|?
literal|"DMA_PRRS "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_PRRQ
condition|?
literal|"DMA_PRRQ "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_ARRS
condition|?
literal|"DMA_ARRS "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_ARRQ
condition|?
literal|"DMA_ARRQ "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_ATRS
condition|?
literal|"DMA_ATRS "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_ATRQ
condition|?
literal|"DMA_ATRQ "
else|:
literal|""
argument_list|,
name|stat
argument_list|,
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASK
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Bus reset */
if|if
condition|(
name|stat
operator|&
name|OHCI_INT_PHY_BUS_R
condition|)
block|{
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"BUS reset\n"
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASKCLR
argument_list|,
name|OHCI_INT_CYC_LOST
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_LNKCTLCLR
argument_list|,
name|OHCI_CNTL_CYCSRC
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ATQCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atrq
operator|.
name|xferq
operator|.
name|flag
operator|&=
operator|~
name|FWXFERQ_RUNNING
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ATSCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atrs
operator|.
name|xferq
operator|.
name|flag
operator|&=
operator|~
name|FWXFERQ_RUNNING
expr_stmt|;
if|#
directive|if
literal|0
block|for( i = 0 ; i< fc->nisodma ; i ++ ){ 			OWRITE(sc,  OHCI_IRCTLCLR(i), OHCI_CNTL_DMA_RUN); 			OWRITE(sc,  OHCI_ITCTLCLR(i), OHCI_CNTL_DMA_RUN); 		}
endif|#
directive|endif
name|fw_busreset
argument_list|(
name|fc
argument_list|)
expr_stmt|;
comment|/* XXX need to wait DMA to stop */
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_PHY_BUS_R
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|1
comment|/* pending all pre-bus_reset packets */
name|fwohci_txd
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|atrq
argument_list|)
expr_stmt|;
name|fwohci_txd
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|atrs
argument_list|)
expr_stmt|;
name|fwohci_arcv
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|arrs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fwohci_arcv
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|arrq
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_AREQHI
argument_list|,
literal|1
operator|<<
literal|31
argument_list|)
expr_stmt|;
comment|/* XXX insecure ?? */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_PREQHI
argument_list|,
literal|0x7fffffff
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_PREQLO
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_PREQUPPER
argument_list|,
literal|0x10000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_DMA_IR
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_DMA_IR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|irstat
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_STAT
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_STATCLR
argument_list|,
name|irstat
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fc
operator|->
name|nisodma
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|fwohci_dbch
modifier|*
name|dbch
decl_stmt|;
if|if
condition|(
operator|(
name|irstat
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|dbch
operator|=
operator|&
name|sc
operator|->
name|ir
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_OPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"dma(%d) not active\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_PACKET
condition|)
block|{
name|fwohci_ircv
argument_list|(
name|sc
argument_list|,
name|dbch
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fwohci_rbuf_update
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_DMA_IT
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_DMA_IT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|itstat
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_STAT
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_STATCLR
argument_list|,
name|itstat
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fc
operator|->
name|nisodma
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|itstat
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fwohci_tbuf_update
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_DMA_PRRS
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_DMA_PRRS
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|dump_dma(sc, ARRS_CH); 		dump_db(sc, ARRS_CH);
endif|#
directive|endif
name|fwohci_arcv
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|arrs
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_DMA_PRRQ
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_DMA_PRRQ
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|dump_dma(sc, ARRQ_CH); 		dump_db(sc, ARRQ_CH);
endif|#
directive|endif
name|fwohci_arcv
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|arrq
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|OHCI_INT_PHY_SID
condition|)
block|{
name|caddr_t
name|buf
decl_stmt|;
name|int
name|plen
decl_stmt|;
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_PHY_SID
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ** Checking whether the node is root or not. If root, turn on  ** cycle master. */
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"node_id = 0x%08x, "
argument_list|,
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCI_NODEID
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCI_NODEID
argument_list|)
operator|&
name|OHCI_NODE_VALID
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Bus reset failure\n"
argument_list|)
expr_stmt|;
goto|goto
name|sidout
goto|;
block|}
if|if
condition|(
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCI_NODEID
argument_list|)
operator|&
name|OHCI_NODE_ROOT
condition|)
block|{
name|printf
argument_list|(
literal|"CYCLEMASTER mode\n"
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_LNKCTL
argument_list|,
name|OHCI_CNTL_CYCMTR
operator||
name|OHCI_CNTL_CYCTIMER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"non CYCLEMASTER mode\n"
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_LNKCTLCLR
argument_list|,
name|OHCI_CNTL_CYCMTR
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_LNKCTL
argument_list|,
name|OHCI_CNTL_CYCTIMER
argument_list|)
expr_stmt|;
block|}
name|fc
operator|->
name|nodeid
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCI_NODEID
argument_list|)
operator|&
literal|0x3f
expr_stmt|;
name|plen
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_SID_CNT
argument_list|)
operator|&
name|OHCI_SID_CNT_MASK
expr_stmt|;
if|if
condition|(
name|plen
operator|<
literal|4
operator|||
name|plen
operator|>
name|OHCI_SIDSIZE
condition|)
block|{
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"invalid SID len = %d\n"
argument_list|,
name|plen
argument_list|)
expr_stmt|;
goto|goto
name|sidout
goto|;
block|}
name|plen
operator|-=
literal|4
expr_stmt|;
comment|/* chop control info */
name|buf
operator|=
name|malloc
argument_list|(
name|OHCI_SIDSIZE
argument_list|,
name|M_FW
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
goto|goto
name|sidout
goto|;
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
specifier|volatile
name|void
operator|*
argument_list|)
argument_list|(
name|fc
operator|->
name|sid_buf
operator|+
literal|1
argument_list|)
argument_list|,
name|buf
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|fw_sidrcv
argument_list|(
name|fc
argument_list|,
name|buf
argument_list|,
name|plen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sidout
label|:
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_DMA_ATRQ
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_DMA_ATRQ
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fwohci_txd
argument_list|(
name|sc
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|atrq
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_DMA_ATRS
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_DMA_ATRS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fwohci_txd
argument_list|(
name|sc
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|atrs
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_PW_ERR
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_PW_ERR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"posted write error\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_ERR
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_ERR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"unrecoverable error\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_PHY_INT
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_PHY_INT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"phy int\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|fwohci_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|u_int32_t
name|stat
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|intmask
operator|&
name|OHCI_INT_EN
operator|)
condition|)
block|{
comment|/* polling mode */
return|return;
block|}
while|while
condition|(
operator|(
name|stat
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTAT
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|stat
operator|==
literal|0xffffffff
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"device physically ejected?\n"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|stat
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fwohci_intr_body
argument_list|(
name|sc
argument_list|,
name|stat
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_poll
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|int
name|quick
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|u_int32_t
name|stat
decl_stmt|;
name|struct
name|fwohci_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
expr_stmt|;
name|stat
operator|=
name|OHCI_INT_DMA_IR
operator||
name|OHCI_INT_DMA_IT
operator||
name|OHCI_INT_DMA_PRRS
operator||
name|OHCI_INT_DMA_PRRQ
operator||
name|OHCI_INT_DMA_ATRQ
operator||
name|OHCI_INT_DMA_ATRS
expr_stmt|;
if|#
directive|if
literal|0
block|if (!quick) {
else|#
directive|else
if|if
condition|(
literal|1
condition|)
block|{
endif|#
directive|endif
name|stat
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|stat
operator|==
literal|0xffffffff
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"device physically ejected?\n"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|stat
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|fwohci_intr_body
argument_list|(
name|sc
argument_list|,
name|stat
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_set_intr
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"fwohci_set_intr: %d\n"
argument_list|,
name|enable
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|sc
operator|->
name|intmask
operator||=
name|OHCI_INT_EN
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASK
argument_list|,
name|OHCI_INT_EN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|intmask
operator|&=
operator|~
name|OHCI_INT_EN
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASKCLR
argument_list|,
name|OHCI_INT_EN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_tbuf_update
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dmach
parameter_list|)
block|{
name|struct
name|firewire_comm
modifier|*
name|fc
init|=
operator|&
name|sc
operator|->
name|fc
decl_stmt|;
specifier|volatile
name|struct
name|fwohcidb
modifier|*
name|db
decl_stmt|;
name|struct
name|fw_bulkxfer
modifier|*
name|chunk
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|it
decl_stmt|;
name|u_int32_t
name|stat
decl_stmt|,
name|count
decl_stmt|;
name|int
name|s
decl_stmt|,
name|w
init|=
literal|0
decl_stmt|;
name|it
operator|=
name|fc
operator|->
name|it
index|[
name|dmach
index|]
expr_stmt|;
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
comment|/* unnecessary ? */
while|while
condition|(
operator|(
name|chunk
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|it
operator|->
name|stdma
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|db
operator|=
operator|(
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
operator|(
name|chunk
operator|->
name|end
operator|)
operator|)
operator|->
name|db
expr_stmt|;
name|stat
operator|=
name|db
index|[
name|sc
operator|->
name|it
index|[
name|dmach
index|]
operator|.
name|ndesc
operator|-
literal|1
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|status
expr_stmt|;
name|db
operator|=
operator|(
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
operator|(
name|chunk
operator|->
name|start
operator|)
operator|)
operator|->
name|db
expr_stmt|;
name|count
operator|=
name|db
index|[
name|sc
operator|->
name|it
index|[
name|dmach
index|]
operator|.
name|ndesc
operator|-
literal|1
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|count
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
break|break;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|it
operator|->
name|stdma
argument_list|,
name|link
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|stat
operator|&
name|FWOHCIEV_MASK
condition|)
block|{
case|case
name|FWOHCIEV_ACKCOMPL
case|:
if|#
directive|if
literal|0
block|device_printf(fc->dev, "0x%08x\n", count);
endif|#
directive|endif
break|break;
default|default:
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"Isochronous transmit err %02x\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|it
operator|->
name|stfree
argument_list|,
name|chunk
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|w
operator|++
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
condition|)
name|wakeup
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_rbuf_update
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dmach
parameter_list|)
block|{
name|struct
name|firewire_comm
modifier|*
name|fc
init|=
operator|&
name|sc
operator|->
name|fc
decl_stmt|;
specifier|volatile
name|struct
name|fwohcidb
modifier|*
name|db
decl_stmt|;
name|struct
name|fw_bulkxfer
modifier|*
name|chunk
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|ir
decl_stmt|;
name|u_int32_t
name|stat
decl_stmt|;
name|int
name|s
decl_stmt|,
name|w
init|=
literal|0
decl_stmt|;
name|ir
operator|=
name|fc
operator|->
name|ir
index|[
name|dmach
index|]
expr_stmt|;
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|chunk
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ir
operator|->
name|stdma
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|db
operator|=
operator|(
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
operator|(
name|chunk
operator|->
name|end
operator|)
operator|)
operator|->
name|db
expr_stmt|;
name|stat
operator|=
name|db
index|[
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|.
name|ndesc
operator|-
literal|1
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|status
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
break|break;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ir
operator|->
name|stdma
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ir
operator|->
name|stvalid
argument_list|,
name|chunk
argument_list|,
name|link
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|stat
operator|&
name|FWOHCIEV_MASK
condition|)
block|{
case|case
name|FWOHCIEV_ACKCOMPL
case|:
break|break;
default|default:
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"Isochronous receive err %02x\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
name|w
operator|++
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
condition|)
name|wakeup
argument_list|(
name|ir
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_dma
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ch
parameter_list|)
block|{
name|u_int32_t
name|off
decl_stmt|,
name|cntl
decl_stmt|,
name|stat
decl_stmt|,
name|cmd
decl_stmt|,
name|match
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|0
condition|)
block|{
name|off
operator|=
name|OHCI_ATQOFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|1
condition|)
block|{
name|off
operator|=
name|OHCI_ATSOFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|2
condition|)
block|{
name|off
operator|=
name|OHCI_ARQOFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|3
condition|)
block|{
name|off
operator|=
name|OHCI_ARSOFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
name|IRX_CH
condition|)
block|{
name|off
operator|=
name|OHCI_ITCTL
argument_list|(
name|ch
operator|-
name|ITX_CH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|off
operator|=
name|OHCI_IRCTL
argument_list|(
name|ch
operator|-
name|IRX_CH
argument_list|)
expr_stmt|;
block|}
name|cntl
operator|=
name|stat
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|off
operator|+
literal|0xc
argument_list|)
expr_stmt|;
name|match
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|off
operator|+
literal|0x10
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"dma ch %1x:dma regs 0x%08x 0x%08x 0x%08x 0x%08x \n"
argument_list|,
name|ch
argument_list|,
name|cntl
argument_list|,
name|stat
argument_list|,
name|cmd
argument_list|,
name|match
argument_list|)
expr_stmt|;
name|stat
operator|&=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|stat
operator|&
literal|0xff00
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"dma %d ch:%s%s%s%s%s%s %s(%x)\n"
argument_list|,
name|ch
argument_list|,
name|stat
operator|&
name|OHCI_CNTL_DMA_RUN
condition|?
literal|"RUN,"
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_CNTL_DMA_WAKE
condition|?
literal|"WAKE,"
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_CNTL_DMA_DEAD
condition|?
literal|"DEAD,"
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_CNTL_DMA_ACTIVE
condition|?
literal|"ACTIVE,"
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_CNTL_DMA_BT
condition|?
literal|"BRANCH,"
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_CNTL_DMA_BAD
condition|?
literal|"BADDMA,"
else|:
literal|""
argument_list|,
name|fwohcicode
index|[
name|stat
operator|&
literal|0x1f
index|]
argument_list|,
name|stat
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"dma %d ch: Nostat\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dump_db
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|ch
parameter_list|)
block|{
name|struct
name|fwohci_dbch
modifier|*
name|dbch
decl_stmt|;
name|struct
name|fwohcidb_tr
modifier|*
name|cp
init|=
name|NULL
decl_stmt|,
modifier|*
name|pp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
specifier|volatile
name|struct
name|fwohcidb
modifier|*
name|curr
init|=
name|NULL
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
init|=
name|NULL
decl_stmt|;
name|int
name|idb
decl_stmt|,
name|jdb
decl_stmt|;
name|u_int32_t
name|cmd
decl_stmt|,
name|off
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|0
condition|)
block|{
name|off
operator|=
name|OHCI_ATQOFF
expr_stmt|;
name|dbch
operator|=
operator|&
name|sc
operator|->
name|atrq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|1
condition|)
block|{
name|off
operator|=
name|OHCI_ATSOFF
expr_stmt|;
name|dbch
operator|=
operator|&
name|sc
operator|->
name|atrs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|2
condition|)
block|{
name|off
operator|=
name|OHCI_ARQOFF
expr_stmt|;
name|dbch
operator|=
operator|&
name|sc
operator|->
name|arrq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|3
condition|)
block|{
name|off
operator|=
name|OHCI_ARSOFF
expr_stmt|;
name|dbch
operator|=
operator|&
name|sc
operator|->
name|arrs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
name|IRX_CH
condition|)
block|{
name|off
operator|=
name|OHCI_ITCTL
argument_list|(
name|ch
operator|-
name|ITX_CH
argument_list|)
expr_stmt|;
name|dbch
operator|=
operator|&
name|sc
operator|->
name|it
index|[
name|ch
operator|-
name|ITX_CH
index|]
expr_stmt|;
block|}
else|else
block|{
name|off
operator|=
name|OHCI_IRCTL
argument_list|(
name|ch
operator|-
name|IRX_CH
argument_list|)
expr_stmt|;
name|dbch
operator|=
operator|&
name|sc
operator|->
name|ir
index|[
name|ch
operator|-
name|IRX_CH
index|]
expr_stmt|;
block|}
name|cmd
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|off
operator|+
literal|0xc
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbch
operator|->
name|ndb
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"No DB is attached ch=%d\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|=
name|dbch
operator|->
name|top
expr_stmt|;
name|prev
operator|=
name|pp
operator|->
name|db
expr_stmt|;
for|for
control|(
name|idb
operator|=
literal|0
init|;
name|idb
operator|<
name|dbch
operator|->
name|ndb
condition|;
name|idb
operator|++
control|)
block|{
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
block|{
name|curr
operator|=
name|NULL
expr_stmt|;
goto|goto
name|outdb
goto|;
block|}
name|cp
operator|=
name|STAILQ_NEXT
argument_list|(
name|pp
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|curr
operator|=
name|NULL
expr_stmt|;
goto|goto
name|outdb
goto|;
block|}
name|np
operator|=
name|STAILQ_NEXT
argument_list|(
name|cp
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
break|break;
for|for
control|(
name|jdb
operator|=
literal|0
init|;
name|jdb
operator|<
name|dbch
operator|->
name|ndesc
condition|;
name|jdb
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cmd
operator|&
literal|0xfffffff0
operator|)
operator|==
name|vtophys
argument_list|(
operator|&
operator|(
name|cp
operator|->
name|db
index|[
name|jdb
index|]
operator|)
argument_list|)
condition|)
block|{
name|curr
operator|=
name|cp
operator|->
name|db
expr_stmt|;
if|if
condition|(
name|np
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|np
operator|->
name|db
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|NULL
expr_stmt|;
block|}
goto|goto
name|outdb
goto|;
block|}
block|}
name|pp
operator|=
name|STAILQ_NEXT
argument_list|(
name|pp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|prev
operator|=
name|pp
operator|->
name|db
expr_stmt|;
block|}
name|outdb
label|:
if|if
condition|(
name|curr
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Prev DB %d\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|print_db
argument_list|(
name|prev
argument_list|,
name|ch
argument_list|,
name|dbch
operator|->
name|ndesc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Current DB %d\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|print_db
argument_list|(
name|curr
argument_list|,
name|ch
argument_list|,
name|dbch
operator|->
name|ndesc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Next DB %d\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|print_db
argument_list|(
name|next
argument_list|,
name|ch
argument_list|,
name|dbch
operator|->
name|ndesc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"dbdump err ch = %d cmd = 0x%08x\n"
argument_list|,
name|ch
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|print_db
parameter_list|(
specifier|volatile
name|struct
name|fwohcidb
modifier|*
name|db
parameter_list|,
name|u_int32_t
name|ch
parameter_list|,
name|u_int32_t
name|max
parameter_list|)
block|{
name|fwohcireg_t
name|stat
decl_stmt|;
name|int
name|i
decl_stmt|,
name|key
decl_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"No Descriptor is found\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"ch = %d\n%8s %s %s %s %s %4s %8s %8s %4s:%4s\n"
argument_list|,
name|ch
argument_list|,
literal|"Current"
argument_list|,
literal|"OP  "
argument_list|,
literal|"KEY"
argument_list|,
literal|"INT"
argument_list|,
literal|"BR "
argument_list|,
literal|"len"
argument_list|,
literal|"Addr"
argument_list|,
literal|"Depend"
argument_list|,
literal|"Stat"
argument_list|,
literal|"Cnt"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
name|key
operator|=
name|db
index|[
name|i
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|control
operator|&
name|OHCI_KEY_MASK
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|printf
argument_list|(
literal|"%08tx %s %s %s %s %5d %08x %08x %04x:%04x"
argument_list|,
else|#
directive|else
argument|printf(
literal|"%08x %s %s %s %s %5d %08x %08x %04x:%04x"
argument|,
endif|#
directive|endif
argument|vtophys(&db[i]), 				dbcode[(db[i].db.desc.control>>
literal|12
argument|)&
literal|0xf
argument|], 				dbkey[(db[i].db.desc.control>>
literal|8
argument|)&
literal|0x7
argument|], 				dbcond[(db[i].db.desc.control>>
literal|4
argument|)&
literal|0x3
argument|], 				dbcond[(db[i].db.desc.control>>
literal|2
argument|)&
literal|0x3
argument|], 				db[i].db.desc.reqcount, 				db[i].db.desc.addr, 				db[i].db.desc.depend, 				db[i].db.desc.status,  				db[i].db.desc.count); 		stat = db[i].db.desc.status; 		if(stat&
literal|0xff00
argument|){ 			printf(
literal|" %s%s%s%s%s%s %s(%x)\n"
argument|, 				stat& OHCI_CNTL_DMA_RUN ?
literal|"RUN,"
argument|:
literal|""
argument|, 				stat& OHCI_CNTL_DMA_WAKE ?
literal|"WAKE,"
argument|:
literal|""
argument|, 				stat& OHCI_CNTL_DMA_DEAD ?
literal|"DEAD,"
argument|:
literal|""
argument|, 				stat& OHCI_CNTL_DMA_ACTIVE ?
literal|"ACTIVE,"
argument|:
literal|""
argument|, 				stat& OHCI_CNTL_DMA_BT ?
literal|"BRANCH,"
argument|:
literal|""
argument|, 				stat& OHCI_CNTL_DMA_BAD ?
literal|"BADDMA,"
argument|:
literal|""
argument|, 				fwohcicode[stat&
literal|0x1f
argument|], 				stat&
literal|0x1f
argument|); 		}else{ 			printf(
literal|" Nostat\n"
argument|); 		} 		if(key == OHCI_KEY_ST2 ){ 			printf(
literal|"0x%08x 0x%08x 0x%08x 0x%08x\n"
argument|,  				db[i+
literal|1
argument|].db.immed[
literal|0
argument|], 				db[i+
literal|1
argument|].db.immed[
literal|1
argument|], 				db[i+
literal|1
argument|].db.immed[
literal|2
argument|], 				db[i+
literal|1
argument|].db.immed[
literal|3
argument|]); 		} 		if(key == OHCI_KEY_DEVICE){ 			return; 		} 		if((db[i].db.desc.control& OHCI_BRANCH_MASK)  				== OHCI_BRANCH_ALWAYS){ 			return; 		} 		if((db[i].db.desc.control& OHCI_CMD_MASK)  				== OHCI_OUTPUT_LAST){ 			return; 		} 		if((db[i].db.desc.control& OHCI_CMD_MASK)  				== OHCI_INPUT_LAST){ 			return; 		} 		if(key == OHCI_KEY_ST2 ){ 			i++; 		} 	} 	return; }  void fwohci_ibr(struct firewire_comm *fc) { 	struct fwohci_softc *sc; 	u_int32_t fun;  	sc = (struct fwohci_softc *)fc;
comment|/* 	 * Set root hold-off bit so that non cyclemaster capable node 	 * shouldn't became the root node. 	 */
if|#
directive|if
literal|1
argument|fun = fwphy_rddata(sc, FW_PHY_IBR_REG); 	fun |= FW_PHY_IBR | FW_PHY_RHB; 	fun = fwphy_wrdata(sc, FW_PHY_IBR_REG, fun);
else|#
directive|else
comment|/* Short bus reset */
argument|fun = fwphy_rddata(sc, FW_PHY_ISBR_REG); 	fun |= FW_PHY_ISBR | FW_PHY_RHB; 	fun = fwphy_wrdata(sc, FW_PHY_ISBR_REG, fun);
endif|#
directive|endif
argument|}  void fwohci_txbufdb(struct fwohci_softc *sc, int dmach, struct fw_bulkxfer *bulkxfer) { 	struct fwohcidb_tr *db_tr
argument_list|,
argument|*fdb_tr; 	struct fwohci_dbch *dbch; 	volatile struct fwohcidb *db; 	struct fw_pkt *fp; 	volatile struct fwohci_txpkthdr *ohcifp; 	unsigned short chtag; 	int idb;  	dbch =&sc->it[dmach]; 	chtag = sc->it[dmach].xferq.flag&
literal|0xff
argument|;  	db_tr = (struct fwohcidb_tr *)(bulkxfer->start); 	fdb_tr = (struct fwohcidb_tr *)(bulkxfer->end);
comment|/* device_printf(sc->fc.dev, "DB %08x %08x %08x\n", bulkxfer, vtophys(db_tr->db), vtophys(fdb_tr->db)); */
argument|for( idb =
literal|0
argument|; idb< bulkxfer->npacket ; idb ++){ 		db = db_tr->db;
if|#
directive|if
literal|0
argument|db[0].db.desc.control 			= OHCI_OUTPUT_MORE | OHCI_KEY_ST2; 		db[0].db.desc.reqcount = 8;
endif|#
directive|endif
argument|fp = (struct fw_pkt *)db_tr->buf; 		ohcifp = (volatile struct fwohci_txpkthdr *) db[
literal|1
argument|].db.immed; 		ohcifp->mode.ld[
literal|0
argument|] = ntohl(fp->mode.ld[
literal|0
argument|]); 		ohcifp->mode.stream.len = ntohs(fp->mode.stream.len); 		ohcifp->mode.stream.chtag = chtag; 		ohcifp->mode.stream.tcode =
literal|0xa
argument|; 		ohcifp->mode.stream.spd =
literal|0
argument|;  		db[
literal|2
argument|].db.desc.reqcount = ntohs(fp->mode.stream.len); 		db[
literal|2
argument|].db.desc.status =
literal|0
argument|; 		db[
literal|2
argument|].db.desc.count =
literal|0
argument|;
if|#
directive|if
literal|0
comment|/* if bulkxfer->npackets changes */
argument|db[2].db.desc.control = OHCI_OUTPUT_LAST 			| OHCI_UPDATE 			| OHCI_BRANCH_ALWAYS; 		db[0].db.desc.depend = 			= db[dbch->ndesc - 1].db.desc.depend 			= vtophys(STAILQ_NEXT(db_tr, link)->db) | dbch->ndesc;
else|#
directive|else
argument|db[
literal|0
argument|].db.desc.depend |= dbch->ndesc; 		db[dbch->ndesc -
literal|1
argument|].db.desc.depend |= dbch->ndesc;
endif|#
directive|endif
argument|bulkxfer->end = (caddr_t)db_tr; 		db_tr = STAILQ_NEXT(db_tr, link); 	} 	db = ((struct fwohcidb_tr *)bulkxfer->end)->db; 	db[
literal|0
argument|].db.desc.depend&= ~
literal|0xf
argument|; 	db[dbch->ndesc -
literal|1
argument|].db.desc.depend&= ~
literal|0xf
argument|;
if|#
directive|if
literal|0
comment|/* if bulkxfer->npackets changes */
argument|db[dbch->ndesc - 1].db.desc.control |= OHCI_INTERRUPT_ALWAYS;
comment|/* OHCI 1.1 and above */
argument|db[0].db.desc.control |= OHCI_INTERRUPT_ALWAYS;
endif|#
directive|endif
comment|/* 	db_tr = (struct fwohcidb_tr *)bulkxfer->start; 	fdb_tr = (struct fwohcidb_tr *)bulkxfer->end; device_printf(sc->fc.dev, "DB %08x %3d %08x %08x\n", bulkxfer, bulkxfer->npacket, vtophys(db_tr->db), vtophys(fdb_tr->db)); */
argument|return; }  static int fwohci_add_tx_buf(struct fwohcidb_tr *db_tr, unsigned short size, 	int mode, void *buf) { 	volatile struct fwohcidb *db = db_tr->db; 	int err =
literal|0
argument|; 	if(buf ==
literal|0
argument|){ 		err = EINVAL; 		return err; 	} 	db_tr->buf = buf; 	db_tr->dbcnt =
literal|3
argument|; 	db_tr->dummy = NULL;  	db[
literal|0
argument|].db.desc.control = OHCI_OUTPUT_MORE | OHCI_KEY_ST2; 	db[
literal|0
argument|].db.desc.reqcount =
literal|8
argument|; 	db[
literal|2
argument|].db.desc.addr = vtophys(buf) + sizeof(u_int32_t); 	db[
literal|2
argument|].db.desc.control =  		OHCI_OUTPUT_LAST | OHCI_UPDATE | OHCI_BRANCH_ALWAYS;
if|#
directive|if
literal|1
argument|db[
literal|0
argument|].db.desc.status =
literal|0
argument|; 	db[
literal|0
argument|].db.desc.count =
literal|0
argument|; 	db[
literal|2
argument|].db.desc.status =
literal|0
argument|; 	db[
literal|2
argument|].db.desc.count =
literal|0
argument|;
endif|#
directive|endif
argument|if( mode& FWXFERQ_STREAM ){ 		if(mode& FWXFERQ_PACKET ){ 			db[
literal|2
argument|].db.desc.control |= OHCI_INTERRUPT_ALWAYS; 		} 	} else { 		printf(
literal|"fwohci_add_tx_buf: who calls me?"
argument|); 	} 	return
literal|1
argument|; }  int fwohci_add_rx_buf(struct fwohcidb_tr *db_tr, unsigned short size, int mode, 	void *buf, void *dummy) { 	volatile struct fwohcidb *db = db_tr->db; 	int i; 	void *dbuf[
literal|2
argument|]; 	int dsiz[
literal|2
argument|];  	if(buf ==
literal|0
argument|){ 		buf = malloc(size, M_FW, M_NOWAIT); 		if(buf == NULL) return
literal|0
argument|; 		db_tr->buf = buf; 		db_tr->dbcnt =
literal|1
argument|; 		db_tr->dummy = NULL; 		dsiz[
literal|0
argument|] = size; 		dbuf[
literal|0
argument|] = buf; 	}else if(dummy == NULL){ 		db_tr->buf = buf; 		db_tr->dbcnt =
literal|1
argument|; 		db_tr->dummy = NULL; 		dsiz[
literal|0
argument|] = size; 		dbuf[
literal|0
argument|] = buf; 	}else{ 		db_tr->buf = buf; 		db_tr->dbcnt =
literal|2
argument|; 		db_tr->dummy = dummy; 		dsiz[
literal|0
argument|] = sizeof(u_int32_t); 		dsiz[
literal|1
argument|] = size; 		dbuf[
literal|0
argument|] = dummy; 		dbuf[
literal|1
argument|] = buf; 	} 	for(i =
literal|0
argument|; i< db_tr->dbcnt ; i++){ 		db[i].db.desc.addr = vtophys(dbuf[i]) ; 		db[i].db.desc.control = OHCI_INPUT_MORE; 		db[i].db.desc.reqcount = dsiz[i]; 		if( mode& FWXFERQ_STREAM ){ 			db[i].db.desc.control |= OHCI_UPDATE; 		} 		db[i].db.desc.status =
literal|0
argument|; 		db[i].db.desc.count = dsiz[i]; 	} 	if( mode& FWXFERQ_STREAM ){ 		db[db_tr->dbcnt -
literal|1
argument|].db.desc.control |= OHCI_INPUT_LAST; 		if(mode& FWXFERQ_PACKET ){ 			db[db_tr->dbcnt -
literal|1
argument|].db.desc.control 					|= OHCI_INTERRUPT_ALWAYS; 		} 	} 	db[db_tr->dbcnt -
literal|1
argument|].db.desc.control |= OHCI_BRANCH_ALWAYS; 	return
literal|1
argument|; }  static void fwohci_ircv(struct fwohci_softc *sc, struct fwohci_dbch *dbch, int count) { 	struct fwohcidb_tr *db_tr = dbch->top
argument_list|,
argument|*odb_tr; 	struct firewire_comm *fc = (struct firewire_comm *)sc; 	int z =
literal|1
argument|; 	struct fw_pkt *fp; 	u_int8_t *ld; 	u_int32_t off = NULL; 	u_int32_t stat; 	u_int32_t *qld; 	u_int32_t reg; 	u_int spd; 	u_int dmach; 	int len
argument_list|,
argument|i
argument_list|,
argument|plen; 	caddr_t buf;  	for(dmach =
literal|0
argument|; dmach< sc->fc.nisodma ; dmach++){ 		if(&sc->ir[dmach] == dbch){ 			off = OHCI_IROFF(dmach); 			break; 		} 	} 	if(off == NULL){ 		return; 	} 	if(!(dbch->xferq.flag& FWXFERQ_RUNNING)){ 		fwohci_irx_disable(&sc->fc, dmach); 		return; 	}  	odb_tr = NULL; 	db_tr = dbch->top; 	i =
literal|0
argument|; 	while ((reg = db_tr->db[
literal|0
argument|].db.desc.status)&
literal|0x1f
argument|) { 		if (count>=
literal|0
argument|&& count-- ==
literal|0
argument|) 			break; 		ld = (u_int8_t *)db_tr->buf; 		if (dbch->xferq.flag& FWXFERQ_PACKET) {
comment|/* skip timeStamp */
argument|ld += sizeof(struct fwohci_trailer); 		} 		qld = (u_int32_t *)ld; 		len = dbch->xferq.psize - (db_tr->db[
literal|0
argument|].db.desc.count);
comment|/* { device_printf(sc->fc.dev, "%04x %2x 0x%08x 0x%08x 0x%08x 0x%08x\n", len,  		db_tr->db[0].db.desc.status& 0x1f, qld[0],qld[1],qld[2],qld[3]); } */
argument|fp=(struct fw_pkt *)ld; 		qld[
literal|0
argument|] = htonl(qld[
literal|0
argument|]); 		plen = sizeof(struct fw_isohdr) 			+ ntohs(fp->mode.stream.len) + sizeof(u_int32_t); 		ld += plen; 		len -= plen; 		buf = db_tr->buf; 		db_tr->buf = NULL; 		stat = reg&
literal|0x1f
argument|; 		spd =  reg&
literal|0x3
argument|; 		switch(stat){ 			case FWOHCIEV_ACKCOMPL: 			case FWOHCIEV_ACKPEND: 				fw_rcv(&sc->fc, buf, plen - sizeof(u_int32_t), dmach, sizeof(u_int32_t), spd); 				break; 			default: 				free(buf, M_FW); 				device_printf(sc->fc.dev,
literal|"Isochronous receive err %02x\n"
argument|, stat); 				break; 		} 		i++; 		fwohci_add_rx_buf(db_tr, dbch->xferq.psize,  					dbch->xferq.flag,
literal|0
argument|, NULL); 		db_tr->db[
literal|0
argument|].db.desc.depend&= ~
literal|0xf
argument|; 		if(dbch->pdb_tr != NULL){ 			dbch->pdb_tr->db[
literal|0
argument|].db.desc.depend |= z; 		} else {
comment|/* XXX should be rewritten in better way */
argument|dbch->bottom->db[
literal|0
argument|].db.desc.depend |= z; 		} 		dbch->pdb_tr = db_tr; 		db_tr = STAILQ_NEXT(db_tr, link); 	} 	dbch->top = db_tr; 	reg = OREAD(sc, OHCI_DMACTL(off)); 	if (reg& OHCI_CNTL_DMA_ACTIVE) 		return; 	device_printf(sc->fc.dev,
literal|"IR DMA %d stopped at %x status=%x (%d)\n"
argument|, 			dmach, OREAD(sc, OHCI_DMACMD(off)), reg, i); 	dbch->top = db_tr; 	fwohci_irx_enable(fc, dmach); }
define|#
directive|define
name|PLEN
parameter_list|(
name|x
parameter_list|)
value|(((ntohs(x))+0x3)& ~0x3)
argument|static int fwohci_get_plen(struct fwohci_softc *sc, struct fw_pkt *fp, int hlen) { 	int i;  	for( i =
literal|4
argument|; i< hlen ; i+=
literal|4
argument|){ 		fp->mode.ld[i/
literal|4
argument|] = htonl(fp->mode.ld[i/
literal|4
argument|]); 	}  	switch(fp->mode.common.tcode){ 	case FWTCODE_RREQQ: 		return sizeof(fp->mode.rreqq) + sizeof(u_int32_t); 	case FWTCODE_WRES: 		return sizeof(fp->mode.wres) + sizeof(u_int32_t); 	case FWTCODE_WREQQ: 		return sizeof(fp->mode.wreqq) + sizeof(u_int32_t); 	case FWTCODE_RREQB: 		return sizeof(fp->mode.rreqb) + sizeof(u_int32_t); 	case FWTCODE_RRESQ: 		return sizeof(fp->mode.rresq) + sizeof(u_int32_t); 	case FWTCODE_WREQB: 		return sizeof(struct fw_asyhdr) + PLEN(fp->mode.wreqb.len) 						+ sizeof(u_int32_t); 	case FWTCODE_LREQ: 		return sizeof(struct fw_asyhdr) + PLEN(fp->mode.lreq.len) 						+ sizeof(u_int32_t); 	case FWTCODE_RRESB: 		return sizeof(struct fw_asyhdr) + PLEN(fp->mode.rresb.len) 						+ sizeof(u_int32_t); 	case FWTCODE_LRES: 		return sizeof(struct fw_asyhdr) + PLEN(fp->mode.lres.len) 						+ sizeof(u_int32_t); 	case FWOHCITCODE_PHY: 		return
literal|16
argument|; 	} 	device_printf(sc->fc.dev,
literal|"Unknown tcode %d\n"
argument|, fp->mode.common.tcode); 	return
literal|0
argument|; }  static void fwohci_arcv(struct fwohci_softc *sc, struct fwohci_dbch *dbch, int count) { 	struct fwohcidb_tr *db_tr; 	int z =
literal|1
argument|; 	struct fw_pkt *fp; 	u_int8_t *ld; 	u_int32_t stat
argument_list|,
argument|off; 	u_int spd; 	int len
argument_list|,
argument|plen
argument_list|,
argument|hlen
argument_list|,
argument|pcnt
argument_list|,
argument|poff =
literal|0
argument_list|,
argument|rlen; 	int s; 	caddr_t buf; 	int resCount;  	if(&sc->arrq == dbch){ 		off = OHCI_ARQOFF; 	}else if(&sc->arrs == dbch){ 		off = OHCI_ARSOFF; 	}else{ 		return; 	}  	s = splfw(); 	db_tr = dbch->top; 	pcnt =
literal|0
argument|;
comment|/* XXX we cannot handle a packet which lies in more than two buf */
argument|while (db_tr->db[
literal|0
argument|].db.desc.status& OHCI_CNTL_DMA_ACTIVE) { 		ld = (u_int8_t *)db_tr->buf + dbch->buf_offset; 		resCount = db_tr->db[
literal|0
argument|].db.desc.count; 		len = dbch->xferq.psize - resCount 					- dbch->buf_offset; 		while (len>
literal|0
argument|) { 			if (count>=
literal|0
argument|&& count-- ==
literal|0
argument|) 				goto out; 			if(dbch->frag.buf != NULL){ 				buf = dbch->frag.buf; 				if (dbch->frag.plen<
literal|0
argument|) {
comment|/* incomplete header */
argument|int hlen;  					hlen = - dbch->frag.plen; 					rlen = hlen - dbch->frag.len; 					bcopy(ld, dbch->frag.buf + dbch->frag.len, rlen); 					ld += rlen; 					len -= rlen; 					dbch->frag.len += rlen;
if|#
directive|if
literal|0
argument|printf("(1)frag.plen=%d frag.len=%d rlen=%d len=%d\n", dbch->frag.plen, dbch->frag.len, rlen, len);
endif|#
directive|endif
argument|fp=(struct fw_pkt *)dbch->frag.buf; 					dbch->frag.plen 						= fwohci_get_plen(sc, fp, hlen); 					if (dbch->frag.plen ==
literal|0
argument|) 						goto out; 				} 				rlen = dbch->frag.plen - dbch->frag.len;
if|#
directive|if
literal|0
argument|printf("(2)frag.plen=%d frag.len=%d rlen=%d len=%d\n", dbch->frag.plen, dbch->frag.len, rlen, len);
endif|#
directive|endif
argument|bcopy(ld, dbch->frag.buf + dbch->frag.len, 						rlen); 				ld += rlen; 				len -= rlen; 				plen = dbch->frag.plen; 				dbch->frag.buf = NULL; 				dbch->frag.plen =
literal|0
argument|; 				dbch->frag.len =
literal|0
argument|; 				poff =
literal|0
argument|; 			}else{ 				fp=(struct fw_pkt *)ld; 				fp->mode.ld[
literal|0
argument|] = htonl(fp->mode.ld[
literal|0
argument|]); 				switch(fp->mode.common.tcode){ 				case FWTCODE_RREQQ: 				case FWTCODE_WRES: 				case FWTCODE_WREQQ: 				case FWTCODE_RRESQ: 				case FWOHCITCODE_PHY: 					hlen =
literal|12
argument|; 					break;  				case FWTCODE_RREQB: 				case FWTCODE_WREQB: 				case FWTCODE_LREQ: 				case FWTCODE_RRESB: 				case FWTCODE_LRES: 					hlen =
literal|16
argument|; 					break;  				default: 					device_printf(sc->fc.dev,
literal|"Unknown tcode %d\n"
argument|, fp->mode.common.tcode); 					goto out; 				} 				if (len>= hlen) { 					plen = fwohci_get_plen(sc, fp, hlen); 					if (plen ==
literal|0
argument|) 						goto out; 					plen = (plen +
literal|3
argument|)& ~
literal|3
argument|; 					len -= plen; 				} else { 					plen = -hlen; 					len -= hlen; 				} 				if(resCount>
literal|0
argument||| len>
literal|0
argument|){ 					buf = malloc( dbch->xferq.psize, 							M_FW, M_NOWAIT); 					if(buf == NULL){ 						printf(
literal|"cannot malloc!\n"
argument|); 						free(db_tr->buf, M_FW); 						goto out; 					} 					bcopy(ld, buf, plen); 					poff =
literal|0
argument|; 					dbch->frag.buf = NULL; 					dbch->frag.plen =
literal|0
argument|; 					dbch->frag.len =
literal|0
argument|; 				}else if(len<
literal|0
argument|){ 					dbch->frag.buf = db_tr->buf; 					if (plen<
literal|0
argument|) {
if|#
directive|if
literal|0
argument|printf("plen< 0:" 						"hlen: %d  len: %d\n", 						hlen, len);
endif|#
directive|endif
argument|dbch->frag.len = hlen + len; 						dbch->frag.plen = -hlen; 					} else { 						dbch->frag.len = plen + len; 						dbch->frag.plen = plen; 					} 					bcopy(ld, db_tr->buf, dbch->frag.len); 					buf = NULL; 				}else{ 					buf = db_tr->buf; 					poff = ld - (u_int8_t *)buf; 					dbch->frag.buf = NULL; 					dbch->frag.plen =
literal|0
argument|; 					dbch->frag.len =
literal|0
argument|; 				} 				ld += plen; 			} 			if( buf != NULL){
comment|/* DMA result-code will be written at the tail of packet */
argument|stat = ((struct fwohci_trailer *)(ld - sizeof(struct fwohci_trailer)))->stat; 				spd = (stat>>
literal|5
argument|)&
literal|0x3
argument|; 				stat&=
literal|0x1f
argument|; 				switch(stat){ 				case FWOHCIEV_ACKPEND:
if|#
directive|if
literal|0
argument|printf("fwohci_arcv: ack pending..\n");
endif|#
directive|endif
comment|/* fall through */
argument|case FWOHCIEV_ACKCOMPL: 					if( poff !=
literal|0
argument|) 						bcopy(buf+poff, buf, plen -
literal|4
argument|); 					fw_rcv(&sc->fc, buf, plen - sizeof(struct fwohci_trailer),
literal|0
argument|,
literal|0
argument|, spd); 					break; 				case FWOHCIEV_BUSRST: 					free(buf, M_FW); 					if (sc->fc.status != FWBUSRESET)  						printf(
literal|"got BUSRST packet!?\n"
argument|); 					break; 				default: 					device_printf(sc->fc.dev,
literal|"Async DMA Receive error err = %02x %s\n"
argument|, stat, fwohcicode[stat]);
if|#
directive|if
literal|0
comment|/* XXX */
argument|goto out;
endif|#
directive|endif
argument|break; 				} 			} 			pcnt ++; 		}; out: 		if (resCount ==
literal|0
argument|) {
comment|/* done on this buffer */
argument|fwohci_add_rx_buf(db_tr, dbch->xferq.psize, 						dbch->xferq.flag,
literal|0
argument|, NULL); 			dbch->bottom->db[
literal|0
argument|].db.desc.depend |= z; 			dbch->bottom = db_tr; 			db_tr = STAILQ_NEXT(db_tr, link); 			dbch->top = db_tr; 			dbch->buf_offset =
literal|0
argument|; 		} else { 			dbch->buf_offset = dbch->xferq.psize - resCount; 			break; 		}
comment|/* XXX make sure DMA is not dead */
argument|}
if|#
directive|if
literal|0
argument|if (pcnt< 1) 		printf("fwohci_arcv: no packets\n");
endif|#
directive|endif
argument|splx(s); }
end_function

end_unit

