begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 Hidetoshi Shimokawa  * Copyright (c) 1998-2002 Katsushi Kobayashi and Hidetoshi Shimokawa  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the acknowledgement as bellow:  *  *    This product includes software developed by K. Kobayashi and H. Shimokawa  *  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *   * $FreeBSD$  *  */
end_comment

begin_define
define|#
directive|define
name|ATRQ_CH
value|0
end_define

begin_define
define|#
directive|define
name|ATRS_CH
value|1
end_define

begin_define
define|#
directive|define
name|ARRQ_CH
value|2
end_define

begin_define
define|#
directive|define
name|ARRS_CH
value|3
end_define

begin_define
define|#
directive|define
name|ITX_CH
value|4
end_define

begin_define
define|#
directive|define
name|IRX_CH
value|0x24
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__DragonFly__
end_ifdef

begin_include
include|#
directive|include
file|"firewire.h"
end_include

begin_include
include|#
directive|include
file|"firewirereg.h"
end_include

begin_include
include|#
directive|include
file|"fwdma.h"
end_include

begin_include
include|#
directive|include
file|"fwohcireg.h"
end_include

begin_include
include|#
directive|include
file|"fwohcivar.h"
end_include

begin_include
include|#
directive|include
file|"firewire_phy.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dev/firewire/firewire.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewirereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/fwdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/fwohcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/fwohcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewire_phy.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|OHCI_DEBUG
end_undef

begin_decl_stmt
specifier|static
name|char
name|dbcode
index|[
literal|16
index|]
index|[
literal|0x10
index|]
init|=
block|{
literal|"OUTM"
block|,
literal|"OUTL"
block|,
literal|"INPM"
block|,
literal|"INPL"
block|,
literal|"STOR"
block|,
literal|"LOAD"
block|,
literal|"NOP "
block|,
literal|"STOP"
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|dbkey
index|[
literal|8
index|]
index|[
literal|0x10
index|]
init|=
block|{
literal|"ST0"
block|,
literal|"ST1"
block|,
literal|"ST2"
block|,
literal|"ST3"
block|,
literal|"UNDEF"
block|,
literal|"REG"
block|,
literal|"SYS"
block|,
literal|"DEV"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|dbcond
index|[
literal|4
index|]
index|[
literal|0x10
index|]
init|=
block|{
literal|"NEV"
block|,
literal|"C=1"
block|,
literal|"C=0"
block|,
literal|"ALL"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|fwohcicode
index|[
literal|32
index|]
index|[
literal|0x20
index|]
init|=
block|{
literal|"No stat"
block|,
literal|"Undef"
block|,
literal|"long"
block|,
literal|"miss Ack err"
block|,
literal|"underrun"
block|,
literal|"overrun"
block|,
literal|"desc err"
block|,
literal|"data read err"
block|,
literal|"data write err"
block|,
literal|"bus reset"
block|,
literal|"timeout"
block|,
literal|"tcode err"
block|,
literal|"Undef"
block|,
literal|"Undef"
block|,
literal|"unknown event"
block|,
literal|"flushed"
block|,
literal|"Undef"
block|,
literal|"ack complete"
block|,
literal|"ack pend"
block|,
literal|"Undef"
block|,
literal|"ack busy_X"
block|,
literal|"ack busy_A"
block|,
literal|"ack busy_B"
block|,
literal|"Undef"
block|,
literal|"Undef"
block|,
literal|"Undef"
block|,
literal|"Undef"
block|,
literal|"ack tardy"
block|,
literal|"Undef"
block|,
literal|"ack data_err"
block|,
literal|"ack type_err"
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_SPEED
value|3
end_define

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|linkspeed
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|tagbit
index|[
literal|4
index|]
init|=
block|{
literal|1
operator|<<
literal|28
block|,
literal|1
operator|<<
literal|29
block|,
literal|1
operator|<<
literal|30
block|,
literal|1
operator|<<
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tcode_info
name|tinfo
index|[]
init|=
block|{
comment|/*		hdr_len block 	flag*/
comment|/* 0 WREQQ  */
block|{
literal|16
block|,
name|FWTI_REQ
operator||
name|FWTI_TLABEL
block|}
block|,
comment|/* 1 WREQB  */
block|{
literal|16
block|,
name|FWTI_REQ
operator||
name|FWTI_TLABEL
operator||
name|FWTI_BLOCK_ASY
block|}
block|,
comment|/* 2 WRES   */
block|{
literal|12
block|,
name|FWTI_RES
block|}
block|,
comment|/* 3 XXX    */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* 4 RREQQ  */
block|{
literal|12
block|,
name|FWTI_REQ
operator||
name|FWTI_TLABEL
block|}
block|,
comment|/* 5 RREQB  */
block|{
literal|16
block|,
name|FWTI_REQ
operator||
name|FWTI_TLABEL
block|}
block|,
comment|/* 6 RRESQ  */
block|{
literal|16
block|,
name|FWTI_RES
block|}
block|,
comment|/* 7 RRESB  */
block|{
literal|16
block|,
name|FWTI_RES
operator||
name|FWTI_BLOCK_ASY
block|}
block|,
comment|/* 8 CYCS   */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* 9 LREQ   */
block|{
literal|16
block|,
name|FWTI_REQ
operator||
name|FWTI_TLABEL
operator||
name|FWTI_BLOCK_ASY
block|}
block|,
comment|/* a STREAM */
block|{
literal|4
block|,
name|FWTI_REQ
operator||
name|FWTI_BLOCK_STR
block|}
block|,
comment|/* b LRES   */
block|{
literal|16
block|,
name|FWTI_RES
operator||
name|FWTI_BLOCK_ASY
block|}
block|,
comment|/* c XXX    */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* d XXX    */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* e PHY    */
block|{
literal|12
block|,
name|FWTI_REQ
block|}
block|,
comment|/* f XXX    */
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OHCI_WRITE_SIGMASK
value|0xffff0000
end_define

begin_define
define|#
directive|define
name|OHCI_READ_SIGMASK
value|0xffff0000
end_define

begin_define
define|#
directive|define
name|OWRITE
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
value|bus_space_write_4((sc)->bst, (sc)->bsh, (r), (x))
end_define

begin_define
define|#
directive|define
name|OREAD
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|bus_space_read_4((sc)->bst, (sc)->bsh, (r))
end_define

begin_function_decl
specifier|static
name|void
name|fwohci_ibr
parameter_list|(
name|struct
name|firewire_comm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwohci_db_init
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
parameter_list|,
name|struct
name|fwohci_dbch
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwohci_db_free
parameter_list|(
name|struct
name|fwohci_dbch
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwohci_arcv
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
parameter_list|,
name|struct
name|fwohci_dbch
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwohci_txd
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
parameter_list|,
name|struct
name|fwohci_dbch
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwohci_start_atq
parameter_list|(
name|struct
name|firewire_comm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwohci_start_ats
parameter_list|(
name|struct
name|firewire_comm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwohci_start
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
parameter_list|,
name|struct
name|fwohci_dbch
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|fwphy_wrdata
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|fwphy_rddata
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fwohci_rx_enable
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
parameter_list|,
name|struct
name|fwohci_dbch
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fwohci_tx_enable
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
parameter_list|,
name|struct
name|fwohci_dbch
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fwohci_irx_enable
parameter_list|(
name|struct
name|firewire_comm
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fwohci_irx_disable
parameter_list|(
name|struct
name|firewire_comm
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
end_if

begin_function_decl
specifier|static
name|void
name|fwohci_irx_post
parameter_list|(
name|struct
name|firewire_comm
modifier|*
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|fwohci_itxbuf_enable
parameter_list|(
name|struct
name|firewire_comm
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fwohci_itx_disable
parameter_list|(
name|struct
name|firewire_comm
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwohci_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwohci_set_intr
parameter_list|(
name|struct
name|firewire_comm
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fwohci_add_rx_buf
parameter_list|(
name|struct
name|fwohci_dbch
modifier|*
parameter_list|,
name|struct
name|fwohcidb_tr
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|fwdma_alloc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fwohci_add_tx_buf
parameter_list|(
name|struct
name|fwohci_dbch
modifier|*
parameter_list|,
name|struct
name|fwohcidb_tr
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_db
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_db
parameter_list|(
name|struct
name|fwohcidb_tr
modifier|*
parameter_list|,
name|struct
name|fwohcidb
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dma
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|fwohci_cyctimer
parameter_list|(
name|struct
name|firewire_comm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwohci_rbuf_update
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwohci_tbuf_update
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fwohci_txbufdb
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|fw_bulkxfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|FWOHCI_TASKQUEUE
end_if

begin_function_decl
specifier|static
name|void
name|fwohci_complete
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * memory allocated for DMA programs  */
end_comment

begin_define
define|#
directive|define
name|DMA_PROG_ALLOC
value|(8 * PAGE_SIZE)
end_define

begin_define
define|#
directive|define
name|NDB
value|FWMAXQUEUE
end_define

begin_define
define|#
directive|define
name|OHCI_VERSION
value|0x00
end_define

begin_define
define|#
directive|define
name|OHCI_ATRETRY
value|0x08
end_define

begin_define
define|#
directive|define
name|OHCI_CROMHDR
value|0x18
end_define

begin_define
define|#
directive|define
name|OHCI_BUS_OPT
value|0x20
end_define

begin_define
define|#
directive|define
name|OHCI_BUSIRMC
value|(1<< 31)
end_define

begin_define
define|#
directive|define
name|OHCI_BUSCMC
value|(1<< 30)
end_define

begin_define
define|#
directive|define
name|OHCI_BUSISC
value|(1<< 29)
end_define

begin_define
define|#
directive|define
name|OHCI_BUSBMC
value|(1<< 28)
end_define

begin_define
define|#
directive|define
name|OHCI_BUSPMC
value|(1<< 27)
end_define

begin_define
define|#
directive|define
name|OHCI_BUSFNC
value|OHCI_BUSIRMC | OHCI_BUSCMC | OHCI_BUSISC |\ 				OHCI_BUSBMC | OHCI_BUSPMC
end_define

begin_define
define|#
directive|define
name|OHCI_EUID_HI
value|0x24
end_define

begin_define
define|#
directive|define
name|OHCI_EUID_LO
value|0x28
end_define

begin_define
define|#
directive|define
name|OHCI_CROMPTR
value|0x34
end_define

begin_define
define|#
directive|define
name|OHCI_HCCCTL
value|0x50
end_define

begin_define
define|#
directive|define
name|OHCI_HCCCTLCLR
value|0x54
end_define

begin_define
define|#
directive|define
name|OHCI_AREQHI
value|0x100
end_define

begin_define
define|#
directive|define
name|OHCI_AREQHICLR
value|0x104
end_define

begin_define
define|#
directive|define
name|OHCI_AREQLO
value|0x108
end_define

begin_define
define|#
directive|define
name|OHCI_AREQLOCLR
value|0x10c
end_define

begin_define
define|#
directive|define
name|OHCI_PREQHI
value|0x110
end_define

begin_define
define|#
directive|define
name|OHCI_PREQHICLR
value|0x114
end_define

begin_define
define|#
directive|define
name|OHCI_PREQLO
value|0x118
end_define

begin_define
define|#
directive|define
name|OHCI_PREQLOCLR
value|0x11c
end_define

begin_define
define|#
directive|define
name|OHCI_PREQUPPER
value|0x120
end_define

begin_define
define|#
directive|define
name|OHCI_SID_BUF
value|0x64
end_define

begin_define
define|#
directive|define
name|OHCI_SID_CNT
value|0x68
end_define

begin_define
define|#
directive|define
name|OHCI_SID_ERR
value|(1<< 31)
end_define

begin_define
define|#
directive|define
name|OHCI_SID_CNT_MASK
value|0xffc
end_define

begin_define
define|#
directive|define
name|OHCI_IT_STAT
value|0x90
end_define

begin_define
define|#
directive|define
name|OHCI_IT_STATCLR
value|0x94
end_define

begin_define
define|#
directive|define
name|OHCI_IT_MASK
value|0x98
end_define

begin_define
define|#
directive|define
name|OHCI_IT_MASKCLR
value|0x9c
end_define

begin_define
define|#
directive|define
name|OHCI_IR_STAT
value|0xa0
end_define

begin_define
define|#
directive|define
name|OHCI_IR_STATCLR
value|0xa4
end_define

begin_define
define|#
directive|define
name|OHCI_IR_MASK
value|0xa8
end_define

begin_define
define|#
directive|define
name|OHCI_IR_MASKCLR
value|0xac
end_define

begin_define
define|#
directive|define
name|OHCI_LNKCTL
value|0xe0
end_define

begin_define
define|#
directive|define
name|OHCI_LNKCTLCLR
value|0xe4
end_define

begin_define
define|#
directive|define
name|OHCI_PHYACCESS
value|0xec
end_define

begin_define
define|#
directive|define
name|OHCI_CYCLETIMER
value|0xf0
end_define

begin_define
define|#
directive|define
name|OHCI_DMACTL
parameter_list|(
name|off
parameter_list|)
value|(off)
end_define

begin_define
define|#
directive|define
name|OHCI_DMACTLCLR
parameter_list|(
name|off
parameter_list|)
value|(off + 4)
end_define

begin_define
define|#
directive|define
name|OHCI_DMACMD
parameter_list|(
name|off
parameter_list|)
value|(off + 0xc)
end_define

begin_define
define|#
directive|define
name|OHCI_DMAMATCH
parameter_list|(
name|off
parameter_list|)
value|(off + 0x10)
end_define

begin_define
define|#
directive|define
name|OHCI_ATQOFF
value|0x180
end_define

begin_define
define|#
directive|define
name|OHCI_ATQCTL
value|OHCI_ATQOFF
end_define

begin_define
define|#
directive|define
name|OHCI_ATQCTLCLR
value|(OHCI_ATQOFF + 4)
end_define

begin_define
define|#
directive|define
name|OHCI_ATQCMD
value|(OHCI_ATQOFF + 0xc)
end_define

begin_define
define|#
directive|define
name|OHCI_ATQMATCH
value|(OHCI_ATQOFF + 0x10)
end_define

begin_define
define|#
directive|define
name|OHCI_ATSOFF
value|0x1a0
end_define

begin_define
define|#
directive|define
name|OHCI_ATSCTL
value|OHCI_ATSOFF
end_define

begin_define
define|#
directive|define
name|OHCI_ATSCTLCLR
value|(OHCI_ATSOFF + 4)
end_define

begin_define
define|#
directive|define
name|OHCI_ATSCMD
value|(OHCI_ATSOFF + 0xc)
end_define

begin_define
define|#
directive|define
name|OHCI_ATSMATCH
value|(OHCI_ATSOFF + 0x10)
end_define

begin_define
define|#
directive|define
name|OHCI_ARQOFF
value|0x1c0
end_define

begin_define
define|#
directive|define
name|OHCI_ARQCTL
value|OHCI_ARQOFF
end_define

begin_define
define|#
directive|define
name|OHCI_ARQCTLCLR
value|(OHCI_ARQOFF + 4)
end_define

begin_define
define|#
directive|define
name|OHCI_ARQCMD
value|(OHCI_ARQOFF + 0xc)
end_define

begin_define
define|#
directive|define
name|OHCI_ARQMATCH
value|(OHCI_ARQOFF + 0x10)
end_define

begin_define
define|#
directive|define
name|OHCI_ARSOFF
value|0x1e0
end_define

begin_define
define|#
directive|define
name|OHCI_ARSCTL
value|OHCI_ARSOFF
end_define

begin_define
define|#
directive|define
name|OHCI_ARSCTLCLR
value|(OHCI_ARSOFF + 4)
end_define

begin_define
define|#
directive|define
name|OHCI_ARSCMD
value|(OHCI_ARSOFF + 0xc)
end_define

begin_define
define|#
directive|define
name|OHCI_ARSMATCH
value|(OHCI_ARSOFF + 0x10)
end_define

begin_define
define|#
directive|define
name|OHCI_ITOFF
parameter_list|(
name|CH
parameter_list|)
value|(0x200 + 0x10 * (CH))
end_define

begin_define
define|#
directive|define
name|OHCI_ITCTL
parameter_list|(
name|CH
parameter_list|)
value|(OHCI_ITOFF(CH))
end_define

begin_define
define|#
directive|define
name|OHCI_ITCTLCLR
parameter_list|(
name|CH
parameter_list|)
value|(OHCI_ITOFF(CH) + 4)
end_define

begin_define
define|#
directive|define
name|OHCI_ITCMD
parameter_list|(
name|CH
parameter_list|)
value|(OHCI_ITOFF(CH) + 0xc)
end_define

begin_define
define|#
directive|define
name|OHCI_IROFF
parameter_list|(
name|CH
parameter_list|)
value|(0x400 + 0x20 * (CH))
end_define

begin_define
define|#
directive|define
name|OHCI_IRCTL
parameter_list|(
name|CH
parameter_list|)
value|(OHCI_IROFF(CH))
end_define

begin_define
define|#
directive|define
name|OHCI_IRCTLCLR
parameter_list|(
name|CH
parameter_list|)
value|(OHCI_IROFF(CH) + 4)
end_define

begin_define
define|#
directive|define
name|OHCI_IRCMD
parameter_list|(
name|CH
parameter_list|)
value|(OHCI_IROFF(CH) + 0xc)
end_define

begin_define
define|#
directive|define
name|OHCI_IRMATCH
parameter_list|(
name|CH
parameter_list|)
value|(OHCI_IROFF(CH) + 0x10)
end_define

begin_decl_stmt
name|d_ioctl_t
name|fwohci_ioctl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Communication with PHY device  */
end_comment

begin_function
specifier|static
name|uint32_t
name|fwphy_wrdata
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|uint32_t
name|fun
decl_stmt|;
name|addr
operator|&=
literal|0xf
expr_stmt|;
name|data
operator|&=
literal|0xff
expr_stmt|;
name|fun
operator|=
operator|(
name|PHYDEV_WRCMD
operator||
operator|(
name|addr
operator|<<
name|PHYDEV_REGADDR
operator|)
operator||
operator|(
name|data
operator|<<
name|PHYDEV_WRDATA
operator|)
operator|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_PHYACCESS
argument_list|,
name|fun
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
return|return
operator|(
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|fwohci_set_bus_manager
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|u_int
name|node
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|bm
decl_stmt|;
define|#
directive|define
name|OHCI_CSR_DATA
value|0x0c
define|#
directive|define
name|OHCI_CSR_COMP
value|0x10
define|#
directive|define
name|OHCI_CSR_CONT
value|0x14
define|#
directive|define
name|OHCI_BUS_MANAGER_ID
value|0
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_CSR_DATA
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_CSR_COMP
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_CSR_CONT
argument_list|,
name|OHCI_BUS_MANAGER_ID
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
operator|(
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_CSR_CONT
argument_list|)
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
operator|)
operator|&&
operator|(
name|i
operator|<
literal|1000
operator|)
condition|;
name|i
operator|++
control|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|bm
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_CSR_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bm
operator|&
literal|0x3f
operator|)
operator|==
literal|0x3f
condition|)
name|bm
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|firewire_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"fw_set_bus_manager: %d->%d (loop=%d)\n"
argument_list|,
name|bm
argument_list|,
name|node
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|bm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|fwphy_rddata
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|addr
parameter_list|)
block|{
name|uint32_t
name|fun
decl_stmt|,
name|stat
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|retry
init|=
literal|0
decl_stmt|;
name|addr
operator|&=
literal|0xf
expr_stmt|;
define|#
directive|define
name|MAX_RETRY
value|100
name|again
label|:
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_REG_FAIL
argument_list|)
expr_stmt|;
name|fun
operator|=
name|PHYDEV_RDCMD
operator||
operator|(
name|addr
operator|<<
name|PHYDEV_REGADDR
operator|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_PHYACCESS
argument_list|,
name|fun
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_RETRY
condition|;
name|i
operator|++
control|)
block|{
name|fun
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_PHYACCESS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fun
operator|&
name|PHYDEV_RDCMD
operator|)
operator|==
literal|0
operator|&&
operator|(
name|fun
operator|&
name|PHYDEV_RDDONE
operator|)
operator|!=
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|MAX_RETRY
condition|)
block|{
if|if
condition|(
name|firewire_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"phy read failed(1).\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|retry
operator|<
name|MAX_RETRY
condition|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
comment|/* Make sure that SCLK is started */
name|stat
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_REG_FAIL
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|fun
operator|>>
name|PHYDEV_REGADDR
operator|)
operator|&
literal|0xf
operator|)
operator|!=
name|addr
condition|)
block|{
if|if
condition|(
name|firewire_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"phy read failed(2).\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|retry
operator|<
name|MAX_RETRY
condition|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
if|if
condition|(
name|firewire_debug
operator|||
name|retry
operator|>=
name|MAX_RETRY
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"fwphy_rddata: 0x%x loop=%d, retry=%d\n"
argument_list|,
name|addr
argument_list|,
name|i
argument_list|,
name|retry
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|MAX_RETRY
return|return
operator|(
operator|(
name|fun
operator|>>
name|PHYDEV_RDDATA
operator|)
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Device specific ioctl. */
end_comment

begin_function
name|int
name|fwohci_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|fw_proc
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|firewire_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|fwohci_softc
modifier|*
name|fc
decl_stmt|;
name|int
name|unit
init|=
name|DEV2UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|fw_reg_req_t
modifier|*
name|reg
init|=
operator|(
expr|struct
name|fw_reg_req_t
operator|*
operator|)
name|data
decl_stmt|;
name|uint32_t
modifier|*
name|dmach
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|data
decl_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|firewire_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|fc
operator|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|sc
operator|->
name|fc
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FWOHCI_WRREG
case|:
define|#
directive|define
name|OHCI_MAX_REG
value|0x800
if|if
condition|(
name|reg
operator|->
name|addr
operator|<=
name|OHCI_MAX_REG
condition|)
block|{
name|OWRITE
argument_list|(
name|fc
argument_list|,
name|reg
operator|->
name|addr
argument_list|,
name|reg
operator|->
name|data
argument_list|)
expr_stmt|;
name|reg
operator|->
name|data
operator|=
name|OREAD
argument_list|(
name|fc
argument_list|,
name|reg
operator|->
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|FWOHCI_RDREG
case|:
if|if
condition|(
name|reg
operator|->
name|addr
operator|<=
name|OHCI_MAX_REG
condition|)
block|{
name|reg
operator|->
name|data
operator|=
name|OREAD
argument_list|(
name|fc
argument_list|,
name|reg
operator|->
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
comment|/* Read DMA descriptors for debug  */
case|case
name|DUMPDMA
case|:
if|if
condition|(
operator|*
name|dmach
operator|<=
name|OHCI_MAX_DMA_CH
condition|)
block|{
name|dump_dma
argument_list|(
name|fc
argument_list|,
operator|*
name|dmach
argument_list|)
expr_stmt|;
name|dump_db
argument_list|(
name|fc
argument_list|,
operator|*
name|dmach
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
comment|/* Read/Write Phy registers */
define|#
directive|define
name|OHCI_MAX_PHY_REG
value|0xf
case|case
name|FWOHCI_RDPHYREG
case|:
if|if
condition|(
name|reg
operator|->
name|addr
operator|<=
name|OHCI_MAX_PHY_REG
condition|)
name|reg
operator|->
name|data
operator|=
name|fwphy_rddata
argument_list|(
name|fc
argument_list|,
name|reg
operator|->
name|addr
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|FWOHCI_WRPHYREG
case|:
if|if
condition|(
name|reg
operator|->
name|addr
operator|<=
name|OHCI_MAX_PHY_REG
condition|)
name|reg
operator|->
name|data
operator|=
name|fwphy_wrdata
argument_list|(
name|fc
argument_list|,
name|reg
operator|->
name|addr
argument_list|,
name|reg
operator|->
name|data
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_probe_phy
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|,
name|reg2
decl_stmt|;
name|int
name|e1394a
init|=
literal|1
decl_stmt|;
comment|/*  * probe PHY parameters  * 0. to prove PHY version, whether compliance of 1394a.  * 1. to probe maximum speed supported by the PHY and   *    number of port supported by core-logic.  *    It is not actually available port on your PC .  */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|,
name|OHCI_HCC_LPS
argument_list|)
expr_stmt|;
name|reg
operator|=
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
name|FW_PHY_SPD_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|>>
literal|5
operator|)
operator|!=
literal|7
condition|)
block|{
name|sc
operator|->
name|fc
operator|.
name|mode
operator|&=
operator|~
name|FWPHYASYST
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|nport
operator|=
name|reg
operator|&
name|FW_PHY_NP
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|speed
operator|=
name|reg
operator|&
name|FW_PHY_SPD
operator|>>
literal|6
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fc
operator|.
name|speed
operator|>
name|MAX_SPEED
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid speed %d (fixed to %d).\n"
argument_list|,
name|sc
operator|->
name|fc
operator|.
name|speed
argument_list|,
name|MAX_SPEED
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|speed
operator|=
name|MAX_SPEED
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Phy 1394 only %s, %d ports.\n"
argument_list|,
name|linkspeed
index|[
name|sc
operator|->
name|fc
operator|.
name|speed
index|]
argument_list|,
name|sc
operator|->
name|fc
operator|.
name|nport
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reg2
operator|=
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
name|FW_PHY_ESPD_REG
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|mode
operator||=
name|FWPHYASYST
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|nport
operator|=
name|reg
operator|&
name|FW_PHY_NP
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|speed
operator|=
operator|(
name|reg2
operator|&
name|FW_PHY_ESPD
operator|)
operator|>>
literal|5
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fc
operator|.
name|speed
operator|>
name|MAX_SPEED
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid speed %d (fixed to %d).\n"
argument_list|,
name|sc
operator|->
name|fc
operator|.
name|speed
argument_list|,
name|MAX_SPEED
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|speed
operator|=
name|MAX_SPEED
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Phy 1394a available %s, %d ports.\n"
argument_list|,
name|linkspeed
index|[
name|sc
operator|->
name|fc
operator|.
name|speed
index|]
argument_list|,
name|sc
operator|->
name|fc
operator|.
name|nport
argument_list|)
expr_stmt|;
comment|/* check programPhyEnable */
name|reg2
operator|=
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (e1394a&& (OREAD(sc, OHCI_HCCCTL)& OHCI_HCC_PRPHY)) {
else|#
directive|else
comment|/* XXX force to enable 1394a */
if|if
condition|(
name|e1394a
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|firewire_debug
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Enable 1394a Enhancements\n"
argument_list|)
expr_stmt|;
comment|/* enable EAA EMC */
name|reg2
operator||=
literal|0x03
expr_stmt|;
comment|/* set aPhyEnhanceEnable */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|,
name|OHCI_HCC_PHYEN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTLCLR
argument_list|,
name|OHCI_HCC_PRPHY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* for safe */
name|reg2
operator|&=
operator|~
literal|0x83
expr_stmt|;
block|}
name|reg2
operator|=
name|fwphy_wrdata
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
block|}
name|reg
operator|=
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
name|FW_PHY_SPD_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|>>
literal|5
operator|)
operator|==
literal|7
condition|)
block|{
name|reg
operator|=
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|reg
operator||=
literal|1
operator|<<
literal|6
expr_stmt|;
name|fwphy_wrdata
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|fwohci_reset
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|max_rec
decl_stmt|,
name|speed
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|,
name|reg2
decl_stmt|;
name|struct
name|fwohcidb_tr
modifier|*
name|db_tr
decl_stmt|;
comment|/* Disable interrupts */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASKCLR
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
comment|/* Now stopping all DMA channels */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ARQCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ARSCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ATQCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ATSCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_MASKCLR
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|fc
operator|.
name|nisodma
condition|;
name|i
operator|++
control|)
block|{
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTLCLR
argument_list|(
name|i
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ITCTLCLR
argument_list|(
name|i
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
block|}
comment|/* FLUSH FIFO and reset Transmitter/Reciever */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|,
name|OHCI_HCC_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|firewire_debug
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"resetting OHCI..."
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|)
operator|&
name|OHCI_HCC_RESET
condition|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
literal|100
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|firewire_debug
condition|)
name|printf
argument_list|(
literal|"done (loop=%d)\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Probe phy */
name|fwohci_probe_phy
argument_list|(
name|sc
argument_list|,
name|dev
argument_list|)
expr_stmt|;
comment|/* Probe link */
name|reg
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_BUS_OPT
argument_list|)
expr_stmt|;
name|reg2
operator|=
name|reg
operator||
name|OHCI_BUSFNC
expr_stmt|;
name|max_rec
operator|=
operator|(
name|reg
operator|&
literal|0x0000f000
operator|)
operator|>>
literal|12
expr_stmt|;
name|speed
operator|=
operator|(
name|reg
operator|&
literal|0x00000007
operator|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link %s, max_rec %d bytes.\n"
argument_list|,
name|linkspeed
index|[
name|speed
index|]
argument_list|,
name|MAXREC
argument_list|(
name|max_rec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX fix max_rec */
name|sc
operator|->
name|fc
operator|.
name|maxrec
operator|=
name|sc
operator|->
name|fc
operator|.
name|speed
operator|+
literal|8
expr_stmt|;
if|if
condition|(
name|max_rec
operator|!=
name|sc
operator|->
name|fc
operator|.
name|maxrec
condition|)
block|{
name|reg2
operator|=
operator|(
name|reg2
operator|&
literal|0xffff0fff
operator|)
operator||
operator|(
name|sc
operator|->
name|fc
operator|.
name|maxrec
operator|<<
literal|12
operator|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"max_rec %d -> %d\n"
argument_list|,
name|MAXREC
argument_list|(
name|max_rec
argument_list|)
argument_list|,
name|MAXREC
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|maxrec
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|firewire_debug
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"BUS_OPT 0x%x -> 0x%x\n"
argument_list|,
name|reg
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_BUS_OPT
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
comment|/* Initialize registers */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_CROMHDR
argument_list|,
name|sc
operator|->
name|fc
operator|.
name|config_rom
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_CROMPTR
argument_list|,
name|sc
operator|->
name|crom_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTLCLR
argument_list|,
name|OHCI_HCC_BIGEND
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|,
name|OHCI_HCC_POSTWR
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_SID_BUF
argument_list|,
name|sc
operator|->
name|sid_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_LNKCTL
argument_list|,
name|OHCI_CNTL_SID
argument_list|)
expr_stmt|;
comment|/* Enable link */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|,
name|OHCI_HCC_LINKEN
argument_list|)
expr_stmt|;
comment|/* Force to start async RX DMA */
name|sc
operator|->
name|arrq
operator|.
name|xferq
operator|.
name|flag
operator|&=
operator|~
name|FWXFERQ_RUNNING
expr_stmt|;
name|sc
operator|->
name|arrs
operator|.
name|xferq
operator|.
name|flag
operator|&=
operator|~
name|FWXFERQ_RUNNING
expr_stmt|;
name|fwohci_rx_enable
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|arrq
argument_list|)
expr_stmt|;
name|fwohci_rx_enable
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|arrs
argument_list|)
expr_stmt|;
comment|/* Initialize async TX */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ATQCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
operator||
name|OHCI_CNTL_DMA_DEAD
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ATSCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
operator||
name|OHCI_CNTL_DMA_DEAD
argument_list|)
expr_stmt|;
comment|/* AT Retries */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_RETRY
argument_list|,
comment|/* CycleLimit   PhyRespRetries ATRespRetries ATReqRetries */
operator|(
literal|0xffff
operator|<<
literal|16
operator|)
operator||
operator|(
literal|0x0f
operator|<<
literal|8
operator|)
operator||
operator|(
literal|0x0f
operator|<<
literal|4
operator|)
operator||
literal|0x0f
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atrq
operator|.
name|top
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|atrq
operator|.
name|db_trq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atrs
operator|.
name|top
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|atrs
operator|.
name|db_trq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atrq
operator|.
name|bottom
operator|=
name|sc
operator|->
name|atrq
operator|.
name|top
expr_stmt|;
name|sc
operator|->
name|atrs
operator|.
name|bottom
operator|=
name|sc
operator|->
name|atrs
operator|.
name|top
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|db_tr
operator|=
name|sc
operator|->
name|atrq
operator|.
name|top
init|;
name|i
operator|<
name|sc
operator|->
name|atrq
operator|.
name|ndb
condition|;
name|i
operator|++
operator|,
name|db_tr
operator|=
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
control|)
block|{
name|db_tr
operator|->
name|xfer
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|db_tr
operator|=
name|sc
operator|->
name|atrs
operator|.
name|top
init|;
name|i
operator|<
name|sc
operator|->
name|atrs
operator|.
name|ndb
condition|;
name|i
operator|++
operator|,
name|db_tr
operator|=
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
control|)
block|{
name|db_tr
operator|->
name|xfer
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Enable interrupts */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASK
argument_list|,
name|OHCI_INT_ERR
operator||
name|OHCI_INT_PHY_SID
operator||
name|OHCI_INT_DMA_ATRQ
operator||
name|OHCI_INT_DMA_ATRS
operator||
name|OHCI_INT_DMA_PRRQ
operator||
name|OHCI_INT_DMA_PRRS
operator||
name|OHCI_INT_PHY_BUS_R
operator||
name|OHCI_INT_PW_ERR
argument_list|)
expr_stmt|;
name|fwohci_set_intr
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|fwohci_init
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|mver
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|uint8_t
name|ui
index|[
literal|8
index|]
decl_stmt|;
if|#
directive|if
name|FWOHCI_TASKQUEUE
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|fwohci_task_complete
argument_list|,
literal|0
argument_list|,
name|fwohci_complete
argument_list|,
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OHCI version */
name|reg
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_VERSION
argument_list|)
expr_stmt|;
name|mver
operator|=
operator|(
name|reg
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"OHCI version %x.%x (ROM=%d)\n"
argument_list|,
name|mver
argument_list|,
name|reg
operator|&
literal|0xff
argument_list|,
operator|(
name|reg
operator|>>
literal|24
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mver
operator|<
literal|1
operator|||
name|mver
operator|>
literal|9
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid OHCI version\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Available Isochronous DMA channel probe */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_MASK
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_MASK
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|reg
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_MASK
argument_list|)
operator|&
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_MASK
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_MASKCLR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_MASKCLR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x20
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|reg
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|sc
operator|->
name|fc
operator|.
name|nisodma
operator|=
name|i
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No. of Isochronous channels is %d.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|->
name|fc
operator|.
name|arq
operator|=
operator|&
name|sc
operator|->
name|arrq
operator|.
name|xferq
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|ars
operator|=
operator|&
name|sc
operator|->
name|arrs
operator|.
name|xferq
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|atq
operator|=
operator|&
name|sc
operator|->
name|atrq
operator|.
name|xferq
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|ats
operator|=
operator|&
name|sc
operator|->
name|atrs
operator|.
name|xferq
expr_stmt|;
name|sc
operator|->
name|arrq
operator|.
name|xferq
operator|.
name|psize
operator|=
name|roundup2
argument_list|(
name|FWPMAX_S400
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arrs
operator|.
name|xferq
operator|.
name|psize
operator|=
name|roundup2
argument_list|(
name|FWPMAX_S400
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atrq
operator|.
name|xferq
operator|.
name|psize
operator|=
name|roundup2
argument_list|(
name|FWPMAX_S400
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atrs
operator|.
name|xferq
operator|.
name|psize
operator|=
name|roundup2
argument_list|(
name|FWPMAX_S400
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arrq
operator|.
name|xferq
operator|.
name|start
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|arrs
operator|.
name|xferq
operator|.
name|start
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|atrq
operator|.
name|xferq
operator|.
name|start
operator|=
name|fwohci_start_atq
expr_stmt|;
name|sc
operator|->
name|atrs
operator|.
name|xferq
operator|.
name|start
operator|=
name|fwohci_start_ats
expr_stmt|;
name|sc
operator|->
name|arrq
operator|.
name|xferq
operator|.
name|buf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|arrs
operator|.
name|xferq
operator|.
name|buf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|atrq
operator|.
name|xferq
operator|.
name|buf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|atrs
operator|.
name|xferq
operator|.
name|buf
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|arrq
operator|.
name|xferq
operator|.
name|dmach
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|arrs
operator|.
name|xferq
operator|.
name|dmach
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|atrq
operator|.
name|xferq
operator|.
name|dmach
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|atrs
operator|.
name|xferq
operator|.
name|dmach
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|arrq
operator|.
name|ndesc
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|arrs
operator|.
name|ndesc
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|atrq
operator|.
name|ndesc
operator|=
literal|8
expr_stmt|;
comment|/* equal to maximum of mbuf chains */
name|sc
operator|->
name|atrs
operator|.
name|ndesc
operator|=
literal|2
expr_stmt|;
name|sc
operator|->
name|arrq
operator|.
name|ndb
operator|=
name|NDB
expr_stmt|;
name|sc
operator|->
name|arrs
operator|.
name|ndb
operator|=
name|NDB
operator|/
literal|2
expr_stmt|;
name|sc
operator|->
name|atrq
operator|.
name|ndb
operator|=
name|NDB
expr_stmt|;
name|sc
operator|->
name|atrs
operator|.
name|ndb
operator|=
name|NDB
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|fc
operator|.
name|nisodma
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|fc
operator|.
name|it
index|[
name|i
index|]
operator|=
operator|&
name|sc
operator|->
name|it
index|[
name|i
index|]
operator|.
name|xferq
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|ir
index|[
name|i
index|]
operator|=
operator|&
name|sc
operator|->
name|ir
index|[
name|i
index|]
operator|.
name|xferq
expr_stmt|;
name|sc
operator|->
name|it
index|[
name|i
index|]
operator|.
name|xferq
operator|.
name|dmach
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|ir
index|[
name|i
index|]
operator|.
name|xferq
operator|.
name|dmach
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|it
index|[
name|i
index|]
operator|.
name|ndb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|ir
index|[
name|i
index|]
operator|.
name|ndb
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|fc
operator|.
name|tcode
operator|=
name|tinfo
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|config_rom
operator|=
name|fwdma_malloc
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|,
name|CROMSIZE
argument_list|,
name|CROMSIZE
argument_list|,
operator|&
name|sc
operator|->
name|crom_dma
argument_list|,
name|BUS_DMA_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fc
operator|.
name|config_rom
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"config_rom alloc failed."
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|#
directive|if
literal|0
block|bzero(&sc->fc.config_rom[0], CROMSIZE); 	sc->fc.config_rom[1] = 0x31333934; 	sc->fc.config_rom[2] = 0xf000a002; 	sc->fc.config_rom[3] = OREAD(sc, OHCI_EUID_HI); 	sc->fc.config_rom[4] = OREAD(sc, OHCI_EUID_LO); 	sc->fc.config_rom[5] = 0; 	sc->fc.config_rom[0] = (4<< 24) | (5<< 16);  	sc->fc.config_rom[0] |= fw_crc16(&sc->fc.config_rom[1], 5*4);
endif|#
directive|endif
comment|/* SID recieve buffer must align 2^11 */
define|#
directive|define
name|OHCI_SIDSIZE
value|(1<< 11)
name|sc
operator|->
name|sid_buf
operator|=
name|fwdma_malloc
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|,
name|OHCI_SIDSIZE
argument_list|,
name|OHCI_SIDSIZE
argument_list|,
operator|&
name|sc
operator|->
name|sid_dma
argument_list|,
name|BUS_DMA_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sid_buf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"sid_buf alloc failed."
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|fwdma_malloc
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|dummy_dma
argument_list|,
name|BUS_DMA_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dummy_dma
operator|.
name|v_addr
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"dummy_dma alloc failed."
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|fwohci_db_init
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|arrq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|arrq
operator|.
name|flags
operator|&
name|FWOHCI_DBCH_INIT
operator|)
operator|==
literal|0
condition|)
return|return
name|ENOMEM
return|;
name|fwohci_db_init
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|arrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|arrs
operator|.
name|flags
operator|&
name|FWOHCI_DBCH_INIT
operator|)
operator|==
literal|0
condition|)
return|return
name|ENOMEM
return|;
name|fwohci_db_init
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|atrq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|atrq
operator|.
name|flags
operator|&
name|FWOHCI_DBCH_INIT
operator|)
operator|==
literal|0
condition|)
return|return
name|ENOMEM
return|;
name|fwohci_db_init
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|atrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|atrs
operator|.
name|flags
operator|&
name|FWOHCI_DBCH_INIT
operator|)
operator|==
literal|0
condition|)
return|return
name|ENOMEM
return|;
name|sc
operator|->
name|fc
operator|.
name|eui
operator|.
name|hi
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCIGUID_H
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|eui
operator|.
name|lo
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCIGUID_L
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|ui
index|[
name|i
index|]
operator|=
name|FW_EUI64_BYTE
argument_list|(
operator|&
name|sc
operator|->
name|fc
operator|.
name|eui
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"EUI64 %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n"
argument_list|,
name|ui
index|[
literal|0
index|]
argument_list|,
name|ui
index|[
literal|1
index|]
argument_list|,
name|ui
index|[
literal|2
index|]
argument_list|,
name|ui
index|[
literal|3
index|]
argument_list|,
name|ui
index|[
literal|4
index|]
argument_list|,
name|ui
index|[
literal|5
index|]
argument_list|,
name|ui
index|[
literal|6
index|]
argument_list|,
name|ui
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|ioctl
operator|=
name|fwohci_ioctl
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|cyctimer
operator|=
name|fwohci_cyctimer
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|set_bmr
operator|=
name|fwohci_set_bus_manager
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|ibr
operator|=
name|fwohci_ibr
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|irx_enable
operator|=
name|fwohci_irx_enable
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|irx_disable
operator|=
name|fwohci_irx_disable
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|itx_enable
operator|=
name|fwohci_itxbuf_enable
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|itx_disable
operator|=
name|fwohci_itx_disable
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|sc
operator|->
name|fc
operator|.
name|irx_post
operator|=
name|fwohci_irx_post
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|fc
operator|.
name|irx_post
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|fc
operator|.
name|itx_post
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|timeout
operator|=
name|fwohci_timeout
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|poll
operator|=
name|fwohci_poll
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|set_intr
operator|=
name|fwohci_set_intr
expr_stmt|;
name|sc
operator|->
name|intmask
operator|=
name|sc
operator|->
name|irstat
operator|=
name|sc
operator|->
name|itstat
operator|=
literal|0
expr_stmt|;
name|fw_init
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|)
expr_stmt|;
name|fwohci_reset
argument_list|(
name|sc
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|fwohci_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|arg
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|fwohci_cyctimer
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
decl_stmt|;
return|return
operator|(
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_CYCLETIMER
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fwohci_detach
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sid_buf
operator|!=
name|NULL
condition|)
name|fwdma_free
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|,
operator|&
name|sc
operator|->
name|sid_dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fc
operator|.
name|config_rom
operator|!=
name|NULL
condition|)
name|fwdma_free
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|,
operator|&
name|sc
operator|->
name|crom_dma
argument_list|)
expr_stmt|;
name|fwohci_db_free
argument_list|(
operator|&
name|sc
operator|->
name|arrq
argument_list|)
expr_stmt|;
name|fwohci_db_free
argument_list|(
operator|&
name|sc
operator|->
name|arrs
argument_list|)
expr_stmt|;
name|fwohci_db_free
argument_list|(
operator|&
name|sc
operator|->
name|atrq
argument_list|)
expr_stmt|;
name|fwohci_db_free
argument_list|(
operator|&
name|sc
operator|->
name|atrs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|fc
operator|.
name|nisodma
condition|;
name|i
operator|++
control|)
block|{
name|fwohci_db_free
argument_list|(
operator|&
name|sc
operator|->
name|it
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fwohci_db_free
argument_list|(
operator|&
name|sc
operator|->
name|ir
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|LAST_DB
parameter_list|(
name|dbtr
parameter_list|,
name|db
parameter_list|)
value|do {						\ 	struct fwohcidb_tr *_dbtr = (dbtr);				\ 	int _cnt = _dbtr->dbcnt;					\ 	db =&_dbtr->db[ (_cnt> 2) ? (_cnt -1) : 0];			\ } while (0)
end_define

begin_function
specifier|static
name|void
name|fwohci_execute_db
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|fwohcidb_tr
modifier|*
name|db_tr
decl_stmt|;
name|struct
name|fwohcidb
modifier|*
name|db
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|db_tr
operator|=
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
name|arg
expr_stmt|;
name|db
operator|=
operator|&
name|db_tr
operator|->
name|db
index|[
name|db_tr
operator|->
name|dbcnt
index|]
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|firewire_debug
operator|||
name|error
operator|!=
name|EFBIG
condition|)
name|printf
argument_list|(
literal|"fwohci_execute_db: error=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|segs
index|[
name|i
index|]
expr_stmt|;
name|FWOHCI_DMA_WRITE
argument_list|(
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|addr
argument_list|,
name|s
operator|->
name|ds_addr
argument_list|)
expr_stmt|;
name|FWOHCI_DMA_WRITE
argument_list|(
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|cmd
argument_list|,
name|s
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|FWOHCI_DMA_WRITE
argument_list|(
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|db
operator|++
expr_stmt|;
name|db_tr
operator|->
name|dbcnt
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_execute_db2
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|fwohci_execute_db
argument_list|(
name|arg
argument_list|,
name|segs
argument_list|,
name|nseg
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_start
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|fwohci_dbch
modifier|*
name|dbch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|int
name|tcode
decl_stmt|,
name|hdr_len
decl_stmt|,
name|pl_off
decl_stmt|;
name|int
name|fsegment
init|=
operator|-
literal|1
decl_stmt|;
name|uint32_t
name|off
decl_stmt|;
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|struct
name|fwohci_txpkthdr
modifier|*
name|ohcifp
decl_stmt|;
name|struct
name|fwohcidb_tr
modifier|*
name|db_tr
decl_stmt|;
name|struct
name|fwohcidb
modifier|*
name|db
decl_stmt|;
name|uint32_t
modifier|*
name|ld
decl_stmt|;
name|struct
name|tcode_info
modifier|*
name|info
decl_stmt|;
specifier|static
name|int
name|maxdesc
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|&
name|sc
operator|->
name|atrq
operator|==
name|dbch
condition|)
block|{
name|off
operator|=
name|OHCI_ATQOFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|&
name|sc
operator|->
name|atrs
operator|==
name|dbch
condition|)
block|{
name|off
operator|=
name|OHCI_ATSOFF
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
if|if
condition|(
name|dbch
operator|->
name|flags
operator|&
name|FWOHCI_DBCH_FULL
condition|)
return|return;
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|db_tr
operator|=
name|dbch
operator|->
name|top
expr_stmt|;
name|txloop
label|:
name|xfer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dbch
operator|->
name|xferq
operator|.
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
goto|goto
name|kick
goto|;
block|}
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|queued
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"TX queue empty\n"
argument_list|)
expr_stmt|;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|dbch
operator|->
name|xferq
operator|.
name|q
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|db_tr
operator|->
name|xfer
operator|=
name|xfer
expr_stmt|;
name|xfer
operator|->
name|state
operator|=
name|FWXF_START
expr_stmt|;
name|fp
operator|=
operator|&
name|xfer
operator|->
name|send
operator|.
name|hdr
expr_stmt|;
name|tcode
operator|=
name|fp
operator|->
name|mode
operator|.
name|common
operator|.
name|tcode
expr_stmt|;
name|ohcifp
operator|=
operator|(
expr|struct
name|fwohci_txpkthdr
operator|*
operator|)
name|db_tr
operator|->
name|db
index|[
literal|1
index|]
operator|.
name|db
operator|.
name|immed
expr_stmt|;
name|info
operator|=
operator|&
name|tinfo
index|[
name|tcode
index|]
expr_stmt|;
name|hdr_len
operator|=
name|pl_off
operator|=
name|info
operator|->
name|hdr_len
expr_stmt|;
name|ld
operator|=
operator|&
name|ohcifp
operator|->
name|mode
operator|.
name|ld
index|[
literal|0
index|]
expr_stmt|;
name|ld
index|[
literal|0
index|]
operator|=
name|ld
index|[
literal|1
index|]
operator|=
name|ld
index|[
literal|2
index|]
operator|=
name|ld
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pl_off
condition|;
name|i
operator|+=
literal|4
control|)
name|ld
index|[
name|i
operator|/
literal|4
index|]
operator|=
name|fp
operator|->
name|mode
operator|.
name|ld
index|[
name|i
operator|/
literal|4
index|]
expr_stmt|;
name|ohcifp
operator|->
name|mode
operator|.
name|common
operator|.
name|spd
operator|=
name|xfer
operator|->
name|send
operator|.
name|spd
operator|&
literal|0x7
expr_stmt|;
if|if
condition|(
name|tcode
operator|==
name|FWTCODE_STREAM
condition|)
block|{
name|hdr_len
operator|=
literal|8
expr_stmt|;
name|ohcifp
operator|->
name|mode
operator|.
name|stream
operator|.
name|len
operator|=
name|fp
operator|->
name|mode
operator|.
name|stream
operator|.
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tcode
operator|==
name|FWTCODE_PHY
condition|)
block|{
name|hdr_len
operator|=
literal|12
expr_stmt|;
name|ld
index|[
literal|1
index|]
operator|=
name|fp
operator|->
name|mode
operator|.
name|ld
index|[
literal|1
index|]
expr_stmt|;
name|ld
index|[
literal|2
index|]
operator|=
name|fp
operator|->
name|mode
operator|.
name|ld
index|[
literal|2
index|]
expr_stmt|;
name|ohcifp
operator|->
name|mode
operator|.
name|common
operator|.
name|spd
operator|=
literal|0
expr_stmt|;
name|ohcifp
operator|->
name|mode
operator|.
name|common
operator|.
name|tcode
operator|=
name|FWOHCITCODE_PHY
expr_stmt|;
block|}
else|else
block|{
name|ohcifp
operator|->
name|mode
operator|.
name|asycomm
operator|.
name|dst
operator|=
name|fp
operator|->
name|mode
operator|.
name|hdr
operator|.
name|dst
expr_stmt|;
name|ohcifp
operator|->
name|mode
operator|.
name|asycomm
operator|.
name|srcbus
operator|=
name|OHCI_ASYSRCBUS
expr_stmt|;
name|ohcifp
operator|->
name|mode
operator|.
name|asycomm
operator|.
name|tlrt
operator||=
name|FWRETRY_X
expr_stmt|;
block|}
name|db
operator|=
operator|&
name|db_tr
operator|->
name|db
index|[
literal|0
index|]
expr_stmt|;
name|FWOHCI_DMA_WRITE
argument_list|(
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|cmd
argument_list|,
name|OHCI_OUTPUT_MORE
operator||
name|OHCI_KEY_ST2
operator||
name|hdr_len
argument_list|)
expr_stmt|;
name|FWOHCI_DMA_WRITE
argument_list|(
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FWOHCI_DMA_WRITE
argument_list|(
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Specify bound timer of asy. responce */
if|if
condition|(
operator|&
name|sc
operator|->
name|atrs
operator|==
name|dbch
condition|)
block|{
name|FWOHCI_DMA_WRITE
argument_list|(
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|res
argument_list|,
operator|(
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_CYCLETIMER
argument_list|)
operator|>>
literal|12
operator|)
operator|+
operator|(
literal|1
operator|<<
literal|13
operator|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
if|if
condition|(
name|tcode
operator|==
name|FWTCODE_WREQQ
operator|||
name|tcode
operator|==
name|FWTCODE_RRESQ
condition|)
name|hdr_len
operator|=
literal|12
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr_len
operator|/
literal|4
condition|;
name|i
operator|++
control|)
name|FWOHCI_DMA_WRITE
argument_list|(
name|ld
index|[
name|i
index|]
argument_list|,
name|ld
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|again
label|:
name|db_tr
operator|->
name|dbcnt
operator|=
literal|2
expr_stmt|;
name|db
operator|=
operator|&
name|db_tr
operator|->
name|db
index|[
name|db_tr
operator|->
name|dbcnt
index|]
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|send
operator|.
name|pay_len
operator|>
literal|0
condition|)
block|{
name|int
name|err
decl_stmt|;
comment|/* handle payload */
if|if
condition|(
name|xfer
operator|->
name|mbuf
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|bus_dmamap_load
argument_list|(
name|dbch
operator|->
name|dmat
argument_list|,
name|db_tr
operator|->
name|dma_map
argument_list|,
operator|&
name|xfer
operator|->
name|send
operator|.
name|payload
index|[
literal|0
index|]
argument_list|,
name|xfer
operator|->
name|send
operator|.
name|pay_len
argument_list|,
name|fwohci_execute_db
argument_list|,
name|db_tr
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX we can handle only 6 (=8-2) mbuf chains */
name|err
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|dbch
operator|->
name|dmat
argument_list|,
name|db_tr
operator|->
name|dma_map
argument_list|,
name|xfer
operator|->
name|mbuf
argument_list|,
name|fwohci_execute_db2
argument_list|,
name|db_tr
argument_list|,
comment|/* flags */
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EFBIG
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
if|if
condition|(
name|firewire_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"EFBIG.\n"
argument_list|)
expr_stmt|;
name|m0
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|!=
name|NULL
condition|)
block|{
name|m_copydata
argument_list|(
name|xfer
operator|->
name|mbuf
argument_list|,
literal|0
argument_list|,
name|xfer
operator|->
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|xfer
operator|->
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_freem
argument_list|(
name|xfer
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|mbuf
operator|=
name|m0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"m_getcl failed.\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
condition|)
name|printf
argument_list|(
literal|"dmamap_load: err=%d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|dbch
operator|->
name|dmat
argument_list|,
name|db_tr
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* OHCI_OUTPUT_MODE == 0 */
block|for (i = 2; i< db_tr->dbcnt; i++) 			FWOHCI_DMA_SET(db_tr->db[i].db.desc.cmd, 						OHCI_OUTPUT_MORE);
endif|#
directive|endif
block|}
if|if
condition|(
name|maxdesc
operator|<
name|db_tr
operator|->
name|dbcnt
condition|)
block|{
name|maxdesc
operator|=
name|db_tr
operator|->
name|dbcnt
expr_stmt|;
if|if
condition|(
name|firewire_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"maxdesc: %d\n"
argument_list|,
name|maxdesc
argument_list|)
expr_stmt|;
block|}
comment|/* last db */
name|LAST_DB
argument_list|(
name|db_tr
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|FWOHCI_DMA_SET
argument_list|(
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|cmd
argument_list|,
name|OHCI_OUTPUT_LAST
operator||
name|OHCI_INTERRUPT_ALWAYS
operator||
name|OHCI_BRANCH_ALWAYS
argument_list|)
expr_stmt|;
name|FWOHCI_DMA_WRITE
argument_list|(
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|depend
argument_list|,
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
operator|->
name|bus_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsegment
operator|==
operator|-
literal|1
condition|)
name|fsegment
operator|=
name|db_tr
operator|->
name|dbcnt
expr_stmt|;
if|if
condition|(
name|dbch
operator|->
name|pdb_tr
operator|!=
name|NULL
condition|)
block|{
name|LAST_DB
argument_list|(
name|dbch
operator|->
name|pdb_tr
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|FWOHCI_DMA_SET
argument_list|(
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|depend
argument_list|,
name|db_tr
operator|->
name|dbcnt
argument_list|)
expr_stmt|;
block|}
name|dbch
operator|->
name|pdb_tr
operator|=
name|db_tr
expr_stmt|;
name|db_tr
operator|=
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_tr
operator|!=
name|dbch
operator|->
name|bottom
condition|)
block|{
goto|goto
name|txloop
goto|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"fwohci_start: lack of db_trq\n"
argument_list|)
expr_stmt|;
name|dbch
operator|->
name|flags
operator||=
name|FWOHCI_DBCH_FULL
expr_stmt|;
block|}
name|kick
label|:
comment|/* kick asy q */
name|fwdma_sync_multiseg_all
argument_list|(
name|dbch
operator|->
name|am
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|fwdma_sync_multiseg_all
argument_list|(
name|dbch
operator|->
name|am
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_RUNNING
condition|)
block|{
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_DMACTL
argument_list|(
name|off
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_WAKE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|firewire_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"start AT DMA status=%x\n"
argument_list|,
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_DMACTL
argument_list|(
name|off
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_DMACMD
argument_list|(
name|off
argument_list|)
argument_list|,
name|dbch
operator|->
name|top
operator|->
name|bus_addr
operator||
name|fsegment
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_DMACTL
argument_list|(
name|off
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator||=
name|FWXFERQ_RUNNING
expr_stmt|;
block|}
name|dbch
operator|->
name|top
operator|=
name|db_tr
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_start_atq
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
decl_stmt|;
name|fwohci_start
argument_list|(
name|sc
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|atrq
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_start_ats
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
decl_stmt|;
name|fwohci_start
argument_list|(
name|sc
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|atrs
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|fwohci_txd
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|fwohci_dbch
modifier|*
name|dbch
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|ch
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|fwohcidb_tr
modifier|*
name|tr
decl_stmt|;
name|struct
name|fwohcidb
modifier|*
name|db
decl_stmt|;
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|uint32_t
name|off
decl_stmt|;
name|u_int
name|stat
decl_stmt|,
name|status
decl_stmt|;
name|int
name|packets
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
init|=
operator|(
expr|struct
name|firewire_comm
operator|*
operator|)
name|sc
decl_stmt|;
if|if
condition|(
operator|&
name|sc
operator|->
name|atrq
operator|==
name|dbch
condition|)
block|{
name|off
operator|=
name|OHCI_ATQOFF
expr_stmt|;
name|ch
operator|=
name|ATRQ_CH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|&
name|sc
operator|->
name|atrs
operator|==
name|dbch
condition|)
block|{
name|off
operator|=
name|OHCI_ATSOFF
expr_stmt|;
name|ch
operator|=
name|ATRS_CH
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|tr
operator|=
name|dbch
operator|->
name|bottom
expr_stmt|;
name|packets
operator|=
literal|0
expr_stmt|;
name|fwdma_sync_multiseg_all
argument_list|(
name|dbch
operator|->
name|am
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|fwdma_sync_multiseg_all
argument_list|(
name|dbch
operator|->
name|am
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
while|while
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|queued
operator|>
literal|0
condition|)
block|{
name|LAST_DB
argument_list|(
name|tr
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|status
operator|=
name|FWOHCI_DMA_READ
argument_list|(
name|db
operator|->
name|db
operator|.
name|desc
operator|.
name|res
argument_list|)
operator|>>
name|OHCI_STATUS_SHIFT
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|OHCI_CNTL_DMA_ACTIVE
operator|)
condition|)
block|{
if|if
condition|(
name|fc
operator|->
name|status
operator|!=
name|FWBUSRESET
condition|)
comment|/* maybe out of order?? */
goto|goto
name|out
goto|;
block|}
name|bus_dmamap_sync
argument_list|(
name|dbch
operator|->
name|dmat
argument_list|,
name|tr
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dbch
operator|->
name|dmat
argument_list|,
name|tr
operator|->
name|dma_map
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
name|firewire_debug
condition|)
name|dump_db
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|&
name|OHCI_CNTL_DMA_DEAD
condition|)
block|{
comment|/* Stop DMA */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_DMACTLCLR
argument_list|(
name|off
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"force reset AT FIFO\n"
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTLCLR
argument_list|,
name|OHCI_HCC_LINKEN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|,
name|OHCI_HCC_LPS
operator||
name|OHCI_HCC_LINKEN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_DMACTLCLR
argument_list|(
name|off
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
block|}
name|stat
operator|=
name|status
operator|&
name|FWOHCIEV_MASK
expr_stmt|;
switch|switch
condition|(
name|stat
condition|)
block|{
case|case
name|FWOHCIEV_ACKPEND
case|:
case|case
name|FWOHCIEV_ACKCOMPL
case|:
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FWOHCIEV_ACKBSA
case|:
case|case
name|FWOHCIEV_ACKBSB
case|:
case|case
name|FWOHCIEV_ACKBSX
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"txd err=%2x %s\n"
argument_list|,
name|stat
argument_list|,
name|fwohcicode
index|[
name|stat
index|]
argument_list|)
expr_stmt|;
name|err
operator|=
name|EBUSY
expr_stmt|;
break|break;
case|case
name|FWOHCIEV_FLUSHED
case|:
case|case
name|FWOHCIEV_ACKTARD
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"txd err=%2x %s\n"
argument_list|,
name|stat
argument_list|,
name|fwohcicode
index|[
name|stat
index|]
argument_list|)
expr_stmt|;
name|err
operator|=
name|EAGAIN
expr_stmt|;
break|break;
case|case
name|FWOHCIEV_MISSACK
case|:
case|case
name|FWOHCIEV_UNDRRUN
case|:
case|case
name|FWOHCIEV_OVRRUN
case|:
case|case
name|FWOHCIEV_DESCERR
case|:
case|case
name|FWOHCIEV_DTRDERR
case|:
case|case
name|FWOHCIEV_TIMEOUT
case|:
case|case
name|FWOHCIEV_TCODERR
case|:
case|case
name|FWOHCIEV_UNKNOWN
case|:
case|case
name|FWOHCIEV_ACKDERR
case|:
case|case
name|FWOHCIEV_ACKTERR
case|:
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"txd err=%2x %s\n"
argument_list|,
name|stat
argument_list|,
name|fwohcicode
index|[
name|stat
index|]
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tr
operator|->
name|xfer
operator|!=
name|NULL
condition|)
block|{
name|xfer
operator|=
name|tr
operator|->
name|xfer
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|state
operator|==
name|FWXF_RCVD
condition|)
block|{
if|#
directive|if
literal|0
block|if (firewire_debug) 					printf("already rcvd\n");
endif|#
directive|endif
name|fw_xfer_done
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xfer
operator|->
name|state
operator|=
name|FWXF_SENT
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EBUSY
operator|&&
name|fc
operator|->
name|status
operator|!=
name|FWBUSRESET
condition|)
block|{
name|xfer
operator|->
name|state
operator|=
name|FWXF_BUSY
expr_stmt|;
name|xfer
operator|->
name|resp
operator|=
name|err
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|retry_req
operator|!=
name|NULL
condition|)
name|xfer
operator|->
name|retry_req
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
else|else
block|{
name|xfer
operator|->
name|recv
operator|.
name|pay_len
operator|=
literal|0
expr_stmt|;
name|fw_xfer_done
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|stat
operator|!=
name|FWOHCIEV_ACKPEND
condition|)
block|{
if|if
condition|(
name|stat
operator|!=
name|FWOHCIEV_ACKCOMPL
condition|)
name|xfer
operator|->
name|state
operator|=
name|FWXF_SENTERR
expr_stmt|;
name|xfer
operator|->
name|resp
operator|=
name|err
expr_stmt|;
name|xfer
operator|->
name|recv
operator|.
name|pay_len
operator|=
literal|0
expr_stmt|;
name|fw_xfer_done
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * The watchdog timer takes care of split 			 * transcation timeout for ACKPEND case. 			 */
block|}
else|else
block|{
name|printf
argument_list|(
literal|"this shouldn't happen\n"
argument_list|)
expr_stmt|;
block|}
name|dbch
operator|->
name|xferq
operator|.
name|queued
operator|--
expr_stmt|;
name|tr
operator|->
name|xfer
operator|=
name|NULL
expr_stmt|;
name|packets
operator|++
expr_stmt|;
name|tr
operator|=
name|STAILQ_NEXT
argument_list|(
name|tr
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dbch
operator|->
name|bottom
operator|=
name|tr
expr_stmt|;
if|if
condition|(
name|dbch
operator|->
name|bottom
operator|==
name|dbch
operator|->
name|top
condition|)
block|{
comment|/* we reaches the end of context program */
if|if
condition|(
name|firewire_debug
operator|&&
name|dbch
operator|->
name|xferq
operator|.
name|queued
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"queued> 0\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|out
label|:
if|if
condition|(
operator|(
name|dbch
operator|->
name|flags
operator|&
name|FWOHCI_DBCH_FULL
operator|)
operator|&&
name|packets
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"make free slot\n"
argument_list|)
expr_stmt|;
name|dbch
operator|->
name|flags
operator|&=
operator|~
name|FWOHCI_DBCH_FULL
expr_stmt|;
name|fwohci_start
argument_list|(
name|sc
argument_list|,
name|dbch
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_db_free
parameter_list|(
name|struct
name|fwohci_dbch
modifier|*
name|dbch
parameter_list|)
block|{
name|struct
name|fwohcidb_tr
modifier|*
name|db_tr
decl_stmt|;
name|int
name|idb
decl_stmt|;
if|if
condition|(
operator|(
name|dbch
operator|->
name|flags
operator|&
name|FWOHCI_DBCH_INIT
operator|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|db_tr
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dbch
operator|->
name|db_trq
argument_list|)
operator|,
name|idb
operator|=
literal|0
init|;
name|idb
operator|<
name|dbch
operator|->
name|ndb
condition|;
name|db_tr
operator|=
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
operator|,
name|idb
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_EXTBUF
operator|)
operator|==
literal|0
operator|&&
name|db_tr
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|fwdma_free_size
argument_list|(
name|dbch
operator|->
name|dmat
argument_list|,
name|db_tr
operator|->
name|dma_map
argument_list|,
name|db_tr
operator|->
name|buf
argument_list|,
name|dbch
operator|->
name|xferq
operator|.
name|psize
argument_list|)
expr_stmt|;
name|db_tr
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|db_tr
operator|->
name|dma_map
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|dbch
operator|->
name|dmat
argument_list|,
name|db_tr
operator|->
name|dma_map
argument_list|)
expr_stmt|;
block|}
name|dbch
operator|->
name|ndb
operator|=
literal|0
expr_stmt|;
name|db_tr
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dbch
operator|->
name|db_trq
argument_list|)
expr_stmt|;
name|fwdma_free_multiseg
argument_list|(
name|dbch
operator|->
name|am
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|db_tr
argument_list|,
name|M_FW
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|dbch
operator|->
name|db_trq
argument_list|)
expr_stmt|;
name|dbch
operator|->
name|flags
operator|&=
operator|~
name|FWOHCI_DBCH_INIT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_db_init
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|fwohci_dbch
modifier|*
name|dbch
parameter_list|)
block|{
name|int
name|idb
decl_stmt|;
name|struct
name|fwohcidb_tr
modifier|*
name|db_tr
decl_stmt|;
if|if
condition|(
operator|(
name|dbch
operator|->
name|flags
operator|&
name|FWOHCI_DBCH_INIT
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* create dma_tag for buffers */
define|#
directive|define
name|MAX_REQCOUNT
value|0xffff
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|sc
operator|->
name|fc
operator|.
name|dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|dbch
operator|->
name|xferq
operator|.
name|psize
argument_list|,
comment|/*nsegments*/
name|dbch
operator|->
name|ndesc
operator|>
literal|3
condition|?
name|dbch
operator|->
name|ndesc
operator|-
literal|2
else|:
literal|1
argument_list|,
comment|/*maxsegsz*/
name|MAX_REQCOUNT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|501102
comment|/*lockfunc*/
name|busdma_lock_mutex
argument_list|,
comment|/*lockarg*/
operator|&
name|Giant
argument_list|,
endif|#
directive|endif
operator|&
name|dbch
operator|->
name|dmat
argument_list|)
condition|)
return|return;
comment|/* allocate DB entries and attach one to each DMA channels */
comment|/* DB entry must start at 16 bytes bounary. */
name|STAILQ_INIT
argument_list|(
operator|&
name|dbch
operator|->
name|db_trq
argument_list|)
expr_stmt|;
name|db_tr
operator|=
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fwohcidb_tr
argument_list|)
operator|*
name|dbch
operator|->
name|ndb
argument_list|,
name|M_FW
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_tr
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"fwohci_db_init: malloc(1) failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
define|#
directive|define
name|DB_SIZE
parameter_list|(
name|x
parameter_list|)
value|(sizeof(struct fwohcidb) * (x)->ndesc)
name|dbch
operator|->
name|am
operator|=
name|fwdma_malloc_multiseg
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|,
name|DB_SIZE
argument_list|(
name|dbch
argument_list|)
argument_list|,
name|DB_SIZE
argument_list|(
name|dbch
argument_list|)
argument_list|,
name|dbch
operator|->
name|ndb
argument_list|,
name|BUS_DMA_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbch
operator|->
name|am
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"fwohci_db_init: fwdma_malloc_multiseg failed\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|db_tr
argument_list|,
name|M_FW
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Attach DB to DMA ch. */
for|for
control|(
name|idb
operator|=
literal|0
init|;
name|idb
operator|<
name|dbch
operator|->
name|ndb
condition|;
name|idb
operator|++
control|)
block|{
name|db_tr
operator|->
name|dbcnt
operator|=
literal|0
expr_stmt|;
name|db_tr
operator|->
name|db
operator|=
operator|(
expr|struct
name|fwohcidb
operator|*
operator|)
name|fwdma_v_addr
argument_list|(
name|dbch
operator|->
name|am
argument_list|,
name|idb
argument_list|)
expr_stmt|;
name|db_tr
operator|->
name|bus_addr
operator|=
name|fwdma_bus_addr
argument_list|(
name|dbch
operator|->
name|am
argument_list|,
name|idb
argument_list|)
expr_stmt|;
comment|/* create dmamap for buffers */
comment|/* XXX do we need 4bytes alignment tag? */
comment|/* XXX don't alloc dma_map for AR */
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|dbch
operator|->
name|dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|db_tr
operator|->
name|dma_map
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"bus_dmamap_create failed\n"
argument_list|)
expr_stmt|;
name|dbch
operator|->
name|flags
operator|=
name|FWOHCI_DBCH_INIT
expr_stmt|;
comment|/* XXX fake */
name|fwohci_db_free
argument_list|(
name|dbch
argument_list|)
expr_stmt|;
return|return;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dbch
operator|->
name|db_trq
argument_list|,
name|db_tr
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_EXTBUF
condition|)
block|{
if|if
condition|(
name|idb
operator|%
name|dbch
operator|->
name|xferq
operator|.
name|bnpacket
operator|==
literal|0
condition|)
name|dbch
operator|->
name|xferq
operator|.
name|bulkxfer
index|[
name|idb
operator|/
name|dbch
operator|->
name|xferq
operator|.
name|bnpacket
index|]
operator|.
name|start
operator|=
operator|(
name|caddr_t
operator|)
name|db_tr
expr_stmt|;
if|if
condition|(
operator|(
name|idb
operator|+
literal|1
operator|)
operator|%
name|dbch
operator|->
name|xferq
operator|.
name|bnpacket
operator|==
literal|0
condition|)
name|dbch
operator|->
name|xferq
operator|.
name|bulkxfer
index|[
name|idb
operator|/
name|dbch
operator|->
name|xferq
operator|.
name|bnpacket
index|]
operator|.
name|end
operator|=
operator|(
name|caddr_t
operator|)
name|db_tr
expr_stmt|;
block|}
name|db_tr
operator|++
expr_stmt|;
block|}
name|STAILQ_LAST
argument_list|(
operator|&
name|dbch
operator|->
name|db_trq
argument_list|,
name|fwohcidb_tr
argument_list|,
name|link
argument_list|)
operator|->
name|link
operator|.
name|stqe_next
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dbch
operator|->
name|db_trq
argument_list|)
expr_stmt|;
name|out
label|:
name|dbch
operator|->
name|xferq
operator|.
name|queued
operator|=
literal|0
expr_stmt|;
name|dbch
operator|->
name|pdb_tr
operator|=
name|NULL
expr_stmt|;
name|dbch
operator|->
name|top
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dbch
operator|->
name|db_trq
argument_list|)
expr_stmt|;
name|dbch
operator|->
name|bottom
operator|=
name|dbch
operator|->
name|top
expr_stmt|;
name|dbch
operator|->
name|flags
operator|=
name|FWOHCI_DBCH_INIT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_itx_disable
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|int
name|dmach
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
decl_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ITCTLCLR
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
operator||
name|OHCI_CNTL_CYCMATCH_S
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_MASKCLR
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_STATCLR
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
comment|/* XXX we cannot free buffers until the DMA really stops */
name|pause
argument_list|(
literal|"fwitxd"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|fwohci_db_free
argument_list|(
operator|&
name|sc
operator|->
name|it
index|[
name|dmach
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|it
index|[
name|dmach
index|]
operator|.
name|xferq
operator|.
name|flag
operator|&=
operator|~
name|FWXFERQ_RUNNING
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_irx_disable
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|int
name|dmach
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
decl_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTLCLR
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_MASKCLR
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_STATCLR
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
comment|/* XXX we cannot free buffers until the DMA really stops */
name|pause
argument_list|(
literal|"fwirxd"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|fwohci_db_free
argument_list|(
operator|&
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|.
name|xferq
operator|.
name|flag
operator|&=
operator|~
name|FWXFERQ_RUNNING
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
end_if

begin_function
specifier|static
name|void
name|fwohci_irx_post
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|uint32_t
modifier|*
name|qld
parameter_list|)
block|{
name|qld
index|[
literal|0
index|]
operator|=
name|FWOHCI_DMA_READ
argument_list|(
name|qld
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|fwohci_tx_enable
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|fwohci_dbch
modifier|*
name|dbch
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|idb
decl_stmt|,
name|z
decl_stmt|,
name|i
decl_stmt|,
name|dmach
init|=
literal|0
decl_stmt|,
name|ldesc
decl_stmt|;
name|uint32_t
name|off
init|=
literal|0
decl_stmt|;
name|struct
name|fwohcidb_tr
modifier|*
name|db_tr
decl_stmt|;
name|struct
name|fwohcidb
modifier|*
name|db
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_EXTBUF
operator|)
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
return|return
name|err
return|;
block|}
name|z
operator|=
name|dbch
operator|->
name|ndesc
expr_stmt|;
for|for
control|(
name|dmach
operator|=
literal|0
init|;
name|dmach
operator|<
name|sc
operator|->
name|fc
operator|.
name|nisodma
condition|;
name|dmach
operator|++
control|)
block|{
if|if
condition|(
operator|&
name|sc
operator|->
name|it
index|[
name|dmach
index|]
operator|==
name|dbch
condition|)
block|{
name|off
operator|=
name|OHCI_ITOFF
argument_list|(
name|dmach
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|off
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_RUNNING
condition|)
return|return
name|err
return|;
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator||=
name|FWXFERQ_RUNNING
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|dbch
operator|->
name|bottom
operator|=
name|dbch
operator|->
name|top
init|;
name|i
operator|<
operator|(
name|dbch
operator|->
name|ndb
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|dbch
operator|->
name|bottom
operator|=
name|STAILQ_NEXT
argument_list|(
name|dbch
operator|->
name|bottom
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|db_tr
operator|=
name|dbch
operator|->
name|top
expr_stmt|;
for|for
control|(
name|idb
operator|=
literal|0
init|;
name|idb
operator|<
name|dbch
operator|->
name|ndb
condition|;
name|idb
operator|++
control|)
block|{
name|fwohci_add_tx_buf
argument_list|(
name|dbch
argument_list|,
name|db_tr
argument_list|,
name|idb
argument_list|)
expr_stmt|;
if|if
condition|(
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|db
operator|=
name|db_tr
operator|->
name|db
expr_stmt|;
name|ldesc
operator|=
name|db_tr
operator|->
name|dbcnt
operator|-
literal|1
expr_stmt|;
name|FWOHCI_DMA_WRITE
argument_list|(
name|db
index|[
literal|0
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
argument_list|,
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
operator|->
name|bus_addr
operator||
name|z
argument_list|)
expr_stmt|;
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
operator|=
name|db
index|[
literal|0
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
expr_stmt|;
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_EXTBUF
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|idb
operator|+
literal|1
operator|)
operator|%
name|dbch
operator|->
name|xferq
operator|.
name|bnpacket
operator|)
operator|==
literal|0
condition|)
block|{
name|FWOHCI_DMA_SET
argument_list|(
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|cmd
argument_list|,
name|OHCI_INTERRUPT_ALWAYS
argument_list|)
expr_stmt|;
comment|/* OHCI 1.1 and above */
name|FWOHCI_DMA_SET
argument_list|(
name|db
index|[
literal|0
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|cmd
argument_list|,
name|OHCI_INTERRUPT_ALWAYS
argument_list|)
expr_stmt|;
block|}
block|}
name|db_tr
operator|=
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|FWOHCI_DMA_CLEAR
argument_list|(
name|dbch
operator|->
name|bottom
operator|->
name|db
index|[
name|dbch
operator|->
name|bottom
operator|->
name|dbcnt
operator|-
literal|1
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
argument_list|,
literal|0xf
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_rx_enable
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|fwohci_dbch
modifier|*
name|dbch
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|idb
decl_stmt|,
name|z
decl_stmt|,
name|i
decl_stmt|,
name|dmach
init|=
literal|0
decl_stmt|,
name|ldesc
decl_stmt|;
name|uint32_t
name|off
init|=
literal|0
decl_stmt|;
name|struct
name|fwohcidb_tr
modifier|*
name|db_tr
decl_stmt|;
name|struct
name|fwohcidb
modifier|*
name|db
decl_stmt|;
name|z
operator|=
name|dbch
operator|->
name|ndesc
expr_stmt|;
if|if
condition|(
operator|&
name|sc
operator|->
name|arrq
operator|==
name|dbch
condition|)
block|{
name|off
operator|=
name|OHCI_ARQOFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|&
name|sc
operator|->
name|arrs
operator|==
name|dbch
condition|)
block|{
name|off
operator|=
name|OHCI_ARSOFF
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|dmach
operator|=
literal|0
init|;
name|dmach
operator|<
name|sc
operator|->
name|fc
operator|.
name|nisodma
condition|;
name|dmach
operator|++
control|)
block|{
if|if
condition|(
operator|&
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|==
name|dbch
condition|)
block|{
name|off
operator|=
name|OHCI_IROFF
argument_list|(
name|dmach
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|off
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_STREAM
condition|)
block|{
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_RUNNING
condition|)
return|return
name|err
return|;
block|}
else|else
block|{
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_RUNNING
condition|)
block|{
name|err
operator|=
name|EBUSY
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator||=
name|FWXFERQ_RUNNING
expr_stmt|;
name|dbch
operator|->
name|top
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dbch
operator|->
name|db_trq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|dbch
operator|->
name|bottom
operator|=
name|dbch
operator|->
name|top
init|;
name|i
operator|<
operator|(
name|dbch
operator|->
name|ndb
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|dbch
operator|->
name|bottom
operator|=
name|STAILQ_NEXT
argument_list|(
name|dbch
operator|->
name|bottom
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|db_tr
operator|=
name|dbch
operator|->
name|top
expr_stmt|;
for|for
control|(
name|idb
operator|=
literal|0
init|;
name|idb
operator|<
name|dbch
operator|->
name|ndb
condition|;
name|idb
operator|++
control|)
block|{
name|fwohci_add_rx_buf
argument_list|(
name|dbch
argument_list|,
name|db_tr
argument_list|,
name|idb
argument_list|,
operator|&
name|sc
operator|->
name|dummy_dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
operator|==
name|NULL
condition|)
break|break;
name|db
operator|=
name|db_tr
operator|->
name|db
expr_stmt|;
name|ldesc
operator|=
name|db_tr
operator|->
name|dbcnt
operator|-
literal|1
expr_stmt|;
name|FWOHCI_DMA_WRITE
argument_list|(
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
argument_list|,
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
operator|->
name|bus_addr
operator||
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_EXTBUF
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|idb
operator|+
literal|1
operator|)
operator|%
name|dbch
operator|->
name|xferq
operator|.
name|bnpacket
operator|)
operator|==
literal|0
condition|)
block|{
name|FWOHCI_DMA_SET
argument_list|(
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|cmd
argument_list|,
name|OHCI_INTERRUPT_ALWAYS
argument_list|)
expr_stmt|;
name|FWOHCI_DMA_CLEAR
argument_list|(
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
argument_list|,
literal|0xf
argument_list|)
expr_stmt|;
block|}
block|}
name|db_tr
operator|=
name|STAILQ_NEXT
argument_list|(
name|db_tr
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|FWOHCI_DMA_CLEAR
argument_list|(
name|dbch
operator|->
name|bottom
operator|->
name|db
index|[
name|db_tr
operator|->
name|dbcnt
operator|-
literal|1
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
argument_list|,
literal|0xf
argument_list|)
expr_stmt|;
name|dbch
operator|->
name|buf_offset
operator|=
literal|0
expr_stmt|;
name|fwdma_sync_multiseg_all
argument_list|(
name|dbch
operator|->
name|am
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|fwdma_sync_multiseg_all
argument_list|(
name|dbch
operator|->
name|am
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_STREAM
condition|)
block|{
return|return
name|err
return|;
block|}
else|else
block|{
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_DMACMD
argument_list|(
name|off
argument_list|)
argument_list|,
name|dbch
operator|->
name|top
operator|->
name|bus_addr
operator||
name|z
argument_list|)
expr_stmt|;
block|}
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_DMACTL
argument_list|(
name|off
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_next_cycle
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|int
name|cycle_now
parameter_list|)
block|{
name|int
name|sec
decl_stmt|,
name|cycle
decl_stmt|,
name|cycle_match
decl_stmt|;
name|cycle
operator|=
name|cycle_now
operator|&
literal|0x1fff
expr_stmt|;
name|sec
operator|=
name|cycle_now
operator|>>
literal|13
expr_stmt|;
define|#
directive|define
name|CYCLE_MOD
value|0x10
if|#
directive|if
literal|1
define|#
directive|define
name|CYCLE_DELAY
value|8
comment|/* min delay to start DMA */
else|#
directive|else
define|#
directive|define
name|CYCLE_DELAY
value|7000
comment|/* min delay to start DMA */
endif|#
directive|endif
name|cycle
operator|=
name|cycle
operator|+
name|CYCLE_DELAY
expr_stmt|;
if|if
condition|(
name|cycle
operator|>=
literal|8000
condition|)
block|{
name|sec
operator|++
expr_stmt|;
name|cycle
operator|-=
literal|8000
expr_stmt|;
block|}
name|cycle
operator|=
name|roundup2
argument_list|(
name|cycle
argument_list|,
name|CYCLE_MOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|cycle
operator|>=
literal|8000
condition|)
block|{
name|sec
operator|++
expr_stmt|;
if|if
condition|(
name|cycle
operator|==
literal|8000
condition|)
name|cycle
operator|=
literal|0
expr_stmt|;
else|else
name|cycle
operator|=
name|CYCLE_MOD
expr_stmt|;
block|}
name|cycle_match
operator|=
operator|(
operator|(
name|sec
operator|<<
literal|13
operator|)
operator||
name|cycle
operator|)
operator|&
literal|0x7ffff
expr_stmt|;
return|return
operator|(
name|cycle_match
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_itxbuf_enable
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|int
name|dmach
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|unsigned
name|short
name|tag
decl_stmt|,
name|ich
decl_stmt|;
name|struct
name|fwohci_dbch
modifier|*
name|dbch
decl_stmt|;
name|int
name|cycle_match
decl_stmt|,
name|cycle_now
decl_stmt|,
name|s
decl_stmt|,
name|ldesc
decl_stmt|;
name|uint32_t
name|stat
decl_stmt|;
name|struct
name|fw_bulkxfer
modifier|*
name|first
decl_stmt|,
modifier|*
name|chunk
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|it
decl_stmt|;
name|dbch
operator|=
operator|&
name|sc
operator|->
name|it
index|[
name|dmach
index|]
expr_stmt|;
name|it
operator|=
operator|&
name|dbch
operator|->
name|xferq
expr_stmt|;
name|tag
operator|=
operator|(
name|it
operator|->
name|flag
operator|>>
literal|6
operator|)
operator|&
literal|3
expr_stmt|;
name|ich
operator|=
name|it
operator|->
name|flag
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
operator|(
name|dbch
operator|->
name|flags
operator|&
name|FWOHCI_DBCH_INIT
operator|)
operator|==
literal|0
condition|)
block|{
name|dbch
operator|->
name|ndb
operator|=
name|it
operator|->
name|bnpacket
operator|*
name|it
operator|->
name|bnchunk
expr_stmt|;
name|dbch
operator|->
name|ndesc
operator|=
literal|3
expr_stmt|;
name|fwohci_db_init
argument_list|(
name|sc
argument_list|,
name|dbch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dbch
operator|->
name|flags
operator|&
name|FWOHCI_DBCH_INIT
operator|)
operator|==
literal|0
condition|)
return|return
name|ENOMEM
return|;
name|err
operator|=
name|fwohci_tx_enable
argument_list|(
name|sc
argument_list|,
name|dbch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|ldesc
operator|=
name|dbch
operator|->
name|ndesc
operator|-
literal|1
expr_stmt|;
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|prev
operator|=
name|STAILQ_LAST
argument_list|(
operator|&
name|it
operator|->
name|stdma
argument_list|,
name|fw_bulkxfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|chunk
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|it
operator|->
name|stvalid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|fwohcidb
modifier|*
name|db
decl_stmt|;
name|fwdma_sync_multiseg
argument_list|(
name|it
operator|->
name|buf
argument_list|,
name|chunk
operator|->
name|poffset
argument_list|,
name|it
operator|->
name|bnpacket
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|fwohci_txbufdb
argument_list|(
name|sc
argument_list|,
name|dmach
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|db
operator|=
operator|(
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
operator|(
name|prev
operator|->
name|end
operator|)
operator|)
operator|->
name|db
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX necessary? */
block|FWOHCI_DMA_SET(db[ldesc].db.desc.cmd, 						OHCI_BRANCH_ALWAYS);
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* if bulkxfer->npacket changes */
block|db[ldesc].db.desc.depend = db[0].db.desc.depend =  				((struct fwohcidb_tr *) 				(chunk->start))->bus_addr | dbch->ndesc;
else|#
directive|else
name|FWOHCI_DMA_SET
argument_list|(
name|db
index|[
literal|0
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
argument_list|,
name|dbch
operator|->
name|ndesc
argument_list|)
expr_stmt|;
name|FWOHCI_DMA_SET
argument_list|(
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
argument_list|,
name|dbch
operator|->
name|ndesc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|it
operator|->
name|stvalid
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|it
operator|->
name|stdma
argument_list|,
name|chunk
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|prev
operator|=
name|chunk
expr_stmt|;
block|}
name|fwdma_sync_multiseg_all
argument_list|(
name|dbch
operator|->
name|am
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|fwdma_sync_multiseg_all
argument_list|(
name|dbch
operator|->
name|am
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|stat
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_ITCTL
argument_list|(
name|dmach
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|firewire_debug
operator|&&
operator|(
name|stat
operator|&
name|OHCI_CNTL_CYCMATCH_S
operator|)
condition|)
name|printf
argument_list|(
literal|"stat 0x%x\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
operator|(
name|OHCI_CNTL_DMA_ACTIVE
operator||
name|OHCI_CNTL_CYCMATCH_S
operator|)
condition|)
return|return
literal|0
return|;
if|#
directive|if
literal|0
block|OWRITE(sc, OHCI_ITCTLCLR(dmach), OHCI_CNTL_DMA_RUN);
endif|#
directive|endif
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_MASKCLR
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_STATCLR
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_MASK
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASK
argument_list|,
name|OHCI_INT_DMA_IT
argument_list|)
expr_stmt|;
name|first
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|it
operator|->
name|stdma
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ITCMD
argument_list|(
name|dmach
argument_list|)
argument_list|,
operator|(
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
operator|(
name|first
operator|->
name|start
operator|)
operator|)
operator|->
name|bus_addr
operator||
name|dbch
operator|->
name|ndesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|firewire_debug
condition|)
block|{
name|printf
argument_list|(
literal|"fwohci_itxbuf_enable: kick 0x%08x\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|dump_dma
argument_list|(
name|sc
argument_list|,
name|ITX_CH
operator|+
name|dmach
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_CNTL_DMA_RUN
operator|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|1
comment|/* Don't start until all chunks are buffered */
if|if
condition|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|it
operator|->
name|stfree
argument_list|)
operator|!=
name|NULL
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
if|#
directive|if
literal|1
comment|/* Clear cycle match counter bits */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ITCTLCLR
argument_list|(
name|dmach
argument_list|)
argument_list|,
literal|0xffff0000
argument_list|)
expr_stmt|;
comment|/* 2bit second + 13bit cycle */
name|cycle_now
operator|=
operator|(
name|fc
operator|->
name|cyctimer
argument_list|(
name|fc
argument_list|)
operator|>>
literal|12
operator|)
operator|&
literal|0x7fff
expr_stmt|;
name|cycle_match
operator|=
name|fwohci_next_cycle
argument_list|(
name|fc
argument_list|,
name|cycle_now
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ITCTL
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|OHCI_CNTL_CYCMATCH_S
operator||
operator|(
name|cycle_match
operator|<<
literal|16
operator|)
operator||
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
else|#
directive|else
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ITCTL
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|firewire_debug
condition|)
block|{
name|printf
argument_list|(
literal|"cycle_match: 0x%04x->0x%04x\n"
argument_list|,
name|cycle_now
argument_list|,
name|cycle_match
argument_list|)
expr_stmt|;
name|dump_dma
argument_list|(
name|sc
argument_list|,
name|ITX_CH
operator|+
name|dmach
argument_list|)
expr_stmt|;
name|dump_db
argument_list|(
name|sc
argument_list|,
name|ITX_CH
operator|+
name|dmach
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_CNTL_CYCMATCH_S
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"IT DMA underrun (0x%08x)\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ITCTL
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_WAKE
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_irx_enable
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|int
name|dmach
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|s
decl_stmt|,
name|ldesc
decl_stmt|;
name|unsigned
name|short
name|tag
decl_stmt|,
name|ich
decl_stmt|;
name|uint32_t
name|stat
decl_stmt|;
name|struct
name|fwohci_dbch
modifier|*
name|dbch
decl_stmt|;
name|struct
name|fwohcidb_tr
modifier|*
name|db_tr
decl_stmt|;
name|struct
name|fw_bulkxfer
modifier|*
name|first
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|chunk
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|ir
decl_stmt|;
name|dbch
operator|=
operator|&
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
expr_stmt|;
name|ir
operator|=
operator|&
name|dbch
operator|->
name|xferq
expr_stmt|;
if|if
condition|(
operator|(
name|ir
operator|->
name|flag
operator|&
name|FWXFERQ_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|tag
operator|=
operator|(
name|ir
operator|->
name|flag
operator|>>
literal|6
operator|)
operator|&
literal|3
expr_stmt|;
name|ich
operator|=
name|ir
operator|->
name|flag
operator|&
literal|0x3f
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRMATCH
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|tagbit
index|[
name|tag
index|]
operator||
name|ich
argument_list|)
expr_stmt|;
name|ir
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
name|dbch
operator|->
name|ndb
operator|=
name|ir
operator|->
name|bnpacket
operator|*
name|ir
operator|->
name|bnchunk
expr_stmt|;
name|dbch
operator|->
name|ndesc
operator|=
literal|2
expr_stmt|;
name|fwohci_db_init
argument_list|(
name|sc
argument_list|,
name|dbch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dbch
operator|->
name|flags
operator|&
name|FWOHCI_DBCH_INIT
operator|)
operator|==
literal|0
condition|)
return|return
name|ENOMEM
return|;
name|err
operator|=
name|fwohci_rx_enable
argument_list|(
name|sc
argument_list|,
name|dbch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|first
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ir
operator|->
name|stfree
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"IR DMA no free chunk\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ldesc
operator|=
name|dbch
operator|->
name|ndesc
operator|-
literal|1
expr_stmt|;
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|prev
operator|=
name|STAILQ_LAST
argument_list|(
operator|&
name|ir
operator|->
name|stdma
argument_list|,
name|fw_bulkxfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|chunk
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ir
operator|->
name|stfree
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|fwohcidb
modifier|*
name|db
decl_stmt|;
if|#
directive|if
literal|1
comment|/* XXX for if_fwe */
if|if
condition|(
name|chunk
operator|->
name|mbuf
operator|!=
name|NULL
condition|)
block|{
name|db_tr
operator|=
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
operator|(
name|chunk
operator|->
name|start
operator|)
expr_stmt|;
name|db_tr
operator|->
name|dbcnt
operator|=
literal|1
expr_stmt|;
name|err
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|dbch
operator|->
name|dmat
argument_list|,
name|db_tr
operator|->
name|dma_map
argument_list|,
name|chunk
operator|->
name|mbuf
argument_list|,
name|fwohci_execute_db2
argument_list|,
name|db_tr
argument_list|,
comment|/* flags */
literal|0
argument_list|)
expr_stmt|;
name|FWOHCI_DMA_SET
argument_list|(
name|db_tr
operator|->
name|db
index|[
literal|1
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|cmd
argument_list|,
name|OHCI_UPDATE
operator||
name|OHCI_INPUT_LAST
operator||
name|OHCI_INTERRUPT_ALWAYS
operator||
name|OHCI_BRANCH_ALWAYS
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|db
operator|=
operator|(
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
operator|(
name|chunk
operator|->
name|end
operator|)
operator|)
operator|->
name|db
expr_stmt|;
name|FWOHCI_DMA_WRITE
argument_list|(
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FWOHCI_DMA_CLEAR
argument_list|(
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
argument_list|,
literal|0xf
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|db
operator|=
operator|(
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
operator|(
name|prev
operator|->
name|end
operator|)
operator|)
operator|->
name|db
expr_stmt|;
name|FWOHCI_DMA_SET
argument_list|(
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|depend
argument_list|,
name|dbch
operator|->
name|ndesc
argument_list|)
expr_stmt|;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ir
operator|->
name|stfree
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ir
operator|->
name|stdma
argument_list|,
name|chunk
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|prev
operator|=
name|chunk
expr_stmt|;
block|}
name|fwdma_sync_multiseg_all
argument_list|(
name|dbch
operator|->
name|am
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|fwdma_sync_multiseg_all
argument_list|(
name|dbch
operator|->
name|am
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|stat
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTL
argument_list|(
name|dmach
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|OHCI_CNTL_DMA_ACTIVE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|stat
operator|&
name|OHCI_CNTL_DMA_RUN
condition|)
block|{
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTLCLR
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"IR DMA overrun (0x%08x)\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|firewire_debug
condition|)
name|printf
argument_list|(
literal|"start IR DMA 0x%x\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_MASKCLR
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_STATCLR
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_MASK
argument_list|,
literal|1
operator|<<
name|dmach
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTLCLR
argument_list|(
name|dmach
argument_list|)
argument_list|,
literal|0xf0000000
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTL
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|OHCI_CNTL_ISOHDR
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCMD
argument_list|(
name|dmach
argument_list|)
argument_list|,
operator|(
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
operator|(
name|first
operator|->
name|start
operator|)
operator|)
operator|->
name|bus_addr
operator||
name|dbch
operator|->
name|ndesc
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTL
argument_list|(
name|dmach
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASK
argument_list|,
name|OHCI_INT_DMA_IR
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|dump_db(sc, IRX_CH + dmach);
endif|#
directive|endif
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|fwohci_stop
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
comment|/* Now stopping all DMA channel */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ARQCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ARSCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ATQCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ATSCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|fc
operator|.
name|nisodma
condition|;
name|i
operator|++
control|)
block|{
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IRCTLCLR
argument_list|(
name|i
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ITCTLCLR
argument_list|(
name|i
argument_list|)
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
block|}
comment|/* FLUSH FIFO and reset Transmitter/Reciever */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|,
name|OHCI_HCC_RESET
argument_list|)
expr_stmt|;
comment|/* Stop interrupt */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASKCLR
argument_list|,
name|OHCI_INT_EN
operator||
name|OHCI_INT_ERR
operator||
name|OHCI_INT_PHY_SID
operator||
name|OHCI_INT_PHY_INT
operator||
name|OHCI_INT_DMA_ATRQ
operator||
name|OHCI_INT_DMA_ATRS
operator||
name|OHCI_INT_DMA_PRRQ
operator||
name|OHCI_INT_DMA_PRRS
operator||
name|OHCI_INT_DMA_ARRQ
operator||
name|OHCI_INT_DMA_ARRS
operator||
name|OHCI_INT_PHY_BUS_R
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fc
operator|.
name|arq
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|fc
operator|.
name|arq
operator|->
name|maxq
operator|>
literal|0
condition|)
name|fw_drain_txq
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|)
expr_stmt|;
comment|/* XXX Link down?  Bus reset? */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fwohci_resume
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|ir
decl_stmt|;
name|struct
name|fw_bulkxfer
modifier|*
name|chunk
decl_stmt|;
name|fwohci_reset
argument_list|(
name|sc
argument_list|,
name|dev
argument_list|)
expr_stmt|;
comment|/* XXX resume isochronous receive automatically. (how about TX?) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|fc
operator|.
name|nisodma
condition|;
name|i
operator|++
control|)
block|{
name|ir
operator|=
operator|&
name|sc
operator|->
name|ir
index|[
name|i
index|]
operator|.
name|xferq
expr_stmt|;
if|if
condition|(
operator|(
name|ir
operator|->
name|flag
operator|&
name|FWXFERQ_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"resume iso receive ch: %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ir
operator|->
name|flag
operator|&=
operator|~
name|FWXFERQ_RUNNING
expr_stmt|;
comment|/* requeue stdma to stfree */
while|while
condition|(
operator|(
name|chunk
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ir
operator|->
name|stdma
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ir
operator|->
name|stdma
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ir
operator|->
name|stfree
argument_list|,
name|chunk
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|fc
operator|.
name|irx_enable
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|bus_generic_resume
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fc
operator|.
name|ibr
argument_list|(
operator|&
name|sc
operator|->
name|fc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ACK_ALL
end_define

begin_function
specifier|static
name|void
name|fwohci_intr_body
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|stat
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|uint32_t
name|irstat
decl_stmt|,
name|itstat
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
init|=
operator|(
expr|struct
name|firewire_comm
operator|*
operator|)
name|sc
decl_stmt|;
ifdef|#
directive|ifdef
name|OHCI_DEBUG
if|if
condition|(
name|stat
operator|&
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASK
argument_list|)
condition|)
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"INTERRUPT< %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s> 0x%08x, 0x%08x\n"
argument_list|,
name|stat
operator|&
name|OHCI_INT_EN
condition|?
literal|"DMA_EN "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_PHY_REG
condition|?
literal|"PHY_REG "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_CYC_LONG
condition|?
literal|"CYC_LONG "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_ERR
condition|?
literal|"INT_ERR "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_CYC_ERR
condition|?
literal|"CYC_ERR "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_CYC_LOST
condition|?
literal|"CYC_LOST "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_CYC_64SECOND
condition|?
literal|"CYC_64SECOND "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_CYC_START
condition|?
literal|"CYC_START "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_PHY_INT
condition|?
literal|"PHY_INT "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_PHY_BUS_R
condition|?
literal|"BUS_RESET "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_PHY_SID
condition|?
literal|"SID "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_LR_ERR
condition|?
literal|"DMA_LR_ERR "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_PW_ERR
condition|?
literal|"DMA_PW_ERR "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_IR
condition|?
literal|"DMA_IR "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_IT
condition|?
literal|"DMA_IT "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_PRRS
condition|?
literal|"DMA_PRRS "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_PRRQ
condition|?
literal|"DMA_PRRQ "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_ARRS
condition|?
literal|"DMA_ARRS "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_ARRQ
condition|?
literal|"DMA_ARRQ "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_ATRS
condition|?
literal|"DMA_ATRS "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_ATRQ
condition|?
literal|"DMA_ATRQ "
else|:
literal|""
argument_list|,
name|stat
argument_list|,
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASK
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Bus reset */
if|if
condition|(
name|stat
operator|&
name|OHCI_INT_PHY_BUS_R
condition|)
block|{
if|if
condition|(
name|fc
operator|->
name|status
operator|==
name|FWBUSRESET
condition|)
goto|goto
name|busresetout
goto|;
comment|/* Disable bus reset interrupt until sid recv. */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASKCLR
argument_list|,
name|OHCI_INT_PHY_BUS_R
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"BUS reset\n"
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASKCLR
argument_list|,
name|OHCI_INT_CYC_LOST
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_LNKCTLCLR
argument_list|,
name|OHCI_CNTL_CYCSRC
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ATQCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atrq
operator|.
name|xferq
operator|.
name|flag
operator|&=
operator|~
name|FWXFERQ_RUNNING
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ATSCTLCLR
argument_list|,
name|OHCI_CNTL_DMA_RUN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atrs
operator|.
name|xferq
operator|.
name|flag
operator|&=
operator|~
name|FWXFERQ_RUNNING
expr_stmt|;
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_PHY_BUS_R
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fw_busreset
argument_list|(
name|fc
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_CROMHDR
argument_list|,
name|ntohl
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|config_rom
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_BUS_OPT
argument_list|,
name|ntohl
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|config_rom
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|busresetout
label|:
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_DMA_IR
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_DMA_IR
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
name|irstat
operator|=
name|sc
operator|->
name|irstat
expr_stmt|;
name|sc
operator|->
name|irstat
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|irstat
operator|=
name|atomic_readandclear_int
argument_list|(
operator|&
name|sc
operator|->
name|irstat
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fc
operator|->
name|nisodma
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|fwohci_dbch
modifier|*
name|dbch
decl_stmt|;
if|if
condition|(
operator|(
name|irstat
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|dbch
operator|=
operator|&
name|sc
operator|->
name|ir
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|dbch
operator|->
name|xferq
operator|.
name|flag
operator|&
name|FWXFERQ_OPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"dma(%d) not active\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fwohci_rbuf_update
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_DMA_IT
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_DMA_IT
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
name|itstat
operator|=
name|sc
operator|->
name|itstat
expr_stmt|;
name|sc
operator|->
name|itstat
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|itstat
operator|=
name|atomic_readandclear_int
argument_list|(
operator|&
name|sc
operator|->
name|itstat
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fc
operator|->
name|nisodma
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|itstat
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fwohci_tbuf_update
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_DMA_PRRS
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_DMA_PRRS
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|dump_dma(sc, ARRS_CH); 		dump_db(sc, ARRS_CH);
endif|#
directive|endif
name|fwohci_arcv
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|arrs
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_DMA_PRRQ
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_DMA_PRRQ
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|dump_dma(sc, ARRQ_CH); 		dump_db(sc, ARRQ_CH);
endif|#
directive|endif
name|fwohci_arcv
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|arrq
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|OHCI_INT_PHY_SID
condition|)
block|{
name|uint32_t
modifier|*
name|buf
decl_stmt|,
name|node_id
decl_stmt|;
name|int
name|plen
decl_stmt|;
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_PHY_SID
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Enable bus reset interrupt */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASK
argument_list|,
name|OHCI_INT_PHY_BUS_R
argument_list|)
expr_stmt|;
comment|/* Allow async. request to us */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_AREQHI
argument_list|,
literal|1
operator|<<
literal|31
argument_list|)
expr_stmt|;
comment|/* XXX insecure ?? */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_PREQHI
argument_list|,
literal|0x7fffffff
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_PREQLO
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_PREQUPPER
argument_list|,
literal|0x10000
argument_list|)
expr_stmt|;
comment|/* Set ATRetries register */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ATRETRY
argument_list|,
literal|1
operator|<<
operator|(
literal|13
operator|+
literal|16
operator|)
operator||
literal|0xfff
argument_list|)
expr_stmt|;
comment|/* ** Checking whether the node is root or not. If root, turn on  ** cycle master. */
name|node_id
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCI_NODEID
argument_list|)
expr_stmt|;
name|plen
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_SID_CNT
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"node_id=0x%08x, gen=%d, "
argument_list|,
name|node_id
argument_list|,
operator|(
name|plen
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|node_id
operator|&
name|OHCI_NODE_VALID
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Bus reset failure\n"
argument_list|)
expr_stmt|;
goto|goto
name|sidout
goto|;
block|}
if|if
condition|(
name|node_id
operator|&
name|OHCI_NODE_ROOT
condition|)
block|{
name|printf
argument_list|(
literal|"CYCLEMASTER mode\n"
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_LNKCTL
argument_list|,
name|OHCI_CNTL_CYCMTR
operator||
name|OHCI_CNTL_CYCTIMER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"non CYCLEMASTER mode\n"
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_LNKCTLCLR
argument_list|,
name|OHCI_CNTL_CYCMTR
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_LNKCTL
argument_list|,
name|OHCI_CNTL_CYCTIMER
argument_list|)
expr_stmt|;
block|}
name|fc
operator|->
name|nodeid
operator|=
name|node_id
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|plen
operator|&
name|OHCI_SID_ERR
condition|)
block|{
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"SID Error\n"
argument_list|)
expr_stmt|;
goto|goto
name|sidout
goto|;
block|}
name|plen
operator|&=
name|OHCI_SID_CNT_MASK
expr_stmt|;
if|if
condition|(
name|plen
operator|<
literal|4
operator|||
name|plen
operator|>
name|OHCI_SIDSIZE
condition|)
block|{
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"invalid SID len = %d\n"
argument_list|,
name|plen
argument_list|)
expr_stmt|;
goto|goto
name|sidout
goto|;
block|}
name|plen
operator|-=
literal|4
expr_stmt|;
comment|/* chop control info */
name|buf
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|malloc
argument_list|(
name|OHCI_SIDSIZE
argument_list|,
name|M_FW
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"malloc failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|sidout
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|plen
operator|/
literal|4
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|FWOHCI_DMA_READ
argument_list|(
name|sc
operator|->
name|sid_buf
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* XXX needed?? */
comment|/* pending all pre-bus_reset packets */
name|fwohci_txd
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|atrq
argument_list|)
expr_stmt|;
name|fwohci_txd
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|atrs
argument_list|)
expr_stmt|;
name|fwohci_arcv
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|arrs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fwohci_arcv
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|arrq
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fw_drain_txq
argument_list|(
name|fc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fw_sidrcv
argument_list|(
name|fc
argument_list|,
name|buf
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_FW
argument_list|)
expr_stmt|;
block|}
name|sidout
label|:
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_DMA_ATRQ
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_DMA_ATRQ
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fwohci_txd
argument_list|(
name|sc
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|atrq
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_DMA_ATRS
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_DMA_ATRS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fwohci_txd
argument_list|(
name|sc
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|atrs
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_PW_ERR
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_PW_ERR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"posted write error\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_ERR
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_ERR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"unrecoverable error\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_PHY_INT
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|ACK_ALL
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_PHY_INT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"phy int\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|FWOHCI_TASKQUEUE
end_if

begin_function
specifier|static
name|void
name|fwohci_complete
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|uint32_t
name|stat
decl_stmt|;
name|again
label|:
name|stat
operator|=
name|atomic_readandclear_int
argument_list|(
operator|&
name|sc
operator|->
name|intstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
condition|)
name|fwohci_intr_body
argument_list|(
name|sc
argument_list|,
name|stat
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
return|return;
goto|goto
name|again
goto|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|uint32_t
name|fwochi_check_stat
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|stat
decl_stmt|,
name|irstat
decl_stmt|,
name|itstat
decl_stmt|;
name|stat
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0xffffffff
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"device physically ejected?\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|ACK_ALL
if|if
condition|(
name|stat
condition|)
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|stat
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stat
operator|&
name|OHCI_INT_DMA_IR
condition|)
block|{
name|irstat
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_STAT
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_STATCLR
argument_list|,
name|irstat
argument_list|)
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|sc
operator|->
name|irstat
argument_list|,
name|irstat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|OHCI_INT_DMA_IT
condition|)
block|{
name|itstat
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_STAT
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_STATCLR
argument_list|,
name|itstat
argument_list|)
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|sc
operator|->
name|itstat
argument_list|,
name|itstat
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|stat
operator|)
return|;
block|}
end_function

begin_function
name|void
name|fwohci_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|uint32_t
name|stat
decl_stmt|;
if|#
directive|if
operator|!
name|FWOHCI_TASKQUEUE
name|uint32_t
name|bus_reset
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|intmask
operator|&
name|OHCI_INT_EN
operator|)
condition|)
block|{
comment|/* polling mode */
return|return;
block|}
if|#
directive|if
operator|!
name|FWOHCI_TASKQUEUE
name|again
label|:
endif|#
directive|endif
name|stat
operator|=
name|fwochi_check_stat
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
operator|||
name|stat
operator|==
literal|0xffffffff
condition|)
return|return;
if|#
directive|if
name|FWOHCI_TASKQUEUE
name|atomic_set_int
argument_list|(
operator|&
name|sc
operator|->
name|intstat
argument_list|,
name|stat
argument_list|)
expr_stmt|;
comment|/* XXX mask bus reset intr. during bus reset phase */
if|if
condition|(
name|stat
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi_giant
argument_list|,
operator|&
name|sc
operator|->
name|fwohci_task_complete
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* We cannot clear bus reset event during bus reset phase */
if|if
condition|(
operator|(
name|stat
operator|&
operator|~
name|bus_reset
operator|)
operator|==
literal|0
condition|)
return|return;
name|bus_reset
operator|=
name|stat
operator|&
name|OHCI_INT_PHY_BUS_R
expr_stmt|;
name|fwohci_intr_body
argument_list|(
name|sc
argument_list|,
name|stat
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|fwohci_poll
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|int
name|quick
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|uint32_t
name|stat
decl_stmt|;
name|struct
name|fwohci_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
expr_stmt|;
name|stat
operator|=
name|OHCI_INT_DMA_IR
operator||
name|OHCI_INT_DMA_IT
operator||
name|OHCI_INT_DMA_PRRS
operator||
name|OHCI_INT_DMA_PRRQ
operator||
name|OHCI_INT_DMA_ATRQ
operator||
name|OHCI_INT_DMA_ATRS
expr_stmt|;
if|#
directive|if
literal|0
block|if (!quick) {
else|#
directive|else
if|if
condition|(
literal|1
condition|)
block|{
endif|#
directive|endif
name|stat
operator|=
name|fwochi_check_stat
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
operator|||
name|stat
operator|==
literal|0xffffffff
condition|)
return|return;
block|}
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|fwohci_intr_body
argument_list|(
name|sc
argument_list|,
name|stat
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_set_intr
parameter_list|(
name|struct
name|firewire_comm
modifier|*
name|fc
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|struct
name|fwohci_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|fwohci_softc
operator|*
operator|)
name|fc
expr_stmt|;
if|if
condition|(
name|firewire_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"fwohci_set_intr: %d\n"
argument_list|,
name|enable
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|sc
operator|->
name|intmask
operator||=
name|OHCI_INT_EN
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASK
argument_list|,
name|OHCI_INT_EN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|intmask
operator|&=
operator|~
name|OHCI_INT_EN
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASKCLR
argument_list|,
name|OHCI_INT_EN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_tbuf_update
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dmach
parameter_list|)
block|{
name|struct
name|firewire_comm
modifier|*
name|fc
init|=
operator|&
name|sc
operator|->
name|fc
decl_stmt|;
name|struct
name|fwohcidb
modifier|*
name|db
decl_stmt|;
name|struct
name|fw_bulkxfer
modifier|*
name|chunk
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|it
decl_stmt|;
name|uint32_t
name|stat
decl_stmt|,
name|count
decl_stmt|;
name|int
name|s
decl_stmt|,
name|w
init|=
literal|0
decl_stmt|,
name|ldesc
decl_stmt|;
name|it
operator|=
name|fc
operator|->
name|it
index|[
name|dmach
index|]
expr_stmt|;
name|ldesc
operator|=
name|sc
operator|->
name|it
index|[
name|dmach
index|]
operator|.
name|ndesc
operator|-
literal|1
expr_stmt|;
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
comment|/* unnecessary ? */
name|fwdma_sync_multiseg_all
argument_list|(
name|sc
operator|->
name|it
index|[
name|dmach
index|]
operator|.
name|am
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|firewire_debug
condition|)
name|dump_db
argument_list|(
name|sc
argument_list|,
name|ITX_CH
operator|+
name|dmach
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|chunk
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|it
operator|->
name|stdma
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|db
operator|=
operator|(
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
operator|(
name|chunk
operator|->
name|end
operator|)
operator|)
operator|->
name|db
expr_stmt|;
name|stat
operator|=
name|FWOHCI_DMA_READ
argument_list|(
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|res
argument_list|)
operator|>>
name|OHCI_STATUS_SHIFT
expr_stmt|;
name|db
operator|=
operator|(
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
operator|(
name|chunk
operator|->
name|start
operator|)
operator|)
operator|->
name|db
expr_stmt|;
comment|/* timestamp */
name|count
operator|=
name|FWOHCI_DMA_READ
argument_list|(
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|res
argument_list|)
operator|&
name|OHCI_COUNT_MASK
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
break|break;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|it
operator|->
name|stdma
argument_list|,
name|link
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|stat
operator|&
name|FWOHCIEV_MASK
condition|)
block|{
case|case
name|FWOHCIEV_ACKCOMPL
case|:
if|#
directive|if
literal|0
block|device_printf(fc->dev, "0x%08x\n", count);
endif|#
directive|endif
break|break;
default|default:
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"Isochronous transmit err %02x(%s)\n"
argument_list|,
name|stat
argument_list|,
name|fwohcicode
index|[
name|stat
operator|&
literal|0x1f
index|]
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|it
operator|->
name|stfree
argument_list|,
name|chunk
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|w
operator|++
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
condition|)
name|wakeup
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_rbuf_update
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dmach
parameter_list|)
block|{
name|struct
name|firewire_comm
modifier|*
name|fc
init|=
operator|&
name|sc
operator|->
name|fc
decl_stmt|;
name|struct
name|fwohcidb_tr
modifier|*
name|db_tr
decl_stmt|;
name|struct
name|fw_bulkxfer
modifier|*
name|chunk
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|ir
decl_stmt|;
name|uint32_t
name|stat
decl_stmt|;
name|int
name|s
decl_stmt|,
name|w
init|=
literal|0
decl_stmt|,
name|ldesc
decl_stmt|;
name|ir
operator|=
name|fc
operator|->
name|ir
index|[
name|dmach
index|]
expr_stmt|;
name|ldesc
operator|=
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|.
name|ndesc
operator|-
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|dump_db(sc, dmach);
endif|#
directive|endif
name|s
operator|=
name|splfw
argument_list|()
expr_stmt|;
name|fwdma_sync_multiseg_all
argument_list|(
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|.
name|am
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|chunk
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ir
operator|->
name|stdma
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|db_tr
operator|=
operator|(
expr|struct
name|fwohcidb_tr
operator|*
operator|)
name|chunk
operator|->
name|end
expr_stmt|;
name|stat
operator|=
name|FWOHCI_DMA_READ
argument_list|(
name|db_tr
operator|->
name|db
index|[
name|ldesc
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|res
argument_list|)
operator|>>
name|OHCI_STATUS_SHIFT
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|chunk
operator|->
name|mbuf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|.
name|dmat
argument_list|,
name|db_tr
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|ir
index|[
name|dmach
index|]
operator|.
name|dmat
argument_list|,
name|db_tr
operator|->
name|dma_map
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ir
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|fwdma_sync_multiseg
argument_list|(
name|ir
operator|->
name|buf
argument_list|,
name|chunk
operator|->
name|poffset
argument_list|,
name|ir
operator|->
name|bnpacket
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX */
name|printf
argument_list|(
literal|"fwohci_rbuf_update: this shouldn't happend\n"
argument_list|)
expr_stmt|;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ir
operator|->
name|stdma
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ir
operator|->
name|stvalid
argument_list|,
name|chunk
argument_list|,
name|link
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|stat
operator|&
name|FWOHCIEV_MASK
condition|)
block|{
case|case
name|FWOHCIEV_ACKCOMPL
case|:
name|chunk
operator|->
name|resp
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|chunk
operator|->
name|resp
operator|=
name|EINVAL
expr_stmt|;
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"Isochronous receive err %02x(%s)\n"
argument_list|,
name|stat
argument_list|,
name|fwohcicode
index|[
name|stat
operator|&
literal|0x1f
index|]
argument_list|)
expr_stmt|;
block|}
name|w
operator|++
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
condition|)
block|{
if|if
condition|(
name|ir
operator|->
name|flag
operator|&
name|FWXFERQ_HANDLER
condition|)
name|ir
operator|->
name|hand
argument_list|(
name|ir
argument_list|)
expr_stmt|;
else|else
name|wakeup
argument_list|(
name|ir
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dump_dma
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|ch
parameter_list|)
block|{
name|uint32_t
name|off
decl_stmt|,
name|cntl
decl_stmt|,
name|stat
decl_stmt|,
name|cmd
decl_stmt|,
name|match
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|0
condition|)
block|{
name|off
operator|=
name|OHCI_ATQOFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|1
condition|)
block|{
name|off
operator|=
name|OHCI_ATSOFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|2
condition|)
block|{
name|off
operator|=
name|OHCI_ARQOFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|3
condition|)
block|{
name|off
operator|=
name|OHCI_ARSOFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
name|IRX_CH
condition|)
block|{
name|off
operator|=
name|OHCI_ITCTL
argument_list|(
name|ch
operator|-
name|ITX_CH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|off
operator|=
name|OHCI_IRCTL
argument_list|(
name|ch
operator|-
name|IRX_CH
argument_list|)
expr_stmt|;
block|}
name|cntl
operator|=
name|stat
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|off
operator|+
literal|0xc
argument_list|)
expr_stmt|;
name|match
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|off
operator|+
literal|0x10
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"ch %1x cntl:0x%08x cmd:0x%08x match:0x%08x\n"
argument_list|,
name|ch
argument_list|,
name|cntl
argument_list|,
name|cmd
argument_list|,
name|match
argument_list|)
expr_stmt|;
name|stat
operator|&=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|stat
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"dma %d ch:%s%s%s%s%s%s %s(%x)\n"
argument_list|,
name|ch
argument_list|,
name|stat
operator|&
name|OHCI_CNTL_DMA_RUN
condition|?
literal|"RUN,"
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_CNTL_DMA_WAKE
condition|?
literal|"WAKE,"
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_CNTL_DMA_DEAD
condition|?
literal|"DEAD,"
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_CNTL_DMA_ACTIVE
condition|?
literal|"ACTIVE,"
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_CNTL_DMA_BT
condition|?
literal|"BRANCH,"
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_CNTL_DMA_BAD
condition|?
literal|"BADDMA,"
else|:
literal|""
argument_list|,
name|fwohcicode
index|[
name|stat
operator|&
literal|0x1f
index|]
argument_list|,
name|stat
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"dma %d ch: Nostat\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dump_db
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|ch
parameter_list|)
block|{
name|struct
name|fwohci_dbch
modifier|*
name|dbch
decl_stmt|;
name|struct
name|fwohcidb_tr
modifier|*
name|cp
init|=
name|NULL
decl_stmt|,
modifier|*
name|pp
decl_stmt|,
modifier|*
name|np
init|=
name|NULL
decl_stmt|;
name|struct
name|fwohcidb
modifier|*
name|curr
init|=
name|NULL
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
init|=
name|NULL
decl_stmt|;
name|int
name|idb
decl_stmt|,
name|jdb
decl_stmt|;
name|uint32_t
name|cmd
decl_stmt|,
name|off
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|0
condition|)
block|{
name|off
operator|=
name|OHCI_ATQOFF
expr_stmt|;
name|dbch
operator|=
operator|&
name|sc
operator|->
name|atrq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|1
condition|)
block|{
name|off
operator|=
name|OHCI_ATSOFF
expr_stmt|;
name|dbch
operator|=
operator|&
name|sc
operator|->
name|atrs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|2
condition|)
block|{
name|off
operator|=
name|OHCI_ARQOFF
expr_stmt|;
name|dbch
operator|=
operator|&
name|sc
operator|->
name|arrq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|3
condition|)
block|{
name|off
operator|=
name|OHCI_ARSOFF
expr_stmt|;
name|dbch
operator|=
operator|&
name|sc
operator|->
name|arrs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
name|IRX_CH
condition|)
block|{
name|off
operator|=
name|OHCI_ITCTL
argument_list|(
name|ch
operator|-
name|ITX_CH
argument_list|)
expr_stmt|;
name|dbch
operator|=
operator|&
name|sc
operator|->
name|it
index|[
name|ch
operator|-
name|ITX_CH
index|]
expr_stmt|;
block|}
else|else
block|{
name|off
operator|=
name|OHCI_IRCTL
argument_list|(
name|ch
operator|-
name|IRX_CH
argument_list|)
expr_stmt|;
name|dbch
operator|=
operator|&
name|sc
operator|->
name|ir
index|[
name|ch
operator|-
name|IRX_CH
index|]
expr_stmt|;
block|}
name|cmd
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|off
operator|+
literal|0xc
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbch
operator|->
name|ndb
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"No DB is attached ch=%d\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|=
name|dbch
operator|->
name|top
expr_stmt|;
name|prev
operator|=
name|pp
operator|->
name|db
expr_stmt|;
for|for
control|(
name|idb
operator|=
literal|0
init|;
name|idb
operator|<
name|dbch
operator|->
name|ndb
condition|;
name|idb
operator|++
control|)
block|{
name|cp
operator|=
name|STAILQ_NEXT
argument_list|(
name|pp
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|curr
operator|=
name|NULL
expr_stmt|;
goto|goto
name|outdb
goto|;
block|}
name|np
operator|=
name|STAILQ_NEXT
argument_list|(
name|cp
argument_list|,
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|jdb
operator|=
literal|0
init|;
name|jdb
operator|<
name|dbch
operator|->
name|ndesc
condition|;
name|jdb
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cmd
operator|&
literal|0xfffffff0
operator|)
operator|==
name|cp
operator|->
name|bus_addr
condition|)
block|{
name|curr
operator|=
name|cp
operator|->
name|db
expr_stmt|;
if|if
condition|(
name|np
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|np
operator|->
name|db
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|NULL
expr_stmt|;
block|}
goto|goto
name|outdb
goto|;
block|}
block|}
name|pp
operator|=
name|STAILQ_NEXT
argument_list|(
name|pp
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
block|{
name|curr
operator|=
name|NULL
expr_stmt|;
goto|goto
name|outdb
goto|;
block|}
name|prev
operator|=
name|pp
operator|->
name|db
expr_stmt|;
block|}
name|outdb
label|:
if|if
condition|(
name|curr
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
literal|0
block|printf("Prev DB %d\n", ch); 		print_db(pp, prev, ch, dbch->ndesc);
endif|#
directive|endif
name|printf
argument_list|(
literal|"Current DB %d\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|print_db
argument_list|(
name|cp
argument_list|,
name|curr
argument_list|,
name|ch
argument_list|,
name|dbch
operator|->
name|ndesc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("Next DB %d\n", ch); 		print_db(np, next, ch, dbch->ndesc);
endif|#
directive|endif
block|}
else|else
block|{
name|printf
argument_list|(
literal|"dbdump err ch = %d cmd = 0x%08x\n"
argument_list|,
name|ch
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|print_db
parameter_list|(
name|struct
name|fwohcidb_tr
modifier|*
name|db_tr
parameter_list|,
name|struct
name|fwohcidb
modifier|*
name|db
parameter_list|,
name|uint32_t
name|ch
parameter_list|,
name|uint32_t
name|max
parameter_list|)
block|{
name|fwohcireg_t
name|stat
decl_stmt|;
name|int
name|i
decl_stmt|,
name|key
decl_stmt|;
name|uint32_t
name|cmd
decl_stmt|,
name|res
decl_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"No Descriptor is found\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"ch = %d\n%8s %s %s %s %s %4s %8s %8s %4s:%4s\n"
argument_list|,
name|ch
argument_list|,
literal|"Current"
argument_list|,
literal|"OP  "
argument_list|,
literal|"KEY"
argument_list|,
literal|"INT"
argument_list|,
literal|"BR "
argument_list|,
literal|"len"
argument_list|,
literal|"Addr"
argument_list|,
literal|"Depend"
argument_list|,
literal|"Stat"
argument_list|,
literal|"Cnt"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
name|cmd
operator|=
name|FWOHCI_DMA_READ
argument_list|(
name|db
index|[
name|i
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|cmd
argument_list|)
expr_stmt|;
name|res
operator|=
name|FWOHCI_DMA_READ
argument_list|(
name|db
index|[
name|i
index|]
operator|.
name|db
operator|.
name|desc
operator|.
name|res
argument_list|)
expr_stmt|;
name|key
operator|=
name|cmd
operator|&
name|OHCI_KEY_MASK
expr_stmt|;
name|stat
operator|=
name|res
operator|>>
name|OHCI_STATUS_SHIFT
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
name|printf
argument_list|(
literal|"%08x %s %s %s %s %5d %08x %08x %04x:%04x"
argument_list|,
argument|db_tr->bus_addr
argument_list|,
else|#
directive|else
argument|printf(
literal|"%08jx %s %s %s %s %5d %08x %08x %04x:%04x"
argument|, 				(uintmax_t)db_tr->bus_addr,
endif|#
directive|endif
argument|dbcode[(cmd>>
literal|28
argument|)&
literal|0xf
argument|], 				dbkey[(cmd>>
literal|24
argument|)&
literal|0x7
argument|], 				dbcond[(cmd>>
literal|20
argument|)&
literal|0x3
argument|], 				dbcond[(cmd>>
literal|18
argument|)&
literal|0x3
argument|], 				cmd& OHCI_COUNT_MASK, 				FWOHCI_DMA_READ(db[i].db.desc.addr), 				FWOHCI_DMA_READ(db[i].db.desc.depend), 				stat, 				res& OHCI_COUNT_MASK); 		if(stat&
literal|0xff00
argument|){ 			printf(
literal|" %s%s%s%s%s%s %s(%x)\n"
argument|, 				stat& OHCI_CNTL_DMA_RUN ?
literal|"RUN,"
argument|:
literal|""
argument|, 				stat& OHCI_CNTL_DMA_WAKE ?
literal|"WAKE,"
argument|:
literal|""
argument|, 				stat& OHCI_CNTL_DMA_DEAD ?
literal|"DEAD,"
argument|:
literal|""
argument|, 				stat& OHCI_CNTL_DMA_ACTIVE ?
literal|"ACTIVE,"
argument|:
literal|""
argument|, 				stat& OHCI_CNTL_DMA_BT ?
literal|"BRANCH,"
argument|:
literal|""
argument|, 				stat& OHCI_CNTL_DMA_BAD ?
literal|"BADDMA,"
argument|:
literal|""
argument|, 				fwohcicode[stat&
literal|0x1f
argument|], 				stat&
literal|0x1f
argument|); 		}else{ 			printf(
literal|" Nostat\n"
argument|); 		} 		if(key == OHCI_KEY_ST2 ){ 			printf(
literal|"0x%08x 0x%08x 0x%08x 0x%08x\n"
argument|,  				FWOHCI_DMA_READ(db[i+
literal|1
argument|].db.immed[
literal|0
argument|]), 				FWOHCI_DMA_READ(db[i+
literal|1
argument|].db.immed[
literal|1
argument|]), 				FWOHCI_DMA_READ(db[i+
literal|1
argument|].db.immed[
literal|2
argument|]), 				FWOHCI_DMA_READ(db[i+
literal|1
argument|].db.immed[
literal|3
argument|])); 		} 		if(key == OHCI_KEY_DEVICE){ 			return; 		} 		if((cmd& OHCI_BRANCH_MASK)  				== OHCI_BRANCH_ALWAYS){ 			return; 		} 		if((cmd& OHCI_CMD_MASK)  				== OHCI_OUTPUT_LAST){ 			return; 		} 		if((cmd& OHCI_CMD_MASK)  				== OHCI_INPUT_LAST){ 			return; 		} 		if(key == OHCI_KEY_ST2 ){ 			i++; 		} 	} 	return; }  void fwohci_ibr(struct firewire_comm *fc) { 	struct fwohci_softc *sc; 	uint32_t fun;  	device_printf(fc->dev,
literal|"Initiate bus reset\n"
argument|); 	sc = (struct fwohci_softc *)fc;
comment|/* 	 * Make sure our cached values from the config rom are 	 * initialised. 	 */
argument|OWRITE(sc, OHCI_CROMHDR, ntohl(sc->fc.config_rom[
literal|0
argument|])); 	OWRITE(sc, OHCI_BUS_OPT, ntohl(sc->fc.config_rom[
literal|2
argument|]));
comment|/* 	 * Set root hold-off bit so that non cyclemaster capable node 	 * shouldn't became the root node. 	 */
if|#
directive|if
literal|1
argument|fun = fwphy_rddata(sc, FW_PHY_IBR_REG); 	fun |= FW_PHY_IBR | FW_PHY_RHB; 	fun = fwphy_wrdata(sc, FW_PHY_IBR_REG, fun);
else|#
directive|else
comment|/* Short bus reset */
argument|fun = fwphy_rddata(sc, FW_PHY_ISBR_REG); 	fun |= FW_PHY_ISBR | FW_PHY_RHB; 	fun = fwphy_wrdata(sc, FW_PHY_ISBR_REG, fun);
endif|#
directive|endif
argument|}  void fwohci_txbufdb(struct fwohci_softc *sc, int dmach, struct fw_bulkxfer *bulkxfer) { 	struct fwohcidb_tr *db_tr
argument_list|,
argument|*fdb_tr; 	struct fwohci_dbch *dbch; 	struct fwohcidb *db; 	struct fw_pkt *fp; 	struct fwohci_txpkthdr *ohcifp; 	unsigned short chtag; 	int idb;  	dbch =&sc->it[dmach]; 	chtag = sc->it[dmach].xferq.flag&
literal|0xff
argument|;  	db_tr = (struct fwohcidb_tr *)(bulkxfer->start); 	fdb_tr = (struct fwohcidb_tr *)(bulkxfer->end);
comment|/* device_printf(sc->fc.dev, "DB %08x %08x %08x\n", bulkxfer, db_tr->bus_addr, fdb_tr->bus_addr); */
argument|for (idb =
literal|0
argument|; idb< dbch->xferq.bnpacket; idb ++) { 		db = db_tr->db; 		fp = (struct fw_pkt *)db_tr->buf; 		ohcifp = (struct fwohci_txpkthdr *) db[
literal|1
argument|].db.immed; 		ohcifp->mode.ld[
literal|0
argument|] = fp->mode.ld[
literal|0
argument|]; 		ohcifp->mode.common.spd =
literal|0
argument|&
literal|0x7
argument|; 		ohcifp->mode.stream.len = fp->mode.stream.len; 		ohcifp->mode.stream.chtag = chtag; 		ohcifp->mode.stream.tcode =
literal|0xa
argument|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
argument|FWOHCI_DMA_WRITE(db[
literal|1
argument|].db.immed[
literal|0
argument|], db[
literal|1
argument|].db.immed[
literal|0
argument|]);  		FWOHCI_DMA_WRITE(db[
literal|1
argument|].db.immed[
literal|1
argument|], db[
literal|1
argument|].db.immed[
literal|1
argument|]);
endif|#
directive|endif
argument|FWOHCI_DMA_CLEAR(db[
literal|2
argument|].db.desc.cmd, OHCI_COUNT_MASK); 		FWOHCI_DMA_SET(db[
literal|2
argument|].db.desc.cmd, fp->mode.stream.len); 		FWOHCI_DMA_WRITE(db[
literal|2
argument|].db.desc.res,
literal|0
argument|);
if|#
directive|if
literal|0
comment|/* if bulkxfer->npackets changes */
argument|db[2].db.desc.cmd = OHCI_OUTPUT_LAST 			| OHCI_UPDATE 			| OHCI_BRANCH_ALWAYS; 		db[0].db.desc.depend = 			= db[dbch->ndesc - 1].db.desc.depend 			= STAILQ_NEXT(db_tr, link)->bus_addr | dbch->ndesc;
else|#
directive|else
argument|FWOHCI_DMA_SET(db[
literal|0
argument|].db.desc.depend, dbch->ndesc); 		FWOHCI_DMA_SET(db[dbch->ndesc -
literal|1
argument|].db.desc.depend, dbch->ndesc);
endif|#
directive|endif
argument|bulkxfer->end = (caddr_t)db_tr; 		db_tr = STAILQ_NEXT(db_tr, link); 	} 	db = ((struct fwohcidb_tr *)bulkxfer->end)->db; 	FWOHCI_DMA_CLEAR(db[
literal|0
argument|].db.desc.depend,
literal|0xf
argument|); 	FWOHCI_DMA_CLEAR(db[dbch->ndesc -
literal|1
argument|].db.desc.depend,
literal|0xf
argument|);
if|#
directive|if
literal|0
comment|/* if bulkxfer->npackets changes */
argument|db[dbch->ndesc - 1].db.desc.control |= OHCI_INTERRUPT_ALWAYS;
comment|/* OHCI 1.1 and above */
argument|db[0].db.desc.control |= OHCI_INTERRUPT_ALWAYS;
endif|#
directive|endif
comment|/* 	db_tr = (struct fwohcidb_tr *)bulkxfer->start; 	fdb_tr = (struct fwohcidb_tr *)bulkxfer->end; device_printf(sc->fc.dev, "DB %08x %3d %08x %08x\n", bulkxfer, bulkxfer->npacket, db_tr->bus_addr, fdb_tr->bus_addr); */
argument|return; }  static int fwohci_add_tx_buf(struct fwohci_dbch *dbch, struct fwohcidb_tr *db_tr, 								int poffset) { 	struct fwohcidb *db = db_tr->db; 	struct fw_xferq *it; 	int err =
literal|0
argument|;  	it =&dbch->xferq; 	if(it->buf ==
literal|0
argument|){ 		err = EINVAL; 		return err; 	} 	db_tr->buf = fwdma_v_addr(it->buf, poffset); 	db_tr->dbcnt =
literal|3
argument|;  	FWOHCI_DMA_WRITE(db[
literal|0
argument|].db.desc.cmd, 		OHCI_OUTPUT_MORE | OHCI_KEY_ST2 |
literal|8
argument|); 	FWOHCI_DMA_WRITE(db[
literal|0
argument|].db.desc.addr,
literal|0
argument|); 	bzero((void *)&db[
literal|1
argument|].db.immed[
literal|0
argument|], sizeof(db[
literal|1
argument|].db.immed)); 	FWOHCI_DMA_WRITE(db[
literal|2
argument|].db.desc.addr, 	fwdma_bus_addr(it->buf, poffset) + sizeof(uint32_t));  	FWOHCI_DMA_WRITE(db[
literal|2
argument|].db.desc.cmd, 		OHCI_OUTPUT_LAST | OHCI_UPDATE | OHCI_BRANCH_ALWAYS);
if|#
directive|if
literal|1
argument|FWOHCI_DMA_WRITE(db[
literal|0
argument|].db.desc.res,
literal|0
argument|); 	FWOHCI_DMA_WRITE(db[
literal|2
argument|].db.desc.res,
literal|0
argument|);
endif|#
directive|endif
argument|return
literal|0
argument|; }  int fwohci_add_rx_buf(struct fwohci_dbch *dbch, struct fwohcidb_tr *db_tr, 		int poffset, struct fwdma_alloc *dummy_dma) { 	struct fwohcidb *db = db_tr->db; 	struct fw_xferq *ir; 	int i
argument_list|,
argument|ldesc; 	bus_addr_t dbuf[
literal|2
argument|]; 	int dsiz[
literal|2
argument|];  	ir =&dbch->xferq; 	if (ir->buf == NULL&& (dbch->xferq.flag& FWXFERQ_EXTBUF) ==
literal|0
argument|) { 		db_tr->buf = fwdma_malloc_size(dbch->dmat,&db_tr->dma_map, 			ir->psize,&dbuf[
literal|0
argument|], BUS_DMA_NOWAIT); 		if (db_tr->buf == NULL) 			return(ENOMEM); 		db_tr->dbcnt =
literal|1
argument|; 		dsiz[
literal|0
argument|] = ir->psize; 		bus_dmamap_sync(dbch->dmat, db_tr->dma_map, 			BUS_DMASYNC_PREREAD); 	} else { 		db_tr->dbcnt =
literal|0
argument|; 		if (dummy_dma != NULL) { 			dsiz[db_tr->dbcnt] = sizeof(uint32_t); 			dbuf[db_tr->dbcnt++] = dummy_dma->bus_addr; 		} 		dsiz[db_tr->dbcnt] = ir->psize; 		if (ir->buf != NULL) { 			db_tr->buf = fwdma_v_addr(ir->buf, poffset); 			dbuf[db_tr->dbcnt] = fwdma_bus_addr( ir->buf, poffset); 		} 		db_tr->dbcnt++; 	} 	for(i =
literal|0
argument|; i< db_tr->dbcnt ; i++){ 		FWOHCI_DMA_WRITE(db[i].db.desc.addr, dbuf[i]); 		FWOHCI_DMA_WRITE(db[i].db.desc.cmd, OHCI_INPUT_MORE | dsiz[i]); 		if (ir->flag& FWXFERQ_STREAM) { 			FWOHCI_DMA_SET(db[i].db.desc.cmd, OHCI_UPDATE); 		} 		FWOHCI_DMA_WRITE(db[i].db.desc.res, dsiz[i]); 	} 	ldesc = db_tr->dbcnt -
literal|1
argument|; 	if (ir->flag& FWXFERQ_STREAM) { 		FWOHCI_DMA_SET(db[ldesc].db.desc.cmd, OHCI_INPUT_LAST); 	} 	FWOHCI_DMA_SET(db[ldesc].db.desc.cmd, OHCI_BRANCH_ALWAYS); 	return
literal|0
argument|; }   static int fwohci_arcv_swap(struct fw_pkt *fp, int len) { 	struct fw_pkt *fp0; 	uint32_t ld0; 	int slen
argument_list|,
argument|hlen;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
argument|int i;
endif|#
directive|endif
argument|ld0 = FWOHCI_DMA_READ(fp->mode.ld[
literal|0
argument|]);
if|#
directive|if
literal|0
argument|printf("ld0: x%08x\n", ld0);
endif|#
directive|endif
argument|fp0 = (struct fw_pkt *)&ld0;
comment|/* determine length to swap */
argument|switch (fp0->mode.common.tcode) { 	case FWTCODE_RREQQ: 	case FWTCODE_WRES: 	case FWTCODE_WREQQ: 	case FWTCODE_RRESQ: 	case FWOHCITCODE_PHY: 		slen =
literal|12
argument|; 		break; 	case FWTCODE_RREQB: 	case FWTCODE_WREQB: 	case FWTCODE_LREQ: 	case FWTCODE_RRESB: 	case FWTCODE_LRES: 		slen =
literal|16
argument|; 		break; 	default: 		printf(
literal|"Unknown tcode %d\n"
argument|, fp0->mode.common.tcode); 		return(
literal|0
argument|); 	} 	hlen = tinfo[fp0->mode.common.tcode].hdr_len; 	if (hlen> len) { 		if (firewire_debug) 			printf(
literal|"splitted header\n"
argument|); 		return(-hlen); 	}
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
argument|for(i =
literal|0
argument|; i< slen/
literal|4
argument|; i ++) 		fp->mode.ld[i] = FWOHCI_DMA_READ(fp->mode.ld[i]);
endif|#
directive|endif
argument|return(hlen); }  static int fwohci_get_plen(struct fwohci_softc *sc, struct fwohci_dbch *dbch, struct fw_pkt *fp) { 	struct tcode_info *info; 	int r;  	info =&tinfo[fp->mode.common.tcode]; 	r = info->hdr_len + sizeof(uint32_t); 	if ((info->flag& FWTI_BLOCK_ASY) !=
literal|0
argument|) 		r += roundup2(fp->mode.wreqb.len, sizeof(uint32_t));  	if (r == sizeof(uint32_t))
comment|/* XXX */
argument|device_printf(sc->fc.dev,
literal|"Unknown tcode %d\n"
argument|, 						fp->mode.common.tcode);  	if (r> dbch->xferq.psize) { 		device_printf(sc->fc.dev,
literal|"Invalid packet length %d\n"
argument|, r);
comment|/* panic ? */
argument|}  	return r; }  static void fwohci_arcv_free_buf(struct fwohci_dbch *dbch, struct fwohcidb_tr *db_tr) { 	struct fwohcidb *db =&db_tr->db[
literal|0
argument|];  	FWOHCI_DMA_CLEAR(db->db.desc.depend,
literal|0xf
argument|); 	FWOHCI_DMA_WRITE(db->db.desc.res, dbch->xferq.psize); 	FWOHCI_DMA_SET(dbch->bottom->db[
literal|0
argument|].db.desc.depend,
literal|1
argument|); 	fwdma_sync_multiseg_all(dbch->am, BUS_DMASYNC_PREWRITE); 	dbch->bottom = db_tr; }  static void fwohci_arcv(struct fwohci_softc *sc, struct fwohci_dbch *dbch, int count) { 	struct fwohcidb_tr *db_tr; 	struct iovec vec[
literal|2
argument|]; 	struct fw_pkt pktbuf; 	int nvec; 	struct fw_pkt *fp; 	uint8_t *ld; 	uint32_t stat
argument_list|,
argument|off
argument_list|,
argument|status; 	u_int spd; 	int len
argument_list|,
argument|plen
argument_list|,
argument|hlen
argument_list|,
argument|pcnt
argument_list|,
argument|offset; 	int s; 	caddr_t buf; 	int resCount;  	if(&sc->arrq == dbch){ 		off = OHCI_ARQOFF; 	}else if(&sc->arrs == dbch){ 		off = OHCI_ARSOFF; 	}else{ 		return; 	}  	s = splfw(); 	db_tr = dbch->top; 	pcnt =
literal|0
argument|;
comment|/* XXX we cannot handle a packet which lies in more than two buf */
argument|fwdma_sync_multiseg_all(dbch->am, BUS_DMASYNC_POSTREAD); 	fwdma_sync_multiseg_all(dbch->am, BUS_DMASYNC_POSTWRITE); 	status = FWOHCI_DMA_READ(db_tr->db[
literal|0
argument|].db.desc.res)>> OHCI_STATUS_SHIFT; 	resCount = FWOHCI_DMA_READ(db_tr->db[
literal|0
argument|].db.desc.res)& OHCI_COUNT_MASK;
if|#
directive|if
literal|0
argument|printf("status 0x%04x, resCount 0x%04x\n", status, resCount);
endif|#
directive|endif
argument|while (status& OHCI_CNTL_DMA_ACTIVE) { 		len = dbch->xferq.psize - resCount; 		ld = (uint8_t *)db_tr->buf; 		if (dbch->pdb_tr == NULL) { 			len -= dbch->buf_offset; 			ld += dbch->buf_offset; 		} 		if (len>
literal|0
argument|) 			bus_dmamap_sync(dbch->dmat, db_tr->dma_map, 					BUS_DMASYNC_POSTREAD); 		while (len>
literal|0
argument|) { 			if (count>=
literal|0
argument|&& count-- ==
literal|0
argument|) 				goto out; 			if(dbch->pdb_tr != NULL){
comment|/* we have a fragment in previous buffer */
argument|int rlen;  				offset = dbch->buf_offset; 				if (offset<
literal|0
argument|) 					offset = - offset; 				buf = dbch->pdb_tr->buf + offset; 				rlen = dbch->xferq.psize - offset; 				if (firewire_debug) 					printf(
literal|"rlen=%d, offset=%d\n"
argument|, 						rlen, dbch->buf_offset); 				if (dbch->buf_offset<
literal|0
argument|) {
comment|/* splitted in header, pull up */
argument|char *p;  					p = (char *)&pktbuf; 					bcopy(buf, p, rlen); 					p += rlen;
comment|/* this must be too long but harmless */
argument|rlen = sizeof(pktbuf) - rlen; 					if (rlen<
literal|0
argument|) 						printf(
literal|"why rlen< 0\n"
argument|); 					bcopy(db_tr->buf, p, rlen); 					ld += rlen; 					len -= rlen; 					hlen = fwohci_arcv_swap(&pktbuf, sizeof(pktbuf)); 					if (hlen<
literal|0
argument|) { 						printf(
literal|"hlen< 0 shouldn't happen"
argument|); 					} 					offset = sizeof(pktbuf); 					vec[
literal|0
argument|].iov_base = (char *)&pktbuf; 					vec[
literal|0
argument|].iov_len = offset; 				} else {
comment|/* splitted in payload */
argument|offset = rlen; 					vec[
literal|0
argument|].iov_base = buf; 					vec[
literal|0
argument|].iov_len = rlen; 				} 				fp=(struct fw_pkt *)vec[
literal|0
argument|].iov_base; 				nvec =
literal|1
argument|; 			} else {
comment|/* no fragment in previous buffer */
argument|fp=(struct fw_pkt *)ld; 				hlen = fwohci_arcv_swap(fp, len); 				if (hlen ==
literal|0
argument|)
comment|/* XXX need reset */
argument|goto out; 				if (hlen<
literal|0
argument|) { 					dbch->pdb_tr = db_tr; 					dbch->buf_offset = - dbch->buf_offset;
comment|/* sanity check */
argument|if (resCount !=
literal|0
argument|)  						printf(
literal|"resCount = %d !?\n"
argument|, 						    resCount);
comment|/* XXX clear pdb_tr */
argument|goto out; 				} 				offset =
literal|0
argument|; 				nvec =
literal|0
argument|; 			} 			plen = fwohci_get_plen(sc, dbch, fp) - offset; 			if (plen<
literal|0
argument|) {
comment|/* minimum header size + trailer 				= sizeof(fw_pkt) so this shouldn't happens */
argument|printf(
literal|"plen(%d) is negative! offset=%d\n"
argument|, 				    plen, offset);
comment|/* XXX clear pdb_tr */
argument|goto out; 			} 			if (plen>
literal|0
argument|) { 				len -= plen; 				if (len<
literal|0
argument|) { 					dbch->pdb_tr = db_tr; 					if (firewire_debug) 						printf(
literal|"splitted payload\n"
argument|);
comment|/* sanity check */
argument|if (resCount !=
literal|0
argument|)  						printf(
literal|"resCount = %d !?\n"
argument|, 						    resCount);
comment|/* XXX clear pdb_tr */
argument|goto out; 				} 				vec[nvec].iov_base = ld; 				vec[nvec].iov_len = plen; 				nvec ++; 				ld += plen; 			} 			dbch->buf_offset = ld - (uint8_t *)db_tr->buf; 			if (nvec ==
literal|0
argument|) 				printf(
literal|"nvec == 0\n"
argument|);
comment|/* DMA result-code will be written at the tail of packet */
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
argument|stat = FWOHCI_DMA_READ(((struct fwohci_trailer *)(ld - sizeof(struct fwohci_trailer)))->stat)>>
literal|16
argument|;
else|#
directive|else
argument|stat = ((struct fwohci_trailer *)(ld - sizeof(struct fwohci_trailer)))->stat;
endif|#
directive|endif
if|#
directive|if
literal|0
argument|printf("plen: %d, stat %x\n", 			    plen ,stat);
endif|#
directive|endif
argument|spd = (stat>>
literal|5
argument|)&
literal|0x3
argument|; 			stat&=
literal|0x1f
argument|; 			switch(stat){ 			case FWOHCIEV_ACKPEND:
if|#
directive|if
literal|0
argument|printf("fwohci_arcv: ack pending tcode=0x%x..\n", fp->mode.common.tcode);
endif|#
directive|endif
comment|/* fall through */
argument|case FWOHCIEV_ACKCOMPL: 			{ 				struct fw_rcv_buf rb;  				if ((vec[nvec-
literal|1
argument|].iov_len -= 					sizeof(struct fwohci_trailer)) ==
literal|0
argument|) 					nvec--;  				rb.fc =&sc->fc; 				rb.vec = vec; 				rb.nvec = nvec; 				rb.spd = spd; 				fw_rcv(&rb); 				break; 			} 			case FWOHCIEV_BUSRST: 				if (sc->fc.status != FWBUSRESET)  					printf(
literal|"got BUSRST packet!?\n"
argument|); 				break; 			default: 				device_printf(sc->fc.dev,
literal|"Async DMA Receive error err = %02x %s\n"
argument|, stat, fwohcicode[stat]);
if|#
directive|if
literal|0
comment|/* XXX */
argument|goto out;
endif|#
directive|endif
argument|break; 			} 			pcnt ++; 			if (dbch->pdb_tr != NULL) { 				fwohci_arcv_free_buf(dbch, dbch->pdb_tr); 				dbch->pdb_tr = NULL; 			}  		} out: 		if (resCount ==
literal|0
argument|) {
comment|/* done on this buffer */
argument|if (dbch->pdb_tr == NULL) { 				fwohci_arcv_free_buf(dbch, db_tr); 				dbch->buf_offset =
literal|0
argument|; 			} else 				if (dbch->pdb_tr != db_tr) 					printf(
literal|"pdb_tr != db_tr\n"
argument|); 			db_tr = STAILQ_NEXT(db_tr, link); 			status = FWOHCI_DMA_READ(db_tr->db[
literal|0
argument|].db.desc.res)>> OHCI_STATUS_SHIFT; 			resCount = FWOHCI_DMA_READ(db_tr->db[
literal|0
argument|].db.desc.res)& OHCI_COUNT_MASK;
comment|/* XXX check buffer overrun */
argument|dbch->top = db_tr; 		} else { 			dbch->buf_offset = dbch->xferq.psize - resCount; 			break; 		}
comment|/* XXX make sure DMA is not dead */
argument|}
if|#
directive|if
literal|0
argument|if (pcnt< 1) 		printf("fwohci_arcv: no packets\n");
endif|#
directive|endif
argument|splx(s); }
end_function

end_unit

