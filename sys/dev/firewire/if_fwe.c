begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2003  * 	Hidetoshi Shimokawa. All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *  *	This product includes software developed by Hidetoshi Shimokawa.  *  * 4. Neither the name of the author nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * $FreeBSD$  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_device_polling.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__DragonFly__
end_ifdef

begin_include
include|#
directive|include
file|<net/vlan/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<bus/firewire/firewire.h>
end_include

begin_include
include|#
directive|include
file|<bus/firewire/firewirereg.h>
end_include

begin_include
include|#
directive|include
file|"if_fwevar.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewire.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewirereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/if_fwevar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FWEDEBUG
value|if (fwedebug) if_printf
end_define

begin_define
define|#
directive|define
name|TX_MAX_QUEUE
value|(FWMAXQUEUE - 1)
end_define

begin_comment
comment|/* network interface */
end_comment

begin_function_decl
specifier|static
name|void
name|fwe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fwe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwe_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwe_output_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwe_as_output
parameter_list|(
name|struct
name|fwe_softc
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fwe_as_input
parameter_list|(
name|struct
name|fw_xferq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|fwedebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stream_ch
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tx_speed
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rx_queue_len
init|=
name|FWMAXQUEUE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_FWE
argument_list|,
literal|"if_fwe"
argument_list|,
literal|"Ethernet over FireWire interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|if_fwe_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fwedebug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_firewire
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_firewire
argument_list|,
name|OID_AUTO
argument_list|,
name|fwe
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Ethernet emulation subsystem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_fwe
argument_list|,
name|OID_AUTO
argument_list|,
name|stream_ch
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stream_ch
argument_list|,
literal|0
argument_list|,
literal|"Stream channel to use"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_fwe
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_speed
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|tx_speed
argument_list|,
literal|0
argument_list|,
literal|"Transmission speed"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_fwe
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_queue_len
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|rx_queue_len
argument_list|,
literal|0
argument_list|,
literal|"Length of the receive queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.firewire.fwe.stream_ch"
argument_list|,
operator|&
name|stream_ch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.firewire.fwe.tx_speed"
argument_list|,
operator|&
name|tx_speed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.firewire.fwe.rx_queue_len"
argument_list|,
operator|&
name|rx_queue_len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_decl_stmt
specifier|static
name|poll_handler_t
name|fwe_poll
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|fwe_poll
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|enum
name|poll_cmd
name|cmd
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|fwe_softc
modifier|*
name|fwe
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return;
name|fwe
operator|=
operator|(
operator|(
expr|struct
name|fwe_eth_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
operator|)
operator|->
name|fwe
expr_stmt|;
name|fc
operator|=
name|fwe
operator|->
name|fd
operator|.
name|fc
expr_stmt|;
name|fc
operator|->
name|poll
argument_list|(
name|fc
argument_list|,
operator|(
name|cmd
operator|==
name|POLL_AND_CHECK_STATUS
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVICE_POLLING */
end_comment

begin_function
specifier|static
name|void
name|fwe_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|"fwe"
argument_list|,
name|device_get_unit
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwe_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|pa
decl_stmt|;
name|pa
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|!=
name|device_get_unit
argument_list|(
name|pa
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Ethernet over FireWire"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwe_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fwe_softc
modifier|*
name|fwe
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|s
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
name|u_char
modifier|*
name|eaddr
decl_stmt|;
else|#
directive|else
name|u_char
name|eaddr
index|[
literal|6
index|]
decl_stmt|;
endif|#
directive|endif
name|struct
name|fw_eui64
modifier|*
name|eui
decl_stmt|;
name|fwe
operator|=
operator|(
operator|(
expr|struct
name|fwe_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
operator|)
expr_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|fwe
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fwe_softc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX */
name|fwe
operator|->
name|stream_ch
operator|=
name|stream_ch
expr_stmt|;
name|fwe
operator|->
name|dma_ch
operator|=
operator|-
literal|1
expr_stmt|;
name|fwe
operator|->
name|fd
operator|.
name|fc
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_speed
operator|<
literal|0
condition|)
name|tx_speed
operator|=
name|fwe
operator|->
name|fd
operator|.
name|fc
operator|->
name|speed
expr_stmt|;
name|fwe
operator|->
name|fd
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|fwe
operator|->
name|fd
operator|.
name|post_explore
operator|=
name|NULL
expr_stmt|;
name|fwe
operator|->
name|eth_softc
operator|.
name|fwe
operator|=
name|fwe
expr_stmt|;
name|fwe
operator|->
name|pkt_hdr
operator|.
name|mode
operator|.
name|stream
operator|.
name|tcode
operator|=
name|FWTCODE_STREAM
expr_stmt|;
name|fwe
operator|->
name|pkt_hdr
operator|.
name|mode
operator|.
name|stream
operator|.
name|sy
operator|=
literal|0
expr_stmt|;
name|fwe
operator|->
name|pkt_hdr
operator|.
name|mode
operator|.
name|stream
operator|.
name|chtag
operator|=
name|fwe
operator|->
name|stream_ch
expr_stmt|;
comment|/* generate fake MAC address: first and last 3bytes from eui64 */
define|#
directive|define
name|LOCAL
value|(0x02)
define|#
directive|define
name|GROUP
value|(0x01)
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
name|eaddr
operator|=
operator|&
name|IFP2ENADDR
argument_list|(
name|fwe
operator|->
name|eth_softc
operator|.
name|ifp
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
name|eui
operator|=
operator|&
name|fwe
operator|->
name|fd
operator|.
name|fc
operator|->
name|eui
expr_stmt|;
name|eaddr
index|[
literal|0
index|]
operator|=
operator|(
name|FW_EUI64_BYTE
argument_list|(
name|eui
argument_list|,
literal|0
argument_list|)
operator||
name|LOCAL
operator|)
operator|&
operator|~
name|GROUP
expr_stmt|;
name|eaddr
index|[
literal|1
index|]
operator|=
name|FW_EUI64_BYTE
argument_list|(
name|eui
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|eaddr
index|[
literal|2
index|]
operator|=
name|FW_EUI64_BYTE
argument_list|(
name|eui
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|eaddr
index|[
literal|3
index|]
operator|=
name|FW_EUI64_BYTE
argument_list|(
name|eui
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|eaddr
index|[
literal|4
index|]
operator|=
name|FW_EUI64_BYTE
argument_list|(
name|eui
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|eaddr
index|[
literal|5
index|]
operator|=
name|FW_EUI64_BYTE
argument_list|(
name|eui
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"if_fwe%d: Fake Ethernet address: "
literal|"%02x:%02x:%02x:%02x:%02x:%02x\n"
argument_list|,
name|unit
argument_list|,
name|eaddr
index|[
literal|0
index|]
argument_list|,
name|eaddr
index|[
literal|1
index|]
argument_list|,
name|eaddr
index|[
literal|2
index|]
argument_list|,
name|eaddr
index|[
literal|3
index|]
argument_list|,
name|eaddr
index|[
literal|4
index|]
argument_list|,
name|eaddr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* fill the rest and attach interface */
name|ifp
operator|=
name|fwe
operator|->
name|eth_softc
operator|.
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not if_alloc()\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|ifp
operator|->
name|if_softc
operator|=
operator|&
name|fwe
operator|->
name|eth_softc
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|501113
operator|||
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|unit
argument_list|)
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"fwe"
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_init
operator|=
name|fwe_init
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_start
operator|=
name|fwe_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|fwe_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
operator||
name|IFF_NEEDSGIANT
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|TX_MAX_QUEUE
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Tell the upper layer(s) we support long frames. */
name|ifp
operator|->
name|if_data
operator|.
name|ifi_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|500000
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_MTU
operator|&
name|IFCAP_POLLING
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_VLAN_MTU
expr_stmt|;
endif|#
directive|endif
name|FWEDEBUG
argument_list|(
name|ifp
argument_list|,
literal|"interface created\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwe_stop
parameter_list|(
name|struct
name|fwe_softc
modifier|*
name|fwe
parameter_list|)
block|{
name|struct
name|firewire_comm
modifier|*
name|fc
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|xferq
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|fwe
operator|->
name|eth_softc
operator|.
name|ifp
decl_stmt|;
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fc
operator|=
name|fwe
operator|->
name|fd
operator|.
name|fc
expr_stmt|;
if|if
condition|(
name|fwe
operator|->
name|dma_ch
operator|>=
literal|0
condition|)
block|{
name|xferq
operator|=
name|fc
operator|->
name|ir
index|[
name|fwe
operator|->
name|dma_ch
index|]
expr_stmt|;
if|if
condition|(
name|xferq
operator|->
name|flag
operator|&
name|FWXFERQ_RUNNING
condition|)
name|fc
operator|->
name|irx_disable
argument_list|(
name|fc
argument_list|,
name|fwe
operator|->
name|dma_ch
argument_list|)
expr_stmt|;
name|xferq
operator|->
name|flag
operator|&=
operator|~
operator|(
name|FWXFERQ_MODEMASK
operator||
name|FWXFERQ_OPEN
operator||
name|FWXFERQ_STREAM
operator||
name|FWXFERQ_EXTBUF
operator||
name|FWXFERQ_HANDLER
operator||
name|FWXFERQ_CHTAGMASK
operator|)
expr_stmt|;
name|xferq
operator|->
name|hand
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xferq
operator|->
name|bnchunk
condition|;
name|i
operator|++
control|)
name|m_freem
argument_list|(
name|xferq
operator|->
name|bulkxfer
index|[
name|i
index|]
operator|.
name|mbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xferq
operator|->
name|bulkxfer
argument_list|,
name|M_FWE
argument_list|)
expr_stmt|;
for|for
control|(
name|xfer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|fwe
operator|->
name|xferlist
argument_list|)
init|;
name|xfer
operator|!=
name|NULL
condition|;
name|xfer
operator|=
name|next
control|)
block|{
name|next
operator|=
name|STAILQ_NEXT
argument_list|(
name|xfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INIT
argument_list|(
operator|&
name|fwe
operator|->
name|xferlist
argument_list|)
expr_stmt|;
name|xferq
operator|->
name|bulkxfer
operator|=
name|NULL
expr_stmt|;
name|fwe
operator|->
name|dma_ch
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|fwe_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fwe_softc
modifier|*
name|fwe
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|fwe
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|fwe
operator|->
name|eth_softc
operator|.
name|ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|fwe_stop
argument_list|(
name|fwe
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwe_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|fwe_softc
modifier|*
name|fwe
init|=
operator|(
operator|(
expr|struct
name|fwe_eth_softc
operator|*
operator|)
name|arg
operator|)
operator|->
name|fwe
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|fwe
operator|->
name|eth_softc
operator|.
name|ifp
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|xferq
decl_stmt|;
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FWEDEBUG
argument_list|(
name|ifp
argument_list|,
literal|"initializing\n"
argument_list|)
expr_stmt|;
comment|/* XXX keep promiscoud mode */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_PROMISC
expr_stmt|;
name|fc
operator|=
name|fwe
operator|->
name|fd
operator|.
name|fc
expr_stmt|;
define|#
directive|define
name|START
value|0
if|if
condition|(
name|fwe
operator|->
name|dma_ch
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|START
init|;
name|i
operator|<
name|fc
operator|->
name|nisodma
condition|;
name|i
operator|++
control|)
block|{
name|xferq
operator|=
name|fc
operator|->
name|ir
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|xferq
operator|->
name|flag
operator|&
name|FWXFERQ_OPEN
operator|)
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
name|printf
argument_list|(
literal|"no free dma channel\n"
argument_list|)
expr_stmt|;
return|return;
name|found
label|:
name|fwe
operator|->
name|dma_ch
operator|=
name|i
expr_stmt|;
name|fwe
operator|->
name|stream_ch
operator|=
name|stream_ch
expr_stmt|;
name|fwe
operator|->
name|pkt_hdr
operator|.
name|mode
operator|.
name|stream
operator|.
name|chtag
operator|=
name|fwe
operator|->
name|stream_ch
expr_stmt|;
comment|/* allocate DMA channel and init packet mode */
name|xferq
operator|->
name|flag
operator||=
name|FWXFERQ_OPEN
operator||
name|FWXFERQ_EXTBUF
operator||
name|FWXFERQ_HANDLER
operator||
name|FWXFERQ_STREAM
expr_stmt|;
name|xferq
operator|->
name|flag
operator|&=
operator|~
literal|0xff
expr_stmt|;
name|xferq
operator|->
name|flag
operator||=
name|fwe
operator|->
name|stream_ch
operator|&
literal|0xff
expr_stmt|;
comment|/* register fwe_input handler */
name|xferq
operator|->
name|sc
operator|=
operator|(
name|caddr_t
operator|)
name|fwe
expr_stmt|;
name|xferq
operator|->
name|hand
operator|=
name|fwe_as_input
expr_stmt|;
name|xferq
operator|->
name|bnchunk
operator|=
name|rx_queue_len
expr_stmt|;
name|xferq
operator|->
name|bnpacket
operator|=
literal|1
expr_stmt|;
name|xferq
operator|->
name|psize
operator|=
name|MCLBYTES
expr_stmt|;
name|xferq
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
name|xferq
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|xferq
operator|->
name|bulkxfer
operator|=
operator|(
expr|struct
name|fw_bulkxfer
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fw_bulkxfer
argument_list|)
operator|*
name|xferq
operator|->
name|bnchunk
argument_list|,
name|M_FWE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|xferq
operator|->
name|bulkxfer
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"if_fwe: malloc failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|STAILQ_INIT
argument_list|(
operator|&
name|xferq
operator|->
name|stvalid
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|xferq
operator|->
name|stfree
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|xferq
operator|->
name|stdma
argument_list|)
expr_stmt|;
name|xferq
operator|->
name|stproc
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xferq
operator|->
name|bnchunk
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
name|m_getcl
argument_list|(
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
else|#
directive|else
name|m_getcl
argument_list|(
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xferq
operator|->
name|bulkxfer
index|[
name|i
index|]
operator|.
name|mbuf
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|xferq
operator|->
name|stfree
argument_list|,
operator|&
name|xferq
operator|->
name|bulkxfer
index|[
name|i
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"fwe_as_input: m_getcl failed\n"
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INIT
argument_list|(
operator|&
name|fwe
operator|->
name|xferlist
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_MAX_QUEUE
condition|;
name|i
operator|++
control|)
block|{
name|xfer
operator|=
name|fw_xfer_alloc
argument_list|(
name|M_FWE
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
break|break;
name|xfer
operator|->
name|send
operator|.
name|spd
operator|=
name|tx_speed
expr_stmt|;
name|xfer
operator|->
name|fc
operator|=
name|fwe
operator|->
name|fd
operator|.
name|fc
expr_stmt|;
name|xfer
operator|->
name|sc
operator|=
operator|(
name|caddr_t
operator|)
name|fwe
expr_stmt|;
name|xfer
operator|->
name|hand
operator|=
name|fwe_output_callback
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|fwe
operator|->
name|xferlist
argument_list|,
name|xfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|xferq
operator|=
name|fc
operator|->
name|ir
index|[
name|fwe
operator|->
name|dma_ch
index|]
expr_stmt|;
comment|/* start dma */
if|if
condition|(
operator|(
name|xferq
operator|->
name|flag
operator|&
name|FWXFERQ_RUNNING
operator|)
operator|==
literal|0
condition|)
name|fc
operator|->
name|irx_enable
argument_list|(
name|fc
argument_list|,
name|fwe
operator|->
name|dma_ch
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* attempt to start output */
block|fwe_start(ifp);
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|fwe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|fwe_softc
modifier|*
name|fwe
init|=
operator|(
operator|(
expr|struct
name|fwe_eth_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
operator|)
operator|->
name|fwe
decl_stmt|;
name|struct
name|ifstat
modifier|*
name|ifs
init|=
name|NULL
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|,
name|len
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
endif|#
directive|endif
name|fwe_init
argument_list|(
operator|&
name|fwe
operator|->
name|eth_softc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
else|#
directive|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
endif|#
directive|endif
name|fwe_stop
argument_list|(
name|fwe
argument_list|)
expr_stmt|;
block|}
comment|/* XXX keep promiscoud mode */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_PROMISC
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
break|break;
case|case
name|SIOCGIFSTATUS
case|:
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ifs
operator|=
operator|(
expr|struct
name|ifstat
operator|*
operator|)
name|data
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|ifs
operator|->
name|ascii
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|ifs
operator|->
name|ascii
argument_list|)
condition|)
name|snprintf
argument_list|(
name|ifs
operator|->
name|ascii
operator|+
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|ifs
operator|->
name|ascii
argument_list|)
operator|-
name|len
argument_list|,
literal|"\tch %d dma %d\n"
argument_list|,
name|fwe
operator|->
name|stream_ch
argument_list|,
name|fwe
operator|->
name|dma_ch
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
ifdef|#
directive|ifdef
name|DEVICE_POLLING
block|{
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
init|=
name|fc
operator|=
name|fwe
operator|->
name|fd
operator|.
name|fc
decl_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_reqcap
operator|&
name|IFCAP_POLLING
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
operator|)
condition|)
block|{
name|error
operator|=
name|ether_poll_register
argument_list|(
name|fwe_poll
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Disable interrupts */
name|fc
operator|->
name|set_intr
argument_list|(
name|fc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_POLLING
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|ifr
operator|->
name|ifr_reqcap
operator|&
name|IFCAP_POLLING
operator|)
operator|&&
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|error
operator|=
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Enable interrupts. */
name|fc
operator|->
name|set_intr
argument_list|(
name|fc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_POLLING
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* DEVICE_POLLING */
break|break;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|500000
default|default:
else|#
directive|else
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
endif|#
directive|endif
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwe_output_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|fwe_softc
modifier|*
name|fwe
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|fwe
operator|=
operator|(
expr|struct
name|fwe_softc
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
name|ifp
operator|=
name|fwe
operator|->
name|eth_softc
operator|.
name|ifp
expr_stmt|;
comment|/* XXX error check */
name|FWEDEBUG
argument_list|(
name|ifp
argument_list|,
literal|"resp = %d\n"
argument_list|,
name|xfer
operator|->
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|resp
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|xfer
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|fw_xfer_unload
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|fwe
operator|->
name|xferlist
argument_list|,
name|xfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* for queue full */
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
name|fwe_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|fwe_softc
modifier|*
name|fwe
init|=
operator|(
operator|(
expr|struct
name|fwe_eth_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
operator|)
operator|->
name|fwe
decl_stmt|;
name|int
name|s
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|FWEDEBUG
argument_list|(
name|ifp
argument_list|,
literal|"starting\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwe
operator|->
name|dma_ch
operator|<
literal|0
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|FWEDEBUG
argument_list|(
name|ifp
argument_list|,
literal|"not ready\n"
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
do|do
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|m
operator|!=
name|NULL
condition|)
do|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_len
operator|!=
literal|0
condition|)
name|fwe_as_output
argument_list|(
name|fwe
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|HDR_LEN
value|4
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|ETHER_ALIGN
end_ifndef

begin_define
define|#
directive|define
name|ETHER_ALIGN
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Async. stream output */
end_comment

begin_function
specifier|static
name|void
name|fwe_as_output
parameter_list|(
name|struct
name|fwe_softc
modifier|*
name|fwe
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|xferq
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|xfer
operator|=
name|NULL
expr_stmt|;
name|xferq
operator|=
name|fwe
operator|->
name|fd
operator|.
name|fc
operator|->
name|atq
expr_stmt|;
while|while
condition|(
name|xferq
operator|->
name|queued
operator|<
name|xferq
operator|->
name|maxq
operator|-
literal|1
condition|)
block|{
name|xfer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|fwe
operator|->
name|xferlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"if_fwe: lack of xfer\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|fwe
operator|->
name|xferlist
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
if|if
condition|(
name|ifp
operator|->
name|if_bpf
operator|!=
name|NULL
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* keep ip packet alignment for alpha */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|ETHER_ALIGN
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|&
name|xfer
operator|->
name|send
operator|.
name|hdr
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|xfer
operator|->
name|send
operator|.
name|hdr
operator|=
operator|*
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|fwe
operator|->
name|pkt_hdr
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|stream
operator|.
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|xfer
operator|->
name|mbuf
operator|=
name|m
expr_stmt|;
name|xfer
operator|->
name|send
operator|.
name|pay_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|fw_asyreq
argument_list|(
name|fwe
operator|->
name|fd
operator|.
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* error */
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
comment|/* XXX set error code */
name|fwe_output_callback
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|if (i> 1) 		printf("%d queued\n", i);
endif|#
directive|endif
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|xferq
operator|->
name|start
argument_list|(
name|fwe
operator|->
name|fd
operator|.
name|fc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Async. stream output */
end_comment

begin_function
specifier|static
name|void
name|fwe_as_input
parameter_list|(
name|struct
name|fw_xferq
modifier|*
name|xferq
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|fwe_softc
modifier|*
name|fwe
decl_stmt|;
name|struct
name|fw_bulkxfer
modifier|*
name|sxfer
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|u_char
modifier|*
name|c
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
endif|#
directive|endif
name|fwe
operator|=
operator|(
expr|struct
name|fwe_softc
operator|*
operator|)
name|xferq
operator|->
name|sc
expr_stmt|;
name|ifp
operator|=
name|fwe
operator|->
name|eth_softc
operator|.
name|ifp
expr_stmt|;
while|while
condition|(
operator|(
name|sxfer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|xferq
operator|->
name|stvalid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|xferq
operator|->
name|stvalid
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|fp
operator|=
name|mtod
argument_list|(
name|sxfer
operator|->
name|mbuf
argument_list|,
expr|struct
name|fw_pkt
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwe
operator|->
name|fd
operator|.
name|fc
operator|->
name|irx_post
operator|!=
name|NULL
condition|)
name|fwe
operator|->
name|fd
operator|.
name|fc
operator|->
name|irx_post
argument_list|(
name|fwe
operator|->
name|fd
operator|.
name|fc
argument_list|,
name|fp
operator|->
name|mode
operator|.
name|ld
argument_list|)
expr_stmt|;
name|m
operator|=
name|sxfer
operator|->
name|mbuf
expr_stmt|;
comment|/* insert new rbuf */
name|sxfer
operator|->
name|mbuf
operator|=
name|m0
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|!=
name|NULL
condition|)
block|{
name|m0
operator|->
name|m_len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m0
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|xferq
operator|->
name|stfree
argument_list|,
name|sxfer
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"fwe_as_input: m_getcl failed\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sxfer
operator|->
name|resp
operator|!=
literal|0
operator|||
name|fp
operator|->
name|mode
operator|.
name|stream
operator|.
name|len
operator|<
name|ETHER_ALIGN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
continue|continue;
block|}
name|m
operator|->
name|m_data
operator|+=
name|HDR_LEN
operator|+
name|ETHER_ALIGN
expr_stmt|;
name|c
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|c
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|fp
operator|->
name|mode
operator|.
name|stream
operator|.
name|len
operator|-
name|ETHER_ALIGN
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
else|#
directive|else
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|fp
operator|->
name|mode
operator|.
name|stream
operator|.
name|len
operator|-
name|ETHER_ALIGN
expr_stmt|;
endif|#
directive|endif
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
if|#
directive|if
literal|0
block|FWEDEBUG(ifp, "%02x %02x %02x %02x %02x %02x\n" 			 "%02x %02x %02x %02x %02x %02x\n" 			 "%02x %02x %02x %02x\n" 			 "%02x %02x %02x %02x\n" 			 "%02x %02x %02x %02x\n" 			 "%02x %02x %02x %02x\n", 			 c[0], c[1], c[2], c[3], c[4], c[5], 			 c[6], c[7], c[8], c[9], c[10], c[11], 			 c[12], c[13], c[14], c[15], 			 c[16], c[17], c[18], c[19], 			 c[20], c[21], c[22], c[23], 			 c[20], c[21], c[22], c[23] 		 );
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|__FreeBSD_version
operator|<
literal|500000
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|xferq
operator|->
name|stfree
argument_list|)
operator|!=
name|NULL
condition|)
name|fwe
operator|->
name|fd
operator|.
name|fc
operator|->
name|irx_enable
argument_list|(
name|fwe
operator|->
name|fd
operator|.
name|fc
argument_list|,
name|fwe
operator|->
name|dma_ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|devclass_t
name|fwe_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|fwe_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|fwe_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|fwe_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|fwe_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|fwe_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|fwe_driver
init|=
block|{
literal|"fwe"
block|,
name|fwe_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|fwe_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__DragonFly__
end_ifdef

begin_expr_stmt
name|DECLARE_DUMMY_MODULE
argument_list|(
name|fwe
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|fwe
argument_list|,
name|firewire
argument_list|,
name|fwe_driver
argument_list|,
name|fwe_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|fwe
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|fwe
argument_list|,
name|firewire
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

