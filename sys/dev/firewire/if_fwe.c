begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2002  * 	Hidetoshi Shimokawa. All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *  *	This product includes software developed by Hidetoshi Shimokawa.  *  * 4. Neither the name of the author nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewire.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewirereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/firewire/if_fwevar.h>
end_include

begin_define
define|#
directive|define
name|FWEDEBUG
value|if (fwedebug) printf
end_define

begin_define
define|#
directive|define
name|MAX_QUEUED
value|IFQ_MAXLEN
end_define

begin_comment
comment|/* 50 */
end_comment

begin_comment
comment|/* network interface */
end_comment

begin_decl_stmt
specifier|static
name|void
name|fwe_start
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fwe_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
name|u_long
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwe_init
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwe_as_output
name|__P
argument_list|(
operator|(
expr|struct
name|fwe_softc
operator|*
operator|,
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwe_as_input
name|__P
argument_list|(
operator|(
expr|struct
name|fw_xferq
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fwedebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stream_ch
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DECLARE
argument_list|(
name|M_FWE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_FWE
argument_list|,
literal|"if_fwe"
argument_list|,
literal|"Ethernet over FireWire interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|if_fwe_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fwedebug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_firewire
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_firewire
argument_list|,
name|OID_AUTO
argument_list|,
name|fwe
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Ethernet Emulation Subsystem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_firewire_fwe
argument_list|,
name|OID_AUTO
argument_list|,
name|stream_ch
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stream_ch
argument_list|,
literal|0
argument_list|,
literal|"Stream channel to use"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_define
define|#
directive|define
name|FWE_POLL_REGISTER
parameter_list|(
name|func
parameter_list|,
name|fwe
parameter_list|,
name|ifp
parameter_list|)
define|\
value|if (ether_poll_register(func, ifp)) {			\ 		struct firewire_comm *fc = (fwe)->fd.fc;	\ 		fc->set_intr(fc, 0);				\ 	}
end_define

begin_define
define|#
directive|define
name|FWE_POLL_DEREGISTER
parameter_list|(
name|fwe
parameter_list|,
name|ifp
parameter_list|)
define|\
value|do {							\ 		struct firewire_comm *fc = (fwe)->fd.fc;	\ 		ether_poll_deregister(ifp);			\ 		fc->set_intr(fc, 1);				\ 	} while(0)						\  static poll_handler_t fwe_poll;
end_define

begin_function
specifier|static
name|void
name|fwe_poll
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|enum
name|poll_cmd
name|cmd
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|fwe_softc
modifier|*
name|fwe
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
decl_stmt|;
name|fwe
operator|=
operator|(
operator|(
expr|struct
name|fwe_eth_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
operator|)
operator|->
name|fwe
expr_stmt|;
name|fc
operator|=
name|fwe
operator|->
name|fd
operator|.
name|fc
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|POLL_DEREGISTER
condition|)
block|{
comment|/* enable interrupts */
name|fc
operator|->
name|set_intr
argument_list|(
name|fc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|fc
operator|->
name|poll
argument_list|(
name|fc
argument_list|,
operator|(
name|cmd
operator|==
name|POLL_AND_CHECK_STATUS
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FWE_POLL_REGISTER
parameter_list|(
name|func
parameter_list|,
name|fwe
parameter_list|,
name|ifp
parameter_list|)
end_define

begin_define
define|#
directive|define
name|FWE_POLL_DEREGISTER
parameter_list|(
name|fwe
parameter_list|,
name|ifp
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|fwe_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|"if_fwe"
argument_list|,
name|device_get_unit
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwe_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|pa
decl_stmt|;
name|pa
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|!=
name|device_get_unit
argument_list|(
name|pa
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Ethernet over FireWire"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwe_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fwe_softc
modifier|*
name|fwe
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|s
decl_stmt|;
name|u_char
modifier|*
name|eaddr
decl_stmt|;
name|fwe
operator|=
operator|(
operator|(
expr|struct
name|fwe_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
operator|)
expr_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|fwe
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fwe_softc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX */
name|fwe
operator|->
name|stream_ch
operator|=
name|stream_ch
expr_stmt|;
name|fwe
operator|->
name|dma_ch
operator|=
operator|-
literal|1
expr_stmt|;
name|fwe
operator|->
name|fd
operator|.
name|fc
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fwe
operator|->
name|fd
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|fwe
operator|->
name|fd
operator|.
name|post_explore
operator|=
name|NULL
expr_stmt|;
name|fwe
operator|->
name|eth_softc
operator|.
name|fwe
operator|=
name|fwe
expr_stmt|;
name|fwe
operator|->
name|pkt_hdr
operator|.
name|mode
operator|.
name|stream
operator|.
name|tcode
operator|=
name|FWTCODE_STREAM
expr_stmt|;
name|fwe
operator|->
name|pkt_hdr
operator|.
name|mode
operator|.
name|stream
operator|.
name|sy
operator|=
literal|0
expr_stmt|;
name|fwe
operator|->
name|pkt_hdr
operator|.
name|mode
operator|.
name|stream
operator|.
name|chtag
operator|=
name|fwe
operator|->
name|stream_ch
expr_stmt|;
comment|/* generate fake MAC address: first and last 3bytes from eui64 */
define|#
directive|define
name|LOCAL
value|(0x02)
define|#
directive|define
name|GROUP
value|(0x01)
name|eaddr
operator|=
operator|&
name|fwe
operator|->
name|eth_softc
operator|.
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|0
index|]
expr_stmt|;
name|eaddr
index|[
literal|0
index|]
operator|=
operator|(
name|fwe
operator|->
name|fd
operator|.
name|fc
operator|->
name|eui
index|[
literal|0
index|]
operator||
name|LOCAL
operator|)
operator|&
operator|~
name|GROUP
expr_stmt|;
name|eaddr
index|[
literal|1
index|]
operator|=
name|fwe
operator|->
name|fd
operator|.
name|fc
operator|->
name|eui
index|[
literal|1
index|]
expr_stmt|;
name|eaddr
index|[
literal|2
index|]
operator|=
name|fwe
operator|->
name|fd
operator|.
name|fc
operator|->
name|eui
index|[
literal|2
index|]
expr_stmt|;
name|eaddr
index|[
literal|3
index|]
operator|=
name|fwe
operator|->
name|fd
operator|.
name|fc
operator|->
name|eui
index|[
literal|5
index|]
expr_stmt|;
name|eaddr
index|[
literal|4
index|]
operator|=
name|fwe
operator|->
name|fd
operator|.
name|fc
operator|->
name|eui
index|[
literal|6
index|]
expr_stmt|;
name|eaddr
index|[
literal|5
index|]
operator|=
name|fwe
operator|->
name|fd
operator|.
name|fc
operator|->
name|eui
index|[
literal|7
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"if_fwe%d: Fake Ethernet address: "
literal|"%02x:%02x:%02x:%02x:%02x:%02x\n"
argument_list|,
name|unit
argument_list|,
name|eaddr
index|[
literal|0
index|]
argument_list|,
name|eaddr
index|[
literal|1
index|]
argument_list|,
name|eaddr
index|[
literal|2
index|]
argument_list|,
name|eaddr
index|[
literal|3
index|]
argument_list|,
name|eaddr
index|[
literal|4
index|]
argument_list|,
name|eaddr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* fill the rest and attach interface */
name|ifp
operator|=
operator|&
name|fwe
operator|->
name|fwe_if
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
operator|&
name|fwe
operator|->
name|eth_softc
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"fwe"
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|fwe_init
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|fwe_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|fwe_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|FWMAXQUEUE
operator|-
literal|1
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Tell the upper layer(s) we support long frames. */
name|ifp
operator|->
name|if_data
operator|.
name|ifi_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|MAX_QUEUED
operator|-
literal|1
expr_stmt|;
name|FWEDEBUG
argument_list|(
literal|"interface %s%d created.\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwe_stop
parameter_list|(
name|struct
name|fwe_softc
modifier|*
name|fwe
parameter_list|)
block|{
name|struct
name|firewire_comm
modifier|*
name|fc
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|xferq
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|fwe
operator|->
name|fwe_if
decl_stmt|;
name|fc
operator|=
name|fwe
operator|->
name|fd
operator|.
name|fc
expr_stmt|;
name|FWE_POLL_DEREGISTER
argument_list|(
name|fwe
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwe
operator|->
name|dma_ch
operator|>=
literal|0
condition|)
block|{
name|xferq
operator|=
name|fc
operator|->
name|ir
index|[
name|fwe
operator|->
name|dma_ch
index|]
expr_stmt|;
if|if
condition|(
name|xferq
operator|->
name|flag
operator|&
name|FWXFERQ_RUNNING
condition|)
name|fc
operator|->
name|irx_disable
argument_list|(
name|fc
argument_list|,
name|fwe
operator|->
name|dma_ch
argument_list|)
expr_stmt|;
name|xferq
operator|->
name|flag
operator|&=
operator|~
operator|(
name|FWXFERQ_MODEMASK
operator||
name|FWXFERQ_OPEN
operator||
name|FWXFERQ_HANDLER
operator|)
expr_stmt|;
comment|/* XXX dequeue xferq->q */
name|fwe
operator|->
name|dma_ch
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwe_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fwe_softc
modifier|*
name|fwe
decl_stmt|;
name|int
name|s
decl_stmt|;
name|fwe
operator|=
operator|(
expr|struct
name|fwe_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|fwe_stop
argument_list|(
name|fwe
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
operator|&
name|fwe
operator|->
name|fwe_if
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwe_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|fwe_softc
modifier|*
name|fwe
init|=
operator|(
operator|(
expr|struct
name|fwe_eth_softc
operator|*
operator|)
name|arg
operator|)
operator|->
name|fwe
decl_stmt|;
name|struct
name|firewire_comm
modifier|*
name|fc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|fwe
operator|->
name|fwe_if
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|xferq
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FWEDEBUG
argument_list|(
literal|"initializing %s%d\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* XXX keep promiscoud mode */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_PROMISC
expr_stmt|;
name|fc
operator|=
name|fwe
operator|->
name|fd
operator|.
name|fc
expr_stmt|;
define|#
directive|define
name|START
value|0
if|if
condition|(
name|fwe
operator|->
name|dma_ch
operator|<
literal|0
condition|)
block|{
name|xferq
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
name|START
init|;
name|i
operator|<
name|fc
operator|->
name|nisodma
condition|;
name|i
operator|++
control|)
block|{
name|xferq
operator|=
name|fc
operator|->
name|ir
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|xferq
operator|->
name|flag
operator|&
name|FWXFERQ_OPEN
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|xferq
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"no free dma channel\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fwe
operator|->
name|dma_ch
operator|=
name|i
expr_stmt|;
name|fwe
operator|->
name|stream_ch
operator|=
name|stream_ch
expr_stmt|;
name|fwe
operator|->
name|pkt_hdr
operator|.
name|mode
operator|.
name|stream
operator|.
name|chtag
operator|=
name|fwe
operator|->
name|stream_ch
expr_stmt|;
comment|/* allocate DMA channel and init packet mode */
name|xferq
operator|->
name|flag
operator||=
name|FWXFERQ_OPEN
operator||
name|FWXFERQ_PACKET
expr_stmt|;
name|xferq
operator|->
name|flag
operator||=
name|fwe
operator|->
name|stream_ch
operator|&
literal|0xff
expr_stmt|;
comment|/* register fwe_input handler */
name|xferq
operator|->
name|sc
operator|=
operator|(
name|caddr_t
operator|)
name|fwe
expr_stmt|;
name|xferq
operator|->
name|hand
operator|=
name|fwe_as_input
expr_stmt|;
name|xferq
operator|->
name|flag
operator||=
name|FWXFERQ_HANDLER
expr_stmt|;
block|}
else|else
name|xferq
operator|=
name|fc
operator|->
name|ir
index|[
name|fwe
operator|->
name|dma_ch
index|]
expr_stmt|;
comment|/* start dma */
if|if
condition|(
operator|(
name|xferq
operator|->
name|flag
operator|&
name|FWXFERQ_RUNNING
operator|)
operator|==
literal|0
condition|)
name|fc
operator|->
name|irx_enable
argument_list|(
name|fc
argument_list|,
name|fwe
operator|->
name|dma_ch
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|FWE_POLL_REGISTER
argument_list|(
name|fwe_poll
argument_list|,
name|fwe
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* attempt to start output */
block|fwe_start(ifp);
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|fwe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|fwe_softc
modifier|*
name|fwe
init|=
operator|(
operator|(
expr|struct
name|fwe_eth_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
operator|)
operator|->
name|fwe
decl_stmt|;
name|struct
name|ifstat
modifier|*
name|ifs
init|=
name|NULL
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|,
name|len
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
case|case
name|SIOCSIFFLAGS
case|:
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
name|fwe_init
argument_list|(
operator|&
name|fwe
operator|->
name|eth_softc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|fwe_stop
argument_list|(
name|fwe
argument_list|)
expr_stmt|;
block|}
comment|/* XXX keep promiscoud mode */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_PROMISC
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
break|break;
case|case
name|SIOCGIFSTATUS
case|:
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ifs
operator|=
operator|(
expr|struct
name|ifstat
operator|*
operator|)
name|data
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|ifs
operator|->
name|ascii
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|ifs
operator|->
name|ascii
argument_list|)
condition|)
name|snprintf
argument_list|(
name|ifs
operator|->
name|ascii
operator|+
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|ifs
operator|->
name|ascii
argument_list|)
operator|-
name|len
argument_list|,
literal|"\tch %d dma %d\n"
argument_list|,
name|fwe
operator|->
name|stream_ch
argument_list|,
name|fwe
operator|->
name|dma_ch
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|fwe_softc
modifier|*
name|fwe
init|=
operator|(
operator|(
expr|struct
name|fwe_eth_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
operator|)
operator|->
name|fwe
decl_stmt|;
name|int
name|s
decl_stmt|;
if|#
directive|if
literal|1
name|FWEDEBUG
argument_list|(
literal|"%s%d starting\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwe
operator|->
name|dma_ch
operator|<
literal|0
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|FWEDEBUG
argument_list|(
literal|"%s%d not ready.\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
do|do
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|m
operator|!=
name|NULL
condition|)
do|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_len
operator|!=
literal|0
condition|)
name|fwe_as_output
argument_list|(
name|fwe
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwe_output_callback
parameter_list|(
name|struct
name|fw_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|fwe_softc
modifier|*
name|fwe
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|fwe
operator|=
operator|(
expr|struct
name|fwe_softc
operator|*
operator|)
name|xfer
operator|->
name|sc
expr_stmt|;
comment|/* XXX error check */
name|FWEDEBUG
argument_list|(
literal|"resp = %d\n"
argument_list|,
name|xfer
operator|->
name|resp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|xfer
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|send
operator|.
name|buf
operator|=
name|NULL
expr_stmt|;
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* XXX for queue full */
name|ifp
operator|=
operator|&
name|fwe
operator|->
name|fwe_if
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
name|fwe_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_define
define|#
directive|define
name|HDR_LEN
value|4
end_define

begin_define
define|#
directive|define
name|ALIGN_PAD
value|2
end_define

begin_comment
comment|/* Async. stream output */
end_comment

begin_function
specifier|static
name|void
name|fwe_as_output
parameter_list|(
name|struct
name|fwe_softc
modifier|*
name|fwe
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fw_xferq
modifier|*
name|xferq
decl_stmt|;
name|struct
name|fw_pkt
modifier|*
name|fp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|xfer
operator|=
name|NULL
expr_stmt|;
name|xferq
operator|=
name|fwe
operator|->
name|fd
operator|.
name|fc
operator|->
name|atq
expr_stmt|;
while|while
condition|(
name|xferq
operator|->
name|queued
operator|<
name|xferq
operator|->
name|maxq
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|xfer
operator|=
name|fw_xfer_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_bpf
operator|!=
name|NULL
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|send
operator|.
name|off
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|spd
operator|=
literal|2
expr_stmt|;
name|xfer
operator|->
name|fc
operator|=
name|fwe
operator|->
name|fd
operator|.
name|fc
expr_stmt|;
name|xfer
operator|->
name|retry_req
operator|=
name|fw_asybusy
expr_stmt|;
name|xfer
operator|->
name|sc
operator|=
operator|(
name|caddr_t
operator|)
name|fwe
expr_stmt|;
name|xfer
operator|->
name|act
operator|.
name|hand
operator|=
name|fwe_output_callback
expr_stmt|;
comment|/* keep ip packet alignment for alpha */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|ALIGN_PAD
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|(
expr|struct
name|fw_pkt
operator|*
operator|)
operator|&
name|xfer
operator|->
name|dst
expr_stmt|;
comment|/* XXX */
name|xfer
operator|->
name|dst
operator|=
operator|*
operator|(
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|fwe
operator|->
name|pkt_hdr
operator|)
expr_stmt|;
name|fp
operator|->
name|mode
operator|.
name|stream
operator|.
name|len
operator|=
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|send
operator|.
name|buf
operator|=
operator|(
name|caddr_t
operator|)
name|fp
expr_stmt|;
name|xfer
operator|->
name|mbuf
operator|=
name|m
expr_stmt|;
name|xfer
operator|->
name|send
operator|.
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|HDR_LEN
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|fw_asyreq
argument_list|(
name|xfer
operator|->
name|fc
argument_list|,
operator|-
literal|1
argument_list|,
name|xfer
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* error */
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
comment|/* XXX set error code */
name|fwe_output_callback
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|if (i> 1) 		printf("%d queued\n", i);
endif|#
directive|endif
if|if
condition|(
name|xfer
operator|!=
name|NULL
condition|)
name|xferq
operator|->
name|start
argument_list|(
name|xfer
operator|->
name|fc
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
end_if

begin_function
specifier|static
name|void
name|fwe_free
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|args
parameter_list|)
block|{
name|FWEDEBUG
argument_list|(
literal|"fwe_free:\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|fwe_free
parameter_list|(
name|caddr_t
name|buf
parameter_list|,
name|u_int
name|size
parameter_list|)
block|{
name|int
modifier|*
name|p
decl_stmt|;
name|FWEDEBUG
argument_list|(
literal|"fwe_free:\n"
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|buf
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|<
literal|1
condition|)
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwe_ref
parameter_list|(
name|caddr_t
name|buf
parameter_list|,
name|u_int
name|size
parameter_list|)
block|{
name|int
modifier|*
name|p
decl_stmt|;
name|FWEDEBUG
argument_list|(
literal|"fwe_ref: called\n"
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|buf
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Async. stream output */
end_comment

begin_function
specifier|static
name|void
name|fwe_as_input
parameter_list|(
name|struct
name|fw_xferq
modifier|*
name|xferq
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|fw_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|fwe_softc
modifier|*
name|fwe
decl_stmt|;
name|u_char
modifier|*
name|c
decl_stmt|;
name|int
name|len
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
name|fwe
operator|=
operator|(
expr|struct
name|fwe_softc
operator|*
operator|)
name|xferq
operator|->
name|sc
expr_stmt|;
name|ifp
operator|=
operator|&
name|fwe
operator|->
name|fwe_if
expr_stmt|;
if|#
directive|if
literal|0
block|FWE_POLL_REGISTER(fwe_poll, fwe, ifp);
endif|#
directive|endif
while|while
condition|(
operator|(
name|xfer
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|xferq
operator|->
name|q
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|xferq
operator|->
name|q
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|xferq
operator|->
name|queued
operator|--
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"MGETHDR failed\n"
argument_list|)
expr_stmt|;
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|xfer
operator|->
name|recv
operator|.
name|off
operator|+
name|xfer
operator|->
name|recv
operator|.
name|len
expr_stmt|;
name|FWEDEBUG
argument_list|(
literal|"fwe_as_input len=%d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|MEXTADD
argument_list|(
name|m
argument_list|,
name|xfer
operator|->
name|recv
operator|.
name|buf
argument_list|,
name|len
argument_list|,
name|fwe_free
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|EXT_NET_DRV
argument_list|)
expr_stmt|;
else|#
directive|else
name|m
operator|->
name|m_flags
operator||=
name|M_EXT
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
operator|=
name|xfer
operator|->
name|recv
operator|.
name|buf
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_size
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_free
operator|=
name|fwe_free
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_ref
operator|=
name|fwe_ref
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
operator|)
operator|=
literal|1
expr_stmt|;
comment|/* XXX refcount */
endif|#
directive|endif
name|p
operator|=
name|xfer
operator|->
name|recv
operator|.
name|buf
operator|+
name|xfer
operator|->
name|recv
operator|.
name|off
operator|+
name|HDR_LEN
operator|+
name|ALIGN_PAD
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|p
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|len
operator|-=
name|xfer
operator|->
name|recv
operator|.
name|off
operator|+
name|HDR_LEN
operator|+
name|ALIGN_PAD
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|p
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|c
operator|=
operator|(
name|char
operator|*
operator|)
name|eh
expr_stmt|;
if|#
directive|if
literal|0
block|FWEDEBUG("%02x %02x %02x %02x %02x %02x\n" 			 "%02x %02x %02x %02x %02x %02x\n" 			 "%02x %02x %02x %02x\n" 			 "%02x %02x %02x %02x\n" 			 "%02x %02x %02x %02x\n" 			 "%02x %02x %02x %02x\n", 			 c[0], c[1], c[2], c[3], c[4], c[5], 			 c[6], c[7], c[8], c[9], c[10], c[11], 			 c[12], c[13], c[14], c[15], 			 c[16], c[17], c[18], c[19], 			 c[20], c[21], c[22], c[23], 			 c[20], c[21], c[22], c[23] 		 );
endif|#
directive|endif
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|xfer
operator|->
name|recv
operator|.
name|buf
operator|=
name|NULL
expr_stmt|;
name|fw_xfer_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|devclass_t
name|fwe_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|fwe_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|fwe_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|fwe_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|fwe_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|fwe_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|fwe_driver
init|=
block|{
literal|"if_fwe"
block|,
name|fwe_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|fwe_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|if_fwe
argument_list|,
name|firewire
argument_list|,
name|fwe_driver
argument_list|,
name|fwe_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|if_fwe
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|if_fwe
argument_list|,
name|firewire
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

