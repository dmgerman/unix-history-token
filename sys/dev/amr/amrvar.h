begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999,2000 Michael Smith  * Copyright (c) 2000 BSDi  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Copyright (c) 2002 Eric Moore  * Copyright (c) 2002 LSI Logic Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The party using or redistributing the source code and binary forms  *    agrees to the disclaimer below and the terms and conditions set forth  *    herein.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *  *      $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<geom/geom_disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_define
define|#
directive|define
name|LSI_DESC_PCI
value|"LSILogic MegaRAID 1.53"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|AMR_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|debug
parameter_list|(
name|level
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|do {if (level<= AMR_DEBUG) printf("%s: " fmt "\n", __func__ , ##args);} while(0)
end_define

begin_define
define|#
directive|define
name|debug_called
parameter_list|(
name|level
parameter_list|)
value|do {if (level<= AMR_DEBUG) printf("%s: called\n", __func__);} while(0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debug
parameter_list|(
name|level
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|debug_called
parameter_list|(
name|level
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|xdebug
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|printf("%s: " fmt "\n", __func__ , ##args)
end_define

begin_comment
comment|/*  * Per-logical-drive datastructure  */
end_comment

begin_struct
struct|struct
name|amr_logdrive
block|{
name|u_int32_t
name|al_size
decl_stmt|;
name|int
name|al_state
decl_stmt|;
name|int
name|al_properties
decl_stmt|;
comment|/* synthetic geometry */
name|int
name|al_cylinders
decl_stmt|;
name|int
name|al_heads
decl_stmt|;
name|int
name|al_sectors
decl_stmt|;
comment|/* driver */
name|device_t
name|al_disk
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Due to the difficulty of using the zone allocator to create a new  * zone from within a module, we use our own clustering to reduce   * memory wastage due to allocating lots of these small structures.  *  * 16k gives us a little under 200 command structures, which should  * normally be plenty.  We will grab more if we need them.  */
end_comment

begin_define
define|#
directive|define
name|AMR_CMD_CLUSTERSIZE
value|(16 * 1024)
end_define

begin_typedef
typedef|typedef
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|amr_command
argument_list|)
name|ac_qhead_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|STAILQ_ENTRY
argument_list|(
argument|amr_command
argument_list|)
name|ac_link_t
expr_stmt|;
end_typedef

begin_union
union|union
name|amr_ccb
block|{
name|struct
name|amr_passthrough
name|ccb_pthru
decl_stmt|;
name|struct
name|amr_ext_passthrough
name|ccb_epthru
decl_stmt|;
name|uint8_t
name|bytes
index|[
literal|128
index|]
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/*  * Per-command control structure.  */
end_comment

begin_struct
struct|struct
name|amr_command
block|{
name|ac_link_t
name|ac_link
decl_stmt|;
name|struct
name|amr_softc
modifier|*
name|ac_sc
decl_stmt|;
name|u_int8_t
name|ac_slot
decl_stmt|;
name|int
name|ac_status
decl_stmt|;
comment|/* command completion status */
union|union
block|{
name|struct
name|amr_sgentry
modifier|*
name|sg32
decl_stmt|;
name|struct
name|amr_sg64entry
modifier|*
name|sg64
decl_stmt|;
block|}
name|ac_sg
union|;
name|u_int32_t
name|ac_sgbusaddr
decl_stmt|;
name|u_int32_t
name|ac_sg64_lo
decl_stmt|;
name|u_int32_t
name|ac_sg64_hi
decl_stmt|;
name|struct
name|amr_mailbox
name|ac_mailbox
decl_stmt|;
name|int
name|ac_flags
decl_stmt|;
define|#
directive|define
name|AMR_CMD_DATAIN
value|(1<<0)
define|#
directive|define
name|AMR_CMD_DATAOUT
value|(1<<1)
define|#
directive|define
name|AMR_CMD_CCB
value|(1<<2)
define|#
directive|define
name|AMR_CMD_PRIORITY
value|(1<<4)
define|#
directive|define
name|AMR_CMD_MAPPED
value|(1<<5)
define|#
directive|define
name|AMR_CMD_SLEEP
value|(1<<6)
define|#
directive|define
name|AMR_CMD_BUSY
value|(1<<7)
define|#
directive|define
name|AMR_CMD_SG64
value|(1<<8)
define|#
directive|define
name|AC_IS_SG64
parameter_list|(
name|ac
parameter_list|)
value|((ac)->ac_flags& AMR_CMD_SG64)
name|u_int
name|ac_retries
decl_stmt|;
name|struct
name|bio
modifier|*
name|ac_bio
decl_stmt|;
name|void
function_decl|(
modifier|*
name|ac_complete
function_decl|)
parameter_list|(
name|struct
name|amr_command
modifier|*
name|ac
parameter_list|)
function_decl|;
name|void
modifier|*
name|ac_private
decl_stmt|;
name|void
modifier|*
name|ac_data
decl_stmt|;
name|size_t
name|ac_length
decl_stmt|;
name|bus_dmamap_t
name|ac_dmamap
decl_stmt|;
name|bus_dmamap_t
name|ac_dma64map
decl_stmt|;
name|bus_dma_tag_t
name|ac_tag
decl_stmt|;
name|bus_dmamap_t
name|ac_datamap
decl_stmt|;
name|int
name|ac_nsegments
decl_stmt|;
name|uint32_t
name|ac_mb_physaddr
decl_stmt|;
name|union
name|amr_ccb
modifier|*
name|ac_ccb
decl_stmt|;
name|uint32_t
name|ac_ccb_busaddr
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|amr_command_cluster
block|{
name|TAILQ_ENTRY
argument_list|(
argument|amr_command_cluster
argument_list|)
name|acc_link
expr_stmt|;
name|struct
name|amr_command
name|acc_command
index|[
literal|0
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|AMR_CMD_CLUSTERCOUNT
value|((AMR_CMD_CLUSTERSIZE - sizeof(struct amr_command_cluster)) /	\ 				 sizeof(struct amr_command))
end_define

begin_comment
comment|/*  * Per-controller-instance data  */
end_comment

begin_struct
struct|struct
name|amr_softc
block|{
comment|/* bus attachments */
name|device_t
name|amr_dev
decl_stmt|;
name|struct
name|resource
modifier|*
name|amr_reg
decl_stmt|;
comment|/* control registers */
name|bus_space_handle_t
name|amr_bhandle
decl_stmt|;
name|bus_space_tag_t
name|amr_btag
decl_stmt|;
name|bus_dma_tag_t
name|amr_parent_dmat
decl_stmt|;
comment|/* parent DMA tag */
name|bus_dma_tag_t
name|amr_buffer_dmat
decl_stmt|;
comment|/* data buffer DMA tag */
name|bus_dma_tag_t
name|amr_buffer64_dmat
decl_stmt|;
name|struct
name|resource
modifier|*
name|amr_irq
decl_stmt|;
comment|/* interrupt */
name|void
modifier|*
name|amr_intr
decl_stmt|;
comment|/* mailbox */
specifier|volatile
name|struct
name|amr_mailbox
modifier|*
name|amr_mailbox
decl_stmt|;
specifier|volatile
name|struct
name|amr_mailbox64
modifier|*
name|amr_mailbox64
decl_stmt|;
name|u_int32_t
name|amr_mailboxphys
decl_stmt|;
name|bus_dma_tag_t
name|amr_mailbox_dmat
decl_stmt|;
name|bus_dmamap_t
name|amr_mailbox_dmamap
decl_stmt|;
comment|/* scatter/gather lists and their controller-visible mappings */
name|struct
name|amr_sgentry
modifier|*
name|amr_sgtable
decl_stmt|;
comment|/* s/g lists */
name|struct
name|amr_sg64entry
modifier|*
name|amr_sg64table
decl_stmt|;
comment|/* 64bit s/g lists */
name|u_int32_t
name|amr_sgbusaddr
decl_stmt|;
comment|/* s/g table base address in bus space */
name|bus_dma_tag_t
name|amr_sg_dmat
decl_stmt|;
comment|/* s/g buffer DMA tag */
name|bus_dmamap_t
name|amr_sg_dmamap
decl_stmt|;
comment|/* map for s/g buffers */
name|union
name|amr_ccb
modifier|*
name|amr_ccb
decl_stmt|;
name|uint32_t
name|amr_ccb_busaddr
decl_stmt|;
name|bus_dma_tag_t
name|amr_ccb_dmat
decl_stmt|;
name|bus_dmamap_t
name|amr_ccb_dmamap
decl_stmt|;
comment|/* controller limits and features */
name|int
name|amr_nextslot
decl_stmt|;
comment|/* Next slot to use for newly allocated commands */
name|int
name|amr_maxio
decl_stmt|;
comment|/* maximum number of I/O transactions */
name|int
name|amr_maxdrives
decl_stmt|;
comment|/* max number of logical drives */
name|int
name|amr_maxchan
decl_stmt|;
comment|/* count of SCSI channels */
comment|/* connected logical drives */
name|struct
name|amr_logdrive
name|amr_drive
index|[
name|AMR_MAXLD
index|]
decl_stmt|;
comment|/* controller state */
name|int
name|amr_state
decl_stmt|;
define|#
directive|define
name|AMR_STATE_OPEN
value|(1<<0)
define|#
directive|define
name|AMR_STATE_SUSPEND
value|(1<<1)
define|#
directive|define
name|AMR_STATE_INTEN
value|(1<<2)
define|#
directive|define
name|AMR_STATE_SHUTDOWN
value|(1<<3)
define|#
directive|define
name|AMR_STATE_CRASHDUMP
value|(1<<4)
define|#
directive|define
name|AMR_STATE_QUEUE_FRZN
value|(1<<5)
define|#
directive|define
name|AMR_STATE_LD_DELETE
value|(1<<6)
define|#
directive|define
name|AMR_STATE_REMAP_LD
value|(1<<7)
comment|/* per-controller queues */
name|struct
name|bio_queue_head
name|amr_bioq
decl_stmt|;
comment|/* pending I/O with no commands */
name|ac_qhead_t
name|amr_ready
decl_stmt|;
comment|/* commands ready to be submitted */
name|struct
name|amr_command
modifier|*
name|amr_busycmd
index|[
name|AMR_MAXCMD
index|]
decl_stmt|;
name|int
name|amr_busyslots
decl_stmt|;
name|ac_qhead_t
name|amr_freecmds
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|amr_command_cluster
argument_list|)
name|amr_cmd_clusters
expr_stmt|;
comment|/* CAM attachments for passthrough */
name|struct
name|cam_sim
modifier|*
name|amr_cam_sim
index|[
name|AMR_MAX_CHANNELS
index|]
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|ccb_hdr
argument_list|)
name|amr_cam_ccbq
expr_stmt|;
name|struct
name|cam_devq
modifier|*
name|amr_cam_devq
decl_stmt|;
comment|/* control device */
name|struct
name|cdev
modifier|*
name|amr_dev_t
decl_stmt|;
name|struct
name|mtx
name|amr_list_lock
decl_stmt|;
comment|/* controller type-specific support */
name|int
name|amr_type
decl_stmt|;
define|#
directive|define
name|AMR_TYPE_QUARTZ
value|(1<<0)
define|#
directive|define
name|AMR_IS_QUARTZ
parameter_list|(
name|sc
parameter_list|)
value|((sc)->amr_type& AMR_TYPE_QUARTZ)
define|#
directive|define
name|AMR_TYPE_40LD
value|(1<<1)
define|#
directive|define
name|AMR_IS_40LD
parameter_list|(
name|sc
parameter_list|)
value|((sc)->amr_type& AMR_TYPE_40LD)
define|#
directive|define
name|AMR_TYPE_SG64
value|(1<<2)
define|#
directive|define
name|AMR_IS_SG64
parameter_list|(
name|sc
parameter_list|)
value|((sc)->amr_type& AMR_TYPE_SG64)
name|int
function_decl|(
modifier|*
name|amr_submit_command
function_decl|)
parameter_list|(
name|struct
name|amr_command
modifier|*
name|ac
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|amr_get_work
function_decl|)
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|amr_mailbox
modifier|*
name|mbsave
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|amr_poll_command
function_decl|)
parameter_list|(
name|struct
name|amr_command
modifier|*
name|ac
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|amr_poll_command1
function_decl|)
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|amr_command
modifier|*
name|ac
parameter_list|)
function_decl|;
name|int
name|support_ext_cdb
decl_stmt|;
comment|/* greater than 10 byte cdb support */
comment|/* misc glue */
name|device_t
name|amr_pass
decl_stmt|;
name|int
function_decl|(
modifier|*
name|amr_cam_command
function_decl|)
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|amr_command
modifier|*
modifier|*
name|acp
parameter_list|)
function_decl|;
name|struct
name|intr_config_hook
name|amr_ich
decl_stmt|;
comment|/* wait-for-interrupts probe hook */
name|struct
name|callout_handle
name|amr_timeout
decl_stmt|;
comment|/* periodic status check */
name|int
name|amr_allow_vol_config
decl_stmt|;
name|int
name|amr_linux_no_adapters
decl_stmt|;
name|int
name|amr_ld_del_supported
decl_stmt|;
name|struct
name|mtx
name|amr_hw_lock
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Interface between bus connections and driver core.  */
end_comment

begin_function_decl
specifier|extern
name|int
name|amr_attach
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|amr_free
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|amr_flush
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|amr_done
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|amr_startio
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Command buffer allocation.  */
end_comment

begin_function_decl
specifier|extern
name|struct
name|amr_command
modifier|*
name|amr_alloccmd
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|amr_releasecmd
parameter_list|(
name|struct
name|amr_command
modifier|*
name|ac
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * MegaRAID logical disk driver  */
end_comment

begin_struct
struct|struct
name|amrd_softc
block|{
name|device_t
name|amrd_dev
decl_stmt|;
name|struct
name|amr_softc
modifier|*
name|amrd_controller
decl_stmt|;
name|struct
name|amr_logdrive
modifier|*
name|amrd_drive
decl_stmt|;
name|struct
name|disk
modifier|*
name|amrd_disk
decl_stmt|;
name|int
name|amrd_unit
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Interface between driver core and disk driver (should be using a bus?)  */
end_comment

begin_function_decl
specifier|extern
name|int
name|amr_submit_bio
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|amr_dump_blocks
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|,
name|int
name|unit
parameter_list|,
name|u_int32_t
name|lba
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|blks
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|amrd_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/********************************************************************************  * Enqueue/dequeue functions  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|amr_enqueue_bio
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bio
parameter_list|)
block|{
name|bioq_insert_tail
argument_list|(
operator|&
name|sc
operator|->
name|amr_bioq
argument_list|,
name|bio
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|bio
operator|*
name|amr_dequeue_bio
argument_list|(
argument|struct amr_softc *sc
argument_list|)
block|{     struct
name|bio
operator|*
name|bio
block|;
if|if
condition|(
operator|(
name|bio
operator|=
name|bioq_first
argument_list|(
operator|&
name|sc
operator|->
name|amr_bioq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|amr_bioq
argument_list|,
name|bio
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|bio
operator|)
return|;
end_return

begin_function
unit|}  static
name|__inline
name|void
name|amr_init_qhead
parameter_list|(
name|ac_qhead_t
modifier|*
name|head
parameter_list|)
block|{
name|STAILQ_INIT
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|amr_enqueue_ready
parameter_list|(
name|struct
name|amr_command
modifier|*
name|ac
parameter_list|)
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ac
operator|->
name|ac_sc
operator|->
name|amr_ready
argument_list|,
name|ac
argument_list|,
name|ac_link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|amr_requeue_ready
parameter_list|(
name|struct
name|amr_command
modifier|*
name|ac
parameter_list|)
block|{
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ac
operator|->
name|ac_sc
operator|->
name|amr_ready
argument_list|,
name|ac
argument_list|,
name|ac_link
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|amr_command
operator|*
name|amr_dequeue_ready
argument_list|(
argument|struct amr_softc *sc
argument_list|)
block|{     struct
name|amr_command
operator|*
name|ac
block|;
if|if
condition|(
operator|(
name|ac
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|amr_ready
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|amr_ready
argument_list|,
name|ac_link
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|ac
operator|)
return|;
end_return

begin_function
unit|}  static
name|__inline
name|void
name|amr_enqueue_completed
parameter_list|(
name|struct
name|amr_command
modifier|*
name|ac
parameter_list|,
name|ac_qhead_t
modifier|*
name|head
parameter_list|)
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
name|head
argument_list|,
name|ac
argument_list|,
name|ac_link
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|amr_command
operator|*
name|amr_dequeue_completed
argument_list|(
argument|struct amr_softc *sc
argument_list|,
argument|ac_qhead_t *head
argument_list|)
block|{     struct
name|amr_command
operator|*
name|ac
block|;
if|if
condition|(
operator|(
name|ac
operator|=
name|STAILQ_FIRST
argument_list|(
name|head
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|STAILQ_REMOVE_HEAD
argument_list|(
name|head
argument_list|,
name|ac_link
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|ac
operator|)
return|;
end_return

begin_function
unit|}  static
name|__inline
name|void
name|amr_enqueue_free
parameter_list|(
name|struct
name|amr_command
modifier|*
name|ac
parameter_list|)
block|{
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ac
operator|->
name|ac_sc
operator|->
name|amr_freecmds
argument_list|,
name|ac
argument_list|,
name|ac_link
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|amr_command
operator|*
name|amr_dequeue_free
argument_list|(
argument|struct amr_softc *sc
argument_list|)
block|{     struct
name|amr_command
operator|*
name|ac
block|;
if|if
condition|(
operator|(
name|ac
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|amr_freecmds
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|amr_freecmds
argument_list|,
name|ac_link
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|ac
operator|)
return|;
end_return

unit|}
end_unit

