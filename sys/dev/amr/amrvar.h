begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999,2000 Michael Smith  * Copyright (c) 2000 BSDi  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      $FreeBSD$  */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500005
end_if

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AMR_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|debug
parameter_list|(
name|level
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|do {if (level<= AMR_DEBUG) printf("%s: " fmt "\n", __FUNCTION__ , ##args);} while(0)
end_define

begin_define
define|#
directive|define
name|debug_called
parameter_list|(
name|level
parameter_list|)
value|do {if (level<= AMR_DEBUG) printf("%s: called\n", __FUNCTION__);} while(0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debug
parameter_list|(
name|level
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|debug_called
parameter_list|(
name|level
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|xdebug
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|printf("%s: " fmt "\n", __FUNCTION__ , ##args)
end_define

begin_comment
comment|/*  * Per-logical-drive datastructure  */
end_comment

begin_struct
struct|struct
name|amr_logdrive
block|{
name|u_int32_t
name|al_size
decl_stmt|;
name|int
name|al_state
decl_stmt|;
name|int
name|al_properties
decl_stmt|;
comment|/* synthetic geometry */
name|int
name|al_cylinders
decl_stmt|;
name|int
name|al_heads
decl_stmt|;
name|int
name|al_sectors
decl_stmt|;
comment|/* driver */
name|device_t
name|al_disk
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Due to the difficulty of using the zone allocator to create a new  * zone from within a module, we use our own clustering to reduce   * memory wastage due to allocating lots of these small structures.  *  * 16k gives us a little under 200 command structures, which should  * normally be plenty.  We will grab more if we need them.  */
end_comment

begin_define
define|#
directive|define
name|AMR_CMD_CLUSTERSIZE
value|(16 * 1024)
end_define

begin_comment
comment|/*  * Per-command control structure.  */
end_comment

begin_struct
struct|struct
name|amr_command
block|{
name|TAILQ_ENTRY
argument_list|(
argument|amr_command
argument_list|)
name|ac_link
expr_stmt|;
name|struct
name|amr_softc
modifier|*
name|ac_sc
decl_stmt|;
name|u_int8_t
name|ac_slot
decl_stmt|;
name|int
name|ac_status
decl_stmt|;
comment|/* command completion status */
name|struct
name|amr_mailbox
name|ac_mailbox
decl_stmt|;
name|int
name|ac_flags
decl_stmt|;
define|#
directive|define
name|AMR_CMD_DATAIN
value|(1<<0)
define|#
directive|define
name|AMR_CMD_DATAOUT
value|(1<<1)
define|#
directive|define
name|AMR_CMD_CCB_DATAIN
value|(1<<2)
define|#
directive|define
name|AMR_CMD_CCB_DATAOUT
value|(1<<3)
define|#
directive|define
name|AMR_CMD_PRIORITY
value|(1<<4)
define|#
directive|define
name|AMR_CMD_MAPPED
value|(1<<5)
define|#
directive|define
name|AMR_CMD_SLEEP
value|(1<<6)
define|#
directive|define
name|AMR_CMD_BUSY
value|(1<<7)
name|struct
name|bio
modifier|*
name|ac_bio
decl_stmt|;
name|void
modifier|*
name|ac_data
decl_stmt|;
name|size_t
name|ac_length
decl_stmt|;
name|bus_dmamap_t
name|ac_dmamap
decl_stmt|;
name|u_int32_t
name|ac_dataphys
decl_stmt|;
name|void
modifier|*
name|ac_ccb_data
decl_stmt|;
name|size_t
name|ac_ccb_length
decl_stmt|;
name|bus_dmamap_t
name|ac_ccb_dmamap
decl_stmt|;
name|u_int32_t
name|ac_ccb_dataphys
decl_stmt|;
name|void
function_decl|(
modifier|*
name|ac_complete
function_decl|)
parameter_list|(
name|struct
name|amr_command
modifier|*
name|ac
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|amr_command_cluster
block|{
name|TAILQ_ENTRY
argument_list|(
argument|amr_command_cluster
argument_list|)
name|acc_link
expr_stmt|;
name|struct
name|amr_command
name|acc_command
index|[
literal|0
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|AMR_CMD_CLUSTERCOUNT
value|((AMR_CMD_CLUSTERSIZE - sizeof(struct amr_command_cluster)) /	\ 				 sizeof(struct amr_command))
end_define

begin_comment
comment|/*  * Per-controller-instance data  */
end_comment

begin_struct
struct|struct
name|amr_softc
block|{
comment|/* bus attachments */
name|device_t
name|amr_dev
decl_stmt|;
name|struct
name|resource
modifier|*
name|amr_reg
decl_stmt|;
comment|/* control registers */
name|bus_space_handle_t
name|amr_bhandle
decl_stmt|;
name|bus_space_tag_t
name|amr_btag
decl_stmt|;
name|bus_dma_tag_t
name|amr_parent_dmat
decl_stmt|;
comment|/* parent DMA tag */
name|bus_dma_tag_t
name|amr_buffer_dmat
decl_stmt|;
comment|/* data buffer DMA tag */
name|struct
name|resource
modifier|*
name|amr_irq
decl_stmt|;
comment|/* interrupt */
name|void
modifier|*
name|amr_intr
decl_stmt|;
comment|/* mailbox */
specifier|volatile
name|struct
name|amr_mailbox
modifier|*
name|amr_mailbox
decl_stmt|;
specifier|volatile
name|struct
name|amr_mailbox64
modifier|*
name|amr_mailbox64
decl_stmt|;
name|u_int32_t
name|amr_mailboxphys
decl_stmt|;
name|bus_dma_tag_t
name|amr_mailbox_dmat
decl_stmt|;
name|bus_dmamap_t
name|amr_mailbox_dmamap
decl_stmt|;
comment|/* scatter/gather lists and their controller-visible mappings */
name|struct
name|amr_sgentry
modifier|*
name|amr_sgtable
decl_stmt|;
comment|/* s/g lists */
name|u_int32_t
name|amr_sgbusaddr
decl_stmt|;
comment|/* s/g table base address in bus space */
name|bus_dma_tag_t
name|amr_sg_dmat
decl_stmt|;
comment|/* s/g buffer DMA tag */
name|bus_dmamap_t
name|amr_sg_dmamap
decl_stmt|;
comment|/* map for s/g buffers */
comment|/* controller limits and features */
name|int
name|amr_maxio
decl_stmt|;
comment|/* maximum number of I/O transactions */
name|int
name|amr_maxdrives
decl_stmt|;
comment|/* max number of logical drives */
name|int
name|amr_maxchan
decl_stmt|;
comment|/* count of SCSI channels */
comment|/* connected logical drives */
name|struct
name|amr_logdrive
name|amr_drive
index|[
name|AMR_MAXLD
index|]
decl_stmt|;
comment|/* controller state */
name|int
name|amr_state
decl_stmt|;
define|#
directive|define
name|AMR_STATE_OPEN
value|(1<<0)
define|#
directive|define
name|AMR_STATE_SUSPEND
value|(1<<1)
define|#
directive|define
name|AMR_STATE_INTEN
value|(1<<2)
define|#
directive|define
name|AMR_STATE_SHUTDOWN
value|(1<<3)
comment|/* per-controller queues */
name|struct
name|bio_queue_head
name|amr_bioq
decl_stmt|;
comment|/* pending I/O with no commands */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|amr_command
argument_list|)
name|amr_ready
expr_stmt|;
comment|/* commands ready to be submitted */
name|struct
name|amr_command
modifier|*
name|amr_busycmd
index|[
name|AMR_MAXCMD
index|]
decl_stmt|;
name|int
name|amr_busyslots
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|amr_command
argument_list|)
name|amr_completed
expr_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|amr_command
argument_list|)
name|amr_freecmds
expr_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|amr_command_cluster
argument_list|)
name|amr_cmd_clusters
expr_stmt|;
comment|/* CAM attachments for passthrough */
name|struct
name|cam_sim
modifier|*
name|amr_cam_sim
index|[
name|AMR_MAX_CHANNELS
index|]
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|ccb_hdr
argument_list|)
name|amr_cam_ccbq
expr_stmt|;
comment|/* control device */
name|dev_t
name|amr_dev_t
decl_stmt|;
comment|/* controller type-specific support */
name|int
name|amr_type
decl_stmt|;
define|#
directive|define
name|AMR_TYPE_QUARTZ
value|(1<<0)
define|#
directive|define
name|AMR_IS_QUARTZ
parameter_list|(
name|sc
parameter_list|)
value|((sc)->amr_type& AMR_TYPE_QUARTZ)
define|#
directive|define
name|AMR_TYPE_40LD
value|(1<<1)
define|#
directive|define
name|AMR_IS_40LD
parameter_list|(
name|sc
parameter_list|)
value|((sc)->amr_type& AMR_TYPE_40LD)
name|int
function_decl|(
modifier|*
name|amr_submit_command
function_decl|)
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|amr_get_work
function_decl|)
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|amr_mailbox
modifier|*
name|mbsave
parameter_list|)
function_decl|;
comment|/* misc glue */
name|struct
name|intr_config_hook
name|amr_ich
decl_stmt|;
comment|/* wait-for-interrupts probe hook */
name|struct
name|callout_handle
name|amr_timeout
decl_stmt|;
comment|/* periodic status check */
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500005
name|struct
name|task
name|amr_task_complete
decl_stmt|;
comment|/* deferred-completion task */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/*  * Interface between bus connections and driver core.  */
end_comment

begin_function_decl
specifier|extern
name|int
name|amr_attach
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|amr_free
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|amr_flush
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|amr_done
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|amr_startio
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|devclass_t
name|amr_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Command buffer allocation.  */
end_comment

begin_function_decl
specifier|extern
name|struct
name|amr_command
modifier|*
name|amr_alloccmd
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|amr_releasecmd
parameter_list|(
name|struct
name|amr_command
modifier|*
name|ac
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * CAM interface  */
end_comment

begin_function_decl
specifier|extern
name|int
name|amr_cam_attach
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|amr_cam_detach
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|amr_cam_command
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|amr_command
modifier|*
modifier|*
name|acp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * MegaRAID logical disk driver  */
end_comment

begin_struct
struct|struct
name|amrd_softc
block|{
name|device_t
name|amrd_dev
decl_stmt|;
name|dev_t
name|amrd_dev_t
decl_stmt|;
name|struct
name|amr_softc
modifier|*
name|amrd_controller
decl_stmt|;
name|struct
name|amr_logdrive
modifier|*
name|amrd_drive
decl_stmt|;
name|struct
name|disk
name|amrd_disk
decl_stmt|;
name|struct
name|devstat
name|amrd_stats
decl_stmt|;
name|struct
name|disklabel
name|amrd_label
decl_stmt|;
name|int
name|amrd_unit
decl_stmt|;
name|int
name|amrd_flags
decl_stmt|;
define|#
directive|define
name|AMRD_OPEN
value|(1<<0)
comment|/* drive is open (can't detach) */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Interface between driver core and disk driver (should be using a bus?)  */
end_comment

begin_function_decl
specifier|extern
name|int
name|amr_submit_bio
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|amrd_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/********************************************************************************  * Enqueue/dequeue functions  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|amr_enqueue_bio
parameter_list|(
name|struct
name|amr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bio
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|sc
operator|->
name|amr_bioq
argument_list|,
name|bio
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|bio
operator|*
name|amr_dequeue_bio
argument_list|(
argument|struct amr_softc *sc
argument_list|)
block|{     struct
name|bio
operator|*
name|bio
block|;
name|int
name|s
block|;
name|s
operator|=
name|splbio
argument_list|()
block|;
if|if
condition|(
operator|(
name|bio
operator|=
name|bioq_first
argument_list|(
operator|&
name|sc
operator|->
name|amr_bioq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|amr_bioq
argument_list|,
name|bio
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|bio
operator|)
return|;
end_return

begin_function
unit|}  static
name|__inline
name|void
name|amr_enqueue_ready
parameter_list|(
name|struct
name|amr_command
modifier|*
name|ac
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ac
operator|->
name|ac_sc
operator|->
name|amr_ready
argument_list|,
name|ac
argument_list|,
name|ac_link
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|amr_requeue_ready
parameter_list|(
name|struct
name|amr_command
modifier|*
name|ac
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ac
operator|->
name|ac_sc
operator|->
name|amr_ready
argument_list|,
name|ac
argument_list|,
name|ac_link
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|amr_command
operator|*
name|amr_dequeue_ready
argument_list|(
argument|struct amr_softc *sc
argument_list|)
block|{     struct
name|amr_command
operator|*
name|ac
block|;
name|int
name|s
block|;
name|s
operator|=
name|splbio
argument_list|()
block|;
if|if
condition|(
operator|(
name|ac
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|amr_ready
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|amr_ready
argument_list|,
name|ac
argument_list|,
name|ac_link
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|ac
operator|)
return|;
end_return

begin_function
unit|}  static
name|__inline
name|void
name|amr_enqueue_completed
parameter_list|(
name|struct
name|amr_command
modifier|*
name|ac
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ac
operator|->
name|ac_sc
operator|->
name|amr_completed
argument_list|,
name|ac
argument_list|,
name|ac_link
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|amr_command
operator|*
name|amr_dequeue_completed
argument_list|(
argument|struct amr_softc *sc
argument_list|)
block|{     struct
name|amr_command
operator|*
name|ac
block|;
name|int
name|s
block|;
name|s
operator|=
name|splbio
argument_list|()
block|;
if|if
condition|(
operator|(
name|ac
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|amr_completed
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|amr_completed
argument_list|,
name|ac
argument_list|,
name|ac_link
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|ac
operator|)
return|;
end_return

begin_function
unit|}  static
name|__inline
name|void
name|amr_enqueue_free
parameter_list|(
name|struct
name|amr_command
modifier|*
name|ac
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ac
operator|->
name|ac_sc
operator|->
name|amr_freecmds
argument_list|,
name|ac
argument_list|,
name|ac_link
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|amr_command
operator|*
name|amr_dequeue_free
argument_list|(
argument|struct amr_softc *sc
argument_list|)
block|{     struct
name|amr_command
operator|*
name|ac
block|;
name|int
name|s
block|;
name|s
operator|=
name|splbio
argument_list|()
block|;
if|if
condition|(
operator|(
name|ac
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|amr_freecmds
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|amr_freecmds
argument_list|,
name|ac
argument_list|,
name|ac_link
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|ac
operator|)
return|;
end_return

unit|}
end_unit

