begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for the Atheros Wireless LAN controller.  *  * This software is derived from work of Atsushi Onoe; his contribution  * is greatly appreciated.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ath.h"
end_include

begin_comment
comment|/*  * This is needed for register operations which are performed  * by the driver - eg, calls to ath_hal_gettsf32().  *  * It's also required for any AH_DEBUG checks in here, eg the  * module dependencies.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_comment
comment|/* for mp_ncpus */
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_superg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ath/if_athvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_misc.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tx.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_beacon.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
end_ifdef

begin_include
include|#
directive|include
file|<dev/ath/ath_tx99/ath_tx99.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Setup a h/w transmit queue for beacons.  */
end_comment

begin_function
name|int
name|ath_beaconq_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_TXQ_INFO
name|qi
decl_stmt|;
name|memset
argument_list|(
operator|&
name|qi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|qi
argument_list|)
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_aifs
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmin
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmax
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
comment|/* NB: for dynamic turbo, don't enable any other interrupts */
name|qi
operator|.
name|tqi_qflags
operator|=
name|HAL_TXQ_TXDESCINT_ENABLE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_isedma
condition|)
name|qi
operator|.
name|tqi_qflags
operator||=
name|HAL_TXQ_TXOKINT_ENABLE
operator||
name|HAL_TXQ_TXERRINT_ENABLE
expr_stmt|;
return|return
name|ath_hal_setuptxqueue
argument_list|(
name|ah
argument_list|,
name|HAL_TX_QUEUE_BEACON
argument_list|,
operator|&
name|qi
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Setup the transmit queue parameters for the beacon queue.  */
end_comment

begin_function
name|int
name|ath_beaconq_config
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
define|#
directive|define
name|ATH_EXPONENT_TO_VALUE
parameter_list|(
name|v
parameter_list|)
value|((1<<(v))-1)
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|sc
operator|->
name|sc_ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_TXQ_INFO
name|qi
decl_stmt|;
name|ath_hal_gettxqueueprops
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
operator|&
name|qi
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
comment|/* 		 * Always burst out beacon and CAB traffic. 		 */
name|qi
operator|.
name|tqi_aifs
operator|=
name|ATH_BEACON_AIFS_DEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmin
operator|=
name|ATH_BEACON_CWMIN_DEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmax
operator|=
name|ATH_BEACON_CWMAX_DEFAULT
expr_stmt|;
block|}
else|else
block|{
name|struct
name|wmeParams
modifier|*
name|wmep
init|=
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|WME_AC_BE
index|]
decl_stmt|;
comment|/* 		 * Adhoc mode; important thing is to use 2x cwmin. 		 */
name|qi
operator|.
name|tqi_aifs
operator|=
name|wmep
operator|->
name|wmep_aifsn
expr_stmt|;
name|qi
operator|.
name|tqi_cwmin
operator|=
literal|2
operator|*
name|ATH_EXPONENT_TO_VALUE
argument_list|(
name|wmep
operator|->
name|wmep_logcwmin
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_cwmax
operator|=
name|ATH_EXPONENT_TO_VALUE
argument_list|(
name|wmep
operator|->
name|wmep_logcwmax
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ath_hal_settxqueueprops
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
operator|&
name|qi
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to update parameters for "
literal|"beacon hardware queue!\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|ath_hal_resettxqueue
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
comment|/* push to h/w */
return|return
literal|1
return|;
block|}
undef|#
directive|undef
name|ATH_EXPONENT_TO_VALUE
block|}
end_function

begin_comment
comment|/*  * Allocate and setup an initial beacon frame.  */
end_comment

begin_function
name|int
name|ath_beacon_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bf
operator|=
name|avp
operator|->
name|av_bcbuf
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE
argument_list|,
literal|"%s: bf_m=%p, bf_node=%p\n"
argument_list|,
name|__func__
argument_list|,
name|bf
operator|->
name|bf_m
argument_list|,
name|bf
operator|->
name|bf_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_node
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * NB: the beacon data buffer must be 32-bit aligned; 	 * we assume the mbuf routines will return us something 	 * with this alignment (perhaps should assert). 	 */
name|m
operator|=
name|ieee80211_beacon_alloc
argument_list|(
name|ni
argument_list|,
operator|&
name|avp
operator|->
name|av_boff
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cannot get mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_nombuf
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cannot map mbuf, bus_dmamap_load_mbuf_sg returns %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Calculate a TSF adjustment factor required for staggered 	 * beacons.  Note that we assume the format of the beacon 	 * frame leaves the tstamp field immediately following the 	 * header. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_stagbeacons
operator|&&
name|avp
operator|->
name|av_bslot
operator|>
literal|0
condition|)
block|{
name|uint64_t
name|tsfadjust
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
comment|/* 		 * The beacon interval is in TU's; the TSF is in usecs. 		 * We figure out how many TU's to add to align the timestamp 		 * then convert to TSF units and handle byte swapping before 		 * inserting it in the frame.  The hardware will then add this 		 * each time a beacon frame is sent.  Note that we align vap's 		 * 1..N and leave vap 0 untouched.  This means vap 0 has a 		 * timestamp in one beacon interval while the others get a 		 * timstamp aligned to the next interval. 		 */
name|tsfadjust
operator|=
name|ni
operator|->
name|ni_intval
operator|*
operator|(
name|ATH_BCBUF
operator|-
name|avp
operator|->
name|av_bslot
operator|)
operator|/
name|ATH_BCBUF
expr_stmt|;
name|tsfadjust
operator|=
name|htole64
argument_list|(
name|tsfadjust
operator|<<
literal|10
argument_list|)
expr_stmt|;
comment|/* TU -> TSF */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: %s beacons bslot %d intval %u tsfadjust %llu\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_stagbeacons
condition|?
literal|"stagger"
else|:
literal|"burst"
argument_list|,
name|avp
operator|->
name|av_bslot
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|,
operator|(
name|long
name|long
name|unsigned
operator|)
name|le64toh
argument_list|(
name|tsfadjust
argument_list|)
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|wh
index|[
literal|1
index|]
argument_list|,
operator|&
name|tsfadjust
argument_list|,
sizeof|sizeof
argument_list|(
name|tsfadjust
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bf
operator|->
name|bf_m
operator|=
name|m
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Setup the beacon frame for transmit.  */
end_comment

begin_function
specifier|static
name|void
name|ath_beacon_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
define|#
directive|define
name|USE_SHPREAMBLE
parameter_list|(
name|_ic
parameter_list|)
define|\
value|(((_ic)->ic_flags& (IEEE80211_F_SHPREAMBLE | IEEE80211_F_USEBARKER))\ 		== IEEE80211_F_SHPREAMBLE)
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|bf
operator|->
name|bf_m
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|antenna
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|u_int8_t
name|rix
decl_stmt|,
name|rate
decl_stmt|;
name|HAL_DMA_ADDR
name|bufAddrList
index|[
literal|4
index|]
decl_stmt|;
name|uint32_t
name|segLenList
index|[
literal|4
index|]
decl_stmt|;
name|HAL_11N_RATE_SERIES
name|rc
index|[
literal|4
index|]
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON_PROC
argument_list|,
literal|"%s: m %p len %u\n"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
comment|/* setup descriptors */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|bf
operator|->
name|bf_last
operator|=
name|bf
expr_stmt|;
name|bf
operator|->
name|bf_lastds
operator|=
name|ds
expr_stmt|;
name|flags
operator|=
name|HAL_TXDESC_NOACK
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|&&
name|sc
operator|->
name|sc_hasveol
condition|)
block|{
comment|/* self-linked descriptor */
name|ath_hal_settxdesclink
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|ds
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|flags
operator||=
name|HAL_TXDESC_VEOL
expr_stmt|;
comment|/* 		 * Let hardware handle antenna switching. 		 */
name|antenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
block|}
else|else
block|{
name|ath_hal_settxdesclink
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|ds
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Switch antenna every 4 beacons. 		 * XXX assumes two antenna 		 */
if|if
condition|(
name|sc
operator|->
name|sc_txantenna
operator|!=
literal|0
condition|)
name|antenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_stagbeacons
operator|&&
name|sc
operator|->
name|sc_nbcnvaps
operator|!=
literal|0
condition|)
name|antenna
operator|=
operator|(
operator|(
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_xmit
operator|/
name|sc
operator|->
name|sc_nbcnvaps
operator|)
operator|&
literal|4
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
else|else
name|antenna
operator|=
operator|(
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_xmit
operator|&
literal|4
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|bf
operator|->
name|bf_nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"multi-segment beacon frame; nseg %u"
operator|,
name|bf
operator|->
name|bf_nseg
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate rate code. 	 * XXX everything at min xmit rate 	 */
name|rix
operator|=
literal|0
expr_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
name|rate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|USE_SHPREAMBLE
argument_list|(
name|ic
argument_list|)
condition|)
name|rate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|ath_hal_setuptxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|m
operator|->
name|m_len
operator|+
name|IEEE80211_CRC_LEN
comment|/* frame length */
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
comment|/* header length */
argument_list|,
name|HAL_PKT_TYPE_BEACON
comment|/* Atheros packet type */
argument_list|,
name|ieee80211_get_node_txpower
argument_list|(
name|ni
argument_list|)
comment|/* txpower XXX */
argument_list|,
name|rate
argument_list|,
literal|1
comment|/* series 0 rate/tries */
argument_list|,
name|HAL_TXKEYIX_INVALID
comment|/* no encryption */
argument_list|,
name|antenna
comment|/* antenna mode */
argument_list|,
name|flags
comment|/* no ack, veol for beacons */
argument_list|,
literal|0
comment|/* rts/cts rate */
argument_list|,
literal|0
comment|/* rts/cts duration */
argument_list|)
expr_stmt|;
comment|/* 	 * The EDMA HAL currently assumes that _all_ rate control 	 * settings are done in ath_hal_set11nratescenario(), rather 	 * than in ath_hal_setuptxdesc(). 	 */
if|if
condition|(
name|sc
operator|->
name|sc_isedma
condition|)
block|{
name|memset
argument_list|(
operator|&
name|rc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
name|rc
index|[
literal|0
index|]
operator|.
name|ChSel
operator|=
name|sc
operator|->
name|sc_txchainmask
expr_stmt|;
name|rc
index|[
literal|0
index|]
operator|.
name|Tries
operator|=
literal|1
expr_stmt|;
name|rc
index|[
literal|0
index|]
operator|.
name|Rate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
name|rc
index|[
literal|0
index|]
operator|.
name|RateIndex
operator|=
name|rix
expr_stmt|;
name|rc
index|[
literal|0
index|]
operator|.
name|tx_power_cap
operator|=
literal|0x3f
expr_stmt|;
name|rc
index|[
literal|0
index|]
operator|.
name|PktDuration
operator|=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|roundup
argument_list|(
name|m
operator|->
name|m_len
argument_list|,
literal|4
argument_list|)
argument_list|,
name|rix
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ath_hal_set11nratescenario
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|rc
argument_list|,
literal|4
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* NB: beacon's BufLen must be a multiple of 4 bytes */
name|segLenList
index|[
literal|0
index|]
operator|=
name|roundup
argument_list|(
name|m
operator|->
name|m_len
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|segLenList
index|[
literal|1
index|]
operator|=
name|segLenList
index|[
literal|2
index|]
operator|=
name|segLenList
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|bufAddrList
index|[
literal|0
index|]
operator|=
name|bf
operator|->
name|bf_segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|bufAddrList
index|[
literal|1
index|]
operator|=
name|bufAddrList
index|[
literal|2
index|]
operator|=
name|bufAddrList
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|ath_hal_filltxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|bufAddrList
argument_list|,
name|segLenList
argument_list|,
literal|0
comment|/* XXX desc id */
argument_list|,
name|sc
operator|->
name|sc_bhalq
comment|/* hardware TXQ */
argument_list|,
name|AH_TRUE
comment|/* first segment */
argument_list|,
name|AH_TRUE
comment|/* last segment */
argument_list|,
name|ds
comment|/* first descriptor */
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|ath_desc_swap(ds);
endif|#
directive|endif
undef|#
directive|undef
name|USE_SHPREAMBLE
block|}
end_function

begin_function
name|void
name|ath_beacon_update
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|item
parameter_list|)
block|{
name|struct
name|ieee80211_beacon_offsets
modifier|*
name|bo
init|=
operator|&
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|av_boff
decl_stmt|;
name|setbit
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a beacon miss.  */
end_comment

begin_function
name|void
name|ath_beacon_miss
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|HAL_SURVEY_SAMPLE
name|hs
decl_stmt|;
name|HAL_BOOL
name|ret
decl_stmt|;
name|uint32_t
name|hangs
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|hs
argument_list|,
sizeof|sizeof
argument_list|(
name|hs
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ath_hal_get_mib_cycle_counts
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|hs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_hal_gethangstate
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0xffff
argument_list|,
operator|&
name|hangs
argument_list|)
operator|&&
name|hangs
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: hang=0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|hangs
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ATH_DEBUG_ALQ
if|if
condition|(
name|if_ath_alq_checkdebug
argument_list|(
operator|&
name|sc
operator|->
name|sc_alq
argument_list|,
name|ATH_ALQ_MISSED_BEACON
argument_list|)
condition|)
name|if_ath_alq_post
argument_list|(
operator|&
name|sc
operator|->
name|sc_alq
argument_list|,
name|ATH_ALQ_MISSED_BEACON
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: valid=%d, txbusy=%u, rxbusy=%u, chanbusy=%u, "
literal|"extchanbusy=%u, cyclecount=%u\n"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|,
name|hs
operator|.
name|tx_busy
argument_list|,
name|hs
operator|.
name|rx_busy
argument_list|,
name|hs
operator|.
name|chan_busy
argument_list|,
name|hs
operator|.
name|ext_chan_busy
argument_list|,
name|hs
operator|.
name|cycle_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Transmit a beacon frame at SWBA.  Dynamic updates to the  * frame contents are done as needed and the slot time is  * also adjusted based on current state.  */
end_comment

begin_function
name|void
name|ath_beacon_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|otherant
decl_stmt|;
name|uint32_t
name|bfaddr
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON_PROC
argument_list|,
literal|"%s: pending %u\n"
argument_list|,
name|__func__
argument_list|,
name|pending
argument_list|)
expr_stmt|;
comment|/* 	 * Check if the previous beacon has gone out.  If 	 * not don't try to post another, skip this period 	 * and wait for the next.  Missed beacons indicate 	 * a problem and should not occur.  If we miss too 	 * many consecutive beacons reset the device. 	 */
if|if
condition|(
name|ath_hal_numtxpending
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_bmisscount
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_missed
operator|++
expr_stmt|;
name|ath_beacon_miss
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: missed %u consecutive beacons\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bmisscount
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bmisscount
operator|>=
name|ath_bstuck_threshold
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_bstucktask
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_bmisscount
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: resume beacon xmit after %u misses\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bmisscount
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bmisscount
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG_ALQ
if|if
condition|(
name|if_ath_alq_checkdebug
argument_list|(
operator|&
name|sc
operator|->
name|sc_alq
argument_list|,
name|ATH_ALQ_RESUME_BEACON
argument_list|)
condition|)
name|if_ath_alq_post
argument_list|(
operator|&
name|sc
operator|->
name|sc_alq
argument_list|,
name|ATH_ALQ_RESUME_BEACON
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|sc
operator|->
name|sc_stagbeacons
condition|)
block|{
comment|/* staggered beacons */
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|sc
operator|->
name|sc_ifp
operator|->
name|if_l2com
decl_stmt|;
name|uint32_t
name|tsftu
decl_stmt|;
name|tsftu
operator|=
name|ath_hal_gettsf32
argument_list|(
name|ah
argument_list|)
operator|>>
literal|10
expr_stmt|;
comment|/* XXX lintval */
name|slot
operator|=
operator|(
operator|(
name|tsftu
operator|%
name|ic
operator|->
name|ic_lintval
operator|)
operator|*
name|ATH_BCBUF
operator|)
operator|/
name|ic
operator|->
name|ic_lintval
expr_stmt|;
name|vap
operator|=
name|sc
operator|->
name|sc_bslot
index|[
operator|(
name|slot
operator|+
literal|1
operator|)
operator|%
name|ATH_BCBUF
index|]
expr_stmt|;
name|bfaddr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vap
operator|!=
name|NULL
operator|&&
name|vap
operator|->
name|iv_state
operator|>=
name|IEEE80211_S_RUN
condition|)
block|{
name|bf
operator|=
name|ath_beacon_generate
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
name|bfaddr
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* burst'd beacons */
name|uint32_t
modifier|*
name|bflink
init|=
operator|&
name|bfaddr
decl_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|ATH_BCBUF
condition|;
name|slot
operator|++
control|)
block|{
name|vap
operator|=
name|sc
operator|->
name|sc_bslot
index|[
name|slot
index|]
expr_stmt|;
if|if
condition|(
name|vap
operator|!=
name|NULL
operator|&&
name|vap
operator|->
name|iv_state
operator|>=
name|IEEE80211_S_RUN
condition|)
block|{
name|bf
operator|=
name|ath_beacon_generate
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
comment|/* 				 * XXX TODO: this should use settxdesclinkptr() 				 * otherwise it won't work for EDMA chipsets! 				 */
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX should do this using the ds */
operator|*
name|bflink
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
name|ath_hal_gettxdesclinkptr
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
operator|&
name|bflink
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * XXX TODO: this should use settxdesclinkptr() 		 * otherwise it won't work for EDMA chipsets! 		 */
operator|*
name|bflink
operator|=
literal|0
expr_stmt|;
comment|/* terminate list */
block|}
comment|/* 	 * Handle slot time change when a non-ERP station joins/leaves 	 * an 11g network.  The 802.11 layer notifies us via callback, 	 * we mark updateslot, then wait one beacon before effecting 	 * the change.  This gives associated stations at least one 	 * beacon interval to note the state change. 	 */
comment|/* XXX locking */
if|if
condition|(
name|sc
operator|->
name|sc_updateslot
operator|==
name|UPDATE
condition|)
block|{
name|sc
operator|->
name|sc_updateslot
operator|=
name|COMMIT
expr_stmt|;
comment|/* commit next beacon */
name|sc
operator|->
name|sc_slotupdate
operator|=
name|slot
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_updateslot
operator|==
name|COMMIT
operator|&&
name|sc
operator|->
name|sc_slotupdate
operator|==
name|slot
condition|)
name|ath_setslottime
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* commit change to h/w */
comment|/* 	 * Check recent per-antenna transmit statistics and flip 	 * the default antenna if noticeably more frames went out 	 * on the non-default antenna. 	 * XXX assumes 2 anntenae 	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_diversity
operator|&&
operator|(
operator|!
name|sc
operator|->
name|sc_stagbeacons
operator|||
name|slot
operator|==
literal|0
operator|)
condition|)
block|{
name|otherant
operator|=
name|sc
operator|->
name|sc_defant
operator|&
literal|1
condition|?
literal|2
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ant_tx
index|[
name|otherant
index|]
operator|>
name|sc
operator|->
name|sc_ant_tx
index|[
name|sc
operator|->
name|sc_defant
index|]
operator|+
literal|2
condition|)
name|ath_setdefantenna
argument_list|(
name|sc
argument_list|,
name|otherant
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ant_tx
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|sc_ant_tx
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Program the CABQ with the contents of the CABQ txq and start it */
name|ATH_TXQ_LOCK
argument_list|(
name|sc
operator|->
name|sc_cabq
argument_list|)
expr_stmt|;
name|ath_beacon_cabq_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_cabq
argument_list|)
expr_stmt|;
comment|/* Program the new beacon frame if we have one for this interval */
if|if
condition|(
name|bfaddr
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Stop any current dma and put the new frame on the queue. 		 * This should never fail since we check above that no frames 		 * are still pending on the queue. 		 */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_isedma
condition|)
block|{
if|if
condition|(
operator|!
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: beacon queue %u did not stop?\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* NB: cabq traffic should already be queued and primed */
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
name|bfaddr
argument_list|)
expr_stmt|;
name|ath_hal_txstart
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_xmit
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_beacon_cabq_start_edma
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|bf_last
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|cabq
init|=
name|sc
operator|->
name|sc_cabq
decl_stmt|;
if|#
directive|if
literal|0
block|struct ath_buf *bfi; 	int i = 0;
endif|#
directive|endif
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|cabq
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|cabq
operator|->
name|axq_q
argument_list|)
condition|)
return|return;
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|cabq
operator|->
name|axq_q
argument_list|)
expr_stmt|;
name|bf_last
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|cabq
operator|->
name|axq_q
argument_list|,
name|axq_q_s
argument_list|)
expr_stmt|;
comment|/* 	 * This is a dirty, dirty hack to push the contents of 	 * the cabq staging queue into the FIFO. 	 * 	 * This ideally should live in the EDMA code file 	 * and only push things into the CABQ if there's a FIFO 	 * slot. 	 * 	 * We can't treat this like a normal TX queue because 	 * in the case of multi-VAP traffic, we may have to flush 	 * the CABQ each new (staggered) beacon that goes out. 	 * But for non-staggered beacons, we could in theory 	 * handle multicast traffic for all VAPs in one FIFO 	 * push.  Just keep all of this in mind if you're wondering 	 * how to correctly/better handle multi-VAP CABQ traffic 	 * with EDMA. 	 */
comment|/* 	 * Is the CABQ FIFO free? If not, complain loudly and 	 * don't queue anything.  Maybe we'll flush the CABQ 	 * traffic, maybe we won't.  But that'll happen next 	 * beacon interval. 	 */
if|if
condition|(
name|cabq
operator|->
name|axq_fifo_depth
operator|>=
name|HAL_TXFIFO_DEPTH
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Q%d: CAB FIFO queue=%d?\n"
argument_list|,
name|__func__
argument_list|,
name|cabq
operator|->
name|axq_qnum
argument_list|,
name|cabq
operator|->
name|axq_fifo_depth
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Ok, so here's the gymnastics reqiured to make this 	 * all sensible. 	 */
comment|/* 	 * Tag the first/last buffer appropriately. 	 */
name|bf
operator|->
name|bf_flags
operator||=
name|ATH_BUF_FIFOPTR
expr_stmt|;
name|bf_last
operator|->
name|bf_flags
operator||=
name|ATH_BUF_FIFOEND
expr_stmt|;
if|#
directive|if
literal|0
block|i = 0; 	TAILQ_FOREACH(bfi,&cabq->axq_q, bf_list) { 		ath_printtxbuf(sc, bf, cabq->axq_qnum, i, 0); 		i++; 	}
endif|#
directive|endif
comment|/* 	 * We now need to push this set of frames onto the tail 	 * of the FIFO queue.  We don't adjust the aggregate 	 * count, only the queue depth counter(s). 	 * We also need to blank the link pointer now. 	 */
name|TAILQ_CONCAT
argument_list|(
operator|&
name|cabq
operator|->
name|fifo
operator|.
name|axq_q
argument_list|,
operator|&
name|cabq
operator|->
name|axq_q
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|cabq
operator|->
name|axq_link
operator|=
name|NULL
expr_stmt|;
name|cabq
operator|->
name|fifo
operator|.
name|axq_depth
operator|+=
name|cabq
operator|->
name|axq_depth
expr_stmt|;
name|cabq
operator|->
name|axq_depth
operator|=
literal|0
expr_stmt|;
comment|/* Bump FIFO queue */
name|cabq
operator|->
name|axq_fifo_depth
operator|++
expr_stmt|;
comment|/* Push the first entry into the hardware */
name|ath_hal_puttxbuf
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|cabq
operator|->
name|axq_qnum
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|cabq
operator|->
name|axq_flags
operator||=
name|ATH_TXQ_PUTRUNNING
expr_stmt|;
comment|/* NB: gated by beacon so safe to start here */
name|ath_hal_txstart
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|cabq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_beacon_cabq_start_legacy
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|cabq
init|=
name|sc
operator|->
name|sc_cabq
decl_stmt|;
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|cabq
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|cabq
operator|->
name|axq_q
argument_list|)
condition|)
return|return;
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|cabq
operator|->
name|axq_q
argument_list|)
expr_stmt|;
comment|/* Push the first entry into the hardware */
name|ath_hal_puttxbuf
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|cabq
operator|->
name|axq_qnum
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|cabq
operator|->
name|axq_flags
operator||=
name|ATH_TXQ_PUTRUNNING
expr_stmt|;
comment|/* NB: gated by beacon so safe to start here */
name|ath_hal_txstart
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|cabq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start CABQ transmission - this assumes that all frames are prepped  * and ready in the CABQ.  */
end_comment

begin_function
name|void
name|ath_beacon_cabq_start
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_txq
modifier|*
name|cabq
init|=
name|sc
operator|->
name|sc_cabq
decl_stmt|;
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|cabq
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|cabq
operator|->
name|axq_q
argument_list|)
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|sc_isedma
condition|)
name|ath_beacon_cabq_start_edma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|ath_beacon_cabq_start_legacy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ath_buf
modifier|*
name|ath_beacon_generate
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|cabq
init|=
name|sc
operator|->
name|sc_cabq
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|nmcastq
decl_stmt|,
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_state
operator|>=
name|IEEE80211_S_RUN
argument_list|,
operator|(
literal|"not running, state %d"
operator|,
name|vap
operator|->
name|iv_state
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|avp
operator|->
name|av_bcbuf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no beacon buffer"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Update dynamic beacon contents.  If this returns 	 * non-zero then we need to remap the memory because 	 * the beacon frame changed size (probably because 	 * of the TIM bitmap). 	 */
name|bf
operator|=
name|avp
operator|->
name|av_bcbuf
expr_stmt|;
name|m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
comment|/* XXX lock mcastq? */
name|nmcastq
operator|=
name|avp
operator|->
name|av_mcastq
operator|.
name|axq_depth
expr_stmt|;
if|if
condition|(
name|ieee80211_beacon_update
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|,
operator|&
name|avp
operator|->
name|av_boff
argument_list|,
name|m
argument_list|,
name|nmcastq
argument_list|)
condition|)
block|{
comment|/* XXX too conservative? */
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|vap
operator|->
name|iv_ifp
argument_list|,
literal|"%s: bus_dmamap_load_mbuf_sg failed, error %u\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
operator|(
name|avp
operator|->
name|av_boff
operator|.
name|bo_tim
index|[
literal|4
index|]
operator|&
literal|1
operator|)
operator|&&
name|cabq
operator|->
name|axq_depth
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: cabq did not drain, mcastq %u cabq %u\n"
argument_list|,
name|__func__
argument_list|,
name|nmcastq
argument_list|,
name|cabq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_cabq_busy
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
operator|>
literal|1
operator|&&
name|sc
operator|->
name|sc_stagbeacons
condition|)
block|{
comment|/* 			 * CABQ traffic from a previous vap is still pending. 			 * We must drain the q before this beacon frame goes 			 * out as otherwise this vap's stations will get cab 			 * frames from a different vap. 			 * XXX could be slow causing us to miss DBA 			 */
comment|/* 			 * XXX TODO: this doesn't stop CABQ DMA - it assumes 			 * that since we're about to transmit a beacon, we've 			 * already stopped transmitting on the CABQ.  But this 			 * doesn't at all mean that the CABQ DMA QCU will 			 * accept a new TXDP!  So what, should we do a DMA 			 * stop? What if it fails? 			 * 			 * More thought is required here. 			 */
comment|/* 			 * XXX can we even stop TX DMA here? Check what the 			 * reference driver does for cabq for beacons, given 			 * that stopping TX requires RX is paused. 			 */
name|ath_tx_draintxq
argument_list|(
name|sc
argument_list|,
name|cabq
argument_list|)
expr_stmt|;
block|}
block|}
name|ath_beacon_setup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Enable the CAB queue before the beacon queue to 	 * insure cab frames are triggered by this beacon. 	 */
if|if
condition|(
name|avp
operator|->
name|av_boff
operator|.
name|bo_tim
index|[
literal|4
index|]
operator|&
literal|1
condition|)
block|{
comment|/* NB: only at DTIM */
name|ATH_TXQ_LOCK
argument_list|(
operator|&
name|avp
operator|->
name|av_mcastq
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmcastq
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|bfm
decl_stmt|,
modifier|*
name|bfc_last
decl_stmt|;
comment|/* 			 * Move frames from the s/w mcast q to the h/w cab q. 			 * 			 * XXX TODO: if we chain together multiple VAPs 			 * worth of CABQ traffic, should we keep the 			 * MORE data bit set on the last frame of each 			 * intermediary VAP (ie, only clear the MORE 			 * bit of the last frame on the last vap?) 			 */
name|bfm
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|avp
operator|->
name|av_mcastq
operator|.
name|axq_q
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK
argument_list|(
name|cabq
argument_list|)
expr_stmt|;
comment|/* 			 * If there's already a frame on the CABQ, we 			 * need to link to the end of the last frame. 			 * We can't use axq_link here because 			 * EDMA descriptors require some recalculation 			 * (checksum) to occur. 			 */
name|bfc_last
operator|=
name|ATH_TXQ_LAST
argument_list|(
name|cabq
argument_list|,
name|axq_q_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfc_last
operator|!=
name|NULL
condition|)
block|{
name|ath_hal_settxdesclink
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bfc_last
operator|->
name|bf_lastds
argument_list|,
name|bfm
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
block|}
name|ath_txqmove
argument_list|(
name|cabq
argument_list|,
operator|&
name|avp
operator|->
name|av_mcastq
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|cabq
argument_list|)
expr_stmt|;
comment|/* 			 * XXX not entirely accurate, in case a mcast 			 * queue frame arrived before we grabbed the TX 			 * lock. 			 */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_cabq_xmit
operator|+=
name|nmcastq
expr_stmt|;
block|}
name|ATH_TXQ_UNLOCK
argument_list|(
operator|&
name|avp
operator|->
name|av_mcastq
argument_list|)
expr_stmt|;
block|}
return|return
name|bf
return|;
block|}
end_function

begin_function
name|void
name|ath_beacon_start_adhoc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|avp
operator|->
name|av_bcbuf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no beacon buffer"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Update dynamic beacon contents.  If this returns 	 * non-zero then we need to remap the memory because 	 * the beacon frame changed size (probably because 	 * of the TIM bitmap). 	 */
name|bf
operator|=
name|avp
operator|->
name|av_bcbuf
expr_stmt|;
name|m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
if|if
condition|(
name|ieee80211_beacon_update
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|,
operator|&
name|avp
operator|->
name|av_boff
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* XXX too conservative? */
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|vap
operator|->
name|iv_ifp
argument_list|,
literal|"%s: bus_dmamap_load_mbuf_sg failed, error %u\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ath_beacon_setup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* NB: caller is known to have already stopped tx dma */
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|ath_hal_txstart
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim beacon resources and return buffer to the pool.  */
end_comment

begin_function
name|void
name|ath_beacon_return
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE
argument_list|,
literal|"%s: free bf=%p, bf_m=%p, bf_node=%p\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|bf
operator|->
name|bf_m
argument_list|,
name|bf
operator|->
name|bf_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_node
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim beacon resources.  */
end_comment

begin_function
name|void
name|ath_beacon_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->sc_bbuf
argument_list|,
argument|bf_list
argument_list|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE
argument_list|,
literal|"%s: free bf=%p, bf_m=%p, bf_node=%p\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|bf
operator|->
name|bf_m
argument_list|,
name|bf
operator|->
name|bf_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_node
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Configure the beacon and sleep timers.  *  * When operating as an AP this resets the TSF and sets  * up the hardware to notify us when we need to issue beacons.  *  * When operating in station mode this sets up the beacon  * timers according to the timestamp of the last received  * beacon and the current TSF, configures PCF and DTIM  * handling, programs the sleep registers so the hardware  * will wakeup in time to receive beacons, and configures  * the beacon miss handling so we'll receive a BMISS  * interrupt when we stop seeing beacons from the AP  * we've associated with.  */
end_comment

begin_function
name|void
name|ath_beacon_config
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
define|#
directive|define
name|TSF_TO_TU
parameter_list|(
name|_h
parameter_list|,
name|_l
parameter_list|)
define|\
value|((((u_int32_t)(_h))<< 22) | (((u_int32_t)(_l))>> 10))
define|#
directive|define
name|FUDGE
value|2
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|sc
operator|->
name|sc_ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|u_int32_t
name|nexttbtt
decl_stmt|,
name|intval
decl_stmt|,
name|tsftu
decl_stmt|;
name|u_int32_t
name|nexttbtt_u8
decl_stmt|,
name|intval_u8
decl_stmt|;
name|u_int64_t
name|tsf
decl_stmt|,
name|tsf_beacon
decl_stmt|;
if|if
condition|(
name|vap
operator|==
name|NULL
condition|)
name|vap
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/* 	 * Just ensure that we aren't being called when the last 	 * VAP is destroyed. 	 */
if|if
condition|(
name|vap
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called with no VAPs\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* extract tstamp from last beacon and convert to TU */
name|nexttbtt
operator|=
name|TSF_TO_TU
argument_list|(
name|LE_READ_4
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
operator|+
literal|4
argument_list|)
argument_list|,
name|LE_READ_4
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|tsf_beacon
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|LE_READ_4
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
operator|+
literal|4
argument_list|)
operator|)
operator|<<
literal|32
expr_stmt|;
name|tsf_beacon
operator||=
name|LE_READ_4
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
comment|/* 		 * For multi-bss ap/mesh support beacons are either staggered 		 * evenly over N slots or burst together.  For the former 		 * arrange for the SWBA to be delivered for each slot. 		 * Slots that are not occupied will generate nothing. 		 */
comment|/* NB: the beacon interval is kept internally in TU's */
name|intval
operator|=
name|ni
operator|->
name|ni_intval
operator|&
name|HAL_BEACON_PERIOD
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_stagbeacons
condition|)
name|intval
operator|/=
name|ATH_BCBUF
expr_stmt|;
block|}
else|else
block|{
comment|/* NB: the beacon interval is kept internally in TU's */
name|intval
operator|=
name|ni
operator|->
name|ni_intval
operator|&
name|HAL_BEACON_PERIOD
expr_stmt|;
block|}
if|if
condition|(
name|nexttbtt
operator|==
literal|0
condition|)
comment|/* e.g. for ap mode */
name|nexttbtt
operator|=
name|intval
expr_stmt|;
elseif|else
if|if
condition|(
name|intval
condition|)
comment|/* NB: can be 0 for monitor mode */
name|nexttbtt
operator|=
name|roundup
argument_list|(
name|nexttbtt
argument_list|,
name|intval
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: nexttbtt %u intval %u (%u)\n"
argument_list|,
name|__func__
argument_list|,
name|nexttbtt
argument_list|,
name|intval
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
operator|!
name|sc
operator|->
name|sc_swbmiss
condition|)
block|{
name|HAL_BEACON_STATE
name|bs
decl_stmt|;
name|int
name|dtimperiod
decl_stmt|,
name|dtimcount
decl_stmt|;
name|int
name|cfpperiod
decl_stmt|,
name|cfpcount
decl_stmt|;
comment|/* 		 * Setup dtim and cfp parameters according to 		 * last beacon we received (which may be none). 		 */
name|dtimperiod
operator|=
name|ni
operator|->
name|ni_dtim_period
expr_stmt|;
if|if
condition|(
name|dtimperiod
operator|<=
literal|0
condition|)
comment|/* NB: 0 if not known */
name|dtimperiod
operator|=
literal|1
expr_stmt|;
name|dtimcount
operator|=
name|ni
operator|->
name|ni_dtim_count
expr_stmt|;
if|if
condition|(
name|dtimcount
operator|>=
name|dtimperiod
condition|)
comment|/* NB: sanity check */
name|dtimcount
operator|=
literal|0
expr_stmt|;
comment|/* XXX? */
name|cfpperiod
operator|=
literal|1
expr_stmt|;
comment|/* NB: no PCF support yet */
name|cfpcount
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Pull nexttbtt forward to reflect the current 		 * TSF and calculate dtim+cfp state for the result. 		 */
name|tsf
operator|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|tsftu
operator|=
name|TSF_TO_TU
argument_list|(
name|tsf
operator|>>
literal|32
argument_list|,
name|tsf
argument_list|)
operator|+
name|FUDGE
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: beacon tsf=%llu, hw tsf=%llu, nexttbtt=%u, tsftu=%u\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|tsf_beacon
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|tsf
argument_list|,
name|nexttbtt
argument_list|,
name|tsftu
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: beacon tsf=%llu, hw tsf=%llu, tsf delta=%lld\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|tsf_beacon
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|tsf
argument_list|,
operator|(
name|long
name|long
operator|)
name|tsf
operator|-
operator|(
name|long
name|long
operator|)
name|tsf_beacon
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: nexttbtt=%llu, beacon tsf delta=%lld\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|nexttbtt
argument_list|,
call|(
name|long
name|long
call|)
argument_list|(
operator|(
name|long
name|long
operator|)
name|nexttbtt
operator|*
literal|1024LL
argument_list|)
operator|-
operator|(
name|long
name|long
operator|)
name|tsf_beacon
argument_list|)
expr_stmt|;
comment|/* XXX cfpcount? */
if|if
condition|(
name|nexttbtt
operator|>
name|tsftu
condition|)
block|{
name|uint32_t
name|countdiff
decl_stmt|,
name|oldtbtt
decl_stmt|,
name|remainder
decl_stmt|;
name|oldtbtt
operator|=
name|nexttbtt
expr_stmt|;
name|remainder
operator|=
operator|(
name|nexttbtt
operator|-
name|tsftu
operator|)
operator|%
name|intval
expr_stmt|;
name|nexttbtt
operator|=
name|tsftu
operator|+
name|remainder
expr_stmt|;
name|countdiff
operator|=
operator|(
name|oldtbtt
operator|-
name|nexttbtt
operator|)
operator|/
name|intval
operator|%
name|dtimperiod
expr_stmt|;
if|if
condition|(
name|dtimcount
operator|>
name|countdiff
condition|)
block|{
name|dtimcount
operator|-=
name|countdiff
expr_stmt|;
block|}
else|else
block|{
name|dtimcount
operator|+=
name|dtimperiod
operator|-
name|countdiff
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//nexttbtt<= tsftu
name|uint32_t
name|countdiff
decl_stmt|,
name|oldtbtt
decl_stmt|,
name|remainder
decl_stmt|;
name|oldtbtt
operator|=
name|nexttbtt
expr_stmt|;
name|remainder
operator|=
operator|(
name|tsftu
operator|-
name|nexttbtt
operator|)
operator|%
name|intval
expr_stmt|;
name|nexttbtt
operator|=
name|tsftu
operator|-
name|remainder
operator|+
name|intval
expr_stmt|;
name|countdiff
operator|=
operator|(
name|nexttbtt
operator|-
name|oldtbtt
operator|)
operator|/
name|intval
operator|%
name|dtimperiod
expr_stmt|;
if|if
condition|(
name|dtimcount
operator|>
name|countdiff
condition|)
block|{
name|dtimcount
operator|-=
name|countdiff
expr_stmt|;
block|}
else|else
block|{
name|dtimcount
operator|+=
name|dtimperiod
operator|-
name|countdiff
expr_stmt|;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: adj nexttbtt=%llu, rx tsf delta=%lld\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|nexttbtt
argument_list|,
call|(
name|long
name|long
call|)
argument_list|(
operator|(
name|long
name|long
operator|)
name|nexttbtt
operator|*
literal|1024LL
argument_list|)
operator|-
operator|(
name|long
name|long
operator|)
name|tsf
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|bs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bs
argument_list|)
argument_list|)
expr_stmt|;
name|bs
operator|.
name|bs_intval
operator|=
name|intval
expr_stmt|;
name|bs
operator|.
name|bs_nexttbtt
operator|=
name|nexttbtt
expr_stmt|;
name|bs
operator|.
name|bs_dtimperiod
operator|=
name|dtimperiod
operator|*
name|intval
expr_stmt|;
name|bs
operator|.
name|bs_nextdtim
operator|=
name|bs
operator|.
name|bs_nexttbtt
operator|+
name|dtimcount
operator|*
name|intval
expr_stmt|;
name|bs
operator|.
name|bs_cfpperiod
operator|=
name|cfpperiod
operator|*
name|bs
operator|.
name|bs_dtimperiod
expr_stmt|;
name|bs
operator|.
name|bs_cfpnext
operator|=
name|bs
operator|.
name|bs_nextdtim
operator|+
name|cfpcount
operator|*
name|bs
operator|.
name|bs_dtimperiod
expr_stmt|;
name|bs
operator|.
name|bs_cfpmaxduration
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 		 * The 802.11 layer records the offset to the DTIM 		 * bitmap while receiving beacons; use it here to 		 * enable h/w detection of our AID being marked in 		 * the bitmap vector (to indicate frames for us are 		 * pending at the AP). 		 * XXX do DTIM handling in s/w to WAR old h/w bugs 		 * XXX enable based on h/w rev for newer chips 		 */
block|bs.bs_timoffset = ni->ni_timoff;
endif|#
directive|endif
comment|/* 		 * Calculate the number of consecutive beacons to miss 		 * before taking a BMISS interrupt. 		 * Note that we clamp the result to at most 10 beacons. 		 */
name|bs
operator|.
name|bs_bmissthreshold
operator|=
name|vap
operator|->
name|iv_bmissthreshold
expr_stmt|;
if|if
condition|(
name|bs
operator|.
name|bs_bmissthreshold
operator|>
literal|10
condition|)
name|bs
operator|.
name|bs_bmissthreshold
operator|=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|bs
operator|.
name|bs_bmissthreshold
operator|<=
literal|0
condition|)
name|bs
operator|.
name|bs_bmissthreshold
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Calculate sleep duration.  The configuration is 		 * given in ms.  We insure a multiple of the beacon 		 * period is used.  Also, if the sleep duration is 		 * greater than the DTIM period then it makes senses 		 * to make it a multiple of that. 		 * 		 * XXX fixed at 100ms 		 */
name|bs
operator|.
name|bs_sleepduration
operator|=
name|roundup
argument_list|(
name|IEEE80211_MS_TO_TU
argument_list|(
literal|100
argument_list|)
argument_list|,
name|bs
operator|.
name|bs_intval
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs
operator|.
name|bs_sleepduration
operator|>
name|bs
operator|.
name|bs_dtimperiod
condition|)
name|bs
operator|.
name|bs_sleepduration
operator|=
name|roundup
argument_list|(
name|bs
operator|.
name|bs_sleepduration
argument_list|,
name|bs
operator|.
name|bs_dtimperiod
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: tsf %ju tsf:tu %u intval %u nexttbtt %u dtim %u "
literal|"nextdtim %u bmiss %u sleep %u cfp:period %u "
literal|"maxdur %u next %u timoffset %u\n"
argument_list|,
name|__func__
argument_list|,
name|tsf
argument_list|,
name|tsftu
argument_list|,
name|bs
operator|.
name|bs_intval
argument_list|,
name|bs
operator|.
name|bs_nexttbtt
argument_list|,
name|bs
operator|.
name|bs_dtimperiod
argument_list|,
name|bs
operator|.
name|bs_nextdtim
argument_list|,
name|bs
operator|.
name|bs_bmissthreshold
argument_list|,
name|bs
operator|.
name|bs_sleepduration
argument_list|,
name|bs
operator|.
name|bs_cfpperiod
argument_list|,
name|bs
operator|.
name|bs_cfpmaxduration
argument_list|,
name|bs
operator|.
name|bs_cfpnext
argument_list|,
name|bs
operator|.
name|bs_timoffset
argument_list|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ath_hal_beacontimers
argument_list|(
name|ah
argument_list|,
operator|&
name|bs
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_BMISS
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nexttbtt
operator|==
name|intval
condition|)
name|intval
operator||=
name|HAL_BEACON_RESET_TSF
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
comment|/* 			 * In IBSS mode enable the beacon timers but only 			 * enable SWBA interrupts if we need to manually 			 * prepare beacon frames.  Otherwise we use a 			 * self-linked tx descriptor and let the hardware 			 * deal with things. 			 */
name|intval
operator||=
name|HAL_BEACON_ENA
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_hasveol
condition|)
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_SWBA
expr_stmt|;
if|if
condition|(
operator|(
name|intval
operator|&
name|HAL_BEACON_RESET_TSF
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Pull nexttbtt forward to reflect 				 * the current TSF. 				 */
name|tsf
operator|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|tsftu
operator|=
name|TSF_TO_TU
argument_list|(
name|tsf
operator|>>
literal|32
argument_list|,
name|tsf
argument_list|)
operator|+
name|FUDGE
expr_stmt|;
do|do
block|{
name|nexttbtt
operator|+=
name|intval
expr_stmt|;
block|}
do|while
condition|(
name|nexttbtt
operator|<
name|tsftu
condition|)
do|;
block|}
name|ath_beaconq_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
comment|/* 			 * In AP/mesh mode we enable the beacon timers 			 * and SWBA interrupts to prepare beacon frames. 			 */
name|intval
operator||=
name|HAL_BEACON_ENA
expr_stmt|;
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_SWBA
expr_stmt|;
comment|/* beacon prepare */
name|ath_beaconq_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Now dirty things because for now, the EDMA HAL has 		 * nexttbtt and intval is TU/8. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_isedma
condition|)
block|{
name|nexttbtt_u8
operator|=
operator|(
name|nexttbtt
operator|<<
literal|3
operator|)
expr_stmt|;
name|intval_u8
operator|=
operator|(
name|intval
operator|<<
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|intval
operator|&
name|HAL_BEACON_ENA
condition|)
name|intval_u8
operator||=
name|HAL_BEACON_ENA
expr_stmt|;
if|if
condition|(
name|intval
operator|&
name|HAL_BEACON_RESET_TSF
condition|)
name|intval_u8
operator||=
name|HAL_BEACON_RESET_TSF
expr_stmt|;
name|ath_hal_beaconinit
argument_list|(
name|ah
argument_list|,
name|nexttbtt_u8
argument_list|,
name|intval_u8
argument_list|)
expr_stmt|;
block|}
else|else
name|ath_hal_beaconinit
argument_list|(
name|ah
argument_list|,
name|nexttbtt
argument_list|,
name|intval
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bmisscount
operator|=
literal|0
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
comment|/* 		 * When using a self-linked beacon descriptor in 		 * ibss mode load it once here. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|&&
name|sc
operator|->
name|sc_hasveol
condition|)
name|ath_beacon_start_adhoc
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|FUDGE
undef|#
directive|undef
name|TSF_TO_TU
block|}
end_function

end_unit

