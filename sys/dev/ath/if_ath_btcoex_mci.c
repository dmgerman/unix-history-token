begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014 Qualcomm Atheros, Inc.  * Copyright (c) 2016 Adrian Chadd<adrian@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This implements the MCI bluetooth coexistence handling.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ath.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_comment
comment|/* XXX for ether_sprintf */
end_comment

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ath/if_athvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_descdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_btcoex.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_btcoex_mci.h>
end_include

begin_expr_stmt
name|MALLOC_DECLARE
argument_list|(
name|M_ATHDEV
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|ATH_MCI_GPM_MAX_ENTRY
value|16
end_define

begin_define
define|#
directive|define
name|ATH_MCI_GPM_BUF_SIZE
value|(ATH_MCI_GPM_MAX_ENTRY * 16)
end_define

begin_define
define|#
directive|define
name|ATH_MCI_SCHED_BUF_SIZE
value|(16 * 16)
end_define

begin_comment
comment|/* 16 entries, 4 dword each */
end_comment

begin_function_decl
specifier|static
name|void
name|ath_btcoex_mci_update_wlan_channels
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|ath_btcoex_mci_attach
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|buflen
decl_stmt|,
name|error
decl_stmt|;
name|buflen
operator|=
name|ATH_MCI_GPM_BUF_SIZE
operator|+
name|ATH_MCI_SCHED_BUF_SIZE
expr_stmt|;
name|error
operator|=
name|ath_descdma_alloc_desc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_btcoex
operator|.
name|buf
argument_list|,
name|NULL
argument_list|,
literal|"MCI bufs"
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to alloc MCI RAM\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Yes, we're going to do bluetooth MCI coex */
name|sc
operator|->
name|sc_btcoex_mci
operator|=
literal|1
expr_stmt|;
comment|/* Initialise the wlan channel mapping */
name|sc
operator|->
name|sc_btcoex
operator|.
name|wlan_channels
index|[
literal|0
index|]
operator|=
literal|0x00000000
expr_stmt|;
name|sc
operator|->
name|sc_btcoex
operator|.
name|wlan_channels
index|[
literal|1
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|sc
operator|->
name|sc_btcoex
operator|.
name|wlan_channels
index|[
literal|2
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|sc
operator|->
name|sc_btcoex
operator|.
name|wlan_channels
index|[
literal|3
index|]
operator|=
literal|0x7fffffff
expr_stmt|;
comment|/* 	 * Ok, so the API is a bit odd. It assumes sched_addr is 	 * after gpm_addr, and it does math to figure out the right 	 * sched_buf pointer. 	 * 	 * So, set gpm_addr to buf, sched_addr to gpm_addr + ATH_MCI_GPM_BUF_SIZE, 	 * the HAL call with do (gpm_buf + (sched_addr - gpm_addr)) to 	 * set sched_buf, and we're "golden". 	 * 	 * Note, it passes in 'len' here (gpm_len) as 	 * ATH_MCI_GPM_BUF_SIZE>> 4.  My guess is that it's 16 	 * bytes per entry and we're storing 16 entries. 	 */
name|sc
operator|->
name|sc_btcoex
operator|.
name|gpm_buf
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|sc_btcoex
operator|.
name|buf
operator|.
name|dd_desc
expr_stmt|;
name|sc
operator|->
name|sc_btcoex
operator|.
name|sched_buf
operator|=
name|sc
operator|->
name|sc_btcoex
operator|.
name|gpm_buf
operator|+
name|ATH_MCI_GPM_BUF_SIZE
expr_stmt|;
name|sc
operator|->
name|sc_btcoex
operator|.
name|gpm_paddr
operator|=
name|sc
operator|->
name|sc_btcoex
operator|.
name|buf
operator|.
name|dd_desc_paddr
expr_stmt|;
name|sc
operator|->
name|sc_btcoex
operator|.
name|sched_paddr
operator|=
name|sc
operator|->
name|sc_btcoex
operator|.
name|gpm_paddr
operator|+
name|ATH_MCI_GPM_BUF_SIZE
expr_stmt|;
comment|/* memset the gpm buffer with MCI_GPM_RSVD_PATTERN */
name|memset
argument_list|(
name|sc
operator|->
name|sc_btcoex
operator|.
name|gpm_buf
argument_list|,
literal|0xfe
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
comment|/* 	 * This is an unfortunate x86'ism in the HAL - the 	 * HAL code expects the passed in buffer to be 	 * coherent, and doesn't implement /any/ kind 	 * of buffer sync operations at all. 	 * 	 * So, this code will only work on dma coherent buffers 	 * and will behave poorly on non-coherent systems. 	 * Fixing this would require some HAL surgery so it 	 * actually /did/ the buffer flushing as appropriate. 	 */
name|ath_hal_btcoex_mci_setup
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_btcoex
operator|.
name|gpm_paddr
argument_list|,
name|sc
operator|->
name|sc_btcoex
operator|.
name|gpm_buf
argument_list|,
name|ATH_MCI_GPM_BUF_SIZE
operator|>>
literal|4
argument_list|,
name|sc
operator|->
name|sc_btcoex
operator|.
name|sched_paddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach btcoex from the given interface  */
end_comment

begin_function
name|int
name|ath_btcoex_mci_detach
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ath_hal_btcoex_mci_detach
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_btcoex
operator|.
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Configure or disable bluetooth coexistence on the given channel.  *  * For MCI, we just use the top-level enable/disable flag, and  * then the MCI reset / channel update path will configure things  * appropriately based on the current band.  */
end_comment

begin_function
name|int
name|ath_btcoex_mci_enable
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
comment|/* 	 * Always reconfigure stomp-all for now, so wlan wins. 	 * 	 * The default weights still don't allow beacons to win, 	 * so unless you set net.wlan.X.bmiss_max to something higher, 	 * net80211 will disconnect you during a HCI INQUIRY command. 	 * 	 * The longer-term solution is to dynamically adjust whether 	 * bmiss happens based on bluetooth requirements, and look at 	 * making the individual stomp bits configurable. 	 */
name|ath_hal_btcoex_set_weights
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_BT_COEX_STOMP_ALL
argument_list|)
expr_stmt|;
comment|/* 	 * update wlan channels so the firmware knows what channels it 	 * can/can't use. 	 */
name|ath_btcoex_mci_update_wlan_channels
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX TODO: turn into general btcoex, and then make this  * the MCI specific bits.  */
end_comment

begin_function
specifier|static
name|void
name|ath_btcoex_mci_event
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ATH_BT_COEX_EVENT
name|nevent
parameter_list|,
name|void
modifier|*
name|param
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_btcoex_mci
condition|)
return|return;
comment|/* 	 * Check whether we need to flush our local profile cache. 	 * If we do, then at (XXX TODO) we should flush our state, 	 * then wait for the MCI response with the updated profile list. 	 */
if|if
condition|(
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_NEED_FLUSH_BT_INFO
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|uint32_t
name|data
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_ENABLE
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) Flush BT profile\n"
argument_list|)
expr_stmt|;
comment|/* 			 * XXX TODO: flush profile state on the ath(4) 			 * driver side; subsequent messages will come 			 * through with the current list of active 			 * profiles. 			 */
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_NEED_FLUSH_BT_INFO
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_SEND_STATUS_QUERY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nevent
operator|==
name|ATH_COEX_EVENT_BT_NOOP
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) BT_NOOP\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_btcoex_mci_send_gpm
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|payload
parameter_list|)
block|{
name|ath_hal_btcoex_mci_send_message
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|MCI_GPM
argument_list|,
literal|0
argument_list|,
name|payload
argument_list|,
literal|16
argument_list|,
name|AH_FALSE
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This starts a BT calibration.  It requires a chip reset.  */
end_comment

begin_function
specifier|static
name|int
name|ath_btcoex_mci_bt_cal_do
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|tx_timeout
parameter_list|,
name|int
name|rx_timeout
parameter_list|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: TODO!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_btcoex_mci_cal_msg
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|opcode
parameter_list|,
name|uint8_t
modifier|*
name|rx_payload
parameter_list|)
block|{
name|uint32_t
name|payload
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|MCI_GPM_BT_CAL_REQ
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) receive BT_CAL_REQ\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_BT
argument_list|,
name|NULL
argument_list|)
operator|==
name|MCI_BT_AWAKE
condition|)
block|{
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_SET_BT_CAL_START
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ath_btcoex_mci_bt_cal_do
argument_list|(
name|sc
argument_list|,
literal|1000
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) State mismatches: %d\n"
argument_list|,
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_BT
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MCI_GPM_BT_CAL_DONE
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) receive BT_CAL_DONE\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_BT
argument_list|,
name|NULL
argument_list|)
operator|==
name|MCI_BT_CAL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) ERROR ILLEGAL!\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) BT not in CAL state.\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MCI_GPM_BT_CAL_GRANT
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) receive BT_CAL_GRANT\n"
argument_list|)
expr_stmt|;
comment|/* Send WLAN_CAL_DONE for now */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) Send WLAN_CAL_DONE\n"
argument_list|)
expr_stmt|;
name|MCI_GPM_SET_CAL_TYPE
argument_list|(
name|payload
argument_list|,
name|MCI_GPM_WLAN_CAL_DONE
argument_list|)
expr_stmt|;
name|ath_btcoex_mci_send_gpm
argument_list|(
name|sc
argument_list|,
operator|&
name|payload
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) Unknown GPM CAL message.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Update the bluetooth channel map.  *  * This map tells the bluetooth device which bluetooth channels  * are available for data.  *  * For 5GHz, all channels are available.  * For 2GHz, the current wifi channel range is blocked out,  *   and the rest are available.  *  * This narrows which frequencies are used by the device when  * it initiates a transfer, thus hopefully reducing the chances  * of collisions (both hopefully on the current device and  * other devices in the same channel.)  */
end_comment

begin_function
specifier|static
name|void
name|ath_btcoex_mci_update_wlan_channels
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|chan
init|=
name|ic
operator|->
name|ic_curchan
decl_stmt|;
name|uint32_t
name|channel_info
index|[
literal|4
index|]
init|=
block|{
literal|0x00000000
block|,
literal|0xffffffff
block|,
literal|0xffffffff
block|,
literal|0x7fffffff
block|}
decl_stmt|;
name|int32_t
name|wl_chan
decl_stmt|,
name|bt_chan
decl_stmt|,
name|bt_start
init|=
literal|0
decl_stmt|,
name|bt_end
init|=
literal|79
decl_stmt|;
comment|/* BT channel frequency is 2402 + k, k = 0 ~ 78 */
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|wl_chan
operator|=
name|chan
operator|->
name|ic_freq
operator|-
literal|2402
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|bt_start
operator|=
name|wl_chan
operator|-
literal|10
expr_stmt|;
name|bt_end
operator|=
name|wl_chan
operator|+
literal|30
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40D
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|bt_start
operator|=
name|wl_chan
operator|-
literal|30
expr_stmt|;
name|bt_end
operator|=
name|wl_chan
operator|+
literal|10
expr_stmt|;
block|}
else|else
block|{
comment|/* Assume 20MHz */
name|bt_start
operator|=
name|wl_chan
operator|-
literal|10
expr_stmt|;
name|bt_end
operator|=
name|wl_chan
operator|+
literal|10
expr_stmt|;
block|}
name|bt_start
operator|-=
literal|7
expr_stmt|;
name|bt_end
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|bt_start
operator|<
literal|0
condition|)
block|{
name|bt_start
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bt_end
operator|>
name|MCI_NUM_BT_CHANNELS
condition|)
block|{
name|bt_end
operator|=
name|MCI_NUM_BT_CHANNELS
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) WLAN use channel %d\n"
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) mask BT channel %d - %d\n"
argument_list|,
name|bt_start
argument_list|,
name|bt_end
argument_list|)
expr_stmt|;
for|for
control|(
name|bt_chan
operator|=
name|bt_start
init|;
name|bt_chan
operator|<
name|bt_end
condition|;
name|bt_chan
operator|++
control|)
block|{
name|MCI_GPM_CLR_CHANNEL_BIT
argument_list|(
operator|&
name|channel_info
index|[
literal|0
index|]
argument_list|,
name|bt_chan
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) WLAN not use any 2G channel, unmask all for BT\n"
argument_list|)
expr_stmt|;
block|}
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_SEND_WLAN_CHANNELS
argument_list|,
operator|&
name|channel_info
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_btcoex_mci_coex_msg
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|opcode
parameter_list|,
name|uint8_t
modifier|*
name|rx_payload
parameter_list|)
block|{
name|uint32_t
name|version
decl_stmt|;
name|uint8_t
name|major
decl_stmt|;
name|uint8_t
name|minor
decl_stmt|;
name|uint32_t
name|seq_num
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|MCI_GPM_COEX_VERSION_QUERY
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) Recv GPM COEX Version Query.\n"
argument_list|)
expr_stmt|;
name|version
operator|=
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_SEND_WLAN_COEX_VERSION
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|MCI_GPM_COEX_VERSION_RESPONSE
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) Recv GPM COEX Version Response.\n"
argument_list|)
expr_stmt|;
name|major
operator|=
operator|*
operator|(
name|rx_payload
operator|+
name|MCI_GPM_COEX_B_MAJOR_VERSION
operator|)
expr_stmt|;
name|minor
operator|=
operator|*
operator|(
name|rx_payload
operator|+
name|MCI_GPM_COEX_B_MINOR_VERSION
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) BT Coex version: %d.%d\n"
argument_list|,
name|major
argument_list|,
name|minor
argument_list|)
expr_stmt|;
name|version
operator|=
operator|(
name|major
operator|<<
literal|8
operator|)
operator|+
name|minor
expr_stmt|;
name|version
operator|=
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_SET_BT_COEX_VERSION
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
break|break;
case|case
name|MCI_GPM_COEX_STATUS_QUERY
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) Recv GPM COEX Status Query = 0x%02x.\n"
argument_list|,
operator|*
operator|(
name|rx_payload
operator|+
name|MCI_GPM_COEX_B_WLAN_BITMAP
operator|)
argument_list|)
expr_stmt|;
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_SEND_WLAN_CHANNELS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|MCI_GPM_COEX_BT_PROFILE_INFO
case|:
comment|/* 		 * XXX TODO: here is where we'd parse active profile 		 * info and make driver/stack choices as appropriate. 		 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) TODO: Recv GPM COEX BT_Profile_Info.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MCI_GPM_COEX_BT_STATUS_UPDATE
case|:
name|seq_num
operator|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|rx_payload
operator|+
literal|12
operator|)
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) Recv GPM COEX BT_Status_Update: SEQ=%d\n"
argument_list|,
name|seq_num
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) Unknown GPM COEX message = 0x%02x\n"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|ath_btcoex_mci_intr
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|mciInt
decl_stmt|,
name|mciIntRxMsg
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|,
name|subtype
decl_stmt|,
name|opcode
decl_stmt|;
name|uint32_t
modifier|*
name|pGpm
decl_stmt|;
name|uint32_t
name|more_data
init|=
name|HAL_MCI_GPM_MORE
decl_stmt|;
name|int8_t
name|value_dbm
decl_stmt|;
name|bool
name|skip_gpm
init|=
name|false
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ath_hal_btcoex_mci_get_interrupt
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|mciInt
argument_list|,
operator|&
name|mciIntRxMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_ENABLE
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_INIT_GPM_OFFSET
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) INTR but MCI_disabled\n"
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) MCI interrupt: mciInt = 0x%x, mciIntRxMsg = 0x%x\n"
argument_list|,
name|mciInt
argument_list|,
name|mciIntRxMsg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mciIntRxMsg
operator|&
name|HAL_MCI_INTERRUPT_RX_MSG_REQ_WAKE
condition|)
block|{
name|uint32_t
name|payload4
index|[
literal|4
index|]
init|=
block|{
literal|0xffffffff
block|,
literal|0xffffffff
block|,
literal|0xffffffff
block|,
literal|0xffffff00
block|}
decl_stmt|;
comment|/* 		 * The following REMOTE_RESET and SYS_WAKING used to sent 		 * only when BT wake up. Now they are always sent, as a 		 * recovery method to reset BT MCI's RX alignment. 		 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) 1. INTR Send REMOTE_RESET\n"
argument_list|)
expr_stmt|;
name|ath_hal_btcoex_mci_send_message
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|MCI_REMOTE_RESET
argument_list|,
literal|0
argument_list|,
name|payload4
argument_list|,
literal|16
argument_list|,
name|AH_TRUE
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) 1. INTR Send SYS_WAKING\n"
argument_list|)
expr_stmt|;
name|ath_hal_btcoex_mci_send_message
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|MCI_SYS_WAKING
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|AH_TRUE
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
name|mciIntRxMsg
operator|&=
operator|~
name|HAL_MCI_INTERRUPT_RX_MSG_REQ_WAKE
expr_stmt|;
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_RESET_REQ_WAKE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* always do this for recovery and 2G/5G toggling and LNA_TRANS */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) 1. Set BT state to AWAKE.\n"
argument_list|)
expr_stmt|;
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_SET_BT_AWAKE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Processing SYS_WAKING/SYS_SLEEPING */
if|if
condition|(
name|mciIntRxMsg
operator|&
name|HAL_MCI_INTERRUPT_RX_MSG_SYS_WAKING
condition|)
block|{
name|mciIntRxMsg
operator|&=
operator|~
name|HAL_MCI_INTERRUPT_RX_MSG_SYS_WAKING
expr_stmt|;
if|if
condition|(
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_BT
argument_list|,
name|NULL
argument_list|)
operator|==
name|MCI_BT_SLEEP
condition|)
block|{
if|if
condition|(
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_REMOTE_SLEEP
argument_list|,
name|NULL
argument_list|)
operator|==
name|MCI_BT_SLEEP
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) 2. BT stays in SLEEP mode.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) 2. Set BT state to AWAKE.\n"
argument_list|)
expr_stmt|;
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_SET_BT_AWAKE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) 2. BT stays in AWAKE mode.\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mciIntRxMsg
operator|&
name|HAL_MCI_INTERRUPT_RX_MSG_SYS_SLEEPING
condition|)
block|{
name|mciIntRxMsg
operator|&=
operator|~
name|HAL_MCI_INTERRUPT_RX_MSG_SYS_SLEEPING
expr_stmt|;
if|if
condition|(
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_BT
argument_list|,
name|NULL
argument_list|)
operator|==
name|MCI_BT_AWAKE
condition|)
block|{
if|if
condition|(
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_REMOTE_SLEEP
argument_list|,
name|NULL
argument_list|)
operator|==
name|MCI_BT_AWAKE
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) 3. BT stays in AWAKE mode.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) 3. Set BT state to SLEEP.\n"
argument_list|)
expr_stmt|;
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_SET_BT_SLEEP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) 3. BT stays in SLEEP mode.\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Recover from out-of-order / wrong-offset GPM messages. 	 */
if|if
condition|(
operator|(
name|mciInt
operator|&
name|HAL_MCI_INTERRUPT_RX_INVALID_HDR
operator|)
operator|||
operator|(
name|mciInt
operator|&
name|HAL_MCI_INTERRUPT_CONT_INFO_TIMEOUT
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) MCI RX broken, skip GPM messages\n"
argument_list|)
expr_stmt|;
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_RECOVER_RX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|skip_gpm
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|mciIntRxMsg
operator|&
name|HAL_MCI_INTERRUPT_RX_MSG_SCHD_INFO
condition|)
block|{
name|mciIntRxMsg
operator|&=
operator|~
name|HAL_MCI_INTERRUPT_RX_MSG_SCHD_INFO
expr_stmt|;
name|offset
operator|=
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_LAST_SCHD_MSG_OFFSET
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Parse GPM messages. 	 */
if|if
condition|(
name|mciIntRxMsg
operator|&
name|HAL_MCI_INTERRUPT_RX_MSG_GPM
condition|)
block|{
name|mciIntRxMsg
operator|&=
operator|~
name|HAL_MCI_INTERRUPT_RX_MSG_GPM
expr_stmt|;
while|while
condition|(
name|more_data
operator|==
name|HAL_MCI_GPM_MORE
condition|)
block|{
name|pGpm
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|sc_btcoex
operator|.
name|gpm_buf
expr_stmt|;
name|offset
operator|=
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_NEXT_GPM_OFFSET
argument_list|,
operator|&
name|more_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|HAL_MCI_GPM_INVALID
condition|)
break|break;
name|pGpm
operator|+=
operator|(
name|offset
operator|>>
literal|2
operator|)
expr_stmt|;
comment|/* 			 * The first DWORD is a timer. 			 * The real data starts from the second DWORD. 			 */
name|subtype
operator|=
name|MCI_GPM_TYPE
argument_list|(
name|pGpm
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|MCI_GPM_OPCODE
argument_list|(
name|pGpm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip_gpm
condition|)
block|{
if|if
condition|(
name|MCI_GPM_IS_CAL_TYPE
argument_list|(
name|subtype
argument_list|)
condition|)
block|{
name|ath_btcoex_mci_cal_msg
argument_list|(
name|sc
argument_list|,
name|subtype
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|pGpm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|MCI_GPM_COEX_AGENT
case|:
name|ath_btcoex_mci_coex_msg
argument_list|(
name|sc
argument_list|,
name|opcode
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|pGpm
argument_list|)
expr_stmt|;
break|break;
case|case
name|MCI_GPM_BT_DEBUG
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"(MCI) TODO: GPM_BT_DEBUG!\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) Unknown GPM message.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|MCI_GPM_RECYCLE
argument_list|(
name|pGpm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * This is monitoring/management information messages, so the driver 	 * layer can hook in and dynamically adjust things like aggregation 	 * size, expected bluetooth/wifi traffic throughput, etc. 	 * 	 * None of that is done right now; it just passes off the values 	 * to the HAL so it can update its internal state as appropriate. 	 * This code just prints out the values for debugging purposes. 	 */
if|if
condition|(
name|mciIntRxMsg
operator|&
name|HAL_MCI_INTERRUPT_RX_MSG_MONITOR
condition|)
block|{
if|if
condition|(
name|mciIntRxMsg
operator|&
name|HAL_MCI_INTERRUPT_RX_MSG_LNA_CONTROL
condition|)
block|{
name|mciIntRxMsg
operator|&=
operator|~
name|HAL_MCI_INTERRUPT_RX_MSG_LNA_CONTROL
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) LNA_CONTROL\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mciIntRxMsg
operator|&
name|HAL_MCI_INTERRUPT_RX_MSG_LNA_INFO
condition|)
block|{
name|mciIntRxMsg
operator|&=
operator|~
name|HAL_MCI_INTERRUPT_RX_MSG_LNA_INFO
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) LNA_INFO\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mciIntRxMsg
operator|&
name|HAL_MCI_INTERRUPT_RX_MSG_CONT_INFO
condition|)
block|{
name|value_dbm
operator|=
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_CONT_RSSI_POWER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mciIntRxMsg
operator|&=
operator|~
name|HAL_MCI_INTERRUPT_RX_MSG_CONT_INFO
expr_stmt|;
if|if
condition|(
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_CONT_TXRX
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) CONT_INFO: (tx) pri = %d, pwr = %d dBm\n"
argument_list|,
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_CONT_PRIORITY
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|value_dbm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) CONT_INFO: (rx) pri = %d, rssi = %d dBm\n"
argument_list|,
name|ath_hal_btcoex_mci_state
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_MCI_STATE_CONT_PRIORITY
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|value_dbm
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mciIntRxMsg
operator|&
name|HAL_MCI_INTERRUPT_RX_MSG_CONT_NACK
condition|)
block|{
name|mciIntRxMsg
operator|&=
operator|~
name|HAL_MCI_INTERRUPT_RX_MSG_CONT_NACK
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) CONT_NACK\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mciIntRxMsg
operator|&
name|HAL_MCI_INTERRUPT_RX_MSG_CONT_RST
condition|)
block|{
name|mciIntRxMsg
operator|&=
operator|~
name|HAL_MCI_INTERRUPT_RX_MSG_CONT_RST
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) CONT_RST\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Recover the state engine if we hit an invalid header/timeout. 	 * This is the final part of GPT out-of-sync recovery. 	 */
if|if
condition|(
operator|(
name|mciInt
operator|&
name|HAL_MCI_INTERRUPT_RX_INVALID_HDR
operator|)
operator|||
operator|(
name|mciInt
operator|&
name|HAL_MCI_INTERRUPT_CONT_INFO_TIMEOUT
operator|)
condition|)
block|{
name|ath_btcoex_mci_event
argument_list|(
name|sc
argument_list|,
name|ATH_COEX_EVENT_BT_NOOP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mciInt
operator|&=
operator|~
operator|(
name|HAL_MCI_INTERRUPT_RX_INVALID_HDR
operator||
name|HAL_MCI_INTERRUPT_CONT_INFO_TIMEOUT
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|mciIntRxMsg
operator|&
literal|0xfffffffe
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BTCOEX
argument_list|,
literal|"(MCI) Not processed IntRxMsg = 0x%x\n"
argument_list|,
name|mciIntRxMsg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

