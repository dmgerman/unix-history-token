begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Adrian Chadd<adrian@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for the Atheros Wireless LAN controller.  *  * This software is derived from work of Atsushi Onoe; his contribution  * is greatly appreciated.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ath.h"
end_include

begin_comment
comment|/*  * This is needed for register operations which are performed  * by the driver - eg, calls to ath_hal_gettsf32().  *  * It's also required for any AH_DEBUG checks in here, eg the  * module dependencies.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_comment
comment|/* for mp_ncpus */
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_superg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_tdma.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ath/if_athvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/ath_hal/ah_devid.h>
end_include

begin_comment
comment|/* XXX for softled */
end_comment

begin_include
include|#
directive|include
file|<dev/ath/ath_hal/ah_diagcodes.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_misc.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tsf.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tx.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_led.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_keycache.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_rx.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_beacon.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_athdfs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
end_ifdef

begin_include
include|#
directive|include
file|<dev/ath/ath_tx99/ath_tx99.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ath/if_ath_rx_edma.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_DEBUG_ALQ
end_ifdef

begin_include
include|#
directive|include
file|<dev/ath/if_ath_alq.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * some general macros   */
end_comment

begin_define
define|#
directive|define
name|INCR
parameter_list|(
name|_l
parameter_list|,
name|_sz
parameter_list|)
value|(_l) ++; (_l)&= ((_sz) - 1)
end_define

begin_define
define|#
directive|define
name|DECR
parameter_list|(
name|_l
parameter_list|,
name|_sz
parameter_list|)
value|(_l) --; (_l)&= ((_sz) - 1)
end_define

begin_expr_stmt
name|MALLOC_DECLARE
argument_list|(
name|M_ATHDEV
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * XXX TODO:  *  * + Make sure the FIFO is correctly flushed and reinitialised  *   through a reset;  * + Verify multi-descriptor frames work!  * + There's a "memory use after free" which needs to be tracked down  *   and fixed ASAP.  I've seen this in the legacy path too, so it  *   may be a generic RX path issue.  */
end_comment

begin_comment
comment|/*  * XXX shuffle the function orders so these pre-declarations aren't  * required!  */
end_comment

begin_function_decl
specifier|static
name|int
name|ath_edma_rxfifo_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|HAL_RX_QUEUE
name|qtype
parameter_list|,
name|int
name|nbufs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_edma_rxfifo_flush
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|HAL_RX_QUEUE
name|qtype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_edma_rxbuf_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_edma_recv_proc_queue
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|HAL_RX_QUEUE
name|qtype
parameter_list|,
name|int
name|dosched
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_edma_recv_proc_deferred_queue
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|HAL_RX_QUEUE
name|qtype
parameter_list|,
name|int
name|dosched
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|ath_edma_stoprecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dodelay
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|ATH_RX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_stoppcurecv
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 *  	 */
if|if
condition|(
name|ath_hal_stopdmarecv
argument_list|(
name|ah
argument_list|)
operator|==
name|AH_TRUE
condition|)
name|sc
operator|->
name|sc_rx_stopped
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Give the various bus FIFOs (not EDMA descriptor FIFO) 	 * time to finish flushing out data. 	 */
name|DELAY
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
comment|/* Flush RX pending for each queue */
comment|/* XXX should generic-ify this */
if|if
condition|(
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_HP
index|]
operator|.
name|m_rxpending
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_HP
index|]
operator|.
name|m_rxpending
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_HP
index|]
operator|.
name|m_rxpending
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_LP
index|]
operator|.
name|m_rxpending
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_LP
index|]
operator|.
name|m_rxpending
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_LP
index|]
operator|.
name|m_rxpending
operator|=
name|NULL
expr_stmt|;
block|}
name|ATH_RX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Re-initialise the FIFO given the current buffer contents.  * Specifically, walk from head -> tail, pushing the FIFO contents  * back into the FIFO.  */
end_comment

begin_function
specifier|static
name|void
name|ath_edma_reinit_fifo
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|HAL_RX_QUEUE
name|qtype
parameter_list|)
block|{
name|struct
name|ath_rx_edma
modifier|*
name|re
init|=
operator|&
name|sc
operator|->
name|sc_rxedma
index|[
name|qtype
index|]
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|ATH_RX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|i
operator|=
name|re
operator|->
name|m_fifo_head
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|re
operator|->
name|m_fifo_depth
condition|;
name|j
operator|++
control|)
block|{
name|bf
operator|=
name|re
operator|->
name|m_fifo
index|[
name|i
index|]
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_EDMA_RX
argument_list|,
literal|"%s: Q%d: pos=%i, addr=0x%jx\n"
argument_list|,
name|__func__
argument_list|,
name|qtype
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|ath_hal_putrxbuf
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|,
name|qtype
argument_list|)
expr_stmt|;
name|INCR
argument_list|(
name|i
argument_list|,
name|re
operator|->
name|m_fifolen
argument_list|)
expr_stmt|;
block|}
comment|/* Ensure this worked out right */
if|if
condition|(
name|i
operator|!=
name|re
operator|->
name|m_fifo_tail
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: i (%d) != tail! (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|re
operator|->
name|m_fifo_tail
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Start receive.  */
end_comment

begin_function
specifier|static
name|int
name|ath_edma_startrecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|ATH_RX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Sanity check - are we being called whilst RX 	 * isn't stopped?  If so, we may end up pushing 	 * too many entries into the RX FIFO and 	 * badness occurs. 	 */
comment|/* Enable RX FIFO */
name|ath_hal_rxena
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 	 * In theory the hardware has been initialised, right? 	 */
if|if
condition|(
name|sc
operator|->
name|sc_rx_resetted
operator|==
literal|1
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_EDMA_RX
argument_list|,
literal|"%s: Re-initing HP FIFO\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ath_edma_reinit_fifo
argument_list|(
name|sc
argument_list|,
name|HAL_RX_QUEUE_HP
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_EDMA_RX
argument_list|,
literal|"%s: Re-initing LP FIFO\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ath_edma_reinit_fifo
argument_list|(
name|sc
argument_list|,
name|HAL_RX_QUEUE_LP
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rx_resetted
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called without resetting chip?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* Add up to m_fifolen entries in each queue */
comment|/* 	 * These must occur after the above write so the FIFO buffers 	 * are pushed/tracked in the same order as the hardware will 	 * process them. 	 * 	 * XXX TODO: is this really necessary? We should've stopped 	 * the hardware already and reinitialised it, so it's a no-op. 	 */
name|ath_edma_rxfifo_alloc
argument_list|(
name|sc
argument_list|,
name|HAL_RX_QUEUE_HP
argument_list|,
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_HP
index|]
operator|.
name|m_fifolen
argument_list|)
expr_stmt|;
name|ath_edma_rxfifo_alloc
argument_list|(
name|sc
argument_list|,
name|HAL_RX_QUEUE_LP
argument_list|,
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_LP
index|]
operator|.
name|m_fifolen
argument_list|)
expr_stmt|;
name|ath_mode_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_startpcurecv
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 	 * We're now doing RX DMA! 	 */
name|sc
operator|->
name|sc_rx_stopped
operator|=
literal|0
expr_stmt|;
name|ATH_RX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_edma_recv_sched_queue
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|HAL_RX_QUEUE
name|qtype
parameter_list|,
name|int
name|dosched
parameter_list|)
block|{
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_edma_recv_proc_queue
argument_list|(
name|sc
argument_list|,
name|qtype
argument_list|,
name|dosched
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_edma_recv_sched
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dosched
parameter_list|)
block|{
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_edma_recv_proc_queue
argument_list|(
name|sc
argument_list|,
name|HAL_RX_QUEUE_HP
argument_list|,
name|dosched
argument_list|)
expr_stmt|;
name|ath_edma_recv_proc_queue
argument_list|(
name|sc
argument_list|,
name|HAL_RX_QUEUE_LP
argument_list|,
name|dosched
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_edma_recv_flush
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RECV
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxproc_cnt
operator|++
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Flush any active frames from FIFO -> deferred list 	 */
name|ath_edma_recv_proc_queue
argument_list|(
name|sc
argument_list|,
name|HAL_RX_QUEUE_HP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ath_edma_recv_proc_queue
argument_list|(
name|sc
argument_list|,
name|HAL_RX_QUEUE_LP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Process what's in the deferred queue 	 */
comment|/* 	 * XXX: If we read the tsf/channoise here and then pass it in, 	 * we could restore the power state before processing 	 * the deferred queue. 	 */
name|ath_edma_recv_proc_deferred_queue
argument_list|(
name|sc
argument_list|,
name|HAL_RX_QUEUE_HP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ath_edma_recv_proc_deferred_queue
argument_list|(
name|sc
argument_list|,
name|HAL_RX_QUEUE_LP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxproc_cnt
operator|--
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process frames from the current queue into the deferred queue.  */
end_comment

begin_function
specifier|static
name|void
name|ath_edma_recv_proc_queue
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|HAL_RX_QUEUE
name|qtype
parameter_list|,
name|int
name|dosched
parameter_list|)
block|{
name|struct
name|ath_rx_edma
modifier|*
name|re
init|=
operator|&
name|sc
operator|->
name|sc_rxedma
index|[
name|qtype
index|]
decl_stmt|;
name|struct
name|ath_rx_status
modifier|*
name|rs
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|uint64_t
name|tsf
decl_stmt|;
name|uint16_t
name|nf
decl_stmt|;
name|int
name|npkts
init|=
literal|0
decl_stmt|;
name|tsf
operator|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|nf
operator|=
name|ath_hal_getchannoise
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_noise
operator|=
name|nf
expr_stmt|;
name|ATH_RX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
name|sc
operator|->
name|sc_rx_resetted
operator|==
literal|1
condition|)
block|{
comment|/* 		 * XXX We shouldn't ever be scheduled if 		 * receive has been stopped - so complain 		 * loudly! 		 */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: sc_rx_resetted=1! Bad!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ATH_RX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
do|do
block|{
name|bf
operator|=
name|re
operator|->
name|m_fifo
index|[
name|re
operator|->
name|m_fifo_head
index|]
expr_stmt|;
comment|/* This shouldn't occur! */
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Q%d: NULL bf?\n"
argument_list|,
name|__func__
argument_list|,
name|qtype
argument_list|)
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
comment|/* 		 * Sync descriptor memory - this also syncs the buffer for us. 		 * EDMA descriptors are in cached memory. 		 */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|rs
operator|=
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_rxstat
expr_stmt|;
name|bf
operator|->
name|bf_rxstatus
operator|=
name|ath_hal_rxprocdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|,
name|NULL
argument_list|,
name|rs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_RECV_DESC
condition|)
name|ath_printrxbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|,
name|bf
operator|->
name|bf_rxstatus
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ATH_DEBUG */
ifdef|#
directive|ifdef
name|ATH_DEBUG_ALQ
if|if
condition|(
name|if_ath_alq_checkdebug
argument_list|(
operator|&
name|sc
operator|->
name|sc_alq
argument_list|,
name|ATH_ALQ_EDMA_RXSTATUS
argument_list|)
condition|)
name|if_ath_alq_post
argument_list|(
operator|&
name|sc
operator|->
name|sc_alq
argument_list|,
name|ATH_ALQ_EDMA_RXSTATUS
argument_list|,
name|sc
operator|->
name|sc_rx_statuslen
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ds
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ATH_DEBUG */
if|if
condition|(
name|bf
operator|->
name|bf_rxstatus
operator|==
name|HAL_EINPROGRESS
condition|)
break|break;
comment|/* 		 * Completed descriptor. 		 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_EDMA_RX
argument_list|,
literal|"%s: Q%d: completed!\n"
argument_list|,
name|__func__
argument_list|,
name|qtype
argument_list|)
expr_stmt|;
name|npkts
operator|++
expr_stmt|;
comment|/* 		 * We've been synced already, so unmap. 		 */
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
comment|/* 		 * Remove the FIFO entry and place it on the completion 		 * queue. 		 */
name|re
operator|->
name|m_fifo
index|[
name|re
operator|->
name|m_fifo_head
index|]
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_rxlist
index|[
name|qtype
index|]
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
comment|/* Bump the descriptor FIFO stats */
name|INCR
argument_list|(
name|re
operator|->
name|m_fifo_head
argument_list|,
name|re
operator|->
name|m_fifolen
argument_list|)
expr_stmt|;
name|re
operator|->
name|m_fifo_depth
operator|--
expr_stmt|;
comment|/* XXX check it doesn't fall below 0 */
block|}
do|while
condition|(
name|re
operator|->
name|m_fifo_depth
operator|>
literal|0
condition|)
do|;
comment|/* Append some more fresh frames to the FIFO */
if|if
condition|(
name|dosched
condition|)
name|ath_edma_rxfifo_alloc
argument_list|(
name|sc
argument_list|,
name|qtype
argument_list|,
name|re
operator|->
name|m_fifolen
argument_list|)
expr_stmt|;
name|ATH_RX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* rx signal state monitoring */
name|ath_hal_rxmonitor
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_halstats
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
expr_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_INTERRUPTS
argument_list|,
literal|1
argument_list|,
literal|"ath edma rx proc: npkts=%d\n"
argument_list|,
name|npkts
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Flush the deferred queue.  *  * This destructively flushes the deferred queue - it doesn't  * call the wireless stack on each mbuf.  */
end_comment

begin_function
specifier|static
name|void
name|ath_edma_flush_deferred_queue
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|ATH_RX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Free in one set, inside the lock */
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_rxlist
index|[
name|HAL_RX_QUEUE_LP
index|]
argument_list|)
condition|)
block|{
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_rxlist
index|[
name|HAL_RX_QUEUE_LP
index|]
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_rxlist
index|[
name|HAL_RX_QUEUE_LP
index|]
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
comment|/* Free the buffer/mbuf */
name|ath_edma_rxbuf_free
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_rxlist
index|[
name|HAL_RX_QUEUE_HP
index|]
argument_list|)
condition|)
block|{
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_rxlist
index|[
name|HAL_RX_QUEUE_HP
index|]
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_rxlist
index|[
name|HAL_RX_QUEUE_HP
index|]
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
comment|/* Free the buffer/mbuf */
name|ath_edma_rxbuf_free
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ath_edma_recv_proc_deferred_queue
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|HAL_RX_QUEUE
name|qtype
parameter_list|,
name|int
name|dosched
parameter_list|)
block|{
name|int
name|ngood
init|=
literal|0
decl_stmt|;
name|uint64_t
name|tsf
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|ath_rx_status
modifier|*
name|rs
decl_stmt|;
name|int16_t
name|nf
decl_stmt|;
name|ath_bufhead
name|rxlist
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|rxlist
argument_list|)
expr_stmt|;
name|nf
operator|=
name|ath_hal_getchannoise
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
expr_stmt|;
comment|/* 	 * XXX TODO: the NF/TSF should be stamped on the bufs themselves, 	 * otherwise we may end up adding in the wrong values if this 	 * is delayed too far.. 	 */
name|tsf
operator|=
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
comment|/* Copy the list over */
name|ATH_RX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TAILQ_CONCAT
argument_list|(
operator|&
name|rxlist
argument_list|,
operator|&
name|sc
operator|->
name|sc_rx_rxlist
index|[
name|qtype
index|]
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_RX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Handle the completed descriptors */
comment|/* 	 * XXX is this SAFE call needed? The ath_buf entries 	 * aren't modified by ath_rx_pkt, right? 	 */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bf
argument_list|,
argument|&rxlist
argument_list|,
argument|bf_list
argument_list|,
argument|next
argument_list|)
block|{
comment|/* 		 * Skip the RX descriptor status - start at the data offset 		 */
name|m_adj
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|,
name|sc
operator|->
name|sc_rx_statuslen
argument_list|)
expr_stmt|;
comment|/* Handle the frame */
name|rs
operator|=
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_rxstat
expr_stmt|;
name|m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ath_rx_pkt
argument_list|(
name|sc
argument_list|,
name|rs
argument_list|,
name|bf
operator|->
name|bf_rxstatus
argument_list|,
name|tsf
argument_list|,
name|nf
argument_list|,
name|qtype
argument_list|,
name|bf
argument_list|,
name|m
argument_list|)
condition|)
name|ngood
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ngood
condition|)
block|{
name|sc
operator|->
name|sc_lastrx
operator|=
name|tsf
expr_stmt|;
block|}
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_INTERRUPTS
argument_list|,
literal|1
argument_list|,
literal|"ath edma rx deferred proc: ngood=%d\n"
argument_list|,
name|ngood
argument_list|)
expr_stmt|;
comment|/* Free in one set, inside the lock */
name|ATH_RX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|rxlist
argument_list|)
condition|)
block|{
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|rxlist
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|rxlist
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
comment|/* Free the buffer/mbuf */
name|ath_edma_rxbuf_free
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
name|ATH_RX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ngood
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_edma_recv_tasklet
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ath_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_EDMA_RX
argument_list|,
literal|"%s: called; npending=%d\n"
argument_list|,
name|__func__
argument_list|,
name|npending
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_inreset_cnt
operator|>
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: sc_inreset_cnt> 0; skipping\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|sc_rxproc_cnt
operator|++
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_edma_recv_proc_queue
argument_list|(
name|sc
argument_list|,
name|HAL_RX_QUEUE_HP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ath_edma_recv_proc_queue
argument_list|(
name|sc
argument_list|,
name|HAL_RX_QUEUE_LP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ath_edma_recv_proc_deferred_queue
argument_list|(
name|sc
argument_list|,
name|HAL_RX_QUEUE_HP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ath_edma_recv_proc_deferred_queue
argument_list|(
name|sc
argument_list|,
name|HAL_RX_QUEUE_LP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: If we read the tsf/channoise here and then pass it in, 	 * we could restore the power state before processing 	 * the deferred queue. 	 */
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX inside IF_LOCK ? */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
name|ieee80211_ff_age_all
argument_list|(
name|ic
argument_list|,
literal|100
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|IFQ_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|ath_tx_kick
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ath_dfs_tasklet_needed
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_dfstask
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxproc_cnt
operator|--
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate an RX mbuf for the given ath_buf and initialise  * it for EDMA.  *  * + Allocate a 4KB mbuf;  * + Setup the DMA map for the given buffer;  * + Return that.  */
end_comment

begin_function
specifier|static
name|int
name|ath_edma_rxbuf_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|len
decl_stmt|;
name|ATH_RX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_getm
argument_list|(
name|NULL
argument_list|,
name|sc
operator|->
name|sc_edma_bufsize
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/* XXX ?*/
comment|/* XXX warn/enforce alignment */
name|len
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
if|#
directive|if
literal|0
block|device_printf(sc->sc_dev, "%s: called: m=%p, size=%d, mtod=%p\n", 	    __func__, 	    m, 	    len, 	    mtod(m, char *));
endif|#
directive|endif
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
comment|/* 	 * Populate ath_buf fields. 	 */
name|bf
operator|->
name|bf_desc
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ath_desc
operator|*
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_lastds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
comment|/* XXX only really for TX? */
name|bf
operator|->
name|bf_m
operator|=
name|m
expr_stmt|;
comment|/* 	 * Zero the descriptor and ensure it makes it out to the 	 * bounce buffer if one is required. 	 * 	 * XXX PREWRITE will copy the whole buffer; we only needed it 	 * to sync the first 32 DWORDS.  Oh well. 	 */
name|memset
argument_list|(
name|bf
operator|->
name|bf_desc
argument_list|,
literal|'\0'
argument_list|,
name|sc
operator|->
name|sc_rx_statuslen
argument_list|)
expr_stmt|;
comment|/* 	 * Create DMA mapping. 	 */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed; error=%d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Set daddr to the physical mapping page. 	 */
name|bf
operator|->
name|bf_daddr
operator|=
name|bf
operator|->
name|bf_segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
comment|/* 	 * Prepare for the upcoming read. 	 * 	 * We need to both sync some data into the buffer (the zero'ed 	 * descriptor payload) and also prepare for the read that's going 	 * to occur. 	 */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Finish! */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a RX buffer.  */
end_comment

begin_function
specifier|static
name|struct
name|ath_buf
modifier|*
name|ath_edma_rxbuf_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ATH_RX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Allocate buffer */
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
comment|/* XXX shouldn't happen upon startup? */
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: nothing on rxbuf?!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Remove it from the free list */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
comment|/* Assign RX mbuf to it */
name|error
operator|=
name|ath_edma_rxbuf_init
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bf=%p, rxbuf alloc failed! error=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|bf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_edma_rxbuf_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|ATH_RX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Only unload the frame if we haven't consumed 	 * the mbuf via ath_rx_pkt(). 	 */
if|if
condition|(
name|bf
operator|->
name|bf_m
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* XXX lock? */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate up to 'n' entries and push them onto the hardware FIFO.  *  * Return how many entries were successfully pushed onto the  * FIFO.  */
end_comment

begin_function
specifier|static
name|int
name|ath_edma_rxfifo_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|HAL_RX_QUEUE
name|qtype
parameter_list|,
name|int
name|nbufs
parameter_list|)
block|{
name|struct
name|ath_rx_edma
modifier|*
name|re
init|=
operator|&
name|sc
operator|->
name|sc_rxedma
index|[
name|qtype
index|]
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ATH_RX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate buffers until the FIFO is full or nbufs is reached. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbufs
operator|&&
name|re
operator|->
name|m_fifo_depth
operator|<
name|re
operator|->
name|m_fifolen
condition|;
name|i
operator|++
control|)
block|{
comment|/* Ensure the FIFO is already blank, complain loudly! */
if|if
condition|(
name|re
operator|->
name|m_fifo
index|[
name|re
operator|->
name|m_fifo_tail
index|]
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Q%d: fifo[%d] != NULL (%p)\n"
argument_list|,
name|__func__
argument_list|,
name|qtype
argument_list|,
name|re
operator|->
name|m_fifo_tail
argument_list|,
name|re
operator|->
name|m_fifo
index|[
name|re
operator|->
name|m_fifo_tail
index|]
argument_list|)
expr_stmt|;
comment|/* Free the slot */
name|ath_edma_rxbuf_free
argument_list|(
name|sc
argument_list|,
name|re
operator|->
name|m_fifo
index|[
name|re
operator|->
name|m_fifo_tail
index|]
argument_list|)
expr_stmt|;
name|re
operator|->
name|m_fifo_depth
operator|--
expr_stmt|;
comment|/* XXX check it's not< 0 */
name|re
operator|->
name|m_fifo
index|[
name|re
operator|->
name|m_fifo_tail
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|bf
operator|=
name|ath_edma_rxbuf_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX should ensure the FIFO is not NULL? */
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Q%d: alloc failed: i=%d, nbufs=%d?\n"
argument_list|,
name|__func__
argument_list|,
name|qtype
argument_list|,
name|i
argument_list|,
name|nbufs
argument_list|)
expr_stmt|;
break|break;
block|}
name|re
operator|->
name|m_fifo
index|[
name|re
operator|->
name|m_fifo_tail
index|]
operator|=
name|bf
expr_stmt|;
comment|/* Write to the RX FIFO */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_EDMA_RX
argument_list|,
literal|"%s: Q%d: putrxbuf=%p (0x%jx)\n"
argument_list|,
name|__func__
argument_list|,
name|qtype
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
operator|(
name|uintmax_t
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|ath_hal_putrxbuf
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|,
name|qtype
argument_list|)
expr_stmt|;
name|re
operator|->
name|m_fifo_depth
operator|++
expr_stmt|;
name|INCR
argument_list|(
name|re
operator|->
name|m_fifo_tail
argument_list|,
name|re
operator|->
name|m_fifolen
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Return how many were allocated. 	 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_EDMA_RX
argument_list|,
literal|"%s: Q%d: nbufs=%d, nalloced=%d\n"
argument_list|,
name|__func__
argument_list|,
name|qtype
argument_list|,
name|nbufs
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_edma_rxfifo_flush
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|HAL_RX_QUEUE
name|qtype
parameter_list|)
block|{
name|struct
name|ath_rx_edma
modifier|*
name|re
init|=
operator|&
name|sc
operator|->
name|sc_rxedma
index|[
name|qtype
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ATH_RX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|re
operator|->
name|m_fifolen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|re
operator|->
name|m_fifo
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|ATH_DEBUG
name|struct
name|ath_buf
modifier|*
name|bf
init|=
name|re
operator|->
name|m_fifo
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_RECV_DESC
condition|)
name|ath_printrxbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|,
name|HAL_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ath_edma_rxbuf_free
argument_list|(
name|sc
argument_list|,
name|re
operator|->
name|m_fifo
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|re
operator|->
name|m_fifo
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|re
operator|->
name|m_fifo_depth
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|re
operator|->
name|m_rxpending
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|re
operator|->
name|m_rxpending
argument_list|)
expr_stmt|;
name|re
operator|->
name|m_rxpending
operator|=
name|NULL
expr_stmt|;
block|}
name|re
operator|->
name|m_fifo_head
operator|=
name|re
operator|->
name|m_fifo_tail
operator|=
name|re
operator|->
name|m_fifo_depth
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Setup the initial RX FIFO structure.  */
end_comment

begin_function
specifier|static
name|int
name|ath_edma_setup_rxfifo
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|HAL_RX_QUEUE
name|qtype
parameter_list|)
block|{
name|struct
name|ath_rx_edma
modifier|*
name|re
init|=
operator|&
name|sc
operator|->
name|sc_rxedma
index|[
name|qtype
index|]
decl_stmt|;
name|ATH_RX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_getrxfifodepth
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|qtype
argument_list|,
operator|&
name|re
operator|->
name|m_fifolen
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: qtype=%d, failed\n"
argument_list|,
name|__func__
argument_list|,
name|qtype
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: type=%d, FIFO depth = %d entries\n"
argument_list|,
name|__func__
argument_list|,
name|qtype
argument_list|,
name|re
operator|->
name|m_fifolen
argument_list|)
expr_stmt|;
comment|/* Allocate ath_buf FIFO array, pre-zero'ed */
name|re
operator|->
name|m_fifo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ath_buf
operator|*
argument_list|)
operator|*
name|re
operator|->
name|m_fifolen
argument_list|,
name|M_ATHDEV
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|m_fifo
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: malloc failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Set initial "empty" state. 	 */
name|re
operator|->
name|m_rxpending
operator|=
name|NULL
expr_stmt|;
name|re
operator|->
name|m_fifo_head
operator|=
name|re
operator|->
name|m_fifo_tail
operator|=
name|re
operator|->
name|m_fifo_depth
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_edma_rxfifo_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|HAL_RX_QUEUE
name|qtype
parameter_list|)
block|{
name|struct
name|ath_rx_edma
modifier|*
name|re
init|=
operator|&
name|sc
operator|->
name|sc_rxedma
index|[
name|qtype
index|]
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called; qtype=%d\n"
argument_list|,
name|__func__
argument_list|,
name|qtype
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|re
operator|->
name|m_fifo
argument_list|,
name|M_ATHDEV
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_edma_dma_rxsetup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* 	 * Create RX DMA tag and buffers. 	 */
name|error
operator|=
name|ath_descdma_setup_rx_edma
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
literal|"rx"
argument_list|,
name|ath_rxbuf
argument_list|,
name|sc
operator|->
name|sc_rx_statuslen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|ATH_RX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_edma_setup_rxfifo
argument_list|(
name|sc
argument_list|,
name|HAL_RX_QUEUE_HP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_edma_setup_rxfifo
argument_list|(
name|sc
argument_list|,
name|HAL_RX_QUEUE_LP
argument_list|)
expr_stmt|;
name|ATH_RX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_edma_dma_rxteardown
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ATH_RX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_edma_flush_deferred_queue
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_edma_rxfifo_flush
argument_list|(
name|sc
argument_list|,
name|HAL_RX_QUEUE_HP
argument_list|)
expr_stmt|;
name|ath_edma_rxfifo_free
argument_list|(
name|sc
argument_list|,
name|HAL_RX_QUEUE_HP
argument_list|)
expr_stmt|;
name|ath_edma_rxfifo_flush
argument_list|(
name|sc
argument_list|,
name|HAL_RX_QUEUE_LP
argument_list|)
expr_stmt|;
name|ath_edma_rxfifo_free
argument_list|(
name|sc
argument_list|,
name|HAL_RX_QUEUE_LP
argument_list|)
expr_stmt|;
name|ATH_RX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Free RX ath_buf */
comment|/* Free RX DMA tag */
if|if
condition|(
name|sc
operator|->
name|sc_rxdma
operator|.
name|dd_desc_len
operator|!=
literal|0
condition|)
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ath_recv_setup_edma
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Set buffer size to 4k */
name|sc
operator|->
name|sc_edma_bufsize
operator|=
literal|4096
expr_stmt|;
comment|/* Fetch EDMA field and buffer sizes */
operator|(
name|void
operator|)
name|ath_hal_getrxstatuslen
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_rx_statuslen
argument_list|)
expr_stmt|;
comment|/* Configure the hardware with the RX buffer size */
operator|(
name|void
operator|)
name|ath_hal_setrxbufsize
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_edma_bufsize
operator|-
name|sc
operator|->
name|sc_rx_statuslen
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"RX status length: %d\n"
argument_list|,
name|sc
operator|->
name|sc_rx_statuslen
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"RX buffer size: %d\n"
argument_list|,
name|sc
operator|->
name|sc_edma_bufsize
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_rx
operator|.
name|recv_stop
operator|=
name|ath_edma_stoprecv
expr_stmt|;
name|sc
operator|->
name|sc_rx
operator|.
name|recv_start
operator|=
name|ath_edma_startrecv
expr_stmt|;
name|sc
operator|->
name|sc_rx
operator|.
name|recv_flush
operator|=
name|ath_edma_recv_flush
expr_stmt|;
name|sc
operator|->
name|sc_rx
operator|.
name|recv_tasklet
operator|=
name|ath_edma_recv_tasklet
expr_stmt|;
name|sc
operator|->
name|sc_rx
operator|.
name|recv_rxbuf_init
operator|=
name|ath_edma_rxbuf_init
expr_stmt|;
name|sc
operator|->
name|sc_rx
operator|.
name|recv_setup
operator|=
name|ath_edma_dma_rxsetup
expr_stmt|;
name|sc
operator|->
name|sc_rx
operator|.
name|recv_teardown
operator|=
name|ath_edma_dma_rxteardown
expr_stmt|;
name|sc
operator|->
name|sc_rx
operator|.
name|recv_sched
operator|=
name|ath_edma_recv_sched
expr_stmt|;
name|sc
operator|->
name|sc_rx
operator|.
name|recv_sched_queue
operator|=
name|ath_edma_recv_sched_queue
expr_stmt|;
block|}
end_function

end_unit

