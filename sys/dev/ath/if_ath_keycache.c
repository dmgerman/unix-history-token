begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for the Atheros Wireless LAN controller.  *  * This software is derived from work of Atsushi Onoe; his contribution  * is greatly appreciated.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ath.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_athvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_keycache.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_misc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|ath_keyprint
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|u_int
name|ix
parameter_list|,
specifier|const
name|HAL_KEYVAL
modifier|*
name|hk
parameter_list|,
specifier|const
name|u_int8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|ciphers
index|[]
init|=
block|{
literal|"WEP"
block|,
literal|"AES-OCB"
block|,
literal|"AES-CCM"
block|,
literal|"CKIP"
block|,
literal|"TKIP"
block|,
literal|"CLR"
block|, 	}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|printf
argument_list|(
literal|"%s: [%02u] %-7s "
argument_list|,
name|tag
argument_list|,
name|ix
argument_list|,
name|ciphers
index|[
name|hk
operator|->
name|kv_type
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|n
operator|=
name|hk
operator|->
name|kv_len
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|hk
operator|->
name|kv_val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" mac %s"
argument_list|,
name|ether_sprintf
argument_list|(
name|mac
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hk
operator|->
name|kv_type
operator|==
name|HAL_CIPHER_TKIP
condition|)
block|{
name|printf
argument_list|(
literal|" %s "
argument_list|,
name|sc
operator|->
name|sc_splitmic
condition|?
literal|"mic"
else|:
literal|"rxmic"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|hk
operator|->
name|kv_mic
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_splitmic
condition|)
block|{
name|printf
argument_list|(
literal|" txmic "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_txmic
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|hk
operator|->
name|kv_txmic
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Set a TKIP key into the hardware.  This handles the  * potential distribution of key state to multiple key  * cache slots for TKIP.  */
end_comment

begin_function
specifier|static
name|int
name|ath_keyset_tkip
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
name|HAL_KEYVAL
modifier|*
name|hk
parameter_list|,
specifier|const
name|u_int8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
define|#
directive|define
name|IEEE80211_KEY_XR
value|(IEEE80211_KEY_XMIT | IEEE80211_KEY_RECV)
specifier|static
specifier|const
name|u_int8_t
name|zerobssid
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|KASSERT
argument_list|(
name|k
operator|->
name|wk_cipher
operator|->
name|ic_cipher
operator|==
name|IEEE80211_CIPHER_TKIP
argument_list|,
operator|(
literal|"got a non-TKIP key, cipher %u"
operator|,
name|k
operator|->
name|wk_cipher
operator|->
name|ic_cipher
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_XR
operator|)
operator|==
name|IEEE80211_KEY_XR
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_splitmic
condition|)
block|{
comment|/* 			 * TX key goes at first index, RX key at the rx index. 			 * The hal handles the MIC keys at index+64. 			 */
name|memcpy
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|,
name|k
operator|->
name|wk_txmic
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|)
argument_list|)
expr_stmt|;
name|KEYPRINTF
argument_list|(
name|sc
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|zerobssid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_keyset
argument_list|(
name|ah
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|zerobssid
argument_list|)
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|,
name|k
operator|->
name|wk_rxmic
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|)
argument_list|)
expr_stmt|;
name|KEYPRINTF
argument_list|(
name|sc
argument_list|,
name|k
operator|->
name|wk_keyix
operator|+
literal|32
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
expr_stmt|;
comment|/* XXX delete tx key on failure? */
return|return
name|ath_hal_keyset
argument_list|(
name|ah
argument_list|,
name|k
operator|->
name|wk_keyix
operator|+
literal|32
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
return|;
block|}
else|else
block|{
comment|/* 			 * Room for both TX+RX MIC keys in one key cache 			 * slot, just set key at the first index; the hal 			 * will handle the rest. 			 */
name|memcpy
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|,
name|k
operator|->
name|wk_rxmic
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hk
operator|->
name|kv_txmic
argument_list|,
name|k
operator|->
name|wk_txmic
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_txmic
argument_list|)
argument_list|)
expr_stmt|;
name|KEYPRINTF
argument_list|(
name|sc
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
expr_stmt|;
return|return
name|ath_hal_keyset
argument_list|(
name|ah
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_XMIT
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_splitmic
condition|)
block|{
comment|/* 			 * NB: must pass MIC key in expected location when 			 * the keycache only holds one MIC key per entry. 			 */
name|memcpy
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|,
name|k
operator|->
name|wk_txmic
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_txmic
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|hk
operator|->
name|kv_txmic
argument_list|,
name|k
operator|->
name|wk_txmic
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_txmic
argument_list|)
argument_list|)
expr_stmt|;
name|KEYPRINTF
argument_list|(
name|sc
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
expr_stmt|;
return|return
name|ath_hal_keyset
argument_list|(
name|ah
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_RECV
condition|)
block|{
name|memcpy
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|,
name|k
operator|->
name|wk_rxmic
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|)
argument_list|)
expr_stmt|;
name|KEYPRINTF
argument_list|(
name|sc
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
expr_stmt|;
return|return
name|ath_hal_keyset
argument_list|(
name|ah
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
return|;
block|}
return|return
literal|0
return|;
undef|#
directive|undef
name|IEEE80211_KEY_XR
block|}
end_function

begin_comment
comment|/*  * Set a net80211 key into the hardware.  This handles the  * potential distribution of key state to multiple key  * cache slots for TKIP with hardware MIC support.  */
end_comment

begin_function
name|int
name|ath_keyset
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|bss
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
specifier|static
specifier|const
name|u_int8_t
name|ciphermap
index|[]
init|=
block|{
name|HAL_CIPHER_WEP
block|,
comment|/* IEEE80211_CIPHER_WEP */
name|HAL_CIPHER_TKIP
block|,
comment|/* IEEE80211_CIPHER_TKIP */
name|HAL_CIPHER_AES_OCB
block|,
comment|/* IEEE80211_CIPHER_AES_OCB */
name|HAL_CIPHER_AES_CCM
block|,
comment|/* IEEE80211_CIPHER_AES_CCM */
operator|(
name|u_int8_t
operator|)
operator|-
literal|1
block|,
comment|/* 4 is not allocated */
name|HAL_CIPHER_CKIP
block|,
comment|/* IEEE80211_CIPHER_CKIP */
name|HAL_CIPHER_CLR
block|,
comment|/* IEEE80211_CIPHER_NONE */
block|}
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
specifier|const
name|struct
name|ieee80211_cipher
modifier|*
name|cip
init|=
name|k
operator|->
name|wk_cipher
decl_stmt|;
name|u_int8_t
name|gmac
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
specifier|const
name|u_int8_t
modifier|*
name|mac
decl_stmt|;
name|HAL_KEYVAL
name|hk
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hk
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Software crypto uses a "clear key" so non-crypto 	 * state kept in the key cache are maintained and 	 * so that rx frames have an entry to match. 	 */
if|if
condition|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWCRYPT
operator|)
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|cip
operator|->
name|ic_cipher
operator|<
name|N
argument_list|(
name|ciphermap
argument_list|)
argument_list|,
operator|(
literal|"invalid cipher type %u"
operator|,
name|cip
operator|->
name|ic_cipher
operator|)
argument_list|)
expr_stmt|;
name|hk
operator|.
name|kv_type
operator|=
name|ciphermap
index|[
name|cip
operator|->
name|ic_cipher
index|]
expr_stmt|;
name|hk
operator|.
name|kv_len
operator|=
name|k
operator|->
name|wk_keylen
expr_stmt|;
name|memcpy
argument_list|(
name|hk
operator|.
name|kv_val
argument_list|,
name|k
operator|->
name|wk_key
argument_list|,
name|k
operator|->
name|wk_keylen
argument_list|)
expr_stmt|;
block|}
else|else
name|hk
operator|.
name|kv_type
operator|=
name|HAL_CIPHER_CLR
expr_stmt|;
comment|/* 	 * If we're installing a clear cipher key and 	 * the hardware doesn't support that, just succeed. 	 * Leave it up to the net80211 layer to figure it out. 	 */
if|if
condition|(
name|hk
operator|.
name|kv_type
operator|==
name|HAL_CIPHER_CLR
operator|&&
name|sc
operator|->
name|sc_hasclrkey
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * XXX TODO: check this: 	 *  	 * Group keys on hardware that supports multicast frame 	 * key search should only be done in adhoc/hostap mode, 	 * not STA mode. 	 * 	 * XXX TODO: what about mesh, tdma? 	 */
if|#
directive|if
literal|0
block|if ((vap->iv_opmode == IEEE80211_M_HOSTAP || 	     vap->iv_opmode == IEEE80211_M_IBSS)&&
else|#
directive|else
if|if
condition|(
endif|#
directive|endif
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_GROUP
operator|)
operator|&&
name|sc
operator|->
name|sc_mcastkey
condition|)
block|{
comment|/* 		 * Group keys on hardware that supports multicast frame 		 * key search use a MAC that is the sender's address with 		 * the multicast bit set instead of the app-specified address. 		 */
name|IEEE80211_ADDR_COPY
argument_list|(
name|gmac
argument_list|,
name|bss
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
name|gmac
index|[
literal|0
index|]
operator||=
literal|0x01
expr_stmt|;
name|mac
operator|=
name|gmac
expr_stmt|;
block|}
else|else
name|mac
operator|=
name|k
operator|->
name|wk_macaddr
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hk
operator|.
name|kv_type
operator|==
name|HAL_CIPHER_TKIP
operator|&&
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWMIC
operator|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|ath_keyset_tkip
argument_list|(
name|sc
argument_list|,
name|k
argument_list|,
operator|&
name|hk
argument_list|,
name|mac
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KEYPRINTF
argument_list|(
name|sc
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
operator|&
name|hk
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ath_hal_keyset
argument_list|(
name|ah
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
operator|&
name|hk
argument_list|,
name|mac
argument_list|)
expr_stmt|;
block|}
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Allocate tx/rx key slots for TKIP.  We allocate two slots for  * each key, one for decrypt/encrypt and the other for the MIC.  */
end_comment

begin_function
specifier|static
name|u_int16_t
name|key_alloc_2pair
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ieee80211_keyix
modifier|*
name|txkeyix
parameter_list|,
name|ieee80211_keyix
modifier|*
name|rxkeyix
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|u_int
name|i
decl_stmt|,
name|keyix
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_splitmic
argument_list|,
operator|(
literal|"key cache !split"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX could optimize */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|u_int8_t
name|b
init|=
name|sc
operator|->
name|sc_keymap
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|0xff
condition|)
block|{
comment|/* 			 * One or more slots in this byte are free. 			 */
name|keyix
operator|=
name|i
operator|*
name|NBBY
expr_stmt|;
while|while
condition|(
name|b
operator|&
literal|1
condition|)
block|{
name|again
label|:
name|keyix
operator|++
expr_stmt|;
name|b
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* XXX IEEE80211_KEY_XMIT | IEEE80211_KEY_RECV */
if|if
condition|(
name|isset
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|32
argument_list|)
operator|||
name|isset
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|64
argument_list|)
operator|||
name|isset
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|32
operator|+
literal|64
argument_list|)
condition|)
block|{
comment|/* full pair unavailable */
comment|/* XXX statistic */
if|if
condition|(
name|keyix
operator|==
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|NBBY
condition|)
block|{
comment|/* no slots were appropriate, advance */
continue|continue;
block|}
goto|goto
name|again
goto|;
block|}
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|64
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|32
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|32
operator|+
literal|64
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: key pair %u,%u %u,%u\n"
argument_list|,
name|__func__
argument_list|,
name|keyix
argument_list|,
name|keyix
operator|+
literal|64
argument_list|,
name|keyix
operator|+
literal|32
argument_list|,
name|keyix
operator|+
literal|32
operator|+
literal|64
argument_list|)
expr_stmt|;
operator|*
name|txkeyix
operator|=
name|keyix
expr_stmt|;
operator|*
name|rxkeyix
operator|=
name|keyix
operator|+
literal|32
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: out of pair space\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Allocate tx/rx key slots for TKIP.  We allocate two slots for  * each key, one for decrypt/encrypt and the other for the MIC.  */
end_comment

begin_function
specifier|static
name|u_int16_t
name|key_alloc_pair
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ieee80211_keyix
modifier|*
name|txkeyix
parameter_list|,
name|ieee80211_keyix
modifier|*
name|rxkeyix
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|u_int
name|i
decl_stmt|,
name|keyix
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
name|sc
operator|->
name|sc_splitmic
argument_list|,
operator|(
literal|"key cache split"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX could optimize */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|u_int8_t
name|b
init|=
name|sc
operator|->
name|sc_keymap
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|0xff
condition|)
block|{
comment|/* 			 * One or more slots in this byte are free. 			 */
name|keyix
operator|=
name|i
operator|*
name|NBBY
expr_stmt|;
while|while
condition|(
name|b
operator|&
literal|1
condition|)
block|{
name|again
label|:
name|keyix
operator|++
expr_stmt|;
name|b
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|isset
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|64
argument_list|)
condition|)
block|{
comment|/* full pair unavailable */
comment|/* XXX statistic */
if|if
condition|(
name|keyix
operator|==
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|NBBY
condition|)
block|{
comment|/* no slots were appropriate, advance */
continue|continue;
block|}
goto|goto
name|again
goto|;
block|}
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|64
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: key pair %u,%u\n"
argument_list|,
name|__func__
argument_list|,
name|keyix
argument_list|,
name|keyix
operator|+
literal|64
argument_list|)
expr_stmt|;
operator|*
name|txkeyix
operator|=
operator|*
name|rxkeyix
operator|=
name|keyix
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: out of pair space\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Allocate a single key cache slot.  */
end_comment

begin_function
specifier|static
name|int
name|key_alloc_single
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ieee80211_keyix
modifier|*
name|txkeyix
parameter_list|,
name|ieee80211_keyix
modifier|*
name|rxkeyix
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|u_int
name|i
decl_stmt|,
name|keyix
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hasclrkey
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Map to slot 0 for the AR5210. 		 */
operator|*
name|txkeyix
operator|=
operator|*
name|rxkeyix
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* XXX try i,i+32,i+64,i+32+64 to minimize key pair conflicts */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|u_int8_t
name|b
init|=
name|sc
operator|->
name|sc_keymap
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|0xff
condition|)
block|{
comment|/* 			 * One or more slots are free. 			 */
name|keyix
operator|=
name|i
operator|*
name|NBBY
expr_stmt|;
while|while
condition|(
name|b
operator|&
literal|1
condition|)
name|keyix
operator|++
operator|,
name|b
operator|>>=
literal|1
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: key %u\n"
argument_list|,
name|__func__
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
operator|*
name|txkeyix
operator|=
operator|*
name|rxkeyix
operator|=
name|keyix
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: out of space\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Allocate one or more key cache slots for a uniacst key.  The  * key itself is needed only to identify the cipher.  For hardware  * TKIP with split cipher+MIC keys we allocate two key cache slot  * pairs so that we can setup separate TX and RX MIC keys.  Note  * that the MIC key for a TKIP key at slot i is assumed by the  * hardware to be at slot i+64.  This limits TKIP keys to the first  * 64 entries.  */
end_comment

begin_function
name|int
name|ath_key_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
name|ieee80211_keyix
modifier|*
name|keyix
parameter_list|,
name|ieee80211_keyix
modifier|*
name|rxkeyix
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
comment|/* 	 * Group key allocation must be handled specially for 	 * parts that do not support multicast key cache search 	 * functionality.  For those parts the key id must match 	 * the h/w key index so lookups find the right key.  On 	 * parts w/ the key search facility we install the sender's 	 * mac address (with the high bit set) and let the hardware 	 * find the key w/o using the key id.  This is preferred as 	 * it permits us to support multiple users for adhoc and/or 	 * multi-station operation. 	 */
if|if
condition|(
name|k
operator|->
name|wk_keyix
operator|!=
name|IEEE80211_KEYIX_NONE
condition|)
block|{
comment|/* 		 * Only global keys should have key index assigned. 		 */
if|if
condition|(
operator|!
operator|(
operator|&
name|vap
operator|->
name|iv_nw_keys
index|[
literal|0
index|]
operator|<=
name|k
operator|&&
name|k
operator|<
operator|&
name|vap
operator|->
name|iv_nw_keys
index|[
name|IEEE80211_WEP_NKID
index|]
operator|)
condition|)
block|{
comment|/* should not happen */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: bogus group key\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_HOSTAP
operator|||
operator|!
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_GROUP
operator|)
operator|||
operator|!
name|sc
operator|->
name|sc_mcastkey
condition|)
block|{
comment|/* 			 * XXX we pre-allocate the global keys so 			 * have no way to check if they've already 			 * been allocated. 			 */
operator|*
name|keyix
operator|=
operator|*
name|rxkeyix
operator|=
name|k
operator|-
name|vap
operator|->
name|iv_nw_keys
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 		 * Group key and device supports multicast key search. 		 */
name|k
operator|->
name|wk_keyix
operator|=
name|IEEE80211_KEYIX_NONE
expr_stmt|;
block|}
comment|/* 	 * We allocate two pair for TKIP when using the h/w to do 	 * the MIC.  For everything else, including software crypto, 	 * we allocate a single entry.  Note that s/w crypto requires 	 * a pass-through slot on the 5211 and 5212.  The 5210 does 	 * not support pass-through cache entries and we map all 	 * those requests to slot 0. 	 */
if|if
condition|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWCRYPT
condition|)
block|{
return|return
name|key_alloc_single
argument_list|(
name|sc
argument_list|,
name|keyix
argument_list|,
name|rxkeyix
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|k
operator|->
name|wk_cipher
operator|->
name|ic_cipher
operator|==
name|IEEE80211_CIPHER_TKIP
operator|&&
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWMIC
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_splitmic
condition|)
return|return
name|key_alloc_2pair
argument_list|(
name|sc
argument_list|,
name|keyix
argument_list|,
name|rxkeyix
argument_list|)
return|;
else|else
return|return
name|key_alloc_pair
argument_list|(
name|sc
argument_list|,
name|keyix
argument_list|,
name|rxkeyix
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|key_alloc_single
argument_list|(
name|sc
argument_list|,
name|keyix
argument_list|,
name|rxkeyix
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Delete an entry in the key cache allocated by ath_key_alloc.  */
end_comment

begin_function
name|int
name|ath_key_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
specifier|const
name|struct
name|ieee80211_cipher
modifier|*
name|cip
init|=
name|k
operator|->
name|wk_cipher
decl_stmt|;
name|u_int
name|keyix
init|=
name|k
operator|->
name|wk_keyix
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: delete key %u\n"
argument_list|,
name|__func__
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ath_hal_keyreset
argument_list|(
name|ah
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
comment|/* 	 * Handle split tx/rx keying required for TKIP with h/w MIC. 	 */
if|if
condition|(
name|cip
operator|->
name|ic_cipher
operator|==
name|IEEE80211_CIPHER_TKIP
operator|&&
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWMIC
operator|)
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_splitmic
condition|)
name|ath_hal_keyreset
argument_list|(
name|ah
argument_list|,
name|keyix
operator|+
literal|32
argument_list|)
expr_stmt|;
comment|/* RX key */
if|if
condition|(
name|keyix
operator|>=
name|IEEE80211_WEP_NKID
condition|)
block|{
comment|/* 		 * Don't touch keymap entries for global keys so 		 * they are never considered for dynamic allocation. 		 */
name|clrbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
if|if
condition|(
name|cip
operator|->
name|ic_cipher
operator|==
name|IEEE80211_CIPHER_TKIP
operator|&&
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWMIC
operator|)
operator|==
literal|0
condition|)
block|{
name|clrbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|64
argument_list|)
expr_stmt|;
comment|/* TX key MIC */
if|if
condition|(
name|sc
operator|->
name|sc_splitmic
condition|)
block|{
comment|/* +32 for RX key, +32+64 for RX key MIC */
name|clrbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|32
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|32
operator|+
literal|64
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Set the key cache contents for the specified key.  Key cache  * slot(s) must already have been allocated by ath_key_alloc.  */
end_comment

begin_function
name|int
name|ath_key_set
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
specifier|const
name|u_int8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
return|return
name|ath_keyset
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|,
name|k
argument_list|,
name|vap
operator|->
name|iv_bss
argument_list|)
return|;
block|}
end_function

end_unit

