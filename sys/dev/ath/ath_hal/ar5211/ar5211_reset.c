begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2002-2006 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_comment
comment|/*  * Chips specific device attachment and device info collection  * Connects Init Reg Vectors, EEPROM Data, and device Functions.  */
end_comment

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_devid.h"
end_include

begin_include
include|#
directive|include
file|"ar5211/ar5211.h"
end_include

begin_include
include|#
directive|include
file|"ar5211/ar5211reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5211/ar5211phy.h"
end_include

begin_include
include|#
directive|include
file|"ah_eeprom_v3.h"
end_include

begin_comment
comment|/* Add static register initialization vectors */
end_comment

begin_include
include|#
directive|include
file|"ar5211/boss.ini"
end_include

begin_comment
comment|/*  * Structure to hold 11b tuning information for Beanie/Sombrero  * 16 MHz mode, divider ratio = 198 = NP+S. N=16, S=4 or 6, P=12  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint32_t
name|refClkSel
decl_stmt|;
comment|/* reference clock, 1 for 16 MHz */
name|uint32_t
name|channelSelect
decl_stmt|;
comment|/* P[7:4]S[3:0] bits */
name|uint16_t
name|channel5111
decl_stmt|;
comment|/* 11a channel for 5111 */
block|}
name|CHAN_INFO_2GHZ
typedef|;
end_typedef

begin_define
define|#
directive|define
name|CI_2GHZ_INDEX_CORRECTION
value|19
end_define

begin_decl_stmt
specifier|const
specifier|static
name|CHAN_INFO_2GHZ
name|chan2GHzData
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|0x46
block|,
literal|96
block|}
block|,
comment|/* 2312 -19 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|97
block|}
block|,
comment|/* 2317 -18 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|98
block|}
block|,
comment|/* 2322 -17 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|99
block|}
block|,
comment|/* 2327 -16 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|100
block|}
block|,
comment|/* 2332 -15 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|101
block|}
block|,
comment|/* 2337 -14 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|102
block|}
block|,
comment|/* 2342 -13 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|103
block|}
block|,
comment|/* 2347 -12 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|104
block|}
block|,
comment|/* 2352 -11 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|105
block|}
block|,
comment|/* 2357 -10 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|106
block|}
block|,
comment|/* 2362  -9 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|107
block|}
block|,
comment|/* 2367  -8 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|108
block|}
block|,
comment|/* 2372  -7 */
comment|/* index -6 to 0 are pad to make this a nolookup table */
block|{
literal|1
block|,
literal|0x46
block|,
literal|116
block|}
block|,
comment|/*       -6 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|116
block|}
block|,
comment|/*       -5 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|116
block|}
block|,
comment|/*       -4 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|116
block|}
block|,
comment|/*       -3 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|116
block|}
block|,
comment|/*       -2 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|116
block|}
block|,
comment|/*       -1 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|116
block|}
block|,
comment|/*        0 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|116
block|}
block|,
comment|/* 2412   1 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|117
block|}
block|,
comment|/* 2417   2 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|118
block|}
block|,
comment|/* 2422   3 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|119
block|}
block|,
comment|/* 2427   4 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|120
block|}
block|,
comment|/* 2432   5 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|121
block|}
block|,
comment|/* 2437   6 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|122
block|}
block|,
comment|/* 2442   7 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|123
block|}
block|,
comment|/* 2447   8 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|124
block|}
block|,
comment|/* 2452   9 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|125
block|}
block|,
comment|/* 2457  10 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|126
block|}
block|,
comment|/* 2462  11 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|127
block|}
block|,
comment|/* 2467  12 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|128
block|}
block|,
comment|/* 2472  13 */
block|{
literal|1
block|,
literal|0x44
block|,
literal|124
block|}
block|,
comment|/* 2484  14 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|136
block|}
block|,
comment|/* 2512  15 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|140
block|}
block|,
comment|/* 2532  16 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|144
block|}
block|,
comment|/* 2552  17 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|148
block|}
block|,
comment|/* 2572  18 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|152
block|}
block|,
comment|/* 2592  19 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|156
block|}
block|,
comment|/* 2612  20 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|160
block|}
block|,
comment|/* 2632  21 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|164
block|}
block|,
comment|/* 2652  22 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|168
block|}
block|,
comment|/* 2672  23 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|172
block|}
block|,
comment|/* 2692  24 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|176
block|}
block|,
comment|/* 2712  25 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|180
block|}
comment|/* 2732  26 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Power timeouts in usec to wait for chip to wake-up. */
end_comment

begin_define
define|#
directive|define
name|POWER_UP_TIME
value|2000
end_define

begin_define
define|#
directive|define
name|DELAY_PLL_SETTLE
value|300
end_define

begin_comment
comment|/* 300 us */
end_comment

begin_define
define|#
directive|define
name|DELAY_BASE_ACTIVATE
value|100
end_define

begin_comment
comment|/* 100 us */
end_comment

begin_define
define|#
directive|define
name|NUM_RATES
value|8
end_define

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5211SetResetReg
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|resetMask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5211SetChannel
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int16_t
name|ar5211RunNoiseFloor
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|uint8_t
name|runTime
parameter_list|,
name|int16_t
name|startingNF
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5211IsNfGood
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5211SetRf6and7
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5211SetBoardValues
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5211SetPowerTable
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|PCDACS_EEPROM
modifier|*
name|pSrcStruct
parameter_list|,
name|uint16_t
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5211SetTransmitPower
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5211SetRateTable
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|RD_EDGES_POWER
modifier|*
name|pRdEdgesPower
parameter_list|,
name|TRGT_POWER_INFO
modifier|*
name|pPowerInfo
parameter_list|,
name|uint16_t
name|numChannels
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|ar5211GetScaledPower
parameter_list|(
name|uint16_t
name|channel
parameter_list|,
name|uint16_t
name|pcdacValue
parameter_list|,
specifier|const
name|PCDACS_EEPROM
modifier|*
name|pSrcStruct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5211FindValueInList
parameter_list|(
name|uint16_t
name|channel
parameter_list|,
name|uint16_t
name|pcdacValue
parameter_list|,
specifier|const
name|PCDACS_EEPROM
modifier|*
name|pSrcStruct
parameter_list|,
name|uint16_t
modifier|*
name|powerValue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|ar5211GetInterpolatedValue
parameter_list|(
name|uint16_t
name|target
parameter_list|,
name|uint16_t
name|srcLeft
parameter_list|,
name|uint16_t
name|srcRight
parameter_list|,
name|uint16_t
name|targetLeft
parameter_list|,
name|uint16_t
name|targetRight
parameter_list|,
name|HAL_BOOL
name|scaleUp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5211GetLowerUpperValues
parameter_list|(
name|uint16_t
name|value
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|pList
parameter_list|,
name|uint16_t
name|listSize
parameter_list|,
name|uint16_t
modifier|*
name|pLowerValue
parameter_list|,
name|uint16_t
modifier|*
name|pUpperValue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5211GetLowerUpperPcdacs
parameter_list|(
name|uint16_t
name|pcdac
parameter_list|,
name|uint16_t
name|channel
parameter_list|,
specifier|const
name|PCDACS_EEPROM
modifier|*
name|pSrcStruct
parameter_list|,
name|uint16_t
modifier|*
name|pLowerPcdac
parameter_list|,
name|uint16_t
modifier|*
name|pUpperPcdac
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5211SetRfgain
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
specifier|const
name|GAIN_VALUES
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5211RequestRfgain
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5211InvalidGainReadback
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|GAIN_VALUES
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5211IsGainAdjustNeeded
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
specifier|const
name|GAIN_VALUES
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|ar5211AdjustGain
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|GAIN_VALUES
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5211SetOperatingMode
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|int
name|opmode
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Places the device in and out of reset and then places sane  * values in the registers based on EEPROM config, initialization  * vectors (as determined by the mode), and station configuration  *  * bChannelChange is used to preserve DMA/PCU registers across  * a HW Reset during channel change.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5211Reset
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_OPMODE
name|opmode
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|HAL_BOOL
name|bChannelChange
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
name|uint32_t
name|softLedCfg
decl_stmt|,
name|softLedState
decl_stmt|;
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) /sizeof (a[0]))
define|#
directive|define
name|FAIL
parameter_list|(
name|_code
parameter_list|)
value|do { ecode = _code; goto bad; } while (0)
name|struct
name|ath_hal_5211
modifier|*
name|ahp
init|=
name|AH5211
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|ledstate
decl_stmt|;
name|HAL_STATUS
name|ecode
decl_stmt|;
name|int
name|q
decl_stmt|;
name|uint32_t
name|data
decl_stmt|,
name|synthDelay
decl_stmt|;
name|uint32_t
name|macStaId1
decl_stmt|;
name|uint16_t
name|modesIndex
init|=
literal|0
decl_stmt|,
name|freqIndex
init|=
literal|0
decl_stmt|;
name|uint32_t
name|saveFrameSeqCount
index|[
name|AR_NUM_DCU
index|]
decl_stmt|;
name|uint32_t
name|saveTsfLow
init|=
literal|0
decl_stmt|,
name|saveTsfHigh
init|=
literal|0
decl_stmt|;
name|uint32_t
name|saveDefAntenna
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s: opmode %u channel %u/0x%x %s channel\n"
argument_list|,
name|__func__
argument_list|,
name|opmode
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|,
name|bChannelChange
condition|?
literal|"change"
else|:
literal|"same"
argument_list|)
expr_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET
argument_list|,
name|bChannelChange
argument_list|)
expr_stmt|;
comment|/* 	 * Map public channel to private. 	 */
name|ichan
operator|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ichan
operator|==
name|AH_NULL
condition|)
name|FAIL
argument_list|(
name|HAL_EINVAL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opmode
condition|)
block|{
case|case
name|HAL_M_STA
case|:
case|case
name|HAL_M_IBSS
case|:
case|case
name|HAL_M_HOSTAP
case|:
case|case
name|HAL_M_MONITOR
case|:
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid operating mode %u\n"
argument_list|,
name|__func__
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EINVAL
argument_list|)
expr_stmt|;
break|break;
block|}
name|HALASSERT
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeversion
operator|>=
name|AR_EEPROM_VER3
argument_list|)
expr_stmt|;
comment|/* Preserve certain DMA hardware registers on a channel change */
if|if
condition|(
name|bChannelChange
condition|)
block|{
comment|/* 		 * Need to save/restore the TSF because of an issue 		 * that accelerates the TSF during a chip reset. 		 * 		 * We could use system timer routines to more 		 * accurately restore the TSF, but 		 * 1. Timer routines on certain platforms are 		 *	not accurate enough (e.g. 1 ms resolution). 		 * 2. It would still not be accurate. 		 * 		 * The most important aspect of this workaround, 		 * is that, after reset, the TSF is behind 		 * other STAs TSFs.  This will allow the STA to 		 * properly resynchronize its TSF in adhoc mode. 		 */
name|saveTsfLow
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|)
expr_stmt|;
name|saveTsfHigh
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_U32
argument_list|)
expr_stmt|;
comment|/* Read frame sequence count */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|>=
name|AR_SREV_VERSION_OAHU
condition|)
block|{
name|saveFrameSeqCount
index|[
literal|0
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_D0_SEQNUM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR_NUM_DCU
condition|;
name|i
operator|++
control|)
name|saveFrameSeqCount
index|[
name|i
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_DSEQNUM
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_DFS
argument_list|(
name|chan
argument_list|)
condition|)
name|chan
operator|->
name|ic_state
operator|&=
operator|~
name|IEEE80211_CHANSTATE_CWINT
expr_stmt|;
block|}
comment|/* 	 * Preserve the antenna on a channel change 	 */
name|saveDefAntenna
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_DEF_ANTENNA
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveDefAntenna
operator|==
literal|0
condition|)
name|saveDefAntenna
operator|=
literal|1
expr_stmt|;
comment|/* Save hardware flag before chip reset clears the register */
name|macStaId1
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|)
operator|&
name|AR_STA_ID1_BASE_RATE_11B
expr_stmt|;
comment|/* Save led state from pci config register */
name|ledstate
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|)
operator|&
operator|(
name|AR_PCICFG_LEDCTL
operator||
name|AR_PCICFG_LEDMODE
operator||
name|AR_PCICFG_LEDBLINK
operator||
name|AR_PCICFG_LEDSLOW
operator|)
expr_stmt|;
name|softLedCfg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_GPIOCR
argument_list|)
expr_stmt|;
name|softLedState
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_GPIODO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar5211ChipReset
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: chip reset failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
comment|/* Setup the indices for the next set of register array writes */
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|freqIndex
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
condition|)
name|modesIndex
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|chan
argument_list|)
condition|)
name|modesIndex
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel %u/0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EINVAL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|freqIndex
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|chan
argument_list|)
condition|)
name|modesIndex
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_PUREG
argument_list|(
name|chan
argument_list|)
condition|)
name|modesIndex
operator|=
literal|4
expr_stmt|;
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel %u/0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EINVAL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set correct Baseband to analog shift setting to access analog chips. */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|>=
name|AR_SREV_VERSION_OAHU
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BASE
argument_list|,
literal|0x00000007
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BASE
argument_list|,
literal|0x00000047
argument_list|)
expr_stmt|;
block|}
comment|/* Write parameters specific to AR5211 */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|>=
name|AR_SREV_VERSION_OAHU
condition|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
operator|&&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeversion
operator|>=
name|AR_EEPROM_VER3_1
condition|)
block|{
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|uint32_t
name|ob2GHz
decl_stmt|,
name|db2GHz
decl_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|ob2GHz
operator|=
name|ee
operator|->
name|ee_ob2GHz
index|[
literal|0
index|]
expr_stmt|;
name|db2GHz
operator|=
name|ee
operator|->
name|ee_db2GHz
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|ob2GHz
operator|=
name|ee
operator|->
name|ee_ob2GHz
index|[
literal|1
index|]
expr_stmt|;
name|db2GHz
operator|=
name|ee
operator|->
name|ee_db2GHz
index|[
literal|1
index|]
expr_stmt|;
block|}
name|ob2GHz
operator|=
name|ath_hal_reverseBits
argument_list|(
name|ob2GHz
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|db2GHz
operator|=
name|ath_hal_reverseBits
argument_list|(
name|db2GHz
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ar5211Mode2_4
index|[
literal|25
index|]
index|[
name|freqIndex
index|]
operator|=
operator|(
name|ar5211Mode2_4
index|[
literal|25
index|]
index|[
name|freqIndex
index|]
operator|&
operator|~
literal|0xC0
operator|)
operator||
operator|(
operator|(
name|ob2GHz
operator|<<
literal|6
operator|)
operator|&
literal|0xC0
operator|)
expr_stmt|;
name|ar5211Mode2_4
index|[
literal|26
index|]
index|[
name|freqIndex
index|]
operator|=
operator|(
name|ar5211Mode2_4
index|[
literal|26
index|]
index|[
name|freqIndex
index|]
operator|&
operator|~
literal|0x0F
operator|)
operator||
operator|(
operator|(
operator|(
name|ob2GHz
operator|>>
literal|2
operator|)
operator|&
literal|0x1
operator|)
operator||
operator|(
operator|(
name|db2GHz
operator|<<
literal|1
operator|)
operator|&
literal|0x0E
operator|)
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|ar5211Mode2_4
argument_list|)
condition|;
name|i
operator|++
control|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|ar5211Mode2_4
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|ar5211Mode2_4
index|[
name|i
index|]
index|[
name|freqIndex
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Write the analog registers 6 and 7 before other config */
name|ar5211SetRf6and7
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* Write registers that vary across all modes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|ar5211Modes
argument_list|)
condition|;
name|i
operator|++
control|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|ar5211Modes
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|ar5211Modes
index|[
name|i
index|]
index|[
name|modesIndex
index|]
argument_list|)
expr_stmt|;
comment|/* Write RFGain Parameters that differ between 2.4 and 5 GHz */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|ar5211BB_RfGain
argument_list|)
condition|;
name|i
operator|++
control|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|ar5211BB_RfGain
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|ar5211BB_RfGain
index|[
name|i
index|]
index|[
name|freqIndex
index|]
argument_list|)
expr_stmt|;
comment|/* Write Common Array Parameters */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|ar5211Common
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|reg
init|=
name|ar5211Common
index|[
name|i
index|]
index|[
literal|0
index|]
decl_stmt|;
comment|/* On channel change, don't reset the PCU registers */
if|if
condition|(
operator|!
operator|(
name|bChannelChange
operator|&&
operator|(
literal|0x8000
operator|<=
name|reg
operator|&&
name|reg
operator|<
literal|0x9000
operator|)
operator|)
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|reg
argument_list|,
name|ar5211Common
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Fix pre-AR5211 register values, this includes AR5311s. */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|<
name|AR_SREV_VERSION_OAHU
condition|)
block|{
comment|/* 		 * The TX and RX latency values have changed locations 		 * within the USEC register in AR5211.  Since they're 		 * set via the .ini, for both AR5211 and AR5311, they 		 * are written properly here for AR5311. 		 */
name|data
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_USEC
argument_list|)
expr_stmt|;
comment|/* Must be 0 for proper write in AR5311 */
name|HALASSERT
argument_list|(
operator|(
name|data
operator|&
literal|0x00700000
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_USEC
argument_list|,
operator|(
name|data
operator|&
operator|(
name|AR_USEC_M
operator||
name|AR_USEC_32_M
operator||
name|AR5311_USEC_TX_LAT_M
operator|)
operator|)
operator||
operator|(
operator|(
literal|29
operator|<<
name|AR5311_USEC_RX_LAT_S
operator|)
operator|&
name|AR5311_USEC_RX_LAT_M
operator|)
argument_list|)
expr_stmt|;
comment|/* The following registers exist only on AR5311. */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR5311_QDCLKGATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set proper ADC& DAC delays for AR5311. */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0x00009878
argument_list|,
literal|0x00000008
argument_list|)
expr_stmt|;
comment|/* Enable the PCU FIFO corruption ECO on AR5311. */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|)
operator||
name|AR5311_DIAG_SW_USE_ECO
argument_list|)
expr_stmt|;
block|}
comment|/* Restore certain DMA hardware registers on a channel change */
if|if
condition|(
name|bChannelChange
condition|)
block|{
comment|/* Restore TSF */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|,
name|saveTsfLow
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TSF_U32
argument_list|,
name|saveTsfHigh
argument_list|)
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|>=
name|AR_SREV_VERSION_OAHU
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_D0_SEQNUM
argument_list|,
name|saveFrameSeqCount
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR_NUM_DCU
condition|;
name|i
operator|++
control|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DSEQNUM
argument_list|(
name|i
argument_list|)
argument_list|,
name|saveFrameSeqCount
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID0
argument_list|,
name|LE_READ_4
argument_list|(
name|ahp
operator|->
name|ah_macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|LE_READ_2
argument_list|(
name|ahp
operator|->
name|ah_macaddr
operator|+
literal|4
argument_list|)
operator||
name|macStaId1
argument_list|)
expr_stmt|;
name|ar5211SetOperatingMode
argument_list|(
name|ah
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
comment|/* Restore previous led state */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|)
operator||
name|ledstate
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_GPIOCR
argument_list|,
name|softLedCfg
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_GPIODO
argument_list|,
name|softLedState
argument_list|)
expr_stmt|;
comment|/* Restore previous antenna */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DEF_ANTENNA
argument_list|,
name|saveDefAntenna
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSS_ID0
argument_list|,
name|LE_READ_4
argument_list|(
name|ahp
operator|->
name|ah_bssid
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSS_ID1
argument_list|,
name|LE_READ_2
argument_list|(
name|ahp
operator|->
name|ah_bssid
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore bmiss rssi& count thresholds */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RSSI_THR
argument_list|,
name|ahp
operator|->
name|ah_rssiThr
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_ISR
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
comment|/* cleared on write */
comment|/* 	 * for pre-Production Oahu only. 	 * Disable clock gating in all DMA blocks. Helps when using 	 * 11B and AES but results in higher power consumption. 	 */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|==
name|AR_SREV_VERSION_OAHU
operator|&&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macRev
operator|<
name|AR_SREV_OAHU_PROD
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CFG
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_CFG
argument_list|)
operator||
name|AR_CFG_CLK_GATE_DIS
argument_list|)
expr_stmt|;
block|}
comment|/* Setup the transmit power values. */
if|if
condition|(
operator|!
name|ar5211SetTransmitPower
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: error init'ing transmit power\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Configurable OFDM spoofing for 11n compatibility; used 	 * only when operating in station mode. 	 */
if|if
condition|(
name|opmode
operator|!=
name|HAL_M_HOSTAP
operator|&&
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_11nCompat
operator|&
name|HAL_DIAG_11N_SERVICES
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* NB: override the .ini setting */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_FRAME_CTL
argument_list|,
name|AR_PHY_FRAME_CTL_ERR_SERV
argument_list|,
name|MS
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_11nCompat
argument_list|,
name|HAL_DIAG_11N_SERVICES
argument_list|)
operator|&
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Setup board specific options for EEPROM version 3 */
name|ar5211SetBoardValues
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar5211SetChannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: unable to set channel\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
comment|/* Activate the PHY */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_devid
operator|==
name|AR5211_FPGA11B
operator|&&
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0xd808
argument_list|,
literal|0x502
argument_list|)
expr_stmt|;
comment|/* required for FPGA */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ACTIVE
argument_list|,
name|AR_PHY_ACTIVE_EN
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for the frequency synth to settle (synth goes on 	 * via AR_PHY_ACTIVE_EN).  Read the phy active delay register. 	 * Value is in 100ns increments. 	 */
name|data
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RX_DELAY
argument_list|)
operator|&
name|AR_PHY_RX_DELAY_M
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|synthDelay
operator|=
operator|(
literal|4
operator|*
name|data
operator|)
operator|/
literal|22
expr_stmt|;
block|}
else|else
block|{
name|synthDelay
operator|=
name|data
operator|/
literal|10
expr_stmt|;
block|}
comment|/* 	 * There is an issue if the AP starts the calibration before 	 * the baseband timeout completes.  This could result in the 	 * rxclear false triggering.  Add an extra delay to ensure this 	 * this does not happen. 	 */
name|OS_DELAY
argument_list|(
name|synthDelay
operator|+
name|DELAY_BASE_ACTIVATE
argument_list|)
expr_stmt|;
comment|/* Calibrate the AGC and wait for completion. */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
operator||
name|AR_PHY_AGC_CONTROL_CAL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_CAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Perform noise floor and set status */
if|if
condition|(
operator|!
name|ar5211CalNoiseFloor
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
condition|)
name|chan
operator|->
name|ic_state
operator||=
name|IEEE80211_CHANSTATE_CWINT
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: noise floor calibration failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
comment|/* Start IQ calibration w/ 2^(INIT_IQCAL_LOG_COUNT_MAX+1) samples */
if|if
condition|(
name|ahp
operator|->
name|ah_calibrationTime
operator|!=
literal|0
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|,
name|AR_PHY_TIMING_CTRL4_DO_IQCAL
operator||
operator|(
name|INIT_IQCAL_LOG_COUNT_MAX
operator|<<
name|AR_PHY_TIMING_CTRL4_IQCAL_LOG_COUNT_MAX_S
operator|)
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_bIQCalibration
operator|=
name|AH_TRUE
expr_stmt|;
block|}
comment|/* set 1:1 QCU to DCU mapping for all queues */
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|AR_NUM_DCU
condition|;
name|q
operator|++
control|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DQCUMASK
argument_list|(
name|q
argument_list|)
argument_list|,
literal|1
operator|<<
name|q
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|q
operator|++
control|)
name|ar5211ResetTxQueue
argument_list|(
name|ah
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Setup QCU0 transmit interrupt masks (TX_ERR, TX_OK, TX_DESC, TX_URN) */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S0
argument_list|,
operator|(
name|AR_IMR_S0_QCU_TXOK
operator|&
name|AR_QCU_0
operator|)
operator||
operator|(
name|AR_IMR_S0_QCU_TXDESC
operator|&
operator|(
name|AR_QCU_0
operator|<<
name|AR_IMR_S0_QCU_TXDESC_S
operator|)
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S1
argument_list|,
operator|(
name|AR_IMR_S1_QCU_TXERR
operator|&
name|AR_QCU_0
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S2
argument_list|,
operator|(
name|AR_IMR_S2_QCU_TXURN
operator|&
name|AR_QCU_0
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * GBL_EIFS must always be written after writing 	 *		to any QCUMASK register. 	 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_D_GBL_IFS_EIFS
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_D_GBL_IFS_EIFS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now set up the Interrupt Mask Register and save it for future use */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR
argument_list|,
name|INIT_INTERRUPT_MASK
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_maskReg
operator|=
name|INIT_INTERRUPT_MASK
expr_stmt|;
comment|/* Enable bus error interrupts */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S2
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S2
argument_list|)
operator||
name|AR_IMR_S2_MCABT
operator||
name|AR_IMR_S2_SSERR
operator||
name|AR_IMR_S2_DPERR
argument_list|)
expr_stmt|;
comment|/* Enable interrupts specific to AP */
if|if
condition|(
name|opmode
operator|==
name|HAL_M_HOSTAP
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_IMR
argument_list|)
operator||
name|AR_IMR_MIB
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_maskReg
operator||=
name|AR_IMR_MIB
expr_stmt|;
block|}
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rfkillEnabled
condition|)
name|ar5211EnableRfKill
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 	 * Writing to AR_BEACON will start timers. Hence it should 	 * be the last register to be written. Do not reset tsf, do 	 * not enable beacons at this point, but preserve other values 	 * like beaconInterval. 	 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BEACON
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_BEACON
argument_list|)
operator|&
operator|~
operator|(
name|AR_BEACON_EN
operator||
name|AR_BEACON_RESET_TSF
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Restore user-specified slot time and timeouts */
if|if
condition|(
name|ahp
operator|->
name|ah_sifstime
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ar5211SetSifsTime
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_sifstime
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_slottime
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ar5211SetSlotTime
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_slottime
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_acktimeout
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ar5211SetAckTimeout
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_acktimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_ctstimeout
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ar5211SetCTSTimeout
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_ctstimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diagreg
operator|!=
literal|0
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diagreg
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
operator|=
name|opmode
expr_stmt|;
comment|/* record operating mode */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s: done\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
name|bad
label|:
if|if
condition|(
name|status
operator|!=
name|AH_NULL
condition|)
operator|*
name|status
operator|=
name|ecode
expr_stmt|;
return|return
name|AH_FALSE
return|;
undef|#
directive|undef
name|FAIL
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Places the PHY and Radio chips into reset.  A full reset  * must be called to leave this state.  The PCI/MAC/PCU are  * not placed into reset as we must receive interrupt to  * re-enable the hardware.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5211PhyDisable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|ar5211SetResetReg
argument_list|(
name|ah
argument_list|,
name|AR_RC_BB
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Places all of hardware into reset  */
end_comment

begin_function
name|HAL_BOOL
name|ar5211Disable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ar5211SetPowerMode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
comment|/* 	 * Reset the HW - PCI must be reset after the rest of the 	 * device has been reset. 	 */
if|if
condition|(
operator|!
name|ar5211SetResetReg
argument_list|(
name|ah
argument_list|,
name|AR_RC_MAC
operator||
name|AR_RC_BB
operator||
name|AR_RC_PCI
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
name|OS_DELAY
argument_list|(
literal|2100
argument_list|)
expr_stmt|;
comment|/* 8245 @ 96Mhz hangs with 2000us. */
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Places the hardware into reset and then pulls it out of reset  *  * Only write the PLL if we're changing to or from CCK mode  *  * Attach calls with channelFlags = 0, as the coldreset should have  * us in the correct mode and we cannot check the hwchannel flags.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5211ChipReset
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ar5211SetPowerMode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
comment|/* NB: called from attach with chan null */
if|if
condition|(
name|chan
operator|!=
name|AH_NULL
condition|)
block|{
comment|/* Set CCK and Turbo modes correctly */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TURBO
argument_list|,
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
condition|?
name|AR_PHY_FC_TURBO_MODE
operator||
name|AR_PHY_FC_TURBO_SHORT
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR5211_PHY_MODE
argument_list|,
name|AR5211_PHY_MODE_CCK
operator||
name|AR5211_PHY_MODE_RF2GHZ
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_CTL
argument_list|,
name|AR_PHY_PLL_CTL_44
argument_list|)
expr_stmt|;
comment|/* Wait for the PLL to settle */
name|OS_DELAY
argument_list|(
name|DELAY_PLL_SETTLE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_devid
operator|==
name|AR5211_DEVID
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_CTL
argument_list|,
name|AR_PHY_PLL_CTL_40
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
name|DELAY_PLL_SETTLE
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR5211_PHY_MODE
argument_list|,
name|AR5211_PHY_MODE_OFDM
operator||
operator|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|?
name|AR5211_PHY_MODE_RF2GHZ
else|:
name|AR5211_PHY_MODE_RF5GHZ
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Reset the HW - PCI must be reset after the rest of the 	 * device has been reset 	 */
if|if
condition|(
operator|!
name|ar5211SetResetReg
argument_list|(
name|ah
argument_list|,
name|AR_RC_MAC
operator||
name|AR_RC_BB
operator||
name|AR_RC_PCI
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
name|OS_DELAY
argument_list|(
literal|2100
argument_list|)
expr_stmt|;
comment|/* 8245 @ 96Mhz hangs with 2000us. */
comment|/* Bring out of sleep mode (AGAIN) */
if|if
condition|(
operator|!
name|ar5211SetPowerMode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
comment|/* Clear warm reset register */
return|return
name|ar5211SetResetReg
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Recalibrate the lower PHY chips to account for temperature/environment  * changes.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5211PerCalibrationN
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|u_int
name|chainMask
parameter_list|,
name|HAL_BOOL
name|longCal
parameter_list|,
name|HAL_BOOL
modifier|*
name|isCalDone
parameter_list|)
block|{
name|struct
name|ath_hal_5211
modifier|*
name|ahp
init|=
name|AH5211
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
decl_stmt|;
name|int32_t
name|qCoff
decl_stmt|,
name|qCoffDenom
decl_stmt|;
name|uint32_t
name|data
decl_stmt|;
name|int32_t
name|iqCorrMeas
decl_stmt|;
name|int32_t
name|iCoff
decl_stmt|,
name|iCoffDenom
decl_stmt|;
name|uint32_t
name|powerMeasQ
decl_stmt|,
name|powerMeasI
decl_stmt|;
name|ichan
operator|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ichan
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel %u/0x%x; no mapping\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* IQ calibration in progress. Check to see if it has finished. */
if|if
condition|(
name|ahp
operator|->
name|ah_bIQCalibration
operator|&&
operator|!
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|)
operator|&
name|AR_PHY_TIMING_CTRL4_DO_IQCAL
operator|)
condition|)
block|{
comment|/* IQ Calibration has finished. */
name|ahp
operator|->
name|ah_bIQCalibration
operator|=
name|AH_FALSE
expr_stmt|;
comment|/* Read calibration results. */
name|powerMeasI
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_IQCAL_RES_PWR_MEAS_I
argument_list|)
expr_stmt|;
name|powerMeasQ
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_IQCAL_RES_PWR_MEAS_Q
argument_list|)
expr_stmt|;
name|iqCorrMeas
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_IQCAL_RES_IQ_CORR_MEAS
argument_list|)
expr_stmt|;
comment|/* 		 * Prescale these values to remove 64-bit operation requirement at the loss 		 * of a little precision. 		 */
name|iCoffDenom
operator|=
operator|(
name|powerMeasI
operator|/
literal|2
operator|+
name|powerMeasQ
operator|/
literal|2
operator|)
operator|/
literal|128
expr_stmt|;
name|qCoffDenom
operator|=
name|powerMeasQ
operator|/
literal|64
expr_stmt|;
comment|/* Protect against divide-by-0. */
if|if
condition|(
name|iCoffDenom
operator|!=
literal|0
operator|&&
name|qCoffDenom
operator|!=
literal|0
condition|)
block|{
name|iCoff
operator|=
operator|(
operator|-
name|iqCorrMeas
operator|)
operator|/
name|iCoffDenom
expr_stmt|;
comment|/* IQCORR_Q_I_COFF is a signed 6 bit number */
name|iCoff
operator|=
name|iCoff
operator|&
literal|0x3f
expr_stmt|;
name|qCoff
operator|=
operator|(
operator|(
name|int32_t
operator|)
name|powerMeasI
operator|/
name|qCoffDenom
operator|)
operator|-
literal|64
expr_stmt|;
comment|/* IQCORR_Q_Q_COFF is a signed 5 bit number */
name|qCoff
operator|=
name|qCoff
operator|&
literal|0x1f
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"powerMeasI = 0x%08x\n"
argument_list|,
name|powerMeasI
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"powerMeasQ = 0x%08x\n"
argument_list|,
name|powerMeasQ
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"iqCorrMeas = 0x%08x\n"
argument_list|,
name|iqCorrMeas
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"iCoff	  = %d\n"
argument_list|,
name|iCoff
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"qCoff	  = %d\n"
argument_list|,
name|qCoff
argument_list|)
expr_stmt|;
comment|/* Write IQ */
name|data
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|)
operator||
name|AR_PHY_TIMING_CTRL4_IQCORR_ENABLE
operator||
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|iCoff
operator|)
operator|<<
name|AR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF_S
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|qCoff
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|isCalDone
operator|=
operator|!
name|ahp
operator|->
name|ah_bIQCalibration
expr_stmt|;
if|if
condition|(
name|longCal
condition|)
block|{
comment|/* Perform noise floor and set status */
if|if
condition|(
operator|!
name|ar5211IsNfGood
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
comment|/* report up and clear internal state */
name|chan
operator|->
name|ic_state
operator||=
name|IEEE80211_CHANSTATE_CWINT
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
if|if
condition|(
operator|!
name|ar5211CalNoiseFloor
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
comment|/* 			 * Delay 5ms before retrying the noise floor 			 * just to make sure, as we are in an error 			 * condition here. 			 */
name|OS_DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar5211CalNoiseFloor
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
condition|)
name|chan
operator|->
name|ic_state
operator||=
name|IEEE80211_CHANSTATE_CWINT
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
block|}
name|ar5211RequestRfgain
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5211PerCalibration
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|HAL_BOOL
modifier|*
name|isIQdone
parameter_list|)
block|{
return|return
name|ar5211PerCalibrationN
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
literal|0x1
argument_list|,
name|AH_TRUE
argument_list|,
name|isIQdone
argument_list|)
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5211ResetCalValid
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
comment|/* XXX */
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Writes the given reset bit mask into the reset register  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5211SetResetReg
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|resetMask
parameter_list|)
block|{
name|uint32_t
name|mask
init|=
name|resetMask
condition|?
name|resetMask
else|:
operator|~
literal|0
decl_stmt|;
name|HAL_BOOL
name|rt
decl_stmt|;
operator|(
name|void
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RXDP
argument_list|)
expr_stmt|;
comment|/* flush any pending MMR writes */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RC
argument_list|,
name|resetMask
argument_list|)
expr_stmt|;
comment|/* need to wait at least 128 clocks when reseting PCI before read */
name|OS_DELAY
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|resetMask
operator|&=
name|AR_RC_MAC
operator||
name|AR_RC_BB
expr_stmt|;
name|mask
operator|&=
name|AR_RC_MAC
operator||
name|AR_RC_BB
expr_stmt|;
name|rt
operator|=
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_RC
argument_list|,
name|mask
argument_list|,
name|resetMask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|resetMask
operator|&
name|AR_RC_MAC
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isBigEndian
argument_list|()
condition|)
block|{
comment|/* 			 * Set CFG, little-endian for register 			 * and descriptor accesses. 			 */
name|mask
operator|=
name|INIT_CONFIG_STATUS
operator||
name|AR_CFG_SWTD
operator||
name|AR_CFG_SWRD
operator||
name|AR_CFG_SWRG
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CFG
argument_list|,
name|LE_READ_4
argument_list|(
operator|&
name|mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CFG
argument_list|,
name|INIT_CONFIG_STATUS
argument_list|)
expr_stmt|;
block|}
return|return
name|rt
return|;
block|}
end_function

begin_comment
comment|/*  * Takes the MHz channel value and sets the Channel value  *  * ASSUMES: Writes enabled to analog bus before AGC is active  *   or by disabling the AGC.  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5211SetChannel
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|uint32_t
name|refClk
decl_stmt|,
name|reg32
decl_stmt|,
name|data2111
decl_stmt|;
name|int16_t
name|chan5111
decl_stmt|,
name|chanIEEE
decl_stmt|;
name|chanIEEE
operator|=
name|chan
operator|->
name|ic_ieee
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
specifier|const
name|CHAN_INFO_2GHZ
modifier|*
name|ci
init|=
operator|&
name|chan2GHzData
index|[
name|chanIEEE
operator|+
name|CI_2GHZ_INDEX_CORRECTION
index|]
decl_stmt|;
name|data2111
operator|=
operator|(
operator|(
name|ath_hal_reverseBits
argument_list|(
name|ci
operator|->
name|channelSelect
argument_list|,
literal|8
argument_list|)
operator|&
literal|0xff
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
name|ci
operator|->
name|refClkSel
operator|<<
literal|4
operator|)
expr_stmt|;
name|chan5111
operator|=
name|ci
operator|->
name|channel5111
expr_stmt|;
block|}
else|else
block|{
name|data2111
operator|=
literal|0
expr_stmt|;
name|chan5111
operator|=
name|chanIEEE
expr_stmt|;
block|}
comment|/* Rest of the code is common for 5 GHz and 2.4 GHz. */
if|if
condition|(
name|chan5111
operator|>=
literal|145
operator|||
operator|(
name|chan5111
operator|&
literal|0x1
operator|)
condition|)
block|{
name|reg32
operator|=
name|ath_hal_reverseBits
argument_list|(
name|chan5111
operator|-
literal|24
argument_list|,
literal|8
argument_list|)
operator|&
literal|0xFF
expr_stmt|;
name|refClk
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|reg32
operator|=
name|ath_hal_reverseBits
argument_list|(
operator|(
operator|(
name|chan5111
operator|-
literal|24
operator|)
operator|/
literal|2
operator|)
argument_list|,
literal|8
argument_list|)
operator|&
literal|0xFF
expr_stmt|;
name|refClk
operator|=
literal|0
expr_stmt|;
block|}
name|reg32
operator|=
operator|(
name|reg32
operator|<<
literal|2
operator|)
operator||
operator|(
name|refClk
operator|<<
literal|1
operator|)
operator||
operator|(
literal|1
operator|<<
literal|10
operator|)
operator||
literal|0x1
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0x27
argument_list|)
argument_list|,
operator|(
operator|(
name|data2111
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|reg32
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|reg32
operator|>>=
literal|8
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0x34
argument_list|)
argument_list|,
operator|(
name|data2111
operator|&
literal|0xff00
operator|)
operator||
operator|(
name|reg32
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|=
name|chan
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int16_t
name|ar5211GetNoiseFloor
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|int16_t
name|nf
decl_stmt|;
name|nf
operator|=
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|25
argument_list|)
argument_list|)
operator|>>
literal|19
operator|)
operator|&
literal|0x1ff
expr_stmt|;
if|if
condition|(
name|nf
operator|&
literal|0x100
condition|)
name|nf
operator|=
literal|0
operator|-
operator|(
operator|(
name|nf
operator|^
literal|0x1ff
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
return|return
name|nf
return|;
block|}
end_function

begin_comment
comment|/*  * Peform the noisefloor calibration for the length of time set  * in runTime (valid values 1 to 7)  *  * Returns: The NF value at the end of the given time (or 0 for failure)  */
end_comment

begin_function
name|int16_t
name|ar5211RunNoiseFloor
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint8_t
name|runTime
parameter_list|,
name|int16_t
name|startingNF
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|searchTime
decl_stmt|;
name|HALASSERT
argument_list|(
name|runTime
operator|<=
literal|7
argument_list|)
expr_stmt|;
comment|/* Setup  noise floor run time and starting value */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|25
argument_list|)
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|25
argument_list|)
argument_list|)
operator|&
operator|~
literal|0xFFF
operator|)
operator||
operator|(
operator|(
name|runTime
operator|<<
literal|9
operator|)
operator|&
literal|0xE00
operator|)
operator||
operator|(
name|startingNF
operator|&
literal|0x1FF
operator|)
argument_list|)
expr_stmt|;
comment|/* Calibrate the noise floor */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
operator||
name|AR_PHY_AGC_CONTROL_NF
argument_list|)
expr_stmt|;
comment|/* Compute the required amount of searchTime needed to finish NF */
if|if
condition|(
name|runTime
operator|==
literal|0
condition|)
block|{
comment|/* 8 search windows * 6.4us each */
name|searchTime
operator|=
literal|8
operator|*
literal|7
expr_stmt|;
block|}
else|else
block|{
comment|/* 512 * runtime search windows * 6.4us each */
name|searchTime
operator|=
operator|(
name|runTime
operator|*
literal|512
operator|)
operator|*
literal|7
expr_stmt|;
block|}
comment|/* 	 * Do not read noise floor until it has been updated 	 * 	 * As a guesstimate - we may only get 1/60th the time on 	 * the air to see search windows  in a heavily congested 	 * network (40 us every 2400 us of time) 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|60
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
operator|&
name|AR_PHY_AGC_CONTROL_NF
operator|)
operator|==
literal|0
condition|)
break|break;
name|OS_DELAY
argument_list|(
name|searchTime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
literal|60
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"NF with runTime %d failed to end on channel %d\n"
argument_list|,
name|runTime
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"  PHY NF Reg state:	 0x%x\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"  PHY Active Reg state: 0x%x\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ACTIVE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ar5211GetNoiseFloor
argument_list|(
name|ah
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|getNoiseFloorThresh
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|int16_t
modifier|*
name|nft
parameter_list|)
block|{
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
switch|switch
condition|(
name|chan
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_ALLFULL
condition|)
block|{
case|case
name|IEEE80211_CHAN_A
case|:
operator|*
name|nft
operator|=
name|ee
operator|->
name|ee_noiseFloorThresh
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|IEEE80211_CHAN_B
case|:
operator|*
name|nft
operator|=
name|ee
operator|->
name|ee_noiseFloorThresh
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|IEEE80211_CHAN_PUREG
case|:
operator|*
name|nft
operator|=
name|ee
operator|->
name|ee_noiseFloorThresh
index|[
literal|2
index|]
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Read the NF and check it against the noise floor threshhold  *  * Returns: TRUE if the NF is good  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5211IsNfGood
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
init|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|int16_t
name|nf
decl_stmt|,
name|nfThresh
decl_stmt|;
if|if
condition|(
operator|!
name|getNoiseFloorThresh
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|&
name|nfThresh
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
if|if
condition|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
operator|&
name|AR_PHY_AGC_CONTROL_NF
condition|)
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: NF did not complete in calibration window\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|nf
operator|=
name|ar5211GetNoiseFloor
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
operator|>
name|nfThresh
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: noise floor failed; detected %u, threshold %u\n"
argument_list|,
name|__func__
argument_list|,
name|nf
argument_list|,
name|nfThresh
argument_list|)
expr_stmt|;
comment|/* 		 * NB: Don't discriminate 2.4 vs 5Ghz, if this 		 *     happens it indicates a problem regardless 		 *     of the band. 		 */
name|chan
operator|->
name|ic_state
operator||=
name|IEEE80211_CHANSTATE_CWINT
expr_stmt|;
block|}
name|ichan
operator|->
name|rawNoiseFloor
operator|=
name|nf
expr_stmt|;
return|return
operator|(
name|nf
operator|<=
name|nfThresh
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Peform the noisefloor calibration and check for any constant channel  * interference.  *  * NOTE: preAR5211 have a lengthy carrier wave detection process - hence  * it is if'ed for MKK regulatory domain only.  *  * Returns: TRUE for a successful noise floor calibration; else FALSE  */
end_comment

begin_function
name|HAL_BOOL
name|ar5211CalNoiseFloor
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) / sizeof (a[0]))
comment|/* Check for Carrier Wave interference in MKK regulatory zone */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|<
name|AR_SREV_VERSION_OAHU
operator|&&
operator|(
name|chan
operator|->
name|ic_flags
operator|&
name|CHANNEL_NFCREQUIRED
operator|)
condition|)
block|{
specifier|static
specifier|const
name|uint8_t
name|runtime
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|7
block|}
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
init|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|int16_t
name|nf
decl_stmt|,
name|nfThresh
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|getNoiseFloorThresh
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|&
name|nfThresh
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
comment|/* 		 * Run a quick noise floor that will hopefully 		 * complete (decrease delay time). 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|runtime
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|nf
operator|=
name|ar5211RunNoiseFloor
argument_list|(
name|ah
argument_list|,
name|runtime
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
operator|>
name|nfThresh
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: run failed with %u> threshold %u "
literal|"(runtime %u)\n"
argument_list|,
name|__func__
argument_list|,
name|nf
argument_list|,
name|nfThresh
argument_list|,
name|runtime
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ichan
operator|->
name|rawNoiseFloor
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ichan
operator|->
name|rawNoiseFloor
operator|=
name|nf
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|<=
name|N
argument_list|(
name|runtime
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* Calibrate the noise floor */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
operator||
name|AR_PHY_AGC_CONTROL_NF
argument_list|)
expr_stmt|;
block|}
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Adjust NF based on statistical values for 5GHz frequencies.  */
end_comment

begin_function
name|int16_t
name|ar5211GetNfAdjust
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_CHANNEL_INTERNAL
modifier|*
name|c
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
block|{
name|uint16_t
name|freqLow
decl_stmt|;
name|int16_t
name|adjust
decl_stmt|;
block|}
name|adjust5111
index|[]
init|=
block|{
block|{
literal|5790
block|,
literal|11
block|}
block|,
comment|/* NB: ordered high -> low */
block|{
literal|5730
block|,
literal|10
block|}
block|,
block|{
literal|5690
block|,
literal|9
block|}
block|,
block|{
literal|5660
block|,
literal|8
block|}
block|,
block|{
literal|5610
block|,
literal|7
block|}
block|,
block|{
literal|5530
block|,
literal|5
block|}
block|,
block|{
literal|5450
block|,
literal|4
block|}
block|,
block|{
literal|5379
block|,
literal|2
block|}
block|,
block|{
literal|5209
block|,
literal|0
block|}
block|,
comment|/* XXX? bogus but doesn't matter */
block|{
literal|0
block|,
literal|1
block|}
block|, 	}
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|c
operator|->
name|channel
operator|<=
name|adjust5111
index|[
name|i
index|]
operator|.
name|freqLow
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* NB: placeholder for 5111's less severe requirement */
return|return
name|adjust5111
index|[
name|i
index|]
operator|.
name|adjust
operator|/
literal|3
return|;
block|}
end_function

begin_comment
comment|/*  * Reads EEPROM header info from device structure and programs  * analog registers 6 and 7  *  * REQUIRES: Access to the analog device  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5211SetRf6and7
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) / sizeof (a[0]))
name|uint16_t
name|freq
init|=
name|ath_hal_gethwchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|struct
name|ath_hal_5211
modifier|*
name|ahp
init|=
name|AH5211
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|uint16_t
name|rfXpdGain
decl_stmt|,
name|rfPloSel
decl_stmt|,
name|rfPwdXpd
decl_stmt|;
name|uint16_t
name|tempOB
decl_stmt|,
name|tempDB
decl_stmt|;
name|uint16_t
name|freqIndex
decl_stmt|;
name|int
name|i
decl_stmt|;
name|freqIndex
operator|=
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
comment|/* 	 * TODO: This array mode correspondes with the index used 	 *	 during the read. 	 * For readability, this should be changed to an enum or #define 	 */
switch|switch
condition|(
name|chan
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_ALLFULL
condition|)
block|{
case|case
name|IEEE80211_CHAN_A
case|:
if|if
condition|(
name|freq
operator|>
literal|4000
operator|&&
name|freq
operator|<
literal|5260
condition|)
block|{
name|tempOB
operator|=
name|ee
operator|->
name|ee_ob1
expr_stmt|;
name|tempDB
operator|=
name|ee
operator|->
name|ee_db1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|freq
operator|>=
literal|5260
operator|&&
name|freq
operator|<
literal|5500
condition|)
block|{
name|tempOB
operator|=
name|ee
operator|->
name|ee_ob2
expr_stmt|;
name|tempDB
operator|=
name|ee
operator|->
name|ee_db2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|freq
operator|>=
literal|5500
operator|&&
name|freq
operator|<
literal|5725
condition|)
block|{
name|tempOB
operator|=
name|ee
operator|->
name|ee_ob3
expr_stmt|;
name|tempDB
operator|=
name|ee
operator|->
name|ee_db3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|freq
operator|>=
literal|5725
condition|)
block|{
name|tempOB
operator|=
name|ee
operator|->
name|ee_ob4
expr_stmt|;
name|tempDB
operator|=
name|ee
operator|->
name|ee_db4
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX panic?? */
name|tempOB
operator|=
name|tempDB
operator|=
literal|0
expr_stmt|;
block|}
name|rfXpdGain
operator|=
name|ee
operator|->
name|ee_xgain
index|[
literal|0
index|]
expr_stmt|;
name|rfPloSel
operator|=
name|ee
operator|->
name|ee_xpd
index|[
literal|0
index|]
expr_stmt|;
name|rfPwdXpd
operator|=
operator|!
name|ee
operator|->
name|ee_xpd
index|[
literal|0
index|]
expr_stmt|;
name|ar5211Rf6n7
index|[
literal|5
index|]
index|[
name|freqIndex
index|]
operator|=
operator|(
name|ar5211Rf6n7
index|[
literal|5
index|]
index|[
name|freqIndex
index|]
operator|&
operator|~
literal|0x10000000
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_cornerCal
operator|.
name|pd84
operator|<<
literal|28
operator|)
expr_stmt|;
name|ar5211Rf6n7
index|[
literal|6
index|]
index|[
name|freqIndex
index|]
operator|=
operator|(
name|ar5211Rf6n7
index|[
literal|6
index|]
index|[
name|freqIndex
index|]
operator|&
operator|~
literal|0x04000000
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_cornerCal
operator|.
name|pd90
operator|<<
literal|26
operator|)
expr_stmt|;
name|ar5211Rf6n7
index|[
literal|21
index|]
index|[
name|freqIndex
index|]
operator|=
operator|(
name|ar5211Rf6n7
index|[
literal|21
index|]
index|[
name|freqIndex
index|]
operator|&
operator|~
literal|0x08
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_cornerCal
operator|.
name|gSel
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_CHAN_B
case|:
name|tempOB
operator|=
name|ee
operator|->
name|ee_obFor24
expr_stmt|;
name|tempDB
operator|=
name|ee
operator|->
name|ee_dbFor24
expr_stmt|;
name|rfXpdGain
operator|=
name|ee
operator|->
name|ee_xgain
index|[
literal|1
index|]
expr_stmt|;
name|rfPloSel
operator|=
name|ee
operator|->
name|ee_xpd
index|[
literal|1
index|]
expr_stmt|;
name|rfPwdXpd
operator|=
operator|!
name|ee
operator|->
name|ee_xpd
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|IEEE80211_CHAN_PUREG
case|:
name|tempOB
operator|=
name|ee
operator|->
name|ee_obFor24g
expr_stmt|;
name|tempDB
operator|=
name|ee
operator|->
name|ee_dbFor24g
expr_stmt|;
name|rfXpdGain
operator|=
name|ee
operator|->
name|ee_xgain
index|[
literal|2
index|]
expr_stmt|;
name|rfPloSel
operator|=
name|ee
operator|->
name|ee_xpd
index|[
literal|2
index|]
expr_stmt|;
name|rfPwdXpd
operator|=
operator|!
name|ee
operator|->
name|ee_xpd
index|[
literal|2
index|]
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|HALASSERT
argument_list|(
literal|1
operator|<=
name|tempOB
operator|&&
name|tempOB
operator|<=
literal|5
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
literal|1
operator|<=
name|tempDB
operator|&&
name|tempDB
operator|<=
literal|5
argument_list|)
expr_stmt|;
comment|/* Set rfXpdGain and rfPwdXpd */
name|ar5211Rf6n7
index|[
literal|11
index|]
index|[
name|freqIndex
index|]
operator|=
operator|(
name|ar5211Rf6n7
index|[
literal|11
index|]
index|[
name|freqIndex
index|]
operator|&
operator|~
literal|0xC0
operator|)
operator||
operator|(
operator|(
operator|(
name|ath_hal_reverseBits
argument_list|(
name|rfXpdGain
argument_list|,
literal|4
argument_list|)
operator|<<
literal|7
operator|)
operator||
operator|(
name|rfPwdXpd
operator|<<
literal|6
operator|)
operator|)
operator|&
literal|0xC0
operator|)
expr_stmt|;
name|ar5211Rf6n7
index|[
literal|12
index|]
index|[
name|freqIndex
index|]
operator|=
operator|(
name|ar5211Rf6n7
index|[
literal|12
index|]
index|[
name|freqIndex
index|]
operator|&
operator|~
literal|0x07
operator|)
operator||
operator|(
operator|(
name|ath_hal_reverseBits
argument_list|(
name|rfXpdGain
argument_list|,
literal|4
argument_list|)
operator|>>
literal|1
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
comment|/* Set OB */
name|ar5211Rf6n7
index|[
literal|12
index|]
index|[
name|freqIndex
index|]
operator|=
operator|(
name|ar5211Rf6n7
index|[
literal|12
index|]
index|[
name|freqIndex
index|]
operator|&
operator|~
literal|0x80
operator|)
operator||
operator|(
operator|(
name|ath_hal_reverseBits
argument_list|(
name|tempOB
argument_list|,
literal|3
argument_list|)
operator|<<
literal|7
operator|)
operator|&
literal|0x80
operator|)
expr_stmt|;
name|ar5211Rf6n7
index|[
literal|13
index|]
index|[
name|freqIndex
index|]
operator|=
operator|(
name|ar5211Rf6n7
index|[
literal|13
index|]
index|[
name|freqIndex
index|]
operator|&
operator|~
literal|0x03
operator|)
operator||
operator|(
operator|(
name|ath_hal_reverseBits
argument_list|(
name|tempOB
argument_list|,
literal|3
argument_list|)
operator|>>
literal|1
operator|)
operator|&
literal|0x03
operator|)
expr_stmt|;
comment|/* Set DB */
name|ar5211Rf6n7
index|[
literal|13
index|]
index|[
name|freqIndex
index|]
operator|=
operator|(
name|ar5211Rf6n7
index|[
literal|13
index|]
index|[
name|freqIndex
index|]
operator|&
operator|~
literal|0x1C
operator|)
operator||
operator|(
operator|(
name|ath_hal_reverseBits
argument_list|(
name|tempDB
argument_list|,
literal|3
argument_list|)
operator|<<
literal|2
operator|)
operator|&
literal|0x1C
operator|)
expr_stmt|;
comment|/* Set rfPloSel */
name|ar5211Rf6n7
index|[
literal|17
index|]
index|[
name|freqIndex
index|]
operator|=
operator|(
name|ar5211Rf6n7
index|[
literal|17
index|]
index|[
name|freqIndex
index|]
operator|&
operator|~
literal|0x08
operator|)
operator||
operator|(
operator|(
name|rfPloSel
operator|<<
literal|3
operator|)
operator|&
literal|0x08
operator|)
expr_stmt|;
comment|/* Write the Rf registers 6& 7 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|ar5211Rf6n7
argument_list|)
condition|;
name|i
operator|++
control|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|ar5211Rf6n7
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|ar5211Rf6n7
index|[
name|i
index|]
index|[
name|freqIndex
index|]
argument_list|)
expr_stmt|;
comment|/* Now that we have reprogrammed rfgain value, clear the flag. */
name|ahp
operator|->
name|ah_rfgainState
operator|=
name|RFGAIN_INACTIVE
expr_stmt|;
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5211SetAntennaSwitchInternal
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_ANT_SETTING
name|settings
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
define|#
directive|define
name|ANT_SWITCH_TABLE1
value|0x9960
define|#
directive|define
name|ANT_SWITCH_TABLE2
value|0x9964
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|struct
name|ath_hal_5211
modifier|*
name|ahp
init|=
name|AH5211
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|uint32_t
name|antSwitchA
decl_stmt|,
name|antSwitchB
decl_stmt|;
name|int
name|ix
decl_stmt|;
switch|switch
condition|(
name|chan
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_ALLFULL
condition|)
block|{
case|case
name|IEEE80211_CHAN_A
case|:
name|ix
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IEEE80211_CHAN_B
case|:
name|ix
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IEEE80211_CHAN_PUREG
case|:
name|ix
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|antSwitchA
operator|=
name|ee
operator|->
name|ee_antennaControl
index|[
literal|1
index|]
index|[
name|ix
index|]
operator||
operator|(
name|ee
operator|->
name|ee_antennaControl
index|[
literal|2
index|]
index|[
name|ix
index|]
operator|<<
literal|6
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_antennaControl
index|[
literal|3
index|]
index|[
name|ix
index|]
operator|<<
literal|12
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_antennaControl
index|[
literal|4
index|]
index|[
name|ix
index|]
operator|<<
literal|18
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_antennaControl
index|[
literal|5
index|]
index|[
name|ix
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|antSwitchB
operator|=
name|ee
operator|->
name|ee_antennaControl
index|[
literal|6
index|]
index|[
name|ix
index|]
operator||
operator|(
name|ee
operator|->
name|ee_antennaControl
index|[
literal|7
index|]
index|[
name|ix
index|]
operator|<<
literal|6
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_antennaControl
index|[
literal|8
index|]
index|[
name|ix
index|]
operator|<<
literal|12
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_antennaControl
index|[
literal|9
index|]
index|[
name|ix
index|]
operator|<<
literal|18
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_antennaControl
index|[
literal|10
index|]
index|[
name|ix
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
comment|/* 	 * For fixed antenna, give the same setting for both switch banks 	 */
switch|switch
condition|(
name|settings
condition|)
block|{
case|case
name|HAL_ANT_FIXED_A
case|:
name|antSwitchB
operator|=
name|antSwitchA
expr_stmt|;
break|break;
case|case
name|HAL_ANT_FIXED_B
case|:
name|antSwitchA
operator|=
name|antSwitchB
expr_stmt|;
break|break;
case|case
name|HAL_ANT_VARIABLE
case|:
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: bad antenna setting %u\n"
argument_list|,
name|__func__
argument_list|,
name|settings
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|ahp
operator|->
name|ah_diversityControl
operator|=
name|settings
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|ANT_SWITCH_TABLE1
argument_list|,
name|antSwitchA
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|ANT_SWITCH_TABLE2
argument_list|,
name|antSwitchB
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|ANT_SWITCH_TABLE1
undef|#
directive|undef
name|ANT_SWITCH_TABLE2
block|}
end_function

begin_comment
comment|/*  * Reads EEPROM header info and programs the device for correct operation  * given the channel value  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5211SetBoardValues
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|struct
name|ath_hal_5211
modifier|*
name|ahp
init|=
name|AH5211
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|arrayMode
decl_stmt|,
name|falseDectectBackoff
decl_stmt|;
switch|switch
condition|(
name|chan
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_ALLFULL
condition|)
block|{
case|case
name|IEEE80211_CHAN_A
case|:
name|arrayMode
operator|=
literal|0
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_FRAME_CTL
argument_list|,
name|AR_PHY_FRAME_CTL_TX_CLIP
argument_list|,
name|ee
operator|->
name|ee_cornerCal
operator|.
name|clip
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_CHAN_B
case|:
name|arrayMode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IEEE80211_CHAN_PUREG
case|:
name|arrayMode
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* Set the antenna register(s) correctly for the chip revision */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|<
name|AR_SREV_VERSION_OAHU
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|68
argument_list|)
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|68
argument_list|)
argument_list|)
operator|&
literal|0xFFFFFFFC
operator|)
operator||
literal|0x3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|68
argument_list|)
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|68
argument_list|)
argument_list|)
operator|&
literal|0xFFFFFC06
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_antennaControl
index|[
literal|0
index|]
index|[
name|arrayMode
index|]
operator|<<
literal|4
operator|)
operator||
literal|0x1
argument_list|)
expr_stmt|;
name|ar5211SetAntennaSwitchInternal
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_diversityControl
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* Set the Noise Floor Thresh on ar5211 devices */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BASE
operator|+
operator|(
literal|90
operator|<<
literal|2
operator|)
argument_list|,
operator|(
name|ee
operator|->
name|ee_noiseFloorThresh
index|[
name|arrayMode
index|]
operator|&
literal|0x1FF
operator|)
operator||
operator|(
literal|1
operator|<<
literal|9
operator|)
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BASE
operator|+
operator|(
literal|17
operator|<<
literal|2
operator|)
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BASE
operator|+
operator|(
literal|17
operator|<<
literal|2
operator|)
argument_list|)
operator|&
literal|0xFFFFC07F
operator|)
operator||
operator|(
operator|(
name|ee
operator|->
name|ee_switchSettling
index|[
name|arrayMode
index|]
operator|<<
literal|7
operator|)
operator|&
literal|0x3F80
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BASE
operator|+
operator|(
literal|18
operator|<<
literal|2
operator|)
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BASE
operator|+
operator|(
literal|18
operator|<<
literal|2
operator|)
argument_list|)
operator|&
literal|0xFFFC0FFF
operator|)
operator||
operator|(
operator|(
name|ee
operator|->
name|ee_txrxAtten
index|[
name|arrayMode
index|]
operator|<<
literal|12
operator|)
operator|&
literal|0x3F000
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BASE
operator|+
operator|(
literal|20
operator|<<
literal|2
operator|)
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BASE
operator|+
operator|(
literal|20
operator|<<
literal|2
operator|)
argument_list|)
operator|&
literal|0xFFFF0000
operator|)
operator||
operator|(
operator|(
name|ee
operator|->
name|ee_pgaDesiredSize
index|[
name|arrayMode
index|]
operator|<<
literal|8
operator|)
operator|&
literal|0xFF00
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_adcDesiredSize
index|[
name|arrayMode
index|]
operator|&
literal|0x00FF
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BASE
operator|+
operator|(
literal|13
operator|<<
literal|2
operator|)
argument_list|,
operator|(
name|ee
operator|->
name|ee_txEndToXPAOff
index|[
name|arrayMode
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_txEndToXPAOff
index|[
name|arrayMode
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_txFrameToXPAOn
index|[
name|arrayMode
index|]
operator|<<
literal|8
operator|)
operator||
name|ee
operator|->
name|ee_txFrameToXPAOn
index|[
name|arrayMode
index|]
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BASE
operator|+
operator|(
literal|10
operator|<<
literal|2
operator|)
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BASE
operator|+
operator|(
literal|10
operator|<<
literal|2
operator|)
argument_list|)
operator|&
literal|0xFFFF00FF
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_txEndToXLNAOn
index|[
name|arrayMode
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BASE
operator|+
operator|(
literal|25
operator|<<
literal|2
operator|)
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BASE
operator|+
operator|(
literal|25
operator|<<
literal|2
operator|)
argument_list|)
operator|&
literal|0xFFF80FFF
operator|)
operator||
operator|(
operator|(
name|ee
operator|->
name|ee_thresh62
index|[
name|arrayMode
index|]
operator|<<
literal|12
operator|)
operator|&
literal|0x7F000
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|NO_FALSE_DETECT_BACKOFF
value|2
define|#
directive|define
name|CB22_FALSE_DETECT_BACKOFF
value|6
comment|/* 	 * False detect backoff - suspected 32 MHz spur causes 	 * false detects in OFDM, causing Tx Hangs.  Decrease 	 * weak signal sensitivity for this card. 	 */
name|falseDectectBackoff
operator|=
name|NO_FALSE_DETECT_BACKOFF
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeversion
operator|<
name|AR_EEPROM_VER3_3
condition|)
block|{
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_subvendorid
operator|==
literal|0x1022
operator|&&
name|IEEE80211_IS_CHAN_OFDM
argument_list|(
name|chan
argument_list|)
condition|)
name|falseDectectBackoff
operator|+=
name|CB22_FALSE_DETECT_BACKOFF
expr_stmt|;
block|}
else|else
block|{
name|uint16_t
name|freq
init|=
name|ath_hal_gethwchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|uint32_t
name|remainder
init|=
name|freq
operator|%
literal|32
decl_stmt|;
if|if
condition|(
name|remainder
operator|&&
operator|(
name|remainder
operator|<
literal|10
operator|||
name|remainder
operator|>
literal|22
operator|)
condition|)
name|falseDectectBackoff
operator|+=
name|ee
operator|->
name|ee_falseDetectBackoff
index|[
name|arrayMode
index|]
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0x9924
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
literal|0x9924
argument_list|)
operator|&
literal|0xFFFFFF01
operator|)
operator||
operator|(
operator|(
name|falseDectectBackoff
operator|<<
literal|1
operator|)
operator|&
literal|0xF7
operator|)
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|NO_FALSE_DETECT_BACKOFF
undef|#
directive|undef
name|CB22_FALSE_DETECT_BACKOFF
block|}
end_function

begin_comment
comment|/*  * Set the limit on the overall output power.  Used for dynamic  * transmit power control and the like.  *  * NOTE: The power is passed in is in units of 0.5 dBm.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5211SetTxPowerLimit
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|limit
parameter_list|)
block|{
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_powerLimit
operator|=
name|AH_MIN
argument_list|(
name|limit
argument_list|,
name|MAX_RATE_POWER
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_RATE_MAX
argument_list|,
name|limit
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Sets the transmit power in the baseband for the given  * operating channel and mode.  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5211SetTransmitPower
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|uint16_t
name|freq
init|=
name|ath_hal_gethwchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|TRGT_POWER_INFO
modifier|*
name|pi
decl_stmt|;
name|RD_EDGES_POWER
modifier|*
name|rep
decl_stmt|;
name|PCDACS_EEPROM
name|eepromPcdacs
decl_stmt|;
name|u_int
name|nchan
decl_stmt|,
name|cfgCtl
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* setup the pcdac struct to point to the correct info, based on mode */
switch|switch
condition|(
name|chan
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_ALLFULL
condition|)
block|{
case|case
name|IEEE80211_CHAN_A
case|:
name|eepromPcdacs
operator|.
name|numChannels
operator|=
name|ee
operator|->
name|ee_numChannels11a
expr_stmt|;
name|eepromPcdacs
operator|.
name|pChannelList
operator|=
name|ee
operator|->
name|ee_channels11a
expr_stmt|;
name|eepromPcdacs
operator|.
name|pDataPerChannel
operator|=
name|ee
operator|->
name|ee_dataPerChannel11a
expr_stmt|;
name|nchan
operator|=
name|ee
operator|->
name|ee_numTargetPwr_11a
expr_stmt|;
name|pi
operator|=
name|ee
operator|->
name|ee_trgtPwr_11a
expr_stmt|;
break|break;
case|case
name|IEEE80211_CHAN_PUREG
case|:
name|eepromPcdacs
operator|.
name|numChannels
operator|=
name|ee
operator|->
name|ee_numChannels2_4
expr_stmt|;
name|eepromPcdacs
operator|.
name|pChannelList
operator|=
name|ee
operator|->
name|ee_channels11g
expr_stmt|;
name|eepromPcdacs
operator|.
name|pDataPerChannel
operator|=
name|ee
operator|->
name|ee_dataPerChannel11g
expr_stmt|;
name|nchan
operator|=
name|ee
operator|->
name|ee_numTargetPwr_11g
expr_stmt|;
name|pi
operator|=
name|ee
operator|->
name|ee_trgtPwr_11g
expr_stmt|;
break|break;
case|case
name|IEEE80211_CHAN_B
case|:
name|eepromPcdacs
operator|.
name|numChannels
operator|=
name|ee
operator|->
name|ee_numChannels2_4
expr_stmt|;
name|eepromPcdacs
operator|.
name|pChannelList
operator|=
name|ee
operator|->
name|ee_channels11b
expr_stmt|;
name|eepromPcdacs
operator|.
name|pDataPerChannel
operator|=
name|ee
operator|->
name|ee_dataPerChannel11b
expr_stmt|;
name|nchan
operator|=
name|ee
operator|->
name|ee_numTargetPwr_11b
expr_stmt|;
name|pi
operator|=
name|ee
operator|->
name|ee_trgtPwr_11b
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|ar5211SetPowerTable
argument_list|(
name|ah
argument_list|,
operator|&
name|eepromPcdacs
argument_list|,
name|freq
argument_list|)
expr_stmt|;
name|rep
operator|=
name|AH_NULL
expr_stmt|;
comment|/* Match CTL to EEPROM value */
name|cfgCtl
operator|=
name|ath_hal_getctl
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ee
operator|->
name|ee_numCtls
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ee
operator|->
name|ee_ctl
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|ee
operator|->
name|ee_ctl
index|[
name|i
index|]
operator|==
name|cfgCtl
condition|)
block|{
name|rep
operator|=
operator|&
name|ee
operator|->
name|ee_rdEdgesPower
index|[
name|i
operator|*
name|NUM_EDGES
index|]
expr_stmt|;
break|break;
block|}
name|ar5211SetRateTable
argument_list|(
name|ah
argument_list|,
name|rep
argument_list|,
name|pi
argument_list|,
name|nchan
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Read the transmit power levels from the structures taken  * from EEPROM. Interpolate read transmit power values for  * this channel. Organize the transmit power values into a  * table for writing into the hardware.  */
end_comment

begin_function
name|void
name|ar5211SetPowerTable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|PCDACS_EEPROM
modifier|*
name|pSrcStruct
parameter_list|,
name|uint16_t
name|channel
parameter_list|)
block|{
specifier|static
name|FULL_PCDAC_STRUCT
name|pcdacStruct
decl_stmt|;
specifier|static
name|uint16_t
name|pcdacTable
index|[
name|PWR_TABLE_SIZE
index|]
decl_stmt|;
name|uint16_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint16_t
modifier|*
name|pPcdacValues
decl_stmt|;
name|int16_t
modifier|*
name|pScaledUpDbm
decl_stmt|;
name|int16_t
name|minScaledPwr
decl_stmt|;
name|int16_t
name|maxScaledPwr
decl_stmt|;
name|int16_t
name|pwr
decl_stmt|;
name|uint16_t
name|pcdacMin
init|=
literal|0
decl_stmt|;
name|uint16_t
name|pcdacMax
init|=
literal|63
decl_stmt|;
name|uint16_t
name|pcdacTableIndex
decl_stmt|;
name|uint16_t
name|scaledPcdac
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|;
name|uint32_t
name|temp32
decl_stmt|;
name|OS_MEMZERO
argument_list|(
operator|&
name|pcdacStruct
argument_list|,
sizeof|sizeof
argument_list|(
name|FULL_PCDAC_STRUCT
argument_list|)
argument_list|)
expr_stmt|;
name|OS_MEMZERO
argument_list|(
name|pcdacTable
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|*
name|PWR_TABLE_SIZE
argument_list|)
expr_stmt|;
name|pPcdacValues
operator|=
name|pcdacStruct
operator|.
name|PcdacValues
expr_stmt|;
name|pScaledUpDbm
operator|=
name|pcdacStruct
operator|.
name|PwrValues
expr_stmt|;
comment|/* Initialize the pcdacs to dBM structs pcdacs to be 1 to 63 */
for|for
control|(
name|i
operator|=
name|PCDAC_START
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<=
name|PCDAC_STOP
condition|;
name|i
operator|+=
name|PCDAC_STEP
operator|,
name|j
operator|++
control|)
name|pPcdacValues
index|[
name|j
index|]
operator|=
name|i
expr_stmt|;
name|pcdacStruct
operator|.
name|numPcdacValues
operator|=
name|j
expr_stmt|;
name|pcdacStruct
operator|.
name|pcdacMin
operator|=
name|PCDAC_START
expr_stmt|;
name|pcdacStruct
operator|.
name|pcdacMax
operator|=
name|PCDAC_STOP
expr_stmt|;
comment|/* Fill out the power values for this channel */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pcdacStruct
operator|.
name|numPcdacValues
condition|;
name|j
operator|++
control|)
name|pScaledUpDbm
index|[
name|j
index|]
operator|=
name|ar5211GetScaledPower
argument_list|(
name|channel
argument_list|,
name|pPcdacValues
index|[
name|j
index|]
argument_list|,
name|pSrcStruct
argument_list|)
expr_stmt|;
comment|/* Now scale the pcdac values to fit in the 64 entry power table */
name|minScaledPwr
operator|=
name|pScaledUpDbm
index|[
literal|0
index|]
expr_stmt|;
name|maxScaledPwr
operator|=
name|pScaledUpDbm
index|[
name|pcdacStruct
operator|.
name|numPcdacValues
operator|-
literal|1
index|]
expr_stmt|;
comment|/* find minimum and make monotonic */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pcdacStruct
operator|.
name|numPcdacValues
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|minScaledPwr
operator|>=
name|pScaledUpDbm
index|[
name|j
index|]
condition|)
block|{
name|minScaledPwr
operator|=
name|pScaledUpDbm
index|[
name|j
index|]
expr_stmt|;
name|pcdacMin
operator|=
name|j
expr_stmt|;
block|}
comment|/* 		 * Make the full_hsh monotonically increasing otherwise 		 * interpolation algorithm will get fooled gotta start 		 * working from the top, hence i = 63 - j. 		 */
name|i
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|pcdacStruct
operator|.
name|numPcdacValues
operator|-
literal|1
operator|-
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|pScaledUpDbm
index|[
name|i
operator|-
literal|1
index|]
operator|>
name|pScaledUpDbm
index|[
name|i
index|]
condition|)
block|{
comment|/* 			 * It could be a glitch, so make the power for 			 * this pcdac the same as the power from the 			 * next highest pcdac. 			 */
name|pScaledUpDbm
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|pScaledUpDbm
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pcdacStruct
operator|.
name|numPcdacValues
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|maxScaledPwr
operator|<
name|pScaledUpDbm
index|[
name|j
index|]
condition|)
block|{
name|maxScaledPwr
operator|=
name|pScaledUpDbm
index|[
name|j
index|]
expr_stmt|;
name|pcdacMax
operator|=
name|j
expr_stmt|;
block|}
comment|/* Find the first power level with a pcdac */
name|pwr
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|PWR_STEP
operator|*
operator|(
operator|(
name|minScaledPwr
operator|-
name|PWR_MIN
operator|+
name|PWR_STEP
operator|/
literal|2
operator|)
operator|/
name|PWR_STEP
operator|)
operator|+
name|PWR_MIN
argument_list|)
expr_stmt|;
comment|/* Write all the first pcdac entries based off the pcdacMin */
name|pcdacTableIndex
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|2
operator|*
operator|(
name|pwr
operator|-
name|PWR_MIN
operator|)
operator|/
name|EEP_SCALE
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|pcdacTable
index|[
name|pcdacTableIndex
operator|++
index|]
operator|=
name|pcdacMin
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pwr
operator|<
name|pScaledUpDbm
index|[
name|pcdacStruct
operator|.
name|numPcdacValues
operator|-
literal|1
index|]
condition|)
block|{
name|pwr
operator|+=
name|PWR_STEP
expr_stmt|;
comment|/* stop if dbM> max_power_possible */
while|while
condition|(
name|pwr
operator|<
name|pScaledUpDbm
index|[
name|pcdacStruct
operator|.
name|numPcdacValues
operator|-
literal|1
index|]
operator|&&
operator|(
name|pwr
operator|-
name|pScaledUpDbm
index|[
name|i
index|]
operator|)
operator|*
operator|(
name|pwr
operator|-
name|pScaledUpDbm
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|>
literal|0
condition|)
name|i
operator|++
expr_stmt|;
comment|/* scale by 2 and add 1 to enable round up or down as needed */
name|scaledPcdac
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|ar5211GetInterpolatedValue
argument_list|(
name|pwr
argument_list|,
name|pScaledUpDbm
index|[
name|i
index|]
argument_list|,
name|pScaledUpDbm
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|pPcdacValues
index|[
name|i
index|]
operator|*
literal|2
argument_list|)
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|pPcdacValues
index|[
name|i
operator|+
literal|1
index|]
operator|*
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pcdacTable
index|[
name|pcdacTableIndex
index|]
operator|=
name|scaledPcdac
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|pcdacTable
index|[
name|pcdacTableIndex
index|]
operator|>
name|pcdacMax
condition|)
name|pcdacTable
index|[
name|pcdacTableIndex
index|]
operator|=
name|pcdacMax
expr_stmt|;
name|pcdacTableIndex
operator|++
expr_stmt|;
block|}
comment|/* Write all the last pcdac entries based off the last valid pcdac */
while|while
condition|(
name|pcdacTableIndex
operator|<
name|PWR_TABLE_SIZE
condition|)
block|{
name|pcdacTable
index|[
name|pcdacTableIndex
index|]
operator|=
name|pcdacTable
index|[
name|pcdacTableIndex
operator|-
literal|1
index|]
expr_stmt|;
name|pcdacTableIndex
operator|++
expr_stmt|;
block|}
comment|/* Finally, write the power values into the baseband power table */
name|addr
operator|=
name|AR_PHY_BASE
operator|+
operator|(
literal|608
operator|<<
literal|2
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|temp32
operator|=
literal|0xffff
operator|&
operator|(
operator|(
name|pcdacTable
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
literal|0xff
operator|)
expr_stmt|;
name|temp32
operator|=
operator|(
name|temp32
operator|<<
literal|16
operator|)
operator||
operator|(
literal|0xffff
operator|&
operator|(
operator|(
name|pcdacTable
index|[
literal|2
operator|*
name|i
index|]
operator|<<
literal|8
operator|)
operator||
literal|0xff
operator|)
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
name|temp32
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the transmit power in the baseband for the given  * operating channel and mode.  */
end_comment

begin_function
specifier|static
name|void
name|ar5211SetRateTable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|RD_EDGES_POWER
modifier|*
name|pRdEdgesPower
parameter_list|,
name|TRGT_POWER_INFO
modifier|*
name|pPowerInfo
parameter_list|,
name|uint16_t
name|numChannels
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|uint16_t
name|freq
init|=
name|ath_hal_gethwchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|struct
name|ath_hal_5211
modifier|*
name|ahp
init|=
name|AH5211
argument_list|(
name|ah
argument_list|)
decl_stmt|;
specifier|static
name|uint16_t
name|ratesArray
index|[
name|NUM_RATES
index|]
decl_stmt|;
specifier|static
specifier|const
name|uint16_t
name|tpcScaleReductionTable
index|[
literal|5
index|]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|6
block|,
literal|9
block|,
name|MAX_RATE_POWER
block|}
decl_stmt|;
name|uint16_t
modifier|*
name|pRatesPower
decl_stmt|;
name|uint16_t
name|lowerChannel
decl_stmt|,
name|lowerIndex
init|=
literal|0
decl_stmt|,
name|lowerPower
init|=
literal|0
decl_stmt|;
name|uint16_t
name|upperChannel
decl_stmt|,
name|upperIndex
init|=
literal|0
decl_stmt|,
name|upperPower
init|=
literal|0
decl_stmt|;
name|uint16_t
name|twiceMaxEdgePower
init|=
literal|63
decl_stmt|;
name|uint16_t
name|twicePower
init|=
literal|0
decl_stmt|;
name|uint16_t
name|i
decl_stmt|,
name|numEdges
decl_stmt|;
name|uint16_t
name|tempChannelList
index|[
name|NUM_EDGES
index|]
decl_stmt|;
comment|/* temp array for holding edge channels */
name|uint16_t
name|twiceMaxRDPower
decl_stmt|;
name|int16_t
name|scaledPower
init|=
literal|0
decl_stmt|;
comment|/* for gcc -O2 */
name|uint16_t
name|mask
init|=
literal|0x3f
decl_stmt|;
name|HAL_BOOL
name|paPreDEnable
init|=
literal|0
decl_stmt|;
name|int8_t
name|twiceAntennaGain
decl_stmt|,
name|twiceAntennaReduction
init|=
literal|0
decl_stmt|;
name|pRatesPower
operator|=
name|ratesArray
expr_stmt|;
name|twiceMaxRDPower
operator|=
name|chan
operator|->
name|ic_maxregpower
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|twiceAntennaGain
operator|=
name|ee
operator|->
name|ee_antennaGainMax
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|twiceAntennaGain
operator|=
name|ee
operator|->
name|ee_antennaGainMax
index|[
literal|1
index|]
expr_stmt|;
block|}
name|twiceAntennaReduction
operator|=
name|ath_hal_getantennareduction
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|twiceAntennaGain
argument_list|)
expr_stmt|;
if|if
condition|(
name|pRdEdgesPower
condition|)
block|{
comment|/* Get the edge power */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EDGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pRdEdgesPower
index|[
name|i
index|]
operator|.
name|rdEdge
operator|==
literal|0
condition|)
break|break;
name|tempChannelList
index|[
name|i
index|]
operator|=
name|pRdEdgesPower
index|[
name|i
index|]
operator|.
name|rdEdge
expr_stmt|;
block|}
name|numEdges
operator|=
name|i
expr_stmt|;
name|ar5211GetLowerUpperValues
argument_list|(
name|freq
argument_list|,
name|tempChannelList
argument_list|,
name|numEdges
argument_list|,
operator|&
name|lowerChannel
argument_list|,
operator|&
name|upperChannel
argument_list|)
expr_stmt|;
comment|/* Get the index for this channel */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numEdges
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|lowerChannel
operator|==
name|tempChannelList
index|[
name|i
index|]
condition|)
break|break;
name|HALASSERT
argument_list|(
name|i
operator|!=
name|numEdges
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lowerChannel
operator|==
name|upperChannel
operator|&&
name|lowerChannel
operator|==
name|freq
operator|)
operator|||
name|pRdEdgesPower
index|[
name|i
index|]
operator|.
name|flag
condition|)
block|{
name|twiceMaxEdgePower
operator|=
name|pRdEdgesPower
index|[
name|i
index|]
operator|.
name|twice_rdEdgePower
expr_stmt|;
name|HALASSERT
argument_list|(
name|twiceMaxEdgePower
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* extrapolate the power values for the test Groups */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numChannels
condition|;
name|i
operator|++
control|)
name|tempChannelList
index|[
name|i
index|]
operator|=
name|pPowerInfo
index|[
name|i
index|]
operator|.
name|testChannel
expr_stmt|;
name|ar5211GetLowerUpperValues
argument_list|(
name|freq
argument_list|,
name|tempChannelList
argument_list|,
name|numChannels
argument_list|,
operator|&
name|lowerChannel
argument_list|,
operator|&
name|upperChannel
argument_list|)
expr_stmt|;
comment|/* get the index for the channel */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numChannels
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lowerChannel
operator|==
name|tempChannelList
index|[
name|i
index|]
condition|)
name|lowerIndex
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|upperChannel
operator|==
name|tempChannelList
index|[
name|i
index|]
condition|)
block|{
name|upperIndex
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RATES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_OFDM
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* power for rates 6,9,12,18,24 is all the same */
if|if
condition|(
name|i
operator|<
literal|5
condition|)
block|{
name|lowerPower
operator|=
name|pPowerInfo
index|[
name|lowerIndex
index|]
operator|.
name|twicePwr6_24
expr_stmt|;
name|upperPower
operator|=
name|pPowerInfo
index|[
name|upperIndex
index|]
operator|.
name|twicePwr6_24
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|5
condition|)
block|{
name|lowerPower
operator|=
name|pPowerInfo
index|[
name|lowerIndex
index|]
operator|.
name|twicePwr36
expr_stmt|;
name|upperPower
operator|=
name|pPowerInfo
index|[
name|upperIndex
index|]
operator|.
name|twicePwr36
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|6
condition|)
block|{
name|lowerPower
operator|=
name|pPowerInfo
index|[
name|lowerIndex
index|]
operator|.
name|twicePwr48
expr_stmt|;
name|upperPower
operator|=
name|pPowerInfo
index|[
name|upperIndex
index|]
operator|.
name|twicePwr48
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|7
condition|)
block|{
name|lowerPower
operator|=
name|pPowerInfo
index|[
name|lowerIndex
index|]
operator|.
name|twicePwr54
expr_stmt|;
name|upperPower
operator|=
name|pPowerInfo
index|[
name|upperIndex
index|]
operator|.
name|twicePwr54
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|lowerPower
operator|=
name|pPowerInfo
index|[
name|lowerIndex
index|]
operator|.
name|twicePwr6_24
expr_stmt|;
name|upperPower
operator|=
name|pPowerInfo
index|[
name|upperIndex
index|]
operator|.
name|twicePwr6_24
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|3
case|:
name|lowerPower
operator|=
name|pPowerInfo
index|[
name|lowerIndex
index|]
operator|.
name|twicePwr36
expr_stmt|;
name|upperPower
operator|=
name|pPowerInfo
index|[
name|upperIndex
index|]
operator|.
name|twicePwr36
expr_stmt|;
break|break;
case|case
literal|4
case|:
case|case
literal|5
case|:
name|lowerPower
operator|=
name|pPowerInfo
index|[
name|lowerIndex
index|]
operator|.
name|twicePwr48
expr_stmt|;
name|upperPower
operator|=
name|pPowerInfo
index|[
name|upperIndex
index|]
operator|.
name|twicePwr48
expr_stmt|;
break|break;
case|case
literal|6
case|:
case|case
literal|7
case|:
name|lowerPower
operator|=
name|pPowerInfo
index|[
name|lowerIndex
index|]
operator|.
name|twicePwr54
expr_stmt|;
name|upperPower
operator|=
name|pPowerInfo
index|[
name|upperIndex
index|]
operator|.
name|twicePwr54
expr_stmt|;
break|break;
block|}
block|}
name|twicePower
operator|=
name|ar5211GetInterpolatedValue
argument_list|(
name|freq
argument_list|,
name|lowerChannel
argument_list|,
name|upperChannel
argument_list|,
name|lowerPower
argument_list|,
name|upperPower
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reduce power by band edge restrictions */
name|twicePower
operator|=
name|AH_MIN
argument_list|(
name|twicePower
argument_list|,
name|twiceMaxEdgePower
argument_list|)
expr_stmt|;
comment|/* 		 * If turbo is set, reduce power to keep power 		 * consumption under 2 Watts.  Note that we always do 		 * this unless specially configured.  Then we limit 		 * power only for non-AP operation. 		 */
if|if
condition|(
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
operator|&&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeversion
operator|>=
name|AR_EEPROM_VER3_1
ifdef|#
directive|ifdef
name|AH_ENABLE_AP_SUPPORT
operator|&&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
operator|!=
name|HAL_M_HOSTAP
endif|#
directive|endif
condition|)
block|{
name|twicePower
operator|=
name|AH_MIN
argument_list|(
name|twicePower
argument_list|,
name|ee
operator|->
name|ee_turbo2WMaxPower5
argument_list|)
expr_stmt|;
block|}
comment|/* Reduce power by max regulatory domain allowed restrictions */
name|pRatesPower
index|[
name|i
index|]
operator|=
name|AH_MIN
argument_list|(
name|twicePower
argument_list|,
name|twiceMaxRDPower
operator|-
name|twiceAntennaReduction
argument_list|)
expr_stmt|;
comment|/* Use 6 Mb power level for transmit power scaling reduction */
comment|/* We don't want to reduce higher rates if its not needed */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|scaledPower
operator|=
name|pRatesPower
index|[
literal|0
index|]
operator|-
operator|(
name|tpcScaleReductionTable
index|[
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tpScale
index|]
operator|*
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|scaledPower
operator|<
literal|1
condition|)
name|scaledPower
operator|=
literal|1
expr_stmt|;
block|}
name|pRatesPower
index|[
name|i
index|]
operator|=
name|AH_MIN
argument_list|(
name|pRatesPower
index|[
name|i
index|]
argument_list|,
name|scaledPower
argument_list|)
expr_stmt|;
block|}
comment|/* Record txPower at Rate 6 for info gathering */
name|ahp
operator|->
name|ah_tx6PowerInHalfDbm
operator|=
name|pRatesPower
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|AH_DEBUG
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s: final output power setting %d MHz:\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"6 Mb %d dBm, MaxRD: %d dBm, MaxEdge %d dBm\n"
argument_list|,
name|scaledPower
operator|/
literal|2
argument_list|,
name|twiceMaxRDPower
operator|/
literal|2
argument_list|,
name|twiceMaxEdgePower
operator|/
literal|2
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"TPC Scale %d dBm - Ant Red %d dBm\n"
argument_list|,
name|tpcScaleReductionTable
index|[
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tpScale
index|]
operator|*
literal|2
argument_list|,
name|twiceAntennaReduction
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
operator|&&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeversion
operator|>=
name|AR_EEPROM_VER3_1
condition|)
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"Max Turbo %d dBm\n"
argument_list|,
name|ee
operator|->
name|ee_turbo2WMaxPower5
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"  %2d | %2d | %2d | %2d | %2d | %2d | %2d | %2d dBm\n"
argument_list|,
name|pRatesPower
index|[
literal|0
index|]
operator|/
literal|2
argument_list|,
name|pRatesPower
index|[
literal|1
index|]
operator|/
literal|2
argument_list|,
name|pRatesPower
index|[
literal|2
index|]
operator|/
literal|2
argument_list|,
name|pRatesPower
index|[
literal|3
index|]
operator|/
literal|2
argument_list|,
name|pRatesPower
index|[
literal|4
index|]
operator|/
literal|2
argument_list|,
name|pRatesPower
index|[
literal|5
index|]
operator|/
literal|2
argument_list|,
name|pRatesPower
index|[
literal|6
index|]
operator|/
literal|2
argument_list|,
name|pRatesPower
index|[
literal|7
index|]
operator|/
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AH_DEBUG */
comment|/* Write the power table into the hardware */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_RATE1
argument_list|,
operator|(
operator|(
name|paPreDEnable
operator|&
literal|1
operator|)
operator|<<
literal|30
operator|)
operator||
operator|(
operator|(
name|pRatesPower
index|[
literal|3
index|]
operator|&
name|mask
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|paPreDEnable
operator|&
literal|1
operator|)
operator|<<
literal|22
operator|)
operator||
operator|(
operator|(
name|pRatesPower
index|[
literal|2
index|]
operator|&
name|mask
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|paPreDEnable
operator|&
literal|1
operator|)
operator|<<
literal|14
operator|)
operator||
operator|(
operator|(
name|pRatesPower
index|[
literal|1
index|]
operator|&
name|mask
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|paPreDEnable
operator|&
literal|1
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|pRatesPower
index|[
literal|0
index|]
operator|&
name|mask
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_RATE2
argument_list|,
operator|(
operator|(
name|paPreDEnable
operator|&
literal|1
operator|)
operator|<<
literal|30
operator|)
operator||
operator|(
operator|(
name|pRatesPower
index|[
literal|7
index|]
operator|&
name|mask
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|paPreDEnable
operator|&
literal|1
operator|)
operator|<<
literal|22
operator|)
operator||
operator|(
operator|(
name|pRatesPower
index|[
literal|6
index|]
operator|&
name|mask
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|paPreDEnable
operator|&
literal|1
operator|)
operator|<<
literal|14
operator|)
operator||
operator|(
operator|(
name|pRatesPower
index|[
literal|5
index|]
operator|&
name|mask
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|paPreDEnable
operator|&
literal|1
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|pRatesPower
index|[
literal|4
index|]
operator|&
name|mask
operator|)
argument_list|)
expr_stmt|;
comment|/* set max power to the power value at rate 6 */
name|ar5211SetTxPowerLimit
argument_list|(
name|ah
argument_list|,
name|pRatesPower
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_maxPowerLevel
operator|=
name|pRatesPower
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get or interpolate the pcdac value from the calibrated data  */
end_comment

begin_function
name|uint16_t
name|ar5211GetScaledPower
parameter_list|(
name|uint16_t
name|channel
parameter_list|,
name|uint16_t
name|pcdacValue
parameter_list|,
specifier|const
name|PCDACS_EEPROM
modifier|*
name|pSrcStruct
parameter_list|)
block|{
name|uint16_t
name|powerValue
decl_stmt|;
name|uint16_t
name|lFreq
decl_stmt|,
name|rFreq
decl_stmt|;
comment|/* left and right frequency values */
name|uint16_t
name|llPcdac
decl_stmt|,
name|ulPcdac
decl_stmt|;
comment|/* lower and upper left pcdac values */
name|uint16_t
name|lrPcdac
decl_stmt|,
name|urPcdac
decl_stmt|;
comment|/* lower and upper right pcdac values */
name|uint16_t
name|lPwr
decl_stmt|,
name|uPwr
decl_stmt|;
comment|/* lower and upper temp pwr values */
name|uint16_t
name|lScaledPwr
decl_stmt|,
name|rScaledPwr
decl_stmt|;
comment|/* left and right scaled power */
if|if
condition|(
name|ar5211FindValueInList
argument_list|(
name|channel
argument_list|,
name|pcdacValue
argument_list|,
name|pSrcStruct
argument_list|,
operator|&
name|powerValue
argument_list|)
condition|)
comment|/* value was copied from srcStruct */
return|return
name|powerValue
return|;
name|ar5211GetLowerUpperValues
argument_list|(
name|channel
argument_list|,
name|pSrcStruct
operator|->
name|pChannelList
argument_list|,
name|pSrcStruct
operator|->
name|numChannels
argument_list|,
operator|&
name|lFreq
argument_list|,
operator|&
name|rFreq
argument_list|)
expr_stmt|;
name|ar5211GetLowerUpperPcdacs
argument_list|(
name|pcdacValue
argument_list|,
name|lFreq
argument_list|,
name|pSrcStruct
argument_list|,
operator|&
name|llPcdac
argument_list|,
operator|&
name|ulPcdac
argument_list|)
expr_stmt|;
name|ar5211GetLowerUpperPcdacs
argument_list|(
name|pcdacValue
argument_list|,
name|rFreq
argument_list|,
name|pSrcStruct
argument_list|,
operator|&
name|lrPcdac
argument_list|,
operator|&
name|urPcdac
argument_list|)
expr_stmt|;
comment|/* get the power index for the pcdac value */
name|ar5211FindValueInList
argument_list|(
name|lFreq
argument_list|,
name|llPcdac
argument_list|,
name|pSrcStruct
argument_list|,
operator|&
name|lPwr
argument_list|)
expr_stmt|;
name|ar5211FindValueInList
argument_list|(
name|lFreq
argument_list|,
name|ulPcdac
argument_list|,
name|pSrcStruct
argument_list|,
operator|&
name|uPwr
argument_list|)
expr_stmt|;
name|lScaledPwr
operator|=
name|ar5211GetInterpolatedValue
argument_list|(
name|pcdacValue
argument_list|,
name|llPcdac
argument_list|,
name|ulPcdac
argument_list|,
name|lPwr
argument_list|,
name|uPwr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar5211FindValueInList
argument_list|(
name|rFreq
argument_list|,
name|lrPcdac
argument_list|,
name|pSrcStruct
argument_list|,
operator|&
name|lPwr
argument_list|)
expr_stmt|;
name|ar5211FindValueInList
argument_list|(
name|rFreq
argument_list|,
name|urPcdac
argument_list|,
name|pSrcStruct
argument_list|,
operator|&
name|uPwr
argument_list|)
expr_stmt|;
name|rScaledPwr
operator|=
name|ar5211GetInterpolatedValue
argument_list|(
name|pcdacValue
argument_list|,
name|lrPcdac
argument_list|,
name|urPcdac
argument_list|,
name|lPwr
argument_list|,
name|uPwr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ar5211GetInterpolatedValue
argument_list|(
name|channel
argument_list|,
name|lFreq
argument_list|,
name|rFreq
argument_list|,
name|lScaledPwr
argument_list|,
name|rScaledPwr
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the value from the calibrated source data struct  */
end_comment

begin_function
name|HAL_BOOL
name|ar5211FindValueInList
parameter_list|(
name|uint16_t
name|channel
parameter_list|,
name|uint16_t
name|pcdacValue
parameter_list|,
specifier|const
name|PCDACS_EEPROM
modifier|*
name|pSrcStruct
parameter_list|,
name|uint16_t
modifier|*
name|powerValue
parameter_list|)
block|{
specifier|const
name|DATA_PER_CHANNEL
modifier|*
name|pChannelData
decl_stmt|;
specifier|const
name|uint16_t
modifier|*
name|pPcdac
decl_stmt|;
name|uint16_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|pChannelData
operator|=
name|pSrcStruct
operator|->
name|pDataPerChannel
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pSrcStruct
operator|->
name|numChannels
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pChannelData
operator|->
name|channelValue
operator|==
name|channel
condition|)
block|{
name|pPcdac
operator|=
name|pChannelData
operator|->
name|PcdacValues
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pChannelData
operator|->
name|numPcdacValues
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|pPcdac
operator|==
name|pcdacValue
condition|)
block|{
operator|*
name|powerValue
operator|=
name|pChannelData
operator|->
name|PwrValues
index|[
name|j
index|]
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
name|pPcdac
operator|++
expr_stmt|;
block|}
block|}
name|pChannelData
operator|++
expr_stmt|;
block|}
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Returns interpolated or the scaled up interpolated value  */
end_comment

begin_function
name|uint16_t
name|ar5211GetInterpolatedValue
parameter_list|(
name|uint16_t
name|target
parameter_list|,
name|uint16_t
name|srcLeft
parameter_list|,
name|uint16_t
name|srcRight
parameter_list|,
name|uint16_t
name|targetLeft
parameter_list|,
name|uint16_t
name|targetRight
parameter_list|,
name|HAL_BOOL
name|scaleUp
parameter_list|)
block|{
name|uint16_t
name|rv
decl_stmt|;
name|int16_t
name|lRatio
decl_stmt|;
name|uint16_t
name|scaleValue
init|=
name|EEP_SCALE
decl_stmt|;
comment|/* to get an accurate ratio, always scale, if want to scale, then don't scale back down */
if|if
condition|(
operator|(
name|targetLeft
operator|*
name|targetRight
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|scaleUp
condition|)
name|scaleValue
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|srcRight
operator|!=
name|srcLeft
condition|)
block|{
comment|/* 		 * Note the ratio always need to be scaled, 		 * since it will be a fraction. 		 */
name|lRatio
operator|=
operator|(
name|target
operator|-
name|srcLeft
operator|)
operator|*
name|EEP_SCALE
operator|/
operator|(
name|srcRight
operator|-
name|srcLeft
operator|)
expr_stmt|;
if|if
condition|(
name|lRatio
operator|<
literal|0
condition|)
block|{
comment|/* Return as Left target if value would be negative */
name|rv
operator|=
name|targetLeft
operator|*
operator|(
name|scaleUp
condition|?
name|EEP_SCALE
else|:
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lRatio
operator|>
name|EEP_SCALE
condition|)
block|{
comment|/* Return as Right target if Ratio is greater than 100% (SCALE) */
name|rv
operator|=
name|targetRight
operator|*
operator|(
name|scaleUp
condition|?
name|EEP_SCALE
else|:
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|rv
operator|=
operator|(
name|lRatio
operator|*
name|targetRight
operator|+
operator|(
name|EEP_SCALE
operator|-
name|lRatio
operator|)
operator|*
name|targetLeft
operator|)
operator|/
name|scaleValue
expr_stmt|;
block|}
block|}
else|else
block|{
name|rv
operator|=
name|targetLeft
expr_stmt|;
if|if
condition|(
name|scaleUp
condition|)
name|rv
operator|*=
name|EEP_SCALE
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/*  *  Look for value being within 0.1 of the search values  *  however, NDIS can't do float calculations, so multiply everything  *  up by EEP_SCALE so can do integer arithmatic  *  * INPUT  value	   -value to search for  * INPUT  pList	   -ptr to the list to search  * INPUT  listSize	-number of entries in list  * OUTPUT pLowerValue -return the lower value  * OUTPUT pUpperValue -return the upper value  */
end_comment

begin_function
name|void
name|ar5211GetLowerUpperValues
parameter_list|(
name|uint16_t
name|value
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|pList
parameter_list|,
name|uint16_t
name|listSize
parameter_list|,
name|uint16_t
modifier|*
name|pLowerValue
parameter_list|,
name|uint16_t
modifier|*
name|pUpperValue
parameter_list|)
block|{
specifier|const
name|uint16_t
name|listEndValue
init|=
operator|*
operator|(
name|pList
operator|+
name|listSize
operator|-
literal|1
operator|)
decl_stmt|;
name|uint32_t
name|target
init|=
name|value
operator|*
name|EEP_SCALE
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * See if value is lower than the first value in the list 	 * if so return first value 	 */
if|if
condition|(
name|target
operator|<
call|(
name|uint32_t
call|)
argument_list|(
operator|*
name|pList
operator|*
name|EEP_SCALE
operator|-
name|EEP_DELTA
argument_list|)
condition|)
block|{
operator|*
name|pLowerValue
operator|=
operator|*
name|pList
expr_stmt|;
operator|*
name|pUpperValue
operator|=
operator|*
name|pList
expr_stmt|;
return|return;
block|}
comment|/* 	 * See if value is greater than last value in list 	 * if so return last value 	 */
if|if
condition|(
name|target
operator|>
call|(
name|uint32_t
call|)
argument_list|(
name|listEndValue
operator|*
name|EEP_SCALE
operator|+
name|EEP_DELTA
argument_list|)
condition|)
block|{
operator|*
name|pLowerValue
operator|=
name|listEndValue
expr_stmt|;
operator|*
name|pUpperValue
operator|=
name|listEndValue
expr_stmt|;
return|return;
block|}
comment|/* look for value being near or between 2 values in list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|listSize
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * If value is close to the current value of the list 		 * then target is not between values, it is one of the values 		 */
if|if
condition|(
name|abs
argument_list|(
name|pList
index|[
name|i
index|]
operator|*
name|EEP_SCALE
operator|-
operator|(
name|int32_t
operator|)
name|target
argument_list|)
operator|<
name|EEP_DELTA
condition|)
block|{
operator|*
name|pLowerValue
operator|=
name|pList
index|[
name|i
index|]
expr_stmt|;
operator|*
name|pUpperValue
operator|=
name|pList
index|[
name|i
index|]
expr_stmt|;
return|return;
block|}
comment|/* 		 * Look for value being between current value and next value 		 * if so return these 2 values 		 */
if|if
condition|(
name|target
operator|<
call|(
name|uint32_t
call|)
argument_list|(
name|pList
index|[
name|i
operator|+
literal|1
index|]
operator|*
name|EEP_SCALE
operator|-
name|EEP_DELTA
argument_list|)
condition|)
block|{
operator|*
name|pLowerValue
operator|=
name|pList
index|[
name|i
index|]
expr_stmt|;
operator|*
name|pUpperValue
operator|=
name|pList
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Get the upper and lower pcdac given the channel and the pcdac  * used in the search  */
end_comment

begin_function
name|void
name|ar5211GetLowerUpperPcdacs
parameter_list|(
name|uint16_t
name|pcdac
parameter_list|,
name|uint16_t
name|channel
parameter_list|,
specifier|const
name|PCDACS_EEPROM
modifier|*
name|pSrcStruct
parameter_list|,
name|uint16_t
modifier|*
name|pLowerPcdac
parameter_list|,
name|uint16_t
modifier|*
name|pUpperPcdac
parameter_list|)
block|{
specifier|const
name|DATA_PER_CHANNEL
modifier|*
name|pChannelData
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Find the channel information */
name|pChannelData
operator|=
name|pSrcStruct
operator|->
name|pDataPerChannel
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pSrcStruct
operator|->
name|numChannels
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pChannelData
operator|->
name|channelValue
operator|==
name|channel
condition|)
break|break;
name|pChannelData
operator|++
expr_stmt|;
block|}
name|ar5211GetLowerUpperValues
argument_list|(
name|pcdac
argument_list|,
name|pChannelData
operator|->
name|PcdacValues
argument_list|,
name|pChannelData
operator|->
name|numPcdacValues
argument_list|,
name|pLowerPcdac
argument_list|,
name|pUpperPcdac
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|DYN_ADJ_UP_MARGIN
value|15
end_define

begin_define
define|#
directive|define
name|DYN_ADJ_LO_MARGIN
value|20
end_define

begin_decl_stmt
specifier|static
specifier|const
name|GAIN_OPTIMIZATION_LADDER
name|gainLadder
init|=
block|{
literal|9
block|,
comment|/* numStepsInLadder */
literal|4
block|,
comment|/* defaultStepNum */
block|{
block|{
block|{
literal|4
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
literal|6
block|,
literal|"FG8"
block|}
block|,
block|{
block|{
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
literal|4
block|,
literal|"FG7"
block|}
block|,
block|{
block|{
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
literal|3
block|,
literal|"FG6"
block|}
block|,
block|{
block|{
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
literal|1
block|,
literal|"FG5"
block|}
block|,
block|{
block|{
literal|4
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|"FG4"
block|}
block|,
comment|/* noJack */
block|{
block|{
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
operator|-
literal|2
block|,
literal|"FG3"
block|}
block|,
comment|/* halfJack */
block|{
block|{
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
operator|-
literal|3
block|,
literal|"FG2"
block|}
block|,
comment|/* clip3 */
block|{
block|{
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
operator|-
literal|4
block|,
literal|"FG1"
block|}
block|,
comment|/* noJack */
block|{
block|{
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
operator|-
literal|6
block|,
literal|"FG0"
block|}
comment|/* clip2 */
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize the gain structure to good values  */
end_comment

begin_function
name|void
name|ar5211InitializeGainValues
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_5211
modifier|*
name|ahp
init|=
name|AH5211
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|GAIN_VALUES
modifier|*
name|gv
init|=
operator|&
name|ahp
operator|->
name|ah_gainValues
decl_stmt|;
comment|/* initialize gain optimization values */
name|gv
operator|->
name|currStepNum
operator|=
name|gainLadder
operator|.
name|defaultStepNum
expr_stmt|;
name|gv
operator|->
name|currStep
operator|=
operator|&
name|gainLadder
operator|.
name|optStep
index|[
name|gainLadder
operator|.
name|defaultStepNum
index|]
expr_stmt|;
name|gv
operator|->
name|active
operator|=
name|AH_TRUE
expr_stmt|;
name|gv
operator|->
name|loTrig
operator|=
literal|20
expr_stmt|;
name|gv
operator|->
name|hiTrig
operator|=
literal|35
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|ar5211InvalidGainReadback
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|GAIN_VALUES
modifier|*
name|gv
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
decl_stmt|;
name|uint32_t
name|gStep
decl_stmt|,
name|g
decl_stmt|;
name|uint32_t
name|L1
decl_stmt|,
name|L2
decl_stmt|,
name|L3
decl_stmt|,
name|L4
decl_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|gStep
operator|=
literal|0x18
expr_stmt|;
name|L1
operator|=
literal|0
expr_stmt|;
name|L2
operator|=
name|gStep
operator|+
literal|4
expr_stmt|;
name|L3
operator|=
literal|0x40
expr_stmt|;
name|L4
operator|=
name|L3
operator|+
literal|50
expr_stmt|;
name|gv
operator|->
name|loTrig
operator|=
name|L1
expr_stmt|;
name|gv
operator|->
name|hiTrig
operator|=
name|L4
operator|+
literal|5
expr_stmt|;
block|}
else|else
block|{
name|gStep
operator|=
literal|0x3f
expr_stmt|;
name|L1
operator|=
literal|0
expr_stmt|;
name|L2
operator|=
literal|50
expr_stmt|;
name|L3
operator|=
name|L1
expr_stmt|;
name|L4
operator|=
name|L3
operator|+
literal|50
expr_stmt|;
name|gv
operator|->
name|loTrig
operator|=
name|L1
operator|+
name|DYN_ADJ_LO_MARGIN
expr_stmt|;
name|gv
operator|->
name|hiTrig
operator|=
name|L4
operator|-
name|DYN_ADJ_UP_MARGIN
expr_stmt|;
block|}
name|g
operator|=
name|gv
operator|->
name|currGain
expr_stmt|;
return|return
operator|!
operator|(
operator|(
name|g
operator|>=
name|L1
operator|&&
name|g
operator|<=
name|L2
operator|)
operator|||
operator|(
name|g
operator|>=
name|L3
operator|&&
name|g
operator|<=
name|L4
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enable the probe gain check on the next packet  */
end_comment

begin_function
specifier|static
name|void
name|ar5211RequestRfgain
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_5211
modifier|*
name|ahp
init|=
name|AH5211
argument_list|(
name|ah
argument_list|)
decl_stmt|;
comment|/* Enable the gain readback probe */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PAPD_PROBE
argument_list|,
name|SM
argument_list|(
name|ahp
operator|->
name|ah_tx6PowerInHalfDbm
argument_list|,
name|AR_PHY_PAPD_PROBE_POWERTX
argument_list|)
operator||
name|AR_PHY_PAPD_PROBE_NEXT_TX
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_rfgainState
operator|=
name|HAL_RFGAIN_READ_REQUESTED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Exported call to check for a recent gain reading and return  * the current state of the thermal calibration gain engine.  */
end_comment

begin_function
name|HAL_RFGAIN
name|ar5211GetRfgain
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_5211
modifier|*
name|ahp
init|=
name|AH5211
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|GAIN_VALUES
modifier|*
name|gv
init|=
operator|&
name|ahp
operator|->
name|ah_gainValues
decl_stmt|;
name|uint32_t
name|rddata
decl_stmt|;
if|if
condition|(
operator|!
name|gv
operator|->
name|active
condition|)
return|return
name|HAL_RFGAIN_INACTIVE
return|;
if|if
condition|(
name|ahp
operator|->
name|ah_rfgainState
operator|==
name|HAL_RFGAIN_READ_REQUESTED
condition|)
block|{
comment|/* Caller had asked to setup a new reading. Check it. */
name|rddata
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PAPD_PROBE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rddata
operator|&
name|AR_PHY_PAPD_PROBE_NEXT_TX
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* bit got cleared, we have a new reading. */
name|gv
operator|->
name|currGain
operator|=
name|rddata
operator|>>
name|AR_PHY_PAPD_PROBE_GAINF_S
expr_stmt|;
comment|/* inactive by default */
name|ahp
operator|->
name|ah_rfgainState
operator|=
name|HAL_RFGAIN_INACTIVE
expr_stmt|;
if|if
condition|(
operator|!
name|ar5211InvalidGainReadback
argument_list|(
name|ah
argument_list|,
name|gv
argument_list|)
operator|&&
name|ar5211IsGainAdjustNeeded
argument_list|(
name|ah
argument_list|,
name|gv
argument_list|)
operator|&&
name|ar5211AdjustGain
argument_list|(
name|ah
argument_list|,
name|gv
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* 				 * Change needed. Copy ladder info 				 * into eeprom info. 				 */
name|ar5211SetRfgain
argument_list|(
name|ah
argument_list|,
name|gv
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_rfgainState
operator|=
name|HAL_RFGAIN_NEED_CHANGE
expr_stmt|;
block|}
block|}
block|}
return|return
name|ahp
operator|->
name|ah_rfgainState
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if our readback gain level sits within the linear  * region of our current variable attenuation window  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5211IsGainAdjustNeeded
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|GAIN_VALUES
modifier|*
name|gv
parameter_list|)
block|{
return|return
operator|(
name|gv
operator|->
name|currGain
operator|<=
name|gv
operator|->
name|loTrig
operator|||
name|gv
operator|->
name|currGain
operator|>=
name|gv
operator|->
name|hiTrig
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move the rabbit ears in the correct direction.  */
end_comment

begin_function
specifier|static
name|int32_t
name|ar5211AdjustGain
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|GAIN_VALUES
modifier|*
name|gv
parameter_list|)
block|{
comment|/* return> 0 for valid adjustments. */
if|if
condition|(
operator|!
name|gv
operator|->
name|active
condition|)
return|return
operator|-
literal|1
return|;
name|gv
operator|->
name|currStep
operator|=
operator|&
name|gainLadder
operator|.
name|optStep
index|[
name|gv
operator|->
name|currStepNum
index|]
expr_stmt|;
if|if
condition|(
name|gv
operator|->
name|currGain
operator|>=
name|gv
operator|->
name|hiTrig
condition|)
block|{
if|if
condition|(
name|gv
operator|->
name|currStepNum
operator|==
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RFPARAM
argument_list|,
literal|"%s: Max gain limit.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RFPARAM
argument_list|,
literal|"%s: Adding gain: currG=%d [%s] --> "
argument_list|,
name|__func__
argument_list|,
name|gv
operator|->
name|currGain
argument_list|,
name|gv
operator|->
name|currStep
operator|->
name|stepName
argument_list|)
expr_stmt|;
name|gv
operator|->
name|targetGain
operator|=
name|gv
operator|->
name|currGain
expr_stmt|;
while|while
condition|(
name|gv
operator|->
name|targetGain
operator|>=
name|gv
operator|->
name|hiTrig
operator|&&
name|gv
operator|->
name|currStepNum
operator|>
literal|0
condition|)
block|{
name|gv
operator|->
name|targetGain
operator|-=
literal|2
operator|*
operator|(
name|gainLadder
operator|.
name|optStep
index|[
operator|--
operator|(
name|gv
operator|->
name|currStepNum
operator|)
index|]
operator|.
name|stepGain
operator|-
name|gv
operator|->
name|currStep
operator|->
name|stepGain
operator|)
expr_stmt|;
name|gv
operator|->
name|currStep
operator|=
operator|&
name|gainLadder
operator|.
name|optStep
index|[
name|gv
operator|->
name|currStepNum
index|]
expr_stmt|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RFPARAM
argument_list|,
literal|"targG=%d [%s]\n"
argument_list|,
name|gv
operator|->
name|targetGain
argument_list|,
name|gv
operator|->
name|currStep
operator|->
name|stepName
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gv
operator|->
name|currGain
operator|<=
name|gv
operator|->
name|loTrig
condition|)
block|{
if|if
condition|(
name|gv
operator|->
name|currStepNum
operator|==
name|gainLadder
operator|.
name|numStepsInLadder
operator|-
literal|1
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RFPARAM
argument_list|,
literal|"%s: Min gain limit.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RFPARAM
argument_list|,
literal|"%s: Deducting gain: currG=%d [%s] --> "
argument_list|,
name|__func__
argument_list|,
name|gv
operator|->
name|currGain
argument_list|,
name|gv
operator|->
name|currStep
operator|->
name|stepName
argument_list|)
expr_stmt|;
name|gv
operator|->
name|targetGain
operator|=
name|gv
operator|->
name|currGain
expr_stmt|;
while|while
condition|(
name|gv
operator|->
name|targetGain
operator|<=
name|gv
operator|->
name|loTrig
operator|&&
name|gv
operator|->
name|currStepNum
operator|<
operator|(
name|gainLadder
operator|.
name|numStepsInLadder
operator|-
literal|1
operator|)
condition|)
block|{
name|gv
operator|->
name|targetGain
operator|-=
literal|2
operator|*
operator|(
name|gainLadder
operator|.
name|optStep
index|[
operator|++
operator|(
name|gv
operator|->
name|currStepNum
operator|)
index|]
operator|.
name|stepGain
operator|-
name|gv
operator|->
name|currStep
operator|->
name|stepGain
operator|)
expr_stmt|;
name|gv
operator|->
name|currStep
operator|=
operator|&
name|gainLadder
operator|.
name|optStep
index|[
name|gv
operator|->
name|currStepNum
index|]
expr_stmt|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RFPARAM
argument_list|,
literal|"targG=%d [%s]\n"
argument_list|,
name|gv
operator|->
name|targetGain
argument_list|,
name|gv
operator|->
name|currStep
operator|->
name|stepName
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
return|return
literal|0
return|;
comment|/* caller didn't call needAdjGain first */
block|}
end_function

begin_comment
comment|/*  * Adjust the 5GHz EEPROM information with the desired calibration values.  */
end_comment

begin_function
specifier|static
name|void
name|ar5211SetRfgain
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|GAIN_VALUES
modifier|*
name|gv
parameter_list|)
block|{
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
if|if
condition|(
operator|!
name|gv
operator|->
name|active
condition|)
return|return;
name|ee
operator|->
name|ee_cornerCal
operator|.
name|clip
operator|=
name|gv
operator|->
name|currStep
operator|->
name|paramVal
index|[
literal|0
index|]
expr_stmt|;
comment|/* bb_tx_clip */
name|ee
operator|->
name|ee_cornerCal
operator|.
name|pd90
operator|=
name|gv
operator|->
name|currStep
operator|->
name|paramVal
index|[
literal|1
index|]
expr_stmt|;
comment|/* rf_pwd_90 */
name|ee
operator|->
name|ee_cornerCal
operator|.
name|pd84
operator|=
name|gv
operator|->
name|currStep
operator|->
name|paramVal
index|[
literal|2
index|]
expr_stmt|;
comment|/* rf_pwd_84 */
name|ee
operator|->
name|ee_cornerCal
operator|.
name|gSel
operator|=
name|gv
operator|->
name|currStep
operator|->
name|paramVal
index|[
literal|3
index|]
expr_stmt|;
comment|/* rf_rfgainsel */
block|}
end_function

begin_function
specifier|static
name|void
name|ar5211SetOperatingMode
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|opmode
parameter_list|)
block|{
name|struct
name|ath_hal_5211
modifier|*
name|ahp
init|=
name|AH5211
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
switch|switch
condition|(
name|opmode
condition|)
block|{
case|case
name|HAL_M_HOSTAP
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|val
operator||
name|AR_STA_ID1_STA_AP
operator||
name|AR_STA_ID1_RTS_USE_DEF
operator||
name|ahp
operator|->
name|ah_staId1Defaults
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_M_IBSS
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|val
operator||
name|AR_STA_ID1_ADHOC
operator||
name|AR_STA_ID1_DESC_ANTENNA
operator||
name|ahp
operator|->
name|ah_staId1Defaults
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_M_STA
case|:
case|case
name|HAL_M_MONITOR
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|val
operator||
name|AR_STA_ID1_DEFAULT_ANTENNA
operator||
name|ahp
operator|->
name|ah_staId1Defaults
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|ar5211SetPCUConfig
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|ar5211SetOperatingMode
argument_list|(
name|ah
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

