begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2002-2006 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ar5211/ar5211.h"
end_include

begin_include
include|#
directive|include
file|"ar5211/ar5211reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5211/ar5211phy.h"
end_include

begin_include
include|#
directive|include
file|"ah_eeprom_v3.h"
end_include

begin_define
define|#
directive|define
name|AR_NUM_GPIO
value|6
end_define

begin_comment
comment|/* 6 GPIO bits */
end_comment

begin_define
define|#
directive|define
name|AR_GPIOD_MASK
value|0x2f
end_define

begin_comment
comment|/* 6-bit mask */
end_comment

begin_function
name|void
name|ar5211GetMacAddress
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint8_t
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|ath_hal_5211
modifier|*
name|ahp
init|=
name|AH5211
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|OS_MEMCPY
argument_list|(
name|mac
argument_list|,
name|ahp
operator|->
name|ah_macaddr
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5211SetMacAddress
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|ath_hal_5211
modifier|*
name|ahp
init|=
name|AH5211
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|OS_MEMCPY
argument_list|(
name|ahp
operator|->
name|ah_macaddr
argument_list|,
name|mac
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|void
name|ar5211GetBssIdMask
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint8_t
modifier|*
name|mask
parameter_list|)
block|{
specifier|static
specifier|const
name|uint8_t
name|ones
index|[
name|IEEE80211_ADDR_LEN
index|]
init|=
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
name|OS_MEMCPY
argument_list|(
name|mask
argument_list|,
name|ones
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5211SetBssIdMask
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|mask
parameter_list|)
block|{
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Read 16 bits of data from the specified EEPROM offset.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5211EepromRead
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|off
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_EEPROM_ADDR
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_EEPROM_CMD
argument_list|,
name|AR_EEPROM_CMD_READ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_EEPROM_STS
argument_list|,
name|AR_EEPROM_STS_READ_COMPLETE
operator||
name|AR_EEPROM_STS_READ_ERROR
argument_list|,
name|AR_EEPROM_STS_READ_COMPLETE
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: read failed for entry 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
operator|*
name|data
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_EEPROM_DATA
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AH_SUPPORT_WRITE_EEPROM
end_ifdef

begin_comment
comment|/*  * Write 16 bits of data to the specified EEPROM offset.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5211EepromWrite
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|off
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AH_SUPPORT_WRITE_EEPROM */
end_comment

begin_comment
comment|/*  * Attempt to change the cards operating regulatory domain to the given value  */
end_comment

begin_function
name|HAL_BOOL
name|ar5211SetRegulatoryDomain
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint16_t
name|regDomain
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
name|HAL_STATUS
name|ecode
decl_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_currentRD
operator|==
name|regDomain
condition|)
block|{
name|ecode
operator|=
name|HAL_EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Check if EEPROM is configured to allow this; must 	 * be a proper version and the protection bits must 	 * permit re-writing that segment of the EEPROM. 	 */
if|if
condition|(
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_WRITEPROTECT
argument_list|)
condition|)
block|{
name|ecode
operator|=
name|HAL_EEWRITE
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|AH_SUPPORT_WRITE_REGDOMAIN
if|if
condition|(
name|ar5211EepromWrite
argument_list|(
name|ah
argument_list|,
name|AR_EEPROM_REG_DOMAIN
argument_list|,
name|regDomain
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: set regulatory domain to %u (0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|regDomain
argument_list|,
name|regDomain
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_currentRD
operator|=
name|regDomain
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
endif|#
directive|endif
name|ecode
operator|=
name|HAL_EIO
expr_stmt|;
name|bad
label|:
if|if
condition|(
name|status
condition|)
operator|*
name|status
operator|=
name|ecode
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Return the wireless modes (a,b,g,t) supported by hardware.  *  * This value is what is actually supported by the hardware  * and is unaffected by regulatory/country code settings.  *  */
end_comment

begin_function
name|u_int
name|ar5211GetWirelessModes
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|u_int
name|mode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_AMODE
argument_list|)
condition|)
block|{
name|mode
operator|=
name|HAL_MODE_11A
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_TURBO5DISABLE
argument_list|)
condition|)
name|mode
operator||=
name|HAL_MODE_TURBO
operator||
name|HAL_MODE_108A
expr_stmt|;
block|}
if|if
condition|(
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_BMODE
argument_list|)
condition|)
name|mode
operator||=
name|HAL_MODE_11B
expr_stmt|;
return|return
name|mode
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|HAL_BOOL ar5211GetTurboDisable(struct ath_hal *ah) { 	return (AH5211(ah)->ah_turboDisable != 0); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Called if RfKill is supported (according to EEPROM).  Set the interrupt and  * GPIO values so the ISR and can disable RF on a switch signal  */
end_comment

begin_function
name|void
name|ar5211EnableRfKill
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|uint16_t
name|rfsilent
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rfsilent
decl_stmt|;
name|int
name|select
init|=
name|MS
argument_list|(
name|rfsilent
argument_list|,
name|AR_EEPROM_RFSILENT_GPIO_SEL
argument_list|)
decl_stmt|;
name|int
name|polarity
init|=
name|MS
argument_list|(
name|rfsilent
argument_list|,
name|AR_EEPROM_RFSILENT_POLARITY
argument_list|)
decl_stmt|;
comment|/* 	 * Configure the desired GPIO port for input 	 * and enable baseband rf silence. 	 */
name|ar5211GpioCfgInput
argument_list|(
name|ah
argument_list|,
name|select
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BASE
argument_list|,
literal|0x00002000
argument_list|)
expr_stmt|;
comment|/* 	 * If radio disable switch connection to GPIO bit x is enabled 	 * program GPIO interrupt. 	 * If rfkill bit on eeprom is 1, setupeeprommap routine has already 	 * verified that it is a later version of eeprom, it has a place for 	 * rfkill bit and it is set to 1, indicating that GPIO bit x hardware 	 * connection is present. 	 */
name|ar5211GpioSetIntr
argument_list|(
name|ah
argument_list|,
name|select
argument_list|,
operator|(
name|ar5211GpioGet
argument_list|(
name|ah
argument_list|,
name|select
argument_list|)
operator|!=
name|polarity
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Configure GPIO Output lines  */
end_comment

begin_function
name|HAL_BOOL
name|ar5211GpioCfgOutput
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|gpio
parameter_list|,
name|HAL_GPIO_MUX_TYPE
name|type
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|HALASSERT
argument_list|(
name|gpio
operator|<
name|AR_NUM_GPIO
argument_list|)
expr_stmt|;
name|reg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_GPIOCR
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|AR_GPIOCR_0_CR_A
operator|<<
operator|(
name|gpio
operator|*
name|AR_GPIOCR_CR_SHIFT
operator|)
operator|)
expr_stmt|;
name|reg
operator||=
name|AR_GPIOCR_0_CR_A
operator|<<
operator|(
name|gpio
operator|*
name|AR_GPIOCR_CR_SHIFT
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_GPIOCR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Configure GPIO Input lines  */
end_comment

begin_function
name|HAL_BOOL
name|ar5211GpioCfgInput
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|gpio
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|HALASSERT
argument_list|(
name|gpio
operator|<
name|AR_NUM_GPIO
argument_list|)
expr_stmt|;
name|reg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_GPIOCR
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|AR_GPIOCR_0_CR_A
operator|<<
operator|(
name|gpio
operator|*
name|AR_GPIOCR_CR_SHIFT
operator|)
operator|)
expr_stmt|;
name|reg
operator||=
name|AR_GPIOCR_0_CR_N
operator|<<
operator|(
name|gpio
operator|*
name|AR_GPIOCR_CR_SHIFT
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_GPIOCR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Once configured for I/O - set output lines  */
end_comment

begin_function
name|HAL_BOOL
name|ar5211GpioSet
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|gpio
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|HALASSERT
argument_list|(
name|gpio
operator|<
name|AR_NUM_GPIO
argument_list|)
expr_stmt|;
name|reg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_GPIODO
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|gpio
operator|)
expr_stmt|;
name|reg
operator||=
operator|(
name|val
operator|&
literal|1
operator|)
operator|<<
name|gpio
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_GPIODO
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Once configured for I/O - get input lines  */
end_comment

begin_function
name|uint32_t
name|ar5211GpioGet
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|gpio
parameter_list|)
block|{
if|if
condition|(
name|gpio
operator|<
name|AR_NUM_GPIO
condition|)
block|{
name|uint32_t
name|val
init|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_GPIODI
argument_list|)
decl_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|&
name|AR_GPIOD_MASK
operator|)
operator|>>
name|gpio
operator|)
operator|&
literal|0x1
expr_stmt|;
return|return
name|val
return|;
block|}
else|else
block|{
return|return
literal|0xffffffff
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the GPIO 0 Interrupt (gpio is ignored)  */
end_comment

begin_function
name|void
name|ar5211GpioSetIntr
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|gpio
parameter_list|,
name|uint32_t
name|ilevel
parameter_list|)
block|{
name|uint32_t
name|val
init|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_GPIOCR
argument_list|)
decl_stmt|;
comment|/* Clear the bits that we will modify. */
name|val
operator|&=
operator|~
operator|(
name|AR_GPIOCR_INT_SEL0
operator||
name|AR_GPIOCR_INT_SELH
operator||
name|AR_GPIOCR_INT_ENA
operator||
name|AR_GPIOCR_0_CR_A
operator|)
expr_stmt|;
name|val
operator||=
name|AR_GPIOCR_INT_SEL0
operator||
name|AR_GPIOCR_INT_ENA
expr_stmt|;
if|if
condition|(
name|ilevel
condition|)
name|val
operator||=
name|AR_GPIOCR_INT_SELH
expr_stmt|;
comment|/* Don't need to change anything for low level interrupt. */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_GPIOCR
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Change the interrupt mask. */
name|ar5211SetInterrupts
argument_list|(
name|ah
argument_list|,
name|AH5211
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_maskReg
operator||
name|HAL_INT_GPIO
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change the LED blinking pattern to correspond to the connectivity  */
end_comment

begin_function
name|void
name|ar5211SetLedState
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_LED_STATE
name|state
parameter_list|)
block|{
specifier|static
specifier|const
name|uint32_t
name|ledbits
index|[
literal|8
index|]
init|=
block|{
name|AR_PCICFG_LEDCTL_NONE
operator||
name|AR_PCICFG_LEDMODE_PROP
block|,
comment|/* HAL_LED_INIT */
name|AR_PCICFG_LEDCTL_PEND
operator||
name|AR_PCICFG_LEDMODE_PROP
block|,
comment|/* HAL_LED_SCAN */
name|AR_PCICFG_LEDCTL_PEND
operator||
name|AR_PCICFG_LEDMODE_PROP
block|,
comment|/* HAL_LED_AUTH */
name|AR_PCICFG_LEDCTL_ASSOC
operator||
name|AR_PCICFG_LEDMODE_PROP
block|,
comment|/* HAL_LED_ASSOC*/
name|AR_PCICFG_LEDCTL_ASSOC
operator||
name|AR_PCICFG_LEDMODE_PROP
block|,
comment|/* HAL_LED_RUN */
name|AR_PCICFG_LEDCTL_NONE
operator||
name|AR_PCICFG_LEDMODE_RAND
block|,
name|AR_PCICFG_LEDCTL_NONE
operator||
name|AR_PCICFG_LEDMODE_RAND
block|,
name|AR_PCICFG_LEDCTL_NONE
operator||
name|AR_PCICFG_LEDMODE_RAND
block|, 	}
decl_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|)
operator|&
operator|~
operator|(
name|AR_PCICFG_LEDCTL
operator||
name|AR_PCICFG_LEDMODE
operator|)
operator|)
operator||
name|ledbits
index|[
name|state
operator|&
literal|0x7
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change association related fields programmed into the hardware.  * Writing a valid BSSID to the hardware effectively enables the hardware  * to synchronize its TSF to the correct beacons and receive frames coming  * from that BSSID. It is called by the SME JOIN operation.  */
end_comment

begin_function
name|void
name|ar5211WriteAssocid
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|bssid
parameter_list|,
name|uint16_t
name|assocId
parameter_list|)
block|{
name|struct
name|ath_hal_5211
modifier|*
name|ahp
init|=
name|AH5211
argument_list|(
name|ah
argument_list|)
decl_stmt|;
comment|/* XXX save bssid for possible re-use on reset */
name|OS_MEMCPY
argument_list|(
name|ahp
operator|->
name|ah_bssid
argument_list|,
name|bssid
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSS_ID0
argument_list|,
name|LE_READ_4
argument_list|(
name|ahp
operator|->
name|ah_bssid
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSS_ID1
argument_list|,
name|LE_READ_2
argument_list|(
name|ahp
operator|->
name|ah_bssid
operator|+
literal|4
argument_list|)
operator||
operator|(
operator|(
name|assocId
operator|&
literal|0x3fff
operator|)
operator|<<
name|AR_BSS_ID1_AID_S
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the current hardware tsf for stamlme.  */
end_comment

begin_function
name|uint64_t
name|ar5211GetTsf64
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|uint32_t
name|low1
decl_stmt|,
name|low2
decl_stmt|,
name|u32
decl_stmt|;
comment|/* sync multi-word read */
name|low1
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|)
expr_stmt|;
name|u32
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_U32
argument_list|)
expr_stmt|;
name|low2
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|)
expr_stmt|;
if|if
condition|(
name|low2
operator|<
name|low1
condition|)
block|{
comment|/* roll over */
comment|/* 		 * If we are not preempted this will work.  If we are 		 * then we re-reading AR_TSF_U32 does no good as the 		 * low bits will be meaningless.  Likewise reading 		 * L32, U32, U32, then comparing the last two reads 		 * to check for rollover doesn't help if preempted--so 		 * we take this approach as it costs one less PCI 		 * read which can be noticeable when doing things 		 * like timestamping packets in monitor mode. 		 */
name|u32
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|u32
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|low2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the current hardware tsf for stamlme.  */
end_comment

begin_function
name|uint32_t
name|ar5211GetTsf32
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset the current hardware tsf for stamlme  */
end_comment

begin_function
name|void
name|ar5211ResetTsf
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|uint32_t
name|val
init|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_BEACON
argument_list|)
decl_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BEACON
argument_list|,
name|val
operator||
name|AR_BEACON_RESET_TSF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Grab a semi-random value from hardware registers - may not  * change often  */
end_comment

begin_function
name|uint32_t
name|ar5211GetRandomSeed
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|uint32_t
name|nf
decl_stmt|;
name|nf
operator|=
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|25
argument_list|)
argument_list|)
operator|>>
literal|19
operator|)
operator|&
literal|0x1ff
expr_stmt|;
if|if
condition|(
name|nf
operator|&
literal|0x100
condition|)
name|nf
operator|=
literal|0
operator|-
operator|(
operator|(
name|nf
operator|^
literal|0x1ff
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_U32
argument_list|)
operator|^
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|)
operator|^
name|nf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detect if our card is present  */
end_comment

begin_function
name|HAL_BOOL
name|ar5211DetectCardPresent
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|uint16_t
name|macVersion
decl_stmt|,
name|macRev
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
comment|/* 	 * Read the Silicon Revision register and compare that 	 * to what we read at attach time.  If the same, we say 	 * a card/device is present. 	 */
name|v
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_SREV
argument_list|)
operator|&
name|AR_SREV_ID_M
expr_stmt|;
name|macVersion
operator|=
name|v
operator|>>
name|AR_SREV_ID_S
expr_stmt|;
name|macRev
operator|=
name|v
operator|&
name|AR_SREV_REVISION_M
expr_stmt|;
return|return
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|==
name|macVersion
operator|&&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macRev
operator|==
name|macRev
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update MIB Counters  */
end_comment

begin_function
name|void
name|ar5211UpdateMibCounters
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_MIB_STATS
modifier|*
name|stats
parameter_list|)
block|{
name|stats
operator|->
name|ackrcv_bad
operator|+=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ACK_FAIL
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rts_bad
operator|+=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RTS_FAIL
argument_list|)
expr_stmt|;
name|stats
operator|->
name|fcs_bad
operator|+=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_FCS_FAIL
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rts_good
operator|+=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RTS_OK
argument_list|)
expr_stmt|;
name|stats
operator|->
name|beacons
operator|+=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_BEACON_CNT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5211SetSifsTime
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|us
parameter_list|)
block|{
name|struct
name|ath_hal_5211
modifier|*
name|ahp
init|=
name|AH5211
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
name|us
operator|>
name|ath_hal_mac_usec
argument_list|(
name|ah
argument_list|,
literal|0xffff
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: bad SIFS time %u\n"
argument_list|,
name|__func__
argument_list|,
name|us
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_sifstime
operator|=
operator|(
name|u_int
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* restore default handling */
return|return
name|AH_FALSE
return|;
block|}
else|else
block|{
comment|/* convert to system clocks */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_D_GBL_IFS_SIFS
argument_list|,
name|ath_hal_mac_clks
argument_list|(
name|ah
argument_list|,
name|us
argument_list|)
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_slottime
operator|=
name|us
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
block|}
end_function

begin_function
name|u_int
name|ar5211GetSifsTime
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|u_int
name|clks
init|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_D_GBL_IFS_SIFS
argument_list|)
operator|&
literal|0xffff
decl_stmt|;
return|return
name|ath_hal_mac_usec
argument_list|(
name|ah
argument_list|,
name|clks
argument_list|)
return|;
comment|/* convert from system clocks */
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5211SetSlotTime
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|us
parameter_list|)
block|{
name|struct
name|ath_hal_5211
modifier|*
name|ahp
init|=
name|AH5211
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
name|us
operator|<
name|HAL_SLOT_TIME_9
operator|||
name|us
operator|>
name|ath_hal_mac_usec
argument_list|(
name|ah
argument_list|,
literal|0xffff
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: bad slot time %u\n"
argument_list|,
name|__func__
argument_list|,
name|us
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_slottime
operator|=
name|us
expr_stmt|;
comment|/* restore default handling */
return|return
name|AH_FALSE
return|;
block|}
else|else
block|{
comment|/* convert to system clocks */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_D_GBL_IFS_SLOT
argument_list|,
name|ath_hal_mac_clks
argument_list|(
name|ah
argument_list|,
name|us
argument_list|)
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_slottime
operator|=
name|us
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
block|}
end_function

begin_function
name|u_int
name|ar5211GetSlotTime
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|u_int
name|clks
init|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_D_GBL_IFS_SLOT
argument_list|)
operator|&
literal|0xffff
decl_stmt|;
return|return
name|ath_hal_mac_usec
argument_list|(
name|ah
argument_list|,
name|clks
argument_list|)
return|;
comment|/* convert from system clocks */
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5211SetAckTimeout
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|us
parameter_list|)
block|{
name|struct
name|ath_hal_5211
modifier|*
name|ahp
init|=
name|AH5211
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
name|us
operator|>
name|ath_hal_mac_usec
argument_list|(
name|ah
argument_list|,
name|MS
argument_list|(
literal|0xffffffff
argument_list|,
name|AR_TIME_OUT_ACK
argument_list|)
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: bad ack timeout %u\n"
argument_list|,
name|__func__
argument_list|,
name|us
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_acktimeout
operator|=
operator|(
name|u_int
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* restore default handling */
return|return
name|AH_FALSE
return|;
block|}
else|else
block|{
comment|/* convert to system clocks */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_TIME_OUT
argument_list|,
name|AR_TIME_OUT_ACK
argument_list|,
name|ath_hal_mac_clks
argument_list|(
name|ah
argument_list|,
name|us
argument_list|)
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_acktimeout
operator|=
name|us
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
block|}
end_function

begin_function
name|u_int
name|ar5211GetAckTimeout
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|u_int
name|clks
init|=
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TIME_OUT
argument_list|)
argument_list|,
name|AR_TIME_OUT_ACK
argument_list|)
decl_stmt|;
return|return
name|ath_hal_mac_usec
argument_list|(
name|ah
argument_list|,
name|clks
argument_list|)
return|;
comment|/* convert from system clocks */
block|}
end_function

begin_function
name|u_int
name|ar5211GetAckCTSRate
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
operator|(
operator|(
name|AH5211
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_staId1Defaults
operator|&
name|AR_STA_ID1_ACKCTS_6MB
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5211SetAckCTSRate
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|high
parameter_list|)
block|{
name|struct
name|ath_hal_5211
modifier|*
name|ahp
init|=
name|AH5211
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
name|high
condition|)
block|{
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|AR_STA_ID1_ACKCTS_6MB
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_staId1Defaults
operator|&=
operator|~
name|AR_STA_ID1_ACKCTS_6MB
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|AR_STA_ID1_ACKCTS_6MB
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_staId1Defaults
operator||=
name|AR_STA_ID1_ACKCTS_6MB
expr_stmt|;
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5211SetCTSTimeout
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|us
parameter_list|)
block|{
name|struct
name|ath_hal_5211
modifier|*
name|ahp
init|=
name|AH5211
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
name|us
operator|>
name|ath_hal_mac_usec
argument_list|(
name|ah
argument_list|,
name|MS
argument_list|(
literal|0xffffffff
argument_list|,
name|AR_TIME_OUT_CTS
argument_list|)
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: bad cts timeout %u\n"
argument_list|,
name|__func__
argument_list|,
name|us
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_ctstimeout
operator|=
operator|(
name|u_int
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* restore default handling */
return|return
name|AH_FALSE
return|;
block|}
else|else
block|{
comment|/* convert to system clocks */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_TIME_OUT
argument_list|,
name|AR_TIME_OUT_CTS
argument_list|,
name|ath_hal_mac_clks
argument_list|(
name|ah
argument_list|,
name|us
argument_list|)
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_ctstimeout
operator|=
name|us
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
block|}
end_function

begin_function
name|u_int
name|ar5211GetCTSTimeout
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|u_int
name|clks
init|=
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TIME_OUT
argument_list|)
argument_list|,
name|AR_TIME_OUT_CTS
argument_list|)
decl_stmt|;
return|return
name|ath_hal_mac_usec
argument_list|(
name|ah
argument_list|,
name|clks
argument_list|)
return|;
comment|/* convert from system clocks */
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5211SetDecompMask
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint16_t
name|keyidx
parameter_list|,
name|int
name|en
parameter_list|)
block|{
comment|/* nothing to do */
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|void
name|ar5211SetCoverageClass
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint8_t
name|coverageclass
parameter_list|,
name|int
name|now
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * Control Adaptive Noise Immunity Parameters  */
end_comment

begin_function
name|HAL_BOOL
name|ar5211AniControl
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_ANI_CMD
name|cmd
parameter_list|,
name|int
name|param
parameter_list|)
block|{
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_function
name|void
name|ar5211AniPoll
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ar5211RxMonitor
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_NODE_STATS
modifier|*
name|stats
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ar5211MibEvent
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_NODE_STATS
modifier|*
name|stats
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * Get the rssi of frame curently being received.  */
end_comment

begin_function
name|uint32_t
name|ar5211GetCurRssi
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CURRENT_RSSI
argument_list|)
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_function
name|u_int
name|ar5211GetDefAntenna
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_DEF_ANTENNA
argument_list|)
operator|&
literal|0x7
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ar5211SetDefAntenna
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|antenna
parameter_list|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DEF_ANTENNA
argument_list|,
operator|(
name|antenna
operator|&
literal|0x7
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|HAL_ANT_SETTING
name|ar5211GetAntennaSwitch
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|AH5211
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diversityControl
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5211SetAntennaSwitch
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_ANT_SETTING
name|settings
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
decl_stmt|;
if|if
condition|(
name|chan
operator|==
name|AH_NULL
condition|)
block|{
name|AH5211
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diversityControl
operator|=
name|settings
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
return|return
name|ar5211SetAntennaSwitchInternal
argument_list|(
name|ah
argument_list|,
name|settings
argument_list|,
name|chan
argument_list|)
return|;
block|}
end_function

begin_function
name|HAL_STATUS
name|ar5211GetCapability
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CAPABILITY_TYPE
name|type
parameter_list|,
name|uint32_t
name|capability
parameter_list|,
name|uint32_t
modifier|*
name|result
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|HAL_CAP_CIPHER
case|:
comment|/* cipher handled in hardware */
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
name|HAL_CIPHER_AES_OCB
case|:
case|case
name|HAL_CIPHER_WEP
case|:
case|case
name|HAL_CIPHER_CLR
case|:
return|return
name|HAL_OK
return|;
default|default:
return|return
name|HAL_ENOTSUPP
return|;
block|}
default|default:
return|return
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|type
argument_list|,
name|capability
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5211SetCapability
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CAPABILITY_TYPE
name|type
parameter_list|,
name|uint32_t
name|capability
parameter_list|,
name|uint32_t
name|setting
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|HAL_CAP_DIAG
case|:
comment|/* hardware diagnostic support */
comment|/* 		 * NB: could split this up into virtual capabilities, 		 *     (e.g. 1 => ACK, 2 => CTS, etc.) but it hardly 		 *     seems worth the additional complexity. 		 */
ifdef|#
directive|ifdef
name|AH_DEBUG
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diagreg
operator|=
name|setting
expr_stmt|;
else|#
directive|else
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diagreg
operator|=
name|setting
operator|&
literal|0x6
expr_stmt|;
comment|/* ACK+CTS */
endif|#
directive|endif
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diagreg
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
default|default:
return|return
name|ath_hal_setcapability
argument_list|(
name|ah
argument_list|,
name|type
argument_list|,
name|capability
argument_list|,
name|setting
argument_list|,
name|status
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5211GetDiagState
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|request
parameter_list|,
specifier|const
name|void
modifier|*
name|args
parameter_list|,
name|uint32_t
name|argsize
parameter_list|,
name|void
modifier|*
modifier|*
name|result
parameter_list|,
name|uint32_t
modifier|*
name|resultsize
parameter_list|)
block|{
name|struct
name|ath_hal_5211
modifier|*
name|ahp
init|=
name|AH5211
argument_list|(
name|ah
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|ahp
expr_stmt|;
if|if
condition|(
name|ath_hal_getdiagstate
argument_list|(
name|ah
argument_list|,
name|request
argument_list|,
name|args
argument_list|,
name|argsize
argument_list|,
name|result
argument_list|,
name|resultsize
argument_list|)
condition|)
return|return
name|AH_TRUE
return|;
switch|switch
condition|(
name|request
condition|)
block|{
case|case
name|HAL_DIAG_EEPROM
case|:
return|return
name|ath_hal_eepromDiag
argument_list|(
name|ah
argument_list|,
name|request
argument_list|,
name|args
argument_list|,
name|argsize
argument_list|,
name|result
argument_list|,
name|resultsize
argument_list|)
return|;
case|case
name|HAL_DIAG_RFGAIN
case|:
operator|*
name|result
operator|=
operator|&
name|ahp
operator|->
name|ah_gainValues
expr_stmt|;
operator|*
name|resultsize
operator|=
sizeof|sizeof
argument_list|(
name|GAIN_VALUES
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_DIAG_RFGAIN_CURSTEP
case|:
operator|*
name|result
operator|=
name|__DECONST
argument_list|(
name|void
operator|*
argument_list|,
name|ahp
operator|->
name|ah_gainValues
operator|.
name|currStep
argument_list|)
expr_stmt|;
operator|*
name|resultsize
operator|=
operator|(
operator|*
name|result
operator|==
name|AH_NULL
operator|)
condition|?
literal|0
else|:
sizeof|sizeof
argument_list|(
name|GAIN_OPTIMIZATION_STEP
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Return what percentage of the extension channel is busy.  * This is always disabled for AR5211 series NICs.  */
end_comment

begin_function
name|uint32_t
name|ar5211Get11nExtBusy
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * There's no channel survey support for the AR5211.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5211GetMibCycleCounts
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_SURVEY_SAMPLE
modifier|*
name|hsample
parameter_list|)
block|{
return|return
operator|(
name|AH_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ar5211SetChainMasks
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|txchainmask
parameter_list|,
name|uint32_t
name|rxchainmask
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ar5211EnableDfs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_PHYERR_PARAM
modifier|*
name|pe
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ar5211GetDfsThresh
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_PHYERR_PARAM
modifier|*
name|pe
parameter_list|)
block|{ }
end_function

end_unit

