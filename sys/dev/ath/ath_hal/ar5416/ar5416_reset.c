begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2002-2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_devid.h"
end_include

begin_include
include|#
directive|include
file|"ah_eeprom_v14.h"
end_include

begin_include
include|#
directive|include
file|"ah_eeprom_v4k.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416phy.h"
end_include

begin_comment
comment|/* Eeprom versioning macros. Returns true if the version is equal or newer than the ver specified */
end_comment

begin_define
define|#
directive|define
name|EEP_MINOR
parameter_list|(
name|_ah
parameter_list|)
define|\
value|(AH_PRIVATE(_ah)->ah_eeversion& AR5416_EEP_VER_MINOR_MASK)
end_define

begin_define
define|#
directive|define
name|IS_EEP_MINOR_V2
parameter_list|(
name|_ah
parameter_list|)
value|(EEP_MINOR(_ah)>= AR5416_EEP_MINOR_VER_2)
end_define

begin_define
define|#
directive|define
name|IS_EEP_MINOR_V3
parameter_list|(
name|_ah
parameter_list|)
value|(EEP_MINOR(_ah)>= AR5416_EEP_MINOR_VER_3)
end_define

begin_comment
comment|/* Additional Time delay to wait after activiting the Base band */
end_comment

begin_define
define|#
directive|define
name|BASE_ACTIVATE_DELAY
value|100
end_define

begin_comment
comment|/* 100 usec */
end_comment

begin_define
define|#
directive|define
name|PLL_SETTLE_DELAY
value|300
end_define

begin_comment
comment|/* 300 usec */
end_comment

begin_define
define|#
directive|define
name|RTC_PLL_SETTLE_DELAY
value|1000
end_define

begin_comment
comment|/* 1 ms     */
end_comment

begin_function_decl
specifier|static
name|void
name|ar5416InitDMA
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5416InitBB
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5416InitIMR
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_OPMODE
name|opmode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5416InitQoS
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5416InitUserSettings
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5416SetTransmitPower
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|uint16_t
modifier|*
name|rfXpdGain
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static HAL_BOOL	ar5416ChannelChange(struct ath_hal *, const struct ieee80211_channel *);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ar5416SetDeltaSlope
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5416SetResetPowerOn
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5416SetReset
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5416InitPLL
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5416SetBoardValues
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5416SetPowerPerRateTable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ar5416eeprom
modifier|*
name|pEepData
parameter_list|,
name|struct
name|ar5416eeprom_4k
modifier|*
name|pEepData4k
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|int16_t
modifier|*
name|ratesArray
parameter_list|,
name|uint16_t
name|cfgCtl
parameter_list|,
name|uint16_t
name|AntennaReduction
parameter_list|,
name|uint16_t
name|twiceMaxRegulatoryPower
parameter_list|,
name|uint16_t
name|powerLimit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5416SetPowerCalTable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ar5416eeprom
modifier|*
name|pEepData
parameter_list|,
name|struct
name|ar5416eeprom_4k
modifier|*
name|pEepData4k
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|int16_t
modifier|*
name|pTxPowerIndexOffset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|ar5416GetMaxEdgePower
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint16_t
name|freq
parameter_list|,
name|CAL_CTL_EDGES
modifier|*
name|pRdEdgesPower
parameter_list|,
name|HAL_BOOL
name|is2GHz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5416GetTargetPowers
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|CAL_TARGET_POWER_HT
modifier|*
name|powInfo
parameter_list|,
name|uint16_t
name|numChannels
parameter_list|,
name|CAL_TARGET_POWER_HT
modifier|*
name|pNewPower
parameter_list|,
name|uint16_t
name|numRates
parameter_list|,
name|HAL_BOOL
name|isHt40Target
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5416GetTargetPowersLeg
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|CAL_TARGET_POWER_LEG
modifier|*
name|powInfo
parameter_list|,
name|uint16_t
name|numChannels
parameter_list|,
name|CAL_TARGET_POWER_LEG
modifier|*
name|pNewPower
parameter_list|,
name|uint16_t
name|numRates
parameter_list|,
name|HAL_BOOL
name|isExtTarget
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int16_t
name|interpolate
parameter_list|(
name|uint16_t
name|target
parameter_list|,
name|uint16_t
name|srcLeft
parameter_list|,
name|uint16_t
name|srcRight
parameter_list|,
name|int16_t
name|targetLeft
parameter_list|,
name|int16_t
name|targetRight
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5416Set11nRegs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5416GetGainBoundariesAndPdadcs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|CAL_DATA_PER_FREQ
modifier|*
name|pRawDataSet
parameter_list|,
name|CAL_DATA_PER_FREQ_4K
modifier|*
name|pRawDataSet4k
parameter_list|,
name|uint8_t
modifier|*
name|bChans
parameter_list|,
name|uint16_t
name|availPiers
parameter_list|,
name|uint16_t
name|tPdGainOverlap
parameter_list|,
name|int16_t
modifier|*
name|pMinCalPower
parameter_list|,
name|uint16_t
modifier|*
name|pPdGainBoundaries
parameter_list|,
name|uint8_t
modifier|*
name|pPDADCValues
parameter_list|,
name|uint16_t
name|numXpdGains
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|getLowerUpperIndex
parameter_list|(
name|uint8_t
name|target
parameter_list|,
name|uint8_t
modifier|*
name|pList
parameter_list|,
name|uint16_t
name|listSize
parameter_list|,
name|uint16_t
modifier|*
name|indexL
parameter_list|,
name|uint16_t
modifier|*
name|indexR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5416FillVpdTable
parameter_list|(
name|uint8_t
name|pwrMin
parameter_list|,
name|uint8_t
name|pwrMax
parameter_list|,
name|uint8_t
modifier|*
name|pPwrList
parameter_list|,
name|uint8_t
modifier|*
name|pVpdList
parameter_list|,
name|uint16_t
name|numIntercepts
parameter_list|,
name|uint8_t
modifier|*
name|pRetVpdList
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Places the device in and out of reset and then places sane  * values in the registers based on EEPROM config, initialization  * vectors (as determined by the mode), and station configuration  *  * bChannelChange is used to preserve DMA/PCU registers across  * a HW Reset during channel change.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5416Reset
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_OPMODE
name|opmode
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|HAL_BOOL
name|bChannelChange
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) / sizeof (a[0]))
define|#
directive|define
name|FAIL
parameter_list|(
name|_code
parameter_list|)
value|do { ecode = _code; goto bad; } while (0)
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
decl_stmt|;
name|uint32_t
name|saveDefAntenna
decl_stmt|,
name|saveLedState
decl_stmt|;
name|uint32_t
name|macStaId1
decl_stmt|;
name|uint16_t
name|rfXpdGain
index|[
literal|2
index|]
decl_stmt|;
name|HAL_STATUS
name|ecode
decl_stmt|;
name|uint32_t
name|powerVal
decl_stmt|,
name|rssiThrReg
decl_stmt|;
name|uint32_t
name|ackTpcPow
decl_stmt|,
name|ctsTpcPow
decl_stmt|,
name|chirpTpcPow
decl_stmt|;
name|int
name|i
decl_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET
argument_list|,
name|bChannelChange
argument_list|)
expr_stmt|;
comment|/* Bring out of sleep mode */
if|if
condition|(
operator|!
name|ar5416SetPowerMode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: chip did not wakeup\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Map public channel to private. 	 */
name|ichan
operator|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ichan
operator|==
name|AH_NULL
condition|)
name|FAIL
argument_list|(
name|HAL_EINVAL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opmode
condition|)
block|{
case|case
name|HAL_M_STA
case|:
case|case
name|HAL_M_IBSS
case|:
case|case
name|HAL_M_HOSTAP
case|:
case|case
name|HAL_M_MONITOR
case|:
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid operating mode %u\n"
argument_list|,
name|__func__
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EINVAL
argument_list|)
expr_stmt|;
break|break;
block|}
name|HALASSERT
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeversion
operator|>=
name|AR_EEPROM_VER14_1
argument_list|)
expr_stmt|;
comment|/* XXX Turn on fast channel change for 5416 */
comment|/* 	 * Preserve the bmiss rssi threshold and count threshold 	 * across resets 	 */
name|rssiThrReg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RSSI_THR
argument_list|)
expr_stmt|;
comment|/* If reg is zero, first time thru set to default val */
if|if
condition|(
name|rssiThrReg
operator|==
literal|0
condition|)
name|rssiThrReg
operator|=
name|INIT_RSSI_THR
expr_stmt|;
comment|/* 	 * Preserve the antenna on a channel change 	 */
name|saveDefAntenna
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_DEF_ANTENNA
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveDefAntenna
operator|==
literal|0
condition|)
comment|/* XXX magic constants */
name|saveDefAntenna
operator|=
literal|1
expr_stmt|;
comment|/* Save hardware flag before chip reset clears the register */
name|macStaId1
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|)
operator|&
operator|(
name|AR_STA_ID1_BASE_RATE_11B
operator||
name|AR_STA_ID1_USE_DEFANT
operator|)
expr_stmt|;
comment|/* Save led state from pci config register */
name|saveLedState
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_MAC_LED
argument_list|)
operator|&
operator|(
name|AR_MAC_LED_ASSOC
operator||
name|AR_MAC_LED_MODE
operator||
name|AR_MAC_LED_BLINK_THRESH_SEL
operator||
name|AR_MAC_LED_BLINK_SLOW
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar5416ChipReset
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: chip reset failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
comment|/* Restore bmiss rssi& count thresholds */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RSSI_THR
argument_list|,
name|rssiThrReg
argument_list|)
expr_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_LINE
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_writeIni
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* Setup 11n MAC/Phy mode registers */
name|ar5416Set11nRegs
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_LINE
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|">>>2 %s: AR_PHY_DAG_CTRLCCK=0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_DAG_CTRLCCK
argument_list|)
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|">>>2 %s: AR_PHY_ADC_CTL=0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ADC_CTL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the mute mask to the correct default */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyRev
operator|>=
name|AR_PHY_CHIP_ID_REV_2
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_SEQ_MASK
argument_list|,
literal|0x0000000F
argument_list|)
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyRev
operator|>=
name|AR_PHY_CHIP_ID_REV_3
condition|)
block|{
comment|/* Clear reg to alllow RX_CLEAR line debug */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BLUETOOTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyRev
operator|>=
name|AR_PHY_CHIP_ID_REV_4
condition|)
block|{
ifdef|#
directive|ifdef
name|notyet
comment|/* Enable burst prefetch for the data queues */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_D_FPCTL
argument_list|,
operator|...
argument_list|)
expr_stmt|;
comment|/* Enable double-buffering */
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_TXCFG
argument_list|,
name|AR_TXCFG_DBL_BUF_DIS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Set ADC/DAC select values */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SLEEP_SCAL
argument_list|,
literal|0x0e
argument_list|)
expr_stmt|;
if|if
condition|(
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rx_chainmask
operator|==
literal|0x5
operator|||
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tx_chainmask
operator|==
literal|0x5
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ANALOG_SWAP
argument_list|,
name|AR_PHY_SWAP_ALT_CHAIN
argument_list|)
expr_stmt|;
comment|/* Setup Chain Masks */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RX_CHAINMASK
argument_list|,
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rx_chainmask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CAL_CHAINMASK
argument_list|,
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rx_chainmask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_SELFGEN_MASK
argument_list|,
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tx_chainmask
argument_list|)
expr_stmt|;
comment|/* Setup the transmit power values. */
if|if
condition|(
operator|!
name|ar5416SetTransmitPower
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|rfXpdGain
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: error init'ing transmit power\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
comment|/* Write the analog registers */
if|if
condition|(
operator|!
name|ahp
operator|->
name|ah_rfHal
operator|->
name|setRfRegs
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|?
literal|2
else|:
literal|1
argument_list|,
name|rfXpdGain
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: ar5212SetRfRegs failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
comment|/* Write delta slope for OFDM enabled modes (A, G, Turbo) */
if|if
condition|(
name|IEEE80211_IS_CHAN_OFDM
argument_list|(
name|chan
argument_list|)
operator|||
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|chan
argument_list|)
condition|)
name|ar5416SetDeltaSlope
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_spurMitigate
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* Setup board specific options for EEPROM version 3 */
if|if
condition|(
operator|!
name|ar5416SetBoardValues
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: error setting board options\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_LINE
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID0
argument_list|,
name|LE_READ_4
argument_list|(
name|ahp
operator|->
name|ah_macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|LE_READ_2
argument_list|(
name|ahp
operator|->
name|ah_macaddr
operator|+
literal|4
argument_list|)
operator||
name|macStaId1
operator||
name|AR_STA_ID1_RTS_USE_DEF
operator||
name|ahp
operator|->
name|ah_staId1Defaults
argument_list|)
expr_stmt|;
name|ar5212SetOperatingMode
argument_list|(
name|ah
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
comment|/* Set Venice BSSID mask according to current state */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSSMSKL
argument_list|,
name|LE_READ_4
argument_list|(
name|ahp
operator|->
name|ah_bssidmask
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSSMSKU
argument_list|,
name|LE_READ_2
argument_list|(
name|ahp
operator|->
name|ah_bssidmask
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore previous led state */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MAC_LED
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_MAC_LED
argument_list|)
operator||
name|saveLedState
argument_list|)
expr_stmt|;
comment|/* Restore previous antenna */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DEF_ANTENNA
argument_list|,
name|saveDefAntenna
argument_list|)
expr_stmt|;
comment|/* then our BSSID */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSS_ID0
argument_list|,
name|LE_READ_4
argument_list|(
name|ahp
operator|->
name|ah_bssid
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSS_ID1
argument_list|,
name|LE_READ_2
argument_list|(
name|ahp
operator|->
name|ah_bssid
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore bmiss rssi& count thresholds */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RSSI_THR
argument_list|,
name|ahp
operator|->
name|ah_rssiThr
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_ISR
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
comment|/* cleared on write */
if|if
condition|(
operator|!
name|ar5212SetChannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_LINE
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* Set 1:1 QCU to DCU mapping for all queues */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR_NUM_DCU
condition|;
name|i
operator|++
control|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DQCUMASK
argument_list|(
name|i
argument_list|)
argument_list|,
literal|1
operator|<<
name|i
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_intrTxqs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halTotalQueues
condition|;
name|i
operator|++
control|)
name|ar5212ResetTxQueue
argument_list|(
name|ah
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ar5416InitIMR
argument_list|(
name|ah
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
name|ar5212SetCoverageClass
argument_list|(
name|ah
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_coverageClass
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ar5416InitQoS
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ar5416InitUserSettings
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 	 * disable seq number generation in hw 	 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|)
operator||
name|AR_STA_ID1_PRESERVE_SEQNUM
argument_list|)
expr_stmt|;
name|ar5416InitDMA
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 	 * program OBS bus to see MAC interrupts 	 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_OBS
argument_list|,
literal|8
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AR5416_INT_MITIGATION
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MIRT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_RIMT
argument_list|,
name|AR_RIMT_LAST
argument_list|,
literal|500
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_RIMT
argument_list|,
name|AR_RIMT_FIRST
argument_list|,
literal|2000
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ar5416InitBB
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* Setup compression registers */
name|ar5212SetCompRegs
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* XXX not needed? */
comment|/* 	 * 5416 baseband will check the per rate power table 	 * and select the lower of the two 	 */
name|ackTpcPow
operator|=
literal|63
expr_stmt|;
name|ctsTpcPow
operator|=
literal|63
expr_stmt|;
name|chirpTpcPow
operator|=
literal|63
expr_stmt|;
name|powerVal
operator|=
name|SM
argument_list|(
name|ackTpcPow
argument_list|,
name|AR_TPC_ACK
argument_list|)
operator||
name|SM
argument_list|(
name|ctsTpcPow
argument_list|,
name|AR_TPC_CTS
argument_list|)
operator||
name|SM
argument_list|(
name|chirpTpcPow
argument_list|,
name|AR_TPC_CHIRP
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TPC
argument_list|,
name|powerVal
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar5416InitCal
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
name|FAIL
argument_list|(
name|HAL_ESELFTEST
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
operator|=
name|opmode
expr_stmt|;
comment|/* record operating mode */
if|if
condition|(
name|bChannelChange
operator|&&
operator|!
name|IEEE80211_IS_CHAN_DFS
argument_list|(
name|chan
argument_list|)
condition|)
name|chan
operator|->
name|ic_state
operator|&=
operator|~
name|IEEE80211_CHANSTATE_CWINT
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s: done\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_DONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
name|bad
label|:
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_DONE
argument_list|,
name|ecode
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|AH_NULL
condition|)
operator|*
name|status
operator|=
name|ecode
expr_stmt|;
return|return
name|AH_FALSE
return|;
undef|#
directive|undef
name|FAIL
undef|#
directive|undef
name|N
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * This channel change evaluates whether the selected hardware can  * perform a synthesizer-only channel change (no reset).  If the  * TX is not stopped, or the RFBus cannot be granted in the given  * time, the function returns false as a reset is necessary  */
end_comment

begin_comment
unit|HAL_BOOL ar5416ChannelChange(struct ath_hal *ah, const structu ieee80211_channel *chan) { 	uint32_t       ulCount; 	uint32_t   data, synthDelay, qnum; 	uint16_t   rfXpdGain[4]; 	struct ath_hal_5212 *ahp = AH5212(ah); 	HAL_CHANNEL_INTERNAL *ichan;
comment|/* 	 * Map public channel to private. 	 */
end_comment

begin_comment
unit|ichan = ath_hal_checkchannel(ah, chan);
comment|/* TX must be stopped or RF Bus grant will not work */
end_comment

begin_comment
unit|for (qnum = 0; qnum< AH_PRIVATE(ah)->ah_caps.halTotalQueues; qnum++) { 		if (ar5212NumTxPending(ah, qnum)) { 			HALDEBUG(ah, HAL_DEBUG_ANY, 			    "%s: frames pending on queue %d\n", __func__, qnum); 			return AH_FALSE; 		} 	}
comment|/* 	 * Kill last Baseband Rx Frame - Request analog bus grant 	 */
end_comment

begin_comment
unit|OS_REG_WRITE(ah, AR_PHY_RFBUS_REQ, AR_PHY_RFBUS_REQ_REQUEST); 	if (!ath_hal_wait(ah, AR_PHY_RFBUS_GNT, AR_PHY_RFBUS_GRANT_EN, AR_PHY_RFBUS_GRANT_EN)) { 		HALDEBUG(ah, HAL_DEBUG_ANY, "%s: could not kill baseband rx\n", 		    __func__); 		return AH_FALSE; 	}  	ar5416Set11nRegs(ah, chan);
comment|/* NB: setup 5416-specific regs */
end_comment

begin_comment
comment|/* Change the synth */
end_comment

begin_comment
unit|if (!ar5212SetChannel(ah, chan)) 		return AH_FALSE;
comment|/* Setup the transmit power values. */
end_comment

begin_comment
unit|if (!ar5416SetTransmitPower(ah, chan, rfXpdGain)) { 		HALDEBUG(ah, HAL_DEBUG_ANY, 		    "%s: error init'ing transmit power\n", __func__); 		return AH_FALSE; 	}
comment|/* 	 * Wait for the frequency synth to settle (synth goes on 	 * via PHY_ACTIVE_EN).  Read the phy active delay register. 	 * Value is in 100ns increments. 	 */
end_comment

begin_comment
unit|data = OS_REG_READ(ah, AR_PHY_RX_DELAY)& AR_PHY_RX_DELAY_DELAY; 	if (IS_CHAN_CCK(ichan)) { 		synthDelay = (4 * data) / 22; 	} else { 		synthDelay = data / 10; 	}  	OS_DELAY(synthDelay + BASE_ACTIVATE_DELAY);
comment|/* Release the RFBus Grant */
end_comment

begin_comment
unit|OS_REG_WRITE(ah, AR_PHY_RFBUS_REQ, 0);
comment|/* Write delta slope for OFDM enabled modes (A, G, Turbo) */
end_comment

begin_comment
unit|if (IEEE80211_IS_CHAN_OFDM(ichan)|| IEEE80211_IS_CHAN_HT(chan)) { 		HALASSERT(AH_PRIVATE(ah)->ah_eeversion>= AR_EEPROM_VER5_3); 		ar5212SetSpurMitigation(ah, chan); 		ar5416SetDeltaSlope(ah, chan); 	}
comment|/* XXX spur mitigation for Melin */
end_comment

begin_endif
unit|if (!IEEE80211_IS_CHAN_DFS(chan))  		chan->ic_state&= ~IEEE80211_CHANSTATE_CWINT;  	ichan->channel_time = 0; 	ichan->tsf_last = ar5212GetTsf64(ah); 	ar5212TxEnable(ah, AH_TRUE); 	return AH_TRUE; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ar5416InitDMA
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
comment|/* 	 * set AHB_MODE not to do cacheline prefetches 	 */
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_AHB_MODE
argument_list|,
name|AR_AHB_PREFETCH_RD_EN
argument_list|)
expr_stmt|;
comment|/* 	 * let mac dma reads be in 128 byte chunks 	 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TXCFG
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TXCFG
argument_list|)
operator|&
operator|~
name|AR_TXCFG_DMASZ_MASK
operator|)
operator||
name|AR_TXCFG_DMASZ_128B
argument_list|)
expr_stmt|;
comment|/* 	 * let mac dma writes be in 128 byte chunks 	 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RXCFG
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RXCFG
argument_list|)
operator|&
operator|~
name|AR_RXCFG_DMASZ_MASK
operator|)
operator||
name|AR_RXCFG_DMASZ_128B
argument_list|)
expr_stmt|;
comment|/* XXX restore TX trigger level */
comment|/* 	 * Setup receive FIFO threshold to hold off TX activities 	 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RXFIFO_CFG
argument_list|,
literal|0x200
argument_list|)
expr_stmt|;
comment|/* 	 * reduce the number of usable entries in PCU TXBUF to avoid 	 * wrap around. 	 */
if|if
condition|(
name|AR_SREV_KITE
argument_list|(
name|ah
argument_list|)
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCU_TXBUF_CTRL
argument_list|,
name|AR_9285_PCU_TXBUF_CTRL_USABLE_SIZE
argument_list|)
expr_stmt|;
else|else
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCU_TXBUF_CTRL
argument_list|,
name|AR_PCU_TXBUF_CTRL_USABLE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar5416InitBB
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|uint32_t
name|synthDelay
decl_stmt|;
comment|/* 	 * Wait for the frequency synth to settle (synth goes on 	 * via AR_PHY_ACTIVE_EN).  Read the phy active delay register. 	 * Value is in 100ns increments. 	  */
name|synthDelay
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RX_DELAY
argument_list|)
operator|&
name|AR_PHY_RX_DELAY_DELAY
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|synthDelay
operator|=
operator|(
literal|4
operator|*
name|synthDelay
operator|)
operator|/
literal|22
expr_stmt|;
block|}
else|else
block|{
name|synthDelay
operator|/=
literal|10
expr_stmt|;
block|}
comment|/* Turn on PLL on 5416 */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s %s channel\n"
argument_list|,
name|__func__
argument_list|,
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|?
literal|"5GHz"
else|:
literal|"2GHz"
argument_list|)
expr_stmt|;
name|ar5416InitPLL
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* Activate the PHY (includes baseband activate and synthesizer on) */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ACTIVE
argument_list|,
name|AR_PHY_ACTIVE_EN
argument_list|)
expr_stmt|;
comment|/*  	 * If the AP starts the calibration before the base band timeout 	 * completes  we could get rx_clear false triggering.  Add an 	 * extra BASE_ACTIVATE_DELAY usecs to ensure this condition 	 * does not happen. 	 */
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|OS_DELAY
argument_list|(
operator|(
name|synthDelay
operator|<<
literal|1
operator|)
operator|+
name|BASE_ACTIVATE_DELAY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|OS_DELAY
argument_list|(
operator|(
name|synthDelay
operator|<<
literal|2
operator|)
operator|+
name|BASE_ACTIVATE_DELAY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_DELAY
argument_list|(
name|synthDelay
operator|+
name|BASE_ACTIVATE_DELAY
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ar5416InitIMR
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_OPMODE
name|opmode
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
comment|/* 	 * Setup interrupt handling.  Note that ar5212ResetTxQueue 	 * manipulates the secondary IMR's as queues are enabled 	 * and disabled.  This is done with RMW ops to insure the 	 * settings we make here are preserved. 	 */
name|ahp
operator|->
name|ah_maskReg
operator|=
name|AR_IMR_TXERR
operator||
name|AR_IMR_TXURN
operator||
name|AR_IMR_RXERR
operator||
name|AR_IMR_RXORN
operator||
name|AR_IMR_BCNMISC
expr_stmt|;
ifdef|#
directive|ifdef
name|AR5416_INT_MITIGATION
name|ahp
operator|->
name|ah_maskReg
operator||=
name|AR_IMR_TXINTM
operator||
name|AR_IMR_RXINTM
operator||
name|AR_IMR_TXMINTR
operator||
name|AR_IMR_RXMINTR
expr_stmt|;
else|#
directive|else
name|ahp
operator|->
name|ah_maskReg
operator||=
name|AR_IMR_TXOK
operator||
name|AR_IMR_RXOK
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|opmode
operator|==
name|HAL_M_HOSTAP
condition|)
name|ahp
operator|->
name|ah_maskReg
operator||=
name|AR_IMR_MIB
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR
argument_list|,
name|ahp
operator|->
name|ah_maskReg
argument_list|)
expr_stmt|;
comment|/* Enable bus errors that are OR'd to set the HIUERR bit */
if|#
directive|if
literal|0
block|OS_REG_WRITE(ah, AR_IMR_S2,  	    	OS_REG_READ(ah, AR_IMR_S2) | AR_IMR_S2_GTT | AR_IMR_S2_CST);
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|ar5416InitQoS
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
comment|/* QoS support */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QOS_CONTROL
argument_list|,
literal|0x100aa
argument_list|)
expr_stmt|;
comment|/* XXX magic */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QOS_SELECT
argument_list|,
literal|0x3210
argument_list|)
expr_stmt|;
comment|/* XXX magic */
comment|/* Turn on NOACK Support for QoS packets */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_NOACK
argument_list|,
name|SM
argument_list|(
literal|2
argument_list|,
name|AR_NOACK_2BIT_VALUE
argument_list|)
operator||
name|SM
argument_list|(
literal|5
argument_list|,
name|AR_NOACK_BIT_OFFSET
argument_list|)
operator||
name|SM
argument_list|(
literal|0
argument_list|,
name|AR_NOACK_BYTE_OFFSET
argument_list|)
argument_list|)
expr_stmt|;
comment|/*     	 * initialize TXOP for all TIDs     	 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TXOP_X
argument_list|,
name|AR_TXOP_X_VAL
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TXOP_0_3
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TXOP_4_7
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TXOP_8_11
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TXOP_12_15
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar5416InitUserSettings
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
comment|/* Restore user-specified settings */
if|if
condition|(
name|ahp
operator|->
name|ah_miscMode
operator|!=
literal|0
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MISC_MODE
argument_list|,
name|ahp
operator|->
name|ah_miscMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_sifstime
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ar5212SetSifsTime
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_sifstime
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_slottime
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ar5212SetSlotTime
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_slottime
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_acktimeout
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ar5212SetAckTimeout
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_acktimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_ctstimeout
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ar5212SetCTSTimeout
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_ctstimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diagreg
operator|!=
literal|0
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diagreg
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX Todo */
block|if (ahp->ah_globaltxtimeout != (u_int) -1)         	ar5416SetGlobalTxTimeout(ah, ahp->ah_globaltxtimeout);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Places the hardware into reset and then pulls it out of reset  */
end_comment

begin_function
name|HAL_BOOL
name|ar5416ChipReset
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_CHIPRESET
argument_list|,
name|chan
condition|?
name|chan
operator|->
name|ic_freq
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Warm reset is optimistic. 	 */
if|if
condition|(
name|AR_SREV_MERLIN_20_OR_LATER
argument_list|(
name|ah
argument_list|)
operator|&&
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_OL_PWRCTRL
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ar5416SetResetReg
argument_list|(
name|ah
argument_list|,
name|HAL_RESET_POWER_ON
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ar5416SetResetReg
argument_list|(
name|ah
argument_list|,
name|HAL_RESET_WARM
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
block|}
comment|/* Bring out of sleep mode (AGAIN) */
if|if
condition|(
operator|!
name|ar5416SetPowerMode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
name|ar5416InitPLL
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* 	 * Perform warm reset before the mode/PLL/turbo registers 	 * are changed in order to deactivate the radio.  Mode changes 	 * with an active radio can result in corrupted shifts to the 	 * radio device. 	 */
if|if
condition|(
name|chan
operator|!=
name|AH_NULL
condition|)
block|{
name|uint32_t
name|rfMode
decl_stmt|;
comment|/* treat channel B as channel G , no  B mode suport in owl */
name|rfMode
operator|=
name|IEEE80211_IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
condition|?
name|AR_PHY_MODE_DYNAMIC
else|:
name|AR_PHY_MODE_OFDM
expr_stmt|;
if|if
condition|(
name|AR_SREV_MERLIN_20
argument_list|(
name|ah
argument_list|)
operator|&&
name|IS_5GHZ_FAST_CLOCK_EN
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
comment|/* phy mode bits for 5GHz channels require Fast Clock */
name|rfMode
operator||=
name|AR_PHY_MODE_DYNAMIC
operator||
name|AR_PHY_MODE_DYN_CCK_DISABLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|AR_SREV_MERLIN_10_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|rfMode
operator||=
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|?
name|AR_PHY_MODE_RF5GHZ
else|:
name|AR_PHY_MODE_RF2GHZ
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MODE
argument_list|,
name|rfMode
argument_list|)
expr_stmt|;
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Delta slope coefficient computation.  * Required for OFDM operation.  */
end_comment

begin_function
specifier|static
name|void
name|ar5416GetDeltaSlopeValues
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|coef_scaled
parameter_list|,
name|uint32_t
modifier|*
name|coef_mantissa
parameter_list|,
name|uint32_t
modifier|*
name|coef_exponent
parameter_list|)
block|{
define|#
directive|define
name|COEF_SCALE_S
value|24
name|uint32_t
name|coef_exp
decl_stmt|,
name|coef_man
decl_stmt|;
comment|/*      * ALGO -> coef_exp = 14-floor(log2(coef));      * floor(log2(x)) is the highest set bit position      */
for|for
control|(
name|coef_exp
operator|=
literal|31
init|;
name|coef_exp
operator|>
literal|0
condition|;
name|coef_exp
operator|--
control|)
if|if
condition|(
operator|(
name|coef_scaled
operator|>>
name|coef_exp
operator|)
operator|&
literal|0x1
condition|)
break|break;
comment|/* A coef_exp of 0 is a legal bit position but an unexpected coef_exp */
name|HALASSERT
argument_list|(
name|coef_exp
argument_list|)
expr_stmt|;
name|coef_exp
operator|=
literal|14
operator|-
operator|(
name|coef_exp
operator|-
name|COEF_SCALE_S
operator|)
expr_stmt|;
comment|/*      * ALGO -> coef_man = floor(coef* 2^coef_exp+0.5);      * The coefficient is already shifted up for scaling      */
name|coef_man
operator|=
name|coef_scaled
operator|+
operator|(
literal|1
operator|<<
operator|(
name|COEF_SCALE_S
operator|-
name|coef_exp
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
operator|*
name|coef_mantissa
operator|=
name|coef_man
operator|>>
operator|(
name|COEF_SCALE_S
operator|-
name|coef_exp
operator|)
expr_stmt|;
operator|*
name|coef_exponent
operator|=
name|coef_exp
operator|-
literal|16
expr_stmt|;
undef|#
directive|undef
name|COEF_SCALE_S
block|}
end_function

begin_function
name|void
name|ar5416SetDeltaSlope
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
define|#
directive|define
name|INIT_CLOCKMHZSCALED
value|0x64000000
name|uint32_t
name|coef_scaled
decl_stmt|,
name|ds_coef_exp
decl_stmt|,
name|ds_coef_man
decl_stmt|;
name|uint32_t
name|clockMhzScaled
decl_stmt|;
name|CHAN_CENTERS
name|centers
decl_stmt|;
comment|/* half and quarter rate can divide the scaled clock by 2 or 4 respectively */
comment|/* scale for selected channel bandwidth */
name|clockMhzScaled
operator|=
name|INIT_CLOCKMHZSCALED
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
condition|)
name|clockMhzScaled
operator|<<=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
condition|)
name|clockMhzScaled
operator|>>=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|chan
argument_list|)
condition|)
name|clockMhzScaled
operator|>>=
literal|2
expr_stmt|;
comment|/* 	 * ALGO -> coef = 1e8/fcarrier*fclock/40; 	 * scaled coef to provide precision for this floating calculation  	 */
name|ar5416GetChannelCenters
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|&
name|centers
argument_list|)
expr_stmt|;
name|coef_scaled
operator|=
name|clockMhzScaled
operator|/
name|centers
operator|.
name|synth_center
expr_stmt|;
name|ar5416GetDeltaSlopeValues
argument_list|(
name|ah
argument_list|,
name|coef_scaled
argument_list|,
operator|&
name|ds_coef_man
argument_list|,
operator|&
name|ds_coef_exp
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING3
argument_list|,
name|AR_PHY_TIMING3_DSC_MAN
argument_list|,
name|ds_coef_man
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING3
argument_list|,
name|AR_PHY_TIMING3_DSC_EXP
argument_list|,
name|ds_coef_exp
argument_list|)
expr_stmt|;
comment|/*          * For Short GI,          * scaled coeff is 9/10 that of normal coeff          */
name|coef_scaled
operator|=
operator|(
literal|9
operator|*
name|coef_scaled
operator|)
operator|/
literal|10
expr_stmt|;
name|ar5416GetDeltaSlopeValues
argument_list|(
name|ah
argument_list|,
name|coef_scaled
argument_list|,
operator|&
name|ds_coef_man
argument_list|,
operator|&
name|ds_coef_exp
argument_list|)
expr_stmt|;
comment|/* for short gi */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_HALFGI
argument_list|,
name|AR_PHY_HALFGI_DSC_MAN
argument_list|,
name|ds_coef_man
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_HALFGI
argument_list|,
name|AR_PHY_HALFGI_DSC_EXP
argument_list|,
name|ds_coef_exp
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|INIT_CLOCKMHZSCALED
block|}
end_function

begin_comment
comment|/*  * Set a limit on the overall output power.  Used for dynamic  * transmit power control and the like.  *  * NB: limit is in units of 0.5 dbM.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5416SetTxPowerLimit
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|limit
parameter_list|)
block|{
name|uint16_t
name|dummyXpdGains
index|[
literal|2
index|]
decl_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_powerLimit
operator|=
name|AH_MIN
argument_list|(
name|limit
argument_list|,
name|MAX_RATE_POWER
argument_list|)
expr_stmt|;
return|return
name|ar5416SetTransmitPower
argument_list|(
name|ah
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
argument_list|,
name|dummyXpdGains
argument_list|)
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5416GetChipPowerLimits
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int16_t
name|minPower
decl_stmt|,
name|maxPower
decl_stmt|;
comment|/* 	 * Get Pier table max and min powers. 	 */
if|if
condition|(
name|ahp
operator|->
name|ah_rfHal
operator|->
name|getChannelMaxMinPower
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|&
name|maxPower
argument_list|,
operator|&
name|minPower
argument_list|)
condition|)
block|{
comment|/* NB: rf code returns 1/4 dBm units, convert */
name|chan
operator|->
name|ic_maxpower
operator|=
name|maxPower
operator|/
literal|2
expr_stmt|;
name|chan
operator|->
name|ic_minpower
operator|=
name|minPower
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: no min/max power for %u/0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|chan
operator|->
name|ic_maxpower
operator|=
name|AR5416_MAX_RATE_POWER
expr_stmt|;
name|chan
operator|->
name|ic_minpower
operator|=
literal|0
expr_stmt|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"Chan %d: MaxPow = %d MinPow = %d\n"
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_maxpower
argument_list|,
name|chan
operator|->
name|ic_minpower
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/* XXX gag, this is sick */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|Ar5416_Rates
block|{
name|rate6mb
block|,
name|rate9mb
block|,
name|rate12mb
block|,
name|rate18mb
block|,
name|rate24mb
block|,
name|rate36mb
block|,
name|rate48mb
block|,
name|rate54mb
block|,
name|rate1l
block|,
name|rate2l
block|,
name|rate2s
block|,
name|rate5_5l
block|,
name|rate5_5s
block|,
name|rate11l
block|,
name|rate11s
block|,
name|rateXr
block|,
name|rateHt20_0
block|,
name|rateHt20_1
block|,
name|rateHt20_2
block|,
name|rateHt20_3
block|,
name|rateHt20_4
block|,
name|rateHt20_5
block|,
name|rateHt20_6
block|,
name|rateHt20_7
block|,
name|rateHt40_0
block|,
name|rateHt40_1
block|,
name|rateHt40_2
block|,
name|rateHt40_3
block|,
name|rateHt40_4
block|,
name|rateHt40_5
block|,
name|rateHt40_6
block|,
name|rateHt40_7
block|,
name|rateDupCck
block|,
name|rateDupOfdm
block|,
name|rateExtCck
block|,
name|rateExtOfdm
block|,
name|Ar5416RateSize
block|}
name|AR5416_RATES
typedef|;
end_typedef

begin_comment
comment|/**************************************************************  * ar5416SetTransmitPower  *  * Set the transmit power in the baseband for the given  * operating channel and mode.  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5416SetTransmitPower
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|uint16_t
modifier|*
name|rfXpdGain
parameter_list|)
block|{
define|#
directive|define
name|POW_SM
parameter_list|(
name|_r
parameter_list|,
name|_s
parameter_list|)
value|(((_r)& 0x3f)<< (_s))
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) / sizeof (a[0]))
name|MODAL_EEP_HEADER
modifier|*
name|pModal
decl_stmt|;
name|MODAL_EEP4K_HEADER
modifier|*
name|pModal4k
decl_stmt|;
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int16_t
name|ratesArray
index|[
name|Ar5416RateSize
index|]
decl_stmt|;
name|int16_t
name|txPowerIndexOffset
init|=
literal|0
decl_stmt|;
name|uint8_t
name|ht40PowerIncForPdadc
init|=
literal|2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
name|cfgCtl
decl_stmt|;
name|uint16_t
name|powerLimit
decl_stmt|;
name|uint16_t
name|twiceAntennaReduction
decl_stmt|;
name|uint16_t
name|twiceMaxRegulatoryPower
decl_stmt|;
name|int16_t
name|maxPower
decl_stmt|;
name|HAL_EEPROM_v14
modifier|*
name|ee
decl_stmt|;
name|HAL_EEPROM_v4k
modifier|*
name|ee4k
decl_stmt|;
name|struct
name|ar5416eeprom
modifier|*
name|pEepData
decl_stmt|;
name|struct
name|ar5416eeprom_4k
modifier|*
name|pEepData4k
decl_stmt|;
name|HALASSERT
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeversion
operator|>=
name|AR_EEPROM_VER14_1
argument_list|)
expr_stmt|;
comment|/* Setup info for the actual eeprom */
name|OS_MEMZERO
argument_list|(
name|ratesArray
argument_list|,
sizeof|sizeof
argument_list|(
name|ratesArray
argument_list|)
argument_list|)
expr_stmt|;
name|cfgCtl
operator|=
name|ath_hal_getctl
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|powerLimit
operator|=
name|chan
operator|->
name|ic_maxregpower
operator|*
literal|2
expr_stmt|;
name|twiceAntennaReduction
operator|=
name|chan
operator|->
name|ic_maxantgain
expr_stmt|;
name|twiceMaxRegulatoryPower
operator|=
name|AH_MIN
argument_list|(
name|MAX_RATE_POWER
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_powerLimit
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_KITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|ee4k
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
expr_stmt|;
name|pEepData4k
operator|=
operator|&
name|ee4k
operator|->
name|ee_base
expr_stmt|;
name|pModal4k
operator|=
operator|&
name|pEepData4k
operator|->
name|modalHeader
expr_stmt|;
name|ee
operator|=
name|NULL
expr_stmt|;
name|pEepData
operator|=
name|NULL
expr_stmt|;
name|pModal
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ee
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
expr_stmt|;
name|pEepData
operator|=
operator|&
name|ee
operator|->
name|ee_base
expr_stmt|;
name|pModal
operator|=
operator|&
name|pEepData
operator|->
name|modalHeader
index|[
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
index|]
expr_stmt|;
name|ee4k
operator|=
name|NULL
expr_stmt|;
name|pEepData4k
operator|=
name|NULL
expr_stmt|;
name|pModal4k
operator|=
name|NULL
expr_stmt|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s Channel=%u CfgCtl=%u\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|cfgCtl
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_EEP_MINOR_V2
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|pModal
condition|)
name|ht40PowerIncForPdadc
operator|=
name|pModal
operator|->
name|ht40PowerIncForPdadc
expr_stmt|;
else|else
name|ht40PowerIncForPdadc
operator|=
name|pModal4k
operator|->
name|ht40PowerIncForPdadc
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ar5416SetPowerPerRateTable
argument_list|(
name|ah
argument_list|,
name|pEepData
argument_list|,
name|pEepData4k
argument_list|,
name|chan
argument_list|,
operator|&
name|ratesArray
index|[
literal|0
index|]
argument_list|,
name|cfgCtl
argument_list|,
name|twiceAntennaReduction
argument_list|,
name|twiceMaxRegulatoryPower
argument_list|,
name|powerLimit
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: unable to set tx power per rate table\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
if|if
condition|(
operator|!
name|ar5416SetPowerCalTable
argument_list|(
name|ah
argument_list|,
name|pEepData
argument_list|,
name|pEepData4k
argument_list|,
name|chan
argument_list|,
operator|&
name|txPowerIndexOffset
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: unable to set power table\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|maxPower
operator|=
name|AH_MAX
argument_list|(
name|ratesArray
index|[
name|rate6mb
index|]
argument_list|,
name|ratesArray
index|[
name|rateHt20_0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|maxPower
operator|=
name|AH_MAX
argument_list|(
name|maxPower
argument_list|,
name|ratesArray
index|[
name|rate1l
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|maxPower
operator|=
name|AH_MAX
argument_list|(
name|maxPower
argument_list|,
name|ratesArray
index|[
name|rateHt40_0
index|]
argument_list|)
expr_stmt|;
block|}
name|ahp
operator|->
name|ah_tx6PowerInHalfDbm
operator|=
name|maxPower
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_maxPowerLevel
operator|=
name|maxPower
expr_stmt|;
name|ahp
operator|->
name|ah_txPowerIndexOffset
operator|=
name|txPowerIndexOffset
expr_stmt|;
comment|/*      * txPowerIndexOffset is set by the SetPowerTable() call -      *  adjust the rate table (0 offset if rates EEPROM not loaded)      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|ratesArray
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ratesArray
index|[
name|i
index|]
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|txPowerIndexOffset
operator|+
name|ratesArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ratesArray
index|[
name|i
index|]
operator|>
name|AR5416_MAX_RATE_POWER
condition|)
name|ratesArray
index|[
name|i
index|]
operator|=
name|AR5416_MAX_RATE_POWER
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AH_EEPROM_DUMP
name|ar5416PrintPowerPerRate
argument_list|(
name|ah
argument_list|,
name|ratesArray
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Write the OFDM power per rate set */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_RATE1
argument_list|,
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rate18mb
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rate12mb
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rate9mb
index|]
argument_list|,
literal|8
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rate6mb
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_RATE2
argument_list|,
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rate54mb
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rate48mb
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rate36mb
index|]
argument_list|,
literal|8
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rate24mb
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* Write the CCK power per rate set */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_RATE3
argument_list|,
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rate2s
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rate2l
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateXr
index|]
argument_list|,
literal|8
argument_list|)
comment|/* XR target power */
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rate1l
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_RATE4
argument_list|,
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rate11s
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rate11l
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rate5_5s
index|]
argument_list|,
literal|8
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rate5_5l
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s AR_PHY_POWER_TX_RATE3=0x%x AR_PHY_POWER_TX_RATE4=0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_RATE3
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_RATE4
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Write the HT20 power per rate set */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_RATE5
argument_list|,
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateHt20_3
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateHt20_2
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateHt20_1
index|]
argument_list|,
literal|8
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateHt20_0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_RATE6
argument_list|,
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateHt20_7
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateHt20_6
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateHt20_5
index|]
argument_list|,
literal|8
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateHt20_4
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* Write the HT40 power per rate set */
comment|/* Correct PAR difference between HT40 and HT20/LEGACY */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_RATE7
argument_list|,
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateHt40_3
index|]
operator|+
name|ht40PowerIncForPdadc
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateHt40_2
index|]
operator|+
name|ht40PowerIncForPdadc
argument_list|,
literal|16
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateHt40_1
index|]
operator|+
name|ht40PowerIncForPdadc
argument_list|,
literal|8
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateHt40_0
index|]
operator|+
name|ht40PowerIncForPdadc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_RATE8
argument_list|,
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateHt40_7
index|]
operator|+
name|ht40PowerIncForPdadc
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateHt40_6
index|]
operator|+
name|ht40PowerIncForPdadc
argument_list|,
literal|16
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateHt40_5
index|]
operator|+
name|ht40PowerIncForPdadc
argument_list|,
literal|8
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateHt40_4
index|]
operator|+
name|ht40PowerIncForPdadc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write the Dup/Ext 40 power per rate set */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_RATE9
argument_list|,
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateExtOfdm
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateExtCck
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateDupOfdm
index|]
argument_list|,
literal|8
argument_list|)
operator||
name|POW_SM
argument_list|(
name|ratesArray
index|[
name|rateDupCck
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Write the Power subtraction for dynamic chain changing, for per-packet powertx */
if|if
condition|(
name|pModal
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_SUB
argument_list|,
name|POW_SM
argument_list|(
name|pModal
operator|->
name|pwrDecreaseFor3Chain
argument_list|,
literal|6
argument_list|)
operator||
name|POW_SM
argument_list|(
name|pModal
operator|->
name|pwrDecreaseFor2Chain
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|POW_SM
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Exported call to check for a recent gain reading and return  * the current state of the thermal calibration gain engine.  */
end_comment

begin_function
name|HAL_RFGAIN
name|ar5416GetRfgain
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|HAL_RFGAIN_INACTIVE
return|;
block|}
end_function

begin_comment
comment|/*  * Places all of hardware into reset  */
end_comment

begin_function
name|HAL_BOOL
name|ar5416Disable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ar5212SetPowerMode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
return|return
name|ar5416SetResetReg
argument_list|(
name|ah
argument_list|,
name|HAL_RESET_COLD
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Places the PHY and Radio chips into reset.  A full reset  * must be called to leave this state.  The PCI/MAC/PCU are  * not placed into reset as we must receive interrupt to  * re-enable the hardware.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5416PhyDisable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|ar5416SetResetReg
argument_list|(
name|ah
argument_list|,
name|HAL_RESET_WARM
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write the given reset bit mask into the reset register  */
end_comment

begin_function
name|HAL_BOOL
name|ar5416SetResetReg
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|HAL_RESET_POWER_ON
case|:
return|return
name|ar5416SetResetPowerOn
argument_list|(
name|ah
argument_list|)
return|;
case|case
name|HAL_RESET_WARM
case|:
case|case
name|HAL_RESET_COLD
case|:
return|return
name|ar5416SetReset
argument_list|(
name|ah
argument_list|,
name|type
argument_list|)
return|;
default|default:
name|HALASSERT
argument_list|(
name|AH_FALSE
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|ar5416SetResetPowerOn
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
comment|/* Power On Reset (Hard Reset) */
comment|/*      * Set force wake      *	      * If the MAC was running, previously calling      * reset will wake up the MAC but it may go back to sleep      * before we can start polling.       * Set force wake  stops that       * This must be called before initiating a hard reset.      */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_FORCE_WAKE
argument_list|,
name|AR_RTC_FORCE_WAKE_EN
operator||
name|AR_RTC_FORCE_WAKE_ON_INT
argument_list|)
expr_stmt|;
comment|/*      * RTC reset and clear      */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_RESET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Poll till RTC is ON      */
if|if
condition|(
operator|!
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_RTC_STATUS
argument_list|,
name|AR_RTC_PM_STATUS_M
argument_list|,
name|AR_RTC_STATUS_ON
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: RTC not waking up\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
return|return
name|ar5416SetReset
argument_list|(
name|ah
argument_list|,
name|HAL_RESET_COLD
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|ar5416SetReset
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|uint32_t
name|tmpReg
decl_stmt|,
name|mask
decl_stmt|;
comment|/*      * Force wake      */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_FORCE_WAKE
argument_list|,
name|AR_RTC_FORCE_WAKE_EN
operator||
name|AR_RTC_FORCE_WAKE_ON_INT
argument_list|)
expr_stmt|;
comment|/*      * Reset AHB      */
name|tmpReg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_CAUSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpReg
operator|&
operator|(
name|AR_INTR_SYNC_LOCAL_TIMEOUT
operator||
name|AR_INTR_SYNC_RADM_CPL_TIMEOUT
operator|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RC
argument_list|,
name|AR_RC_AHB
operator||
name|AR_RC_HOSTIF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RC
argument_list|,
name|AR_RC_AHB
argument_list|)
expr_stmt|;
block|}
comment|/*      * Set Mac(BB,Phy) Warm Reset      */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|HAL_RESET_WARM
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_RC
argument_list|,
name|AR_RTC_RC_MAC_WARM
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_RESET_COLD
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_RC
argument_list|,
name|AR_RTC_RC_MAC_WARM
operator||
name|AR_RTC_RC_MAC_COLD
argument_list|)
expr_stmt|;
break|break;
default|default:
name|HALASSERT
argument_list|(
name|AH_FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*      * Clear resets and force wakeup      */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_RC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_RTC_RC
argument_list|,
name|AR_RTC_RC_M
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: RTC stuck in MAC reset\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* Clear AHB reset */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|HAL_RESET_COLD
condition|)
block|{
if|if
condition|(
name|isBigEndian
argument_list|()
condition|)
block|{
comment|/* 			 * Set CFG, little-endian for register 			 * and descriptor accesses. 			 */
name|mask
operator|=
name|INIT_CONFIG_STATUS
operator||
name|AR_CFG_SWRD
operator||
name|AR_CFG_SWRG
expr_stmt|;
ifndef|#
directive|ifndef
name|AH_NEED_DESC_SWAP
name|mask
operator||=
name|AR_CFG_SWTD
expr_stmt|;
endif|#
directive|endif
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s Applying descriptor swap\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CFG
argument_list|,
name|LE_READ_4
argument_list|(
operator|&
name|mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CFG
argument_list|,
name|INIT_CONFIG_STATUS
argument_list|)
expr_stmt|;
block|}
name|ar5416InitPLL
argument_list|(
name|ah
argument_list|,
name|AH_NULL
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|IS_5GHZ_FAST_CLOCK_EN
end_ifndef

begin_define
define|#
directive|define
name|IS_5GHZ_FAST_CLOCK_EN
parameter_list|(
name|ah
parameter_list|,
name|chan
parameter_list|)
value|AH_FALSE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ar5416InitPLL
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|uint32_t
name|pll
decl_stmt|;
if|if
condition|(
name|AR_SREV_MERLIN_20
argument_list|(
name|ah
argument_list|)
operator|&&
name|chan
operator|!=
name|AH_NULL
operator|&&
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* 		 * PLL WAR for Merlin 2.0/2.1 		 * When doing fast clock, set PLL to 0x142c 		 * Else, set PLL to 0x2850 to prevent reset-to-reset variation  		 */
name|pll
operator|=
name|IS_5GHZ_FAST_CLOCK_EN
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|?
literal|0x142c
else|:
literal|0x2850
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_MERLIN_10_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|pll
operator|=
name|SM
argument_list|(
literal|0x5
argument_list|,
name|AR_RTC_SOWL_PLL_REFDIV
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
name|AH_NULL
condition|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
condition|)
name|pll
operator||=
name|SM
argument_list|(
literal|0x1
argument_list|,
name|AR_RTC_SOWL_PLL_CLKSEL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|chan
argument_list|)
condition|)
name|pll
operator||=
name|SM
argument_list|(
literal|0x2
argument_list|,
name|AR_RTC_SOWL_PLL_CLKSEL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|)
name|pll
operator||=
name|SM
argument_list|(
literal|0x28
argument_list|,
name|AR_RTC_SOWL_PLL_DIV
argument_list|)
expr_stmt|;
else|else
name|pll
operator||=
name|SM
argument_list|(
literal|0x2c
argument_list|,
name|AR_RTC_SOWL_PLL_DIV
argument_list|)
expr_stmt|;
block|}
else|else
name|pll
operator||=
name|SM
argument_list|(
literal|0x2c
argument_list|,
name|AR_RTC_SOWL_PLL_DIV
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_SOWL_10_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|pll
operator|=
name|SM
argument_list|(
literal|0x5
argument_list|,
name|AR_RTC_SOWL_PLL_REFDIV
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
name|AH_NULL
condition|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
condition|)
name|pll
operator||=
name|SM
argument_list|(
literal|0x1
argument_list|,
name|AR_RTC_SOWL_PLL_CLKSEL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|chan
argument_list|)
condition|)
name|pll
operator||=
name|SM
argument_list|(
literal|0x2
argument_list|,
name|AR_RTC_SOWL_PLL_CLKSEL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|)
name|pll
operator||=
name|SM
argument_list|(
literal|0x50
argument_list|,
name|AR_RTC_SOWL_PLL_DIV
argument_list|)
expr_stmt|;
else|else
name|pll
operator||=
name|SM
argument_list|(
literal|0x58
argument_list|,
name|AR_RTC_SOWL_PLL_DIV
argument_list|)
expr_stmt|;
block|}
else|else
name|pll
operator||=
name|SM
argument_list|(
literal|0x58
argument_list|,
name|AR_RTC_SOWL_PLL_DIV
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pll
operator|=
name|AR_RTC_PLL_REFDIV_5
operator||
name|AR_RTC_PLL_DIV2
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
name|AH_NULL
condition|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
condition|)
name|pll
operator||=
name|SM
argument_list|(
literal|0x1
argument_list|,
name|AR_RTC_PLL_CLKSEL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|chan
argument_list|)
condition|)
name|pll
operator||=
name|SM
argument_list|(
literal|0x2
argument_list|,
name|AR_RTC_PLL_CLKSEL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|)
name|pll
operator||=
name|SM
argument_list|(
literal|0xa
argument_list|,
name|AR_RTC_PLL_DIV
argument_list|)
expr_stmt|;
else|else
name|pll
operator||=
name|SM
argument_list|(
literal|0xb
argument_list|,
name|AR_RTC_PLL_DIV
argument_list|)
expr_stmt|;
block|}
else|else
name|pll
operator||=
name|SM
argument_list|(
literal|0xb
argument_list|,
name|AR_RTC_PLL_DIV
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_PLL_CONTROL
argument_list|,
name|pll
argument_list|)
expr_stmt|;
comment|/* TODO: 	* For multi-band owl, switch between bands by reiniting the PLL. 	*/
name|OS_DELAY
argument_list|(
name|RTC_PLL_SETTLE_DELAY
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_SLEEP_CLK
argument_list|,
name|AR_RTC_SLEEP_DERIVED_CLK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read EEPROM header info and program the device for correct operation  * given the channel value.  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5416SetBoardValues
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
specifier|const
name|HAL_EEPROM_v14
modifier|*
name|ee
decl_stmt|;
specifier|const
name|HAL_EEPROM_v4k
modifier|*
name|ee4k
decl_stmt|;
specifier|const
name|struct
name|ar5416eeprom
modifier|*
name|eep
decl_stmt|;
specifier|const
name|struct
name|ar5416eeprom_4k
modifier|*
name|eep4k
decl_stmt|;
specifier|const
name|MODAL_EEP_HEADER
modifier|*
name|pModal
decl_stmt|;
specifier|const
name|MODAL_EEP4K_HEADER
modifier|*
name|pModal4k
decl_stmt|;
name|int
name|i
decl_stmt|,
name|regChainOffset
decl_stmt|;
name|uint8_t
name|txRxAttenLocal
decl_stmt|;
comment|/* workaround for eeprom versions<= 14.2 */
name|HALASSERT
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeversion
operator|>=
name|AR_EEPROM_VER14_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_KITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|ee4k
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
expr_stmt|;
name|eep4k
operator|=
operator|&
name|ee4k
operator|->
name|ee_base
expr_stmt|;
name|pModal4k
operator|=
operator|&
name|eep4k
operator|->
name|modalHeader
expr_stmt|;
name|ee
operator|=
name|NULL
expr_stmt|;
name|eep
operator|=
name|NULL
expr_stmt|;
name|pModal
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ee
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
expr_stmt|;
name|eep
operator|=
operator|&
name|ee
operator|->
name|ee_base
expr_stmt|;
name|pModal
operator|=
operator|&
name|eep
operator|->
name|modalHeader
index|[
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
index|]
expr_stmt|;
name|ee4k
operator|=
name|NULL
expr_stmt|;
name|eep4k
operator|=
name|NULL
expr_stmt|;
name|pModal4k
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* NB: workaround for eeprom versions<= 14.2 */
name|txRxAttenLocal
operator|=
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|?
literal|23
else|:
literal|44
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SWITCH_COM
argument_list|,
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|antCtrlCommon
else|:
name|pModal4k
operator|->
name|antCtrlCommon
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR5416_MAX_CHAINS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|AR_SREV_KITE
argument_list|(
name|ah
argument_list|)
operator|&&
name|i
operator|>=
literal|1
condition|)
break|break;
if|if
condition|(
name|AR_SREV_MERLIN
argument_list|(
name|ah
argument_list|)
operator|&&
name|i
operator|>=
literal|2
condition|)
break|break;
if|if
condition|(
name|AR_SREV_OWL_20_OR_LATER
argument_list|(
name|ah
argument_list|)
operator|&&
operator|(
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rx_chainmask
operator|==
literal|0x5
operator|||
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tx_chainmask
operator|==
literal|0x5
operator|)
operator|&&
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* Regs are swapped from chain 2 to 1 for 5416 2_0 with               * only chains 0 and 2 populated               */
name|regChainOffset
operator|=
operator|(
name|i
operator|==
literal|1
operator|)
condition|?
literal|0x2000
else|:
literal|0x1000
expr_stmt|;
block|}
else|else
block|{
name|regChainOffset
operator|=
name|i
operator|*
literal|0x1000
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SWITCH_CHAIN_0
operator|+
name|regChainOffset
argument_list|,
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|antCtrlChain
index|[
name|i
index|]
else|:
name|pModal4k
operator|->
name|antCtrlChain
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
operator|+
name|regChainOffset
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
operator|+
name|regChainOffset
argument_list|)
operator|&
operator|~
operator|(
name|AR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF
operator||
name|AR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF
operator|)
operator|)
operator||
name|SM
argument_list|(
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|iqCalICh
index|[
name|i
index|]
else|:
name|pModal4k
operator|->
name|iqCalICh
index|[
name|i
index|]
argument_list|,
name|AR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF
argument_list|)
operator||
name|SM
argument_list|(
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|iqCalQCh
index|[
name|i
index|]
else|:
name|pModal4k
operator|->
name|iqCalQCh
index|[
name|i
index|]
argument_list|,
name|AR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF
argument_list|)
argument_list|)
expr_stmt|;
comment|/*          * Large signal upgrade. 	 * XXX update          */
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|||
name|AR_SREV_OWL_20_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|int
name|txRxAtten
decl_stmt|;
if|if
condition|(
name|IS_EEP_MINOR_V3
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|pModal
condition|)
name|txRxAtten
operator|=
name|pModal
operator|->
name|txRxAttenCh
index|[
name|i
index|]
expr_stmt|;
else|else
name|txRxAtten
operator|=
name|pModal4k
operator|->
name|txRxAttenCh
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|txRxAtten
operator|=
name|txRxAttenLocal
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RXGAIN
operator|+
name|regChainOffset
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RXGAIN
operator|+
name|regChainOffset
argument_list|)
operator|&
operator|~
name|AR_PHY_RXGAIN_TXRX_ATTEN
operator|)
operator||
name|SM
argument_list|(
name|txRxAtten
argument_list|,
name|AR_PHY_RXGAIN_TXRX_ATTEN
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
operator|+
name|regChainOffset
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
operator|+
name|regChainOffset
argument_list|)
operator|&
operator|~
name|AR_PHY_GAIN_2GHZ_RXTX_MARGIN
operator|)
operator||
name|SM
argument_list|(
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|rxTxMarginCh
index|[
name|i
index|]
else|:
name|pModal4k
operator|->
name|rxTxMarginCh
index|[
name|i
index|]
argument_list|,
name|AR_PHY_GAIN_2GHZ_RXTX_MARGIN
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SETTLING
argument_list|,
name|AR_PHY_SETTLING_SWITCH
argument_list|,
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|switchSettling
else|:
name|pModal4k
operator|->
name|switchSettling
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_DESIRED_SZ
argument_list|,
name|AR_PHY_DESIRED_SZ_ADC
argument_list|,
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|adcDesiredSize
else|:
name|pModal4k
operator|->
name|adcDesiredSize
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_DESIRED_SZ
argument_list|,
name|AR_PHY_DESIRED_SZ_PGA
argument_list|,
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|pgaDesiredSize
else|:
name|pModal4k
operator|->
name|pgaDesiredSize
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RF_CTL4
argument_list|,
name|SM
argument_list|(
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|txEndToXpaOff
else|:
name|pModal4k
operator|->
name|txEndToXpaOff
argument_list|,
name|AR_PHY_RF_CTL4_TX_END_XPAA_OFF
argument_list|)
operator||
name|SM
argument_list|(
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|txEndToXpaOff
else|:
name|pModal4k
operator|->
name|txEndToXpaOff
argument_list|,
name|AR_PHY_RF_CTL4_TX_END_XPAB_OFF
argument_list|)
operator||
name|SM
argument_list|(
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|txFrameToXpaOn
else|:
name|pModal4k
operator|->
name|txFrameToXpaOn
argument_list|,
name|AR_PHY_RF_CTL4_FRAME_XPAA_ON
argument_list|)
operator||
name|SM
argument_list|(
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|txFrameToXpaOn
else|:
name|pModal4k
operator|->
name|txFrameToXpaOn
argument_list|,
name|AR_PHY_RF_CTL4_FRAME_XPAB_ON
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RF_CTL3
argument_list|,
name|AR_PHY_TX_END_TO_A2_RX_ON
argument_list|,
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|txEndToRxOn
else|:
name|pModal4k
operator|->
name|txEndToRxOn
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_MERLIN_10_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCA
argument_list|,
name|AR9280_PHY_CCA_THRESH62
argument_list|,
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|thresh62
else|:
name|pModal4k
operator|->
name|thresh62
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_EXT_CCA0
argument_list|,
name|AR_PHY_EXT_CCA0_THRESH62
argument_list|,
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|thresh62
else|:
name|pModal4k
operator|->
name|thresh62
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCA
argument_list|,
name|AR_PHY_CCA_THRESH62
argument_list|,
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|thresh62
else|:
name|pModal4k
operator|->
name|thresh62
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_EXT_CCA0
argument_list|,
name|AR_PHY_EXT_CCA_THRESH62
argument_list|,
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|thresh62
else|:
name|pModal4k
operator|->
name|thresh62
argument_list|)
expr_stmt|;
block|}
comment|/* Minor Version Specific application */
if|if
condition|(
name|IS_EEP_MINOR_V2
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RF_CTL2
argument_list|,
name|AR_PHY_TX_FRAME_TO_DATA_START
argument_list|,
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|txFrameToDataStart
else|:
name|pModal4k
operator|->
name|txFrameToDataStart
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RF_CTL2
argument_list|,
name|AR_PHY_TX_FRAME_TO_PA_ON
argument_list|,
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|txFrameToPaOn
else|:
name|pModal4k
operator|->
name|txFrameToPaOn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_EEP_MINOR_V3
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* Overwrite switch settling with HT40 value */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SETTLING
argument_list|,
name|AR_PHY_SETTLING_SWITCH
argument_list|,
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|swSettleHt40
else|:
name|pModal4k
operator|->
name|swSettleHt40
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|AR_SREV_OWL_20_OR_LATER
argument_list|(
name|ah
argument_list|)
operator|)
operator|&&
operator|(
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rx_chainmask
operator|==
literal|0x5
operator|||
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tx_chainmask
operator|==
literal|0x5
operator|)
condition|)
block|{
comment|/* NB: no v4k EEPROM */
comment|/* Reg Offsets are swapped for logical mapping */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
operator|+
literal|0x1000
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
operator|+
literal|0x1000
argument_list|)
operator|&
operator|~
name|AR_PHY_GAIN_2GHZ_BSW_MARGIN
operator|)
operator||
name|SM
argument_list|(
name|pModal
operator|->
name|bswMargin
index|[
literal|2
index|]
argument_list|,
name|AR_PHY_GAIN_2GHZ_BSW_MARGIN
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
operator|+
literal|0x1000
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
operator|+
literal|0x1000
argument_list|)
operator|&
operator|~
name|AR_PHY_GAIN_2GHZ_BSW_ATTEN
operator|)
operator||
name|SM
argument_list|(
name|pModal
operator|->
name|bswAtten
index|[
literal|2
index|]
argument_list|,
name|AR_PHY_GAIN_2GHZ_BSW_ATTEN
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
operator|+
literal|0x2000
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
operator|+
literal|0x2000
argument_list|)
operator|&
operator|~
name|AR_PHY_GAIN_2GHZ_BSW_MARGIN
operator|)
operator||
name|SM
argument_list|(
name|pModal
operator|->
name|bswMargin
index|[
literal|1
index|]
argument_list|,
name|AR_PHY_GAIN_2GHZ_BSW_MARGIN
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
operator|+
literal|0x2000
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
operator|+
literal|0x2000
argument_list|)
operator|&
operator|~
name|AR_PHY_GAIN_2GHZ_BSW_ATTEN
operator|)
operator||
name|SM
argument_list|(
name|pModal
operator|->
name|bswAtten
index|[
literal|1
index|]
argument_list|,
name|AR_PHY_GAIN_2GHZ_BSW_ATTEN
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
operator|+
literal|0x1000
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
operator|+
literal|0x1000
argument_list|)
operator|&
operator|~
name|AR_PHY_GAIN_2GHZ_BSW_MARGIN
operator|)
operator||
name|SM
argument_list|(
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|bswMargin
index|[
literal|1
index|]
else|:
name|pModal4k
operator|->
name|bswMargin
index|[
literal|1
index|]
argument_list|,
name|AR_PHY_GAIN_2GHZ_BSW_MARGIN
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
operator|+
literal|0x1000
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
operator|+
literal|0x1000
argument_list|)
operator|&
operator|~
name|AR_PHY_GAIN_2GHZ_BSW_ATTEN
operator|)
operator||
name|SM
argument_list|(
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|bswAtten
index|[
literal|1
index|]
else|:
name|pModal4k
operator|->
name|bswAtten
index|[
literal|1
index|]
argument_list|,
name|AR_PHY_GAIN_2GHZ_BSW_ATTEN
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
operator|+
literal|0x2000
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
operator|+
literal|0x2000
argument_list|)
operator|&
operator|~
name|AR_PHY_GAIN_2GHZ_BSW_MARGIN
operator|)
operator||
name|SM
argument_list|(
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|bswMargin
index|[
literal|2
index|]
else|:
name|pModal4k
operator|->
name|bswMargin
index|[
literal|2
index|]
argument_list|,
name|AR_PHY_GAIN_2GHZ_BSW_MARGIN
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
operator|+
literal|0x2000
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
operator|+
literal|0x2000
argument_list|)
operator|&
operator|~
name|AR_PHY_GAIN_2GHZ_BSW_ATTEN
operator|)
operator||
name|SM
argument_list|(
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|bswAtten
index|[
literal|2
index|]
else|:
name|pModal4k
operator|->
name|bswAtten
index|[
literal|2
index|]
argument_list|,
name|AR_PHY_GAIN_2GHZ_BSW_ATTEN
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
argument_list|,
name|AR_PHY_GAIN_2GHZ_BSW_MARGIN
argument_list|,
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|bswMargin
index|[
literal|0
index|]
else|:
name|pModal4k
operator|->
name|bswMargin
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
argument_list|,
name|AR_PHY_GAIN_2GHZ_BSW_ATTEN
argument_list|,
operator|(
name|pModal
operator|)
condition|?
name|pModal
operator|->
name|bswAtten
index|[
literal|0
index|]
else|:
name|pModal4k
operator|->
name|bswAtten
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Helper functions common for AP/CB/XB  */
end_comment

begin_comment
comment|/*  * ar5416SetPowerPerRateTable  *  * Sets the transmit power in the baseband for the given  * operating channel and mode.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5416SetPowerPerRateTable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ar5416eeprom
modifier|*
name|pEepData
parameter_list|,
name|struct
name|ar5416eeprom_4k
modifier|*
name|pEepData4k
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|int16_t
modifier|*
name|ratesArray
parameter_list|,
name|uint16_t
name|cfgCtl
parameter_list|,
name|uint16_t
name|AntennaReduction
parameter_list|,
name|uint16_t
name|twiceMaxRegulatoryPower
parameter_list|,
name|uint16_t
name|powerLimit
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
comment|/* Local defines to distinguish between extension and control CTL's */
define|#
directive|define
name|EXT_ADDITIVE
value|(0x8000)
define|#
directive|define
name|CTL_11A_EXT
value|(CTL_11A | EXT_ADDITIVE)
define|#
directive|define
name|CTL_11G_EXT
value|(CTL_11G | EXT_ADDITIVE)
define|#
directive|define
name|CTL_11B_EXT
value|(CTL_11B | EXT_ADDITIVE)
name|uint16_t
name|twiceMaxEdgePower
init|=
name|AR5416_MAX_RATE_POWER
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int16_t
name|twiceLargestAntenna
decl_stmt|;
name|CAL_CTL_DATA
modifier|*
name|rep
decl_stmt|;
name|CAL_CTL_DATA_4K
modifier|*
name|rep4k
decl_stmt|;
name|CAL_TARGET_POWER_LEG
name|targetPowerOfdm
decl_stmt|,
name|targetPowerCck
init|=
block|{
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|CAL_TARGET_POWER_LEG
name|targetPowerOfdmExt
init|=
block|{
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|,
name|targetPowerCckExt
init|=
block|{
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|CAL_TARGET_POWER_HT
name|targetPowerHt20
decl_stmt|,
name|targetPowerHt40
init|=
block|{
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|int16_t
name|scaledPower
decl_stmt|,
name|minCtlPower
decl_stmt|;
define|#
directive|define
name|SUB_NUM_CTL_MODES_AT_5G_40
value|2
comment|/* excluding HT40, EXT-OFDM */
define|#
directive|define
name|SUB_NUM_CTL_MODES_AT_2G_40
value|3
comment|/* excluding HT40, EXT-OFDM, EXT-CCK */
specifier|static
specifier|const
name|uint16_t
name|ctlModesFor11a
index|[]
init|=
block|{
name|CTL_11A
block|,
name|CTL_5GHT20
block|,
name|CTL_11A_EXT
block|,
name|CTL_5GHT40
block|}
decl_stmt|;
specifier|static
specifier|const
name|uint16_t
name|ctlModesFor11g
index|[]
init|=
block|{
name|CTL_11B
block|,
name|CTL_11G
block|,
name|CTL_2GHT20
block|,
name|CTL_11B_EXT
block|,
name|CTL_11G_EXT
block|,
name|CTL_2GHT40
block|}
decl_stmt|;
specifier|const
name|uint16_t
modifier|*
name|pCtlMode
decl_stmt|;
name|uint16_t
name|numCtlModes
decl_stmt|,
name|ctlMode
decl_stmt|,
name|freq
decl_stmt|;
name|CHAN_CENTERS
name|centers
decl_stmt|;
name|int
name|n2gcck
decl_stmt|,
name|n2g20
decl_stmt|,
name|n2g40
decl_stmt|,
name|numctls
decl_stmt|;
name|ar5416GetChannelCenters
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|&
name|centers
argument_list|)
expr_stmt|;
comment|/* Compute TxPower reduction due to Antenna Gain */
if|if
condition|(
name|pEepData
condition|)
name|twiceLargestAntenna
operator|=
name|AH_MAX
argument_list|(
name|AH_MAX
argument_list|(
name|pEepData
operator|->
name|modalHeader
index|[
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
index|]
operator|.
name|antennaGainCh
index|[
literal|0
index|]
argument_list|,
name|pEepData
operator|->
name|modalHeader
index|[
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
index|]
operator|.
name|antennaGainCh
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|pEepData
operator|->
name|modalHeader
index|[
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
index|]
operator|.
name|antennaGainCh
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|twiceLargestAntenna
operator|=
name|AH_MAX
argument_list|(
name|AH_MAX
argument_list|(
name|pEepData4k
operator|->
name|modalHeader
operator|.
name|antennaGainCh
index|[
literal|0
index|]
argument_list|,
name|pEepData4k
operator|->
name|modalHeader
operator|.
name|antennaGainCh
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|pEepData4k
operator|->
name|modalHeader
operator|.
name|antennaGainCh
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Turn it back on if we need to calculate per chain antenna gain reduction */
comment|/* Use only if the expected gain> 6dbi */
comment|/* Chain 0 is always used */
block|twiceLargestAntenna = pEepData->modalHeader[IEEE80211_IS_CHAN_2GHZ(chan)].antennaGainCh[0];
comment|/* Look at antenna gains of Chains 1 and 2 if the TX mask is set */
block|if (ahp->ah_tx_chainmask& 0x2) 		twiceLargestAntenna = AH_MAX(twiceLargestAntenna, 			pEepData->modalHeader[IEEE80211_IS_CHAN_2GHZ(chan)].antennaGainCh[1]);  	if (ahp->ah_tx_chainmask& 0x4) 		twiceLargestAntenna = AH_MAX(twiceLargestAntenna, 			pEepData->modalHeader[IEEE80211_IS_CHAN_2GHZ(chan)].antennaGainCh[2]);
endif|#
directive|endif
name|twiceLargestAntenna
operator|=
operator|(
name|int16_t
operator|)
name|AH_MIN
argument_list|(
operator|(
name|AntennaReduction
operator|)
operator|-
name|twiceLargestAntenna
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX setup for 5212 use (really used?) */
name|ath_hal_eepromSet
argument_list|(
name|ah
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|?
name|AR_EEP_ANTGAINMAX_2
else|:
name|AR_EEP_ANTGAINMAX_5
argument_list|,
name|twiceLargestAntenna
argument_list|)
expr_stmt|;
comment|/*  	 * scaledPower is the minimum of the user input power level and 	 * the regulatory allowed power level 	 */
name|scaledPower
operator|=
name|AH_MIN
argument_list|(
name|powerLimit
argument_list|,
name|twiceMaxRegulatoryPower
operator|+
name|twiceLargestAntenna
argument_list|)
expr_stmt|;
comment|/* Reduce scaled Power by number of chains active to get to per chain tx power level */
comment|/* TODO: better value than these? */
switch|switch
condition|(
name|owl_get_ntxchains
argument_list|(
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tx_chainmask
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|pEepData
condition|)
name|scaledPower
operator|-=
name|pEepData
operator|->
name|modalHeader
index|[
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
index|]
operator|.
name|pwrDecreaseFor2Chain
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|pEepData
condition|)
name|scaledPower
operator|-=
name|pEepData
operator|->
name|modalHeader
index|[
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
index|]
operator|.
name|pwrDecreaseFor3Chain
expr_stmt|;
break|break;
default|default:
return|return
name|AH_FALSE
return|;
comment|/* Unsupported number of chains */
block|}
name|scaledPower
operator|=
name|AH_MAX
argument_list|(
literal|0
argument_list|,
name|scaledPower
argument_list|)
expr_stmt|;
name|n2gcck
operator|=
operator|(
name|pEepData
operator|)
condition|?
name|AR5416_NUM_2G_CCK_TARGET_POWERS
else|:
name|AR5416_4K_NUM_2G_CCK_TARGET_POWERS
expr_stmt|;
name|n2g20
operator|=
operator|(
name|pEepData
operator|)
condition|?
name|AR5416_NUM_2G_20_TARGET_POWERS
else|:
name|AR5416_4K_NUM_2G_20_TARGET_POWERS
expr_stmt|;
name|n2g40
operator|=
operator|(
name|pEepData
operator|)
condition|?
name|AR5416_NUM_2G_40_TARGET_POWERS
else|:
name|AR5416_4K_NUM_2G_40_TARGET_POWERS
expr_stmt|;
comment|/* Get target powers from EEPROM - our baseline for TX Power */
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* Setup for CTL modes */
name|numCtlModes
operator|=
name|N
argument_list|(
name|ctlModesFor11g
argument_list|)
operator|-
name|SUB_NUM_CTL_MODES_AT_2G_40
expr_stmt|;
comment|/* CTL_11B, CTL_11G, CTL_2GHT20 */
name|pCtlMode
operator|=
name|ctlModesFor11g
expr_stmt|;
name|ar5416GetTargetPowersLeg
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|(
name|pEepData
operator|)
condition|?
name|pEepData
operator|->
name|calTargetPowerCck
else|:
name|pEepData4k
operator|->
name|calTargetPowerCck
argument_list|,
name|n2gcck
argument_list|,
operator|&
name|targetPowerCck
argument_list|,
literal|4
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
name|ar5416GetTargetPowersLeg
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|(
name|pEepData
operator|)
condition|?
name|pEepData
operator|->
name|calTargetPower2G
else|:
name|pEepData4k
operator|->
name|calTargetPower2G
argument_list|,
name|n2g20
argument_list|,
operator|&
name|targetPowerOfdm
argument_list|,
literal|4
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
name|ar5416GetTargetPowers
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|(
name|pEepData
operator|)
condition|?
name|pEepData
operator|->
name|calTargetPower2GHT20
else|:
name|pEepData4k
operator|->
name|calTargetPower2GHT20
argument_list|,
name|n2g20
argument_list|,
operator|&
name|targetPowerHt20
argument_list|,
literal|8
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|numCtlModes
operator|=
name|N
argument_list|(
name|ctlModesFor11g
argument_list|)
expr_stmt|;
comment|/* All 2G CTL's */
name|ar5416GetTargetPowers
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|(
name|pEepData
operator|)
condition|?
name|pEepData
operator|->
name|calTargetPower2GHT40
else|:
name|pEepData4k
operator|->
name|calTargetPower2GHT40
argument_list|,
name|n2g40
argument_list|,
operator|&
name|targetPowerHt40
argument_list|,
literal|8
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
comment|/* Get target powers for extension channels */
name|ar5416GetTargetPowersLeg
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|(
name|pEepData
operator|)
condition|?
name|pEepData
operator|->
name|calTargetPowerCck
else|:
name|pEepData4k
operator|->
name|calTargetPowerCck
argument_list|,
name|n2gcck
argument_list|,
operator|&
name|targetPowerCckExt
argument_list|,
literal|4
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
name|ar5416GetTargetPowersLeg
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|(
name|pEepData
operator|)
condition|?
name|pEepData
operator|->
name|calTargetPower2G
else|:
name|pEepData4k
operator|->
name|calTargetPower2G
argument_list|,
name|n2g20
argument_list|,
operator|&
name|targetPowerOfdmExt
argument_list|,
literal|4
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Setup for CTL modes */
name|numCtlModes
operator|=
name|N
argument_list|(
name|ctlModesFor11a
argument_list|)
operator|-
name|SUB_NUM_CTL_MODES_AT_5G_40
expr_stmt|;
comment|/* CTL_11A, CTL_5GHT20 */
name|pCtlMode
operator|=
name|ctlModesFor11a
expr_stmt|;
comment|/* NB: v4k EEPROM has no 5Ghz info */
name|ar5416GetTargetPowersLeg
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|pEepData
operator|->
name|calTargetPower5G
argument_list|,
name|AR5416_NUM_5G_20_TARGET_POWERS
argument_list|,
operator|&
name|targetPowerOfdm
argument_list|,
literal|4
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
name|ar5416GetTargetPowers
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|pEepData
operator|->
name|calTargetPower5GHT20
argument_list|,
name|AR5416_NUM_5G_20_TARGET_POWERS
argument_list|,
operator|&
name|targetPowerHt20
argument_list|,
literal|8
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|numCtlModes
operator|=
name|N
argument_list|(
name|ctlModesFor11a
argument_list|)
expr_stmt|;
comment|/* All 5G CTL's */
name|ar5416GetTargetPowers
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|pEepData
operator|->
name|calTargetPower5GHT40
argument_list|,
name|AR5416_NUM_5G_40_TARGET_POWERS
argument_list|,
operator|&
name|targetPowerHt40
argument_list|,
literal|8
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
name|ar5416GetTargetPowersLeg
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|pEepData
operator|->
name|calTargetPower5G
argument_list|,
name|AR5416_NUM_5G_20_TARGET_POWERS
argument_list|,
operator|&
name|targetPowerOfdmExt
argument_list|,
literal|4
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * For MIMO, need to apply regulatory caps individually across dynamically 	 * running modes: CCK, OFDM, HT20, HT40 	 * 	 * The outer loop walks through each possible applicable runtime mode. 	 * The inner loop walks through each ctlIndex entry in EEPROM. 	 * The ctl value is encoded as [7:4] == test group, [3:0] == test mode. 	 * 	 */
name|numctls
operator|=
operator|(
name|pEepData
operator|)
condition|?
name|AR5416_NUM_CTLS
else|:
name|AR5416_4K_NUM_CTLS
expr_stmt|;
for|for
control|(
name|ctlMode
operator|=
literal|0
init|;
name|ctlMode
operator|<
name|numCtlModes
condition|;
name|ctlMode
operator|++
control|)
block|{
name|int
name|ctlIndex
decl_stmt|;
name|HAL_BOOL
name|isHt40CtlMode
init|=
operator|(
name|pCtlMode
index|[
name|ctlMode
index|]
operator|==
name|CTL_5GHT40
operator|)
operator|||
operator|(
name|pCtlMode
index|[
name|ctlMode
index|]
operator|==
name|CTL_2GHT40
operator|)
decl_stmt|;
if|if
condition|(
name|isHt40CtlMode
condition|)
block|{
name|freq
operator|=
name|centers
operator|.
name|ctl_center
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pCtlMode
index|[
name|ctlMode
index|]
operator|&
name|EXT_ADDITIVE
condition|)
block|{
name|freq
operator|=
name|centers
operator|.
name|ext_center
expr_stmt|;
block|}
else|else
block|{
name|freq
operator|=
name|centers
operator|.
name|ctl_center
expr_stmt|;
block|}
name|ctlIndex
operator|=
operator|(
name|pEepData
operator|)
condition|?
name|pEepData
operator|->
name|ctlIndex
index|[
literal|0
index|]
else|:
name|pEepData4k
operator|->
name|ctlIndex
index|[
literal|0
index|]
expr_stmt|;
comment|/* walk through each CTL index stored in EEPROM */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|numctls
operator|)
operator|&&
name|ctlIndex
condition|;
name|i
operator|++
control|)
block|{
name|uint16_t
name|twiceMinEdgePower
decl_stmt|;
name|CAL_CTL_EDGES
modifier|*
name|ctlEdge
decl_stmt|;
name|ctlIndex
operator|=
operator|(
name|pEepData
operator|)
condition|?
name|pEepData
operator|->
name|ctlIndex
index|[
name|i
index|]
else|:
name|pEepData4k
operator|->
name|ctlIndex
index|[
name|i
index|]
expr_stmt|;
comment|/* compare test group from regulatory channel list with test mode from pCtlMode list */
if|if
condition|(
operator|(
operator|(
operator|(
name|cfgCtl
operator|&
operator|~
name|CTL_MODE_M
operator|)
operator||
operator|(
name|pCtlMode
index|[
name|ctlMode
index|]
operator|&
name|CTL_MODE_M
operator|)
operator|)
operator|==
name|ctlIndex
operator|)
operator|||
operator|(
operator|(
operator|(
name|cfgCtl
operator|&
operator|~
name|CTL_MODE_M
operator|)
operator||
operator|(
name|pCtlMode
index|[
name|ctlMode
index|]
operator|&
name|CTL_MODE_M
operator|)
operator|)
operator|==
operator|(
operator|(
name|ctlIndex
operator|&
name|CTL_MODE_M
operator|)
operator||
name|SD_NO_CTL
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|pEepData
condition|)
block|{
name|rep
operator|=
operator|&
operator|(
name|pEepData
operator|->
name|ctlData
index|[
name|i
index|]
operator|)
expr_stmt|;
name|ctlEdge
operator|=
name|rep
operator|->
name|ctlEdges
index|[
name|owl_get_ntxchains
argument_list|(
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tx_chainmask
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|rep4k
operator|=
operator|&
operator|(
name|pEepData4k
operator|->
name|ctlData
index|[
name|i
index|]
operator|)
expr_stmt|;
name|ctlEdge
operator|=
name|rep4k
operator|->
name|ctlEdges
index|[
name|owl_get_ntxchains
argument_list|(
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tx_chainmask
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|twiceMinEdgePower
operator|=
name|ar5416GetMaxEdgePower
argument_list|(
name|ah
argument_list|,
name|freq
argument_list|,
name|ctlEdge
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cfgCtl
operator|&
operator|~
name|CTL_MODE_M
operator|)
operator|==
name|SD_NO_CTL
condition|)
block|{
comment|/* Find the minimum of all CTL edge powers that apply to this channel */
name|twiceMaxEdgePower
operator|=
name|AH_MIN
argument_list|(
name|twiceMaxEdgePower
argument_list|,
name|twiceMinEdgePower
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* specific */
name|twiceMaxEdgePower
operator|=
name|twiceMinEdgePower
expr_stmt|;
break|break;
block|}
block|}
block|}
name|minCtlPower
operator|=
operator|(
name|uint8_t
operator|)
name|AH_MIN
argument_list|(
name|twiceMaxEdgePower
argument_list|,
name|scaledPower
argument_list|)
expr_stmt|;
comment|/* Apply ctl mode to correct target power set */
switch|switch
condition|(
name|pCtlMode
index|[
name|ctlMode
index|]
condition|)
block|{
case|case
name|CTL_11B
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|targetPowerCck
operator|.
name|tPow2x
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|targetPowerCck
operator|.
name|tPow2x
index|[
name|i
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|AH_MIN
argument_list|(
name|targetPowerCck
operator|.
name|tPow2x
index|[
name|i
index|]
argument_list|,
name|minCtlPower
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTL_11A
case|:
case|case
name|CTL_11G
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|targetPowerOfdm
operator|.
name|tPow2x
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|targetPowerOfdm
operator|.
name|tPow2x
index|[
name|i
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|AH_MIN
argument_list|(
name|targetPowerOfdm
operator|.
name|tPow2x
index|[
name|i
index|]
argument_list|,
name|minCtlPower
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTL_5GHT20
case|:
case|case
name|CTL_2GHT20
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|targetPowerHt20
operator|.
name|tPow2x
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|targetPowerHt20
operator|.
name|tPow2x
index|[
name|i
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|AH_MIN
argument_list|(
name|targetPowerHt20
operator|.
name|tPow2x
index|[
name|i
index|]
argument_list|,
name|minCtlPower
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTL_11B_EXT
case|:
name|targetPowerCckExt
operator|.
name|tPow2x
index|[
literal|0
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|AH_MIN
argument_list|(
name|targetPowerCckExt
operator|.
name|tPow2x
index|[
literal|0
index|]
argument_list|,
name|minCtlPower
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_11A_EXT
case|:
case|case
name|CTL_11G_EXT
case|:
name|targetPowerOfdmExt
operator|.
name|tPow2x
index|[
literal|0
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|AH_MIN
argument_list|(
name|targetPowerOfdmExt
operator|.
name|tPow2x
index|[
literal|0
index|]
argument_list|,
name|minCtlPower
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_5GHT40
case|:
case|case
name|CTL_2GHT40
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|targetPowerHt40
operator|.
name|tPow2x
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|targetPowerHt40
operator|.
name|tPow2x
index|[
name|i
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|AH_MIN
argument_list|(
name|targetPowerHt40
operator|.
name|tPow2x
index|[
name|i
index|]
argument_list|,
name|minCtlPower
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|AH_FALSE
return|;
break|break;
block|}
block|}
comment|/* end ctl mode checking */
comment|/* Set rates Array from collected data */
name|ratesArray
index|[
name|rate6mb
index|]
operator|=
name|ratesArray
index|[
name|rate9mb
index|]
operator|=
name|ratesArray
index|[
name|rate12mb
index|]
operator|=
name|ratesArray
index|[
name|rate18mb
index|]
operator|=
name|ratesArray
index|[
name|rate24mb
index|]
operator|=
name|targetPowerOfdm
operator|.
name|tPow2x
index|[
literal|0
index|]
expr_stmt|;
name|ratesArray
index|[
name|rate36mb
index|]
operator|=
name|targetPowerOfdm
operator|.
name|tPow2x
index|[
literal|1
index|]
expr_stmt|;
name|ratesArray
index|[
name|rate48mb
index|]
operator|=
name|targetPowerOfdm
operator|.
name|tPow2x
index|[
literal|2
index|]
expr_stmt|;
name|ratesArray
index|[
name|rate54mb
index|]
operator|=
name|targetPowerOfdm
operator|.
name|tPow2x
index|[
literal|3
index|]
expr_stmt|;
name|ratesArray
index|[
name|rateXr
index|]
operator|=
name|targetPowerOfdm
operator|.
name|tPow2x
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|targetPowerHt20
operator|.
name|tPow2x
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ratesArray
index|[
name|rateHt20_0
operator|+
name|i
index|]
operator|=
name|targetPowerHt20
operator|.
name|tPow2x
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|ratesArray
index|[
name|rate1l
index|]
operator|=
name|targetPowerCck
operator|.
name|tPow2x
index|[
literal|0
index|]
expr_stmt|;
name|ratesArray
index|[
name|rate2s
index|]
operator|=
name|ratesArray
index|[
name|rate2l
index|]
operator|=
name|targetPowerCck
operator|.
name|tPow2x
index|[
literal|1
index|]
expr_stmt|;
name|ratesArray
index|[
name|rate5_5s
index|]
operator|=
name|ratesArray
index|[
name|rate5_5l
index|]
operator|=
name|targetPowerCck
operator|.
name|tPow2x
index|[
literal|2
index|]
expr_stmt|;
name|ratesArray
index|[
name|rate11s
index|]
operator|=
name|ratesArray
index|[
name|rate11l
index|]
operator|=
name|targetPowerCck
operator|.
name|tPow2x
index|[
literal|3
index|]
expr_stmt|;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|targetPowerHt40
operator|.
name|tPow2x
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ratesArray
index|[
name|rateHt40_0
operator|+
name|i
index|]
operator|=
name|targetPowerHt40
operator|.
name|tPow2x
index|[
name|i
index|]
expr_stmt|;
block|}
name|ratesArray
index|[
name|rateDupOfdm
index|]
operator|=
name|targetPowerHt40
operator|.
name|tPow2x
index|[
literal|0
index|]
expr_stmt|;
name|ratesArray
index|[
name|rateDupCck
index|]
operator|=
name|targetPowerHt40
operator|.
name|tPow2x
index|[
literal|0
index|]
expr_stmt|;
name|ratesArray
index|[
name|rateExtOfdm
index|]
operator|=
name|targetPowerOfdmExt
operator|.
name|tPow2x
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|ratesArray
index|[
name|rateExtCck
index|]
operator|=
name|targetPowerCckExt
operator|.
name|tPow2x
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|EXT_ADDITIVE
undef|#
directive|undef
name|CTL_11A_EXT
undef|#
directive|undef
name|CTL_11G_EXT
undef|#
directive|undef
name|CTL_11B_EXT
undef|#
directive|undef
name|SUB_NUM_CTL_MODES_AT_5G_40
undef|#
directive|undef
name|SUB_NUM_CTL_MODES_AT_2G_40
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/**************************************************************************  * fbin2freq  *  * Get channel value from binary representation held in eeprom  * RETURNS: the frequency in MHz  */
end_comment

begin_function
specifier|static
name|uint16_t
name|fbin2freq
parameter_list|(
name|uint8_t
name|fbin
parameter_list|,
name|HAL_BOOL
name|is2GHz
parameter_list|)
block|{
comment|/*      * Reserved value 0xFF provides an empty definition both as      * an fbin and as a frequency - do not convert      */
if|if
condition|(
name|fbin
operator|==
name|AR5416_BCHAN_UNUSED
condition|)
block|{
return|return
name|fbin
return|;
block|}
return|return
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|is2GHz
operator|)
condition|?
operator|(
literal|2300
operator|+
name|fbin
operator|)
else|:
operator|(
literal|4800
operator|+
literal|5
operator|*
name|fbin
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ar5416GetMaxEdgePower  *  * Find the maximum conformance test limit for the given channel and CTL info  */
end_comment

begin_function
specifier|static
name|uint16_t
name|ar5416GetMaxEdgePower
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint16_t
name|freq
parameter_list|,
name|CAL_CTL_EDGES
modifier|*
name|pRdEdgesPower
parameter_list|,
name|HAL_BOOL
name|is2GHz
parameter_list|)
block|{
name|uint16_t
name|twiceMaxEdgePower
init|=
name|AR5416_MAX_RATE_POWER
decl_stmt|;
name|int
name|i
decl_stmt|,
name|numBand
decl_stmt|;
if|if
condition|(
name|AR_SREV_KITE
argument_list|(
name|ah
argument_list|)
condition|)
name|numBand
operator|=
name|AR5416_4K_NUM_BAND_EDGES
expr_stmt|;
else|else
name|numBand
operator|=
name|AR5416_NUM_BAND_EDGES
expr_stmt|;
comment|/* Get the edge power */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|numBand
operator|)
operator|&&
operator|(
name|pRdEdgesPower
index|[
name|i
index|]
operator|.
name|bChannel
operator|!=
name|AR5416_BCHAN_UNUSED
operator|)
condition|;
name|i
operator|++
control|)
block|{
comment|/*          * If there's an exact channel match or an inband flag set          * on the lower channel use the given rdEdgePower          */
if|if
condition|(
name|freq
operator|==
name|fbin2freq
argument_list|(
name|pRdEdgesPower
index|[
name|i
index|]
operator|.
name|bChannel
argument_list|,
name|is2GHz
argument_list|)
condition|)
block|{
name|twiceMaxEdgePower
operator|=
name|MS
argument_list|(
name|pRdEdgesPower
index|[
name|i
index|]
operator|.
name|tPowerFlag
argument_list|,
name|CAL_CTL_EDGES_POWER
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
operator|(
name|freq
operator|<
name|fbin2freq
argument_list|(
name|pRdEdgesPower
index|[
name|i
index|]
operator|.
name|bChannel
argument_list|,
name|is2GHz
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|fbin2freq
argument_list|(
name|pRdEdgesPower
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|bChannel
argument_list|,
name|is2GHz
argument_list|)
operator|<
name|freq
operator|&&
operator|(
name|pRdEdgesPower
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|tPowerFlag
operator|&
name|CAL_CTL_EDGES_FLAG
operator|)
operator|!=
literal|0
condition|)
block|{
name|twiceMaxEdgePower
operator|=
name|MS
argument_list|(
name|pRdEdgesPower
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|tPowerFlag
argument_list|,
name|CAL_CTL_EDGES_POWER
argument_list|)
expr_stmt|;
block|}
comment|/* Leave loop - no more affecting edges possible in this monotonic increasing list */
break|break;
block|}
block|}
name|HALASSERT
argument_list|(
name|twiceMaxEdgePower
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
name|twiceMaxEdgePower
return|;
block|}
end_function

begin_comment
comment|/**************************************************************  * ar5416GetTargetPowers  *  * Return the rates of target power for the given target power table  * channel, and number of channels  */
end_comment

begin_function
specifier|static
name|void
name|ar5416GetTargetPowers
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|CAL_TARGET_POWER_HT
modifier|*
name|powInfo
parameter_list|,
name|uint16_t
name|numChannels
parameter_list|,
name|CAL_TARGET_POWER_HT
modifier|*
name|pNewPower
parameter_list|,
name|uint16_t
name|numRates
parameter_list|,
name|HAL_BOOL
name|isHt40Target
parameter_list|)
block|{
name|uint16_t
name|clo
decl_stmt|,
name|chi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|matchIndex
init|=
operator|-
literal|1
decl_stmt|,
name|lowIndex
init|=
operator|-
literal|1
decl_stmt|;
name|uint16_t
name|freq
decl_stmt|;
name|CHAN_CENTERS
name|centers
decl_stmt|;
name|ar5416GetChannelCenters
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|&
name|centers
argument_list|)
expr_stmt|;
name|freq
operator|=
name|isHt40Target
condition|?
name|centers
operator|.
name|synth_center
else|:
name|centers
operator|.
name|ctl_center
expr_stmt|;
comment|/* Copy the target powers into the temp channel list */
if|if
condition|(
name|freq
operator|<=
name|fbin2freq
argument_list|(
name|powInfo
index|[
literal|0
index|]
operator|.
name|bChannel
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
condition|)
block|{
name|matchIndex
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|numChannels
operator|)
operator|&&
operator|(
name|powInfo
index|[
name|i
index|]
operator|.
name|bChannel
operator|!=
name|AR5416_BCHAN_UNUSED
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|freq
operator|==
name|fbin2freq
argument_list|(
name|powInfo
index|[
name|i
index|]
operator|.
name|bChannel
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
condition|)
block|{
name|matchIndex
operator|=
name|i
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|freq
operator|<
name|fbin2freq
argument_list|(
name|powInfo
index|[
name|i
index|]
operator|.
name|bChannel
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|freq
operator|>
name|fbin2freq
argument_list|(
name|powInfo
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|bChannel
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|lowIndex
operator|=
name|i
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|matchIndex
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|lowIndex
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|HALASSERT
argument_list|(
name|freq
operator|>
name|fbin2freq
argument_list|(
name|powInfo
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|bChannel
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|matchIndex
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|matchIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|OS_MEMCPY
argument_list|(
name|pNewPower
argument_list|,
operator|&
name|powInfo
index|[
name|matchIndex
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pNewPower
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HALASSERT
argument_list|(
name|lowIndex
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*          * Get the lower and upper channels, target powers,          * and interpolate between them.          */
name|clo
operator|=
name|fbin2freq
argument_list|(
name|powInfo
index|[
name|lowIndex
index|]
operator|.
name|bChannel
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
name|chi
operator|=
name|fbin2freq
argument_list|(
name|powInfo
index|[
name|lowIndex
operator|+
literal|1
index|]
operator|.
name|bChannel
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numRates
condition|;
name|i
operator|++
control|)
block|{
name|pNewPower
operator|->
name|tPow2x
index|[
name|i
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|interpolate
argument_list|(
name|freq
argument_list|,
name|clo
argument_list|,
name|chi
argument_list|,
name|powInfo
index|[
name|lowIndex
index|]
operator|.
name|tPow2x
index|[
name|i
index|]
argument_list|,
name|powInfo
index|[
name|lowIndex
operator|+
literal|1
index|]
operator|.
name|tPow2x
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**************************************************************  * ar5416GetTargetPowersLeg  *  * Return the four rates of target power for the given target power table  * channel, and number of channels  */
end_comment

begin_function
specifier|static
name|void
name|ar5416GetTargetPowersLeg
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|CAL_TARGET_POWER_LEG
modifier|*
name|powInfo
parameter_list|,
name|uint16_t
name|numChannels
parameter_list|,
name|CAL_TARGET_POWER_LEG
modifier|*
name|pNewPower
parameter_list|,
name|uint16_t
name|numRates
parameter_list|,
name|HAL_BOOL
name|isExtTarget
parameter_list|)
block|{
name|uint16_t
name|clo
decl_stmt|,
name|chi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|matchIndex
init|=
operator|-
literal|1
decl_stmt|,
name|lowIndex
init|=
operator|-
literal|1
decl_stmt|;
name|uint16_t
name|freq
decl_stmt|;
name|CHAN_CENTERS
name|centers
decl_stmt|;
name|ar5416GetChannelCenters
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|&
name|centers
argument_list|)
expr_stmt|;
name|freq
operator|=
operator|(
name|isExtTarget
operator|)
condition|?
name|centers
operator|.
name|ext_center
else|:
name|centers
operator|.
name|ctl_center
expr_stmt|;
comment|/* Copy the target powers into the temp channel list */
if|if
condition|(
name|freq
operator|<=
name|fbin2freq
argument_list|(
name|powInfo
index|[
literal|0
index|]
operator|.
name|bChannel
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
condition|)
block|{
name|matchIndex
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|numChannels
operator|)
operator|&&
operator|(
name|powInfo
index|[
name|i
index|]
operator|.
name|bChannel
operator|!=
name|AR5416_BCHAN_UNUSED
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|freq
operator|==
name|fbin2freq
argument_list|(
name|powInfo
index|[
name|i
index|]
operator|.
name|bChannel
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
condition|)
block|{
name|matchIndex
operator|=
name|i
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|freq
operator|<
name|fbin2freq
argument_list|(
name|powInfo
index|[
name|i
index|]
operator|.
name|bChannel
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|freq
operator|>
name|fbin2freq
argument_list|(
name|powInfo
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|bChannel
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|lowIndex
operator|=
name|i
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|matchIndex
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|lowIndex
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|HALASSERT
argument_list|(
name|freq
operator|>
name|fbin2freq
argument_list|(
name|powInfo
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|bChannel
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|matchIndex
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|matchIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|OS_MEMCPY
argument_list|(
name|pNewPower
argument_list|,
operator|&
name|powInfo
index|[
name|matchIndex
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pNewPower
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HALASSERT
argument_list|(
name|lowIndex
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*          * Get the lower and upper channels, target powers,          * and interpolate between them.          */
name|clo
operator|=
name|fbin2freq
argument_list|(
name|powInfo
index|[
name|lowIndex
index|]
operator|.
name|bChannel
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
name|chi
operator|=
name|fbin2freq
argument_list|(
name|powInfo
index|[
name|lowIndex
operator|+
literal|1
index|]
operator|.
name|bChannel
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numRates
condition|;
name|i
operator|++
control|)
block|{
name|pNewPower
operator|->
name|tPow2x
index|[
name|i
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|interpolate
argument_list|(
name|freq
argument_list|,
name|clo
argument_list|,
name|chi
argument_list|,
name|powInfo
index|[
name|lowIndex
index|]
operator|.
name|tPow2x
index|[
name|i
index|]
argument_list|,
name|powInfo
index|[
name|lowIndex
operator|+
literal|1
index|]
operator|.
name|tPow2x
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**************************************************************  * ar5416SetPowerCalTable  *  * Pull the PDADC piers from cal data and interpolate them across the given  * points as well as from the nearest pier(s) to get a power detector  * linear voltage to power level table.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5416SetPowerCalTable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ar5416eeprom
modifier|*
name|pEepData
parameter_list|,
name|struct
name|ar5416eeprom_4k
modifier|*
name|pEepData4k
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|int16_t
modifier|*
name|pTxPowerIndexOffset
parameter_list|)
block|{
name|CAL_DATA_PER_FREQ
modifier|*
name|pRawDataset
init|=
name|NULL
decl_stmt|;
name|CAL_DATA_PER_FREQ_4K
modifier|*
name|pRawDataset4k
init|=
name|NULL
decl_stmt|;
name|uint8_t
modifier|*
name|pCalBChans
init|=
name|AH_NULL
decl_stmt|;
name|uint16_t
name|pdGainOverlap_t2
decl_stmt|;
specifier|static
name|uint8_t
name|pdadcValues
index|[
name|AR5416_NUM_PDADC_VALUES
index|]
decl_stmt|;
name|uint16_t
name|gainBoundaries
index|[
name|AR5416_PD_GAINS_IN_MASK
index|]
decl_stmt|;
name|uint16_t
name|numPiers
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int16_t
name|tMinCalPower
decl_stmt|;
name|uint16_t
name|numXpdGain
decl_stmt|,
name|xpdMask
decl_stmt|;
name|uint16_t
name|xpdGainValues
index|[
name|AR5416_NUM_PD_GAINS
index|]
decl_stmt|;
name|uint32_t
name|reg32
decl_stmt|,
name|regOffset
decl_stmt|,
name|regChainOffset
decl_stmt|;
name|OS_MEMZERO
argument_list|(
name|xpdGainValues
argument_list|,
sizeof|sizeof
argument_list|(
name|xpdGainValues
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pEepData
condition|)
name|xpdMask
operator|=
name|pEepData
operator|->
name|modalHeader
index|[
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
index|]
operator|.
name|xpdGain
expr_stmt|;
else|else
name|xpdMask
operator|=
name|pEepData4k
operator|->
name|modalHeader
operator|.
name|xpdGain
expr_stmt|;
if|if
condition|(
name|IS_EEP_MINOR_V2
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|pEepData
condition|)
name|pdGainOverlap_t2
operator|=
name|pEepData
operator|->
name|modalHeader
index|[
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
index|]
operator|.
name|pdGainOverlap
expr_stmt|;
else|else
name|pdGainOverlap_t2
operator|=
name|pEepData4k
operator|->
name|modalHeader
operator|.
name|pdGainOverlap
expr_stmt|;
block|}
else|else
block|{
name|pdGainOverlap_t2
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPCRG5
argument_list|)
argument_list|,
name|AR_PHY_TPCRG5_PD_GAIN_OVERLAP
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
if|if
condition|(
name|pEepData
condition|)
block|{
name|pCalBChans
operator|=
name|pEepData
operator|->
name|calFreqPier2G
expr_stmt|;
name|numPiers
operator|=
name|AR5416_NUM_2G_CAL_PIERS
expr_stmt|;
block|}
else|else
block|{
name|pCalBChans
operator|=
name|pEepData4k
operator|->
name|calFreqPier2G
expr_stmt|;
name|numPiers
operator|=
name|AR5416_4K_NUM_2G_CAL_PIERS
expr_stmt|;
block|}
block|}
else|else
block|{
name|pCalBChans
operator|=
name|pEepData
operator|->
name|calFreqPier5G
expr_stmt|;
name|numPiers
operator|=
name|AR5416_NUM_5G_CAL_PIERS
expr_stmt|;
block|}
name|numXpdGain
operator|=
literal|0
expr_stmt|;
comment|/* Calculate the value of xpdgains from the xpdGain Mask */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|AR5416_PD_GAINS_IN_MASK
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|xpdMask
operator|>>
operator|(
name|AR5416_PD_GAINS_IN_MASK
operator|-
name|i
operator|)
operator|)
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|numXpdGain
operator|>=
name|AR5416_NUM_PD_GAINS
condition|)
block|{
name|HALASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|xpdGainValues
index|[
name|numXpdGain
index|]
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|AR5416_PD_GAINS_IN_MASK
operator|-
name|i
argument_list|)
expr_stmt|;
name|numXpdGain
operator|++
expr_stmt|;
block|}
block|}
comment|/* Write the detector gain biases and their number */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPCRG1
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPCRG1
argument_list|)
operator|&
operator|~
operator|(
name|AR_PHY_TPCRG1_NUM_PD_GAIN
operator||
name|AR_PHY_TPCRG1_PD_GAIN_1
operator||
name|AR_PHY_TPCRG1_PD_GAIN_2
operator||
name|AR_PHY_TPCRG1_PD_GAIN_3
operator|)
operator|)
operator||
name|SM
argument_list|(
name|numXpdGain
operator|-
literal|1
argument_list|,
name|AR_PHY_TPCRG1_NUM_PD_GAIN
argument_list|)
operator||
name|SM
argument_list|(
name|xpdGainValues
index|[
literal|0
index|]
argument_list|,
name|AR_PHY_TPCRG1_PD_GAIN_1
argument_list|)
operator||
name|SM
argument_list|(
name|xpdGainValues
index|[
literal|1
index|]
argument_list|,
name|AR_PHY_TPCRG1_PD_GAIN_2
argument_list|)
operator||
name|SM
argument_list|(
name|xpdGainValues
index|[
literal|2
index|]
argument_list|,
name|AR_PHY_TPCRG1_PD_GAIN_3
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR5416_MAX_CHAINS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|AR_SREV_KITE
argument_list|(
name|ah
argument_list|)
operator|&&
name|i
operator|>=
name|AR5416_4K_MAX_CHAINS
condition|)
break|break;
if|if
condition|(
name|AR_SREV_OWL_20_OR_LATER
argument_list|(
name|ah
argument_list|)
operator|&&
operator|(
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rx_chainmask
operator|==
literal|0x5
operator|||
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tx_chainmask
operator|==
literal|0x5
operator|)
operator|&&
operator|(
name|i
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* Regs are swapped from chain 2 to 1 for 5416 2_0 with               * only chains 0 and 2 populated               */
name|regChainOffset
operator|=
operator|(
name|i
operator|==
literal|1
operator|)
condition|?
literal|0x2000
else|:
literal|0x1000
expr_stmt|;
block|}
else|else
block|{
name|regChainOffset
operator|=
name|i
operator|*
literal|0x1000
expr_stmt|;
block|}
name|int
name|txMask
decl_stmt|;
name|txMask
operator|=
operator|(
name|pEepData
operator|)
condition|?
name|pEepData
operator|->
name|baseEepHeader
operator|.
name|txMask
else|:
name|pEepData4k
operator|->
name|baseEepHeader
operator|.
name|txMask
expr_stmt|;
if|if
condition|(
name|txMask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
if|if
condition|(
name|pEepData
condition|)
name|pRawDataset
operator|=
name|pEepData
operator|->
name|calPierData2G
index|[
name|i
index|]
expr_stmt|;
else|else
name|pRawDataset4k
operator|=
name|pEepData4k
operator|->
name|calPierData2G
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|pRawDataset
operator|=
name|pEepData
operator|->
name|calPierData5G
index|[
name|i
index|]
expr_stmt|;
block|}
name|ar5416GetGainBoundariesAndPdadcs
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|pRawDataset
argument_list|,
name|pRawDataset4k
argument_list|,
name|pCalBChans
argument_list|,
name|numPiers
argument_list|,
name|pdGainOverlap_t2
argument_list|,
operator|&
name|tMinCalPower
argument_list|,
name|gainBoundaries
argument_list|,
name|pdadcValues
argument_list|,
name|numXpdGain
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|||
name|AR_SREV_OWL_20_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/*                  * Note the pdadc table may not start at 0 dBm power, could be                  * negative or greater than 0.  Need to offset the power                  * values by the amount of minPower for griffin                  */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPCRG5
operator|+
name|regChainOffset
argument_list|,
name|SM
argument_list|(
name|pdGainOverlap_t2
argument_list|,
name|AR_PHY_TPCRG5_PD_GAIN_OVERLAP
argument_list|)
operator||
name|SM
argument_list|(
name|gainBoundaries
index|[
literal|0
index|]
argument_list|,
name|AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_1
argument_list|)
operator||
name|SM
argument_list|(
name|gainBoundaries
index|[
literal|1
index|]
argument_list|,
name|AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_2
argument_list|)
operator||
name|SM
argument_list|(
name|gainBoundaries
index|[
literal|2
index|]
argument_list|,
name|AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_3
argument_list|)
operator||
name|SM
argument_list|(
name|gainBoundaries
index|[
literal|3
index|]
argument_list|,
name|AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_4
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Write the power values into the baseband power table */
name|regOffset
operator|=
name|AR_PHY_BASE
operator|+
operator|(
literal|672
operator|<<
literal|2
operator|)
operator|+
name|regChainOffset
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
block|{
name|reg32
operator|=
operator|(
operator|(
name|pdadcValues
index|[
literal|4
operator|*
name|j
operator|+
literal|0
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|0
operator|)
operator||
operator|(
operator|(
name|pdadcValues
index|[
literal|4
operator|*
name|j
operator|+
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|pdadcValues
index|[
literal|4
operator|*
name|j
operator|+
literal|2
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|pdadcValues
index|[
literal|4
operator|*
name|j
operator|+
literal|3
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|24
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|regOffset
argument_list|,
name|reg32
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PDADC_DUMP
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"PDADC: Chain %d | PDADC %3d Value %3d | PDADC %3d Value %3d | PDADC %3d Value %3d | PDADC %3d Value %3d |\n"
argument_list|,
name|i
argument_list|,
literal|4
operator|*
name|j
argument_list|,
name|pdadcValues
index|[
literal|4
operator|*
name|j
index|]
argument_list|,
literal|4
operator|*
name|j
operator|+
literal|1
argument_list|,
name|pdadcValues
index|[
literal|4
operator|*
name|j
operator|+
literal|1
index|]
argument_list|,
literal|4
operator|*
name|j
operator|+
literal|2
argument_list|,
name|pdadcValues
index|[
literal|4
operator|*
name|j
operator|+
literal|2
index|]
argument_list|,
literal|4
operator|*
name|j
operator|+
literal|3
argument_list|,
name|pdadcValues
index|[
literal|4
operator|*
name|j
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|regOffset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
operator|*
name|pTxPowerIndexOffset
operator|=
literal|0
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/**************************************************************  * ar5416GetGainBoundariesAndPdadcs  *  * Uses the data points read from EEPROM to reconstruct the pdadc power table  * Called by ar5416SetPowerCalTable only.  */
end_comment

begin_function
specifier|static
name|void
name|ar5416GetGainBoundariesAndPdadcs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|CAL_DATA_PER_FREQ
modifier|*
name|pRawDataSet
parameter_list|,
name|CAL_DATA_PER_FREQ_4K
modifier|*
name|pRawDataSet4k
parameter_list|,
name|uint8_t
modifier|*
name|bChans
parameter_list|,
name|uint16_t
name|availPiers
parameter_list|,
name|uint16_t
name|tPdGainOverlap
parameter_list|,
name|int16_t
modifier|*
name|pMinCalPower
parameter_list|,
name|uint16_t
modifier|*
name|pPdGainBoundaries
parameter_list|,
name|uint8_t
modifier|*
name|pPDADCValues
parameter_list|,
name|uint16_t
name|numXpdGains
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int16_t
name|ss
decl_stmt|;
comment|/* potentially -ve index for taking care of pdGainOverlap */
name|uint16_t
name|idxL
decl_stmt|,
name|idxR
decl_stmt|,
name|numPiers
decl_stmt|;
comment|/* Pier indexes */
comment|/* filled out Vpd table for all pdGains (chanL) */
specifier|static
name|uint8_t
name|vpdTableL
index|[
name|AR5416_NUM_PD_GAINS
index|]
index|[
name|AR5416_MAX_PWR_RANGE_IN_HALF_DB
index|]
decl_stmt|;
comment|/* filled out Vpd table for all pdGains (chanR) */
specifier|static
name|uint8_t
name|vpdTableR
index|[
name|AR5416_NUM_PD_GAINS
index|]
index|[
name|AR5416_MAX_PWR_RANGE_IN_HALF_DB
index|]
decl_stmt|;
comment|/* filled out Vpd table for all pdGains (interpolated) */
specifier|static
name|uint8_t
name|vpdTableI
index|[
name|AR5416_NUM_PD_GAINS
index|]
index|[
name|AR5416_MAX_PWR_RANGE_IN_HALF_DB
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|pVpdL
decl_stmt|,
modifier|*
name|pVpdR
decl_stmt|,
modifier|*
name|pPwrL
decl_stmt|,
modifier|*
name|pPwrR
decl_stmt|;
name|uint8_t
name|minPwrT4
index|[
name|AR5416_NUM_PD_GAINS
index|]
decl_stmt|;
name|uint8_t
name|maxPwrT4
index|[
name|AR5416_NUM_PD_GAINS
index|]
decl_stmt|;
name|int16_t
name|vpdStep
decl_stmt|;
name|int16_t
name|tmpVal
decl_stmt|;
name|uint16_t
name|sizeCurrVpdTable
decl_stmt|,
name|maxIndex
decl_stmt|,
name|tgtIndex
decl_stmt|;
name|HAL_BOOL
name|match
decl_stmt|;
name|int16_t
name|minDelta
init|=
literal|0
decl_stmt|;
name|CHAN_CENTERS
name|centers
decl_stmt|;
name|ar5416GetChannelCenters
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|&
name|centers
argument_list|)
expr_stmt|;
comment|/* Trim numPiers for the number of populated channel Piers */
for|for
control|(
name|numPiers
operator|=
literal|0
init|;
name|numPiers
operator|<
name|availPiers
condition|;
name|numPiers
operator|++
control|)
block|{
if|if
condition|(
name|bChans
index|[
name|numPiers
index|]
operator|==
name|AR5416_BCHAN_UNUSED
condition|)
block|{
break|break;
block|}
block|}
comment|/* Find pier indexes around the current channel */
name|match
operator|=
name|getLowerUpperIndex
argument_list|(
operator|(
name|uint8_t
operator|)
name|FREQ2FBIN
argument_list|(
name|centers
operator|.
name|synth_center
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
argument_list|,
name|bChans
argument_list|,
name|numPiers
argument_list|,
operator|&
name|idxL
argument_list|,
operator|&
name|idxR
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
condition|)
block|{
comment|/* Directly fill both vpd tables from the matching index */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numXpdGains
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pRawDataSet
condition|)
block|{
name|minPwrT4
index|[
name|i
index|]
operator|=
name|pRawDataSet
index|[
name|idxL
index|]
operator|.
name|pwrPdg
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
name|maxPwrT4
index|[
name|i
index|]
operator|=
name|pRawDataSet
index|[
name|idxL
index|]
operator|.
name|pwrPdg
index|[
name|i
index|]
index|[
literal|4
index|]
expr_stmt|;
name|ar5416FillVpdTable
argument_list|(
name|minPwrT4
index|[
name|i
index|]
argument_list|,
name|maxPwrT4
index|[
name|i
index|]
argument_list|,
name|pRawDataSet
index|[
name|idxL
index|]
operator|.
name|pwrPdg
index|[
name|i
index|]
argument_list|,
name|pRawDataSet
index|[
name|idxL
index|]
operator|.
name|vpdPdg
index|[
name|i
index|]
argument_list|,
name|AR5416_PD_GAIN_ICEPTS
argument_list|,
name|vpdTableI
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|minPwrT4
index|[
name|i
index|]
operator|=
name|pRawDataSet4k
index|[
name|idxL
index|]
operator|.
name|pwrPdg
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
name|maxPwrT4
index|[
name|i
index|]
operator|=
name|pRawDataSet4k
index|[
name|idxL
index|]
operator|.
name|pwrPdg
index|[
name|i
index|]
index|[
literal|4
index|]
expr_stmt|;
name|ar5416FillVpdTable
argument_list|(
name|minPwrT4
index|[
name|i
index|]
argument_list|,
name|maxPwrT4
index|[
name|i
index|]
argument_list|,
name|pRawDataSet4k
index|[
name|idxL
index|]
operator|.
name|pwrPdg
index|[
name|i
index|]
argument_list|,
name|pRawDataSet4k
index|[
name|idxL
index|]
operator|.
name|vpdPdg
index|[
name|i
index|]
argument_list|,
name|AR5416_PD_GAIN_ICEPTS
argument_list|,
name|vpdTableI
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numXpdGains
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pRawDataSet
condition|)
block|{
name|pVpdL
operator|=
name|pRawDataSet
index|[
name|idxL
index|]
operator|.
name|vpdPdg
index|[
name|i
index|]
expr_stmt|;
name|pPwrL
operator|=
name|pRawDataSet
index|[
name|idxL
index|]
operator|.
name|pwrPdg
index|[
name|i
index|]
expr_stmt|;
name|pVpdR
operator|=
name|pRawDataSet
index|[
name|idxR
index|]
operator|.
name|vpdPdg
index|[
name|i
index|]
expr_stmt|;
name|pPwrR
operator|=
name|pRawDataSet
index|[
name|idxR
index|]
operator|.
name|pwrPdg
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|pVpdL
operator|=
name|pRawDataSet4k
index|[
name|idxL
index|]
operator|.
name|vpdPdg
index|[
name|i
index|]
expr_stmt|;
name|pPwrL
operator|=
name|pRawDataSet4k
index|[
name|idxL
index|]
operator|.
name|pwrPdg
index|[
name|i
index|]
expr_stmt|;
name|pVpdR
operator|=
name|pRawDataSet4k
index|[
name|idxR
index|]
operator|.
name|vpdPdg
index|[
name|i
index|]
expr_stmt|;
name|pPwrR
operator|=
name|pRawDataSet4k
index|[
name|idxR
index|]
operator|.
name|pwrPdg
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Start Vpd interpolation from the max of the minimum powers */
name|minPwrT4
index|[
name|i
index|]
operator|=
name|AH_MAX
argument_list|(
name|pPwrL
index|[
literal|0
index|]
argument_list|,
name|pPwrR
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* End Vpd interpolation from the min of the max powers */
name|maxPwrT4
index|[
name|i
index|]
operator|=
name|AH_MIN
argument_list|(
name|pPwrL
index|[
name|AR5416_PD_GAIN_ICEPTS
operator|-
literal|1
index|]
argument_list|,
name|pPwrR
index|[
name|AR5416_PD_GAIN_ICEPTS
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|maxPwrT4
index|[
name|i
index|]
operator|>
name|minPwrT4
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Fill pier Vpds */
name|ar5416FillVpdTable
argument_list|(
name|minPwrT4
index|[
name|i
index|]
argument_list|,
name|maxPwrT4
index|[
name|i
index|]
argument_list|,
name|pPwrL
argument_list|,
name|pVpdL
argument_list|,
name|AR5416_PD_GAIN_ICEPTS
argument_list|,
name|vpdTableL
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ar5416FillVpdTable
argument_list|(
name|minPwrT4
index|[
name|i
index|]
argument_list|,
name|maxPwrT4
index|[
name|i
index|]
argument_list|,
name|pPwrR
argument_list|,
name|pVpdR
argument_list|,
name|AR5416_PD_GAIN_ICEPTS
argument_list|,
name|vpdTableR
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Interpolate the final vpd */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
operator|(
name|maxPwrT4
index|[
name|i
index|]
operator|-
name|minPwrT4
index|[
name|i
index|]
operator|)
operator|/
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|vpdTableI
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|interpolate
argument_list|(
operator|(
name|uint16_t
operator|)
name|FREQ2FBIN
argument_list|(
name|centers
operator|.
name|synth_center
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
argument_list|,
name|bChans
index|[
name|idxL
index|]
argument_list|,
name|bChans
index|[
name|idxR
index|]
argument_list|,
name|vpdTableL
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|vpdTableR
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|pMinCalPower
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|minPwrT4
index|[
literal|0
index|]
operator|/
literal|2
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
comment|/* index for the final table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numXpdGains
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|numXpdGains
operator|-
literal|1
operator|)
condition|)
block|{
name|pPdGainBoundaries
index|[
name|i
index|]
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|maxPwrT4
index|[
name|i
index|]
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pPdGainBoundaries
index|[
name|i
index|]
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|maxPwrT4
index|[
name|i
index|]
operator|+
name|minPwrT4
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
name|pPdGainBoundaries
index|[
name|i
index|]
operator|=
operator|(
name|uint16_t
operator|)
name|AH_MIN
argument_list|(
name|AR5416_MAX_RATE_POWER
argument_list|,
name|pPdGainBoundaries
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* NB: only applies to owl 1.0 */
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
operator|!
name|AR_SREV_OWL_20_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/*              * fix the gain delta, but get a delta that can be applied to min to              * keep the upper power values accurate, don't think max needs to              * be adjusted because should not be at that area of the table? 	     */
name|minDelta
operator|=
name|pPdGainBoundaries
index|[
literal|0
index|]
operator|-
literal|23
expr_stmt|;
name|pPdGainBoundaries
index|[
literal|0
index|]
operator|=
literal|23
expr_stmt|;
block|}
else|else
block|{
name|minDelta
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Find starting index for this pdGain */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|ss
operator|=
literal|0
expr_stmt|;
comment|/* for the first pdGain, start from index 0 */
block|}
else|else
block|{
comment|/* need overlap entries extrapolated below. */
name|ss
operator|=
call|(
name|int16_t
call|)
argument_list|(
operator|(
name|pPdGainBoundaries
index|[
name|i
operator|-
literal|1
index|]
operator|-
operator|(
name|minPwrT4
index|[
name|i
index|]
operator|/
literal|2
operator|)
operator|)
operator|-
name|tPdGainOverlap
operator|+
literal|1
operator|+
name|minDelta
argument_list|)
expr_stmt|;
block|}
name|vpdStep
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|vpdTableI
index|[
name|i
index|]
index|[
literal|1
index|]
operator|-
name|vpdTableI
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|vpdStep
operator|=
call|(
name|int16_t
call|)
argument_list|(
operator|(
name|vpdStep
operator|<
literal|1
operator|)
condition|?
literal|1
else|:
name|vpdStep
argument_list|)
expr_stmt|;
comment|/*          *-ve ss indicates need to extrapolate data below for this pdGain          */
while|while
condition|(
operator|(
name|ss
operator|<
literal|0
operator|)
operator|&&
operator|(
name|k
operator|<
operator|(
name|AR5416_NUM_PDADC_VALUES
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|tmpVal
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|vpdTableI
index|[
name|i
index|]
index|[
literal|0
index|]
operator|+
name|ss
operator|*
name|vpdStep
argument_list|)
expr_stmt|;
name|pPDADCValues
index|[
name|k
operator|++
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|tmpVal
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|tmpVal
argument_list|)
expr_stmt|;
name|ss
operator|++
expr_stmt|;
block|}
name|sizeCurrVpdTable
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|maxPwrT4
index|[
name|i
index|]
operator|-
name|minPwrT4
index|[
name|i
index|]
operator|)
operator|/
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tgtIndex
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|pPdGainBoundaries
index|[
name|i
index|]
operator|+
name|tPdGainOverlap
operator|-
operator|(
name|minPwrT4
index|[
name|i
index|]
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
name|maxIndex
operator|=
operator|(
name|tgtIndex
operator|<
name|sizeCurrVpdTable
operator|)
condition|?
name|tgtIndex
else|:
name|sizeCurrVpdTable
expr_stmt|;
while|while
condition|(
operator|(
name|ss
operator|<
name|maxIndex
operator|)
operator|&&
operator|(
name|k
operator|<
operator|(
name|AR5416_NUM_PDADC_VALUES
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|pPDADCValues
index|[
name|k
operator|++
index|]
operator|=
name|vpdTableI
index|[
name|i
index|]
index|[
name|ss
operator|++
index|]
expr_stmt|;
block|}
name|vpdStep
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|vpdTableI
index|[
name|i
index|]
index|[
name|sizeCurrVpdTable
operator|-
literal|1
index|]
operator|-
name|vpdTableI
index|[
name|i
index|]
index|[
name|sizeCurrVpdTable
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|vpdStep
operator|=
call|(
name|int16_t
call|)
argument_list|(
operator|(
name|vpdStep
operator|<
literal|1
operator|)
condition|?
literal|1
else|:
name|vpdStep
argument_list|)
expr_stmt|;
comment|/*          * for last gain, pdGainBoundary == Pmax_t2, so will          * have to extrapolate          */
if|if
condition|(
name|tgtIndex
operator|>
name|maxIndex
condition|)
block|{
comment|/* need to extrapolate above */
while|while
condition|(
operator|(
name|ss
operator|<=
name|tgtIndex
operator|)
operator|&&
operator|(
name|k
operator|<
operator|(
name|AR5416_NUM_PDADC_VALUES
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|tmpVal
operator|=
call|(
name|int16_t
call|)
argument_list|(
operator|(
name|vpdTableI
index|[
name|i
index|]
index|[
name|sizeCurrVpdTable
operator|-
literal|1
index|]
operator|+
operator|(
name|ss
operator|-
name|maxIndex
operator|+
literal|1
operator|)
operator|*
name|vpdStep
operator|)
argument_list|)
expr_stmt|;
name|pPDADCValues
index|[
name|k
operator|++
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|tmpVal
operator|>
literal|255
operator|)
condition|?
literal|255
else|:
name|tmpVal
argument_list|)
expr_stmt|;
name|ss
operator|++
expr_stmt|;
block|}
block|}
comment|/* extrapolated above */
block|}
comment|/* for all pdGainUsed */
comment|/* Fill out pdGainBoundaries - only up to 2 allowed here, but hardware allows up to 4 */
while|while
condition|(
name|i
operator|<
name|AR5416_PD_GAINS_IN_MASK
condition|)
block|{
name|pPdGainBoundaries
index|[
name|i
index|]
operator|=
name|pPdGainBoundaries
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|k
operator|<
name|AR5416_NUM_PDADC_VALUES
condition|)
block|{
name|pPDADCValues
index|[
name|k
index|]
operator|=
name|pPDADCValues
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************  * getLowerUppderIndex  *  * Return indices surrounding the value in sorted integer lists.  * Requirement: the input list must be monotonically increasing  *     and populated up to the list size  * Returns: match is set if an index in the array matches exactly  *     or a the target is before or after the range of the array.  */
end_comment

begin_function
name|HAL_BOOL
name|getLowerUpperIndex
parameter_list|(
name|uint8_t
name|target
parameter_list|,
name|uint8_t
modifier|*
name|pList
parameter_list|,
name|uint16_t
name|listSize
parameter_list|,
name|uint16_t
modifier|*
name|indexL
parameter_list|,
name|uint16_t
modifier|*
name|indexR
parameter_list|)
block|{
name|uint16_t
name|i
decl_stmt|;
comment|/*      * Check first and last elements for beyond ordered array cases.      */
if|if
condition|(
name|target
operator|<=
name|pList
index|[
literal|0
index|]
condition|)
block|{
operator|*
name|indexL
operator|=
operator|*
name|indexR
operator|=
literal|0
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
if|if
condition|(
name|target
operator|>=
name|pList
index|[
name|listSize
operator|-
literal|1
index|]
condition|)
block|{
operator|*
name|indexL
operator|=
operator|*
name|indexR
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|listSize
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
comment|/* look for value being near or between 2 values in list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|listSize
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
comment|/*          * If value is close to the current value of the list          * then target is not between values, it is one of the values          */
if|if
condition|(
name|pList
index|[
name|i
index|]
operator|==
name|target
condition|)
block|{
operator|*
name|indexL
operator|=
operator|*
name|indexR
operator|=
name|i
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
comment|/*          * Look for value being between current value and next value          * if so return these 2 values          */
if|if
condition|(
name|target
operator|<
name|pList
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
operator|*
name|indexL
operator|=
name|i
expr_stmt|;
operator|*
name|indexR
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
block|}
name|HALASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|indexL
operator|=
operator|*
name|indexR
operator|=
literal|0
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/**************************************************************  * ar5416FillVpdTable  *  * Fill the Vpdlist for indices Pmax-Pmin  * Note: pwrMin, pwrMax and Vpdlist are all in dBm * 4  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5416FillVpdTable
parameter_list|(
name|uint8_t
name|pwrMin
parameter_list|,
name|uint8_t
name|pwrMax
parameter_list|,
name|uint8_t
modifier|*
name|pPwrList
parameter_list|,
name|uint8_t
modifier|*
name|pVpdList
parameter_list|,
name|uint16_t
name|numIntercepts
parameter_list|,
name|uint8_t
modifier|*
name|pRetVpdList
parameter_list|)
block|{
name|uint16_t
name|i
decl_stmt|,
name|k
decl_stmt|;
name|uint8_t
name|currPwr
init|=
name|pwrMin
decl_stmt|;
name|uint16_t
name|idxL
decl_stmt|,
name|idxR
decl_stmt|;
name|HALASSERT
argument_list|(
name|pwrMax
operator|>
name|pwrMin
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
operator|(
name|pwrMax
operator|-
name|pwrMin
operator|)
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|getLowerUpperIndex
argument_list|(
name|currPwr
argument_list|,
name|pPwrList
argument_list|,
name|numIntercepts
argument_list|,
operator|&
operator|(
name|idxL
operator|)
argument_list|,
operator|&
operator|(
name|idxR
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idxR
operator|<
literal|1
condition|)
name|idxR
operator|=
literal|1
expr_stmt|;
comment|/* extrapolate below */
if|if
condition|(
name|idxL
operator|==
name|numIntercepts
operator|-
literal|1
condition|)
name|idxL
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|numIntercepts
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* extrapolate above */
if|if
condition|(
name|pPwrList
index|[
name|idxL
index|]
operator|==
name|pPwrList
index|[
name|idxR
index|]
condition|)
name|k
operator|=
name|pVpdList
index|[
name|idxL
index|]
expr_stmt|;
else|else
name|k
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
operator|(
name|currPwr
operator|-
name|pPwrList
index|[
name|idxL
index|]
operator|)
operator|*
name|pVpdList
index|[
name|idxR
index|]
operator|+
operator|(
name|pPwrList
index|[
name|idxR
index|]
operator|-
name|currPwr
operator|)
operator|*
name|pVpdList
index|[
name|idxL
index|]
operator|)
operator|/
operator|(
name|pPwrList
index|[
name|idxR
index|]
operator|-
name|pPwrList
index|[
name|idxL
index|]
operator|)
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|k
operator|<
literal|256
argument_list|)
expr_stmt|;
name|pRetVpdList
index|[
name|i
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|k
expr_stmt|;
name|currPwr
operator|+=
literal|2
expr_stmt|;
comment|/* half dB steps */
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************  * interpolate  *  * Returns signed interpolated or the scaled up interpolated value  */
end_comment

begin_function
specifier|static
name|int16_t
name|interpolate
parameter_list|(
name|uint16_t
name|target
parameter_list|,
name|uint16_t
name|srcLeft
parameter_list|,
name|uint16_t
name|srcRight
parameter_list|,
name|int16_t
name|targetLeft
parameter_list|,
name|int16_t
name|targetRight
parameter_list|)
block|{
name|int16_t
name|rv
decl_stmt|;
if|if
condition|(
name|srcRight
operator|==
name|srcLeft
condition|)
block|{
name|rv
operator|=
name|targetLeft
expr_stmt|;
block|}
else|else
block|{
name|rv
operator|=
call|(
name|int16_t
call|)
argument_list|(
operator|(
operator|(
name|target
operator|-
name|srcLeft
operator|)
operator|*
name|targetRight
operator|+
operator|(
name|srcRight
operator|-
name|target
operator|)
operator|*
name|targetLeft
operator|)
operator|/
operator|(
name|srcRight
operator|-
name|srcLeft
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar5416Set11nRegs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|uint32_t
name|phymode
decl_stmt|;
name|HAL_HT_MACMODE
name|macmode
decl_stmt|;
comment|/* MAC - 20/40 mode */
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|chan
argument_list|)
condition|)
return|return;
comment|/* Enable 11n HT, 20 MHz */
name|phymode
operator|=
name|AR_PHY_FC_HT_EN
operator||
name|AR_PHY_FC_SHORT_GI_40
operator||
name|AR_PHY_FC_SINGLE_HT_LTF1
operator||
name|AR_PHY_FC_WALSH
expr_stmt|;
comment|/* Configure baseband for dynamic 20/40 operation */
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|phymode
operator||=
name|AR_PHY_FC_DYN2040_EN
operator||
name|AR_PHY_FC_SHORT_GI_40
expr_stmt|;
comment|/* Configure control (primary) channel at +-10MHz */
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|chan
argument_list|)
condition|)
name|phymode
operator||=
name|AR_PHY_FC_DYN2040_PRI_CH
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Configure 20/25 spacing */
block|if (ht->ht_extprotspacing == HAL_HT_EXTPROTSPACING_25) 			phymode |= AR_PHY_FC_DYN2040_EXT_CH;
endif|#
directive|endif
name|macmode
operator|=
name|HAL_HT_MACMODE_2040
expr_stmt|;
block|}
else|else
name|macmode
operator|=
name|HAL_HT_MACMODE_20
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TURBO
argument_list|,
name|phymode
argument_list|)
expr_stmt|;
comment|/* Configure MAC for 20/40 operation */
name|ar5416Set11nMac2040
argument_list|(
name|ah
argument_list|,
name|macmode
argument_list|)
expr_stmt|;
comment|/* global transmit timeout (25 TUs default)*/
comment|/* XXX - put this elsewhere??? */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_GTXTO
argument_list|,
literal|25
operator|<<
name|AR_GTXTO_TIMEOUT_LIMIT_S
argument_list|)
expr_stmt|;
comment|/* carrier sense timeout */
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_GTTM
argument_list|,
name|AR_GTTM_CST_USEC
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CST
argument_list|,
literal|1
operator|<<
name|AR_CST_TIMEOUT_LIMIT_S
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ar5416GetChannelCenters
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|CHAN_CENTERS
modifier|*
name|centers
parameter_list|)
block|{
name|uint16_t
name|freq
init|=
name|ath_hal_gethwchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|centers
operator|->
name|ctl_center
operator|=
name|freq
expr_stmt|;
name|centers
operator|->
name|synth_center
operator|=
name|freq
expr_stmt|;
comment|/* 	 * In 20/40 phy mode, the center frequency is 	 * "between" the control and extension channels. 	 */
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|centers
operator|->
name|synth_center
operator|+=
name|HT40_CHANNEL_CENTER_SHIFT
expr_stmt|;
name|centers
operator|->
name|ext_center
operator|=
name|centers
operator|->
name|synth_center
operator|+
name|HT40_CHANNEL_CENTER_SHIFT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40D
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|centers
operator|->
name|synth_center
operator|-=
name|HT40_CHANNEL_CENTER_SHIFT
expr_stmt|;
name|centers
operator|->
name|ext_center
operator|=
name|centers
operator|->
name|synth_center
operator|-
name|HT40_CHANNEL_CENTER_SHIFT
expr_stmt|;
block|}
else|else
block|{
name|centers
operator|->
name|ext_center
operator|=
name|freq
expr_stmt|;
block|}
block|}
end_function

end_unit

