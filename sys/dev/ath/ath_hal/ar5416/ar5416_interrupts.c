begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2008 Sam Leffler, Errno Consulting  * Copyright (c) 2002-2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416reg.h"
end_include

begin_comment
comment|/*  * Checks to see if an interrupt is pending on our NIC  *  * Returns: TRUE    if an interrupt is pending  *          FALSE   if not  */
end_comment

begin_function
name|HAL_BOOL
name|ar5416IsInterruptPending
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|uint32_t
name|isr
decl_stmt|;
comment|/*  	 * Some platforms trigger our ISR before applying power to 	 * the card, so make sure the INTPEND is really 1, not 0xffffffff. 	 */
name|isr
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_INTR_ASYNC_CAUSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isr
operator|!=
name|AR_INTR_SPURIOUS
operator|&&
operator|(
name|isr
operator|&
name|AR_INTR_MAC_IRQ
operator|)
operator|!=
literal|0
condition|)
return|return
name|AH_TRUE
return|;
name|isr
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_CAUSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isr
operator|!=
name|AR_INTR_SPURIOUS
operator|&&
operator|(
name|isr
operator|&
name|AR_INTR_SYNC_DEFAULT
operator|)
condition|)
return|return
name|AH_TRUE
return|;
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Reads the Interrupt Status Register value from the NIC, thus deasserting  * the interrupt line, and returns both the masked and unmasked mapped ISR  * values.  The value returned is mapped to abstract the hw-specific bit  * locations in the Interrupt Status Register.  *  * Returns: A hardware-abstracted bitmap of all non-masked-out  *          interrupts pending, as well as an unmasked value  */
end_comment

begin_function
name|HAL_BOOL
name|ar5416GetPendingInterrupts
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_INT
modifier|*
name|masked
parameter_list|)
block|{
name|uint32_t
name|isr
decl_stmt|,
name|isr0
decl_stmt|,
name|isr1
decl_stmt|,
name|sync_cause
decl_stmt|;
comment|/* 	 * Verify there's a mac interrupt and the RTC is on. 	 */
if|if
condition|(
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_INTR_ASYNC_CAUSE
argument_list|)
operator|&
name|AR_INTR_MAC_IRQ
operator|)
operator|&&
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RTC_STATUS
argument_list|)
operator|&
name|AR_RTC_STATUS_M
operator|)
operator|==
name|AR_RTC_STATUS_ON
condition|)
name|isr
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR
argument_list|)
expr_stmt|;
else|else
name|isr
operator|=
literal|0
expr_stmt|;
name|sync_cause
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_CAUSE
argument_list|)
expr_stmt|;
name|sync_cause
operator|&=
name|AR_INTR_SYNC_DEFAULT
expr_stmt|;
if|if
condition|(
name|isr
operator|==
literal|0
operator|&&
name|sync_cause
operator|==
literal|0
condition|)
block|{
operator|*
name|masked
operator|=
literal|0
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
if|if
condition|(
name|isr
operator|!=
literal|0
condition|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|uint32_t
name|mask2
decl_stmt|;
name|mask2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isr
operator|&
name|AR_ISR_BCNMISC
condition|)
block|{
name|uint32_t
name|isr2
init|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S2
argument_list|)
decl_stmt|;
if|if
condition|(
name|isr2
operator|&
name|AR_ISR_S2_TIM
condition|)
name|mask2
operator||=
name|HAL_INT_TIM
expr_stmt|;
if|if
condition|(
name|isr2
operator|&
name|AR_ISR_S2_DTIM
condition|)
name|mask2
operator||=
name|HAL_INT_DTIM
expr_stmt|;
if|if
condition|(
name|isr2
operator|&
name|AR_ISR_S2_DTIMSYNC
condition|)
name|mask2
operator||=
name|HAL_INT_DTIMSYNC
expr_stmt|;
if|if
condition|(
name|isr2
operator|&
operator|(
name|AR_ISR_S2_CABEND
operator|)
condition|)
name|mask2
operator||=
name|HAL_INT_CABEND
expr_stmt|;
if|if
condition|(
name|isr2
operator|&
name|AR_ISR_S2_GTT
condition|)
name|mask2
operator||=
name|HAL_INT_GTT
expr_stmt|;
if|if
condition|(
name|isr2
operator|&
name|AR_ISR_S2_CST
condition|)
name|mask2
operator||=
name|HAL_INT_CST
expr_stmt|;
if|if
condition|(
name|isr2
operator|&
name|AR_ISR_S2_TSFOOR
condition|)
name|mask2
operator||=
name|HAL_INT_TSFOOR
expr_stmt|;
block|}
name|isr
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_RAC
argument_list|)
expr_stmt|;
if|if
condition|(
name|isr
operator|==
literal|0xffffffff
condition|)
block|{
operator|*
name|masked
operator|=
literal|0
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
operator|*
name|masked
operator|=
name|isr
operator|&
name|HAL_INT_COMMON
expr_stmt|;
if|if
condition|(
name|isr
operator|&
operator|(
name|AR_ISR_RXOK
operator||
name|AR_ISR_RXERR
operator|)
condition|)
operator|*
name|masked
operator||=
name|HAL_INT_RX
expr_stmt|;
if|if
condition|(
name|isr
operator|&
operator|(
name|AR_ISR_TXOK
operator||
name|AR_ISR_TXDESC
operator||
name|AR_ISR_TXERR
operator||
name|AR_ISR_TXEOL
operator|)
condition|)
block|{
operator|*
name|masked
operator||=
name|HAL_INT_TX
expr_stmt|;
name|isr0
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S0_S
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_intrTxqs
operator||=
name|MS
argument_list|(
name|isr0
argument_list|,
name|AR_ISR_S0_QCU_TXOK
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_intrTxqs
operator||=
name|MS
argument_list|(
name|isr0
argument_list|,
name|AR_ISR_S0_QCU_TXDESC
argument_list|)
expr_stmt|;
name|isr1
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S1_S
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_intrTxqs
operator||=
name|MS
argument_list|(
name|isr1
argument_list|,
name|AR_ISR_S1_QCU_TXERR
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_intrTxqs
operator||=
name|MS
argument_list|(
name|isr1
argument_list|,
name|AR_ISR_S1_QCU_TXEOL
argument_list|)
expr_stmt|;
block|}
comment|/* Interrupt Mitigation on AR5416 */
ifdef|#
directive|ifdef
name|AR5416_INT_MITIGATION
if|if
condition|(
name|isr
operator|&
operator|(
name|AR_ISR_RXMINTR
operator||
name|AR_ISR_RXINTM
operator|)
condition|)
operator|*
name|masked
operator||=
name|HAL_INT_RX
expr_stmt|;
if|if
condition|(
name|isr
operator|&
operator|(
name|AR_ISR_TXMINTR
operator||
name|AR_ISR_TXINTM
operator|)
condition|)
operator|*
name|masked
operator||=
name|HAL_INT_TX
expr_stmt|;
endif|#
directive|endif
operator|*
name|masked
operator||=
name|mask2
expr_stmt|;
block|}
if|if
condition|(
name|sync_cause
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sync_cause
operator|&
operator|(
name|AR_INTR_SYNC_HOST1_FATAL
operator||
name|AR_INTR_SYNC_HOST1_PERR
operator|)
condition|)
block|{
operator|*
name|masked
operator||=
name|HAL_INT_FATAL
expr_stmt|;
block|}
if|if
condition|(
name|sync_cause
operator|&
name|AR_INTR_SYNC_RADM_CPL_TIMEOUT
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: RADM CPL timeout\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RC
argument_list|,
name|AR_RC_HOSTIF
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|masked
operator||=
name|HAL_INT_FATAL
expr_stmt|;
block|}
comment|/* 		 * On fatal errors collect ISR state for debugging. 		 */
if|if
condition|(
operator|*
name|masked
operator|&
name|HAL_INT_FATAL
condition|)
block|{
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_fatalState
index|[
literal|0
index|]
operator|=
name|isr
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_fatalState
index|[
literal|1
index|]
operator|=
name|sync_cause
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: fatal error, ISR_RAC 0x%x SYNC_CAUSE 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|isr
argument_list|,
name|sync_cause
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_CAUSE_CLR
argument_list|,
name|sync_cause
argument_list|)
expr_stmt|;
comment|/* NB: flush write */
operator|(
name|void
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_CAUSE_CLR
argument_list|)
expr_stmt|;
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Atomically enables NIC interrupts.  Interrupts are passed in  * via the enumerated bitmask in ints.  */
end_comment

begin_function
name|HAL_INT
name|ar5416SetInterrupts
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_INT
name|ints
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|uint32_t
name|omask
init|=
name|ahp
operator|->
name|ah_maskReg
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|,
name|mask2
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: 0x%x => 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|omask
argument_list|,
name|ints
argument_list|)
expr_stmt|;
if|if
condition|(
name|omask
operator|&
name|HAL_INT_GLOBAL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: disable IER\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IER
argument_list|,
name|AR_IER_DISABLE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_IER
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_INTR_ASYNC_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_INTR_ASYNC_ENABLE
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_ENABLE
argument_list|)
expr_stmt|;
block|}
name|mask
operator|=
name|ints
operator|&
name|HAL_INT_COMMON
expr_stmt|;
name|mask2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_TX
condition|)
block|{
if|if
condition|(
name|ahp
operator|->
name|ah_txOkInterruptMask
condition|)
name|mask
operator||=
name|AR_IMR_TXOK
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_txErrInterruptMask
condition|)
name|mask
operator||=
name|AR_IMR_TXERR
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_txDescInterruptMask
condition|)
name|mask
operator||=
name|AR_IMR_TXDESC
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_txEolInterruptMask
condition|)
name|mask
operator||=
name|AR_IMR_TXEOL
expr_stmt|;
block|}
if|if
condition|(
name|ints
operator|&
name|HAL_INT_RX
condition|)
name|mask
operator||=
name|AR_IMR_RXOK
operator||
name|AR_IMR_RXERR
operator||
name|AR_IMR_RXDESC
expr_stmt|;
ifdef|#
directive|ifdef
name|AR5416_INT_MITIGATION
comment|/* 	 * Overwrite default mask if Interrupt mitigation 	 * is specified for AR5416 	 */
name|mask
operator|=
name|ints
operator|&
name|HAL_INT_COMMON
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_TX
condition|)
name|mask
operator||=
name|AR_IMR_TXMINTR
operator||
name|AR_IMR_TXINTM
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_RX
condition|)
name|mask
operator||=
name|AR_IMR_RXERR
operator||
name|AR_IMR_RXMINTR
operator||
name|AR_IMR_RXINTM
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ints
operator|&
operator|(
name|HAL_INT_BMISC
operator|)
condition|)
block|{
name|mask
operator||=
name|AR_IMR_BCNMISC
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_TIM
condition|)
name|mask2
operator||=
name|AR_IMR_S2_TIM
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_DTIM
condition|)
name|mask2
operator||=
name|AR_IMR_S2_DTIM
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_DTIMSYNC
condition|)
name|mask2
operator||=
name|AR_IMR_S2_DTIMSYNC
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_CABEND
condition|)
name|mask2
operator||=
operator|(
name|AR_IMR_S2_CABEND
operator|)
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_GTT
condition|)
name|mask2
operator||=
name|AR_IMR_S2_GTT
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_CST
condition|)
name|mask2
operator||=
name|AR_IMR_S2_CST
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_TSFOOR
condition|)
name|mask2
operator||=
name|AR_IMR_S2_TSFOOR
expr_stmt|;
block|}
comment|/* Write the new IMR and store off our SW copy. */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: new IMR 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|mask
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S2
argument_list|)
operator|&
operator|~
operator|(
name|AR_IMR_S2_TIM
operator||
name|AR_IMR_S2_DTIM
operator||
name|AR_IMR_S2_DTIMSYNC
operator||
name|AR_IMR_S2_CABEND
operator||
name|AR_IMR_S2_CABTO
operator||
name|AR_IMR_S2_TSFOOR
operator||
name|AR_IMR_S2_GTT
operator||
name|AR_IMR_S2_CST
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S2
argument_list|,
name|mask
operator||
name|mask2
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_maskReg
operator|=
name|ints
expr_stmt|;
comment|/* Re-enable interrupts if they were enabled before. */
if|if
condition|(
name|ints
operator|&
name|HAL_INT_GLOBAL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: enable IER\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IER
argument_list|,
name|AR_IER_ENABLE
argument_list|)
expr_stmt|;
name|mask
operator|=
name|AR_INTR_MAC_IRQ
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_GPIO
condition|)
name|mask
operator||=
name|SM
argument_list|(
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_gpioMask
argument_list|,
name|AR_INTR_ASYNC_MASK_GPIO
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_INTR_ASYNC_ENABLE
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_INTR_ASYNC_MASK
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|mask
operator|=
name|AR_INTR_SYNC_DEFAULT
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_GPIO
condition|)
name|mask
operator||=
name|SM
argument_list|(
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_gpioMask
argument_list|,
name|AR_INTR_SYNC_MASK_GPIO
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_ENABLE
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_MASK
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
return|return
name|omask
return|;
block|}
end_function

end_unit

