begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2002-2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_comment
comment|/*  * XXX this is virtually the same code as for 5212; we reuse  * storage in the 5212 state block; need to refactor.  */
end_comment

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_desc.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416phy.h"
end_include

begin_comment
comment|/*  * Anti noise immunity support.  We track phy errors and react  * to excessive errors by adjusting the noise immunity parameters.  */
end_comment

begin_define
define|#
directive|define
name|HAL_EP_RND
parameter_list|(
name|x
parameter_list|,
name|mul
parameter_list|)
define|\
value|((((x)%(mul))>= ((mul)/2)) ? ((x) + ((mul) - 1)) / (mul) : (x)/(mul))
end_define

begin_define
define|#
directive|define
name|BEACON_RSSI
parameter_list|(
name|ahp
parameter_list|)
define|\
value|HAL_EP_RND(ahp->ah_stats.ast_nodestats.ns_avgbrssi, \ 		HAL_RSSI_EP_MULTIPLIER)
end_define

begin_comment
comment|/*  * ANI processing tunes radio parameters according to PHY errors  * and related information.  This is done for for noise and spur  * immunity in all operating modes if the device indicates it's  * capable at attach time.  In addition, when there is a reference  * rssi value (e.g. beacon frames from an ap in station mode)  * further tuning is done.  *  * ANI_ENA indicates whether any ANI processing should be done;  * this is specified at attach time.  *  * ANI_ENA_RSSI indicates whether rssi-based processing should  * done, this is enabled based on operating mode and is meaningful  * only if ANI_ENA is true.  *  * ANI parameters are typically controlled only by the hal.  The  * AniControl interface however permits manual tuning through the  * diagnostic api.  */
end_comment

begin_define
define|#
directive|define
name|ANI_ENA
parameter_list|(
name|ah
parameter_list|)
define|\
value|(AH5212(ah)->ah_procPhyErr& HAL_ANI_ENA)
end_define

begin_define
define|#
directive|define
name|ANI_ENA_RSSI
parameter_list|(
name|ah
parameter_list|)
define|\
value|(AH5212(ah)->ah_procPhyErr& HAL_RSSI_ANI_ENA)
end_define

begin_define
define|#
directive|define
name|ah_mibStats
value|ah_stats.ast_mibstats
end_define

begin_function
specifier|static
name|void
name|enableAniMIBCounters
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ar5212AniParams
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: Enable mib counters: "
literal|"OfdmPhyErrBase 0x%x cckPhyErrBase 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|params
operator|->
name|ofdmPhyErrBase
argument_list|,
name|params
operator|->
name|cckPhyErrBase
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_FILTOFDM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_FILTCCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHYCNT1
argument_list|,
name|params
operator|->
name|ofdmPhyErrBase
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHYCNT2
argument_list|,
name|params
operator|->
name|cckPhyErrBase
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_MASK_1
argument_list|,
name|AR_PHY_ERR_OFDM_TIMING
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_MASK_2
argument_list|,
name|AR_PHY_ERR_CCK_TIMING
argument_list|)
expr_stmt|;
name|ar5212UpdateMibCounters
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_mibStats
argument_list|)
expr_stmt|;
comment|/* save+clear counters*/
name|ar5212EnableMibCounters
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* enable everything */
block|}
end_function

begin_function
specifier|static
name|void
name|disableAniMIBCounters
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"Disable MIB counters\n"
argument_list|)
expr_stmt|;
name|ar5212UpdateMibCounters
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_mibStats
argument_list|)
expr_stmt|;
comment|/* save stats */
name|ar5212DisableMibCounters
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* disable everything */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_MASK_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_MASK_2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setPhyErrBase
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ar5212AniParams
modifier|*
name|params
parameter_list|)
block|{
if|if
condition|(
name|params
operator|->
name|ofdmTrigHigh
operator|>=
name|AR_PHY_COUNTMAX
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"OFDM Trigger %d is too high for hw counters, using max\n"
argument_list|,
name|params
operator|->
name|ofdmTrigHigh
argument_list|)
expr_stmt|;
name|params
operator|->
name|ofdmPhyErrBase
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|params
operator|->
name|ofdmPhyErrBase
operator|=
name|AR_PHY_COUNTMAX
operator|-
name|params
operator|->
name|ofdmTrigHigh
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|cckTrigHigh
operator|>=
name|AR_PHY_COUNTMAX
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"CCK Trigger %d is too high for hw counters, using max\n"
argument_list|,
name|params
operator|->
name|cckTrigHigh
argument_list|)
expr_stmt|;
name|params
operator|->
name|cckPhyErrBase
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|params
operator|->
name|cckPhyErrBase
operator|=
name|AR_PHY_COUNTMAX
operator|-
name|params
operator|->
name|cckTrigHigh
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup ANI handling.  Sets all thresholds and reset the  * channel statistics.  Note that ar5416AniReset should be  * called by ar5416Reset before anything else happens and  * that's where we force initial settings.  */
end_comment

begin_function
name|void
name|ar5416AniAttach
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ar5212AniParams
modifier|*
name|params24
parameter_list|,
specifier|const
name|struct
name|ar5212AniParams
modifier|*
name|params5
parameter_list|,
name|HAL_BOOL
name|enable
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
name|params24
operator|!=
name|AH_NULL
condition|)
block|{
name|OS_MEMCPY
argument_list|(
operator|&
name|ahp
operator|->
name|ah_aniParams24
argument_list|,
name|params24
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|params24
argument_list|)
argument_list|)
expr_stmt|;
name|setPhyErrBase
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_aniParams24
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|params5
operator|!=
name|AH_NULL
condition|)
block|{
name|OS_MEMCPY
argument_list|(
operator|&
name|ahp
operator|->
name|ah_aniParams5
argument_list|,
name|params5
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|params5
argument_list|)
argument_list|)
expr_stmt|;
name|setPhyErrBase
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_aniParams5
argument_list|)
expr_stmt|;
block|}
name|OS_MEMZERO
argument_list|(
name|ahp
operator|->
name|ah_ani
argument_list|,
sizeof|sizeof
argument_list|(
name|ahp
operator|->
name|ah_ani
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable MIB Counters */
name|enableAniMIBCounters
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_aniParams24
comment|/*XXX*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
comment|/* Enable ani now */
name|HALASSERT
argument_list|(
name|params24
operator|!=
name|AH_NULL
operator|&&
name|params5
operator|!=
name|AH_NULL
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_procPhyErr
operator||=
name|HAL_ANI_ENA
expr_stmt|;
block|}
else|else
block|{
name|ahp
operator|->
name|ah_procPhyErr
operator|&=
operator|~
name|HAL_ANI_ENA
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Cleanup any ANI state setup.  */
end_comment

begin_function
name|void
name|ar5416AniDetach
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"Detaching Ani\n"
argument_list|)
expr_stmt|;
name|disableAniMIBCounters
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Control Adaptive Noise Immunity Parameters  */
end_comment

begin_function
name|HAL_BOOL
name|ar5416AniControl
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_ANI_CMD
name|cmd
parameter_list|,
name|int
name|param
parameter_list|)
block|{
typedef|typedef
name|int
name|TABLE
index|[]
typedef|;
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar5212AniState
modifier|*
name|aniState
init|=
name|ahp
operator|->
name|ah_curani
decl_stmt|;
specifier|const
name|struct
name|ar5212AniParams
modifier|*
name|params
init|=
name|aniState
operator|->
name|params
decl_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_ANI_CONTROL
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|HAL_ANI_NOISE_IMMUNITY_LEVEL
case|:
block|{
name|u_int
name|level
init|=
name|param
decl_stmt|;
if|if
condition|(
name|level
operator|>=
name|params
operator|->
name|maxNoiseImmunityLevel
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: immunity level out of range (%u> %u)\n"
argument_list|,
name|__func__
argument_list|,
name|level
argument_list|,
name|params
operator|->
name|maxNoiseImmunityLevel
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_DESIRED_SZ
argument_list|,
name|AR_PHY_DESIRED_SZ_TOT_DES
argument_list|,
name|params
operator|->
name|totalSizeDesired
index|[
name|level
index|]
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CTL1
argument_list|,
name|AR_PHY_AGC_CTL1_COARSE_LOW
argument_list|,
name|params
operator|->
name|coarseLow
index|[
name|level
index|]
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CTL1
argument_list|,
name|AR_PHY_AGC_CTL1_COARSE_HIGH
argument_list|,
name|params
operator|->
name|coarseHigh
index|[
name|level
index|]
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_FIND_SIG
argument_list|,
name|AR_PHY_FIND_SIG_FIRPWR
argument_list|,
name|params
operator|->
name|firpwr
index|[
name|level
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|>
name|aniState
operator|->
name|noiseImmunityLevel
condition|)
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_niup
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|<
name|aniState
operator|->
name|noiseImmunityLevel
condition|)
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_nidown
operator|++
expr_stmt|;
name|aniState
operator|->
name|noiseImmunityLevel
operator|=
name|level
expr_stmt|;
break|break;
block|}
case|case
name|HAL_ANI_OFDM_WEAK_SIGNAL_DETECTION
case|:
block|{
specifier|static
specifier|const
name|TABLE
name|m1ThreshLow
init|=
block|{
literal|127
block|,
literal|50
block|}
decl_stmt|;
specifier|static
specifier|const
name|TABLE
name|m2ThreshLow
init|=
block|{
literal|127
block|,
literal|40
block|}
decl_stmt|;
specifier|static
specifier|const
name|TABLE
name|m1Thresh
init|=
block|{
literal|127
block|,
literal|0x4d
block|}
decl_stmt|;
specifier|static
specifier|const
name|TABLE
name|m2Thresh
init|=
block|{
literal|127
block|,
literal|0x40
block|}
decl_stmt|;
specifier|static
specifier|const
name|TABLE
name|m2CountThr
init|=
block|{
literal|31
block|,
literal|16
block|}
decl_stmt|;
specifier|static
specifier|const
name|TABLE
name|m2CountThrLow
init|=
block|{
literal|63
block|,
literal|48
block|}
decl_stmt|;
name|u_int
name|on
init|=
name|param
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_LOW
argument_list|,
name|AR_PHY_SFCORR_LOW_M1_THRESH_LOW
argument_list|,
name|m1ThreshLow
index|[
name|on
index|]
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_LOW
argument_list|,
name|AR_PHY_SFCORR_LOW_M2_THRESH_LOW
argument_list|,
name|m2ThreshLow
index|[
name|on
index|]
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR
argument_list|,
name|AR_PHY_SFCORR_M1_THRESH
argument_list|,
name|m1Thresh
index|[
name|on
index|]
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR
argument_list|,
name|AR_PHY_SFCORR_M2_THRESH
argument_list|,
name|m2Thresh
index|[
name|on
index|]
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR
argument_list|,
name|AR_PHY_SFCORR_M2COUNT_THR
argument_list|,
name|m2CountThr
index|[
name|on
index|]
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_LOW
argument_list|,
name|AR_PHY_SFCORR_LOW_M2COUNT_THR_LOW
argument_list|,
name|m2CountThrLow
index|[
name|on
index|]
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_EXT
argument_list|,
name|AR_PHY_SFCORR_EXT_M1_THRESH_LOW
argument_list|,
name|m1ThreshLow
index|[
name|on
index|]
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_EXT
argument_list|,
name|AR_PHY_SFCORR_EXT_M2_THRESH_LOW
argument_list|,
name|m2ThreshLow
index|[
name|on
index|]
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_EXT
argument_list|,
name|AR_PHY_SFCORR_EXT_M1_THRESH
argument_list|,
name|m1Thresh
index|[
name|on
index|]
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_EXT
argument_list|,
name|AR_PHY_SFCORR_EXT_M2_THRESH
argument_list|,
name|m2Thresh
index|[
name|on
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
condition|)
block|{
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_LOW
argument_list|,
name|AR_PHY_SFCORR_LOW_USE_SELF_CORR_LOW
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_LOW
argument_list|,
name|AR_PHY_SFCORR_LOW_USE_SELF_CORR_LOW
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|on
condition|)
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_ofdmon
operator|++
expr_stmt|;
else|else
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_ofdmoff
operator|++
expr_stmt|;
name|aniState
operator|->
name|ofdmWeakSigDetectOff
operator|=
operator|!
name|on
expr_stmt|;
break|break;
block|}
case|case
name|HAL_ANI_CCK_WEAK_SIGNAL_THR
case|:
block|{
specifier|static
specifier|const
name|TABLE
name|weakSigThrCck
init|=
block|{
literal|8
block|,
literal|6
block|}
decl_stmt|;
name|u_int
name|high
init|=
name|param
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_DETECT
argument_list|,
name|AR_PHY_CCK_DETECT_WEAK_SIG_THR_CCK
argument_list|,
name|weakSigThrCck
index|[
name|high
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|high
condition|)
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_cckhigh
operator|++
expr_stmt|;
else|else
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_ccklow
operator|++
expr_stmt|;
name|aniState
operator|->
name|cckWeakSigThreshold
operator|=
name|high
expr_stmt|;
break|break;
block|}
case|case
name|HAL_ANI_FIRSTEP_LEVEL
case|:
block|{
name|u_int
name|level
init|=
name|param
decl_stmt|;
if|if
condition|(
name|level
operator|>=
name|params
operator|->
name|maxFirstepLevel
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: firstep level out of range (%u> %u)\n"
argument_list|,
name|__func__
argument_list|,
name|level
argument_list|,
name|params
operator|->
name|maxFirstepLevel
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_FIND_SIG
argument_list|,
name|AR_PHY_FIND_SIG_FIRSTEP
argument_list|,
name|params
operator|->
name|firstep
index|[
name|level
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|>
name|aniState
operator|->
name|firstepLevel
condition|)
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_stepup
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|<
name|aniState
operator|->
name|firstepLevel
condition|)
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_stepdown
operator|++
expr_stmt|;
name|aniState
operator|->
name|firstepLevel
operator|=
name|level
expr_stmt|;
break|break;
block|}
case|case
name|HAL_ANI_SPUR_IMMUNITY_LEVEL
case|:
block|{
name|u_int
name|level
init|=
name|param
decl_stmt|;
if|if
condition|(
name|level
operator|>=
name|params
operator|->
name|maxSpurImmunityLevel
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: spur immunity level out of range (%u> %u)\n"
argument_list|,
name|__func__
argument_list|,
name|level
argument_list|,
name|params
operator|->
name|maxSpurImmunityLevel
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING5
argument_list|,
name|AR_PHY_TIMING5_CYCPWR_THR1
argument_list|,
name|params
operator|->
name|cycPwrThr1
index|[
name|level
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|>
name|aniState
operator|->
name|spurImmunityLevel
condition|)
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_spurup
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|<
name|aniState
operator|->
name|spurImmunityLevel
condition|)
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_spurdown
operator|++
expr_stmt|;
name|aniState
operator|->
name|spurImmunityLevel
operator|=
name|level
expr_stmt|;
break|break;
block|}
case|case
name|HAL_ANI_PRESENT
case|:
break|break;
case|case
name|HAL_ANI_MODE
case|:
if|if
condition|(
name|param
operator|==
literal|0
condition|)
block|{
name|ahp
operator|->
name|ah_procPhyErr
operator|&=
operator|~
name|HAL_ANI_ENA
expr_stmt|;
comment|/* Turn off HW counters if we have them */
name|ar5416AniDetach
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ar5212SetRxFilter
argument_list|(
name|ah
argument_list|,
name|ar5212GetRxFilter
argument_list|(
name|ah
argument_list|)
operator|&
operator|~
name|HAL_RX_FILTER_PHYERR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* normal/auto mode */
comment|/* don't mess with state if already enabled */
if|if
condition|(
name|ahp
operator|->
name|ah_procPhyErr
operator|&
name|HAL_ANI_ENA
condition|)
break|break;
name|ar5212SetRxFilter
argument_list|(
name|ah
argument_list|,
name|ar5212GetRxFilter
argument_list|(
name|ah
argument_list|)
operator|&
operator|~
name|HAL_RX_FILTER_PHYERR
argument_list|)
expr_stmt|;
comment|/* Enable MIB Counters */
name|enableAniMIBCounters
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_curani
operator|!=
name|AH_NULL
condition|?
name|ahp
operator|->
name|ah_curani
operator|->
name|params
else|:
operator|&
name|ahp
operator|->
name|ah_aniParams24
comment|/*XXX*/
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_procPhyErr
operator||=
name|HAL_ANI_ENA
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|AH_PRIVATE_DIAG
case|case
name|HAL_ANI_PHYERR_RESET
case|:
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_ofdmerrs
operator|=
literal|0
expr_stmt|;
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_cckerrs
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* AH_PRIVATE_DIAG */
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid cmd %u\n"
argument_list|,
name|__func__
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar5416AniOfdmErrTrigger
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
decl_stmt|;
name|struct
name|ar5212AniState
modifier|*
name|aniState
decl_stmt|;
specifier|const
name|struct
name|ar5212AniParams
modifier|*
name|params
decl_stmt|;
name|HALASSERT
argument_list|(
name|chan
operator|!=
name|AH_NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ANI_ENA
argument_list|(
name|ah
argument_list|)
condition|)
return|return;
name|aniState
operator|=
name|ahp
operator|->
name|ah_curani
expr_stmt|;
name|params
operator|=
name|aniState
operator|->
name|params
expr_stmt|;
comment|/* First, raise noise immunity level, up to max */
if|if
condition|(
name|aniState
operator|->
name|noiseImmunityLevel
operator|+
literal|1
operator|<
name|params
operator|->
name|maxNoiseImmunityLevel
condition|)
block|{
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_NOISE_IMMUNITY_LEVEL
argument_list|,
name|aniState
operator|->
name|noiseImmunityLevel
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* then, raise spur immunity level, up to max */
if|if
condition|(
name|aniState
operator|->
name|spurImmunityLevel
operator|+
literal|1
operator|<
name|params
operator|->
name|maxSpurImmunityLevel
condition|)
block|{
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_SPUR_IMMUNITY_LEVEL
argument_list|,
name|aniState
operator|->
name|spurImmunityLevel
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ANI_ENA_RSSI
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|int32_t
name|rssi
init|=
name|BEACON_RSSI
argument_list|(
name|ahp
argument_list|)
decl_stmt|;
if|if
condition|(
name|rssi
operator|>
name|params
operator|->
name|rssiThrHigh
condition|)
block|{
comment|/* 			 * Beacon rssi is high, can turn off ofdm 			 * weak sig detect. 			 */
if|if
condition|(
operator|!
name|aniState
operator|->
name|ofdmWeakSigDetectOff
condition|)
block|{
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_OFDM_WEAK_SIGNAL_DETECTION
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_SPUR_IMMUNITY_LEVEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  			 * If weak sig detect is already off, as last resort, 			 * raise firstep level  			 */
if|if
condition|(
name|aniState
operator|->
name|firstepLevel
operator|+
literal|1
operator|<
name|params
operator|->
name|maxFirstepLevel
condition|)
block|{
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_FIRSTEP_LEVEL
argument_list|,
name|aniState
operator|->
name|firstepLevel
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|rssi
operator|>
name|params
operator|->
name|rssiThrLow
condition|)
block|{
comment|/*  			 * Beacon rssi in mid range, need ofdm weak signal 			 * detect, but we can raise firststepLevel. 			 */
if|if
condition|(
name|aniState
operator|->
name|ofdmWeakSigDetectOff
condition|)
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_OFDM_WEAK_SIGNAL_DETECTION
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|aniState
operator|->
name|firstepLevel
operator|+
literal|1
operator|<
name|params
operator|->
name|maxFirstepLevel
condition|)
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_FIRSTEP_LEVEL
argument_list|,
name|aniState
operator|->
name|firstepLevel
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/*  			 * Beacon rssi is low, if in 11b/g mode, turn off ofdm 			 * weak signal detection and zero firstepLevel to 			 * maximize CCK sensitivity  			 */
if|if
condition|(
name|IEEE80211_IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|aniState
operator|->
name|ofdmWeakSigDetectOff
condition|)
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_OFDM_WEAK_SIGNAL_DETECTION
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|aniState
operator|->
name|firstepLevel
operator|>
literal|0
condition|)
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_FIRSTEP_LEVEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ar5416AniCckErrTrigger
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
decl_stmt|;
name|struct
name|ar5212AniState
modifier|*
name|aniState
decl_stmt|;
specifier|const
name|struct
name|ar5212AniParams
modifier|*
name|params
decl_stmt|;
name|HALASSERT
argument_list|(
name|chan
operator|!=
name|AH_NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ANI_ENA
argument_list|(
name|ah
argument_list|)
condition|)
return|return;
comment|/* first, raise noise immunity level, up to max */
name|aniState
operator|=
name|ahp
operator|->
name|ah_curani
expr_stmt|;
name|params
operator|=
name|aniState
operator|->
name|params
expr_stmt|;
if|if
condition|(
name|aniState
operator|->
name|noiseImmunityLevel
operator|+
literal|1
operator|<
name|params
operator|->
name|maxNoiseImmunityLevel
condition|)
block|{
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_NOISE_IMMUNITY_LEVEL
argument_list|,
name|aniState
operator|->
name|noiseImmunityLevel
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ANI_ENA_RSSI
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|int32_t
name|rssi
init|=
name|BEACON_RSSI
argument_list|(
name|ahp
argument_list|)
decl_stmt|;
if|if
condition|(
name|rssi
operator|>
name|params
operator|->
name|rssiThrLow
condition|)
block|{
comment|/* 			 * Beacon signal in mid and high range, 			 * raise firstep level. 			 */
if|if
condition|(
name|aniState
operator|->
name|firstepLevel
operator|+
literal|1
operator|<
name|params
operator|->
name|maxFirstepLevel
condition|)
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_FIRSTEP_LEVEL
argument_list|,
name|aniState
operator|->
name|firstepLevel
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Beacon rssi is low, zero firstep level to maximize 			 * CCK sensitivity in 11b/g mode. 			 */
if|if
condition|(
name|IEEE80211_IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
condition|)
block|{
if|if
condition|(
name|aniState
operator|->
name|firstepLevel
operator|>
literal|0
condition|)
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_FIRSTEP_LEVEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ar5416AniRestart
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ar5212AniState
modifier|*
name|aniState
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|ar5212AniParams
modifier|*
name|params
init|=
name|aniState
operator|->
name|params
decl_stmt|;
name|aniState
operator|->
name|listenTime
operator|=
literal|0
expr_stmt|;
comment|/* 	 * NB: these are written on reset based on the 	 *     ini so we must re-write them! 	 */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: Writing ofdmbase=%u   cckbase=%u\n"
argument_list|,
name|__func__
argument_list|,
name|params
operator|->
name|ofdmPhyErrBase
argument_list|,
name|params
operator|->
name|cckPhyErrBase
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_1
argument_list|,
name|params
operator|->
name|ofdmPhyErrBase
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_2
argument_list|,
name|params
operator|->
name|cckPhyErrBase
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_MASK_1
argument_list|,
name|AR_PHY_ERR_OFDM_TIMING
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_MASK_1
argument_list|,
name|AR_PHY_ERR_CCK_TIMING
argument_list|)
expr_stmt|;
comment|/* Clear the mib counters and save them in the stats */
name|ar5212UpdateMibCounters
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_mibStats
argument_list|)
expr_stmt|;
name|aniState
operator|->
name|ofdmPhyErrCount
operator|=
literal|0
expr_stmt|;
name|aniState
operator|->
name|cckPhyErrCount
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restore/reset the ANI parameters and reset the statistics.  * This routine must be called for every channel change.  *  * NOTE: This is where ah_curani is set; other ani code assumes  *       it is setup to reflect the current channel.  */
end_comment

begin_function
name|void
name|ar5416AniReset
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|HAL_OPMODE
name|opmode
parameter_list|,
name|int
name|restore
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
init|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
comment|/* XXX bounds check ic_devdata */
name|struct
name|ar5212AniState
modifier|*
name|aniState
init|=
operator|&
name|ahp
operator|->
name|ah_ani
index|[
name|chan
operator|->
name|ic_devdata
index|]
decl_stmt|;
name|uint32_t
name|rxfilter
decl_stmt|;
if|if
condition|(
operator|(
name|ichan
operator|->
name|privFlags
operator|&
name|CHANNEL_ANI_INIT
operator|)
operator|==
literal|0
condition|)
block|{
name|OS_MEMZERO
argument_list|(
name|aniState
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aniState
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
name|aniState
operator|->
name|params
operator|=
operator|&
name|ahp
operator|->
name|ah_aniParams24
expr_stmt|;
else|else
name|aniState
operator|->
name|params
operator|=
operator|&
name|ahp
operator|->
name|ah_aniParams5
expr_stmt|;
name|ichan
operator|->
name|privFlags
operator||=
name|CHANNEL_ANI_INIT
expr_stmt|;
name|HALASSERT
argument_list|(
operator|(
name|ichan
operator|->
name|privFlags
operator|&
name|CHANNEL_ANI_SETUP
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|ahp
operator|->
name|ah_curani
operator|=
name|aniState
expr_stmt|;
if|#
directive|if
literal|0
block|ath_hal_printf(ah,"%s: chan %u/0x%x restore %d opmode %u%s\n", 	    __func__, chan->ic_freq, chan->ic_flags, restore, opmode, 	    ichan->privFlags& CHANNEL_ANI_SETUP ? " setup" : "");
else|#
directive|else
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: chan %u/0x%x restore %d opmode %u%s\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|,
name|restore
argument_list|,
name|opmode
argument_list|,
name|ichan
operator|->
name|privFlags
operator|&
name|CHANNEL_ANI_SETUP
condition|?
literal|" setup"
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_ANI_RESET
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
comment|/* 	 * Turn off PHY error frame delivery while we futz with settings. 	 */
name|rxfilter
operator|=
name|ar5212GetRxFilter
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ar5212SetRxFilter
argument_list|(
name|ah
argument_list|,
name|rxfilter
operator|&
operator|~
name|HAL_RX_FILTER_PHYERR
argument_list|)
expr_stmt|;
comment|/* 	 * Automatic processing is done only in station mode right now. 	 */
if|if
condition|(
name|opmode
operator|==
name|HAL_M_STA
condition|)
name|ahp
operator|->
name|ah_procPhyErr
operator||=
name|HAL_RSSI_ANI_ENA
expr_stmt|;
else|else
name|ahp
operator|->
name|ah_procPhyErr
operator|&=
operator|~
name|HAL_RSSI_ANI_ENA
expr_stmt|;
comment|/* 	 * Set all ani parameters.  We either set them to initial 	 * values or restore the previous ones for the channel. 	 * XXX if ANI follows hardware, we don't care what mode we're 	 * XXX in, we should keep the ani parameters 	 */
if|if
condition|(
name|restore
operator|&&
operator|(
name|ichan
operator|->
name|privFlags
operator|&
name|CHANNEL_ANI_SETUP
operator|)
condition|)
block|{
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_NOISE_IMMUNITY_LEVEL
argument_list|,
name|aniState
operator|->
name|noiseImmunityLevel
argument_list|)
expr_stmt|;
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_SPUR_IMMUNITY_LEVEL
argument_list|,
name|aniState
operator|->
name|spurImmunityLevel
argument_list|)
expr_stmt|;
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_OFDM_WEAK_SIGNAL_DETECTION
argument_list|,
operator|!
name|aniState
operator|->
name|ofdmWeakSigDetectOff
argument_list|)
expr_stmt|;
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_CCK_WEAK_SIGNAL_THR
argument_list|,
name|aniState
operator|->
name|cckWeakSigThreshold
argument_list|)
expr_stmt|;
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_FIRSTEP_LEVEL
argument_list|,
name|aniState
operator|->
name|firstepLevel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_NOISE_IMMUNITY_LEVEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_SPUR_IMMUNITY_LEVEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_OFDM_WEAK_SIGNAL_DETECTION
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_CCK_WEAK_SIGNAL_THR
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_FIRSTEP_LEVEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ichan
operator|->
name|privFlags
operator||=
name|CHANNEL_ANI_SETUP
expr_stmt|;
block|}
name|ar5416AniRestart
argument_list|(
name|ah
argument_list|,
name|aniState
argument_list|)
expr_stmt|;
comment|/* restore RX filter mask */
name|ar5212SetRxFilter
argument_list|(
name|ah
argument_list|,
name|rxfilter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a MIB interrupt.  We may potentially be invoked because  * any of the MIB counters overflow/trigger so don't assume we're  * here because a PHY error counter triggered.  */
end_comment

begin_function
name|void
name|ar5416ProcessMibIntr
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_NODE_STATS
modifier|*
name|stats
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|uint32_t
name|phyCnt1
decl_stmt|,
name|phyCnt2
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: mibc 0x%x phyCnt1 0x%x phyCnt2 0x%x "
literal|"filtofdm 0x%x filtcck 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_MIBC
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHYCNT1
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHYCNT2
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_FILTOFDM
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_FILTCCK
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * First order of business is to clear whatever caused 	 * the interrupt so we don't keep getting interrupted. 	 * We have the usual mib counters that are reset-on-read 	 * and the additional counters that appeared starting in 	 * Hainan.  We collect the mib counters and explicitly 	 * zero additional counters we are not using.  Anything 	 * else is reset only if it caused the interrupt. 	 */
comment|/* NB: these are not reset-on-read */
name|phyCnt1
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_1
argument_list|)
expr_stmt|;
name|phyCnt2
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_2
argument_list|)
expr_stmt|;
comment|/* not used, always reset them in case they are the cause */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_FILTOFDM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_FILTCCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_SLP_MIB_CTRL
argument_list|)
operator|&
name|AR_SLP_MIB_PENDING
operator|)
operator|==
literal|0
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_SLP_MIB_CTRL
argument_list|,
name|AR_SLP_MIB_CLEAR
argument_list|)
expr_stmt|;
comment|/* Clear the mib counters and save them in the stats */
name|ar5212UpdateMibCounters
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_mibStats
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_nodestats
operator|=
operator|*
name|stats
expr_stmt|;
comment|/* 	 * Check for an ani stat hitting the trigger threshold. 	 * When this happens we get a MIB interrupt and the top 	 * 2 bits of the counter register will be 0b11, hence 	 * the mask check of phyCnt?. 	 */
if|if
condition|(
operator|(
operator|(
name|phyCnt1
operator|&
name|AR_MIBCNT_INTRMASK
operator|)
operator|==
name|AR_MIBCNT_INTRMASK
operator|)
operator|||
operator|(
operator|(
name|phyCnt2
operator|&
name|AR_MIBCNT_INTRMASK
operator|)
operator|==
name|AR_MIBCNT_INTRMASK
operator|)
condition|)
block|{
name|struct
name|ar5212AniState
modifier|*
name|aniState
init|=
name|ahp
operator|->
name|ah_curani
decl_stmt|;
specifier|const
name|struct
name|ar5212AniParams
modifier|*
name|params
init|=
name|aniState
operator|->
name|params
decl_stmt|;
name|uint32_t
name|ofdmPhyErrCnt
decl_stmt|,
name|cckPhyErrCnt
decl_stmt|;
name|ofdmPhyErrCnt
operator|=
name|phyCnt1
operator|-
name|params
operator|->
name|ofdmPhyErrBase
expr_stmt|;
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_ofdmerrs
operator|+=
name|ofdmPhyErrCnt
operator|-
name|aniState
operator|->
name|ofdmPhyErrCount
expr_stmt|;
name|aniState
operator|->
name|ofdmPhyErrCount
operator|=
name|ofdmPhyErrCnt
expr_stmt|;
name|cckPhyErrCnt
operator|=
name|phyCnt2
operator|-
name|params
operator|->
name|cckPhyErrBase
expr_stmt|;
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_cckerrs
operator|+=
name|cckPhyErrCnt
operator|-
name|aniState
operator|->
name|cckPhyErrCount
expr_stmt|;
name|aniState
operator|->
name|cckPhyErrCount
operator|=
name|cckPhyErrCnt
expr_stmt|;
comment|/* 		 * NB: figure out which counter triggered.  If both 		 * trigger we'll only deal with one as the processing 		 * clobbers the error counter so the trigger threshold 		 * check will never be true. 		 */
if|if
condition|(
name|aniState
operator|->
name|ofdmPhyErrCount
operator|>
name|params
operator|->
name|ofdmTrigHigh
condition|)
name|ar5416AniOfdmErrTrigger
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|aniState
operator|->
name|cckPhyErrCount
operator|>
name|params
operator|->
name|cckTrigHigh
condition|)
name|ar5416AniCckErrTrigger
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* NB: always restart to insure the h/w counters are reset */
name|ar5416AniRestart
argument_list|(
name|ah
argument_list|,
name|aniState
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ar5416AniLowerImmunity
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar5212AniState
modifier|*
name|aniState
decl_stmt|;
specifier|const
name|struct
name|ar5212AniParams
modifier|*
name|params
decl_stmt|;
name|HALASSERT
argument_list|(
name|ANI_ENA
argument_list|(
name|ah
argument_list|)
argument_list|)
expr_stmt|;
name|aniState
operator|=
name|ahp
operator|->
name|ah_curani
expr_stmt|;
name|params
operator|=
name|aniState
operator|->
name|params
expr_stmt|;
if|if
condition|(
name|ANI_ENA_RSSI
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|int32_t
name|rssi
init|=
name|BEACON_RSSI
argument_list|(
name|ahp
argument_list|)
decl_stmt|;
if|if
condition|(
name|rssi
operator|>
name|params
operator|->
name|rssiThrHigh
condition|)
block|{
comment|/*  			 * Beacon signal is high, leave ofdm weak signal 			 * detection off or it may oscillate.  Let it fall 			 * through. 			 */
block|}
elseif|else
if|if
condition|(
name|rssi
operator|>
name|params
operator|->
name|rssiThrLow
condition|)
block|{
comment|/* 			 * Beacon rssi in mid range, turn on ofdm weak signal 			 * detection or lower firstep level. 			 */
if|if
condition|(
name|aniState
operator|->
name|ofdmWeakSigDetectOff
condition|)
block|{
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_OFDM_WEAK_SIGNAL_DETECTION
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|aniState
operator|->
name|firstepLevel
operator|>
literal|0
condition|)
block|{
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_FIRSTEP_LEVEL
argument_list|,
name|aniState
operator|->
name|firstepLevel
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* 			 * Beacon rssi is low, reduce firstep level. 			 */
if|if
condition|(
name|aniState
operator|->
name|firstepLevel
operator|>
literal|0
condition|)
block|{
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_FIRSTEP_LEVEL
argument_list|,
name|aniState
operator|->
name|firstepLevel
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* then lower spur immunity level, down to zero */
if|if
condition|(
name|aniState
operator|->
name|spurImmunityLevel
operator|>
literal|0
condition|)
block|{
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_SPUR_IMMUNITY_LEVEL
argument_list|,
name|aniState
operator|->
name|spurImmunityLevel
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  	 * if all else fails, lower noise immunity level down to a min value 	 * zero for now 	 */
if|if
condition|(
name|aniState
operator|->
name|noiseImmunityLevel
operator|>
literal|0
condition|)
block|{
name|ar5416AniControl
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_NOISE_IMMUNITY_LEVEL
argument_list|,
name|aniState
operator|->
name|noiseImmunityLevel
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|CLOCK_RATE
value|44000
end_define

begin_comment
comment|/* XXX use mac_usec or similar */
end_comment

begin_comment
comment|/* convert HW counter values to ms using 11g clock rate, goo9d enough    for 11a and Turbo */
end_comment

begin_comment
comment|/*   * Return an approximation of the time spent ``listening'' by  * deducting the cycles spent tx'ing and rx'ing from the total  * cycle count since our last call.  A return value<0 indicates  * an invalid/inconsistent time.  */
end_comment

begin_function
specifier|static
name|int32_t
name|ar5416AniGetListenTime
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar5212AniState
modifier|*
name|aniState
decl_stmt|;
name|uint32_t
name|txFrameCount
decl_stmt|,
name|rxFrameCount
decl_stmt|,
name|cycleCount
decl_stmt|;
name|int32_t
name|listenTime
decl_stmt|;
name|txFrameCount
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TFCNT
argument_list|)
expr_stmt|;
name|rxFrameCount
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RFCNT
argument_list|)
expr_stmt|;
name|cycleCount
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_CCCNT
argument_list|)
expr_stmt|;
name|aniState
operator|=
name|ahp
operator|->
name|ah_curani
expr_stmt|;
if|if
condition|(
name|aniState
operator|->
name|cycleCount
operator|==
literal|0
operator|||
name|aniState
operator|->
name|cycleCount
operator|>
name|cycleCount
condition|)
block|{
comment|/* 		 * Cycle counter wrap (or initial call); it's not possible 		 * to accurately calculate a value because the registers 		 * right shift rather than wrap--so punt and return 0. 		 */
name|listenTime
operator|=
literal|0
expr_stmt|;
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_lzero
operator|++
expr_stmt|;
block|}
else|else
block|{
name|int32_t
name|ccdelta
init|=
name|cycleCount
operator|-
name|aniState
operator|->
name|cycleCount
decl_stmt|;
name|int32_t
name|rfdelta
init|=
name|rxFrameCount
operator|-
name|aniState
operator|->
name|rxFrameCount
decl_stmt|;
name|int32_t
name|tfdelta
init|=
name|txFrameCount
operator|-
name|aniState
operator|->
name|txFrameCount
decl_stmt|;
name|listenTime
operator|=
operator|(
name|ccdelta
operator|-
name|rfdelta
operator|-
name|tfdelta
operator|)
operator|/
name|CLOCK_RATE
expr_stmt|;
block|}
name|aniState
operator|->
name|cycleCount
operator|=
name|cycleCount
expr_stmt|;
name|aniState
operator|->
name|txFrameCount
operator|=
name|txFrameCount
expr_stmt|;
name|aniState
operator|->
name|rxFrameCount
operator|=
name|rxFrameCount
expr_stmt|;
return|return
name|listenTime
return|;
block|}
end_function

begin_comment
comment|/*  * Update ani stats in preparation for listen time processing.  */
end_comment

begin_function
specifier|static
name|void
name|updateMIBStats
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ar5212AniState
modifier|*
name|aniState
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|ar5212AniParams
modifier|*
name|params
init|=
name|aniState
operator|->
name|params
decl_stmt|;
name|uint32_t
name|phyCnt1
decl_stmt|,
name|phyCnt2
decl_stmt|;
name|int32_t
name|ofdmPhyErrCnt
decl_stmt|,
name|cckPhyErrCnt
decl_stmt|;
comment|/* Clear the mib counters and save them in the stats */
name|ar5212UpdateMibCounters
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_mibStats
argument_list|)
expr_stmt|;
comment|/* NB: these are not reset-on-read */
name|phyCnt1
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_1
argument_list|)
expr_stmt|;
name|phyCnt2
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_2
argument_list|)
expr_stmt|;
comment|/* NB: these are spec'd to never roll-over */
name|ofdmPhyErrCnt
operator|=
name|phyCnt1
operator|-
name|params
operator|->
name|ofdmPhyErrBase
expr_stmt|;
if|if
condition|(
name|ofdmPhyErrCnt
operator|<
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"OFDM phyErrCnt %d phyCnt1 0x%x\n"
argument_list|,
name|ofdmPhyErrCnt
argument_list|,
name|phyCnt1
argument_list|)
expr_stmt|;
name|ofdmPhyErrCnt
operator|=
name|AR_PHY_COUNTMAX
expr_stmt|;
block|}
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_ofdmerrs
operator|+=
name|ofdmPhyErrCnt
operator|-
name|aniState
operator|->
name|ofdmPhyErrCount
expr_stmt|;
name|aniState
operator|->
name|ofdmPhyErrCount
operator|=
name|ofdmPhyErrCnt
expr_stmt|;
name|cckPhyErrCnt
operator|=
name|phyCnt2
operator|-
name|params
operator|->
name|cckPhyErrBase
expr_stmt|;
if|if
condition|(
name|cckPhyErrCnt
operator|<
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"CCK phyErrCnt %d phyCnt2 0x%x\n"
argument_list|,
name|cckPhyErrCnt
argument_list|,
name|phyCnt2
argument_list|)
expr_stmt|;
name|cckPhyErrCnt
operator|=
name|AR_PHY_COUNTMAX
expr_stmt|;
block|}
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_cckerrs
operator|+=
name|cckPhyErrCnt
operator|-
name|aniState
operator|->
name|cckPhyErrCount
expr_stmt|;
name|aniState
operator|->
name|cckPhyErrCount
operator|=
name|cckPhyErrCnt
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do periodic processing.  This routine is called from the  * driver's rx interrupt handler after processing frames.  */
end_comment

begin_function
name|void
name|ar5416AniPoll
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_NODE_STATS
modifier|*
name|stats
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar5212AniState
modifier|*
name|aniState
init|=
name|ahp
operator|->
name|ah_curani
decl_stmt|;
specifier|const
name|struct
name|ar5212AniParams
modifier|*
name|params
decl_stmt|;
name|int32_t
name|listenTime
decl_stmt|;
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_nodestats
operator|.
name|ns_avgbrssi
operator|=
name|stats
operator|->
name|ns_avgbrssi
expr_stmt|;
comment|/* XXX can aniState be null? */
if|if
condition|(
name|aniState
operator|==
name|AH_NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|ANI_ENA
argument_list|(
name|ah
argument_list|)
condition|)
return|return;
name|listenTime
operator|=
name|ar5416AniGetListenTime
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|listenTime
operator|<
literal|0
condition|)
block|{
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_lneg
operator|++
expr_stmt|;
comment|/* restart ANI period if listenTime is invalid */
name|ar5416AniRestart
argument_list|(
name|ah
argument_list|,
name|aniState
argument_list|)
expr_stmt|;
block|}
comment|/* XXX beware of overflow? */
name|aniState
operator|->
name|listenTime
operator|+=
name|listenTime
expr_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_ANI_POLL
argument_list|,
name|aniState
operator|->
name|listenTime
argument_list|)
expr_stmt|;
name|params
operator|=
name|aniState
operator|->
name|params
expr_stmt|;
if|if
condition|(
name|aniState
operator|->
name|listenTime
operator|>
literal|5
operator|*
name|params
operator|->
name|period
condition|)
block|{
comment|/*  		 * Check to see if need to lower immunity if 		 * 5 aniPeriods have passed 		 */
name|updateMIBStats
argument_list|(
name|ah
argument_list|,
name|aniState
argument_list|)
expr_stmt|;
if|if
condition|(
name|aniState
operator|->
name|ofdmPhyErrCount
operator|<=
name|aniState
operator|->
name|listenTime
operator|*
name|params
operator|->
name|ofdmTrigLow
operator|/
literal|1000
operator|&&
name|aniState
operator|->
name|cckPhyErrCount
operator|<=
name|aniState
operator|->
name|listenTime
operator|*
name|params
operator|->
name|cckTrigLow
operator|/
literal|1000
condition|)
name|ar5416AniLowerImmunity
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ar5416AniRestart
argument_list|(
name|ah
argument_list|,
name|aniState
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aniState
operator|->
name|listenTime
operator|>
name|params
operator|->
name|period
condition|)
block|{
name|updateMIBStats
argument_list|(
name|ah
argument_list|,
name|aniState
argument_list|)
expr_stmt|;
comment|/* check to see if need to raise immunity */
if|if
condition|(
name|aniState
operator|->
name|ofdmPhyErrCount
operator|>
name|aniState
operator|->
name|listenTime
operator|*
name|params
operator|->
name|ofdmTrigHigh
operator|/
literal|1000
condition|)
block|{
name|ar5416AniOfdmErrTrigger
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ar5416AniRestart
argument_list|(
name|ah
argument_list|,
name|aniState
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aniState
operator|->
name|cckPhyErrCount
operator|>
name|aniState
operator|->
name|listenTime
operator|*
name|params
operator|->
name|cckTrigHigh
operator|/
literal|1000
condition|)
block|{
name|ar5416AniCckErrTrigger
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ar5416AniRestart
argument_list|(
name|ah
argument_list|,
name|aniState
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

