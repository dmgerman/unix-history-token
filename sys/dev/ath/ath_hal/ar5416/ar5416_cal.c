begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2002-2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_devid.h"
end_include

begin_include
include|#
directive|include
file|"ah_eeprom_v14.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212.h"
end_include

begin_comment
comment|/* for NF cal related declarations */
end_comment

begin_include
include|#
directive|include
file|"ar5416/ar5416.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416phy.h"
end_include

begin_comment
comment|/* Owl specific stuff */
end_comment

begin_define
define|#
directive|define
name|NUM_NOISEFLOOR_READINGS
value|6
end_define

begin_comment
comment|/* 3 chains * (ctl + ext) */
end_comment

begin_function_decl
specifier|static
name|void
name|ar5416StartNFCal
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5416LoadNF
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int16_t
name|ar5416GetNf
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|ar5416GetDefaultNF
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5416SanitizeNF
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int16_t
modifier|*
name|nf
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Determine if calibration is supported by device and channel flags  */
end_comment

begin_comment
comment|/*  * ADC GAIN/DC offset calibration is for calibrating two ADCs that  * are acting as one by interleaving incoming symbols. This isn't  * relevant for 2.4GHz 20MHz wide modes because, as far as I can tell,  * the secondary ADC is never enabled. It is enabled however for  * 5GHz modes.  *  * It hasn't been confirmed whether doing this calibration is needed  * at all in the above modes and/or whether it's actually harmful.  * So for now, let's leave it enabled and just remember to get  * confirmation that it needs to be clarified.  *  * See US Patent No: US 7,541,952 B1:  *  " Method and Apparatus for Offset and Gain Compensation for  *    Analog-to-Digital Converters."  */
end_comment

begin_function
specifier|static
name|OS_INLINE
name|HAL_BOOL
name|ar5416IsCalSupp
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|HAL_CAL_TYPE
name|calType
parameter_list|)
block|{
name|struct
name|ar5416PerCal
modifier|*
name|cal
init|=
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
decl_stmt|;
switch|switch
condition|(
name|calType
operator|&
name|cal
operator|->
name|suppCals
condition|)
block|{
case|case
name|IQ_MISMATCH_CAL
case|:
comment|/* Run IQ Mismatch for non-CCK only */
return|return
operator|!
name|IEEE80211_IS_CHAN_B
argument_list|(
name|chan
argument_list|)
return|;
case|case
name|ADC_GAIN_CAL
case|:
case|case
name|ADC_DC_CAL
case|:
comment|/* Run ADC Gain Cal for either 5ghz any or 2ghz HT40 */
comment|/* 		 * Merlin (AR9280) doesn't ever complete ADC calibrations 		 * in 5ghz non-HT40 mode (ie, HT20, 11a). For now, disable 		 * it for Merlin only until further information is 		 * available. 		 */
if|if
condition|(
operator|!
name|AR_SREV_MERLIN
argument_list|(
name|ah
argument_list|)
condition|)
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|AH_TRUE
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|AH_TRUE
return|;
return|return
name|AH_FALSE
return|;
block|}
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Setup HW to collect samples used for current cal  */
end_comment

begin_function
specifier|static
name|void
name|ar5416SetupMeasurement
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CAL_LIST
modifier|*
name|currCal
parameter_list|)
block|{
comment|/* Start calibration w/ 2^(INIT_IQCAL_LOG_COUNT_MAX+1) samples */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|,
name|AR_PHY_TIMING_CTRL4_IQCAL_LOG_COUNT_MAX
argument_list|,
name|currCal
operator|->
name|calData
operator|->
name|calCountMax
argument_list|)
expr_stmt|;
comment|/* Select calibration to run */
switch|switch
condition|(
name|currCal
operator|->
name|calData
operator|->
name|calType
condition|)
block|{
case|case
name|IQ_MISMATCH_CAL
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CALMODE
argument_list|,
name|AR_PHY_CALMODE_IQ
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"%s: start IQ Mismatch calibration\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADC_GAIN_CAL
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CALMODE
argument_list|,
name|AR_PHY_CALMODE_ADC_GAIN
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"%s: start ADC Gain calibration\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADC_DC_CAL
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CALMODE
argument_list|,
name|AR_PHY_CALMODE_ADC_DC_PER
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"%s: start ADC DC calibration\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADC_DC_INIT_CAL
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CALMODE
argument_list|,
name|AR_PHY_CALMODE_ADC_DC_INIT
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"%s: start Init ADC DC calibration\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Kick-off cal */
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|,
name|AR_PHY_TIMING_CTRL4_DO_CAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize shared data structures and prepare a cal to be run.  */
end_comment

begin_function
specifier|static
name|void
name|ar5416ResetMeasurement
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CAL_LIST
modifier|*
name|currCal
parameter_list|)
block|{
name|struct
name|ar5416PerCal
modifier|*
name|cal
init|=
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
decl_stmt|;
comment|/* Reset data structures shared between different calibrations */
name|OS_MEMZERO
argument_list|(
name|cal
operator|->
name|caldata
argument_list|,
sizeof|sizeof
argument_list|(
name|cal
operator|->
name|caldata
argument_list|)
argument_list|)
expr_stmt|;
name|cal
operator|->
name|calSamples
operator|=
literal|0
expr_stmt|;
comment|/* Setup HW for new calibration */
name|ar5416SetupMeasurement
argument_list|(
name|ah
argument_list|,
name|currCal
argument_list|)
expr_stmt|;
comment|/* Change SW state to RUNNING for this calibration */
name|currCal
operator|->
name|calState
operator|=
name|CAL_RUNNING
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Run non-periodic calibrations.  */
end_comment

begin_comment
unit|static HAL_BOOL ar5416RunInitCals(struct ath_hal *ah, int init_cal_count) { 	struct ath_hal_5416 *ahp = AH5416(ah); 	struct ar5416PerCal *cal =&AH5416(ah)->ah_cal; 	HAL_CHANNEL_INTERNAL ichan;
comment|/* XXX bogus */
end_comment

begin_comment
unit|HAL_CAL_LIST *curCal = ahp->ah_cal_curr; 	HAL_BOOL isCalDone; 	int i;  	if (curCal == AH_NULL) 		return AH_FALSE;  	ichan.calValid = 0; 	for (i = 0; i< init_cal_count; i++) {
comment|/* Reset this Cal */
end_comment

begin_comment
unit|ar5416ResetMeasurement(ah, curCal);
comment|/* Poll for offset calibration complete */
end_comment

begin_comment
unit|if (!ath_hal_wait(ah, AR_PHY_TIMING_CTRL4, AR_PHY_TIMING_CTRL4_DO_CAL, 0)) { 			HALDEBUG(ah, HAL_DEBUG_ANY, 			    "%s: Cal %d failed to finish in 100ms.\n", 			    __func__, curCal->calData->calType);
comment|/* Re-initialize list pointers for periodic cals */
end_comment

begin_comment
unit|cal->cal_list = cal->cal_last = cal->cal_curr = AH_NULL; 			return AH_FALSE; 		}
comment|/* Run this cal */
end_comment

begin_comment
unit|ar5416DoCalibration(ah,&ichan, ahp->ah_rxchainmask, 		    curCal,&isCalDone); 		if (!isCalDone) 			HALDEBUG(ah, HAL_DEBUG_ANY, 			    "%s: init cal %d did not complete.\n", 			    __func__, curCal->calData->calType); 		if (curCal->calNext != AH_NULL) 			curCal = curCal->calNext; 	}
comment|/* Re-initialize list pointers for periodic cals */
end_comment

begin_endif
unit|cal->cal_list = cal->cal_last = cal->cal_curr = AH_NULL; 	return AH_TRUE; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * AGC calibration for the AR5416, AR9130, AR9160, AR9280.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5416InitCalHardware
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
if|if
condition|(
name|AR_SREV_MERLIN_10_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Disable ADC */
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ADC_CTL
argument_list|,
name|AR_PHY_ADC_CTL_OFF_PWDADC
argument_list|)
expr_stmt|;
comment|/* Enable Rx Filter Cal */
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_FLTR_CAL
argument_list|)
expr_stmt|;
block|}
comment|/* Calibrate the AGC */
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_CAL
argument_list|)
expr_stmt|;
comment|/* Poll for offset calibration complete */
if|if
condition|(
operator|!
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_CAL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: offset calibration did not complete in 1ms; "
literal|"noisy environment?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
if|if
condition|(
name|AR_SREV_MERLIN_10_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Enable ADC */
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ADC_CTL
argument_list|,
name|AR_PHY_ADC_CTL_OFF_PWDADC
argument_list|)
expr_stmt|;
comment|/* Disable Rx Filter Cal */
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_FLTR_CAL
argument_list|)
expr_stmt|;
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize Calibration infrastructure.  */
end_comment

begin_define
define|#
directive|define
name|MAX_CAL_CHECK
value|32
end_define

begin_function
name|HAL_BOOL
name|ar5416InitCal
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ar5416PerCal
modifier|*
name|cal
init|=
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
decl_stmt|;
name|ichan
operator|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|ichan
operator|!=
name|AH_NULL
argument_list|)
expr_stmt|;
comment|/* Do initial chipset-specific calibration */
if|if
condition|(
operator|!
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal_initcal
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: initial chipset calibration did "
literal|"not complete in time; noisy environment?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* If there's PA Cal, do it */
if|if
condition|(
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal_pacal
condition|)
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal_pacal
argument_list|(
name|ah
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
comment|/*  	 * Do NF calibration after DC offset and other CALs. 	 * Per system engineers, noise floor value can sometimes be 20 dB 	 * higher than normal value if DC offset and noise floor cal are 	 * triggered at the same time. 	 */
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_NF
argument_list|)
expr_stmt|;
comment|/* 	 * This may take a while to run; make sure subsequent 	 * calibration routines check that this has completed 	 * before reading the value and triggering a subsequent 	 * calibration. 	 */
comment|/* Initialize list pointers */
name|cal
operator|->
name|cal_list
operator|=
name|cal
operator|->
name|cal_last
operator|=
name|cal
operator|->
name|cal_curr
operator|=
name|AH_NULL
expr_stmt|;
comment|/* 	 * Enable IQ, ADC Gain, ADC DC Offset Cals 	 */
if|if
condition|(
name|AR_SREV_HOWL
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SOWL_10_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Setup all non-periodic, init time only calibrations */
comment|/* XXX: Init DC Offset not working yet */
if|#
directive|if
literal|0
block|if (ar5416IsCalSupp(ah, chan, ADC_DC_INIT_CAL)) { 			INIT_CAL(&cal->adcDcCalInitData); 			INSERT_CAL(cal,&cal->adcDcCalInitData); 		}
comment|/* Initialize current pointer to first element in list */
block|cal->cal_curr = cal->cal_list;  		if (cal->ah_cal_curr != AH_NULL&& !ar5416RunInitCals(ah, 0)) 			return AH_FALSE;
endif|#
directive|endif
block|}
comment|/* If Cals are supported, add them to list via INIT/INSERT_CAL */
if|if
condition|(
name|ar5416IsCalSupp
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|ADC_GAIN_CAL
argument_list|)
condition|)
block|{
name|INIT_CAL
argument_list|(
operator|&
name|cal
operator|->
name|adcGainCalData
argument_list|)
expr_stmt|;
name|INSERT_CAL
argument_list|(
name|cal
argument_list|,
operator|&
name|cal
operator|->
name|adcGainCalData
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"%s: enable ADC Gain Calibration.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ar5416IsCalSupp
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|ADC_DC_CAL
argument_list|)
condition|)
block|{
name|INIT_CAL
argument_list|(
operator|&
name|cal
operator|->
name|adcDcCalData
argument_list|)
expr_stmt|;
name|INSERT_CAL
argument_list|(
name|cal
argument_list|,
operator|&
name|cal
operator|->
name|adcDcCalData
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"%s: enable ADC DC Calibration.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ar5416IsCalSupp
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|IQ_MISMATCH_CAL
argument_list|)
condition|)
block|{
name|INIT_CAL
argument_list|(
operator|&
name|cal
operator|->
name|iqCalData
argument_list|)
expr_stmt|;
name|INSERT_CAL
argument_list|(
name|cal
argument_list|,
operator|&
name|cal
operator|->
name|iqCalData
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"%s: enable IQ Calibration.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize current pointer to first element in list */
name|cal
operator|->
name|cal_curr
operator|=
name|cal
operator|->
name|cal_list
expr_stmt|;
comment|/* Kick off measurements for the first cal */
if|if
condition|(
name|cal
operator|->
name|cal_curr
operator|!=
name|AH_NULL
condition|)
name|ar5416ResetMeasurement
argument_list|(
name|ah
argument_list|,
name|cal
operator|->
name|cal_curr
argument_list|)
expr_stmt|;
comment|/* Mark all calibrations on this channel as being invalid */
name|ichan
operator|->
name|calValid
operator|=
literal|0
expr_stmt|;
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|MAX_CAL_CHECK
block|}
end_function

begin_comment
comment|/*  * Entry point for upper layers to restart current cal.  * Reset the calibration valid bit in channel.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5416ResetCalValid
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ar5416PerCal
modifier|*
name|cal
init|=
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
init|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|HAL_CAL_LIST
modifier|*
name|currCal
init|=
name|cal
operator|->
name|cal_curr
decl_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_SOWL_10_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
if|if
condition|(
name|currCal
operator|==
name|AH_NULL
condition|)
return|return
name|AH_FALSE
return|;
if|if
condition|(
name|ichan
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel %u/0x%x; no mapping\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* 	 * Expected that this calibration has run before, post-reset. 	 * Current state should be done 	 */
if|if
condition|(
name|currCal
operator|->
name|calState
operator|!=
name|CAL_DONE
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: Calibration state incorrect, %d\n"
argument_list|,
name|__func__
argument_list|,
name|currCal
operator|->
name|calState
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* Verify Cal is supported on this channel */
if|if
condition|(
operator|!
name|ar5416IsCalSupp
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|currCal
operator|->
name|calData
operator|->
name|calType
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"%s: Resetting Cal %d state for channel %u/0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|currCal
operator|->
name|calData
operator|->
name|calType
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
comment|/* Disable cal validity in channel */
name|ichan
operator|->
name|calValid
operator|&=
operator|~
name|currCal
operator|->
name|calData
operator|->
name|calType
expr_stmt|;
name|currCal
operator|->
name|calState
operator|=
name|CAL_WAITING
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Recalibrate the lower PHY chips to account for temperature/environment  * changes.  */
end_comment

begin_function
specifier|static
name|void
name|ar5416DoCalibration
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
parameter_list|,
name|uint8_t
name|rxchainmask
parameter_list|,
name|HAL_CAL_LIST
modifier|*
name|currCal
parameter_list|,
name|HAL_BOOL
modifier|*
name|isCalDone
parameter_list|)
block|{
name|struct
name|ar5416PerCal
modifier|*
name|cal
init|=
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
decl_stmt|;
comment|/* Cal is assumed not done until explicitly set below */
operator|*
name|isCalDone
operator|=
name|AH_FALSE
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"%s: %s Calibration, state %d, calValid 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|currCal
operator|->
name|calData
operator|->
name|calName
argument_list|,
name|currCal
operator|->
name|calState
argument_list|,
name|ichan
operator|->
name|calValid
argument_list|)
expr_stmt|;
comment|/* Calibration in progress. */
if|if
condition|(
name|currCal
operator|->
name|calState
operator|==
name|CAL_RUNNING
condition|)
block|{
comment|/* Check to see if it has finished. */
if|if
condition|(
operator|!
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|)
operator|&
name|AR_PHY_TIMING_CTRL4_DO_CAL
operator|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"%s: sample %d of %d finished\n"
argument_list|,
name|__func__
argument_list|,
name|cal
operator|->
name|calSamples
argument_list|,
name|currCal
operator|->
name|calData
operator|->
name|calNumSamples
argument_list|)
expr_stmt|;
comment|/*  			 * Collect measurements for active chains. 			 */
name|currCal
operator|->
name|calData
operator|->
name|calCollect
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|cal
operator|->
name|calSamples
operator|>=
name|currCal
operator|->
name|calData
operator|->
name|calNumSamples
condition|)
block|{
name|int
name|i
decl_stmt|,
name|numChains
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR5416_MAX_CHAINS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rxchainmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|numChains
operator|++
expr_stmt|;
block|}
comment|/*  				 * Process accumulated data 				 */
name|currCal
operator|->
name|calData
operator|->
name|calPostProc
argument_list|(
name|ah
argument_list|,
name|numChains
argument_list|)
expr_stmt|;
comment|/* Calibration has finished. */
name|ichan
operator|->
name|calValid
operator||=
name|currCal
operator|->
name|calData
operator|->
name|calType
expr_stmt|;
name|currCal
operator|->
name|calState
operator|=
name|CAL_DONE
expr_stmt|;
operator|*
name|isCalDone
operator|=
name|AH_TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Set-up to collect of another sub-sample. 				 */
name|ar5416SetupMeasurement
argument_list|(
name|ah
argument_list|,
name|currCal
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|ichan
operator|->
name|calValid
operator|&
name|currCal
operator|->
name|calData
operator|->
name|calType
operator|)
condition|)
block|{
comment|/* If current cal is marked invalid in channel, kick it off */
name|ar5416ResetMeasurement
argument_list|(
name|ah
argument_list|,
name|currCal
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Internal interface to schedule periodic calibration work.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5416PerCalibrationN
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|u_int
name|rxchainmask
parameter_list|,
name|HAL_BOOL
name|longcal
parameter_list|,
name|HAL_BOOL
modifier|*
name|isCalDone
parameter_list|)
block|{
name|struct
name|ar5416PerCal
modifier|*
name|cal
init|=
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
decl_stmt|;
name|HAL_CAL_LIST
modifier|*
name|currCal
init|=
name|cal
operator|->
name|cal_curr
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
decl_stmt|;
name|int
name|r
decl_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_PERCAL
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
operator|*
name|isCalDone
operator|=
name|AH_TRUE
expr_stmt|;
comment|/* 	 * Since ath_hal calls the PerCal method with rxchainmask=0x1; 	 * override it with the current chainmask. The upper levels currently 	 * doesn't know about the chainmask. 	 */
name|rxchainmask
operator|=
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rx_chainmask
expr_stmt|;
comment|/* Invalid channel check */
name|ichan
operator|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ichan
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel %u/0x%x; no mapping\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* 	 * For given calibration: 	 * 1. Call generic cal routine 	 * 2. When this cal is done (isCalDone) if we have more cals waiting 	 *    (eg after reset), mask this to upper layers by not propagating 	 *    isCalDone if it is set to TRUE. 	 *    Instead, change isCalDone to FALSE and setup the waiting cal(s) 	 *    to be run. 	 */
if|if
condition|(
name|currCal
operator|!=
name|AH_NULL
operator|&&
operator|(
name|currCal
operator|->
name|calState
operator|==
name|CAL_RUNNING
operator|||
name|currCal
operator|->
name|calState
operator|==
name|CAL_WAITING
operator|)
condition|)
block|{
name|ar5416DoCalibration
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|,
name|rxchainmask
argument_list|,
name|currCal
argument_list|,
name|isCalDone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|isCalDone
operator|==
name|AH_TRUE
condition|)
block|{
name|cal
operator|->
name|cal_curr
operator|=
name|currCal
operator|=
name|currCal
operator|->
name|calNext
expr_stmt|;
if|if
condition|(
name|currCal
operator|->
name|calState
operator|==
name|CAL_WAITING
condition|)
block|{
operator|*
name|isCalDone
operator|=
name|AH_FALSE
expr_stmt|;
name|ar5416ResetMeasurement
argument_list|(
name|ah
argument_list|,
name|currCal
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Do NF cal only at longer intervals */
if|if
condition|(
name|longcal
condition|)
block|{
comment|/* Do PA calibration if the chipset supports */
if|if
condition|(
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal_pacal
condition|)
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal_pacal
argument_list|(
name|ah
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
comment|/* Do open-loop temperature compensation if the chipset needs it */
if|if
condition|(
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_OL_PWRCTRL
argument_list|)
condition|)
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_olcTempCompensation
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 		 * Get the value from the previous NF cal 		 * and update the history buffer. 		 */
name|r
operator|=
name|ar5416GetNf
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
operator|||
name|r
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* NF calibration result isn't valid */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: NF calibration"
literal|" didn't finish; delaying CCA\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  			 * NF calibration result is valid. 			 * 			 * Load the NF from history buffer of the current channel. 			 * NF is slow time-variant, so it is OK to use a 			 * historical value. 			 */
name|ar5416LoadNF
argument_list|(
name|ah
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
argument_list|)
expr_stmt|;
comment|/* start NF calibration, without updating BB NF register*/
name|ar5416StartNFCal
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Recalibrate the lower PHY chips to account for temperature/environment  * changes.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5416PerCalibration
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|HAL_BOOL
modifier|*
name|isIQdone
parameter_list|)
block|{
name|struct
name|ath_hal_5416
modifier|*
name|ahp
init|=
name|AH5416
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar5416PerCal
modifier|*
name|cal
init|=
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
decl_stmt|;
name|HAL_CAL_LIST
modifier|*
name|curCal
init|=
name|cal
operator|->
name|cal_curr
decl_stmt|;
if|if
condition|(
name|curCal
operator|!=
name|AH_NULL
operator|&&
name|curCal
operator|->
name|calData
operator|->
name|calType
operator|==
name|IQ_MISMATCH_CAL
condition|)
block|{
return|return
name|ar5416PerCalibrationN
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|ahp
operator|->
name|ah_rx_chainmask
argument_list|,
name|AH_TRUE
argument_list|,
name|isIQdone
argument_list|)
return|;
block|}
else|else
block|{
name|HAL_BOOL
name|isCalDone
decl_stmt|;
operator|*
name|isIQdone
operator|=
name|AH_FALSE
expr_stmt|;
return|return
name|ar5416PerCalibrationN
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|ahp
operator|->
name|ah_rx_chainmask
argument_list|,
name|AH_TRUE
argument_list|,
operator|&
name|isCalDone
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|ar5416GetEepromNoiseFloorThresh
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|int16_t
modifier|*
name|nft
parameter_list|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_NFTHRESH_5
argument_list|,
name|nft
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_NFTHRESH_2
argument_list|,
name|nft
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar5416StartNFCal
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_ENABLE_NF
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_NO_UPDATE_NF
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_NF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar5416LoadNF
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
specifier|static
specifier|const
name|uint32_t
name|ar5416_cca_regs
index|[]
init|=
block|{
name|AR_PHY_CCA
block|,
name|AR_PHY_CH1_CCA
block|,
name|AR_PHY_CH2_CCA
block|,
name|AR_PHY_EXT_CCA
block|,
name|AR_PHY_CH1_EXT_CCA
block|,
name|AR_PHY_CH2_EXT_CCA
block|}
decl_stmt|;
name|struct
name|ar5212NfCalHist
modifier|*
name|h
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int32_t
name|val
decl_stmt|;
name|uint8_t
name|chainmask
decl_stmt|;
name|int16_t
name|default_nf
init|=
name|ar5416GetDefaultNF
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
comment|/* 	 * Force NF calibration for all chains. 	 */
if|if
condition|(
name|AR_SREV_KITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Kite has only one chain */
name|chainmask
operator|=
literal|0x9
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_MERLIN
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_KIWI
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Merlin/Kiwi has only two chains */
name|chainmask
operator|=
literal|0x1B
expr_stmt|;
block|}
else|else
block|{
name|chainmask
operator|=
literal|0x3F
expr_stmt|;
block|}
comment|/* 	 * Write filtered NF values into maxCCApwr register parameter 	 * so we can load below. 	 */
name|h
operator|=
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
operator|.
name|nfCalHist
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"CCA: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR5416_NUM_NF_READINGS
condition|;
name|i
operator|++
control|)
block|{
comment|/* Don't write to EXT radio CCA registers unless in HT/40 mode */
comment|/* XXX this check should really be cleaner! */
if|if
condition|(
name|i
operator|>
literal|2
operator|&&
operator|!
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|chainmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|int16_t
name|nf_val
decl_stmt|;
if|if
condition|(
name|h
condition|)
name|nf_val
operator|=
name|h
index|[
name|i
index|]
operator|.
name|privNF
expr_stmt|;
else|else
name|nf_val
operator|=
name|default_nf
expr_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|ar5416_cca_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|0xFFFFFE00
expr_stmt|;
name|val
operator||=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|nf_val
operator|<<
literal|1
operator|)
operator|&
literal|0x1ff
operator|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"[%d: %d]"
argument_list|,
name|i
argument_list|,
name|nf_val
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|ar5416_cca_regs
index|[
name|i
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Load software filtered NF value into baseband internal minCCApwr variable. */
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_ENABLE_NF
argument_list|)
expr_stmt|;
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_NO_UPDATE_NF
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_NF
argument_list|)
expr_stmt|;
comment|/* Wait for load to complete, should be fast, a few 10s of us. */
if|if
condition|(
operator|!
name|ar5212WaitNFCalComplete
argument_list|(
name|ah
argument_list|,
literal|1000
argument_list|)
condition|)
block|{
comment|/* 		 * We timed out waiting for the noisefloor to load, probably due to an 		 * in-progress rx. Simply return here and allow the load plenty of time 		 * to complete before the next calibration interval.  We need to avoid 		 * trying to load -50 (which happens below) while the previous load is 		 * still in progress as this can cause rx deafness. Instead by returning 		 * here, the baseband nf cal will just be capped by our present 		 * noisefloor until the next calibration timer. 		 */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"Timeout while waiting for "
literal|"nf to load: AR_PHY_AGC_CONTROL=0x%x\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Restore maxCCAPower register parameter again so that we're not capped 	 * by the median we just loaded.  This will be initial (and max) value 	 * of next noise floor calibration the baseband does.   	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR5416_NUM_NF_READINGS
condition|;
name|i
operator|++
control|)
comment|/* Don't write to EXT radio CCA registers unless in HT/40 mode */
comment|/* XXX this check should really be cleaner! */
if|if
condition|(
name|i
operator|>
literal|2
operator|&&
operator|!
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|chainmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|ar5416_cca_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|0xFFFFFE00
expr_stmt|;
name|val
operator||=
operator|(
operator|(
call|(
name|uint32_t
call|)
argument_list|(
operator|-
literal|50
argument_list|)
operator|<<
literal|1
operator|)
operator|&
literal|0x1ff
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|ar5416_cca_regs
index|[
name|i
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This just initialises the "good" values for AR5416 which  * may not be right; it'lll be overridden by ar5416SanitizeNF()  * to nominal values.  */
end_comment

begin_function
name|void
name|ar5416InitNfHistBuff
parameter_list|(
name|struct
name|ar5212NfCalHist
modifier|*
name|h
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR5416_NUM_NF_READINGS
condition|;
name|i
operator|++
control|)
block|{
name|h
index|[
name|i
index|]
operator|.
name|currIndex
operator|=
literal|0
expr_stmt|;
name|h
index|[
name|i
index|]
operator|.
name|privNF
operator|=
name|AR5416_CCA_MAX_GOOD_VALUE
expr_stmt|;
name|h
index|[
name|i
index|]
operator|.
name|invalidNFcount
operator|=
name|AR512_NF_CAL_HIST_MAX
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|AR512_NF_CAL_HIST_MAX
condition|;
name|j
operator|++
control|)
name|h
index|[
name|i
index|]
operator|.
name|nfCalBuffer
index|[
name|j
index|]
operator|=
name|AR5416_CCA_MAX_GOOD_VALUE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Update the noise floor buffer as a ring buffer  */
end_comment

begin_function
specifier|static
name|void
name|ar5416UpdateNFHistBuff
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ar5212NfCalHist
modifier|*
name|h
parameter_list|,
name|int16_t
modifier|*
name|nfarray
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* XXX TODO: don't record nfarray[] entries for inactive chains */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR5416_NUM_NF_READINGS
condition|;
name|i
operator|++
control|)
block|{
name|h
index|[
name|i
index|]
operator|.
name|nfCalBuffer
index|[
name|h
index|[
name|i
index|]
operator|.
name|currIndex
index|]
operator|=
name|nfarray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|h
index|[
name|i
index|]
operator|.
name|currIndex
operator|>=
name|AR512_NF_CAL_HIST_MAX
condition|)
name|h
index|[
name|i
index|]
operator|.
name|currIndex
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h
index|[
name|i
index|]
operator|.
name|invalidNFcount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|nfarray
index|[
name|i
index|]
operator|<
name|AR5416_CCA_MIN_BAD_VALUE
operator|||
name|nfarray
index|[
name|i
index|]
operator|>
name|AR5416_CCA_MAX_HIGH_VALUE
condition|)
block|{
name|h
index|[
name|i
index|]
operator|.
name|invalidNFcount
operator|=
name|AR512_NF_CAL_HIST_MAX
expr_stmt|;
block|}
else|else
block|{
name|h
index|[
name|i
index|]
operator|.
name|invalidNFcount
operator|--
expr_stmt|;
name|h
index|[
name|i
index|]
operator|.
name|privNF
operator|=
name|nfarray
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|h
index|[
name|i
index|]
operator|.
name|privNF
operator|=
name|ar5212GetNfHistMid
argument_list|(
name|h
index|[
name|i
index|]
operator|.
name|nfCalBuffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|ar5416GetDefaultNF
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ar5416NfLimits
modifier|*
name|limit
decl_stmt|;
if|if
condition|(
operator|!
name|chan
operator|||
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
name|limit
operator|=
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_2g
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_5g
expr_stmt|;
return|return
name|limit
operator|->
name|nominal
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar5416SanitizeNF
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int16_t
modifier|*
name|nf
parameter_list|)
block|{
name|struct
name|ar5416NfLimits
modifier|*
name|limit
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
argument_list|)
condition|)
name|limit
operator|=
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_2g
expr_stmt|;
else|else
name|limit
operator|=
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_5g
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR5416_NUM_NF_READINGS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|nf
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|nf
index|[
name|i
index|]
operator|>
name|limit
operator|->
name|max
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"NF[%d] (%d)> MAX (%d), correcting to MAX\n"
argument_list|,
name|i
argument_list|,
name|nf
index|[
name|i
index|]
argument_list|,
name|limit
operator|->
name|max
argument_list|)
expr_stmt|;
name|nf
index|[
name|i
index|]
operator|=
name|limit
operator|->
name|max
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nf
index|[
name|i
index|]
operator|<
name|limit
operator|->
name|min
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"NF[%d] (%d)< MIN (%d), correcting to NOM\n"
argument_list|,
name|i
argument_list|,
name|nf
index|[
name|i
index|]
argument_list|,
name|limit
operator|->
name|min
argument_list|)
expr_stmt|;
name|nf
index|[
name|i
index|]
operator|=
name|limit
operator|->
name|nominal
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Read the NF and check it against the noise floor threshhold  *  * Return 0 if the NF calibration hadn't finished, 0 if it was  * invalid, or> 0 for a valid NF reading.  */
end_comment

begin_function
specifier|static
name|int16_t
name|ar5416GetNf
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|int16_t
name|nf
decl_stmt|,
name|nfThresh
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ar5212IsNFCalInProgress
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: NF didn't complete in calibration window\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|nf
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* NF didn't finish */
block|}
else|else
block|{
comment|/* Finished NF cal, check against threshold */
name|int16_t
name|nfarray
index|[
name|NUM_NOISEFLOOR_READINGS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
init|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
comment|/* TODO - enhance for multiple chains and ext ch */
name|ath_hal_getNoiseFloor
argument_list|(
name|ah
argument_list|,
name|nfarray
argument_list|)
expr_stmt|;
name|nf
operator|=
name|nfarray
index|[
literal|0
index|]
expr_stmt|;
name|ar5416SanitizeNF
argument_list|(
name|ah
argument_list|,
name|nfarray
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar5416GetEepromNoiseFloorThresh
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|&
name|nfThresh
argument_list|)
condition|)
block|{
if|if
condition|(
name|nf
operator|>
name|nfThresh
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: noise floor failed detected; "
literal|"detected %d, threshold %d\n"
argument_list|,
name|__func__
argument_list|,
name|nf
argument_list|,
name|nfThresh
argument_list|)
expr_stmt|;
comment|/* 				 * NB: Don't discriminate 2.4 vs 5Ghz, if this 				 *     happens it indicates a problem regardless 				 *     of the band. 				 */
name|chan
operator|->
name|ic_state
operator||=
name|IEEE80211_CHANSTATE_CWINT
expr_stmt|;
name|nf
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|nf
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Update MIMO channel statistics, regardless of validity or not (for now) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|ichan
operator|->
name|noiseFloorCtl
index|[
name|i
index|]
operator|=
name|nfarray
index|[
name|i
index|]
expr_stmt|;
name|ichan
operator|->
name|noiseFloorExt
index|[
name|i
index|]
operator|=
name|nfarray
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
block|}
name|ichan
operator|->
name|privFlags
operator||=
name|CHANNEL_MIMO_NF_VALID
expr_stmt|;
name|ar5416UpdateNFHistBuff
argument_list|(
name|ah
argument_list|,
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
operator|.
name|nfCalHist
argument_list|,
name|nfarray
argument_list|)
expr_stmt|;
name|ichan
operator|->
name|rawNoiseFloor
operator|=
name|nf
expr_stmt|;
name|retval
operator|=
name|nf
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

end_unit

