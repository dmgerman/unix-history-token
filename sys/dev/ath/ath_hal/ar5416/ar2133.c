begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2002-2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_eeprom_v14.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416phy.h"
end_include

begin_define
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
end_define

begin_struct
struct|struct
name|ar2133State
block|{
name|RF_HAL_FUNCS
name|base
decl_stmt|;
comment|/* public state, must be first */
name|uint16_t
name|pcdacTable
index|[
literal|1
index|]
decl_stmt|;
name|uint32_t
modifier|*
name|Bank0Data
decl_stmt|;
name|uint32_t
modifier|*
name|Bank1Data
decl_stmt|;
name|uint32_t
modifier|*
name|Bank2Data
decl_stmt|;
name|uint32_t
modifier|*
name|Bank3Data
decl_stmt|;
name|uint32_t
modifier|*
name|Bank6Data
decl_stmt|;
name|uint32_t
modifier|*
name|Bank7Data
decl_stmt|;
comment|/* NB: Bank*Data storage follows */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|AR2133
parameter_list|(
name|ah
parameter_list|)
value|((struct ar2133State *) AH5212(ah)->ah_rfHal)
end_define

begin_define
define|#
directive|define
name|ar5416ModifyRfBuffer
value|ar5212ModifyRfBuffer
end_define

begin_comment
comment|/*XXX*/
end_comment

begin_function_decl
name|void
name|ar5416ModifyRfBuffer
parameter_list|(
name|uint32_t
modifier|*
name|rfBuf
parameter_list|,
name|uint32_t
name|reg32
parameter_list|,
name|uint32_t
name|numBits
parameter_list|,
name|uint32_t
name|firstBit
parameter_list|,
name|uint32_t
name|column
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|ar2133WriteRegs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|modesIndex
parameter_list|,
name|u_int
name|freqIndex
parameter_list|,
name|int
name|writes
parameter_list|)
block|{
operator|(
name|void
operator|)
name|ath_hal_ini_write
argument_list|(
name|ah
argument_list|,
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bb_rfgain
argument_list|,
name|freqIndex
argument_list|,
name|writes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fix on 2.4 GHz band for orientation sensitivity issue by increasing  * rf_pwd_icsyndiv.  *   * Theoretical Rules:  *   if 2 GHz band  *      if forceBiasAuto  *         if synth_freq< 2412  *            bias = 0  *         else if 2412<= synth_freq<= 2422  *            bias = 1  *         else // synth_freq> 2422  *            bias = 2  *      else if forceBias> 0  *         bias = forceBias& 7  *      else  *         no change, use value from ini file  *   else  *      no change, invalid band  *  *  1st Mod:  *    2422 also uses value of 2  *<approved>  *  *  2nd Mod:  *    Less than 2412 uses value of 0, 2412 and above uses value of 2  */
end_comment

begin_function
specifier|static
name|void
name|ar2133ForceBias
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint16_t
name|synth_freq
parameter_list|)
block|{
name|uint32_t
name|tmp_reg
decl_stmt|;
name|int
name|reg_writes
init|=
literal|0
decl_stmt|;
name|uint32_t
name|new_bias
init|=
literal|0
decl_stmt|;
name|struct
name|ar2133State
modifier|*
name|priv
init|=
name|AR2133
argument_list|(
name|ah
argument_list|)
decl_stmt|;
comment|/* XXX this is a bit of a silly check for 2.4ghz channels -adrian */
if|if
condition|(
name|synth_freq
operator|>=
literal|3000
condition|)
return|return;
if|if
condition|(
name|synth_freq
operator|<
literal|2412
condition|)
name|new_bias
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|synth_freq
operator|<
literal|2422
condition|)
name|new_bias
operator|=
literal|1
expr_stmt|;
else|else
name|new_bias
operator|=
literal|2
expr_stmt|;
comment|/* pre-reverse this field */
name|tmp_reg
operator|=
name|ath_hal_reverseBits
argument_list|(
name|new_bias
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: Force rf_pwd_icsyndiv to %1d on %4d\n"
argument_list|,
name|__func__
argument_list|,
name|new_bias
argument_list|,
name|synth_freq
argument_list|)
expr_stmt|;
comment|/* swizzle rf_pwd_icsyndiv */
name|ar5416ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|tmp_reg
argument_list|,
literal|3
argument_list|,
literal|181
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* write Bank 6 with new params */
name|ath_hal_ini_bank_write
argument_list|(
name|ah
argument_list|,
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank6
argument_list|,
name|priv
operator|->
name|Bank6Data
argument_list|,
name|reg_writes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take the MHz channel value and set the Channel value  *  * ASSUMES: Writes enabled to analog bus  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar2133SetChannel
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|uint32_t
name|channelSel
init|=
literal|0
decl_stmt|;
name|uint32_t
name|bModeSynth
init|=
literal|0
decl_stmt|;
name|uint32_t
name|aModeRefSel
init|=
literal|0
decl_stmt|;
name|uint32_t
name|reg32
init|=
literal|0
decl_stmt|;
name|uint16_t
name|freq
decl_stmt|;
name|CHAN_CENTERS
name|centers
decl_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_SETCHANNEL
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|ar5416GetChannelCenters
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|&
name|centers
argument_list|)
expr_stmt|;
name|freq
operator|=
name|centers
operator|.
name|synth_center
expr_stmt|;
if|if
condition|(
name|freq
operator|<
literal|4800
condition|)
block|{
name|uint32_t
name|txctl
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|freq
operator|-
literal|2192
operator|)
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
block|{
name|channelSel
operator|=
operator|(
operator|(
name|freq
operator|-
literal|672
operator|)
operator|*
literal|2
operator|-
literal|3040
operator|)
operator|/
literal|10
expr_stmt|;
name|bModeSynth
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|freq
operator|-
literal|2224
operator|)
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
block|{
name|channelSel
operator|=
operator|(
operator|(
name|freq
operator|-
literal|704
operator|)
operator|*
literal|2
operator|-
literal|3040
operator|)
operator|/
literal|10
expr_stmt|;
name|bModeSynth
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel %u MHz\n"
argument_list|,
name|__func__
argument_list|,
name|freq
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|channelSel
operator|=
operator|(
name|channelSel
operator|<<
literal|2
operator|)
operator|&
literal|0xff
expr_stmt|;
name|channelSel
operator|=
name|ath_hal_reverseBits
argument_list|(
name|channelSel
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|txctl
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_TX_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq
operator|==
literal|2484
condition|)
block|{
comment|/* Enable channel spreading for channel 14 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_TX_CTRL
argument_list|,
name|txctl
operator||
name|AR_PHY_CCK_TX_CTRL_JAPAN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_TX_CTRL
argument_list|,
name|txctl
operator|&
operator|~
name|AR_PHY_CCK_TX_CTRL_JAPAN
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|freq
operator|%
literal|20
operator|)
operator|==
literal|0
operator|&&
name|freq
operator|>=
literal|5120
condition|)
block|{
name|channelSel
operator|=
name|ath_hal_reverseBits
argument_list|(
operator|(
operator|(
name|freq
operator|-
literal|4800
operator|)
operator|/
literal|20
operator|<<
literal|2
operator|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_HOWL
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SOWL_10_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
name|aModeRefSel
operator|=
name|ath_hal_reverseBits
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
name|aModeRefSel
operator|=
name|ath_hal_reverseBits
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|freq
operator|%
literal|10
operator|)
operator|==
literal|0
condition|)
block|{
name|channelSel
operator|=
name|ath_hal_reverseBits
argument_list|(
operator|(
operator|(
name|freq
operator|-
literal|4800
operator|)
operator|/
literal|10
operator|<<
literal|1
operator|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_HOWL
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SOWL_10_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
name|aModeRefSel
operator|=
name|ath_hal_reverseBits
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
name|aModeRefSel
operator|=
name|ath_hal_reverseBits
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|freq
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
block|{
name|channelSel
operator|=
name|ath_hal_reverseBits
argument_list|(
operator|(
name|freq
operator|-
literal|4800
operator|)
operator|/
literal|5
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|aModeRefSel
operator|=
name|ath_hal_reverseBits
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel %u MHz\n"
argument_list|,
name|__func__
argument_list|,
name|freq
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* Workaround for hw bug - AR5416 specific */
if|if
condition|(
name|AR_SREV_OWL
argument_list|(
name|ah
argument_list|)
operator|&&
name|ah
operator|->
name|ah_config
operator|.
name|ah_ar5416_biasadj
condition|)
name|ar2133ForceBias
argument_list|(
name|ah
argument_list|,
name|freq
argument_list|)
expr_stmt|;
name|reg32
operator|=
operator|(
name|channelSel
operator|<<
literal|8
operator|)
operator||
operator|(
name|aModeRefSel
operator|<<
literal|2
operator|)
operator||
operator|(
name|bModeSynth
operator|<<
literal|1
operator|)
operator||
operator|(
literal|1
operator|<<
literal|5
operator|)
operator||
literal|0x1
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0x37
argument_list|)
argument_list|,
name|reg32
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|=
name|chan
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Return a reference to the requested RF Bank.  */
end_comment

begin_function
specifier|static
name|uint32_t
modifier|*
name|ar2133GetRfBank
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|bank
parameter_list|)
block|{
name|struct
name|ar2133State
modifier|*
name|priv
init|=
name|AR2133
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HALASSERT
argument_list|(
name|priv
operator|!=
name|AH_NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bank
condition|)
block|{
case|case
literal|1
case|:
return|return
name|priv
operator|->
name|Bank1Data
return|;
case|case
literal|2
case|:
return|return
name|priv
operator|->
name|Bank2Data
return|;
case|case
literal|3
case|:
return|return
name|priv
operator|->
name|Bank3Data
return|;
case|case
literal|6
case|:
return|return
name|priv
operator|->
name|Bank6Data
return|;
case|case
literal|7
case|:
return|return
name|priv
operator|->
name|Bank7Data
return|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: unknown RF Bank %d requested\n"
argument_list|,
name|__func__
argument_list|,
name|bank
argument_list|)
expr_stmt|;
return|return
name|AH_NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Reads EEPROM header info from device structure and programs  * all rf registers  *  * REQUIRES: Access to the analog rf device  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar2133SetRfRegs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|uint16_t
name|modesIndex
parameter_list|,
name|uint16_t
modifier|*
name|rfXpdGain
parameter_list|)
block|{
name|struct
name|ar2133State
modifier|*
name|priv
init|=
name|AR2133
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|writes
decl_stmt|;
name|HALASSERT
argument_list|(
name|priv
argument_list|)
expr_stmt|;
comment|/* Setup Bank 0 Write */
name|ath_hal_ini_bank_setup
argument_list|(
name|priv
operator|->
name|Bank0Data
argument_list|,
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Setup Bank 1 Write */
name|ath_hal_ini_bank_setup
argument_list|(
name|priv
operator|->
name|Bank1Data
argument_list|,
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Setup Bank 2 Write */
name|ath_hal_ini_bank_setup
argument_list|(
name|priv
operator|->
name|Bank2Data
argument_list|,
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Setup Bank 3 Write */
name|ath_hal_ini_bank_setup
argument_list|(
name|priv
operator|->
name|Bank3Data
argument_list|,
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank3
argument_list|,
name|modesIndex
argument_list|)
expr_stmt|;
comment|/* Setup Bank 6 Write */
name|ath_hal_ini_bank_setup
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank6
argument_list|,
name|modesIndex
argument_list|)
expr_stmt|;
comment|/* Only the 5 or 2 GHz OB/DB need to be set for a mode */
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: 2ghz: OB_2:%d, DB_2:%d\n"
argument_list|,
name|__func__
argument_list|,
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_OB_2
argument_list|,
name|AH_NULL
argument_list|)
argument_list|,
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_DB_2
argument_list|,
name|AH_NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ar5416ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_OB_2
argument_list|,
name|AH_NULL
argument_list|)
argument_list|,
literal|3
argument_list|,
literal|197
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar5416ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_DB_2
argument_list|,
name|AH_NULL
argument_list|)
argument_list|,
literal|3
argument_list|,
literal|194
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: 5ghz: OB_5:%d, DB_5:%d\n"
argument_list|,
name|__func__
argument_list|,
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_OB_5
argument_list|,
name|AH_NULL
argument_list|)
argument_list|,
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_DB_5
argument_list|,
name|AH_NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ar5416ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_OB_5
argument_list|,
name|AH_NULL
argument_list|)
argument_list|,
literal|3
argument_list|,
literal|203
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar5416ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_DB_5
argument_list|,
name|AH_NULL
argument_list|)
argument_list|,
literal|3
argument_list|,
literal|200
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Setup Bank 7 Setup */
name|ath_hal_ini_bank_setup
argument_list|(
name|priv
operator|->
name|Bank7Data
argument_list|,
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank7
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Write Analog registers */
name|writes
operator|=
name|ath_hal_ini_bank_write
argument_list|(
name|ah
argument_list|,
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank0
argument_list|,
name|priv
operator|->
name|Bank0Data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writes
operator|=
name|ath_hal_ini_bank_write
argument_list|(
name|ah
argument_list|,
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank1
argument_list|,
name|priv
operator|->
name|Bank1Data
argument_list|,
name|writes
argument_list|)
expr_stmt|;
name|writes
operator|=
name|ath_hal_ini_bank_write
argument_list|(
name|ah
argument_list|,
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank2
argument_list|,
name|priv
operator|->
name|Bank2Data
argument_list|,
name|writes
argument_list|)
expr_stmt|;
name|writes
operator|=
name|ath_hal_ini_bank_write
argument_list|(
name|ah
argument_list|,
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank3
argument_list|,
name|priv
operator|->
name|Bank3Data
argument_list|,
name|writes
argument_list|)
expr_stmt|;
name|writes
operator|=
name|ath_hal_ini_bank_write
argument_list|(
name|ah
argument_list|,
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank6
argument_list|,
name|priv
operator|->
name|Bank6Data
argument_list|,
name|writes
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_hal_ini_bank_write
argument_list|(
name|ah
argument_list|,
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank7
argument_list|,
name|priv
operator|->
name|Bank7Data
argument_list|,
name|writes
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|RF_BANK_SETUP
block|}
end_function

begin_comment
comment|/*  * Read the transmit power levels from the structures taken from EEPROM  * Interpolate read transmit power values for this channel  * Organize the transmit power values into a table for writing into the hardware  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar2133SetPowerTable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int16_t
modifier|*
name|pPowerMin
parameter_list|,
name|int16_t
modifier|*
name|pPowerMax
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|uint16_t
modifier|*
name|rfXpdGain
parameter_list|)
block|{
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static int16_t ar2133GetMinPower(struct ath_hal *ah, EXPN_DATA_PER_CHANNEL_5112 *data) {     int i, minIndex;     int16_t minGain,minPwr,minPcdac,retVal;
comment|/* Assume NUM_POINTS_XPD0> 0 */
end_comment

begin_endif
unit|minGain = data->pDataPerXPD[0].xpd_gain;     for (minIndex=0,i=1; i<NUM_XPD_PER_CHANNEL; i++) {         if (data->pDataPerXPD[i].xpd_gain< minGain) {             minIndex = i;             minGain = data->pDataPerXPD[i].xpd_gain;         }     }     minPwr = data->pDataPerXPD[minIndex].pwr_t4[0];     minPcdac = data->pDataPerXPD[minIndex].pcdac[0];     for (i=1; i<NUM_POINTS_XPD0; i++) {         if (data->pDataPerXPD[minIndex].pwr_t4[i]< minPwr) {             minPwr = data->pDataPerXPD[minIndex].pwr_t4[i];             minPcdac = data->pDataPerXPD[minIndex].pcdac[i];         }     }     retVal = minPwr - (minPcdac*2);     return(retVal); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|HAL_BOOL
name|ar2133GetChannelMaxMinPower
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|int16_t
modifier|*
name|maxPow
parameter_list|,
name|int16_t
modifier|*
name|minPow
parameter_list|)
block|{
if|#
directive|if
literal|0
block|struct ath_hal_5212 *ahp = AH5212(ah);     int numChannels=0,i,last;     int totalD, totalF,totalMin;     EXPN_DATA_PER_CHANNEL_5112 *data=AH_NULL;     EEPROM_POWER_EXPN_5112 *powerArray=AH_NULL;      *maxPow = 0;     if (IS_CHAN_A(chan)) {         powerArray = ahp->ah_modePowerArray5112;         data = powerArray[headerInfo11A].pDataPerChannel;         numChannels = powerArray[headerInfo11A].numChannels;     } else if (IS_CHAN_G(chan) || IS_CHAN_108G(chan)) {
comment|/* XXX - is this correct? Should we also use the same power for turbo G? */
block|powerArray = ahp->ah_modePowerArray5112;         data = powerArray[headerInfo11G].pDataPerChannel;         numChannels = powerArray[headerInfo11G].numChannels;     } else if (IS_CHAN_B(chan)) {         powerArray = ahp->ah_modePowerArray5112;         data = powerArray[headerInfo11B].pDataPerChannel;         numChannels = powerArray[headerInfo11B].numChannels;     } else {         return (AH_TRUE);     }
comment|/* Make sure the channel is in the range of the TP values      *  (freq piers)      */
block|if ((numChannels< 1) ||         (chan->channel< data[0].channelValue) ||         (chan->channel> data[numChannels-1].channelValue))         return(AH_FALSE);
comment|/* Linearly interpolate the power value now */
block|for (last=0,i=0;          (i<numChannels)&& (chan->channel> data[i].channelValue);          last=i++);     totalD = data[i].channelValue - data[last].channelValue;     if (totalD> 0) {         totalF = data[i].maxPower_t4 - data[last].maxPower_t4;         *maxPow = (int8_t) ((totalF*(chan->channel-data[last].channelValue) + data[last].maxPower_t4*totalD)/totalD);          totalMin = ar2133GetMinPower(ah,&data[i]) - ar2133GetMinPower(ah,&data[last]);         *minPow = (int8_t) ((totalMin*(chan->channel-data[last].channelValue) + ar2133GetMinPower(ah,&data[last])*totalD)/totalD);         return (AH_TRUE);     } else {         if (chan->channel == data[i].channelValue) {             *maxPow = data[i].maxPower_t4;             *minPow = ar2133GetMinPower(ah,&data[i]);             return(AH_TRUE);         } else             return(AH_FALSE);     }
else|#
directive|else
operator|*
name|maxPow
operator|=
operator|*
name|minPow
operator|=
literal|0
expr_stmt|;
return|return
name|AH_FALSE
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * The ordering of nfarray is thus:  *  * nfarray[0]:	Chain 0 ctl  * nfarray[1]:	Chain 1 ctl  * nfarray[2]:	Chain 2 ctl  * nfarray[3]:	Chain 0 ext  * nfarray[4]:	Chain 1 ext  * nfarray[5]:	Chain 2 ext  */
end_comment

begin_function
specifier|static
name|void
name|ar2133GetNoiseFloor
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int16_t
name|nfarray
index|[]
parameter_list|)
block|{
name|struct
name|ath_hal_5416
modifier|*
name|ahp
init|=
name|AH5416
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int16_t
name|nf
decl_stmt|;
comment|/* 	 * Blank nf array - some chips may only 	 * have one or two RX chainmasks enabled. 	 */
name|nfarray
index|[
literal|0
index|]
operator|=
name|nfarray
index|[
literal|1
index|]
operator|=
name|nfarray
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|nfarray
index|[
literal|3
index|]
operator|=
name|nfarray
index|[
literal|4
index|]
operator|=
name|nfarray
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ahp
operator|->
name|ah_rx_chainmask
condition|)
block|{
case|case
literal|0x7
case|:
name|nf
operator|=
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CH2_CCA
argument_list|)
argument_list|,
name|AR_PHY_CH2_MINCCA_PWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
operator|&
literal|0x100
condition|)
name|nf
operator|=
literal|0
operator|-
operator|(
operator|(
name|nf
operator|^
literal|0x1ff
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"NF calibrated [ctl] [chain 2] is %d\n"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|nfarray
index|[
literal|2
index|]
operator|=
name|nf
expr_stmt|;
name|nf
operator|=
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CH2_EXT_CCA
argument_list|)
argument_list|,
name|AR_PHY_CH2_EXT_MINCCA_PWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
operator|&
literal|0x100
condition|)
name|nf
operator|=
literal|0
operator|-
operator|(
operator|(
name|nf
operator|^
literal|0x1ff
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"NF calibrated [ext] [chain 2] is %d\n"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|nfarray
index|[
literal|5
index|]
operator|=
name|nf
expr_stmt|;
comment|/* fall thru... */
case|case
literal|0x3
case|:
case|case
literal|0x5
case|:
name|nf
operator|=
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CH1_CCA
argument_list|)
argument_list|,
name|AR_PHY_CH1_MINCCA_PWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
operator|&
literal|0x100
condition|)
name|nf
operator|=
literal|0
operator|-
operator|(
operator|(
name|nf
operator|^
literal|0x1ff
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"NF calibrated [ctl] [chain 1] is %d\n"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|nfarray
index|[
literal|1
index|]
operator|=
name|nf
expr_stmt|;
name|nf
operator|=
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CH1_EXT_CCA
argument_list|)
argument_list|,
name|AR_PHY_CH1_EXT_MINCCA_PWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
operator|&
literal|0x100
condition|)
name|nf
operator|=
literal|0
operator|-
operator|(
operator|(
name|nf
operator|^
literal|0x1ff
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"NF calibrated [ext] [chain 1] is %d\n"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|nfarray
index|[
literal|4
index|]
operator|=
name|nf
expr_stmt|;
comment|/* fall thru... */
case|case
literal|0x1
case|:
name|nf
operator|=
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCA
argument_list|)
argument_list|,
name|AR_PHY_MINCCA_PWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
operator|&
literal|0x100
condition|)
name|nf
operator|=
literal|0
operator|-
operator|(
operator|(
name|nf
operator|^
literal|0x1ff
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"NF calibrated [ctl] [chain 0] is %d\n"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|nfarray
index|[
literal|0
index|]
operator|=
name|nf
expr_stmt|;
name|nf
operator|=
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_EXT_CCA
argument_list|)
argument_list|,
name|AR_PHY_EXT_MINCCA_PWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
operator|&
literal|0x100
condition|)
name|nf
operator|=
literal|0
operator|-
operator|(
operator|(
name|nf
operator|^
literal|0x1ff
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"NF calibrated [ext] [chain 0] is %d\n"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|nfarray
index|[
literal|3
index|]
operator|=
name|nf
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Adjust NF based on statistical values for 5GHz frequencies.  * Stubbed:Not used by Fowl  */
end_comment

begin_function
specifier|static
name|int16_t
name|ar2133GetNfAdjust
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_CHANNEL_INTERNAL
modifier|*
name|c
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Free memory for analog bank scratch buffers  */
end_comment

begin_function
specifier|static
name|void
name|ar2133RfDetach
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HALASSERT
argument_list|(
name|ahp
operator|->
name|ah_rfHal
operator|!=
name|AH_NULL
argument_list|)
expr_stmt|;
name|ath_hal_free
argument_list|(
name|ahp
operator|->
name|ah_rfHal
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_rfHal
operator|=
name|AH_NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate memory for analog bank scratch buffers  * Scratch Buffer will be reinitialized every reset so no need to zero now  */
end_comment

begin_function
name|HAL_BOOL
name|ar2133RfAttach
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar2133State
modifier|*
name|priv
decl_stmt|;
name|uint32_t
modifier|*
name|bankData
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ATTACH
argument_list|,
literal|"%s: attach AR2133 radio\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|ahp
operator|->
name|ah_rfHal
operator|==
name|AH_NULL
argument_list|)
expr_stmt|;
name|priv
operator|=
name|ath_hal_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ar2133State
argument_list|)
operator|+
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank0
operator|.
name|rows
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank1
operator|.
name|rows
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank2
operator|.
name|rows
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank3
operator|.
name|rows
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank6
operator|.
name|rows
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank7
operator|.
name|rows
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: cannot allocate private state\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|HAL_ENOMEM
expr_stmt|;
comment|/* XXX */
return|return
name|AH_FALSE
return|;
block|}
name|priv
operator|->
name|base
operator|.
name|rfDetach
operator|=
name|ar2133RfDetach
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|writeRegs
operator|=
name|ar2133WriteRegs
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|getRfBank
operator|=
name|ar2133GetRfBank
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|setChannel
operator|=
name|ar2133SetChannel
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|setRfRegs
operator|=
name|ar2133SetRfRegs
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|setPowerTable
operator|=
name|ar2133SetPowerTable
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|getChannelMaxMinPower
operator|=
name|ar2133GetChannelMaxMinPower
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|getNfAdjust
operator|=
name|ar2133GetNfAdjust
expr_stmt|;
name|bankData
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|priv
index|[
literal|1
index|]
expr_stmt|;
name|priv
operator|->
name|Bank0Data
operator|=
name|bankData
operator|,
name|bankData
operator|+=
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank0
operator|.
name|rows
expr_stmt|;
name|priv
operator|->
name|Bank1Data
operator|=
name|bankData
operator|,
name|bankData
operator|+=
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank1
operator|.
name|rows
expr_stmt|;
name|priv
operator|->
name|Bank2Data
operator|=
name|bankData
operator|,
name|bankData
operator|+=
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank2
operator|.
name|rows
expr_stmt|;
name|priv
operator|->
name|Bank3Data
operator|=
name|bankData
operator|,
name|bankData
operator|+=
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank3
operator|.
name|rows
expr_stmt|;
name|priv
operator|->
name|Bank6Data
operator|=
name|bankData
operator|,
name|bankData
operator|+=
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank6
operator|.
name|rows
expr_stmt|;
name|priv
operator|->
name|Bank7Data
operator|=
name|bankData
operator|,
name|bankData
operator|+=
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bank7
operator|.
name|rows
expr_stmt|;
name|ahp
operator|->
name|ah_pcdacTable
operator|=
name|priv
operator|->
name|pcdacTable
expr_stmt|;
name|ahp
operator|->
name|ah_pcdacTableSize
operator|=
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|pcdacTable
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_rfHal
operator|=
operator|&
name|priv
operator|->
name|base
expr_stmt|;
comment|/* 	 * Set noise floor adjust method; we arrange a 	 * direct call instead of thunking. 	 */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_getNfAdjust
operator|=
name|priv
operator|->
name|base
operator|.
name|getNfAdjust
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_getNoiseFloor
operator|=
name|ar2133GetNoiseFloor
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|ar2133Probe
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
operator|(
name|AR_SREV_OWL
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_HOWL
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SOWL
argument_list|(
name|ah
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|AH_RF
argument_list|(
name|RF2133
argument_list|,
name|ar2133Probe
argument_list|,
name|ar2133RfAttach
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

