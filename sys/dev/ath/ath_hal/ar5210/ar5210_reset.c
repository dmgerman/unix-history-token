begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2002-2004 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ar5210/ar5210.h"
end_include

begin_include
include|#
directive|include
file|"ar5210/ar5210reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5210/ar5210phy.h"
end_include

begin_include
include|#
directive|include
file|"ah_eeprom_v1.h"
end_include

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint32_t
name|Offset
decl_stmt|;
name|uint32_t
name|Value
decl_stmt|;
block|}
name|REGISTER_VAL
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|REGISTER_VAL
name|ar5k0007_init
index|[]
init|=
block|{
include|#
directive|include
file|"ar5210/ar5k_0007.ini"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default Power Settings for channels outside of EEPROM range */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|ar5k0007_pwrSettings
index|[
literal|17
index|]
init|=
block|{
comment|/*	gain delta			pc dac */
comment|/* 54  48  36  24  18  12   9   54  48  36  24  18  12   9   6  ob  db	  */
literal|9
block|,
literal|9
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|2
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The delay, in usecs, between writing AR_RC with a reset  * request and waiting for the chip to settle.  If this is  * too short then the chip does not come out of sleep state.  * Note this value was empirically derived and may be dependent  * on the host machine (don't know--the problem was identified  * on an IBM 570e laptop; 10us delays worked on other systems).  */
end_comment

begin_define
define|#
directive|define
name|AR_RC_SETTLE_TIME
value|20000
end_define

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5210SetResetReg
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|uint32_t
name|resetMask
parameter_list|,
name|u_int
name|delay
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5210SetChannel
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5210SetOperatingMode
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|int
name|opmode
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Places the device in and out of reset and then places sane  * values in the registers based on EEPROM config, initialization  * vectors (as determined by the mode), and station configuration  *  * bChannelChange is used to preserve DMA/PCU registers across  * a HW Reset during channel change.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5210Reset
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_OPMODE
name|opmode
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|HAL_BOOL
name|bChannelChange
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) /sizeof (a[0]))
define|#
directive|define
name|FAIL
parameter_list|(
name|_code
parameter_list|)
value|do { ecode = _code; goto bad; } while (0)
name|struct
name|ath_hal_5210
modifier|*
name|ahp
init|=
name|AH5210
argument_list|(
name|ah
argument_list|)
decl_stmt|;
specifier|const
name|HAL_EEPROM_v1
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
decl_stmt|;
name|HAL_STATUS
name|ecode
decl_stmt|;
name|uint32_t
name|ledstate
decl_stmt|;
name|int
name|i
decl_stmt|,
name|q
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s: opmode %u channel %u/0x%x %s channel\n"
argument_list|,
name|__func__
argument_list|,
name|opmode
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|,
name|bChannelChange
condition|?
literal|"change"
else|:
literal|"same"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* Only 11a mode */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: channel not 5GHz\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EINVAL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Map public channel to private. 	 */
name|ichan
operator|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ichan
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel %u/0x%x; no mapping\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EINVAL
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|opmode
condition|)
block|{
case|case
name|HAL_M_STA
case|:
case|case
name|HAL_M_IBSS
case|:
case|case
name|HAL_M_HOSTAP
case|:
case|case
name|HAL_M_MONITOR
case|:
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid operating mode %u\n"
argument_list|,
name|__func__
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EINVAL
argument_list|)
expr_stmt|;
break|break;
block|}
name|ledstate
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|)
operator|&
operator|(
name|AR_PCICFG_LED_PEND
operator||
name|AR_PCICFG_LED_ACT
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar5210ChipReset
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: chip reset failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID0
argument_list|,
name|LE_READ_4
argument_list|(
name|ahp
operator|->
name|ah_macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|LE_READ_2
argument_list|(
name|ahp
operator|->
name|ah_macaddr
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|ar5210SetOperatingMode
argument_list|(
name|ah
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opmode
condition|)
block|{
case|case
name|HAL_M_HOSTAP
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BCR
argument_list|,
name|INIT_BCON_CNTRL_REG
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|,
name|AR_PCICFG_LED_ACT
operator||
name|AR_PCICFG_LED_BCTL
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_M_IBSS
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BCR
argument_list|,
name|INIT_BCON_CNTRL_REG
operator||
name|AR_BCR_BCMD
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|,
name|AR_PCICFG_CLKRUNEN
operator||
name|AR_PCICFG_LED_PEND
operator||
name|AR_PCICFG_LED_BCTL
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_M_STA
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BCR
argument_list|,
name|INIT_BCON_CNTRL_REG
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|,
name|AR_PCICFG_CLKRUNEN
operator||
name|AR_PCICFG_LED_PEND
operator||
name|AR_PCICFG_LED_BCTL
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_M_MONITOR
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BCR
argument_list|,
name|INIT_BCON_CNTRL_REG
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|,
name|AR_PCICFG_LED_ACT
operator||
name|AR_PCICFG_LED_BCTL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Restore previous led state */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|)
operator||
name|ledstate
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSS_ID0
argument_list|,
name|LE_READ_4
argument_list|(
name|ahp
operator|->
name|ah_bssid
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSS_ID1
argument_list|,
name|LE_READ_2
argument_list|(
name|ahp
operator|->
name|ah_bssid
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TXDP0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TXDP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RXDP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize interrupt state. 	 */
operator|(
name|void
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR
argument_list|)
expr_stmt|;
comment|/* cleared on read */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IER
argument_list|,
name|AR_IER_DISABLE
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_maskReg
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_BSR
argument_list|)
expr_stmt|;
comment|/* cleared on read */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TXCFG
argument_list|,
name|AR_DMASIZE_128B
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RXCFG
argument_list|,
name|AR_DMASIZE_128B
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TOPS
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* timeout prescale */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RXNOFRM
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* RX no frame timeout */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RPGTO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* RX frame gap timeout */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TXNOFRM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* TX no frame timeout */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_SFR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MIBC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unfreeze ctrs + clr state */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RSSI_THR
argument_list|,
name|ahp
operator|->
name|ah_rssiThr
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CFP_DUR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar5210SetRxFilter
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* nothing for now */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MCAST_FIL0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* multicast filter */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MCAST_FIL1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX was 2 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TX_MASK0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TX_MASK1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CLR_TMASK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TRIG_LEV
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* minimum */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CFP_PERIOD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TIMER0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* next beacon time */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* local clock */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TIMER1
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
comment|/* next DMA beacon alert */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TIMER2
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
comment|/* next SW beacon alert */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TIMER3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* next ATIM window */
comment|/* Write the INI values for PHYreg initialization */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|ar5k0007_init
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|reg
init|=
name|ar5k0007_init
index|[
name|i
index|]
operator|.
name|Offset
decl_stmt|;
comment|/* On channel change, don't reset the PCU registers */
if|if
condition|(
operator|!
operator|(
name|bChannelChange
operator|&&
operator|(
literal|0x8000
operator|<=
name|reg
operator|&&
name|reg
operator|<
literal|0x9000
operator|)
operator|)
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|reg
argument_list|,
name|ar5k0007_init
index|[
name|i
index|]
operator|.
name|Value
argument_list|)
expr_stmt|;
block|}
comment|/* Setup the transmit power values for cards since 0x0[0-2]05 */
if|if
condition|(
operator|!
name|ar5210SetTransmitPower
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: error init'ing transmit power\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|10
argument_list|)
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|10
argument_list|)
argument_list|)
operator|&
literal|0xFFFF00FF
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_xlnaOn
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|13
argument_list|)
argument_list|,
operator|(
name|ee
operator|->
name|ee_xpaOff
operator|<<
literal|24
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_xpaOff
operator|<<
literal|16
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_xpaOn
operator|<<
literal|8
operator|)
operator||
name|ee
operator|->
name|ee_xpaOn
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|17
argument_list|)
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|17
argument_list|)
argument_list|)
operator|&
literal|0xFFFFC07F
operator|)
operator||
operator|(
operator|(
name|ee
operator|->
name|ee_antenna
operator|>>
literal|1
operator|)
operator|&
literal|0x3F80
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|18
argument_list|)
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|18
argument_list|)
argument_list|)
operator|&
literal|0xFFFC0FFF
operator|)
operator||
operator|(
operator|(
name|ee
operator|->
name|ee_antenna
operator|<<
literal|10
operator|)
operator|&
literal|0x3F000
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|25
argument_list|)
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|25
argument_list|)
argument_list|)
operator|&
literal|0xFFF80FFF
operator|)
operator||
operator|(
operator|(
name|ee
operator|->
name|ee_thresh62
operator|<<
literal|12
operator|)
operator|&
literal|0x7F000
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|68
argument_list|)
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|68
argument_list|)
argument_list|)
operator|&
literal|0xFFFFFFFC
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_antenna
operator|&
literal|0x3
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar5210SetChannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: unable to set channel\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bChannelChange
operator|&&
operator|!
name|IEEE80211_IS_CHAN_DFS
argument_list|(
name|chan
argument_list|)
condition|)
name|chan
operator|->
name|ic_state
operator|&=
operator|~
name|IEEE80211_CHANSTATE_CWINT
expr_stmt|;
comment|/* Activate the PHY */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ACTIVE
argument_list|,
name|AR_PHY_ENABLE
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Wait a bit (1 msec) */
comment|/* calibrate the HW and poll the bit going to 0 for completion */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGCCTL
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGCCTL
argument_list|)
operator||
name|AR_PHY_AGC_CAL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGCCTL
argument_list|,
name|AR_PHY_AGC_CAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Perform noise floor calibration and set status */
if|if
condition|(
operator|!
name|ar5210CalNoiseFloor
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
condition|)
block|{
name|chan
operator|->
name|ic_state
operator||=
name|IEEE80211_CHANSTATE_CWINT
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: noise floor calibration failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|q
operator|++
control|)
name|ar5210ResetTxQueue
argument_list|(
name|ah
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rfkillEnabled
condition|)
name|ar5210EnableRfKill
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 	 * Writing to AR_BEACON will start timers. Hence it should be 	 * the last register to be written. Do not reset tsf, do not 	 * enable beacons at this point, but preserve other values 	 * like beaconInterval. 	 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BEACON
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_BEACON
argument_list|)
operator|&
operator|~
operator|(
name|AR_BEACON_EN
operator||
name|AR_BEACON_RESET_TSF
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Restore user-specified slot time and timeouts */
if|if
condition|(
name|ahp
operator|->
name|ah_sifstime
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ar5210SetSifsTime
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_sifstime
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_slottime
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ar5210SetSlotTime
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_slottime
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_acktimeout
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ar5210SetAckTimeout
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_acktimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_ctstimeout
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ar5210SetCTSTimeout
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_ctstimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diagreg
operator|!=
literal|0
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diagreg
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
operator|=
name|opmode
expr_stmt|;
comment|/* record operating mode */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s: done\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
name|bad
label|:
if|if
condition|(
name|status
operator|!=
name|AH_NULL
condition|)
operator|*
name|status
operator|=
name|ecode
expr_stmt|;
return|return
name|AH_FALSE
return|;
undef|#
directive|undef
name|FAIL
undef|#
directive|undef
name|N
block|}
end_function

begin_function
specifier|static
name|void
name|ar5210SetOperatingMode
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|opmode
parameter_list|)
block|{
name|struct
name|ath_hal_5210
modifier|*
name|ahp
init|=
name|AH5210
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
switch|switch
condition|(
name|opmode
condition|)
block|{
case|case
name|HAL_M_HOSTAP
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|val
operator||
name|AR_STA_ID1_AP
operator||
name|AR_STA_ID1_NO_PSPOLL
operator||
name|AR_STA_ID1_DESC_ANTENNA
operator||
name|ahp
operator|->
name|ah_staId1Defaults
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_M_IBSS
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|val
operator||
name|AR_STA_ID1_ADHOC
operator||
name|AR_STA_ID1_NO_PSPOLL
operator||
name|AR_STA_ID1_DESC_ANTENNA
operator||
name|ahp
operator|->
name|ah_staId1Defaults
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_M_STA
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|val
operator||
name|AR_STA_ID1_NO_PSPOLL
operator||
name|AR_STA_ID1_PWR_SV
operator||
name|ahp
operator|->
name|ah_staId1Defaults
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_M_MONITOR
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|val
operator||
name|AR_STA_ID1_NO_PSPOLL
operator||
name|ahp
operator|->
name|ah_staId1Defaults
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|ar5210SetPCUConfig
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|ar5210SetOperatingMode
argument_list|(
name|ah
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Places the PHY and Radio chips into reset.  A full reset  * must be called to leave this state.  The PCI/MAC/PCU are  * not placed into reset as we must receive interrupt to  * re-enable the hardware.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5210PhyDisable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|ar5210SetResetReg
argument_list|(
name|ah
argument_list|,
name|AR_RC_RPHY
argument_list|,
literal|10
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Places all of hardware into reset  */
end_comment

begin_function
name|HAL_BOOL
name|ar5210Disable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
define|#
directive|define
name|AR_RC_HW
value|(AR_RC_RPCU | AR_RC_RDMA | AR_RC_RPHY | AR_RC_RMAC)
if|if
condition|(
operator|!
name|ar5210SetPowerMode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
comment|/* 	 * Reset the HW - PCI must be reset after the rest of the 	 * device has been reset 	 */
if|if
condition|(
operator|!
name|ar5210SetResetReg
argument_list|(
name|ah
argument_list|,
name|AR_RC_HW
argument_list|,
name|AR_RC_SETTLE_TIME
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
name|OS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ar5210SetResetReg
argument_list|(
name|ah
argument_list|,
name|AR_RC_HW
operator||
name|AR_RC_RPCI
argument_list|,
name|AR_RC_SETTLE_TIME
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|2100
argument_list|)
expr_stmt|;
comment|/* 8245 @ 96Mhz hangs with 2000us. */
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|AR_RC_HW
block|}
end_function

begin_comment
comment|/*  * Places the hardware into reset and then pulls it out of reset  */
end_comment

begin_function
name|HAL_BOOL
name|ar5210ChipReset
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
define|#
directive|define
name|AR_RC_HW
value|(AR_RC_RPCU | AR_RC_RDMA | AR_RC_RPHY | AR_RC_RMAC)
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s turbo %s\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|&&
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar5210SetPowerMode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
comment|/* Place chip in turbo before reset to cleanly reset clocks */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_FRCTL
argument_list|,
name|chan
operator|&&
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
condition|?
name|AR_PHY_TURBO_MODE
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the HW. 	 * PCI must be reset after the rest of the device has been reset. 	 */
if|if
condition|(
operator|!
name|ar5210SetResetReg
argument_list|(
name|ah
argument_list|,
name|AR_RC_HW
argument_list|,
name|AR_RC_SETTLE_TIME
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
name|OS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar5210SetResetReg
argument_list|(
name|ah
argument_list|,
name|AR_RC_HW
operator||
name|AR_RC_RPCI
argument_list|,
name|AR_RC_SETTLE_TIME
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
name|OS_DELAY
argument_list|(
literal|2100
argument_list|)
expr_stmt|;
comment|/* 8245 @ 96Mhz hangs with 2000us. */
comment|/* 	 * Bring out of sleep mode (AGAIN) 	 * 	 * WARNING WARNING WARNING 	 * 	 * There is a problem with the chip where it doesn't always indicate 	 * that it's awake, so initializePowerUp() will fail. 	 */
if|if
condition|(
operator|!
name|ar5210SetPowerMode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
comment|/* Clear warm reset reg */
return|return
name|ar5210SetResetReg
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
return|;
undef|#
directive|undef
name|AR_RC_HW
block|}
end_function

begin_enum
enum|enum
block|{
name|FIRPWR_M
init|=
literal|0x03fc0000
block|,
name|FIRPWR_S
init|=
literal|18
block|,
name|KCOARSEHIGH_M
init|=
literal|0x003f8000
block|,
name|KCOARSEHIGH_S
init|=
literal|15
block|,
name|KCOARSELOW_M
init|=
literal|0x00007f80
block|,
name|KCOARSELOW_S
init|=
literal|7
block|,
name|ADCSAT_ICOUNT_M
init|=
literal|0x0001f800
block|,
name|ADCSAT_ICOUNT_S
init|=
literal|11
block|,
name|ADCSAT_THRESH_M
init|=
literal|0x000007e0
block|,
name|ADCSAT_THRESH_S
init|=
literal|5
block|}
enum|;
end_enum

begin_comment
comment|/*  * Recalibrate the lower PHY chips to account for temperature/environment  * changes.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5210PerCalibrationN
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|u_int
name|chainMask
parameter_list|,
name|HAL_BOOL
name|longCal
parameter_list|,
name|HAL_BOOL
modifier|*
name|isCalDone
parameter_list|)
block|{
name|uint32_t
name|regBeacon
decl_stmt|;
name|uint32_t
name|reg9858
decl_stmt|,
name|reg985c
decl_stmt|,
name|reg9868
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
decl_stmt|;
name|ichan
operator|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ichan
operator|==
name|AH_NULL
condition|)
return|return
name|AH_FALSE
return|;
comment|/* Disable tx and rx */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|)
operator||
operator|(
name|AR_DIAG_SW_DIS_TX
operator||
name|AR_DIAG_SW_DIS_RX
operator|)
argument_list|)
expr_stmt|;
comment|/* Disable Beacon Enable */
name|regBeacon
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_BEACON
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BEACON
argument_list|,
name|regBeacon
operator|&
operator|~
name|AR_BEACON_EN
argument_list|)
expr_stmt|;
comment|/* Delay 4ms to ensure that all tx and rx activity has ceased */
name|OS_DELAY
argument_list|(
literal|4000
argument_list|)
expr_stmt|;
comment|/* Disable AGC to radio traffic */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0x9808
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
literal|0x9808
argument_list|)
operator||
literal|0x08000000
argument_list|)
expr_stmt|;
comment|/* Wait for the AGC traffic to cease. */
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Change Channel to relock synth */
if|if
condition|(
operator|!
name|ar5210SetChannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
comment|/* wait for the synthesizer lock to stabilize */
name|OS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Re-enable AGC to radio traffic */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0x9808
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
literal|0x9808
argument_list|)
operator|&
operator|(
operator|~
literal|0x08000000
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Configure the AGC so that it is highly unlikely (if not 	 * impossible) for it to send any gain changes to the analog 	 * chip.  We store off the current values so that they can 	 * be rewritten below. Setting the following values: 	 * firpwr	 = -1 	 * Kcoursehigh   = -1 	 * Kcourselow	 = -127 	 * ADCsat_icount = 2 	 * ADCsat_thresh = 12 	 */
name|reg9858
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
literal|0x9858
argument_list|)
expr_stmt|;
name|reg985c
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
literal|0x985c
argument_list|)
expr_stmt|;
name|reg9868
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
literal|0x9868
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0x9858
argument_list|,
operator|(
name|reg9858
operator|&
operator|~
name|FIRPWR_M
operator|)
operator||
operator|(
operator|(
operator|-
literal|1
operator|<<
name|FIRPWR_S
operator|)
operator|&
name|FIRPWR_M
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0x985c
argument_list|,
operator|(
name|reg985c
operator|&
operator|~
operator|(
name|KCOARSEHIGH_M
operator||
name|KCOARSELOW_M
operator|)
operator|)
operator||
operator|(
operator|(
operator|-
literal|1
operator|<<
name|KCOARSEHIGH_S
operator|)
operator|&
name|KCOARSEHIGH_M
operator|)
operator||
operator|(
operator|(
operator|-
literal|127
operator|<<
name|KCOARSELOW_S
operator|)
operator|&
name|KCOARSELOW_M
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0x9868
argument_list|,
operator|(
name|reg9868
operator|&
operator|~
operator|(
name|ADCSAT_ICOUNT_M
operator||
name|ADCSAT_THRESH_M
operator|)
operator|)
operator||
operator|(
operator|(
literal|2
operator|<<
name|ADCSAT_ICOUNT_S
operator|)
operator|&
name|ADCSAT_ICOUNT_M
operator|)
operator||
operator|(
operator|(
literal|12
operator|<<
name|ADCSAT_THRESH_S
operator|)
operator|&
name|ADCSAT_THRESH_M
operator|)
argument_list|)
expr_stmt|;
comment|/* Wait for AGC changes to be enacted */
name|OS_DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* 	 * We disable RF mix/gain stages for the PGA to avoid a 	 * race condition that will occur with receiving a frame 	 * and performing the AGC calibration.  This will be 	 * re-enabled at the end of offset cal.  We turn off AGC 	 * writes during this write as it will go over the analog bus. 	 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0x9808
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
literal|0x9808
argument_list|)
operator||
literal|0x08000000
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* wait for the AGC traffic to cease */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0x98D4
argument_list|,
literal|0x21
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0x9808
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
literal|0x9808
argument_list|)
operator|&
operator|(
operator|~
literal|0x08000000
operator|)
argument_list|)
expr_stmt|;
comment|/* wait to make sure that additional AGC traffic has quiesced */
name|OS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* AGC calibration (this was added to make the NF threshold check work) */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGCCTL
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGCCTL
argument_list|)
operator||
name|AR_PHY_AGC_CAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGCCTL
argument_list|,
name|AR_PHY_AGC_CAL
argument_list|,
literal|0
argument_list|)
condition|)
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: AGC calibration timeout\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Rewrite our AGC values we stored off earlier (return AGC to normal operation) */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0x9858
argument_list|,
name|reg9858
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0x985c
argument_list|,
name|reg985c
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0x9868
argument_list|,
name|reg9868
argument_list|)
expr_stmt|;
comment|/* Perform noise floor and set status */
if|if
condition|(
operator|!
name|ar5210CalNoiseFloor
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
condition|)
block|{
comment|/* 		 * Delay 5ms before retrying the noise floor - 		 * just to make sure.  We're in an error 		 * condition here 		 */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
operator||
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"%s: Performing 2nd Noise Cal\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar5210CalNoiseFloor
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
condition|)
name|chan
operator|->
name|ic_state
operator||=
name|IEEE80211_CHANSTATE_CWINT
expr_stmt|;
block|}
comment|/* Clear tx and rx disable bit */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|)
operator|&
operator|~
operator|(
name|AR_DIAG_SW_DIS_TX
operator||
name|AR_DIAG_SW_DIS_RX
operator|)
argument_list|)
expr_stmt|;
comment|/* Re-enable Beacons */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BEACON
argument_list|,
name|regBeacon
argument_list|)
expr_stmt|;
operator|*
name|isCalDone
operator|=
name|AH_TRUE
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5210PerCalibration
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|HAL_BOOL
modifier|*
name|isIQdone
parameter_list|)
block|{
return|return
name|ar5210PerCalibrationN
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
literal|0x1
argument_list|,
name|AH_TRUE
argument_list|,
name|isIQdone
argument_list|)
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5210ResetCalValid
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Writes the given reset bit mask into the reset register  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5210SetResetReg
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|resetMask
parameter_list|,
name|u_int
name|delay
parameter_list|)
block|{
name|uint32_t
name|mask
init|=
name|resetMask
condition|?
name|resetMask
else|:
operator|~
literal|0
decl_stmt|;
name|HAL_BOOL
name|rt
decl_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RC
argument_list|,
name|resetMask
argument_list|)
expr_stmt|;
comment|/* need to wait at least 128 clocks when reseting PCI before read */
name|OS_DELAY
argument_list|(
name|delay
argument_list|)
expr_stmt|;
name|resetMask
operator|&=
name|AR_RC_RPCU
operator||
name|AR_RC_RDMA
operator||
name|AR_RC_RPHY
operator||
name|AR_RC_RMAC
expr_stmt|;
name|mask
operator|&=
name|AR_RC_RPCU
operator||
name|AR_RC_RDMA
operator||
name|AR_RC_RPHY
operator||
name|AR_RC_RMAC
expr_stmt|;
name|rt
operator|=
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_RC
argument_list|,
name|mask
argument_list|,
name|resetMask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|resetMask
operator|&
name|AR_RC_RMAC
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isBigEndian
argument_list|()
condition|)
block|{
comment|/* 			 * Set CFG, little-endian for register 			 * and descriptor accesses. 			 */
name|mask
operator|=
name|INIT_CONFIG_STATUS
operator||
name|AR_CFG_SWTD
operator||
name|AR_CFG_SWRD
operator||
name|AR_CFG_SWRG
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CFG
argument_list|,
name|LE_READ_4
argument_list|(
operator|&
name|mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CFG
argument_list|,
name|INIT_CONFIG_STATUS
argument_list|)
expr_stmt|;
block|}
return|return
name|rt
return|;
block|}
end_function

begin_comment
comment|/*  * Returns: the pcdac value  */
end_comment

begin_function
specifier|static
name|uint8_t
name|getPcdac
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|tpcMap
modifier|*
name|pRD
parameter_list|,
name|uint8_t
name|dBm
parameter_list|)
block|{
name|int32_t
name|i
decl_stmt|;
name|int
name|useNextEntry
init|=
name|AH_FALSE
decl_stmt|;
name|uint32_t
name|interp
decl_stmt|;
for|for
control|(
name|i
operator|=
name|AR_TP_SCALING_ENTRIES
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Check for exact entry */
if|if
condition|(
name|dBm
operator|==
name|AR_I2DBM
argument_list|(
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|pRD
operator|->
name|pcdac
index|[
name|i
index|]
operator|!=
literal|63
condition|)
return|return
name|pRD
operator|->
name|pcdac
index|[
name|i
index|]
return|;
name|useNextEntry
operator|=
name|AH_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dBm
operator|+
literal|1
operator|==
name|AR_I2DBM
argument_list|(
name|i
argument_list|)
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
comment|/* Interpolate for between entry with a logish scale */
if|if
condition|(
name|pRD
operator|->
name|pcdac
index|[
name|i
index|]
operator|!=
literal|63
operator|&&
name|pRD
operator|->
name|pcdac
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|63
condition|)
block|{
name|interp
operator|=
operator|(
literal|350
operator|*
operator|(
name|pRD
operator|->
name|pcdac
index|[
name|i
index|]
operator|-
name|pRD
operator|->
name|pcdac
index|[
name|i
operator|-
literal|1
index|]
operator|)
operator|)
operator|+
literal|999
expr_stmt|;
name|interp
operator|=
operator|(
name|interp
operator|/
literal|1000
operator|)
operator|+
name|pRD
operator|->
name|pcdac
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
return|return
name|interp
return|;
block|}
name|useNextEntry
operator|=
name|AH_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|useNextEntry
operator|==
name|AH_TRUE
condition|)
block|{
comment|/* Grab the next lowest */
if|if
condition|(
name|pRD
operator|->
name|pcdac
index|[
name|i
index|]
operator|!=
literal|63
condition|)
return|return
name|pRD
operator|->
name|pcdac
index|[
name|i
index|]
return|;
block|}
block|}
comment|/* Return the lowest Entry if we haven't returned */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR_TP_SCALING_ENTRIES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pRD
operator|->
name|pcdac
index|[
name|i
index|]
operator|!=
literal|63
condition|)
return|return
name|pRD
operator|->
name|pcdac
index|[
name|i
index|]
return|;
comment|/* No value to return from table */
ifdef|#
directive|ifdef
name|AH_DEBUG
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"%s: empty transmit power table?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Find or interpolates the gainF value from the table ptr.  */
end_comment

begin_function
specifier|static
name|uint8_t
name|getGainF
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|tpcMap
modifier|*
name|pRD
parameter_list|,
name|uint8_t
name|pcdac
parameter_list|,
name|uint8_t
modifier|*
name|dBm
parameter_list|)
block|{
name|uint32_t
name|interp
decl_stmt|;
name|int
name|low
decl_stmt|,
name|high
decl_stmt|,
name|i
decl_stmt|;
name|low
operator|=
name|high
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR_TP_SCALING_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pRD
operator|->
name|pcdac
index|[
name|i
index|]
operator|==
literal|63
condition|)
continue|continue;
if|if
condition|(
name|pcdac
operator|==
name|pRD
operator|->
name|pcdac
index|[
name|i
index|]
condition|)
block|{
operator|*
name|dBm
operator|=
name|AR_I2DBM
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|pRD
operator|->
name|gainF
index|[
name|i
index|]
return|;
comment|/* Exact Match */
block|}
if|if
condition|(
name|pcdac
operator|>
name|pRD
operator|->
name|pcdac
index|[
name|i
index|]
condition|)
name|low
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|pcdac
operator|<
name|pRD
operator|->
name|pcdac
index|[
name|i
index|]
condition|)
block|{
name|high
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|low
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|dBm
operator|=
name|AR_I2DBM
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* PCDAC is lower than lowest setting */
return|return
name|pRD
operator|->
name|gainF
index|[
name|i
index|]
return|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|AR_TP_SCALING_ENTRIES
operator|&&
name|low
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* No settings were found */
ifdef|#
directive|ifdef
name|AH_DEBUG
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"%s: no valid entries in the pcdac table: %d\n"
argument_list|,
name|__func__
argument_list|,
name|pcdac
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|63
return|;
block|}
if|if
condition|(
name|i
operator|>=
name|AR_TP_SCALING_ENTRIES
condition|)
block|{
comment|/* PCDAC setting was above the max setting in the table */
operator|*
name|dBm
operator|=
name|AR_I2DBM
argument_list|(
name|low
argument_list|)
expr_stmt|;
return|return
name|pRD
operator|->
name|gainF
index|[
name|low
index|]
return|;
block|}
comment|/* Only exact if table has no missing entries */
operator|*
name|dBm
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|+
literal|3
expr_stmt|;
comment|/* 	 * Perform interpolation between low and high values to find gainF 	 * linearly scale the pcdac between low and high 	 */
name|interp
operator|=
operator|(
operator|(
name|pcdac
operator|-
name|pRD
operator|->
name|pcdac
index|[
name|low
index|]
operator|)
operator|*
literal|1000
operator|)
operator|/
operator|(
name|pRD
operator|->
name|pcdac
index|[
name|high
index|]
operator|-
name|pRD
operator|->
name|pcdac
index|[
name|low
index|]
operator|)
expr_stmt|;
comment|/* 	 * Multiply the scale ratio by the gainF difference 	 * (plus a rnd up factor) 	 */
name|interp
operator|=
operator|(
operator|(
name|interp
operator|*
operator|(
name|pRD
operator|->
name|gainF
index|[
name|high
index|]
operator|-
name|pRD
operator|->
name|gainF
index|[
name|low
index|]
operator|)
operator|)
operator|+
literal|999
operator|)
operator|/
literal|1000
expr_stmt|;
comment|/* Add ratioed gain_f to low gain_f value */
return|return
name|interp
operator|+
name|pRD
operator|->
name|gainF
index|[
name|low
index|]
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5210SetTxPowerLimit
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|limit
parameter_list|)
block|{
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_powerLimit
operator|=
name|AH_MIN
argument_list|(
name|limit
argument_list|,
name|AR5210_MAX_RATE_POWER
argument_list|)
expr_stmt|;
comment|/* XXX flush to h/w */
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Get TXPower values and set them in the radio  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|setupPowerSettings
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|uint8_t
name|cp
index|[
literal|17
index|]
parameter_list|)
block|{
name|uint16_t
name|freq
init|=
name|ath_hal_gethwchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
specifier|const
name|HAL_EEPROM_v1
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|uint8_t
name|gainFRD
decl_stmt|,
name|gainF36
decl_stmt|,
name|gainF48
decl_stmt|,
name|gainF54
decl_stmt|;
name|uint8_t
name|dBmRD
decl_stmt|,
name|dBm36
decl_stmt|,
name|dBm48
decl_stmt|,
name|dBm54
decl_stmt|,
name|dontcare
decl_stmt|;
name|uint32_t
name|rd
decl_stmt|,
name|group
decl_stmt|;
specifier|const
name|struct
name|tpcMap
modifier|*
name|pRD
decl_stmt|;
comment|/* Set OB/DB Values regardless of channel */
name|cp
index|[
literal|15
index|]
operator|=
operator|(
name|ee
operator|->
name|ee_biasCurrents
operator|>>
literal|4
operator|)
operator|&
literal|0x7
expr_stmt|;
name|cp
index|[
literal|16
index|]
operator|=
name|ee
operator|->
name|ee_biasCurrents
operator|&
literal|0x7
expr_stmt|;
if|if
condition|(
name|freq
operator|<
literal|5170
operator|||
name|freq
operator|>
literal|5320
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel %u\n"
argument_list|,
name|__func__
argument_list|,
name|freq
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|HALASSERT
argument_list|(
name|ee
operator|->
name|ee_version
operator|>=
name|AR_EEPROM_VER1
operator|&&
name|ee
operator|->
name|ee_version
operator|<
name|AR_EEPROM_VER3
argument_list|)
expr_stmt|;
comment|/* Match regulatory domain */
for|for
control|(
name|rd
operator|=
literal|0
init|;
name|rd
operator|<
name|AR_REG_DOMAINS_MAX
condition|;
name|rd
operator|++
control|)
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_currentRD
operator|==
name|ee
operator|->
name|ee_regDomain
index|[
name|rd
index|]
condition|)
break|break;
if|if
condition|(
name|rd
operator|==
name|AR_REG_DOMAINS_MAX
condition|)
block|{
ifdef|#
directive|ifdef
name|AH_DEBUG
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"%s: no calibrated regulatory domain matches the "
literal|"current regularly domain (0x%0x)\n"
argument_list|,
name|__func__
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_currentRD
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|AH_FALSE
return|;
block|}
name|group
operator|=
operator|(
operator|(
name|freq
operator|-
literal|5170
operator|)
operator|/
literal|10
operator|)
expr_stmt|;
if|if
condition|(
name|group
operator|>
literal|11
condition|)
block|{
comment|/* Pull 5.29 into the 5.27 group */
name|group
operator|--
expr_stmt|;
block|}
comment|/* Integer divide will set group from 0 to 4 */
name|group
operator|=
name|group
operator|/
literal|3
expr_stmt|;
name|pRD
operator|=
operator|&
name|ee
operator|->
name|ee_tpc
index|[
name|group
index|]
expr_stmt|;
comment|/* Set PC DAC Values */
name|cp
index|[
literal|14
index|]
operator|=
name|pRD
operator|->
name|regdmn
index|[
name|rd
index|]
expr_stmt|;
name|cp
index|[
literal|9
index|]
operator|=
name|AH_MIN
argument_list|(
name|pRD
operator|->
name|regdmn
index|[
name|rd
index|]
argument_list|,
name|pRD
operator|->
name|rate36
argument_list|)
expr_stmt|;
name|cp
index|[
literal|8
index|]
operator|=
name|AH_MIN
argument_list|(
name|pRD
operator|->
name|regdmn
index|[
name|rd
index|]
argument_list|,
name|pRD
operator|->
name|rate48
argument_list|)
expr_stmt|;
name|cp
index|[
literal|7
index|]
operator|=
name|AH_MIN
argument_list|(
name|pRD
operator|->
name|regdmn
index|[
name|rd
index|]
argument_list|,
name|pRD
operator|->
name|rate54
argument_list|)
expr_stmt|;
comment|/* Find Corresponding gainF values for RD, 36, 48, 54 */
name|gainFRD
operator|=
name|getGainF
argument_list|(
name|ah
argument_list|,
name|pRD
argument_list|,
name|pRD
operator|->
name|regdmn
index|[
name|rd
index|]
argument_list|,
operator|&
name|dBmRD
argument_list|)
expr_stmt|;
name|gainF36
operator|=
name|getGainF
argument_list|(
name|ah
argument_list|,
name|pRD
argument_list|,
name|cp
index|[
literal|9
index|]
argument_list|,
operator|&
name|dBm36
argument_list|)
expr_stmt|;
name|gainF48
operator|=
name|getGainF
argument_list|(
name|ah
argument_list|,
name|pRD
argument_list|,
name|cp
index|[
literal|8
index|]
argument_list|,
operator|&
name|dBm48
argument_list|)
expr_stmt|;
name|gainF54
operator|=
name|getGainF
argument_list|(
name|ah
argument_list|,
name|pRD
argument_list|,
name|cp
index|[
literal|7
index|]
argument_list|,
operator|&
name|dBm54
argument_list|)
expr_stmt|;
comment|/* Power Scale if requested */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tpScale
operator|!=
name|HAL_TP_SCALE_MAX
condition|)
block|{
specifier|static
specifier|const
name|uint16_t
name|tpcScaleReductionTable
index|[
literal|5
index|]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|6
block|,
literal|9
block|,
name|AR5210_MAX_RATE_POWER
block|}
decl_stmt|;
name|uint16_t
name|tpScale
decl_stmt|;
name|tpScale
operator|=
name|tpcScaleReductionTable
index|[
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tpScale
index|]
expr_stmt|;
if|if
condition|(
name|dBmRD
operator|<
name|tpScale
operator|+
literal|3
condition|)
name|dBmRD
operator|=
literal|3
expr_stmt|;
comment|/* min */
else|else
name|dBmRD
operator|-=
name|tpScale
expr_stmt|;
name|cp
index|[
literal|14
index|]
operator|=
name|getPcdac
argument_list|(
name|ah
argument_list|,
name|pRD
argument_list|,
name|dBmRD
argument_list|)
expr_stmt|;
name|gainFRD
operator|=
name|getGainF
argument_list|(
name|ah
argument_list|,
name|pRD
argument_list|,
name|cp
index|[
literal|14
index|]
argument_list|,
operator|&
name|dontcare
argument_list|)
expr_stmt|;
name|dBm36
operator|=
name|AH_MIN
argument_list|(
name|dBm36
argument_list|,
name|dBmRD
argument_list|)
expr_stmt|;
name|cp
index|[
literal|9
index|]
operator|=
name|getPcdac
argument_list|(
name|ah
argument_list|,
name|pRD
argument_list|,
name|dBm36
argument_list|)
expr_stmt|;
name|gainF36
operator|=
name|getGainF
argument_list|(
name|ah
argument_list|,
name|pRD
argument_list|,
name|cp
index|[
literal|9
index|]
argument_list|,
operator|&
name|dontcare
argument_list|)
expr_stmt|;
name|dBm48
operator|=
name|AH_MIN
argument_list|(
name|dBm48
argument_list|,
name|dBmRD
argument_list|)
expr_stmt|;
name|cp
index|[
literal|8
index|]
operator|=
name|getPcdac
argument_list|(
name|ah
argument_list|,
name|pRD
argument_list|,
name|dBm48
argument_list|)
expr_stmt|;
name|gainF48
operator|=
name|getGainF
argument_list|(
name|ah
argument_list|,
name|pRD
argument_list|,
name|cp
index|[
literal|8
index|]
argument_list|,
operator|&
name|dontcare
argument_list|)
expr_stmt|;
name|dBm54
operator|=
name|AH_MIN
argument_list|(
name|dBm54
argument_list|,
name|dBmRD
argument_list|)
expr_stmt|;
name|cp
index|[
literal|7
index|]
operator|=
name|getPcdac
argument_list|(
name|ah
argument_list|,
name|pRD
argument_list|,
name|dBm54
argument_list|)
expr_stmt|;
name|gainF54
operator|=
name|getGainF
argument_list|(
name|ah
argument_list|,
name|pRD
argument_list|,
name|cp
index|[
literal|7
index|]
argument_list|,
operator|&
name|dontcare
argument_list|)
expr_stmt|;
block|}
comment|/* Record current dBm at rate 6 */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_maxPowerLevel
operator|=
literal|2
operator|*
name|dBmRD
expr_stmt|;
name|cp
index|[
literal|13
index|]
operator|=
name|cp
index|[
literal|12
index|]
operator|=
name|cp
index|[
literal|11
index|]
operator|=
name|cp
index|[
literal|10
index|]
operator|=
name|cp
index|[
literal|14
index|]
expr_stmt|;
comment|/* Set GainF Values */
name|cp
index|[
literal|0
index|]
operator|=
name|gainFRD
operator|-
name|gainF54
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
name|gainFRD
operator|-
name|gainF48
expr_stmt|;
name|cp
index|[
literal|2
index|]
operator|=
name|gainFRD
operator|-
name|gainF36
expr_stmt|;
comment|/* 9, 12, 18, 24 have no gain_delta from 6 */
name|cp
index|[
literal|3
index|]
operator|=
name|cp
index|[
literal|4
index|]
operator|=
name|cp
index|[
literal|5
index|]
operator|=
name|cp
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Places the device in and out of reset and then places sane  * values in the registers based on EEPROM config, initialization  * vectors (as determined by the mode), and station configuration  */
end_comment

begin_function
name|HAL_BOOL
name|ar5210SetTransmitPower
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) / sizeof (a[0]))
specifier|static
specifier|const
name|uint32_t
name|pwr_regs_start
index|[
literal|17
index|]
init|=
block|{
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0xf0000000
block|,
literal|0xcc000000
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x0a000000
block|,
literal|0x000000e2
block|,
literal|0x0a000020
block|,
literal|0x01000002
block|,
literal|0x01000018
block|,
literal|0x40000000
block|,
literal|0x00000418
block|}
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|uint8_t
name|cp
index|[
sizeof|sizeof
argument_list|(
name|ar5k0007_pwrSettings
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|pwr_regs
index|[
literal|17
index|]
decl_stmt|;
name|OS_MEMCPY
argument_list|(
name|pwr_regs
argument_list|,
name|pwr_regs_start
argument_list|,
sizeof|sizeof
argument_list|(
name|pwr_regs
argument_list|)
argument_list|)
expr_stmt|;
name|OS_MEMCPY
argument_list|(
name|cp
argument_list|,
name|ar5k0007_pwrSettings
argument_list|,
sizeof|sizeof
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check the EEPROM tx power calibration settings */
if|if
condition|(
operator|!
name|setupPowerSettings
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|cp
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|AH_DEBUG
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"%s: unable to setup power settings\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|AH_FALSE
return|;
block|}
if|if
condition|(
name|cp
index|[
literal|15
index|]
operator|<
literal|1
operator|||
name|cp
index|[
literal|15
index|]
operator|>
literal|5
condition|)
block|{
ifdef|#
directive|ifdef
name|AH_DEBUG
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"%s: OB out of range (%u)\n"
argument_list|,
name|__func__
argument_list|,
name|cp
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|AH_FALSE
return|;
block|}
if|if
condition|(
name|cp
index|[
literal|16
index|]
operator|<
literal|1
operator|||
name|cp
index|[
literal|16
index|]
operator|>
literal|5
condition|)
block|{
ifdef|#
directive|ifdef
name|AH_DEBUG
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"%s: DB out of range (%u)\n"
argument_list|,
name|__func__
argument_list|,
name|cp
index|[
literal|16
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|AH_FALSE
return|;
block|}
comment|/* reverse bits of the transmit power array */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
name|cp
index|[
name|i
index|]
operator|=
name|ath_hal_reverseBits
argument_list|(
name|cp
index|[
name|i
index|]
argument_list|,
literal|5
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
name|cp
index|[
name|i
index|]
operator|=
name|ath_hal_reverseBits
argument_list|(
name|cp
index|[
name|i
index|]
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* merge transmit power values into the register - quite gross */
name|pwr_regs
index|[
literal|0
index|]
operator||=
operator|(
operator|(
name|cp
index|[
literal|1
index|]
operator|<<
literal|5
operator|)
operator|&
literal|0xE0
operator|)
operator||
operator|(
name|cp
index|[
literal|0
index|]
operator|&
literal|0x1F
operator|)
expr_stmt|;
name|pwr_regs
index|[
literal|1
index|]
operator||=
operator|(
operator|(
name|cp
index|[
literal|3
index|]
operator|<<
literal|7
operator|)
operator|&
literal|0x80
operator|)
operator||
operator|(
operator|(
name|cp
index|[
literal|2
index|]
operator|<<
literal|2
operator|)
operator|&
literal|0x7C
operator|)
operator||
operator|(
operator|(
name|cp
index|[
literal|1
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0x03
operator|)
expr_stmt|;
name|pwr_regs
index|[
literal|2
index|]
operator||=
operator|(
operator|(
name|cp
index|[
literal|4
index|]
operator|<<
literal|4
operator|)
operator|&
literal|0xF0
operator|)
operator||
operator|(
operator|(
name|cp
index|[
literal|3
index|]
operator|>>
literal|1
operator|)
operator|&
literal|0x0F
operator|)
expr_stmt|;
name|pwr_regs
index|[
literal|3
index|]
operator||=
operator|(
operator|(
name|cp
index|[
literal|6
index|]
operator|<<
literal|6
operator|)
operator|&
literal|0xC0
operator|)
operator||
operator|(
operator|(
name|cp
index|[
literal|5
index|]
operator|<<
literal|1
operator|)
operator|&
literal|0x3E
operator|)
operator||
operator|(
operator|(
name|cp
index|[
literal|4
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0x01
operator|)
expr_stmt|;
name|pwr_regs
index|[
literal|4
index|]
operator||=
operator|(
operator|(
name|cp
index|[
literal|7
index|]
operator|<<
literal|3
operator|)
operator|&
literal|0xF8
operator|)
operator||
operator|(
operator|(
name|cp
index|[
literal|6
index|]
operator|>>
literal|2
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
name|pwr_regs
index|[
literal|5
index|]
operator||=
operator|(
operator|(
name|cp
index|[
literal|9
index|]
operator|<<
literal|7
operator|)
operator|&
literal|0x80
operator|)
operator||
operator|(
operator|(
name|cp
index|[
literal|8
index|]
operator|<<
literal|1
operator|)
operator|&
literal|0x7E
operator|)
operator||
operator|(
operator|(
name|cp
index|[
literal|7
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x01
operator|)
expr_stmt|;
name|pwr_regs
index|[
literal|6
index|]
operator||=
operator|(
operator|(
name|cp
index|[
literal|10
index|]
operator|<<
literal|5
operator|)
operator|&
literal|0xE0
operator|)
operator||
operator|(
operator|(
name|cp
index|[
literal|9
index|]
operator|>>
literal|1
operator|)
operator|&
literal|0x1F
operator|)
expr_stmt|;
name|pwr_regs
index|[
literal|7
index|]
operator||=
operator|(
operator|(
name|cp
index|[
literal|11
index|]
operator|<<
literal|3
operator|)
operator|&
literal|0xF8
operator|)
operator||
operator|(
operator|(
name|cp
index|[
literal|10
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
name|pwr_regs
index|[
literal|8
index|]
operator||=
operator|(
operator|(
name|cp
index|[
literal|12
index|]
operator|<<
literal|1
operator|)
operator|&
literal|0x7E
operator|)
operator||
operator|(
operator|(
name|cp
index|[
literal|11
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x01
operator|)
expr_stmt|;
name|pwr_regs
index|[
literal|9
index|]
operator||=
operator|(
operator|(
name|cp
index|[
literal|13
index|]
operator|<<
literal|5
operator|)
operator|&
literal|0xE0
operator|)
expr_stmt|;
name|pwr_regs
index|[
literal|10
index|]
operator||=
operator|(
operator|(
name|cp
index|[
literal|14
index|]
operator|<<
literal|3
operator|)
operator|&
literal|0xF8
operator|)
operator||
operator|(
operator|(
name|cp
index|[
literal|13
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
name|pwr_regs
index|[
literal|11
index|]
operator||=
operator|(
operator|(
name|cp
index|[
literal|14
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x01
operator|)
expr_stmt|;
comment|/* Set OB */
name|pwr_regs
index|[
literal|8
index|]
operator||=
operator|(
name|ath_hal_reverseBits
argument_list|(
name|cp
index|[
literal|15
index|]
argument_list|,
literal|3
argument_list|)
operator|<<
literal|7
operator|)
operator|&
literal|0x80
expr_stmt|;
name|pwr_regs
index|[
literal|9
index|]
operator||=
operator|(
name|ath_hal_reverseBits
argument_list|(
name|cp
index|[
literal|15
index|]
argument_list|,
literal|3
argument_list|)
operator|>>
literal|1
operator|)
operator|&
literal|0x03
expr_stmt|;
comment|/* Set DB */
name|pwr_regs
index|[
literal|9
index|]
operator||=
operator|(
name|ath_hal_reverseBits
argument_list|(
name|cp
index|[
literal|16
index|]
argument_list|,
literal|3
argument_list|)
operator|<<
literal|2
operator|)
operator|&
literal|0x1C
expr_stmt|;
comment|/* Write the registers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|pwr_regs
argument_list|)
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0x0000989c
argument_list|,
name|pwr_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* last write is a flush */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0x000098d4
argument_list|,
name|pwr_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Takes the MHz channel value and sets the Channel value  *  * ASSUMES: Writes enabled to analog bus before AGC is active  *   or by disabling the AGC.  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5210SetChannel
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|uint16_t
name|freq
init|=
name|ath_hal_gethwchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|uint32_t
name|data
decl_stmt|;
comment|/* Set the Channel */
name|data
operator|=
name|ath_hal_reverseBits
argument_list|(
operator|(
name|freq
operator|-
literal|5120
operator|)
operator|/
literal|10
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|data
operator|<<
literal|1
operator|)
operator||
literal|0x41
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0x27
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0x30
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|=
name|chan
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|int16_t
name|ar5210GetNoiseFloor
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|int16_t
name|nf
decl_stmt|;
name|nf
operator|=
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|25
argument_list|)
argument_list|)
operator|>>
literal|19
operator|)
operator|&
literal|0x1ff
expr_stmt|;
if|if
condition|(
name|nf
operator|&
literal|0x100
condition|)
name|nf
operator|=
literal|0
operator|-
operator|(
operator|(
name|nf
operator|^
literal|0x1ff
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
return|return
name|nf
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NORMAL_NF_THRESH
value|(-72)
end_define

begin_comment
comment|/*  * Peform the noisefloor calibration and check for  * any constant channel interference  *  * Returns: TRUE for a successful noise floor calibration; else FALSE  */
end_comment

begin_function
name|HAL_BOOL
name|ar5210CalNoiseFloor
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
parameter_list|)
block|{
name|int32_t
name|nf
decl_stmt|,
name|nfLoops
decl_stmt|;
comment|/* Calibrate the noise floor */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGCCTL
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGCCTL
argument_list|)
operator||
name|AR_PHY_AGC_NF
argument_list|)
expr_stmt|;
comment|/* Do not read noise floor until it has done the first update */
if|if
condition|(
operator|!
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGCCTL
argument_list|,
name|AR_PHY_AGC_NF
argument_list|,
literal|0
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ATH_HAL_DEBUG
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|" -PHY NF Reg state: 0x%x\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGCCTL
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|" -MAC Reset Reg state: 0x%x\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RC
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|" -PHY Active Reg state: 0x%x\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ACTIVE
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ATH_HAL_DEBUG */
return|return
name|AH_FALSE
return|;
block|}
name|nf
operator|=
literal|0
expr_stmt|;
comment|/* Keep checking until the floor is below the threshold or the nf is done */
for|for
control|(
name|nfLoops
operator|=
literal|0
init|;
operator|(
operator|(
name|nfLoops
operator|<
literal|21
operator|)
operator|&&
operator|(
name|nf
operator|>
name|NORMAL_NF_THRESH
operator|)
operator|)
condition|;
name|nfLoops
operator|++
control|)
block|{
name|OS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Sleep for 1 ms */
name|nf
operator|=
name|ar5210GetNoiseFloor
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nf
operator|>
name|NORMAL_NF_THRESH
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: Bad noise cal %d\n"
argument_list|,
name|__func__
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|ichan
operator|->
name|rawNoiseFloor
operator|=
literal|0
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|ichan
operator|->
name|rawNoiseFloor
operator|=
name|nf
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Adjust NF based on statistical values for 5GHz frequencies.  */
end_comment

begin_function
name|int16_t
name|ar5210GetNfAdjust
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_CHANNEL_INTERNAL
modifier|*
name|c
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|HAL_RFGAIN
name|ar5210GetRfgain
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|HAL_RFGAIN_INACTIVE
return|;
block|}
end_function

end_unit

