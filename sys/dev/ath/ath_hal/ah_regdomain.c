begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2005-2006 Atheros Communications, Inc.  * All rights reserved.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|<net80211/_ieee80211.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_eeprom.h"
end_include

begin_include
include|#
directive|include
file|"ah_devid.h"
end_include

begin_include
include|#
directive|include
file|"ah_regdomain.h"
end_include

begin_comment
comment|/*  * XXX this code needs a audit+review  */
end_comment

begin_comment
comment|/* used throughout this file... */
end_comment

begin_define
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|nitems(a)
end_define

begin_define
define|#
directive|define
name|HAL_MODE_11A_TURBO
value|HAL_MODE_108A
end_define

begin_define
define|#
directive|define
name|HAL_MODE_11G_TURBO
value|HAL_MODE_108G
end_define

begin_comment
comment|/*  * Mask to check whether a domain is a multidomain or a single domain  */
end_comment

begin_define
define|#
directive|define
name|MULTI_DOMAIN_MASK
value|0xFF00
end_define

begin_comment
comment|/*  * Enumerated Regulatory Domain Information 8 bit values indicate that  * the regdomain is really a pair of unitary regdomains.  12 bit values  * are the real unitary regdomains and are the only ones which have the  * frequency bitmasks and flags set.  */
end_comment

begin_include
include|#
directive|include
file|"ah_regdomain/ah_rd_regenum.h"
end_include

begin_define
define|#
directive|define
name|WORLD_SKU_MASK
value|0x00F0
end_define

begin_define
define|#
directive|define
name|WORLD_SKU_PREFIX
value|0x0060
end_define

begin_comment
comment|/*  * THE following table is the mapping of regdomain pairs specified by  * an 8 bit regdomain value to the individual unitary reg domains  */
end_comment

begin_include
include|#
directive|include
file|"ah_regdomain/ah_rd_regmap.h"
end_include

begin_comment
comment|/*   * The following tables are the master list for all different freqeuncy  * bands with the complete matrix of all possible flags and settings  * for each band if it is used in ANY reg domain.  */
end_comment

begin_define
define|#
directive|define
name|COUNTRY_ERD_FLAG
value|0x8000
end_define

begin_define
define|#
directive|define
name|WORLDWIDE_ROAMING_FLAG
value|0x4000
end_define

begin_comment
comment|/*  * This table maps country ISO codes from net80211 into regulatory  * domains which the ath regulatory domain code understands.  */
end_comment

begin_include
include|#
directive|include
file|"ah_regdomain/ah_rd_ctry.h"
end_include

begin_comment
comment|/*  * The frequency band collections are a set of frequency ranges  * with shared properties - max tx power, max antenna gain, channel width,  * channel spacing, DFS requirements and passive scanning requirements.  *  * These are represented as entries in a frequency band bitmask.  * Each regulatory domain entry in ah_regdomain_domains.h uses one  * or more frequency band entries for each of the channel modes  * supported (11bg, 11a, half, quarter, turbo, etc.)  *  */
end_comment

begin_include
include|#
directive|include
file|"ah_regdomain/ah_rd_freqbands.h"
end_include

begin_comment
comment|/*  * This is the main regulatory database. It defines the supported  * set of features and requirements for each of the defined regulatory  * zones. It uses combinations of frequency ranges - represented in  * a bitmask - to determine the requirements and limitations needed.  */
end_comment

begin_include
include|#
directive|include
file|"ah_regdomain/ah_rd_domains.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|cmode
name|modes
index|[]
init|=
block|{
block|{
name|HAL_MODE_TURBO
block|,
name|IEEE80211_CHAN_ST
block|,
operator|&
name|regDmn5GhzTurboFreq
index|[
literal|0
index|]
block|}
block|,
block|{
name|HAL_MODE_11A
block|,
name|IEEE80211_CHAN_A
block|,
operator|&
name|regDmn5GhzFreq
index|[
literal|0
index|]
block|}
block|,
block|{
name|HAL_MODE_11B
block|,
name|IEEE80211_CHAN_B
block|,
operator|&
name|regDmn2GhzFreq
index|[
literal|0
index|]
block|}
block|,
block|{
name|HAL_MODE_11G
block|,
name|IEEE80211_CHAN_G
block|,
operator|&
name|regDmn2Ghz11gFreq
index|[
literal|0
index|]
block|}
block|,
block|{
name|HAL_MODE_11G_TURBO
block|,
name|IEEE80211_CHAN_108G
block|,
operator|&
name|regDmn2Ghz11gTurboFreq
index|[
literal|0
index|]
block|}
block|,
block|{
name|HAL_MODE_11A_TURBO
block|,
name|IEEE80211_CHAN_108A
block|,
operator|&
name|regDmn5GhzTurboFreq
index|[
literal|0
index|]
block|}
block|,
block|{
name|HAL_MODE_11A_QUARTER_RATE
block|,
name|IEEE80211_CHAN_A
operator||
name|IEEE80211_CHAN_QUARTER
block|,
operator|&
name|regDmn5GhzFreq
index|[
literal|0
index|]
block|}
block|,
block|{
name|HAL_MODE_11A_HALF_RATE
block|,
name|IEEE80211_CHAN_A
operator||
name|IEEE80211_CHAN_HALF
block|,
operator|&
name|regDmn5GhzFreq
index|[
literal|0
index|]
block|}
block|,
block|{
name|HAL_MODE_11G_QUARTER_RATE
block|,
name|IEEE80211_CHAN_G
operator||
name|IEEE80211_CHAN_QUARTER
block|,
operator|&
name|regDmn2Ghz11gFreq
index|[
literal|0
index|]
block|}
block|,
block|{
name|HAL_MODE_11G_HALF_RATE
block|,
name|IEEE80211_CHAN_G
operator||
name|IEEE80211_CHAN_HALF
block|,
operator|&
name|regDmn2Ghz11gFreq
index|[
literal|0
index|]
block|}
block|,
block|{
name|HAL_MODE_11NG_HT20
block|,
name|IEEE80211_CHAN_G
operator||
name|IEEE80211_CHAN_HT20
block|,
operator|&
name|regDmn2Ghz11gFreq
index|[
literal|0
index|]
block|}
block|,
block|{
name|HAL_MODE_11NG_HT40PLUS
block|,
name|IEEE80211_CHAN_G
operator||
name|IEEE80211_CHAN_HT40U
block|,
operator|&
name|regDmn2Ghz11gFreq
index|[
literal|0
index|]
block|}
block|,
block|{
name|HAL_MODE_11NG_HT40MINUS
block|,
name|IEEE80211_CHAN_G
operator||
name|IEEE80211_CHAN_HT40D
block|,
operator|&
name|regDmn2Ghz11gFreq
index|[
literal|0
index|]
block|}
block|,
block|{
name|HAL_MODE_11NA_HT20
block|,
name|IEEE80211_CHAN_A
operator||
name|IEEE80211_CHAN_HT20
block|,
operator|&
name|regDmn5GhzFreq
index|[
literal|0
index|]
block|}
block|,
block|{
name|HAL_MODE_11NA_HT40PLUS
block|,
name|IEEE80211_CHAN_A
operator||
name|IEEE80211_CHAN_HT40U
block|,
operator|&
name|regDmn5GhzFreq
index|[
literal|0
index|]
block|}
block|,
block|{
name|HAL_MODE_11NA_HT40MINUS
block|,
name|IEEE80211_CHAN_A
operator||
name|IEEE80211_CHAN_HT40D
block|,
operator|&
name|regDmn5GhzFreq
index|[
literal|0
index|]
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ath_hal_update_dfsdomain
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|OS_INLINE
name|uint16_t
name|getEepromRD
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_currentRD
operator|&
operator|~
name|WORLDWIDE_ROAMING_FLAG
return|;
block|}
end_function

begin_comment
comment|/*  * Test to see if the bitmask array is all zeros  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|isChanBitMaskZero
parameter_list|(
specifier|const
name|uint64_t
modifier|*
name|bitmask
parameter_list|)
block|{
if|#
directive|if
name|BMLEN
operator|>
literal|2
error|#
directive|error
literal|"add more cases"
endif|#
directive|endif
if|#
directive|if
name|BMLEN
operator|>
literal|1
if|if
condition|(
name|bitmask
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
return|return
name|AH_FALSE
return|;
endif|#
directive|endif
return|return
operator|(
name|bitmask
index|[
literal|0
index|]
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return whether or not the regulatory domain/country in EEPROM  * is acceptable.  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|isEepromValid
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|uint16_t
name|rd
init|=
name|getEepromRD
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|rd
operator|&
name|COUNTRY_ERD_FLAG
condition|)
block|{
name|uint16_t
name|cc
init|=
name|rd
operator|&
operator|~
name|COUNTRY_ERD_FLAG
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|allCountries
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|allCountries
index|[
name|i
index|]
operator|.
name|countryCode
operator|==
name|cc
condition|)
return|return
name|AH_TRUE
return|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|regDomainPairs
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regDomainPairs
index|[
name|i
index|]
operator|.
name|regDmnEnum
operator|==
name|rd
condition|)
return|return
name|AH_TRUE
return|;
block|}
if|if
condition|(
name|rd
operator|==
name|FCC_UBNT
condition|)
block|{
return|return
name|AH_TRUE
return|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: invalid regulatory domain/country code 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|rd
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Find the pointer to the country element in the country table  * corresponding to the country code  */
end_comment

begin_function
specifier|static
name|COUNTRY_CODE_TO_ENUM_RD
modifier|*
name|findCountry
parameter_list|(
name|HAL_CTRY_CODE
name|countryCode
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|allCountries
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|allCountries
index|[
name|i
index|]
operator|.
name|countryCode
operator|==
name|countryCode
condition|)
return|return
operator|&
name|allCountries
index|[
name|i
index|]
return|;
block|}
return|return
name|AH_NULL
return|;
block|}
end_function

begin_function
specifier|static
name|REG_DOMAIN
modifier|*
name|findRegDmn
parameter_list|(
name|int
name|regDmn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|regDomains
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regDomains
index|[
name|i
index|]
operator|.
name|regDmnEnum
operator|==
name|regDmn
condition|)
return|return
operator|&
name|regDomains
index|[
name|i
index|]
return|;
block|}
return|return
name|AH_NULL
return|;
block|}
end_function

begin_function
specifier|static
name|REG_DMN_PAIR_MAPPING
modifier|*
name|findRegDmnPair
parameter_list|(
name|int
name|regDmnPair
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regDmnPair
operator|!=
name|NO_ENUMRD
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|regDomainPairs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regDomainPairs
index|[
name|i
index|]
operator|.
name|regDmnEnum
operator|==
name|regDmnPair
condition|)
return|return
operator|&
name|regDomainPairs
index|[
name|i
index|]
return|;
block|}
block|}
return|return
name|AH_NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate a default country based on the EEPROM setting.  */
end_comment

begin_function
specifier|static
name|HAL_CTRY_CODE
name|getDefaultCountry
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|REG_DMN_PAIR_MAPPING
modifier|*
name|regpair
decl_stmt|;
name|uint16_t
name|rd
decl_stmt|;
name|rd
operator|=
name|getEepromRD
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|&
name|COUNTRY_ERD_FLAG
condition|)
block|{
name|COUNTRY_CODE_TO_ENUM_RD
modifier|*
name|country
decl_stmt|;
name|uint16_t
name|cc
init|=
name|rd
operator|&
operator|~
name|COUNTRY_ERD_FLAG
decl_stmt|;
name|country
operator|=
name|findCountry
argument_list|(
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|country
operator|!=
name|AH_NULL
condition|)
return|return
name|cc
return|;
block|}
comment|/* 	 * Check reg domains that have only one country 	 */
name|regpair
operator|=
name|findRegDmnPair
argument_list|(
name|rd
argument_list|)
expr_stmt|;
return|return
operator|(
name|regpair
operator|!=
name|AH_NULL
operator|)
condition|?
name|regpair
operator|->
name|singleCC
else|:
name|CTRY_DEFAULT
return|;
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|IS_BIT_SET
parameter_list|(
name|int
name|bit
parameter_list|,
specifier|const
name|uint64_t
name|bitmask
index|[]
parameter_list|)
block|{
name|int
name|byteOffset
decl_stmt|,
name|bitnum
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|byteOffset
operator|=
name|bit
operator|/
literal|64
expr_stmt|;
name|bitnum
operator|=
name|bit
operator|-
name|byteOffset
operator|*
literal|64
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|uint64_t
operator|)
literal|1
operator|)
operator|<<
name|bitnum
expr_stmt|;
return|return
operator|(
name|bitmask
index|[
name|byteOffset
index|]
operator|&
name|val
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|HAL_STATUS
name|getregstate
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CTRY_CODE
name|cc
parameter_list|,
name|HAL_REG_DOMAIN
name|regDmn
parameter_list|,
name|COUNTRY_CODE_TO_ENUM_RD
modifier|*
modifier|*
name|pcountry
parameter_list|,
name|REG_DOMAIN
modifier|*
modifier|*
name|prd2GHz
parameter_list|,
name|REG_DOMAIN
modifier|*
modifier|*
name|prd5GHz
parameter_list|)
block|{
name|COUNTRY_CODE_TO_ENUM_RD
modifier|*
name|country
decl_stmt|;
name|REG_DOMAIN
modifier|*
name|rd5GHz
decl_stmt|,
modifier|*
name|rd2GHz
decl_stmt|;
if|if
condition|(
name|cc
operator|==
name|CTRY_DEFAULT
operator|&&
name|regDmn
operator|==
name|SKU_NONE
condition|)
block|{
comment|/* 		 * Validate the EEPROM setting and setup defaults 		 */
if|if
condition|(
operator|!
name|isEepromValid
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* 			 * Don't return any channels if the EEPROM has an 			 * invalid regulatory domain/country code setting. 			 */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: invalid EEPROM contents\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|HAL_EEBADREG
return|;
block|}
name|cc
operator|=
name|getDefaultCountry
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|country
operator|=
name|findCountry
argument_list|(
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|country
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"NULL Country!, cc %d\n"
argument_list|,
name|cc
argument_list|)
expr_stmt|;
return|return
name|HAL_EEBADCC
return|;
block|}
name|regDmn
operator|=
name|country
operator|->
name|regDmnEnum
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: EEPROM cc %u rd 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|cc
argument_list|,
name|regDmn
argument_list|)
expr_stmt|;
if|if
condition|(
name|country
operator|->
name|countryCode
operator|==
name|CTRY_DEFAULT
condition|)
block|{
comment|/* 			 * Check EEPROM; SKU may be for a country, single 			 * domain, or multiple domains (WWR). 			 */
name|uint16_t
name|rdnum
init|=
name|getEepromRD
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|rdnum
operator|&
name|COUNTRY_ERD_FLAG
operator|)
operator|==
literal|0
operator|&&
operator|(
name|findRegDmn
argument_list|(
name|rdnum
argument_list|)
operator|!=
name|AH_NULL
operator|||
name|findRegDmnPair
argument_list|(
name|rdnum
argument_list|)
operator|!=
name|AH_NULL
operator|)
condition|)
block|{
name|regDmn
operator|=
name|rdnum
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: EEPROM rd 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|rdnum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|country
operator|=
name|findCountry
argument_list|(
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|country
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"unknown country, cc %d\n"
argument_list|,
name|cc
argument_list|)
expr_stmt|;
return|return
name|HAL_EINVAL
return|;
block|}
if|if
condition|(
name|regDmn
operator|==
name|SKU_NONE
condition|)
name|regDmn
operator|=
name|country
operator|->
name|regDmnEnum
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: cc %u rd 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|cc
argument_list|,
name|regDmn
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Setup per-band state. 	 */
if|if
condition|(
operator|(
name|regDmn
operator|&
name|MULTI_DOMAIN_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|REG_DMN_PAIR_MAPPING
modifier|*
name|regpair
init|=
name|findRegDmnPair
argument_list|(
name|regDmn
argument_list|)
decl_stmt|;
if|if
condition|(
name|regpair
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: no reg domain pair %u for country %u\n"
argument_list|,
name|__func__
argument_list|,
name|regDmn
argument_list|,
name|country
operator|->
name|countryCode
argument_list|)
expr_stmt|;
return|return
name|HAL_EINVAL
return|;
block|}
name|rd5GHz
operator|=
name|findRegDmn
argument_list|(
name|regpair
operator|->
name|regDmn5GHz
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd5GHz
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: no 5GHz reg domain %u for country %u\n"
argument_list|,
name|__func__
argument_list|,
name|regpair
operator|->
name|regDmn5GHz
argument_list|,
name|country
operator|->
name|countryCode
argument_list|)
expr_stmt|;
return|return
name|HAL_EINVAL
return|;
block|}
name|rd2GHz
operator|=
name|findRegDmn
argument_list|(
name|regpair
operator|->
name|regDmn2GHz
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd2GHz
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: no 2GHz reg domain %u for country %u\n"
argument_list|,
name|__func__
argument_list|,
name|regpair
operator|->
name|regDmn2GHz
argument_list|,
name|country
operator|->
name|countryCode
argument_list|)
expr_stmt|;
return|return
name|HAL_EINVAL
return|;
block|}
block|}
else|else
block|{
name|rd5GHz
operator|=
name|rd2GHz
operator|=
name|findRegDmn
argument_list|(
name|regDmn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd2GHz
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: no unitary reg domain %u for country %u\n"
argument_list|,
name|__func__
argument_list|,
name|regDmn
argument_list|,
name|country
operator|->
name|countryCode
argument_list|)
expr_stmt|;
return|return
name|HAL_EINVAL
return|;
block|}
block|}
if|if
condition|(
name|pcountry
operator|!=
name|AH_NULL
condition|)
operator|*
name|pcountry
operator|=
name|country
expr_stmt|;
operator|*
name|prd2GHz
operator|=
name|rd2GHz
expr_stmt|;
operator|*
name|prd5GHz
operator|=
name|rd5GHz
expr_stmt|;
return|return
name|HAL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
modifier|*
name|getchannelBM
parameter_list|(
name|u_int
name|mode
parameter_list|,
name|REG_DOMAIN
modifier|*
name|rd
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|HAL_MODE_11B
case|:
return|return
operator|(
name|rd
operator|->
name|chan11b
operator|)
return|;
case|case
name|HAL_MODE_11G_QUARTER_RATE
case|:
return|return
operator|(
name|rd
operator|->
name|chan11g_quarter
operator|)
return|;
case|case
name|HAL_MODE_11G_HALF_RATE
case|:
return|return
operator|(
name|rd
operator|->
name|chan11g_half
operator|)
return|;
case|case
name|HAL_MODE_11G
case|:
case|case
name|HAL_MODE_11NG_HT20
case|:
case|case
name|HAL_MODE_11NG_HT40PLUS
case|:
case|case
name|HAL_MODE_11NG_HT40MINUS
case|:
return|return
operator|(
name|rd
operator|->
name|chan11g
operator|)
return|;
case|case
name|HAL_MODE_11G_TURBO
case|:
return|return
operator|(
name|rd
operator|->
name|chan11g_turbo
operator|)
return|;
case|case
name|HAL_MODE_11A_QUARTER_RATE
case|:
return|return
operator|(
name|rd
operator|->
name|chan11a_quarter
operator|)
return|;
case|case
name|HAL_MODE_11A_HALF_RATE
case|:
return|return
operator|(
name|rd
operator|->
name|chan11a_half
operator|)
return|;
case|case
name|HAL_MODE_11A
case|:
case|case
name|HAL_MODE_11NA_HT20
case|:
case|case
name|HAL_MODE_11NA_HT40PLUS
case|:
case|case
name|HAL_MODE_11NA_HT40MINUS
case|:
return|return
operator|(
name|rd
operator|->
name|chan11a
operator|)
return|;
case|case
name|HAL_MODE_TURBO
case|:
return|return
operator|(
name|rd
operator|->
name|chan11a_turbo
operator|)
return|;
case|case
name|HAL_MODE_11A_TURBO
case|:
return|return
operator|(
name|rd
operator|->
name|chan11a_dyn_turbo
operator|)
return|;
default|default:
return|return
operator|(
name|AH_NULL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|setchannelflags
parameter_list|(
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|,
name|REG_DMN_FREQ_BAND
modifier|*
name|fband
parameter_list|,
name|REG_DOMAIN
modifier|*
name|rd
parameter_list|)
block|{
if|if
condition|(
name|fband
operator|->
name|usePassScan
operator|&
name|rd
operator|->
name|pscan
condition|)
name|c
operator|->
name|ic_flags
operator||=
name|IEEE80211_CHAN_PASSIVE
expr_stmt|;
if|if
condition|(
name|fband
operator|->
name|useDfs
operator|&
name|rd
operator|->
name|dfsMask
condition|)
name|c
operator|->
name|ic_flags
operator||=
name|IEEE80211_CHAN_DFS
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|rd
operator|->
name|flags
operator|&
name|DISALLOW_ADHOC_11A
operator|)
condition|)
name|c
operator|->
name|ic_flags
operator||=
name|IEEE80211_CHAN_NOADHOC
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|rd
operator|->
name|flags
operator|&
name|DISALLOW_ADHOC_11A_TURB
operator|)
condition|)
name|c
operator|->
name|ic_flags
operator||=
name|IEEE80211_CHAN_NOADHOC
expr_stmt|;
if|if
condition|(
name|rd
operator|->
name|flags
operator|&
name|NO_HOSTAP
condition|)
name|c
operator|->
name|ic_flags
operator||=
name|IEEE80211_CHAN_NOHOSTAP
expr_stmt|;
if|if
condition|(
name|rd
operator|->
name|flags
operator|&
name|LIMIT_FRAME_4MS
condition|)
name|c
operator|->
name|ic_flags
operator||=
name|IEEE80211_CHAN_4MSXMIT
expr_stmt|;
if|if
condition|(
name|rd
operator|->
name|flags
operator|&
name|NEED_NFC
condition|)
name|c
operator|->
name|ic_flags
operator||=
name|CHANNEL_NFCREQUIRED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|addchan
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|u_int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|uint16_t
name|freq
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|REG_DMN_FREQ_BAND
modifier|*
name|fband
parameter_list|,
name|REG_DOMAIN
modifier|*
name|rd
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|nchans
operator|>=
name|maxchans
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|c
operator|=
operator|&
name|chans
index|[
operator|(
operator|*
name|nchans
operator|)
operator|++
index|]
expr_stmt|;
name|c
operator|->
name|ic_freq
operator|=
name|freq
expr_stmt|;
name|c
operator|->
name|ic_flags
operator|=
name|flags
expr_stmt|;
name|setchannelflags
argument_list|(
name|c
argument_list|,
name|fband
argument_list|,
name|rd
argument_list|)
expr_stmt|;
name|c
operator|->
name|ic_maxregpower
operator|=
name|fband
operator|->
name|powerDfs
expr_stmt|;
name|ath_hal_getpowerlimits
argument_list|(
name|ah
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|ic_maxantgain
operator|=
name|fband
operator|->
name|antennaMax
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|copychan_prev
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|u_int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|uint16_t
name|freq
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|KASSERT
argument_list|(
operator|*
name|nchans
operator|>
literal|0
argument_list|,
operator|(
literal|"channel list is empty\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|nchans
operator|>=
name|maxchans
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|c
operator|=
operator|&
name|chans
index|[
operator|(
operator|*
name|nchans
operator|)
operator|++
index|]
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|=
name|c
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|c
operator|->
name|ic_freq
operator|=
name|freq
expr_stmt|;
comment|/* XXX is it needed here? */
name|ath_hal_getpowerlimits
argument_list|(
name|ah
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_chanlist_band
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|uint16_t
name|freq_lo
parameter_list|,
name|uint16_t
name|freq_hi
parameter_list|,
name|int
name|step
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|REG_DMN_FREQ_BAND
modifier|*
name|fband
parameter_list|,
name|REG_DOMAIN
modifier|*
name|rd
parameter_list|)
block|{
name|uint16_t
name|freq
init|=
name|freq_lo
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|freq_hi
operator|<
name|freq_lo
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|addchan
argument_list|(
name|ah
argument_list|,
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|freq
argument_list|,
name|flags
argument_list|,
name|fband
argument_list|,
name|rd
argument_list|)
expr_stmt|;
for|for
control|(
name|freq
operator|+=
name|step
init|;
name|freq
operator|<=
name|freq_hi
operator|&&
name|error
operator|==
literal|0
condition|;
name|freq
operator|+=
name|step
control|)
name|error
operator|=
name|copychan_prev
argument_list|(
name|ah
argument_list|,
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|freq
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adj_freq_ht40
parameter_list|(
name|u_int
name|mode
parameter_list|,
name|int
modifier|*
name|low_adj
parameter_list|,
name|int
modifier|*
name|hi_adj
parameter_list|,
name|int
modifier|*
name|channelSep
parameter_list|)
block|{
operator|*
name|low_adj
operator|=
operator|*
name|hi_adj
operator|=
operator|*
name|channelSep
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|HAL_MODE_11NA_HT40PLUS
case|:
operator|*
name|channelSep
operator|=
literal|40
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|HAL_MODE_11NG_HT40PLUS
case|:
operator|*
name|hi_adj
operator|=
operator|-
literal|20
expr_stmt|;
break|break;
case|case
name|HAL_MODE_11NA_HT40MINUS
case|:
operator|*
name|channelSep
operator|=
literal|40
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|HAL_MODE_11NG_HT40MINUS
case|:
operator|*
name|low_adj
operator|=
literal|20
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_chanlist_mode
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|u_int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
specifier|const
name|struct
name|cmode
modifier|*
name|cm
parameter_list|,
name|REG_DOMAIN
modifier|*
name|rd
parameter_list|,
name|HAL_BOOL
name|enableExtendedChannels
parameter_list|)
block|{
name|uint64_t
modifier|*
name|channelBM
decl_stmt|;
name|uint16_t
name|freq_lo
decl_stmt|,
name|freq_hi
decl_stmt|;
name|int
name|b
decl_stmt|,
name|error
decl_stmt|,
name|low_adj
decl_stmt|,
name|hi_adj
decl_stmt|,
name|channelSep
decl_stmt|;
if|if
condition|(
operator|!
name|ath_hal_getChannelEdges
argument_list|(
name|ah
argument_list|,
name|cm
operator|->
name|flags
argument_list|,
operator|&
name|freq_lo
argument_list|,
operator|&
name|freq_hi
argument_list|)
condition|)
block|{
comment|/* channel not supported by hardware, skip it */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: channels 0x%x not supported by hardware\n"
argument_list|,
name|__func__
argument_list|,
name|cm
operator|->
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
name|channelBM
operator|=
name|getchannelBM
argument_list|(
name|cm
operator|->
name|mode
argument_list|,
name|rd
argument_list|)
expr_stmt|;
if|if
condition|(
name|isChanBitMaskZero
argument_list|(
name|channelBM
argument_list|)
condition|)
return|return;
comment|/* 	 * Setup special handling for HT40 channels; e.g. 	 * 5G HT40 channels require 40Mhz channel separation. 	 */
name|adj_freq_ht40
argument_list|(
name|cm
operator|->
name|mode
argument_list|,
operator|&
name|low_adj
argument_list|,
operator|&
name|hi_adj
argument_list|,
operator|&
name|channelSep
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
literal|64
operator|*
name|BMLEN
condition|;
name|b
operator|++
control|)
block|{
name|REG_DMN_FREQ_BAND
modifier|*
name|fband
decl_stmt|;
name|uint16_t
name|bfreq_lo
decl_stmt|,
name|bfreq_hi
decl_stmt|;
name|int
name|step
decl_stmt|;
if|if
condition|(
operator|!
name|IS_BIT_SET
argument_list|(
name|b
argument_list|,
name|channelBM
argument_list|)
condition|)
continue|continue;
name|fband
operator|=
operator|&
name|cm
operator|->
name|freqs
index|[
name|b
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fband
operator|->
name|usePassScan
operator|&
name|IS_ECM_CHAN
operator|)
operator|&&
operator|!
name|enableExtendedChannels
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"skip ecm channels\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
literal|0
block|if ((fband->useDfs& rd->dfsMask)&&  		    (cm->flags& IEEE80211_CHAN_HT40)) {
comment|/* NB: DFS and HT40 don't mix */
block|HALDEBUG(ah, HAL_DEBUG_REGDOMAIN, 			    "skip HT40 chan, DFS required\n"); 			continue; 		}
endif|#
directive|endif
name|bfreq_lo
operator|=
name|MAX
argument_list|(
name|fband
operator|->
name|lowChannel
operator|+
name|low_adj
argument_list|,
name|freq_lo
argument_list|)
expr_stmt|;
name|bfreq_hi
operator|=
name|MIN
argument_list|(
name|fband
operator|->
name|highChannel
operator|+
name|hi_adj
argument_list|,
name|freq_hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|fband
operator|->
name|channelSep
operator|>=
name|channelSep
condition|)
name|step
operator|=
name|fband
operator|->
name|channelSep
expr_stmt|;
else|else
name|step
operator|=
name|roundup
argument_list|(
name|channelSep
argument_list|,
name|fband
operator|->
name|channelSep
argument_list|)
expr_stmt|;
name|error
operator|=
name|add_chanlist_band
argument_list|(
name|ah
argument_list|,
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|bfreq_lo
argument_list|,
name|bfreq_hi
argument_list|,
name|step
argument_list|,
name|cm
operator|->
name|flags
argument_list|,
name|fband
argument_list|,
name|rd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: too many channels for channel table\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|u_int
name|getmodesmask
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|REG_DOMAIN
modifier|*
name|rd5GHz
parameter_list|,
name|u_int
name|modeSelect
parameter_list|)
block|{
define|#
directive|define
name|HAL_MODE_11A_ALL
define|\
value|(HAL_MODE_11A | HAL_MODE_11A_TURBO | HAL_MODE_TURBO | \ 	 HAL_MODE_11A_QUARTER_RATE | HAL_MODE_11A_HALF_RATE)
name|u_int
name|modesMask
decl_stmt|;
comment|/* get modes that HW is capable of */
name|modesMask
operator|=
name|ath_hal_getWirelessModes
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|modesMask
operator|&=
name|modeSelect
expr_stmt|;
comment|/* optimize work below if no 11a channels */
if|if
condition|(
name|isChanBitMaskZero
argument_list|(
name|rd5GHz
operator|->
name|chan11a
argument_list|)
operator|&&
operator|(
name|modesMask
operator|&
name|HAL_MODE_11A_ALL
operator|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: disallow all 11a\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|modesMask
operator|&=
operator|~
name|HAL_MODE_11A_ALL
expr_stmt|;
block|}
return|return
operator|(
name|modesMask
operator|)
return|;
undef|#
directive|undef
name|HAL_MODE_11A_ALL
block|}
end_function

begin_comment
comment|/*  * Construct the channel list for the specified regulatory config.  */
end_comment

begin_function
specifier|static
name|HAL_STATUS
name|getchannels
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|u_int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|u_int
name|modeSelect
parameter_list|,
name|HAL_CTRY_CODE
name|cc
parameter_list|,
name|HAL_REG_DOMAIN
name|regDmn
parameter_list|,
name|HAL_BOOL
name|enableExtendedChannels
parameter_list|,
name|COUNTRY_CODE_TO_ENUM_RD
modifier|*
modifier|*
name|pcountry
parameter_list|,
name|REG_DOMAIN
modifier|*
modifier|*
name|prd2GHz
parameter_list|,
name|REG_DOMAIN
modifier|*
modifier|*
name|prd5GHz
parameter_list|)
block|{
name|REG_DOMAIN
modifier|*
name|rd5GHz
decl_stmt|,
modifier|*
name|rd2GHz
decl_stmt|;
name|u_int
name|modesMask
decl_stmt|;
specifier|const
name|struct
name|cmode
modifier|*
name|cm
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: cc %u regDmn 0x%x mode 0x%x%s\n"
argument_list|,
name|__func__
argument_list|,
name|cc
argument_list|,
name|regDmn
argument_list|,
name|modeSelect
argument_list|,
name|enableExtendedChannels
condition|?
literal|" ecm"
else|:
literal|""
argument_list|)
expr_stmt|;
name|status
operator|=
name|getregstate
argument_list|(
name|ah
argument_list|,
name|cc
argument_list|,
name|regDmn
argument_list|,
name|pcountry
argument_list|,
operator|&
name|rd2GHz
argument_list|,
operator|&
name|rd5GHz
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|HAL_OK
condition|)
return|return
name|status
return|;
name|modesMask
operator|=
name|getmodesmask
argument_list|(
name|ah
argument_list|,
name|rd5GHz
argument_list|,
name|modeSelect
argument_list|)
expr_stmt|;
comment|/* XXX error? */
if|if
condition|(
name|modesMask
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
for|for
control|(
name|cm
operator|=
name|modes
init|;
name|cm
operator|<
operator|&
name|modes
index|[
name|N
argument_list|(
name|modes
argument_list|)
index|]
condition|;
name|cm
operator|++
control|)
block|{
name|REG_DOMAIN
modifier|*
name|rd
decl_stmt|;
if|if
condition|(
operator|(
name|cm
operator|->
name|mode
operator|&
name|modesMask
operator|)
operator|==
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: skip mode 0x%x flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|cm
operator|->
name|mode
argument_list|,
name|cm
operator|->
name|flags
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cm
operator|->
name|flags
operator|&
name|IEEE80211_CHAN_5GHZ
condition|)
name|rd
operator|=
name|rd5GHz
expr_stmt|;
elseif|else
if|if
condition|(
name|cm
operator|->
name|flags
operator|&
name|IEEE80211_CHAN_2GHZ
condition|)
name|rd
operator|=
name|rd2GHz
expr_stmt|;
else|else
block|{
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"%s: Unkonwn HAL flags 0x%x\n"
operator|,
name|__func__
operator|,
name|cm
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
return|return
name|HAL_EINVAL
return|;
block|}
name|add_chanlist_mode
argument_list|(
name|ah
argument_list|,
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|cm
argument_list|,
name|rd
argument_list|,
name|enableExtendedChannels
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|nchans
operator|>=
name|maxchans
condition|)
goto|goto
name|done
goto|;
block|}
name|done
label|:
comment|/* NB: pcountry set above by getregstate */
if|if
condition|(
name|prd2GHz
operator|!=
name|AH_NULL
condition|)
operator|*
name|prd2GHz
operator|=
name|rd2GHz
expr_stmt|;
if|if
condition|(
name|prd5GHz
operator|!=
name|AH_NULL
condition|)
operator|*
name|prd5GHz
operator|=
name|rd5GHz
expr_stmt|;
return|return
name|HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve a channel list without affecting runtime state.  */
end_comment

begin_function
name|HAL_STATUS
name|ath_hal_getchannels
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|u_int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|u_int
name|modeSelect
parameter_list|,
name|HAL_CTRY_CODE
name|cc
parameter_list|,
name|HAL_REG_DOMAIN
name|regDmn
parameter_list|,
name|HAL_BOOL
name|enableExtendedChannels
parameter_list|)
block|{
return|return
name|getchannels
argument_list|(
name|ah
argument_list|,
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|modeSelect
argument_list|,
name|cc
argument_list|,
name|regDmn
argument_list|,
name|enableExtendedChannels
argument_list|,
name|AH_NULL
argument_list|,
name|AH_NULL
argument_list|,
name|AH_NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle frequency mapping from 900Mhz range to 2.4GHz range  * for GSM radios.  This is done when we need the h/w frequency  * and the channel is marked IEEE80211_CHAN_GSM.  */
end_comment

begin_function
specifier|static
name|int
name|ath_hal_mapgsm
parameter_list|(
name|int
name|sku
parameter_list|,
name|int
name|freq
parameter_list|)
block|{
if|if
condition|(
name|sku
operator|==
name|SKU_XR9
condition|)
return|return
literal|1520
operator|+
name|freq
return|;
if|if
condition|(
name|sku
operator|==
name|SKU_GZ901
condition|)
return|return
literal|1544
operator|+
name|freq
return|;
if|if
condition|(
name|sku
operator|==
name|SKU_SR9
condition|)
return|return
literal|3344
operator|-
name|freq
return|;
if|if
condition|(
name|sku
operator|==
name|SKU_XC900M
condition|)
return|return
literal|1517
operator|+
name|freq
return|;
name|HALDEBUG
argument_list|(
name|AH_NULL
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: cannot map freq %u unknown gsm sku %u\n"
argument_list|,
name|__func__
argument_list|,
name|freq
argument_list|,
name|sku
argument_list|)
expr_stmt|;
return|return
name|freq
return|;
block|}
end_function

begin_comment
comment|/*  * Setup the internal/private channel state given a table of  * net80211 channels.  We collapse entries for the same frequency  * and record the frequency for doing noise floor processing  * where we don't have net80211 channel context.  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|assignPrivateChannels
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|int
name|nchans
parameter_list|,
name|int
name|sku
parameter_list|)
block|{
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ic
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|next
decl_stmt|,
name|freq
decl_stmt|;
name|next
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchans
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
operator|&
name|chans
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|chans
index|[
name|j
index|]
operator|.
name|ic_freq
operator|==
name|c
operator|->
name|ic_freq
condition|)
block|{
name|c
operator|->
name|ic_devdata
operator|=
name|chans
index|[
name|j
index|]
operator|.
name|ic_devdata
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
comment|/* new entry, assign a private channel entry */
if|if
condition|(
name|next
operator|>=
name|N
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_channels
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: too many channels, max %zu\n"
argument_list|,
name|__func__
argument_list|,
name|N
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_channels
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* 			 * Handle frequency mapping for 900MHz devices. 			 * The hardware uses 2.4GHz frequencies that are 			 * down-converted.  The 802.11 layer uses the 			 * true frequencies. 			 */
name|freq
operator|=
name|IEEE80211_IS_CHAN_GSM
argument_list|(
name|c
argument_list|)
condition|?
name|ath_hal_mapgsm
argument_list|(
name|sku
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|)
else|:
name|c
operator|->
name|ic_freq
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: private[%3u] %u/0x%x -> channel %u\n"
argument_list|,
name|__func__
argument_list|,
name|next
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|,
name|c
operator|->
name|ic_flags
argument_list|,
name|freq
argument_list|)
expr_stmt|;
name|ic
operator|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_channels
index|[
name|next
index|]
expr_stmt|;
comment|/* 			 * NB: This clears privFlags which means ancillary 			 *     code like ANI and IQ calibration will be 			 *     restarted and re-setup any per-channel state. 			 */
name|OS_MEMZERO
argument_list|(
name|ic
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ic
argument_list|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|channel
operator|=
name|freq
expr_stmt|;
name|c
operator|->
name|ic_devdata
operator|=
name|next
expr_stmt|;
name|next
operator|++
expr_stmt|;
block|}
block|}
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_nchan
operator|=
name|next
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: %u public, %u private channels\n"
argument_list|,
name|__func__
argument_list|,
name|nchans
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Setup the channel list based on the information in the EEPROM.  */
end_comment

begin_function
name|HAL_STATUS
name|ath_hal_init_channels
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|u_int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|u_int
name|modeSelect
parameter_list|,
name|HAL_CTRY_CODE
name|cc
parameter_list|,
name|HAL_REG_DOMAIN
name|regDmn
parameter_list|,
name|HAL_BOOL
name|enableExtendedChannels
parameter_list|)
block|{
name|COUNTRY_CODE_TO_ENUM_RD
modifier|*
name|country
decl_stmt|;
name|REG_DOMAIN
modifier|*
name|rd5GHz
decl_stmt|,
modifier|*
name|rd2GHz
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|status
operator|=
name|getchannels
argument_list|(
name|ah
argument_list|,
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|modeSelect
argument_list|,
name|cc
argument_list|,
name|regDmn
argument_list|,
name|enableExtendedChannels
argument_list|,
operator|&
name|country
argument_list|,
operator|&
name|rd2GHz
argument_list|,
operator|&
name|rd5GHz
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|HAL_OK
operator|&&
name|assignPrivateChannels
argument_list|(
name|ah
argument_list|,
name|chans
argument_list|,
operator|*
name|nchans
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_currentRD
argument_list|)
condition|)
block|{
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rd2GHz
operator|=
name|rd2GHz
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rd5GHz
operator|=
name|rd5GHz
expr_stmt|;
name|ah
operator|->
name|ah_countryCode
operator|=
name|country
operator|->
name|countryCode
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: cc %u\n"
argument_list|,
name|__func__
argument_list|,
name|ah
operator|->
name|ah_countryCode
argument_list|)
expr_stmt|;
comment|/* Update current DFS domain */
name|ath_hal_update_dfsdomain
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
else|else
name|status
operator|=
name|HAL_EINVAL
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Set the channel list.  */
end_comment

begin_function
name|HAL_STATUS
name|ath_hal_set_channels
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|int
name|nchans
parameter_list|,
name|HAL_CTRY_CODE
name|cc
parameter_list|,
name|HAL_REG_DOMAIN
name|rd
parameter_list|)
block|{
name|COUNTRY_CODE_TO_ENUM_RD
modifier|*
name|country
decl_stmt|;
name|REG_DOMAIN
modifier|*
name|rd5GHz
decl_stmt|,
modifier|*
name|rd2GHz
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
switch|switch
condition|(
name|rd
condition|)
block|{
case|case
name|SKU_SR9
case|:
case|case
name|SKU_XR9
case|:
case|case
name|SKU_GZ901
case|:
case|case
name|SKU_XC900M
case|:
comment|/* 		 * Map 900MHz sku's.  The frequencies will be mapped 		 * according to the sku to compensate for the down-converter. 		 * We use the FCC for these sku's as the mapped channel 		 * list is known compatible (will need to change if/when 		 * vendors do different mapping in different locales). 		 */
name|status
operator|=
name|getregstate
argument_list|(
name|ah
argument_list|,
name|CTRY_DEFAULT
argument_list|,
name|SKU_FCC
argument_list|,
operator|&
name|country
argument_list|,
operator|&
name|rd2GHz
argument_list|,
operator|&
name|rd5GHz
argument_list|)
expr_stmt|;
break|break;
default|default:
name|status
operator|=
name|getregstate
argument_list|(
name|ah
argument_list|,
name|cc
argument_list|,
name|rd
argument_list|,
operator|&
name|country
argument_list|,
operator|&
name|rd2GHz
argument_list|,
operator|&
name|rd5GHz
argument_list|)
expr_stmt|;
name|rd
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_currentRD
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|status
operator|==
name|HAL_OK
operator|&&
name|assignPrivateChannels
argument_list|(
name|ah
argument_list|,
name|chans
argument_list|,
name|nchans
argument_list|,
name|rd
argument_list|)
condition|)
block|{
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rd2GHz
operator|=
name|rd2GHz
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rd5GHz
operator|=
name|rd5GHz
expr_stmt|;
name|ah
operator|->
name|ah_countryCode
operator|=
name|country
operator|->
name|countryCode
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: cc %u\n"
argument_list|,
name|__func__
argument_list|,
name|ah
operator|->
name|ah_countryCode
argument_list|)
expr_stmt|;
block|}
else|else
name|status
operator|=
name|HAL_EINVAL
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|HAL_OK
condition|)
block|{
comment|/* Update current DFS domain */
operator|(
name|void
operator|)
name|ath_hal_update_dfsdomain
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AH_DEBUG
end_ifdef

begin_comment
comment|/*  * Return the internal channel corresponding to a public channel.  * NB: normally this routine is inline'd (see ah_internal.h)  */
end_comment

begin_function
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ath_hal_checkchannel
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
name|HAL_CHANNEL_INTERNAL
modifier|*
name|cc
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_channels
index|[
name|c
operator|->
name|ic_devdata
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|ic_devdata
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_nchan
operator|&&
operator|(
name|c
operator|->
name|ic_freq
operator|==
name|cc
operator|->
name|channel
operator|||
name|IEEE80211_IS_CHAN_GSM
argument_list|(
name|c
argument_list|)
operator|)
condition|)
return|return
name|cc
return|;
if|if
condition|(
name|c
operator|->
name|ic_devdata
operator|>=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_nchan
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: bad mapping, devdata %u nchans %u\n"
argument_list|,
name|__func__
argument_list|,
name|c
operator|->
name|ic_devdata
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_nchan
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|c
operator|->
name|ic_devdata
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_nchan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: no match for %u/0x%x devdata %u channel %u\n"
argument_list|,
name|__func__
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|,
name|c
operator|->
name|ic_flags
argument_list|,
name|c
operator|->
name|ic_devdata
argument_list|,
name|cc
operator|->
name|channel
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|c
operator|->
name|ic_freq
operator|==
name|cc
operator|->
name|channel
operator|||
name|IEEE80211_IS_CHAN_GSM
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|AH_NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AH_DEBUG */
end_comment

begin_define
define|#
directive|define
name|isWwrSKU
parameter_list|(
name|_ah
parameter_list|)
define|\
value|((getEepromRD((_ah))& WORLD_SKU_MASK) == WORLD_SKU_PREFIX || \ 	  getEepromRD(_ah) == WORLD)
end_define

begin_comment
comment|/*  * Return the test group for the specific channel based on  * the current regulatory setup.  */
end_comment

begin_function
name|u_int
name|ath_hal_getctl
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
name|u_int
name|ctl
decl_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rd2GHz
operator|==
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rd5GHz
operator|||
operator|(
name|ah
operator|->
name|ah_countryCode
operator|==
name|CTRY_DEFAULT
operator|&&
name|isWwrSKU
argument_list|(
name|ah
argument_list|)
operator|)
condition|)
name|ctl
operator|=
name|SD_NO_CTL
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|c
argument_list|)
condition|)
name|ctl
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rd2GHz
operator|->
name|conformanceTestLimit
expr_stmt|;
else|else
name|ctl
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rd5GHz
operator|->
name|conformanceTestLimit
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|ctl
operator||
name|CTL_11B
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_G
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|ctl
operator||
name|CTL_11G
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_108G
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|ctl
operator||
name|CTL_108G
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|ctl
operator||
name|CTL_TURBO
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|ctl
operator||
name|CTL_11A
return|;
return|return
name|ctl
return|;
block|}
end_function

begin_comment
comment|/*  * Update the current dfsDomain setting based on the given  * country code.  *  * Since FreeBSD/net80211 allows the channel set to change  * after the card has been setup (via ath_hal_init_channels())  * this function method is needed to update ah_dfsDomain.  */
end_comment

begin_function
name|void
name|ath_hal_update_dfsdomain
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
specifier|const
name|REG_DOMAIN
modifier|*
name|rd5GHz
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rd5GHz
decl_stmt|;
name|HAL_DFS_DOMAIN
name|dfsDomain
init|=
name|HAL_DFS_UNINIT_DOMAIN
decl_stmt|;
if|if
condition|(
name|rd5GHz
operator|->
name|dfsMask
operator|&
name|DFS_FCC3
condition|)
name|dfsDomain
operator|=
name|HAL_DFS_FCC_DOMAIN
expr_stmt|;
if|if
condition|(
name|rd5GHz
operator|->
name|dfsMask
operator|&
name|DFS_ETSI
condition|)
name|dfsDomain
operator|=
name|HAL_DFS_ETSI_DOMAIN
expr_stmt|;
if|if
condition|(
name|rd5GHz
operator|->
name|dfsMask
operator|&
name|DFS_MKK4
condition|)
name|dfsDomain
operator|=
name|HAL_DFS_MKK4_DOMAIN
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_dfsDomain
operator|=
name|dfsDomain
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGDOMAIN
argument_list|,
literal|"%s ah_dfsDomain: %d\n"
argument_list|,
name|__func__
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_dfsDomain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the max allowed antenna gain and apply any regulatory  * domain specific changes.  *  * NOTE: a negative reduction is possible in RD's that only  * measure radiated power (e.g., ETSI) which would increase  * that actual conducted output power (though never beyond  * the calibrated target power).  */
end_comment

begin_function
name|u_int
name|ath_hal_getantennareduction
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|u_int
name|twiceGain
parameter_list|)
block|{
name|int8_t
name|antennaMax
init|=
name|twiceGain
operator|-
name|chan
operator|->
name|ic_maxantgain
operator|*
literal|2
decl_stmt|;
return|return
operator|(
name|antennaMax
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|antennaMax
return|;
block|}
end_function

end_unit

