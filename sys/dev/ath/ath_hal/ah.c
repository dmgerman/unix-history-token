begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2002-2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_devid.h"
end_include

begin_comment
comment|/* linker set of registered chips */
end_comment

begin_expr_stmt
name|OS_SET_DECLARE
argument_list|(
name|ah_chips
argument_list|,
expr|struct
name|ath_hal_chip
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Check the set of registered chips to see if any recognize  * the device as one they can support.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ath_hal_probe
parameter_list|(
name|uint16_t
name|vendorid
parameter_list|,
name|uint16_t
name|devid
parameter_list|)
block|{
name|struct
name|ath_hal_chip
modifier|*
specifier|const
modifier|*
name|pchip
decl_stmt|;
name|OS_SET_FOREACH
argument_list|(
argument|pchip
argument_list|,
argument|ah_chips
argument_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
operator|(
operator|*
name|pchip
operator|)
operator|->
name|probe
argument_list|(
name|vendorid
argument_list|,
name|devid
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|AH_NULL
condition|)
return|return
name|name
return|;
block|}
return|return
name|AH_NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Attach detects device chip revisions, initializes the hwLayer  * function list, reads EEPROM information,  * selects reset vectors, and performs a short self test.  * Any failures will return an error that should cause a hardware  * disable.  */
end_comment

begin_function
name|struct
name|ath_hal
modifier|*
name|ath_hal_attach
parameter_list|(
name|uint16_t
name|devid
parameter_list|,
name|HAL_SOFTC
name|sc
parameter_list|,
name|HAL_BUS_TAG
name|st
parameter_list|,
name|HAL_BUS_HANDLE
name|sh
parameter_list|,
name|HAL_STATUS
modifier|*
name|error
parameter_list|)
block|{
name|struct
name|ath_hal_chip
modifier|*
specifier|const
modifier|*
name|pchip
decl_stmt|;
name|OS_SET_FOREACH
argument_list|(
argument|pchip
argument_list|,
argument|ah_chips
argument_list|)
block|{
name|struct
name|ath_hal_chip
modifier|*
name|chip
init|=
operator|*
name|pchip
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
decl_stmt|;
comment|/* XXX don't have vendorid, assume atheros one works */
if|if
condition|(
name|chip
operator|->
name|probe
argument_list|(
name|ATHEROS_VENDOR_ID
argument_list|,
name|devid
argument_list|)
operator|==
name|AH_NULL
condition|)
continue|continue;
name|ah
operator|=
name|chip
operator|->
name|attach
argument_list|(
name|devid
argument_list|,
name|sc
argument_list|,
name|st
argument_list|,
name|sh
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ah
operator|!=
name|AH_NULL
condition|)
block|{
comment|/* copy back private state to public area */
name|ah
operator|->
name|ah_devid
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_devid
expr_stmt|;
name|ah
operator|->
name|ah_subvendorid
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_subvendorid
expr_stmt|;
name|ah
operator|->
name|ah_macVersion
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
expr_stmt|;
name|ah
operator|->
name|ah_macRev
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macRev
expr_stmt|;
name|ah
operator|->
name|ah_phyRev
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyRev
expr_stmt|;
name|ah
operator|->
name|ah_analog5GhzRev
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
expr_stmt|;
name|ah
operator|->
name|ah_analog2GhzRev
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog2GhzRev
expr_stmt|;
return|return
name|ah
return|;
block|}
block|}
return|return
name|AH_NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Return the mask of available modes based on the hardware capabilities.  */
end_comment

begin_function
name|u_int
name|ath_hal_getwirelessmodes
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|ath_hal_getWirelessModes
argument_list|(
name|ah
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* linker set of registered RF backends */
end_comment

begin_expr_stmt
name|OS_SET_DECLARE
argument_list|(
name|ah_rfs
argument_list|,
expr|struct
name|ath_hal_rf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Check the set of registered RF backends to see if  * any recognize the device as one they can support.  */
end_comment

begin_function
name|struct
name|ath_hal_rf
modifier|*
name|ath_hal_rfprobe
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_STATUS
modifier|*
name|ecode
parameter_list|)
block|{
name|struct
name|ath_hal_rf
modifier|*
specifier|const
modifier|*
name|prf
decl_stmt|;
name|OS_SET_FOREACH
argument_list|(
argument|prf
argument_list|,
argument|ah_rfs
argument_list|)
block|{
name|struct
name|ath_hal_rf
modifier|*
name|rf
init|=
operator|*
name|prf
decl_stmt|;
if|if
condition|(
name|rf
operator|->
name|probe
argument_list|(
name|ah
argument_list|)
condition|)
return|return
name|rf
return|;
block|}
operator|*
name|ecode
operator|=
name|HAL_ENOTSUPP
expr_stmt|;
return|return
name|AH_NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Poll the register looking for a specific value.  */
end_comment

begin_function
name|HAL_BOOL
name|ath_hal_wait
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|uint32_t
name|mask
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
define|#
directive|define
name|AH_TIMEOUT
value|1000
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AH_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|reg
argument_list|)
operator|&
name|mask
operator|)
operator|==
name|val
condition|)
return|return
name|AH_TRUE
return|;
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGIO
operator||
name|HAL_DEBUG_PHYIO
argument_list|,
literal|"%s: timeout on reg 0x%x: 0x%08x& 0x%08x != 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|reg
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|reg
argument_list|)
argument_list|,
name|mask
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
undef|#
directive|undef
name|AH_TIMEOUT
block|}
end_function

begin_comment
comment|/*  * Reverse the bits starting at the low bit for a value of  * bit_count in size  */
end_comment

begin_function
name|uint32_t
name|ath_hal_reverseBits
parameter_list|(
name|uint32_t
name|val
parameter_list|,
name|uint32_t
name|n
parameter_list|)
block|{
name|uint32_t
name|retval
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|retval
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|retval
operator|=
operator|(
name|retval
operator|<<
literal|1
operator|)
operator||
operator|(
name|val
operator|&
literal|1
operator|)
expr_stmt|;
name|val
operator|>>=
literal|1
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the time to transmit a frame of length frameLen bytes  * using the specified rate, phy, and short preamble setting.  */
end_comment

begin_function
name|uint16_t
name|ath_hal_computetxtime
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rates
parameter_list|,
name|uint32_t
name|frameLen
parameter_list|,
name|uint16_t
name|rateix
parameter_list|,
name|HAL_BOOL
name|shortPreamble
parameter_list|)
block|{
name|uint32_t
name|bitsPerSymbol
decl_stmt|,
name|numBits
decl_stmt|,
name|numSymbols
decl_stmt|,
name|phyTime
decl_stmt|,
name|txTime
decl_stmt|;
name|uint32_t
name|kbps
decl_stmt|;
name|kbps
operator|=
name|rates
operator|->
name|info
index|[
name|rateix
index|]
operator|.
name|rateKbps
expr_stmt|;
comment|/* 	 * index can be invalid duting dynamic Turbo transitions.  	 * XXX 	 */
if|if
condition|(
name|kbps
operator|==
literal|0
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|rates
operator|->
name|info
index|[
name|rateix
index|]
operator|.
name|phy
condition|)
block|{
case|case
name|IEEE80211_T_CCK
case|:
name|phyTime
operator|=
name|CCK_PREAMBLE_BITS
operator|+
name|CCK_PLCP_BITS
expr_stmt|;
if|if
condition|(
name|shortPreamble
operator|&&
name|rates
operator|->
name|info
index|[
name|rateix
index|]
operator|.
name|shortPreamble
condition|)
name|phyTime
operator|>>=
literal|1
expr_stmt|;
name|numBits
operator|=
name|frameLen
operator|<<
literal|3
expr_stmt|;
name|txTime
operator|=
name|CCK_SIFS_TIME
operator|+
name|phyTime
operator|+
operator|(
operator|(
name|numBits
operator|*
literal|1000
operator|)
operator|/
name|kbps
operator|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_T_OFDM
case|:
name|bitsPerSymbol
operator|=
operator|(
name|kbps
operator|*
name|OFDM_SYMBOL_TIME
operator|)
operator|/
literal|1000
expr_stmt|;
name|HALASSERT
argument_list|(
name|bitsPerSymbol
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|numBits
operator|=
name|OFDM_PLCP_BITS
operator|+
operator|(
name|frameLen
operator|<<
literal|3
operator|)
expr_stmt|;
name|numSymbols
operator|=
name|howmany
argument_list|(
name|numBits
argument_list|,
name|bitsPerSymbol
argument_list|)
expr_stmt|;
name|txTime
operator|=
name|OFDM_SIFS_TIME
operator|+
name|OFDM_PREAMBLE_TIME
operator|+
operator|(
name|numSymbols
operator|*
name|OFDM_SYMBOL_TIME
operator|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_T_OFDM_HALF
case|:
name|bitsPerSymbol
operator|=
operator|(
name|kbps
operator|*
name|OFDM_HALF_SYMBOL_TIME
operator|)
operator|/
literal|1000
expr_stmt|;
name|HALASSERT
argument_list|(
name|bitsPerSymbol
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|numBits
operator|=
name|OFDM_HALF_PLCP_BITS
operator|+
operator|(
name|frameLen
operator|<<
literal|3
operator|)
expr_stmt|;
name|numSymbols
operator|=
name|howmany
argument_list|(
name|numBits
argument_list|,
name|bitsPerSymbol
argument_list|)
expr_stmt|;
name|txTime
operator|=
name|OFDM_HALF_SIFS_TIME
operator|+
name|OFDM_HALF_PREAMBLE_TIME
operator|+
operator|(
name|numSymbols
operator|*
name|OFDM_HALF_SYMBOL_TIME
operator|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_T_OFDM_QUARTER
case|:
name|bitsPerSymbol
operator|=
operator|(
name|kbps
operator|*
name|OFDM_QUARTER_SYMBOL_TIME
operator|)
operator|/
literal|1000
expr_stmt|;
name|HALASSERT
argument_list|(
name|bitsPerSymbol
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|numBits
operator|=
name|OFDM_QUARTER_PLCP_BITS
operator|+
operator|(
name|frameLen
operator|<<
literal|3
operator|)
expr_stmt|;
name|numSymbols
operator|=
name|howmany
argument_list|(
name|numBits
argument_list|,
name|bitsPerSymbol
argument_list|)
expr_stmt|;
name|txTime
operator|=
name|OFDM_QUARTER_SIFS_TIME
operator|+
name|OFDM_QUARTER_PREAMBLE_TIME
operator|+
operator|(
name|numSymbols
operator|*
name|OFDM_QUARTER_SYMBOL_TIME
operator|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_T_TURBO
case|:
comment|/* we still save OFDM rates in kbps - so double them */
name|bitsPerSymbol
operator|=
operator|(
operator|(
name|kbps
operator|<<
literal|1
operator|)
operator|*
name|TURBO_SYMBOL_TIME
operator|)
operator|/
literal|1000
expr_stmt|;
name|HALASSERT
argument_list|(
name|bitsPerSymbol
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|numBits
operator|=
name|TURBO_PLCP_BITS
operator|+
operator|(
name|frameLen
operator|<<
literal|3
operator|)
expr_stmt|;
name|numSymbols
operator|=
name|howmany
argument_list|(
name|numBits
argument_list|,
name|bitsPerSymbol
argument_list|)
expr_stmt|;
name|txTime
operator|=
name|TURBO_SIFS_TIME
operator|+
name|TURBO_PREAMBLE_TIME
operator|+
operator|(
name|numSymbols
operator|*
name|TURBO_SYMBOL_TIME
operator|)
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PHYIO
argument_list|,
literal|"%s: unknown phy %u (rate ix %u)\n"
argument_list|,
name|__func__
argument_list|,
name|rates
operator|->
name|info
index|[
name|rateix
index|]
operator|.
name|phy
argument_list|,
name|rateix
argument_list|)
expr_stmt|;
name|txTime
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|txTime
return|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
block|{
name|WIRELESS_MODE_11a
init|=
literal|0
block|,
name|WIRELESS_MODE_TURBO
init|=
literal|1
block|,
name|WIRELESS_MODE_11b
init|=
literal|2
block|,
name|WIRELESS_MODE_11g
init|=
literal|3
block|,
name|WIRELESS_MODE_108g
init|=
literal|4
block|,
name|WIRELESS_MODE_MAX
block|}
name|WIRELESS_MODE
typedef|;
end_typedef

begin_function
specifier|static
name|WIRELESS_MODE
name|ath_hal_chan2wmode
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|WIRELESS_MODE_11b
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_G
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|WIRELESS_MODE_11g
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_108G
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|WIRELESS_MODE_108g
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|WIRELESS_MODE_TURBO
return|;
return|return
name|WIRELESS_MODE_11a
return|;
block|}
end_function

begin_comment
comment|/*  * Convert between microseconds and core system clocks.  */
end_comment

begin_comment
comment|/* 11a Turbo  11b  11g  108g */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|CLOCK_RATE
index|[]
init|=
block|{
literal|40
block|,
literal|80
block|,
literal|22
block|,
literal|44
block|,
literal|88
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|u_int
name|ath_hal_mac_clks
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|usecs
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
decl_stmt|;
name|u_int
name|clks
decl_stmt|;
comment|/* NB: ah_curchan may be null when called attach time */
if|if
condition|(
name|c
operator|!=
name|AH_NULL
condition|)
block|{
name|clks
operator|=
name|usecs
operator|*
name|CLOCK_RATE
index|[
name|ath_hal_chan2wmode
argument_list|(
name|ah
argument_list|,
name|c
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|c
argument_list|)
condition|)
name|clks
operator|<<=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|c
argument_list|)
condition|)
name|clks
operator|>>=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|c
argument_list|)
condition|)
name|clks
operator|>>=
literal|2
expr_stmt|;
block|}
else|else
name|clks
operator|=
name|usecs
operator|*
name|CLOCK_RATE
index|[
name|WIRELESS_MODE_11b
index|]
expr_stmt|;
return|return
name|clks
return|;
block|}
end_function

begin_function
name|u_int
name|ath_hal_mac_usec
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|clks
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
decl_stmt|;
name|u_int
name|usec
decl_stmt|;
comment|/* NB: ah_curchan may be null when called attach time */
if|if
condition|(
name|c
operator|!=
name|AH_NULL
condition|)
block|{
name|usec
operator|=
name|clks
operator|/
name|CLOCK_RATE
index|[
name|ath_hal_chan2wmode
argument_list|(
name|ah
argument_list|,
name|c
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|c
argument_list|)
condition|)
name|usec
operator|>>=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|c
argument_list|)
condition|)
name|usec
operator|<<=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|c
argument_list|)
condition|)
name|usec
operator|<<=
literal|2
expr_stmt|;
block|}
else|else
name|usec
operator|=
name|clks
operator|/
name|CLOCK_RATE
index|[
name|WIRELESS_MODE_11b
index|]
expr_stmt|;
return|return
name|usec
return|;
block|}
end_function

begin_comment
comment|/*  * Setup a h/w rate table's reverse lookup table and  * fill in ack durations.  This routine is called for  * each rate table returned through the ah_getRateTable  * method.  The reverse lookup tables are assumed to be  * initialized to zero (or at least the first entry).  * We use this as a key that indicates whether or not  * we've previously setup the reverse lookup table.  *  * XXX not reentrant, but shouldn't matter  */
end_comment

begin_function
name|void
name|ath_hal_setupratetable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_RATE_TABLE
modifier|*
name|rt
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|int
name|i
decl_stmt|;
if|if
condition|(
name|rt
operator|->
name|rateCodeToIndex
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
comment|/* already setup */
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|rt
operator|->
name|rateCodeToIndex
argument_list|)
condition|;
name|i
operator|++
control|)
name|rt
operator|->
name|rateCodeToIndex
index|[
name|i
index|]
operator|=
operator|(
name|uint8_t
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rt
operator|->
name|rateCount
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
name|code
init|=
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|rateCode
decl_stmt|;
name|uint8_t
name|cix
init|=
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|controlRate
decl_stmt|;
name|HALASSERT
argument_list|(
name|code
operator|<
name|N
argument_list|(
name|rt
operator|->
name|rateCodeToIndex
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rateCodeToIndex
index|[
name|code
index|]
operator|=
name|i
expr_stmt|;
name|HALASSERT
argument_list|(
operator|(
name|code
operator||
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|shortPreamble
operator|)
operator|<
name|N
argument_list|(
name|rt
operator|->
name|rateCodeToIndex
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rateCodeToIndex
index|[
name|code
operator||
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|shortPreamble
index|]
operator|=
name|i
expr_stmt|;
comment|/* 		 * XXX for 11g the control rate to use for 5.5 and 11 Mb/s 		 *     depends on whether they are marked as basic rates; 		 *     the static tables are setup with an 11b-compatible 		 *     2Mb/s rate which will work but is suboptimal 		 */
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|lpAckDuration
operator|=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|WLAN_CTRL_FRAME_SIZE
argument_list|,
name|cix
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|spAckDuration
operator|=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|WLAN_CTRL_FRAME_SIZE
argument_list|,
name|cix
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|N
block|}
end_function

begin_function
name|HAL_STATUS
name|ath_hal_getcapability
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CAPABILITY_TYPE
name|type
parameter_list|,
name|uint32_t
name|capability
parameter_list|,
name|uint32_t
modifier|*
name|result
parameter_list|)
block|{
specifier|const
name|HAL_CAPABILITIES
modifier|*
name|pCap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|HAL_CAP_REG_DMN
case|:
comment|/* regulatory domain */
operator|*
name|result
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_currentRD
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_CIPHER
case|:
comment|/* cipher handled in hardware */
case|case
name|HAL_CAP_TKIP_MIC
case|:
comment|/* handle TKIP MIC in hardware */
return|return
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_TKIP_SPLIT
case|:
comment|/* hardware TKIP uses split keys */
return|return
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_PHYCOUNTERS
case|:
comment|/* hardware PHY error counters */
return|return
name|pCap
operator|->
name|halHwPhyCounterSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENXIO
return|;
case|case
name|HAL_CAP_WME_TKIPMIC
case|:
comment|/* hardware can do TKIP MIC when WMM is turned on */
return|return
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_DIVERSITY
case|:
comment|/* hardware supports fast diversity */
return|return
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_KEYCACHE_SIZE
case|:
comment|/* hardware key cache size */
operator|*
name|result
operator|=
name|pCap
operator|->
name|halKeyCacheSize
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_NUM_TXQUEUES
case|:
comment|/* number of hardware tx queues */
operator|*
name|result
operator|=
name|pCap
operator|->
name|halTotalQueues
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_VEOL
case|:
comment|/* hardware supports virtual EOL */
return|return
name|pCap
operator|->
name|halVEOLSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_PSPOLL
case|:
comment|/* hardware PS-Poll support works */
return|return
name|pCap
operator|->
name|halPSPollBroken
condition|?
name|HAL_ENOTSUPP
else|:
name|HAL_OK
return|;
case|case
name|HAL_CAP_COMPRESSION
case|:
return|return
name|pCap
operator|->
name|halCompressSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_BURST
case|:
return|return
name|pCap
operator|->
name|halBurstSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_FASTFRAME
case|:
return|return
name|pCap
operator|->
name|halFastFramesSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_DIAG
case|:
comment|/* hardware diagnostic support */
operator|*
name|result
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diagreg
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_TXPOW
case|:
comment|/* global tx power limit  */
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
literal|0
case|:
comment|/* facility is supported */
return|return
name|HAL_OK
return|;
case|case
literal|1
case|:
comment|/* current limit */
operator|*
name|result
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_powerLimit
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
literal|2
case|:
comment|/* current max tx power */
operator|*
name|result
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_maxPowerLevel
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
literal|3
case|:
comment|/* scale factor */
operator|*
name|result
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tpScale
expr_stmt|;
return|return
name|HAL_OK
return|;
block|}
return|return
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_BSSIDMASK
case|:
comment|/* hardware supports bssid mask */
return|return
name|pCap
operator|->
name|halBssIdMaskSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_MCAST_KEYSRCH
case|:
comment|/* multicast frame keycache search */
return|return
name|pCap
operator|->
name|halMcastKeySrchSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_TSF_ADJUST
case|:
comment|/* hardware has beacon tsf adjust */
return|return
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_RFSILENT
case|:
comment|/* rfsilent support  */
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
literal|0
case|:
comment|/* facility is supported */
return|return
name|pCap
operator|->
name|halRfSilentSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
literal|1
case|:
comment|/* current setting */
return|return
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rfkillEnabled
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
literal|2
case|:
comment|/* rfsilent config */
operator|*
name|result
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rfsilent
expr_stmt|;
return|return
name|HAL_OK
return|;
block|}
return|return
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_11D
case|:
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_RXORN_FATAL
case|:
comment|/* HAL_INT_RXORN treated as fatal  */
return|return
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rxornIsFatal
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_HT
case|:
return|return
name|pCap
operator|->
name|halHTSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_TX_CHAINMASK
case|:
comment|/* mask of TX chains supported */
operator|*
name|result
operator|=
name|pCap
operator|->
name|halTxChainMask
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_RX_CHAINMASK
case|:
comment|/* mask of RX chains supported */
operator|*
name|result
operator|=
name|pCap
operator|->
name|halRxChainMask
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_RXTSTAMP_PREC
case|:
comment|/* rx desc tstamp precision (bits) */
operator|*
name|result
operator|=
name|pCap
operator|->
name|halTstampPrecision
expr_stmt|;
return|return
name|HAL_OK
return|;
default|default:
return|return
name|HAL_EINVAL
return|;
block|}
block|}
end_function

begin_function
name|HAL_BOOL
name|ath_hal_setcapability
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CAPABILITY_TYPE
name|type
parameter_list|,
name|uint32_t
name|capability
parameter_list|,
name|uint32_t
name|setting
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|HAL_CAP_TXPOW
case|:
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|setting
operator|<=
name|HAL_TP_SCALE_MIN
condition|)
block|{
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tpScale
operator|=
name|setting
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
break|break;
block|}
break|break;
case|case
name|HAL_CAP_RFSILENT
case|:
comment|/* rfsilent support  */
comment|/* 		 * NB: allow even if halRfSilentSupport is false 		 *     in case the EEPROM is misprogrammed. 		 */
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
literal|1
case|:
comment|/* current setting */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rfkillEnabled
operator|=
operator|(
name|setting
operator|!=
literal|0
operator|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
literal|2
case|:
comment|/* rfsilent config */
comment|/* XXX better done per-chip for validation? */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rfsilent
operator|=
name|setting
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
break|break;
case|case
name|HAL_CAP_REG_DMN
case|:
comment|/* regulatory domain */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_currentRD
operator|=
name|setting
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_CAP_RXORN_FATAL
case|:
comment|/* HAL_INT_RXORN treated as fatal  */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rxornIsFatal
operator|=
name|setting
expr_stmt|;
return|return
name|AH_TRUE
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|status
condition|)
operator|*
name|status
operator|=
name|HAL_EINVAL
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/*   * Common support for getDiagState method.  */
end_comment

begin_function
specifier|static
name|u_int
name|ath_hal_getregdump
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_REGRANGE
modifier|*
name|regs
parameter_list|,
name|void
modifier|*
name|dstbuf
parameter_list|,
name|int
name|space
parameter_list|)
block|{
name|uint32_t
modifier|*
name|dp
init|=
name|dstbuf
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|space
operator|>=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|u_int
name|r
init|=
name|regs
index|[
name|i
index|]
operator|.
name|start
decl_stmt|;
name|u_int
name|e
init|=
name|regs
index|[
name|i
index|]
operator|.
name|end
decl_stmt|;
operator|*
name|dp
operator|++
operator|=
operator|(
name|r
operator|<<
literal|16
operator|)
operator||
name|e
expr_stmt|;
name|space
operator|-=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
do|do
block|{
operator|*
name|dp
operator|++
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|r
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|space
operator|-=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|r
operator|<=
name|e
operator|&&
name|space
operator|>=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
do|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|dp
operator|-
operator|(
name|char
operator|*
operator|)
name|dstbuf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_hal_setregs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_REGWRITE
modifier|*
name|regs
parameter_list|,
name|int
name|space
parameter_list|)
block|{
while|while
condition|(
name|space
operator|>=
sizeof|sizeof
argument_list|(
name|HAL_REGWRITE
argument_list|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|regs
operator|->
name|addr
argument_list|,
name|regs
operator|->
name|value
argument_list|)
expr_stmt|;
name|regs
operator|++
operator|,
name|space
operator|-=
sizeof|sizeof
argument_list|(
name|HAL_REGWRITE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|HAL_BOOL
name|ath_hal_getdiagstate
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|request
parameter_list|,
specifier|const
name|void
modifier|*
name|args
parameter_list|,
name|uint32_t
name|argsize
parameter_list|,
name|void
modifier|*
modifier|*
name|result
parameter_list|,
name|uint32_t
modifier|*
name|resultsize
parameter_list|)
block|{
switch|switch
condition|(
name|request
condition|)
block|{
case|case
name|HAL_DIAG_REVS
case|:
operator|*
name|result
operator|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_devid
expr_stmt|;
operator|*
name|resultsize
operator|=
sizeof|sizeof
argument_list|(
name|HAL_REVS
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_DIAG_REGS
case|:
operator|*
name|resultsize
operator|=
name|ath_hal_getregdump
argument_list|(
name|ah
argument_list|,
name|args
argument_list|,
operator|*
name|result
argument_list|,
operator|*
name|resultsize
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_DIAG_SETREGS
case|:
name|ath_hal_setregs
argument_list|(
name|ah
argument_list|,
name|args
argument_list|,
name|argsize
argument_list|)
expr_stmt|;
operator|*
name|resultsize
operator|=
literal|0
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_DIAG_FATALERR
case|:
operator|*
name|result
operator|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_fatalState
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|resultsize
operator|=
sizeof|sizeof
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_fatalState
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_DIAG_EEREAD
case|:
if|if
condition|(
name|argsize
operator|!=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
if|if
condition|(
operator|!
name|ath_hal_eepromRead
argument_list|(
name|ah
argument_list|,
operator|*
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|args
argument_list|,
operator|*
name|result
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
operator|*
name|resultsize
operator|=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
ifdef|#
directive|ifdef
name|AH_PRIVATE_DIAG
case|case
name|HAL_DIAG_SETKEY
case|:
block|{
specifier|const
name|HAL_DIAG_KEYVAL
modifier|*
name|dk
decl_stmt|;
if|if
condition|(
name|argsize
operator|!=
sizeof|sizeof
argument_list|(
name|HAL_DIAG_KEYVAL
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
name|dk
operator|=
operator|(
specifier|const
name|HAL_DIAG_KEYVAL
operator|*
operator|)
name|args
expr_stmt|;
return|return
name|ah
operator|->
name|ah_setKeyCacheEntry
argument_list|(
name|ah
argument_list|,
name|dk
operator|->
name|dk_keyix
argument_list|,
operator|&
name|dk
operator|->
name|dk_keyval
argument_list|,
name|dk
operator|->
name|dk_mac
argument_list|,
name|dk
operator|->
name|dk_xor
argument_list|)
return|;
block|}
case|case
name|HAL_DIAG_RESETKEY
case|:
if|if
condition|(
name|argsize
operator|!=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
return|return
name|ah
operator|->
name|ah_resetKeyCacheEntry
argument_list|(
name|ah
argument_list|,
operator|*
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|args
argument_list|)
return|;
ifdef|#
directive|ifdef
name|AH_SUPPORT_WRITE_EEPROM
case|case
name|HAL_DIAG_EEWRITE
case|:
block|{
specifier|const
name|HAL_DIAG_EEVAL
modifier|*
name|ee
decl_stmt|;
if|if
condition|(
name|argsize
operator|!=
sizeof|sizeof
argument_list|(
name|HAL_DIAG_EEVAL
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
name|ee
operator|=
operator|(
specifier|const
name|HAL_DIAG_EEVAL
operator|*
operator|)
name|args
expr_stmt|;
return|return
name|ath_hal_eepromWrite
argument_list|(
name|ah
argument_list|,
name|ee
operator|->
name|ee_off
argument_list|,
name|ee
operator|->
name|ee_data
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* AH_SUPPORT_WRITE_EEPROM */
endif|#
directive|endif
comment|/* AH_PRIVATE_DIAG */
case|case
name|HAL_DIAG_11NCOMPAT
case|:
if|if
condition|(
name|argsize
operator|==
literal|0
condition|)
block|{
operator|*
name|resultsize
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|*
name|result
operator|)
operator|)
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_11nCompat
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argsize
operator|==
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_11nCompat
operator|=
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|args
expr_stmt|;
block|}
else|else
return|return
name|AH_FALSE
return|;
return|return
name|AH_TRUE
return|;
block|}
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Set the properties of the tx queue with the parameters  * from qInfo.  */
end_comment

begin_function
name|HAL_BOOL
name|ath_hal_setTxQProps
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_TX_QUEUE_INFO
modifier|*
name|qi
parameter_list|,
specifier|const
name|HAL_TXQ_INFO
modifier|*
name|qInfo
parameter_list|)
block|{
name|uint32_t
name|cw
decl_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_type
operator|==
name|HAL_TX_QUEUE_INACTIVE
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_TXQUEUE
argument_list|,
literal|"%s: inactive queue\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* XXX validate parameters */
name|qi
operator|->
name|tqi_ver
operator|=
name|qInfo
operator|->
name|tqi_ver
expr_stmt|;
name|qi
operator|->
name|tqi_subtype
operator|=
name|qInfo
operator|->
name|tqi_subtype
expr_stmt|;
name|qi
operator|->
name|tqi_qflags
operator|=
name|qInfo
operator|->
name|tqi_qflags
expr_stmt|;
name|qi
operator|->
name|tqi_priority
operator|=
name|qInfo
operator|->
name|tqi_priority
expr_stmt|;
if|if
condition|(
name|qInfo
operator|->
name|tqi_aifs
operator|!=
name|HAL_TXQ_USEDEFAULT
condition|)
name|qi
operator|->
name|tqi_aifs
operator|=
name|AH_MIN
argument_list|(
name|qInfo
operator|->
name|tqi_aifs
argument_list|,
literal|255
argument_list|)
expr_stmt|;
else|else
name|qi
operator|->
name|tqi_aifs
operator|=
name|INIT_AIFS
expr_stmt|;
if|if
condition|(
name|qInfo
operator|->
name|tqi_cwmin
operator|!=
name|HAL_TXQ_USEDEFAULT
condition|)
block|{
name|cw
operator|=
name|AH_MIN
argument_list|(
name|qInfo
operator|->
name|tqi_cwmin
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
comment|/* make sure that the CWmin is of the form (2^n - 1) */
name|qi
operator|->
name|tqi_cwmin
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|qi
operator|->
name|tqi_cwmin
operator|<
name|cw
condition|)
name|qi
operator|->
name|tqi_cwmin
operator|=
operator|(
name|qi
operator|->
name|tqi_cwmin
operator|<<
literal|1
operator|)
operator||
literal|1
expr_stmt|;
block|}
else|else
name|qi
operator|->
name|tqi_cwmin
operator|=
name|qInfo
operator|->
name|tqi_cwmin
expr_stmt|;
if|if
condition|(
name|qInfo
operator|->
name|tqi_cwmax
operator|!=
name|HAL_TXQ_USEDEFAULT
condition|)
block|{
name|cw
operator|=
name|AH_MIN
argument_list|(
name|qInfo
operator|->
name|tqi_cwmax
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
comment|/* make sure that the CWmax is of the form (2^n - 1) */
name|qi
operator|->
name|tqi_cwmax
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|qi
operator|->
name|tqi_cwmax
operator|<
name|cw
condition|)
name|qi
operator|->
name|tqi_cwmax
operator|=
operator|(
name|qi
operator|->
name|tqi_cwmax
operator|<<
literal|1
operator|)
operator||
literal|1
expr_stmt|;
block|}
else|else
name|qi
operator|->
name|tqi_cwmax
operator|=
name|INIT_CWMAX
expr_stmt|;
comment|/* Set retry limit values */
if|if
condition|(
name|qInfo
operator|->
name|tqi_shretry
operator|!=
literal|0
condition|)
name|qi
operator|->
name|tqi_shretry
operator|=
name|AH_MIN
argument_list|(
name|qInfo
operator|->
name|tqi_shretry
argument_list|,
literal|15
argument_list|)
expr_stmt|;
else|else
name|qi
operator|->
name|tqi_shretry
operator|=
name|INIT_SH_RETRY
expr_stmt|;
if|if
condition|(
name|qInfo
operator|->
name|tqi_lgretry
operator|!=
literal|0
condition|)
name|qi
operator|->
name|tqi_lgretry
operator|=
name|AH_MIN
argument_list|(
name|qInfo
operator|->
name|tqi_lgretry
argument_list|,
literal|15
argument_list|)
expr_stmt|;
else|else
name|qi
operator|->
name|tqi_lgretry
operator|=
name|INIT_LG_RETRY
expr_stmt|;
name|qi
operator|->
name|tqi_cbrPeriod
operator|=
name|qInfo
operator|->
name|tqi_cbrPeriod
expr_stmt|;
name|qi
operator|->
name|tqi_cbrOverflowLimit
operator|=
name|qInfo
operator|->
name|tqi_cbrOverflowLimit
expr_stmt|;
name|qi
operator|->
name|tqi_burstTime
operator|=
name|qInfo
operator|->
name|tqi_burstTime
expr_stmt|;
name|qi
operator|->
name|tqi_readyTime
operator|=
name|qInfo
operator|->
name|tqi_readyTime
expr_stmt|;
switch|switch
condition|(
name|qInfo
operator|->
name|tqi_subtype
condition|)
block|{
case|case
name|HAL_WME_UPSD
case|:
if|if
condition|(
name|qi
operator|->
name|tqi_type
operator|==
name|HAL_TX_QUEUE_DATA
condition|)
name|qi
operator|->
name|tqi_intFlags
operator|=
name|HAL_TXQ_USE_LOCKOUT_BKOFF_DIS
expr_stmt|;
break|break;
default|default:
break|break;
comment|/* NB: silence compiler */
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ath_hal_getTxQProps
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_TXQ_INFO
modifier|*
name|qInfo
parameter_list|,
specifier|const
name|HAL_TX_QUEUE_INFO
modifier|*
name|qi
parameter_list|)
block|{
if|if
condition|(
name|qi
operator|->
name|tqi_type
operator|==
name|HAL_TX_QUEUE_INACTIVE
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_TXQUEUE
argument_list|,
literal|"%s: inactive queue\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|qInfo
operator|->
name|tqi_qflags
operator|=
name|qi
operator|->
name|tqi_qflags
expr_stmt|;
name|qInfo
operator|->
name|tqi_ver
operator|=
name|qi
operator|->
name|tqi_ver
expr_stmt|;
name|qInfo
operator|->
name|tqi_subtype
operator|=
name|qi
operator|->
name|tqi_subtype
expr_stmt|;
name|qInfo
operator|->
name|tqi_qflags
operator|=
name|qi
operator|->
name|tqi_qflags
expr_stmt|;
name|qInfo
operator|->
name|tqi_priority
operator|=
name|qi
operator|->
name|tqi_priority
expr_stmt|;
name|qInfo
operator|->
name|tqi_aifs
operator|=
name|qi
operator|->
name|tqi_aifs
expr_stmt|;
name|qInfo
operator|->
name|tqi_cwmin
operator|=
name|qi
operator|->
name|tqi_cwmin
expr_stmt|;
name|qInfo
operator|->
name|tqi_cwmax
operator|=
name|qi
operator|->
name|tqi_cwmax
expr_stmt|;
name|qInfo
operator|->
name|tqi_shretry
operator|=
name|qi
operator|->
name|tqi_shretry
expr_stmt|;
name|qInfo
operator|->
name|tqi_lgretry
operator|=
name|qi
operator|->
name|tqi_lgretry
expr_stmt|;
name|qInfo
operator|->
name|tqi_cbrPeriod
operator|=
name|qi
operator|->
name|tqi_cbrPeriod
expr_stmt|;
name|qInfo
operator|->
name|tqi_cbrOverflowLimit
operator|=
name|qi
operator|->
name|tqi_cbrOverflowLimit
expr_stmt|;
name|qInfo
operator|->
name|tqi_burstTime
operator|=
name|qi
operator|->
name|tqi_burstTime
expr_stmt|;
name|qInfo
operator|->
name|tqi_readyTime
operator|=
name|qi
operator|->
name|tqi_readyTime
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/* 11a Turbo  11b  11g  108g */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int16_t
name|NOISE_FLOOR
index|[]
init|=
block|{
operator|-
literal|96
block|,
operator|-
literal|93
block|,
operator|-
literal|98
block|,
operator|-
literal|96
block|,
operator|-
literal|93
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read the current channel noise floor and return.  * If nf cal hasn't finished, channel noise floor should be 0  * and we return a nominal value based on band and frequency.  *  * NB: This is a private routine used by per-chip code to  *     implement the ah_getChanNoise method.  */
end_comment

begin_function
name|int16_t
name|ath_hal_getChanNoise
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
decl_stmt|;
name|ichan
operator|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ichan
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"%s: invalid channel %u/0x%x; no mapping\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ichan
operator|->
name|rawNoiseFloor
operator|==
literal|0
condition|)
block|{
name|WIRELESS_MODE
name|mode
init|=
name|ath_hal_chan2wmode
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|HALASSERT
argument_list|(
name|mode
operator|<
name|WIRELESS_MODE_MAX
argument_list|)
expr_stmt|;
return|return
name|NOISE_FLOOR
index|[
name|mode
index|]
operator|+
name|ath_hal_getNfAdjust
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
return|;
block|}
else|else
return|return
name|ichan
operator|->
name|rawNoiseFloor
operator|+
name|ichan
operator|->
name|noiseFloorAdjust
return|;
block|}
end_function

begin_comment
comment|/*  * Process all valid raw noise floors into the dBm noise floor values.  * Though our device has no reference for a dBm noise floor, we perform  * a relative minimization of NF's based on the lowest NF found across a  * channel scan.  */
end_comment

begin_function
name|void
name|ath_hal_process_noisefloor
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|HAL_CHANNEL_INTERNAL
modifier|*
name|c
decl_stmt|;
name|int16_t
name|correct2
decl_stmt|,
name|correct5
decl_stmt|;
name|int16_t
name|lowest2
decl_stmt|,
name|lowest5
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*  	 * Find the lowest 2GHz and 5GHz noise floor values after adjusting 	 * for statistically recorded NF/channel deviation. 	 */
name|correct2
operator|=
name|lowest2
operator|=
literal|0
expr_stmt|;
name|correct5
operator|=
name|lowest5
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_nchan
condition|;
name|i
operator|++
control|)
block|{
name|WIRELESS_MODE
name|mode
decl_stmt|;
name|int16_t
name|nf
decl_stmt|;
name|c
operator|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|rawNoiseFloor
operator|>=
literal|0
condition|)
continue|continue;
comment|/* XXX can't identify proper mode */
name|mode
operator|=
name|IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|?
name|WIRELESS_MODE_11a
else|:
name|WIRELESS_MODE_11g
expr_stmt|;
name|nf
operator|=
name|c
operator|->
name|rawNoiseFloor
operator|+
name|NOISE_FLOOR
index|[
name|mode
index|]
operator|+
name|ath_hal_getNfAdjust
argument_list|(
name|ah
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|nf
operator|<
name|lowest5
condition|)
block|{
name|lowest5
operator|=
name|nf
expr_stmt|;
name|correct5
operator|=
name|NOISE_FLOOR
index|[
name|mode
index|]
operator|-
operator|(
name|c
operator|->
name|rawNoiseFloor
operator|+
name|ath_hal_getNfAdjust
argument_list|(
name|ah
argument_list|,
name|c
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|nf
operator|<
name|lowest2
condition|)
block|{
name|lowest2
operator|=
name|nf
expr_stmt|;
name|correct2
operator|=
name|NOISE_FLOOR
index|[
name|mode
index|]
operator|-
operator|(
name|c
operator|->
name|rawNoiseFloor
operator|+
name|ath_hal_getNfAdjust
argument_list|(
name|ah
argument_list|,
name|c
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Correct the channels to reach the expected NF value */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_nchan
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|rawNoiseFloor
operator|>=
literal|0
condition|)
continue|continue;
comment|/* Apply correction factor */
name|c
operator|->
name|noiseFloorAdjust
operator|=
name|ath_hal_getNfAdjust
argument_list|(
name|ah
argument_list|,
name|c
argument_list|)
operator|+
operator|(
name|IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|?
name|correct5
else|:
name|correct2
operator|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"%u raw nf %d adjust %d\n"
argument_list|,
name|c
operator|->
name|channel
argument_list|,
name|c
operator|->
name|rawNoiseFloor
argument_list|,
name|c
operator|->
name|noiseFloorAdjust
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * INI support routines.  */
end_comment

begin_function
name|int
name|ath_hal_ini_write
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_INI_ARRAY
modifier|*
name|ia
parameter_list|,
name|int
name|col
parameter_list|,
name|int
name|regWr
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|ia
operator|->
name|rows
condition|;
name|r
operator|++
control|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|HAL_INI_VAL
argument_list|(
name|ia
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
argument_list|,
name|HAL_INI_VAL
argument_list|(
name|ia
argument_list|,
name|r
argument_list|,
name|col
argument_list|)
argument_list|)
expr_stmt|;
name|DMA_YIELD
argument_list|(
name|regWr
argument_list|)
expr_stmt|;
block|}
return|return
name|regWr
return|;
block|}
end_function

begin_function
name|void
name|ath_hal_ini_bank_setup
parameter_list|(
name|uint32_t
name|data
index|[]
parameter_list|,
specifier|const
name|HAL_INI_ARRAY
modifier|*
name|ia
parameter_list|,
name|int
name|col
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|ia
operator|->
name|rows
condition|;
name|r
operator|++
control|)
name|data
index|[
name|r
index|]
operator|=
name|HAL_INI_VAL
argument_list|(
name|ia
argument_list|,
name|r
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ath_hal_ini_bank_write
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_INI_ARRAY
modifier|*
name|ia
parameter_list|,
specifier|const
name|uint32_t
name|data
index|[]
parameter_list|,
name|int
name|regWr
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|ia
operator|->
name|rows
condition|;
name|r
operator|++
control|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|HAL_INI_VAL
argument_list|(
name|ia
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
argument_list|,
name|data
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|DMA_YIELD
argument_list|(
name|regWr
argument_list|)
expr_stmt|;
block|}
return|return
name|regWr
return|;
block|}
end_function

end_unit

