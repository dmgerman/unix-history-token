begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2002-2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_devid.h"
end_include

begin_include
include|#
directive|include
file|"ah_eeprom.h"
end_include

begin_comment
comment|/* for 5ghz fast clock flag */
end_comment

begin_include
include|#
directive|include
file|"ar5416/ar5416reg.h"
end_include

begin_comment
comment|/* NB: includes ar5212reg.h */
end_comment

begin_include
include|#
directive|include
file|"ar9003/ar9300_devid.h"
end_include

begin_comment
comment|/* linker set of registered chips */
end_comment

begin_expr_stmt
name|OS_SET_DECLARE
argument_list|(
name|ah_chips
argument_list|,
expr|struct
name|ath_hal_chip
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|ath_hal_chip
argument_list|)
end_macro

begin_expr_stmt
name|ah_chip_list
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|ah_chip_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|ath_hal_add_chip
parameter_list|(
name|struct
name|ath_hal_chip
modifier|*
name|ahc
parameter_list|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ah_chip_list
argument_list|,
name|ahc
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ath_hal_remove_chip
parameter_list|(
name|struct
name|ath_hal_chip
modifier|*
name|ahc
parameter_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ah_chip_list
argument_list|,
name|ahc
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check the set of registered chips to see if any recognize  * the device as one they can support.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ath_hal_probe
parameter_list|(
name|uint16_t
name|vendorid
parameter_list|,
name|uint16_t
name|devid
parameter_list|)
block|{
name|struct
name|ath_hal_chip
modifier|*
specifier|const
modifier|*
name|pchip
decl_stmt|;
name|struct
name|ath_hal_chip
modifier|*
name|pc
decl_stmt|;
comment|/* Linker set */
name|OS_SET_FOREACH
argument_list|(
argument|pchip
argument_list|,
argument|ah_chips
argument_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
operator|(
operator|*
name|pchip
operator|)
operator|->
name|probe
argument_list|(
name|vendorid
argument_list|,
name|devid
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|AH_NULL
condition|)
return|return
name|name
return|;
block|}
comment|/* List */
name|TAILQ_FOREACH
argument_list|(
argument|pc
argument_list|,
argument|&ah_chip_list
argument_list|,
argument|node
argument_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|pc
operator|->
name|probe
argument_list|(
name|vendorid
argument_list|,
name|devid
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|AH_NULL
condition|)
return|return
name|name
return|;
block|}
return|return
name|AH_NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Attach detects device chip revisions, initializes the hwLayer  * function list, reads EEPROM information,  * selects reset vectors, and performs a short self test.  * Any failures will return an error that should cause a hardware  * disable.  */
end_comment

begin_function
name|struct
name|ath_hal
modifier|*
name|ath_hal_attach
parameter_list|(
name|uint16_t
name|devid
parameter_list|,
name|HAL_SOFTC
name|sc
parameter_list|,
name|HAL_BUS_TAG
name|st
parameter_list|,
name|HAL_BUS_HANDLE
name|sh
parameter_list|,
name|uint16_t
modifier|*
name|eepromdata
parameter_list|,
name|HAL_OPS_CONFIG
modifier|*
name|ah_config
parameter_list|,
name|HAL_STATUS
modifier|*
name|error
parameter_list|)
block|{
name|struct
name|ath_hal_chip
modifier|*
specifier|const
modifier|*
name|pchip
decl_stmt|;
name|struct
name|ath_hal_chip
modifier|*
name|pc
decl_stmt|;
name|OS_SET_FOREACH
argument_list|(
argument|pchip
argument_list|,
argument|ah_chips
argument_list|)
block|{
name|struct
name|ath_hal_chip
modifier|*
name|chip
init|=
operator|*
name|pchip
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
decl_stmt|;
comment|/* XXX don't have vendorid, assume atheros one works */
if|if
condition|(
name|chip
operator|->
name|probe
argument_list|(
name|ATHEROS_VENDOR_ID
argument_list|,
name|devid
argument_list|)
operator|==
name|AH_NULL
condition|)
continue|continue;
name|ah
operator|=
name|chip
operator|->
name|attach
argument_list|(
name|devid
argument_list|,
name|sc
argument_list|,
name|st
argument_list|,
name|sh
argument_list|,
name|eepromdata
argument_list|,
name|ah_config
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ah
operator|!=
name|AH_NULL
condition|)
block|{
comment|/* copy back private state to public area */
name|ah
operator|->
name|ah_devid
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_devid
expr_stmt|;
name|ah
operator|->
name|ah_subvendorid
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_subvendorid
expr_stmt|;
name|ah
operator|->
name|ah_macVersion
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
expr_stmt|;
name|ah
operator|->
name|ah_macRev
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macRev
expr_stmt|;
name|ah
operator|->
name|ah_phyRev
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyRev
expr_stmt|;
name|ah
operator|->
name|ah_analog5GhzRev
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
expr_stmt|;
name|ah
operator|->
name|ah_analog2GhzRev
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog2GhzRev
expr_stmt|;
return|return
name|ah
return|;
block|}
block|}
comment|/* List */
name|TAILQ_FOREACH
argument_list|(
argument|pc
argument_list|,
argument|&ah_chip_list
argument_list|,
argument|node
argument_list|)
block|{
name|struct
name|ath_hal_chip
modifier|*
name|chip
init|=
name|pc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
decl_stmt|;
comment|/* XXX don't have vendorid, assume atheros one works */
if|if
condition|(
name|chip
operator|->
name|probe
argument_list|(
name|ATHEROS_VENDOR_ID
argument_list|,
name|devid
argument_list|)
operator|==
name|AH_NULL
condition|)
continue|continue;
name|ah
operator|=
name|chip
operator|->
name|attach
argument_list|(
name|devid
argument_list|,
name|sc
argument_list|,
name|st
argument_list|,
name|sh
argument_list|,
name|eepromdata
argument_list|,
name|ah_config
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ah
operator|!=
name|AH_NULL
condition|)
block|{
comment|/* copy back private state to public area */
name|ah
operator|->
name|ah_devid
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_devid
expr_stmt|;
name|ah
operator|->
name|ah_subvendorid
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_subvendorid
expr_stmt|;
name|ah
operator|->
name|ah_macVersion
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
expr_stmt|;
name|ah
operator|->
name|ah_macRev
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macRev
expr_stmt|;
name|ah
operator|->
name|ah_phyRev
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyRev
expr_stmt|;
name|ah
operator|->
name|ah_analog5GhzRev
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
expr_stmt|;
name|ah
operator|->
name|ah_analog2GhzRev
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog2GhzRev
expr_stmt|;
return|return
name|ah
return|;
block|}
block|}
return|return
name|AH_NULL
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|ath_hal_mac_name
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
switch|switch
condition|(
name|ah
operator|->
name|ah_macVersion
condition|)
block|{
case|case
name|AR_SREV_VERSION_CRETE
case|:
case|case
name|AR_SREV_VERSION_MAUI_1
case|:
return|return
literal|"AR5210"
return|;
case|case
name|AR_SREV_VERSION_MAUI_2
case|:
case|case
name|AR_SREV_VERSION_OAHU
case|:
return|return
literal|"AR5211"
return|;
case|case
name|AR_SREV_VERSION_VENICE
case|:
return|return
literal|"AR5212"
return|;
case|case
name|AR_SREV_VERSION_GRIFFIN
case|:
return|return
literal|"AR2413"
return|;
case|case
name|AR_SREV_VERSION_CONDOR
case|:
return|return
literal|"AR5424"
return|;
case|case
name|AR_SREV_VERSION_EAGLE
case|:
return|return
literal|"AR5413"
return|;
case|case
name|AR_SREV_VERSION_COBRA
case|:
return|return
literal|"AR2415"
return|;
case|case
name|AR_SREV_2425
case|:
comment|/* Swan */
return|return
literal|"AR2425"
return|;
case|case
name|AR_SREV_2417
case|:
comment|/* Nala */
return|return
literal|"AR2417"
return|;
case|case
name|AR_XSREV_VERSION_OWL_PCI
case|:
return|return
literal|"AR5416"
return|;
case|case
name|AR_XSREV_VERSION_OWL_PCIE
case|:
return|return
literal|"AR5418"
return|;
case|case
name|AR_XSREV_VERSION_HOWL
case|:
return|return
literal|"AR9130"
return|;
case|case
name|AR_XSREV_VERSION_SOWL
case|:
return|return
literal|"AR9160"
return|;
case|case
name|AR_XSREV_VERSION_MERLIN
case|:
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ispcie
condition|)
return|return
literal|"AR9280"
return|;
return|return
literal|"AR9220"
return|;
case|case
name|AR_XSREV_VERSION_KITE
case|:
return|return
literal|"AR9285"
return|;
case|case
name|AR_XSREV_VERSION_KIWI
case|:
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ispcie
condition|)
return|return
literal|"AR9287"
return|;
return|return
literal|"AR9227"
return|;
case|case
name|AR_SREV_VERSION_AR9380
case|:
if|if
condition|(
name|ah
operator|->
name|ah_macRev
operator|>=
name|AR_SREV_REVISION_AR9580_10
condition|)
return|return
literal|"AR9580"
return|;
return|return
literal|"AR9380"
return|;
case|case
name|AR_SREV_VERSION_AR9460
case|:
return|return
literal|"AR9460"
return|;
case|case
name|AR_SREV_VERSION_AR9330
case|:
return|return
literal|"AR9330"
return|;
case|case
name|AR_SREV_VERSION_AR9340
case|:
return|return
literal|"AR9340"
return|;
case|case
name|AR_SREV_VERSION_QCA9550
case|:
return|return
literal|"QCA9550"
return|;
case|case
name|AR_SREV_VERSION_AR9485
case|:
return|return
literal|"AR9485"
return|;
case|case
name|AR_SREV_VERSION_QCA9565
case|:
return|return
literal|"QCA9565"
return|;
case|case
name|AR_SREV_VERSION_QCA9530
case|:
return|return
literal|"QCA9530"
return|;
block|}
return|return
literal|"????"
return|;
block|}
end_function

begin_comment
comment|/*  * Return the mask of available modes based on the hardware capabilities.  */
end_comment

begin_function
name|u_int
name|ath_hal_getwirelessmodes
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|ath_hal_getWirelessModes
argument_list|(
name|ah
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* linker set of registered RF backends */
end_comment

begin_expr_stmt
name|OS_SET_DECLARE
argument_list|(
name|ah_rfs
argument_list|,
expr|struct
name|ath_hal_rf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|ath_hal_rf
argument_list|)
end_macro

begin_expr_stmt
name|ah_rf_list
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|ah_rf_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|ath_hal_add_rf
parameter_list|(
name|struct
name|ath_hal_rf
modifier|*
name|arf
parameter_list|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ah_rf_list
argument_list|,
name|arf
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ath_hal_remove_rf
parameter_list|(
name|struct
name|ath_hal_rf
modifier|*
name|arf
parameter_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ah_rf_list
argument_list|,
name|arf
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check the set of registered RF backends to see if  * any recognize the device as one they can support.  */
end_comment

begin_function
name|struct
name|ath_hal_rf
modifier|*
name|ath_hal_rfprobe
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_STATUS
modifier|*
name|ecode
parameter_list|)
block|{
name|struct
name|ath_hal_rf
modifier|*
specifier|const
modifier|*
name|prf
decl_stmt|;
name|struct
name|ath_hal_rf
modifier|*
name|rf
decl_stmt|;
name|OS_SET_FOREACH
argument_list|(
argument|prf
argument_list|,
argument|ah_rfs
argument_list|)
block|{
name|struct
name|ath_hal_rf
modifier|*
name|rf
init|=
operator|*
name|prf
decl_stmt|;
if|if
condition|(
name|rf
operator|->
name|probe
argument_list|(
name|ah
argument_list|)
condition|)
return|return
name|rf
return|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|rf
argument_list|,
argument|&ah_rf_list
argument_list|,
argument|node
argument_list|)
block|{
if|if
condition|(
name|rf
operator|->
name|probe
argument_list|(
name|ah
argument_list|)
condition|)
return|return
name|rf
return|;
block|}
operator|*
name|ecode
operator|=
name|HAL_ENOTSUPP
expr_stmt|;
return|return
name|AH_NULL
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|ath_hal_rf_name
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
switch|switch
condition|(
name|ah
operator|->
name|ah_analog5GhzRev
operator|&
name|AR_RADIO_SREV_MAJOR
condition|)
block|{
case|case
literal|0
case|:
comment|/* 5210 */
return|return
literal|"5110"
return|;
comment|/* NB: made up */
case|case
name|AR_RAD5111_SREV_MAJOR
case|:
case|case
name|AR_RAD5111_SREV_PROD
case|:
return|return
literal|"5111"
return|;
case|case
name|AR_RAD2111_SREV_MAJOR
case|:
return|return
literal|"2111"
return|;
case|case
name|AR_RAD5112_SREV_MAJOR
case|:
case|case
name|AR_RAD5112_SREV_2_0
case|:
case|case
name|AR_RAD5112_SREV_2_1
case|:
return|return
literal|"5112"
return|;
case|case
name|AR_RAD2112_SREV_MAJOR
case|:
case|case
name|AR_RAD2112_SREV_2_0
case|:
case|case
name|AR_RAD2112_SREV_2_1
case|:
return|return
literal|"2112"
return|;
case|case
name|AR_RAD2413_SREV_MAJOR
case|:
return|return
literal|"2413"
return|;
case|case
name|AR_RAD5413_SREV_MAJOR
case|:
return|return
literal|"5413"
return|;
case|case
name|AR_RAD2316_SREV_MAJOR
case|:
return|return
literal|"2316"
return|;
case|case
name|AR_RAD2317_SREV_MAJOR
case|:
return|return
literal|"2317"
return|;
case|case
name|AR_RAD5424_SREV_MAJOR
case|:
return|return
literal|"5424"
return|;
case|case
name|AR_RAD5133_SREV_MAJOR
case|:
return|return
literal|"5133"
return|;
case|case
name|AR_RAD2133_SREV_MAJOR
case|:
return|return
literal|"2133"
return|;
case|case
name|AR_RAD5122_SREV_MAJOR
case|:
return|return
literal|"5122"
return|;
case|case
name|AR_RAD2122_SREV_MAJOR
case|:
return|return
literal|"2122"
return|;
block|}
return|return
literal|"????"
return|;
block|}
end_function

begin_comment
comment|/*  * Poll the register looking for a specific value.  */
end_comment

begin_function
name|HAL_BOOL
name|ath_hal_wait
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|uint32_t
name|mask
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
define|#
directive|define
name|AH_TIMEOUT
value|5000
return|return
name|ath_hal_waitfor
argument_list|(
name|ah
argument_list|,
name|reg
argument_list|,
name|mask
argument_list|,
name|val
argument_list|,
name|AH_TIMEOUT
argument_list|)
return|;
undef|#
directive|undef
name|AH_TIMEOUT
block|}
end_function

begin_function
name|HAL_BOOL
name|ath_hal_waitfor
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|uint32_t
name|mask
parameter_list|,
name|uint32_t
name|val
parameter_list|,
name|uint32_t
name|timeout
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|reg
argument_list|)
operator|&
name|mask
operator|)
operator|==
name|val
condition|)
return|return
name|AH_TRUE
return|;
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_REGIO
operator||
name|HAL_DEBUG_PHYIO
argument_list|,
literal|"%s: timeout on reg 0x%x: 0x%08x& 0x%08x != 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|reg
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|reg
argument_list|)
argument_list|,
name|mask
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Reverse the bits starting at the low bit for a value of  * bit_count in size  */
end_comment

begin_function
name|uint32_t
name|ath_hal_reverseBits
parameter_list|(
name|uint32_t
name|val
parameter_list|,
name|uint32_t
name|n
parameter_list|)
block|{
name|uint32_t
name|retval
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|retval
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|retval
operator|=
operator|(
name|retval
operator|<<
literal|1
operator|)
operator||
operator|(
name|val
operator|&
literal|1
operator|)
expr_stmt|;
name|val
operator|>>=
literal|1
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* 802.11n related timing definitions */
end_comment

begin_define
define|#
directive|define
name|OFDM_PLCP_BITS
value|22
end_define

begin_define
define|#
directive|define
name|HT_L_STF
value|8
end_define

begin_define
define|#
directive|define
name|HT_L_LTF
value|8
end_define

begin_define
define|#
directive|define
name|HT_L_SIG
value|4
end_define

begin_define
define|#
directive|define
name|HT_SIG
value|8
end_define

begin_define
define|#
directive|define
name|HT_STF
value|4
end_define

begin_define
define|#
directive|define
name|HT_LTF
parameter_list|(
name|n
parameter_list|)
value|((n) * 4)
end_define

begin_define
define|#
directive|define
name|HT_RC_2_MCS
parameter_list|(
name|_rc
parameter_list|)
value|((_rc)& 0x1f)
end_define

begin_define
define|#
directive|define
name|HT_RC_2_STREAMS
parameter_list|(
name|_rc
parameter_list|)
value|((((_rc)& 0x78)>> 3) + 1)
end_define

begin_define
define|#
directive|define
name|IS_HT_RATE
parameter_list|(
name|_rc
parameter_list|)
value|( (_rc)& IEEE80211_RATE_MCS)
end_define

begin_comment
comment|/*  * Calculate the duration of a packet whether it is 11n or legacy.  */
end_comment

begin_function
name|uint32_t
name|ath_hal_pkt_txtime
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rates
parameter_list|,
name|uint32_t
name|frameLen
parameter_list|,
name|uint16_t
name|rateix
parameter_list|,
name|HAL_BOOL
name|isht40
parameter_list|,
name|HAL_BOOL
name|shortPreamble
parameter_list|,
name|HAL_BOOL
name|includeSifs
parameter_list|)
block|{
name|uint8_t
name|rc
decl_stmt|;
name|int
name|numStreams
decl_stmt|;
name|rc
operator|=
name|rates
operator|->
name|info
index|[
name|rateix
index|]
operator|.
name|rateCode
expr_stmt|;
comment|/* Legacy rate? Return the old way */
if|if
condition|(
operator|!
name|IS_HT_RATE
argument_list|(
name|rc
argument_list|)
condition|)
return|return
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rates
argument_list|,
name|frameLen
argument_list|,
name|rateix
argument_list|,
name|shortPreamble
argument_list|,
name|includeSifs
argument_list|)
return|;
comment|/* 11n frame - extract out the number of spatial streams */
name|numStreams
operator|=
name|HT_RC_2_STREAMS
argument_list|(
name|rc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|numStreams
operator|>
literal|0
operator|&&
name|numStreams
operator|<=
literal|4
argument_list|,
operator|(
literal|"number of spatial streams needs to be 1..3: MCS rate 0x%x!"
operator|,
name|rateix
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX TODO: Add SIFS */
return|return
name|ath_computedur_ht
argument_list|(
name|frameLen
argument_list|,
name|rc
argument_list|,
name|numStreams
argument_list|,
name|isht40
argument_list|,
name|shortPreamble
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|ht20_bps
index|[
literal|32
index|]
init|=
block|{
literal|26
block|,
literal|52
block|,
literal|78
block|,
literal|104
block|,
literal|156
block|,
literal|208
block|,
literal|234
block|,
literal|260
block|,
literal|52
block|,
literal|104
block|,
literal|156
block|,
literal|208
block|,
literal|312
block|,
literal|416
block|,
literal|468
block|,
literal|520
block|,
literal|78
block|,
literal|156
block|,
literal|234
block|,
literal|312
block|,
literal|468
block|,
literal|624
block|,
literal|702
block|,
literal|780
block|,
literal|104
block|,
literal|208
block|,
literal|312
block|,
literal|416
block|,
literal|624
block|,
literal|832
block|,
literal|936
block|,
literal|1040
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|ht40_bps
index|[
literal|32
index|]
init|=
block|{
literal|54
block|,
literal|108
block|,
literal|162
block|,
literal|216
block|,
literal|324
block|,
literal|432
block|,
literal|486
block|,
literal|540
block|,
literal|108
block|,
literal|216
block|,
literal|324
block|,
literal|432
block|,
literal|648
block|,
literal|864
block|,
literal|972
block|,
literal|1080
block|,
literal|162
block|,
literal|324
block|,
literal|486
block|,
literal|648
block|,
literal|972
block|,
literal|1296
block|,
literal|1458
block|,
literal|1620
block|,
literal|216
block|,
literal|432
block|,
literal|648
block|,
literal|864
block|,
literal|1296
block|,
literal|1728
block|,
literal|1944
block|,
literal|2160
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Calculate the transmit duration of an 11n frame.  */
end_comment

begin_function
name|uint32_t
name|ath_computedur_ht
parameter_list|(
name|uint32_t
name|frameLen
parameter_list|,
name|uint16_t
name|rate
parameter_list|,
name|int
name|streams
parameter_list|,
name|HAL_BOOL
name|isht40
parameter_list|,
name|HAL_BOOL
name|isShortGI
parameter_list|)
block|{
name|uint32_t
name|bitsPerSymbol
decl_stmt|,
name|numBits
decl_stmt|,
name|numSymbols
decl_stmt|,
name|txTime
decl_stmt|;
name|KASSERT
argument_list|(
name|rate
operator|&
name|IEEE80211_RATE_MCS
argument_list|,
operator|(
literal|"not mcs %d"
operator|,
name|rate
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|rate
operator|&
operator|~
name|IEEE80211_RATE_MCS
operator|)
operator|<
literal|31
argument_list|,
operator|(
literal|"bad mcs 0x%x"
operator|,
name|rate
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isht40
condition|)
name|bitsPerSymbol
operator|=
name|ht40_bps
index|[
name|HT_RC_2_MCS
argument_list|(
name|rate
argument_list|)
index|]
expr_stmt|;
else|else
name|bitsPerSymbol
operator|=
name|ht20_bps
index|[
name|HT_RC_2_MCS
argument_list|(
name|rate
argument_list|)
index|]
expr_stmt|;
name|numBits
operator|=
name|OFDM_PLCP_BITS
operator|+
operator|(
name|frameLen
operator|<<
literal|3
operator|)
expr_stmt|;
name|numSymbols
operator|=
name|howmany
argument_list|(
name|numBits
argument_list|,
name|bitsPerSymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|isShortGI
condition|)
name|txTime
operator|=
operator|(
operator|(
name|numSymbols
operator|*
literal|18
operator|)
operator|+
literal|4
operator|)
operator|/
literal|5
expr_stmt|;
comment|/* 3.6us */
else|else
name|txTime
operator|=
name|numSymbols
operator|*
literal|4
expr_stmt|;
comment|/* 4us */
return|return
name|txTime
operator|+
name|HT_L_STF
operator|+
name|HT_L_LTF
operator|+
name|HT_L_SIG
operator|+
name|HT_SIG
operator|+
name|HT_STF
operator|+
name|HT_LTF
argument_list|(
name|streams
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the time to transmit a frame of length frameLen bytes  * using the specified rate, phy, and short preamble setting.  */
end_comment

begin_function
name|uint16_t
name|ath_hal_computetxtime
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rates
parameter_list|,
name|uint32_t
name|frameLen
parameter_list|,
name|uint16_t
name|rateix
parameter_list|,
name|HAL_BOOL
name|shortPreamble
parameter_list|,
name|HAL_BOOL
name|includeSifs
parameter_list|)
block|{
name|uint32_t
name|bitsPerSymbol
decl_stmt|,
name|numBits
decl_stmt|,
name|numSymbols
decl_stmt|,
name|phyTime
decl_stmt|,
name|txTime
decl_stmt|;
name|uint32_t
name|kbps
decl_stmt|;
comment|/* Warn if this function is called for 11n rates; it should not be! */
if|if
condition|(
name|IS_HT_RATE
argument_list|(
name|rates
operator|->
name|info
index|[
name|rateix
index|]
operator|.
name|rateCode
argument_list|)
condition|)
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"%s: MCS rate? (index %d; hwrate 0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|rateix
argument_list|,
name|rates
operator|->
name|info
index|[
name|rateix
index|]
operator|.
name|rateCode
argument_list|)
expr_stmt|;
name|kbps
operator|=
name|rates
operator|->
name|info
index|[
name|rateix
index|]
operator|.
name|rateKbps
expr_stmt|;
comment|/* 	 * index can be invalid during dynamic Turbo transitions.  	 * XXX 	 */
if|if
condition|(
name|kbps
operator|==
literal|0
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|rates
operator|->
name|info
index|[
name|rateix
index|]
operator|.
name|phy
condition|)
block|{
case|case
name|IEEE80211_T_CCK
case|:
name|phyTime
operator|=
name|CCK_PREAMBLE_BITS
operator|+
name|CCK_PLCP_BITS
expr_stmt|;
if|if
condition|(
name|shortPreamble
operator|&&
name|rates
operator|->
name|info
index|[
name|rateix
index|]
operator|.
name|shortPreamble
condition|)
name|phyTime
operator|>>=
literal|1
expr_stmt|;
name|numBits
operator|=
name|frameLen
operator|<<
literal|3
expr_stmt|;
name|txTime
operator|=
name|phyTime
operator|+
operator|(
operator|(
name|numBits
operator|*
literal|1000
operator|)
operator|/
name|kbps
operator|)
expr_stmt|;
if|if
condition|(
name|includeSifs
condition|)
name|txTime
operator|+=
name|CCK_SIFS_TIME
expr_stmt|;
break|break;
case|case
name|IEEE80211_T_OFDM
case|:
name|bitsPerSymbol
operator|=
operator|(
name|kbps
operator|*
name|OFDM_SYMBOL_TIME
operator|)
operator|/
literal|1000
expr_stmt|;
name|HALASSERT
argument_list|(
name|bitsPerSymbol
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|numBits
operator|=
name|OFDM_PLCP_BITS
operator|+
operator|(
name|frameLen
operator|<<
literal|3
operator|)
expr_stmt|;
name|numSymbols
operator|=
name|howmany
argument_list|(
name|numBits
argument_list|,
name|bitsPerSymbol
argument_list|)
expr_stmt|;
name|txTime
operator|=
name|OFDM_PREAMBLE_TIME
operator|+
operator|(
name|numSymbols
operator|*
name|OFDM_SYMBOL_TIME
operator|)
expr_stmt|;
if|if
condition|(
name|includeSifs
condition|)
name|txTime
operator|+=
name|OFDM_SIFS_TIME
expr_stmt|;
break|break;
case|case
name|IEEE80211_T_OFDM_HALF
case|:
name|bitsPerSymbol
operator|=
operator|(
name|kbps
operator|*
name|OFDM_HALF_SYMBOL_TIME
operator|)
operator|/
literal|1000
expr_stmt|;
name|HALASSERT
argument_list|(
name|bitsPerSymbol
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|numBits
operator|=
name|OFDM_HALF_PLCP_BITS
operator|+
operator|(
name|frameLen
operator|<<
literal|3
operator|)
expr_stmt|;
name|numSymbols
operator|=
name|howmany
argument_list|(
name|numBits
argument_list|,
name|bitsPerSymbol
argument_list|)
expr_stmt|;
name|txTime
operator|=
name|OFDM_HALF_PREAMBLE_TIME
operator|+
operator|(
name|numSymbols
operator|*
name|OFDM_HALF_SYMBOL_TIME
operator|)
expr_stmt|;
if|if
condition|(
name|includeSifs
condition|)
name|txTime
operator|+=
name|OFDM_HALF_SIFS_TIME
expr_stmt|;
break|break;
case|case
name|IEEE80211_T_OFDM_QUARTER
case|:
name|bitsPerSymbol
operator|=
operator|(
name|kbps
operator|*
name|OFDM_QUARTER_SYMBOL_TIME
operator|)
operator|/
literal|1000
expr_stmt|;
name|HALASSERT
argument_list|(
name|bitsPerSymbol
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|numBits
operator|=
name|OFDM_QUARTER_PLCP_BITS
operator|+
operator|(
name|frameLen
operator|<<
literal|3
operator|)
expr_stmt|;
name|numSymbols
operator|=
name|howmany
argument_list|(
name|numBits
argument_list|,
name|bitsPerSymbol
argument_list|)
expr_stmt|;
name|txTime
operator|=
name|OFDM_QUARTER_PREAMBLE_TIME
operator|+
operator|(
name|numSymbols
operator|*
name|OFDM_QUARTER_SYMBOL_TIME
operator|)
expr_stmt|;
if|if
condition|(
name|includeSifs
condition|)
name|txTime
operator|+=
name|OFDM_QUARTER_SIFS_TIME
expr_stmt|;
break|break;
case|case
name|IEEE80211_T_TURBO
case|:
name|bitsPerSymbol
operator|=
operator|(
name|kbps
operator|*
name|TURBO_SYMBOL_TIME
operator|)
operator|/
literal|1000
expr_stmt|;
name|HALASSERT
argument_list|(
name|bitsPerSymbol
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|numBits
operator|=
name|TURBO_PLCP_BITS
operator|+
operator|(
name|frameLen
operator|<<
literal|3
operator|)
expr_stmt|;
name|numSymbols
operator|=
name|howmany
argument_list|(
name|numBits
argument_list|,
name|bitsPerSymbol
argument_list|)
expr_stmt|;
name|txTime
operator|=
name|TURBO_PREAMBLE_TIME
operator|+
operator|(
name|numSymbols
operator|*
name|TURBO_SYMBOL_TIME
operator|)
expr_stmt|;
if|if
condition|(
name|includeSifs
condition|)
name|txTime
operator|+=
name|TURBO_SIFS_TIME
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PHYIO
argument_list|,
literal|"%s: unknown phy %u (rate ix %u)\n"
argument_list|,
name|__func__
argument_list|,
name|rates
operator|->
name|info
index|[
name|rateix
index|]
operator|.
name|phy
argument_list|,
name|rateix
argument_list|)
expr_stmt|;
name|txTime
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|txTime
return|;
block|}
end_function

begin_function
name|int
name|ath_hal_get_curmode
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
comment|/* 	 * Pick a default mode at bootup. A channel change is inevitable. 	 */
if|if
condition|(
operator|!
name|chan
condition|)
return|return
name|HAL_MODE_11NG_HT20
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|HAL_MODE_TURBO
return|;
comment|/* check for NA_HT before plain A, since IS_CHAN_A includes NA_HT */
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
operator|&&
name|IEEE80211_IS_CHAN_HT20
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|HAL_MODE_11NA_HT20
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
operator|&&
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|HAL_MODE_11NA_HT40PLUS
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
operator|&&
name|IEEE80211_IS_CHAN_HT40D
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|HAL_MODE_11NA_HT40MINUS
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|HAL_MODE_11A
return|;
comment|/* check for NG_HT before plain G, since IS_CHAN_G includes NG_HT */
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
operator|&&
name|IEEE80211_IS_CHAN_HT20
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|HAL_MODE_11NG_HT20
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
operator|&&
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|HAL_MODE_11NG_HT40PLUS
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
operator|&&
name|IEEE80211_IS_CHAN_HT40D
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|HAL_MODE_11NG_HT40MINUS
return|;
comment|/* 	 * XXX For FreeBSD, will this work correctly given the DYN 	 * chan mode (OFDM+CCK dynamic) ? We have pure-G versions DYN-BG.. 	 */
if|if
condition|(
name|IEEE80211_IS_CHAN_G
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|HAL_MODE_11G
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|HAL_MODE_11B
return|;
name|HALASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|HAL_MODE_11NG_HT20
return|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
block|{
name|WIRELESS_MODE_11a
init|=
literal|0
block|,
name|WIRELESS_MODE_TURBO
init|=
literal|1
block|,
name|WIRELESS_MODE_11b
init|=
literal|2
block|,
name|WIRELESS_MODE_11g
init|=
literal|3
block|,
name|WIRELESS_MODE_108g
init|=
literal|4
block|,
name|WIRELESS_MODE_MAX
block|}
name|WIRELESS_MODE
typedef|;
end_typedef

begin_comment
comment|/*  * XXX TODO: for some (?) chips, an 11b mode still runs at 11bg.  * Maybe AR5211 has separate 11b and 11g only modes, so 11b is 22MHz  * and 11g is 44MHz, but AR5416 and later run 11b in 11bg mode, right?  */
end_comment

begin_function
specifier|static
name|WIRELESS_MODE
name|ath_hal_chan2wmode
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|WIRELESS_MODE_11b
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_G
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|WIRELESS_MODE_11g
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_108G
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|WIRELESS_MODE_108g
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|WIRELESS_MODE_TURBO
return|;
return|return
name|WIRELESS_MODE_11a
return|;
block|}
end_function

begin_comment
comment|/*  * Convert between microseconds and core system clocks.  */
end_comment

begin_comment
comment|/* 11a Turbo  11b  11g  108g */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|CLOCK_RATE
index|[]
init|=
block|{
literal|40
block|,
literal|80
block|,
literal|22
block|,
literal|44
block|,
literal|88
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CLOCK_FAST_RATE_5GHZ_OFDM
value|44
end_define

begin_function
name|u_int
name|ath_hal_mac_clks
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|usecs
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
decl_stmt|;
name|u_int
name|clks
decl_stmt|;
comment|/* NB: ah_curchan may be null when called attach time */
comment|/* XXX merlin and later specific workaround - 5ghz fast clock is 44 */
if|if
condition|(
name|c
operator|!=
name|AH_NULL
operator|&&
name|IS_5GHZ_FAST_CLOCK_EN
argument_list|(
name|ah
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|clks
operator|=
name|usecs
operator|*
name|CLOCK_FAST_RATE_5GHZ_OFDM
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|c
argument_list|)
condition|)
name|clks
operator|<<=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
name|AH_NULL
condition|)
block|{
name|clks
operator|=
name|usecs
operator|*
name|CLOCK_RATE
index|[
name|ath_hal_chan2wmode
argument_list|(
name|ah
argument_list|,
name|c
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|c
argument_list|)
condition|)
name|clks
operator|<<=
literal|1
expr_stmt|;
block|}
else|else
name|clks
operator|=
name|usecs
operator|*
name|CLOCK_RATE
index|[
name|WIRELESS_MODE_11b
index|]
expr_stmt|;
comment|/* Compensate for half/quarter rate */
if|if
condition|(
name|c
operator|!=
name|AH_NULL
operator|&&
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|c
argument_list|)
condition|)
name|clks
operator|=
name|clks
operator|/
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
name|AH_NULL
operator|&&
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|c
argument_list|)
condition|)
name|clks
operator|=
name|clks
operator|/
literal|4
expr_stmt|;
return|return
name|clks
return|;
block|}
end_function

begin_function
name|u_int
name|ath_hal_mac_usec
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|clks
parameter_list|)
block|{
name|uint64_t
name|psec
decl_stmt|;
name|psec
operator|=
name|ath_hal_mac_psec
argument_list|(
name|ah
argument_list|,
name|clks
argument_list|)
expr_stmt|;
return|return
operator|(
name|psec
operator|/
literal|1000000
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX TODO: half, quarter rates.  */
end_comment

begin_function
name|uint64_t
name|ath_hal_mac_psec
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|clks
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
decl_stmt|;
name|uint64_t
name|psec
decl_stmt|;
comment|/* NB: ah_curchan may be null when called attach time */
comment|/* XXX merlin and later specific workaround - 5ghz fast clock is 44 */
if|if
condition|(
name|c
operator|!=
name|AH_NULL
operator|&&
name|IS_5GHZ_FAST_CLOCK_EN
argument_list|(
name|ah
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|psec
operator|=
operator|(
name|clks
operator|*
literal|1000000ULL
operator|)
operator|/
name|CLOCK_FAST_RATE_5GHZ_OFDM
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|c
argument_list|)
condition|)
name|psec
operator|>>=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
name|AH_NULL
condition|)
block|{
name|psec
operator|=
operator|(
name|clks
operator|*
literal|1000000ULL
operator|)
operator|/
name|CLOCK_RATE
index|[
name|ath_hal_chan2wmode
argument_list|(
name|ah
argument_list|,
name|c
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|c
argument_list|)
condition|)
name|psec
operator|>>=
literal|1
expr_stmt|;
block|}
else|else
name|psec
operator|=
operator|(
name|clks
operator|*
literal|1000000ULL
operator|)
operator|/
name|CLOCK_RATE
index|[
name|WIRELESS_MODE_11b
index|]
expr_stmt|;
return|return
name|psec
return|;
block|}
end_function

begin_comment
comment|/*  * Setup a h/w rate table's reverse lookup table and  * fill in ack durations.  This routine is called for  * each rate table returned through the ah_getRateTable  * method.  The reverse lookup tables are assumed to be  * initialized to zero (or at least the first entry).  * We use this as a key that indicates whether or not  * we've previously setup the reverse lookup table.  *  * XXX not reentrant, but shouldn't matter  */
end_comment

begin_function
name|void
name|ath_hal_setupratetable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_RATE_TABLE
modifier|*
name|rt
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|int
name|i
decl_stmt|;
if|if
condition|(
name|rt
operator|->
name|rateCodeToIndex
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
comment|/* already setup */
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|rt
operator|->
name|rateCodeToIndex
argument_list|)
condition|;
name|i
operator|++
control|)
name|rt
operator|->
name|rateCodeToIndex
index|[
name|i
index|]
operator|=
operator|(
name|uint8_t
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rt
operator|->
name|rateCount
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
name|code
init|=
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|rateCode
decl_stmt|;
name|uint8_t
name|cix
init|=
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|controlRate
decl_stmt|;
name|HALASSERT
argument_list|(
name|code
operator|<
name|N
argument_list|(
name|rt
operator|->
name|rateCodeToIndex
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rateCodeToIndex
index|[
name|code
index|]
operator|=
name|i
expr_stmt|;
name|HALASSERT
argument_list|(
operator|(
name|code
operator||
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|shortPreamble
operator|)
operator|<
name|N
argument_list|(
name|rt
operator|->
name|rateCodeToIndex
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rateCodeToIndex
index|[
name|code
operator||
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|shortPreamble
index|]
operator|=
name|i
expr_stmt|;
comment|/* 		 * XXX for 11g the control rate to use for 5.5 and 11 Mb/s 		 *     depends on whether they are marked as basic rates; 		 *     the static tables are setup with an 11b-compatible 		 *     2Mb/s rate which will work but is suboptimal 		 */
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|lpAckDuration
operator|=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|WLAN_CTRL_FRAME_SIZE
argument_list|,
name|cix
argument_list|,
name|AH_FALSE
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|spAckDuration
operator|=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|WLAN_CTRL_FRAME_SIZE
argument_list|,
name|cix
argument_list|,
name|AH_TRUE
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|N
block|}
end_function

begin_function
name|HAL_STATUS
name|ath_hal_getcapability
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CAPABILITY_TYPE
name|type
parameter_list|,
name|uint32_t
name|capability
parameter_list|,
name|uint32_t
modifier|*
name|result
parameter_list|)
block|{
specifier|const
name|HAL_CAPABILITIES
modifier|*
name|pCap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|HAL_CAP_REG_DMN
case|:
comment|/* regulatory domain */
operator|*
name|result
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_currentRD
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_DFS_DMN
case|:
comment|/* DFS Domain */
operator|*
name|result
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_dfsDomain
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_CIPHER
case|:
comment|/* cipher handled in hardware */
case|case
name|HAL_CAP_TKIP_MIC
case|:
comment|/* handle TKIP MIC in hardware */
return|return
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_TKIP_SPLIT
case|:
comment|/* hardware TKIP uses split keys */
return|return
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_PHYCOUNTERS
case|:
comment|/* hardware PHY error counters */
return|return
name|pCap
operator|->
name|halHwPhyCounterSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENXIO
return|;
case|case
name|HAL_CAP_WME_TKIPMIC
case|:
comment|/* hardware can do TKIP MIC when WMM is turned on */
return|return
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_DIVERSITY
case|:
comment|/* hardware supports fast diversity */
return|return
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_KEYCACHE_SIZE
case|:
comment|/* hardware key cache size */
operator|*
name|result
operator|=
name|pCap
operator|->
name|halKeyCacheSize
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_NUM_TXQUEUES
case|:
comment|/* number of hardware tx queues */
operator|*
name|result
operator|=
name|pCap
operator|->
name|halTotalQueues
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_VEOL
case|:
comment|/* hardware supports virtual EOL */
return|return
name|pCap
operator|->
name|halVEOLSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_PSPOLL
case|:
comment|/* hardware PS-Poll support works */
return|return
name|pCap
operator|->
name|halPSPollBroken
condition|?
name|HAL_ENOTSUPP
else|:
name|HAL_OK
return|;
case|case
name|HAL_CAP_COMPRESSION
case|:
return|return
name|pCap
operator|->
name|halCompressSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_BURST
case|:
return|return
name|pCap
operator|->
name|halBurstSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_FASTFRAME
case|:
return|return
name|pCap
operator|->
name|halFastFramesSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_DIAG
case|:
comment|/* hardware diagnostic support */
operator|*
name|result
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diagreg
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_TXPOW
case|:
comment|/* global tx power limit  */
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
literal|0
case|:
comment|/* facility is supported */
return|return
name|HAL_OK
return|;
case|case
literal|1
case|:
comment|/* current limit */
operator|*
name|result
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_powerLimit
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
literal|2
case|:
comment|/* current max tx power */
operator|*
name|result
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_maxPowerLevel
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
literal|3
case|:
comment|/* scale factor */
operator|*
name|result
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tpScale
expr_stmt|;
return|return
name|HAL_OK
return|;
block|}
return|return
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_BSSIDMASK
case|:
comment|/* hardware supports bssid mask */
return|return
name|pCap
operator|->
name|halBssIdMaskSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_MCAST_KEYSRCH
case|:
comment|/* multicast frame keycache search */
return|return
name|pCap
operator|->
name|halMcastKeySrchSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_TSF_ADJUST
case|:
comment|/* hardware has beacon tsf adjust */
return|return
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_RFSILENT
case|:
comment|/* rfsilent support  */
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
literal|0
case|:
comment|/* facility is supported */
return|return
name|pCap
operator|->
name|halRfSilentSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
literal|1
case|:
comment|/* current setting */
return|return
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rfkillEnabled
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
literal|2
case|:
comment|/* rfsilent config */
operator|*
name|result
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rfsilent
expr_stmt|;
return|return
name|HAL_OK
return|;
block|}
return|return
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_11D
case|:
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_HT
case|:
return|return
name|pCap
operator|->
name|halHTSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_GTXTO
case|:
return|return
name|pCap
operator|->
name|halGTTSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_FAST_CC
case|:
return|return
name|pCap
operator|->
name|halFastCCSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_TX_CHAINMASK
case|:
comment|/* mask of TX chains supported */
operator|*
name|result
operator|=
name|pCap
operator|->
name|halTxChainMask
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_RX_CHAINMASK
case|:
comment|/* mask of RX chains supported */
operator|*
name|result
operator|=
name|pCap
operator|->
name|halRxChainMask
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_NUM_GPIO_PINS
case|:
operator|*
name|result
operator|=
name|pCap
operator|->
name|halNumGpioPins
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_CST
case|:
return|return
name|pCap
operator|->
name|halCSTSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_RTS_AGGR_LIMIT
case|:
operator|*
name|result
operator|=
name|pCap
operator|->
name|halRtsAggrLimit
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_4ADDR_AGGR
case|:
return|return
name|pCap
operator|->
name|hal4AddrAggrSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_EXT_CHAN_DFS
case|:
return|return
name|pCap
operator|->
name|halExtChanDfsSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_RX_STBC
case|:
return|return
name|pCap
operator|->
name|halRxStbcSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_TX_STBC
case|:
return|return
name|pCap
operator|->
name|halTxStbcSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_COMBINED_RADAR_RSSI
case|:
return|return
name|pCap
operator|->
name|halUseCombinedRadarRssi
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_AUTO_SLEEP
case|:
return|return
name|pCap
operator|->
name|halAutoSleepSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_MBSSID_AGGR_SUPPORT
case|:
return|return
name|pCap
operator|->
name|halMbssidAggrSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_SPLIT_4KB_TRANS
case|:
comment|/* hardware handles descriptors straddling 4k page boundary */
return|return
name|pCap
operator|->
name|hal4kbSplitTransSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_REG_FLAG
case|:
operator|*
name|result
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_currentRDext
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_ENHANCED_DMA_SUPPORT
case|:
return|return
name|pCap
operator|->
name|halEnhancedDmaSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_NUM_TXMAPS
case|:
operator|*
name|result
operator|=
name|pCap
operator|->
name|halNumTxMaps
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_TXDESCLEN
case|:
operator|*
name|result
operator|=
name|pCap
operator|->
name|halTxDescLen
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_TXSTATUSLEN
case|:
operator|*
name|result
operator|=
name|pCap
operator|->
name|halTxStatusLen
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_RXSTATUSLEN
case|:
operator|*
name|result
operator|=
name|pCap
operator|->
name|halRxStatusLen
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_RXFIFODEPTH
case|:
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
name|HAL_RX_QUEUE_HP
case|:
operator|*
name|result
operator|=
name|pCap
operator|->
name|halRxHpFifoDepth
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_RX_QUEUE_LP
case|:
operator|*
name|result
operator|=
name|pCap
operator|->
name|halRxLpFifoDepth
expr_stmt|;
return|return
name|HAL_OK
return|;
default|default:
return|return
name|HAL_ENOTSUPP
return|;
block|}
case|case
name|HAL_CAP_RXBUFSIZE
case|:
case|case
name|HAL_CAP_NUM_MR_RETRIES
case|:
operator|*
name|result
operator|=
name|pCap
operator|->
name|halNumMRRetries
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_BT_COEX
case|:
return|return
name|pCap
operator|->
name|halBtCoexSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_SPECTRAL_SCAN
case|:
return|return
name|pCap
operator|->
name|halSpectralScanSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_HT20_SGI
case|:
return|return
name|pCap
operator|->
name|halHTSGI20Support
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_RXTSTAMP_PREC
case|:
comment|/* rx desc tstamp precision (bits) */
operator|*
name|result
operator|=
name|pCap
operator|->
name|halRxTstampPrecision
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_ANT_DIV_COMB
case|:
comment|/* AR9285/AR9485 LNA diversity */
return|return
name|pCap
operator|->
name|halAntDivCombSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_ENHANCED_DFS_SUPPORT
case|:
return|return
name|pCap
operator|->
name|halEnhancedDfsSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
comment|/* FreeBSD-specific entries for now */
case|case
name|HAL_CAP_RXORN_FATAL
case|:
comment|/* HAL_INT_RXORN treated as fatal  */
return|return
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rxornIsFatal
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_INTRMASK
case|:
comment|/* mask of supported interrupts */
operator|*
name|result
operator|=
name|pCap
operator|->
name|halIntrMask
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_BSSIDMATCH
case|:
comment|/* hardware has disable bssid match */
return|return
name|pCap
operator|->
name|halBssidMatchSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_STREAMS
case|:
comment|/* number of 11n spatial streams */
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
literal|0
case|:
comment|/* TX */
operator|*
name|result
operator|=
name|pCap
operator|->
name|halTxStreams
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
literal|1
case|:
comment|/* RX */
operator|*
name|result
operator|=
name|pCap
operator|->
name|halRxStreams
expr_stmt|;
return|return
name|HAL_OK
return|;
default|default:
return|return
name|HAL_ENOTSUPP
return|;
block|}
case|case
name|HAL_CAP_RXDESC_SELFLINK
case|:
comment|/* hardware supports self-linked final RX descriptors correctly */
return|return
name|pCap
operator|->
name|halHasRxSelfLinkedTail
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_BB_READ_WAR
case|:
comment|/* Baseband read WAR */
return|return
name|pCap
operator|->
name|halHasBBReadWar
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_SERIALISE_WAR
case|:
comment|/* PCI register serialisation */
return|return
name|pCap
operator|->
name|halSerialiseRegWar
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_MFP
case|:
comment|/* Management frame protection setting */
operator|*
name|result
operator|=
name|pCap
operator|->
name|halMfpSupport
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_RX_LNA_MIXING
case|:
comment|/* Hardware uses an RX LNA mixer to map 2 antennas to a 1 stream receiver */
return|return
name|pCap
operator|->
name|halRxUsingLnaMixing
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_DO_MYBEACON
case|:
comment|/* Hardware supports filtering my-beacons */
return|return
name|pCap
operator|->
name|halRxDoMyBeacon
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_TXTSTAMP_PREC
case|:
comment|/* tx desc tstamp precision (bits) */
operator|*
name|result
operator|=
name|pCap
operator|->
name|halTxTstampPrecision
expr_stmt|;
return|return
name|HAL_OK
return|;
default|default:
return|return
name|HAL_EINVAL
return|;
block|}
block|}
end_function

begin_function
name|HAL_BOOL
name|ath_hal_setcapability
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CAPABILITY_TYPE
name|type
parameter_list|,
name|uint32_t
name|capability
parameter_list|,
name|uint32_t
name|setting
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|HAL_CAP_TXPOW
case|:
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|setting
operator|<=
name|HAL_TP_SCALE_MIN
condition|)
block|{
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tpScale
operator|=
name|setting
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
break|break;
block|}
break|break;
case|case
name|HAL_CAP_RFSILENT
case|:
comment|/* rfsilent support  */
comment|/* 		 * NB: allow even if halRfSilentSupport is false 		 *     in case the EEPROM is misprogrammed. 		 */
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
literal|1
case|:
comment|/* current setting */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rfkillEnabled
operator|=
operator|(
name|setting
operator|!=
literal|0
operator|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
literal|2
case|:
comment|/* rfsilent config */
comment|/* XXX better done per-chip for validation? */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rfsilent
operator|=
name|setting
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
break|break;
case|case
name|HAL_CAP_REG_DMN
case|:
comment|/* regulatory domain */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_currentRD
operator|=
name|setting
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_CAP_RXORN_FATAL
case|:
comment|/* HAL_INT_RXORN treated as fatal  */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rxornIsFatal
operator|=
name|setting
expr_stmt|;
return|return
name|AH_TRUE
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|status
condition|)
operator|*
name|status
operator|=
name|HAL_EINVAL
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/*   * Common support for getDiagState method.  */
end_comment

begin_function
specifier|static
name|u_int
name|ath_hal_getregdump
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_REGRANGE
modifier|*
name|regs
parameter_list|,
name|void
modifier|*
name|dstbuf
parameter_list|,
name|int
name|space
parameter_list|)
block|{
name|uint32_t
modifier|*
name|dp
init|=
name|dstbuf
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|space
operator|>=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|r
init|=
name|regs
index|[
name|i
index|]
operator|.
name|start
decl_stmt|;
name|uint32_t
name|e
init|=
name|regs
index|[
name|i
index|]
operator|.
name|end
decl_stmt|;
operator|*
name|dp
operator|++
operator|=
name|r
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
name|e
expr_stmt|;
name|space
operator|-=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
do|do
block|{
operator|*
name|dp
operator|++
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|r
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|space
operator|-=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|r
operator|<=
name|e
operator|&&
name|space
operator|>=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
do|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|dp
operator|-
operator|(
name|char
operator|*
operator|)
name|dstbuf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_hal_setregs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_REGWRITE
modifier|*
name|regs
parameter_list|,
name|int
name|space
parameter_list|)
block|{
while|while
condition|(
name|space
operator|>=
sizeof|sizeof
argument_list|(
name|HAL_REGWRITE
argument_list|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|regs
operator|->
name|addr
argument_list|,
name|regs
operator|->
name|value
argument_list|)
expr_stmt|;
name|regs
operator|++
operator|,
name|space
operator|-=
sizeof|sizeof
argument_list|(
name|HAL_REGWRITE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|HAL_BOOL
name|ath_hal_getdiagstate
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|request
parameter_list|,
specifier|const
name|void
modifier|*
name|args
parameter_list|,
name|uint32_t
name|argsize
parameter_list|,
name|void
modifier|*
modifier|*
name|result
parameter_list|,
name|uint32_t
modifier|*
name|resultsize
parameter_list|)
block|{
switch|switch
condition|(
name|request
condition|)
block|{
case|case
name|HAL_DIAG_REVS
case|:
operator|*
name|result
operator|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_devid
expr_stmt|;
operator|*
name|resultsize
operator|=
sizeof|sizeof
argument_list|(
name|HAL_REVS
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_DIAG_REGS
case|:
operator|*
name|resultsize
operator|=
name|ath_hal_getregdump
argument_list|(
name|ah
argument_list|,
name|args
argument_list|,
operator|*
name|result
argument_list|,
operator|*
name|resultsize
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_DIAG_SETREGS
case|:
name|ath_hal_setregs
argument_list|(
name|ah
argument_list|,
name|args
argument_list|,
name|argsize
argument_list|)
expr_stmt|;
operator|*
name|resultsize
operator|=
literal|0
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_DIAG_FATALERR
case|:
operator|*
name|result
operator|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_fatalState
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|resultsize
operator|=
sizeof|sizeof
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_fatalState
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_DIAG_EEREAD
case|:
if|if
condition|(
name|argsize
operator|!=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
if|if
condition|(
operator|!
name|ath_hal_eepromRead
argument_list|(
name|ah
argument_list|,
operator|*
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|args
argument_list|,
operator|*
name|result
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
operator|*
name|resultsize
operator|=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
ifdef|#
directive|ifdef
name|AH_PRIVATE_DIAG
case|case
name|HAL_DIAG_SETKEY
case|:
block|{
specifier|const
name|HAL_DIAG_KEYVAL
modifier|*
name|dk
decl_stmt|;
if|if
condition|(
name|argsize
operator|!=
sizeof|sizeof
argument_list|(
name|HAL_DIAG_KEYVAL
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
name|dk
operator|=
operator|(
specifier|const
name|HAL_DIAG_KEYVAL
operator|*
operator|)
name|args
expr_stmt|;
return|return
name|ah
operator|->
name|ah_setKeyCacheEntry
argument_list|(
name|ah
argument_list|,
name|dk
operator|->
name|dk_keyix
argument_list|,
operator|&
name|dk
operator|->
name|dk_keyval
argument_list|,
name|dk
operator|->
name|dk_mac
argument_list|,
name|dk
operator|->
name|dk_xor
argument_list|)
return|;
block|}
case|case
name|HAL_DIAG_RESETKEY
case|:
if|if
condition|(
name|argsize
operator|!=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
return|return
name|ah
operator|->
name|ah_resetKeyCacheEntry
argument_list|(
name|ah
argument_list|,
operator|*
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|args
argument_list|)
return|;
ifdef|#
directive|ifdef
name|AH_SUPPORT_WRITE_EEPROM
case|case
name|HAL_DIAG_EEWRITE
case|:
block|{
specifier|const
name|HAL_DIAG_EEVAL
modifier|*
name|ee
decl_stmt|;
if|if
condition|(
name|argsize
operator|!=
sizeof|sizeof
argument_list|(
name|HAL_DIAG_EEVAL
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
name|ee
operator|=
operator|(
specifier|const
name|HAL_DIAG_EEVAL
operator|*
operator|)
name|args
expr_stmt|;
return|return
name|ath_hal_eepromWrite
argument_list|(
name|ah
argument_list|,
name|ee
operator|->
name|ee_off
argument_list|,
name|ee
operator|->
name|ee_data
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* AH_SUPPORT_WRITE_EEPROM */
endif|#
directive|endif
comment|/* AH_PRIVATE_DIAG */
case|case
name|HAL_DIAG_11NCOMPAT
case|:
if|if
condition|(
name|argsize
operator|==
literal|0
condition|)
block|{
operator|*
name|resultsize
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|*
name|result
operator|)
operator|)
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_11nCompat
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argsize
operator|==
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_11nCompat
operator|=
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|args
expr_stmt|;
block|}
else|else
return|return
name|AH_FALSE
return|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_DIAG_CHANSURVEY
case|:
operator|*
name|result
operator|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_chansurvey
expr_stmt|;
operator|*
name|resultsize
operator|=
sizeof|sizeof
argument_list|(
name|HAL_CHANNEL_SURVEY
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Set the properties of the tx queue with the parameters  * from qInfo.  */
end_comment

begin_function
name|HAL_BOOL
name|ath_hal_setTxQProps
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_TX_QUEUE_INFO
modifier|*
name|qi
parameter_list|,
specifier|const
name|HAL_TXQ_INFO
modifier|*
name|qInfo
parameter_list|)
block|{
name|uint32_t
name|cw
decl_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_type
operator|==
name|HAL_TX_QUEUE_INACTIVE
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_TXQUEUE
argument_list|,
literal|"%s: inactive queue\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* XXX validate parameters */
name|qi
operator|->
name|tqi_ver
operator|=
name|qInfo
operator|->
name|tqi_ver
expr_stmt|;
name|qi
operator|->
name|tqi_subtype
operator|=
name|qInfo
operator|->
name|tqi_subtype
expr_stmt|;
name|qi
operator|->
name|tqi_qflags
operator|=
name|qInfo
operator|->
name|tqi_qflags
expr_stmt|;
name|qi
operator|->
name|tqi_priority
operator|=
name|qInfo
operator|->
name|tqi_priority
expr_stmt|;
if|if
condition|(
name|qInfo
operator|->
name|tqi_aifs
operator|!=
name|HAL_TXQ_USEDEFAULT
condition|)
name|qi
operator|->
name|tqi_aifs
operator|=
name|AH_MIN
argument_list|(
name|qInfo
operator|->
name|tqi_aifs
argument_list|,
literal|255
argument_list|)
expr_stmt|;
else|else
name|qi
operator|->
name|tqi_aifs
operator|=
name|INIT_AIFS
expr_stmt|;
if|if
condition|(
name|qInfo
operator|->
name|tqi_cwmin
operator|!=
name|HAL_TXQ_USEDEFAULT
condition|)
block|{
name|cw
operator|=
name|AH_MIN
argument_list|(
name|qInfo
operator|->
name|tqi_cwmin
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
comment|/* make sure that the CWmin is of the form (2^n - 1) */
name|qi
operator|->
name|tqi_cwmin
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|qi
operator|->
name|tqi_cwmin
operator|<
name|cw
condition|)
name|qi
operator|->
name|tqi_cwmin
operator|=
operator|(
name|qi
operator|->
name|tqi_cwmin
operator|<<
literal|1
operator|)
operator||
literal|1
expr_stmt|;
block|}
else|else
name|qi
operator|->
name|tqi_cwmin
operator|=
name|qInfo
operator|->
name|tqi_cwmin
expr_stmt|;
if|if
condition|(
name|qInfo
operator|->
name|tqi_cwmax
operator|!=
name|HAL_TXQ_USEDEFAULT
condition|)
block|{
name|cw
operator|=
name|AH_MIN
argument_list|(
name|qInfo
operator|->
name|tqi_cwmax
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
comment|/* make sure that the CWmax is of the form (2^n - 1) */
name|qi
operator|->
name|tqi_cwmax
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|qi
operator|->
name|tqi_cwmax
operator|<
name|cw
condition|)
name|qi
operator|->
name|tqi_cwmax
operator|=
operator|(
name|qi
operator|->
name|tqi_cwmax
operator|<<
literal|1
operator|)
operator||
literal|1
expr_stmt|;
block|}
else|else
name|qi
operator|->
name|tqi_cwmax
operator|=
name|INIT_CWMAX
expr_stmt|;
comment|/* Set retry limit values */
if|if
condition|(
name|qInfo
operator|->
name|tqi_shretry
operator|!=
literal|0
condition|)
name|qi
operator|->
name|tqi_shretry
operator|=
name|AH_MIN
argument_list|(
name|qInfo
operator|->
name|tqi_shretry
argument_list|,
literal|15
argument_list|)
expr_stmt|;
else|else
name|qi
operator|->
name|tqi_shretry
operator|=
name|INIT_SH_RETRY
expr_stmt|;
if|if
condition|(
name|qInfo
operator|->
name|tqi_lgretry
operator|!=
literal|0
condition|)
name|qi
operator|->
name|tqi_lgretry
operator|=
name|AH_MIN
argument_list|(
name|qInfo
operator|->
name|tqi_lgretry
argument_list|,
literal|15
argument_list|)
expr_stmt|;
else|else
name|qi
operator|->
name|tqi_lgretry
operator|=
name|INIT_LG_RETRY
expr_stmt|;
name|qi
operator|->
name|tqi_cbrPeriod
operator|=
name|qInfo
operator|->
name|tqi_cbrPeriod
expr_stmt|;
name|qi
operator|->
name|tqi_cbrOverflowLimit
operator|=
name|qInfo
operator|->
name|tqi_cbrOverflowLimit
expr_stmt|;
name|qi
operator|->
name|tqi_burstTime
operator|=
name|qInfo
operator|->
name|tqi_burstTime
expr_stmt|;
name|qi
operator|->
name|tqi_readyTime
operator|=
name|qInfo
operator|->
name|tqi_readyTime
expr_stmt|;
switch|switch
condition|(
name|qInfo
operator|->
name|tqi_subtype
condition|)
block|{
case|case
name|HAL_WME_UPSD
case|:
if|if
condition|(
name|qi
operator|->
name|tqi_type
operator|==
name|HAL_TX_QUEUE_DATA
condition|)
name|qi
operator|->
name|tqi_intFlags
operator|=
name|HAL_TXQ_USE_LOCKOUT_BKOFF_DIS
expr_stmt|;
break|break;
default|default:
break|break;
comment|/* NB: silence compiler */
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ath_hal_getTxQProps
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_TXQ_INFO
modifier|*
name|qInfo
parameter_list|,
specifier|const
name|HAL_TX_QUEUE_INFO
modifier|*
name|qi
parameter_list|)
block|{
if|if
condition|(
name|qi
operator|->
name|tqi_type
operator|==
name|HAL_TX_QUEUE_INACTIVE
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_TXQUEUE
argument_list|,
literal|"%s: inactive queue\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|qInfo
operator|->
name|tqi_qflags
operator|=
name|qi
operator|->
name|tqi_qflags
expr_stmt|;
name|qInfo
operator|->
name|tqi_ver
operator|=
name|qi
operator|->
name|tqi_ver
expr_stmt|;
name|qInfo
operator|->
name|tqi_subtype
operator|=
name|qi
operator|->
name|tqi_subtype
expr_stmt|;
name|qInfo
operator|->
name|tqi_qflags
operator|=
name|qi
operator|->
name|tqi_qflags
expr_stmt|;
name|qInfo
operator|->
name|tqi_priority
operator|=
name|qi
operator|->
name|tqi_priority
expr_stmt|;
name|qInfo
operator|->
name|tqi_aifs
operator|=
name|qi
operator|->
name|tqi_aifs
expr_stmt|;
name|qInfo
operator|->
name|tqi_cwmin
operator|=
name|qi
operator|->
name|tqi_cwmin
expr_stmt|;
name|qInfo
operator|->
name|tqi_cwmax
operator|=
name|qi
operator|->
name|tqi_cwmax
expr_stmt|;
name|qInfo
operator|->
name|tqi_shretry
operator|=
name|qi
operator|->
name|tqi_shretry
expr_stmt|;
name|qInfo
operator|->
name|tqi_lgretry
operator|=
name|qi
operator|->
name|tqi_lgretry
expr_stmt|;
name|qInfo
operator|->
name|tqi_cbrPeriod
operator|=
name|qi
operator|->
name|tqi_cbrPeriod
expr_stmt|;
name|qInfo
operator|->
name|tqi_cbrOverflowLimit
operator|=
name|qi
operator|->
name|tqi_cbrOverflowLimit
expr_stmt|;
name|qInfo
operator|->
name|tqi_burstTime
operator|=
name|qi
operator|->
name|tqi_burstTime
expr_stmt|;
name|qInfo
operator|->
name|tqi_readyTime
operator|=
name|qi
operator|->
name|tqi_readyTime
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/* 11a Turbo  11b  11g  108g */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int16_t
name|NOISE_FLOOR
index|[]
init|=
block|{
operator|-
literal|96
block|,
operator|-
literal|93
block|,
operator|-
literal|98
block|,
operator|-
literal|96
block|,
operator|-
literal|93
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read the current channel noise floor and return.  * If nf cal hasn't finished, channel noise floor should be 0  * and we return a nominal value based on band and frequency.  *  * NB: This is a private routine used by per-chip code to  *     implement the ah_getChanNoise method.  */
end_comment

begin_function
name|int16_t
name|ath_hal_getChanNoise
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
decl_stmt|;
name|ichan
operator|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ichan
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"%s: invalid channel %u/0x%x; no mapping\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ichan
operator|->
name|rawNoiseFloor
operator|==
literal|0
condition|)
block|{
name|WIRELESS_MODE
name|mode
init|=
name|ath_hal_chan2wmode
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|HALASSERT
argument_list|(
name|mode
operator|<
name|WIRELESS_MODE_MAX
argument_list|)
expr_stmt|;
return|return
name|NOISE_FLOOR
index|[
name|mode
index|]
operator|+
name|ath_hal_getNfAdjust
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
return|;
block|}
else|else
return|return
name|ichan
operator|->
name|rawNoiseFloor
operator|+
name|ichan
operator|->
name|noiseFloorAdjust
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch the current setup of ctl/ext noise floor values.  *  * If the CHANNEL_MIMO_NF_VALID flag isn't set, the array is simply  * populated with values from NOISE_FLOOR[] + ath_hal_getNfAdjust().  *  * The caller must supply ctl/ext NF arrays which are at least  * AH_MAX_CHAINS entries long.  */
end_comment

begin_function
name|int
name|ath_hal_get_mimo_chan_noise
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|int16_t
modifier|*
name|nf_ctl
parameter_list|,
name|int16_t
modifier|*
name|nf_ext
parameter_list|)
block|{
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ichan
operator|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ichan
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"%s: invalid channel %u/0x%x; no mapping\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AH_MAX_CHAINS
condition|;
name|i
operator|++
control|)
block|{
name|nf_ctl
index|[
name|i
index|]
operator|=
name|nf_ext
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Return 0 if there's no valid MIMO values (yet) */
if|if
condition|(
operator|!
operator|(
name|ichan
operator|->
name|privFlags
operator|&
name|CHANNEL_MIMO_NF_VALID
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AH_MAX_CHAINS
condition|;
name|i
operator|++
control|)
block|{
name|nf_ctl
index|[
name|i
index|]
operator|=
name|nf_ext
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ichan
operator|->
name|rawNoiseFloor
operator|==
literal|0
condition|)
block|{
name|WIRELESS_MODE
name|mode
init|=
name|ath_hal_chan2wmode
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|HALASSERT
argument_list|(
name|mode
operator|<
name|WIRELESS_MODE_MAX
argument_list|)
expr_stmt|;
comment|/* 		 * See the comment below - this could cause issues for 		 * stations which have a very low RSSI, below the 		 * 'normalised' NF values in NOISE_FLOOR[]. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AH_MAX_CHAINS
condition|;
name|i
operator|++
control|)
block|{
name|nf_ctl
index|[
name|i
index|]
operator|=
name|nf_ext
index|[
name|i
index|]
operator|=
name|NOISE_FLOOR
index|[
name|mode
index|]
operator|+
name|ath_hal_getNfAdjust
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* 		 * The value returned here from a MIMO radio is presumed to be 		 * "good enough" as a NF calculation. As RSSI values are calculated 		 * against this, an adjusted NF may be higher than the RSSI value 		 * returned from a vary weak station, resulting in an obscenely 		 * high signal strength calculation being returned. 		 * 		 * This should be re-evaluated at a later date, along with any 		 * signal strength calculations which are made. Quite likely the 		 * RSSI values will need to be adjusted to ensure the calculations 		 * don't "wrap" when RSSI is less than the "adjusted" NF value. 		 * ("Adjust" here is via ichan->noiseFloorAdjust.) 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AH_MAX_CHAINS
condition|;
name|i
operator|++
control|)
block|{
name|nf_ctl
index|[
name|i
index|]
operator|=
name|ichan
operator|->
name|noiseFloorCtl
index|[
name|i
index|]
operator|+
name|ath_hal_getNfAdjust
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
expr_stmt|;
name|nf_ext
index|[
name|i
index|]
operator|=
name|ichan
operator|->
name|noiseFloorExt
index|[
name|i
index|]
operator|+
name|ath_hal_getNfAdjust
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process all valid raw noise floors into the dBm noise floor values.  * Though our device has no reference for a dBm noise floor, we perform  * a relative minimization of NF's based on the lowest NF found across a  * channel scan.  */
end_comment

begin_function
name|void
name|ath_hal_process_noisefloor
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|HAL_CHANNEL_INTERNAL
modifier|*
name|c
decl_stmt|;
name|int16_t
name|correct2
decl_stmt|,
name|correct5
decl_stmt|;
name|int16_t
name|lowest2
decl_stmt|,
name|lowest5
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*  	 * Find the lowest 2GHz and 5GHz noise floor values after adjusting 	 * for statistically recorded NF/channel deviation. 	 */
name|correct2
operator|=
name|lowest2
operator|=
literal|0
expr_stmt|;
name|correct5
operator|=
name|lowest5
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_nchan
condition|;
name|i
operator|++
control|)
block|{
name|WIRELESS_MODE
name|mode
decl_stmt|;
name|int16_t
name|nf
decl_stmt|;
name|c
operator|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|rawNoiseFloor
operator|>=
literal|0
condition|)
continue|continue;
comment|/* XXX can't identify proper mode */
name|mode
operator|=
name|IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|?
name|WIRELESS_MODE_11a
else|:
name|WIRELESS_MODE_11g
expr_stmt|;
name|nf
operator|=
name|c
operator|->
name|rawNoiseFloor
operator|+
name|NOISE_FLOOR
index|[
name|mode
index|]
operator|+
name|ath_hal_getNfAdjust
argument_list|(
name|ah
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|nf
operator|<
name|lowest5
condition|)
block|{
name|lowest5
operator|=
name|nf
expr_stmt|;
name|correct5
operator|=
name|NOISE_FLOOR
index|[
name|mode
index|]
operator|-
operator|(
name|c
operator|->
name|rawNoiseFloor
operator|+
name|ath_hal_getNfAdjust
argument_list|(
name|ah
argument_list|,
name|c
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|nf
operator|<
name|lowest2
condition|)
block|{
name|lowest2
operator|=
name|nf
expr_stmt|;
name|correct2
operator|=
name|NOISE_FLOOR
index|[
name|mode
index|]
operator|-
operator|(
name|c
operator|->
name|rawNoiseFloor
operator|+
name|ath_hal_getNfAdjust
argument_list|(
name|ah
argument_list|,
name|c
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Correct the channels to reach the expected NF value */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_nchan
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|rawNoiseFloor
operator|>=
literal|0
condition|)
continue|continue;
comment|/* Apply correction factor */
name|c
operator|->
name|noiseFloorAdjust
operator|=
name|ath_hal_getNfAdjust
argument_list|(
name|ah
argument_list|,
name|c
argument_list|)
operator|+
operator|(
name|IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|?
name|correct5
else|:
name|correct2
operator|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"%u raw nf %d adjust %d\n"
argument_list|,
name|c
operator|->
name|channel
argument_list|,
name|c
operator|->
name|rawNoiseFloor
argument_list|,
name|c
operator|->
name|noiseFloorAdjust
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * INI support routines.  */
end_comment

begin_function
name|int
name|ath_hal_ini_write
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_INI_ARRAY
modifier|*
name|ia
parameter_list|,
name|int
name|col
parameter_list|,
name|int
name|regWr
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|HALASSERT
argument_list|(
name|col
operator|<
name|ia
operator|->
name|cols
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|ia
operator|->
name|rows
condition|;
name|r
operator|++
control|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|HAL_INI_VAL
argument_list|(
name|ia
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
argument_list|,
name|HAL_INI_VAL
argument_list|(
name|ia
argument_list|,
name|r
argument_list|,
name|col
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Analog shift register delay seems needed for Merlin - PR kern/154220 */
if|if
condition|(
name|HAL_INI_VAL
argument_list|(
name|ia
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0x7800
operator|&&
name|HAL_INI_VAL
argument_list|(
name|ia
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
operator|<
literal|0x7900
condition|)
name|OS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|DMA_YIELD
argument_list|(
name|regWr
argument_list|)
expr_stmt|;
block|}
return|return
name|regWr
return|;
block|}
end_function

begin_function
name|void
name|ath_hal_ini_bank_setup
parameter_list|(
name|uint32_t
name|data
index|[]
parameter_list|,
specifier|const
name|HAL_INI_ARRAY
modifier|*
name|ia
parameter_list|,
name|int
name|col
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|HALASSERT
argument_list|(
name|col
operator|<
name|ia
operator|->
name|cols
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|ia
operator|->
name|rows
condition|;
name|r
operator|++
control|)
name|data
index|[
name|r
index|]
operator|=
name|HAL_INI_VAL
argument_list|(
name|ia
argument_list|,
name|r
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ath_hal_ini_bank_write
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_INI_ARRAY
modifier|*
name|ia
parameter_list|,
specifier|const
name|uint32_t
name|data
index|[]
parameter_list|,
name|int
name|regWr
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|ia
operator|->
name|rows
condition|;
name|r
operator|++
control|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|HAL_INI_VAL
argument_list|(
name|ia
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
argument_list|,
name|data
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|DMA_YIELD
argument_list|(
name|regWr
argument_list|)
expr_stmt|;
block|}
return|return
name|regWr
return|;
block|}
end_function

begin_comment
comment|/*  * These are EEPROM board related routines which should likely live in  * a helper library of some sort.  */
end_comment

begin_comment
comment|/**************************************************************  * ath_ee_getLowerUppderIndex  *  * Return indices surrounding the value in sorted integer lists.  * Requirement: the input list must be monotonically increasing  *     and populated up to the list size  * Returns: match is set if an index in the array matches exactly  *     or a the target is before or after the range of the array.  */
end_comment

begin_function
name|HAL_BOOL
name|ath_ee_getLowerUpperIndex
parameter_list|(
name|uint8_t
name|target
parameter_list|,
name|uint8_t
modifier|*
name|pList
parameter_list|,
name|uint16_t
name|listSize
parameter_list|,
name|uint16_t
modifier|*
name|indexL
parameter_list|,
name|uint16_t
modifier|*
name|indexR
parameter_list|)
block|{
name|uint16_t
name|i
decl_stmt|;
comment|/*      * Check first and last elements for beyond ordered array cases.      */
if|if
condition|(
name|target
operator|<=
name|pList
index|[
literal|0
index|]
condition|)
block|{
operator|*
name|indexL
operator|=
operator|*
name|indexR
operator|=
literal|0
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
if|if
condition|(
name|target
operator|>=
name|pList
index|[
name|listSize
operator|-
literal|1
index|]
condition|)
block|{
operator|*
name|indexL
operator|=
operator|*
name|indexR
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|listSize
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
comment|/* look for value being near or between 2 values in list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|listSize
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
comment|/*          * If value is close to the current value of the list          * then target is not between values, it is one of the values          */
if|if
condition|(
name|pList
index|[
name|i
index|]
operator|==
name|target
condition|)
block|{
operator|*
name|indexL
operator|=
operator|*
name|indexR
operator|=
name|i
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
comment|/*          * Look for value being between current value and next value          * if so return these 2 values          */
if|if
condition|(
name|target
operator|<
name|pList
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
operator|*
name|indexL
operator|=
name|i
expr_stmt|;
operator|*
name|indexR
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
block|}
name|HALASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|indexL
operator|=
operator|*
name|indexR
operator|=
literal|0
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/**************************************************************  * ath_ee_FillVpdTable  *  * Fill the Vpdlist for indices Pmax-Pmin  * Note: pwrMin, pwrMax and Vpdlist are all in dBm * 4  */
end_comment

begin_function
name|HAL_BOOL
name|ath_ee_FillVpdTable
parameter_list|(
name|uint8_t
name|pwrMin
parameter_list|,
name|uint8_t
name|pwrMax
parameter_list|,
name|uint8_t
modifier|*
name|pPwrList
parameter_list|,
name|uint8_t
modifier|*
name|pVpdList
parameter_list|,
name|uint16_t
name|numIntercepts
parameter_list|,
name|uint8_t
modifier|*
name|pRetVpdList
parameter_list|)
block|{
name|uint16_t
name|i
decl_stmt|,
name|k
decl_stmt|;
name|uint8_t
name|currPwr
init|=
name|pwrMin
decl_stmt|;
name|uint16_t
name|idxL
decl_stmt|,
name|idxR
decl_stmt|;
name|HALASSERT
argument_list|(
name|pwrMax
operator|>
name|pwrMin
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
operator|(
name|pwrMax
operator|-
name|pwrMin
operator|)
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|ath_ee_getLowerUpperIndex
argument_list|(
name|currPwr
argument_list|,
name|pPwrList
argument_list|,
name|numIntercepts
argument_list|,
operator|&
operator|(
name|idxL
operator|)
argument_list|,
operator|&
operator|(
name|idxR
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idxR
operator|<
literal|1
condition|)
name|idxR
operator|=
literal|1
expr_stmt|;
comment|/* extrapolate below */
if|if
condition|(
name|idxL
operator|==
name|numIntercepts
operator|-
literal|1
condition|)
name|idxL
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|numIntercepts
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* extrapolate above */
if|if
condition|(
name|pPwrList
index|[
name|idxL
index|]
operator|==
name|pPwrList
index|[
name|idxR
index|]
condition|)
name|k
operator|=
name|pVpdList
index|[
name|idxL
index|]
expr_stmt|;
else|else
name|k
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
operator|(
name|currPwr
operator|-
name|pPwrList
index|[
name|idxL
index|]
operator|)
operator|*
name|pVpdList
index|[
name|idxR
index|]
operator|+
operator|(
name|pPwrList
index|[
name|idxR
index|]
operator|-
name|currPwr
operator|)
operator|*
name|pVpdList
index|[
name|idxL
index|]
operator|)
operator|/
operator|(
name|pPwrList
index|[
name|idxR
index|]
operator|-
name|pPwrList
index|[
name|idxL
index|]
operator|)
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|k
operator|<
literal|256
argument_list|)
expr_stmt|;
name|pRetVpdList
index|[
name|i
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|k
expr_stmt|;
name|currPwr
operator|+=
literal|2
expr_stmt|;
comment|/* half dB steps */
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************  * ath_ee_interpolate  *  * Returns signed interpolated or the scaled up interpolated value  */
end_comment

begin_function
name|int16_t
name|ath_ee_interpolate
parameter_list|(
name|uint16_t
name|target
parameter_list|,
name|uint16_t
name|srcLeft
parameter_list|,
name|uint16_t
name|srcRight
parameter_list|,
name|int16_t
name|targetLeft
parameter_list|,
name|int16_t
name|targetRight
parameter_list|)
block|{
name|int16_t
name|rv
decl_stmt|;
if|if
condition|(
name|srcRight
operator|==
name|srcLeft
condition|)
block|{
name|rv
operator|=
name|targetLeft
expr_stmt|;
block|}
else|else
block|{
name|rv
operator|=
call|(
name|int16_t
call|)
argument_list|(
operator|(
operator|(
name|target
operator|-
name|srcLeft
operator|)
operator|*
name|targetRight
operator|+
operator|(
name|srcRight
operator|-
name|target
operator|)
operator|*
name|targetLeft
operator|)
operator|/
operator|(
name|srcRight
operator|-
name|srcLeft
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/*  * Adjust the TSF.  */
end_comment

begin_function
name|void
name|ath_hal_adjusttsf
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int32_t
name|tsfdelta
parameter_list|)
block|{
comment|/* XXX handle wrap/overflow */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|)
operator|+
name|tsfdelta
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enable or disable CCA.  */
end_comment

begin_function
name|void
name|ath_hal_setcca
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|ena
parameter_list|)
block|{
comment|/* 	 * NB: fill me in; this is not provided by default because disabling 	 *     CCA in most locales violates regulatory. 	 */
block|}
end_function

begin_comment
comment|/*  * Get CCA setting.  *  * XXX TODO: turn this and the above function into methods  * in case there are chipset differences in handling CCA.  */
end_comment

begin_function
name|int
name|ath_hal_getcca
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|u_int32_t
name|diag
decl_stmt|;
if|if
condition|(
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_DIAG
argument_list|,
literal|0
argument_list|,
operator|&
name|diag
argument_list|)
operator|!=
name|HAL_OK
condition|)
return|return
literal|1
return|;
return|return
operator|(
operator|(
name|diag
operator|&
literal|0x500000
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the current state of self-generated ACK and RTS/CTS frames.  *  * For correct DFS operation, the device should not even /ACK/ frames  * that are sent to it during CAC or CSA.  */
end_comment

begin_function
name|void
name|ath_hal_set_dfs_cac_tx_quiet
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|ena
parameter_list|)
block|{
if|if
condition|(
name|ah
operator|->
name|ah_setDfsCacTxQuiet
operator|==
name|NULL
condition|)
return|return;
name|ah
operator|->
name|ah_setDfsCacTxQuiet
argument_list|(
name|ah
argument_list|,
name|ena
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is only needed when supporting EEPROM-in-RAM setups  * (eg embedded SoCs and on-board PCI/PCIe devices.)  */
end_comment

begin_comment
comment|/* NB: This is in 16 bit words; not bytes */
end_comment

begin_comment
comment|/* XXX This doesn't belong here!  */
end_comment

begin_define
define|#
directive|define
name|ATH_DATA_EEPROM_SIZE
value|2048
end_define

begin_function
name|HAL_BOOL
name|ath_hal_EepromDataRead
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|off
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|ah
operator|->
name|ah_eepromdata
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: no eeprom data!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
if|if
condition|(
name|off
operator|>
name|ATH_DATA_EEPROM_SIZE
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: offset %x> %x\n"
argument_list|,
name|__func__
argument_list|,
name|off
argument_list|,
name|ATH_DATA_EEPROM_SIZE
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
operator|(
operator|*
name|data
operator|)
operator|=
name|ah
operator|->
name|ah_eepromdata
index|[
name|off
index|]
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Do a 2GHz specific MHz->IEEE based on the hardware  * frequency.  *  * This is the unmapped frequency which is programmed into the hardware.  */
end_comment

begin_function
name|int
name|ath_hal_mhz2ieee_2ghz
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|freq
parameter_list|)
block|{
if|if
condition|(
name|freq
operator|==
literal|2484
condition|)
return|return
literal|14
return|;
if|if
condition|(
name|freq
operator|<
literal|2484
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|freq
operator|-
literal|2407
operator|)
operator|/
literal|5
return|;
else|else
return|return
literal|15
operator|+
operator|(
operator|(
name|freq
operator|-
literal|2512
operator|)
operator|/
literal|20
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear the current survey data.  *  * This should be done during a channel change.  */
end_comment

begin_function
name|void
name|ath_hal_survey_clear
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|OS_MEMZERO
argument_list|(
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_chansurvey
argument_list|,
sizeof|sizeof
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_chansurvey
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a sample to the channel survey.  */
end_comment

begin_function
name|void
name|ath_hal_survey_add_sample
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_SURVEY_SAMPLE
modifier|*
name|hs
parameter_list|)
block|{
name|HAL_CHANNEL_SURVEY
modifier|*
name|cs
decl_stmt|;
name|cs
operator|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_chansurvey
expr_stmt|;
name|OS_MEMCPY
argument_list|(
operator|&
name|cs
operator|->
name|samples
index|[
name|cs
operator|->
name|cur_sample
index|]
argument_list|,
name|hs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hs
argument_list|)
argument_list|)
expr_stmt|;
name|cs
operator|->
name|samples
index|[
name|cs
operator|->
name|cur_sample
index|]
operator|.
name|seq_num
operator|=
name|cs
operator|->
name|cur_seq
expr_stmt|;
name|cs
operator|->
name|cur_sample
operator|=
operator|(
name|cs
operator|->
name|cur_sample
operator|+
literal|1
operator|)
operator|%
name|CHANNEL_SURVEY_SAMPLE_COUNT
expr_stmt|;
name|cs
operator|->
name|cur_seq
operator|++
expr_stmt|;
block|}
end_function

end_unit

