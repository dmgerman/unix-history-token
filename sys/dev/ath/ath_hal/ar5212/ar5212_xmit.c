begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2002-2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_desc.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212desc.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212phy.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|AH_SUPPORT_5311
end_ifdef

begin_include
include|#
directive|include
file|"ar5212/ar5311reg.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AH_NEED_DESC_SWAP
end_ifdef

begin_function_decl
specifier|static
name|void
name|ar5212SwapTxDesc
parameter_list|(
name|struct
name|ath_desc
modifier|*
name|ds
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Update Tx FIFO trigger level.  *  * Set bIncTrigLevel to TRUE to increase the trigger level.  * Set bIncTrigLevel to FALSE to decrease the trigger level.  *  * Returns TRUE if the trigger level was updated  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212UpdateTxTrigLevel
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|bIncTrigLevel
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|uint32_t
name|txcfg
decl_stmt|,
name|curLevel
decl_stmt|,
name|newLevel
decl_stmt|;
name|HAL_INT
name|omask
decl_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_txTrigLev
operator|>=
name|ahp
operator|->
name|ah_maxTxTrigLev
condition|)
return|return
name|AH_FALSE
return|;
comment|/* 	 * Disable interrupts while futzing with the fifo level. 	 */
name|omask
operator|=
name|ath_hal_setInterrupts
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_maskReg
operator|&
operator|~
name|HAL_INT_GLOBAL
argument_list|)
expr_stmt|;
name|txcfg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TXCFG
argument_list|)
expr_stmt|;
name|curLevel
operator|=
name|MS
argument_list|(
name|txcfg
argument_list|,
name|AR_FTRIG
argument_list|)
expr_stmt|;
name|newLevel
operator|=
name|curLevel
expr_stmt|;
if|if
condition|(
name|bIncTrigLevel
condition|)
block|{
comment|/* increase the trigger level */
if|if
condition|(
name|curLevel
operator|<
name|ahp
operator|->
name|ah_maxTxTrigLev
condition|)
name|newLevel
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curLevel
operator|>
name|MIN_TX_FIFO_THRESHOLD
condition|)
name|newLevel
operator|--
expr_stmt|;
if|if
condition|(
name|newLevel
operator|!=
name|curLevel
condition|)
comment|/* Update the trigger level */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TXCFG
argument_list|,
operator|(
name|txcfg
operator|&
operator|~
name|AR_FTRIG
operator|)
operator||
name|SM
argument_list|(
name|newLevel
argument_list|,
name|AR_FTRIG
argument_list|)
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_txTrigLev
operator|=
name|newLevel
expr_stmt|;
comment|/* re-enable chip interrupts */
name|ath_hal_setInterrupts
argument_list|(
name|ah
argument_list|,
name|omask
argument_list|)
expr_stmt|;
return|return
operator|(
name|newLevel
operator|!=
name|curLevel
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the properties of the tx queue with the parameters  * from qInfo.    */
end_comment

begin_function
name|HAL_BOOL
name|ar5212SetTxQueueProps
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|q
parameter_list|,
specifier|const
name|HAL_TXQ_INFO
modifier|*
name|qInfo
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CAPABILITIES
modifier|*
name|pCap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
if|if
condition|(
name|q
operator|>=
name|pCap
operator|->
name|halTotalQueues
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid queue num %u\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
return|return
name|ath_hal_setTxQProps
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_txq
index|[
name|q
index|]
argument_list|,
name|qInfo
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the properties for the specified tx queue.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212GetTxQueueProps
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|q
parameter_list|,
name|HAL_TXQ_INFO
modifier|*
name|qInfo
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CAPABILITIES
modifier|*
name|pCap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
if|if
condition|(
name|q
operator|>=
name|pCap
operator|->
name|halTotalQueues
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid queue num %u\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
return|return
name|ath_hal_getTxQProps
argument_list|(
name|ah
argument_list|,
name|qInfo
argument_list|,
operator|&
name|ahp
operator|->
name|ah_txq
index|[
name|q
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate and initialize a tx DCU/QCU combination.  */
end_comment

begin_function
name|int
name|ar5212SetupTxQueue
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_TX_QUEUE
name|type
parameter_list|,
specifier|const
name|HAL_TXQ_INFO
modifier|*
name|qInfo
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_TX_QUEUE_INFO
modifier|*
name|qi
decl_stmt|;
name|HAL_CAPABILITIES
modifier|*
name|pCap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
name|int
name|q
decl_stmt|,
name|defqflags
decl_stmt|;
comment|/* by default enable OK+ERR+DESC+URN interrupts */
name|defqflags
operator|=
name|HAL_TXQ_TXOKINT_ENABLE
operator||
name|HAL_TXQ_TXERRINT_ENABLE
operator||
name|HAL_TXQ_TXDESCINT_ENABLE
operator||
name|HAL_TXQ_TXURNINT_ENABLE
expr_stmt|;
comment|/* XXX move queue assignment to driver */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|HAL_TX_QUEUE_BEACON
case|:
name|q
operator|=
name|pCap
operator|->
name|halTotalQueues
operator|-
literal|1
expr_stmt|;
comment|/* highest priority */
name|defqflags
operator||=
name|HAL_TXQ_DBA_GATED
operator||
name|HAL_TXQ_CBR_DIS_QEMPTY
operator||
name|HAL_TXQ_ARB_LOCKOUT_GLOBAL
operator||
name|HAL_TXQ_BACKOFF_DISABLE
expr_stmt|;
break|break;
case|case
name|HAL_TX_QUEUE_CAB
case|:
name|q
operator|=
name|pCap
operator|->
name|halTotalQueues
operator|-
literal|2
expr_stmt|;
comment|/* next highest priority */
name|defqflags
operator||=
name|HAL_TXQ_DBA_GATED
operator||
name|HAL_TXQ_CBR_DIS_QEMPTY
operator||
name|HAL_TXQ_CBR_DIS_BEMPTY
operator||
name|HAL_TXQ_ARB_LOCKOUT_GLOBAL
operator||
name|HAL_TXQ_BACKOFF_DISABLE
expr_stmt|;
break|break;
case|case
name|HAL_TX_QUEUE_UAPSD
case|:
name|q
operator|=
name|pCap
operator|->
name|halTotalQueues
operator|-
literal|3
expr_stmt|;
comment|/* nextest highest priority */
if|if
condition|(
name|ahp
operator|->
name|ah_txq
index|[
name|q
index|]
operator|.
name|tqi_type
operator|!=
name|HAL_TX_QUEUE_INACTIVE
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: no available UAPSD tx queue\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
name|HAL_TX_QUEUE_DATA
case|:
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|pCap
operator|->
name|halTotalQueues
condition|;
name|q
operator|++
control|)
if|if
condition|(
name|ahp
operator|->
name|ah_txq
index|[
name|q
index|]
operator|.
name|tqi_type
operator|==
name|HAL_TX_QUEUE_INACTIVE
condition|)
break|break;
if|if
condition|(
name|q
operator|==
name|pCap
operator|->
name|halTotalQueues
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: no available tx queue\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: bad tx queue type %u\n"
argument_list|,
name|__func__
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_TXQUEUE
argument_list|,
literal|"%s: queue %u\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|qi
operator|=
operator|&
name|ahp
operator|->
name|ah_txq
index|[
name|q
index|]
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_type
operator|!=
name|HAL_TX_QUEUE_INACTIVE
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: tx queue %u already active\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|OS_MEMZERO
argument_list|(
name|qi
argument_list|,
sizeof|sizeof
argument_list|(
name|HAL_TX_QUEUE_INFO
argument_list|)
argument_list|)
expr_stmt|;
name|qi
operator|->
name|tqi_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|qInfo
operator|==
name|AH_NULL
condition|)
block|{
name|qi
operator|->
name|tqi_qflags
operator|=
name|defqflags
expr_stmt|;
name|qi
operator|->
name|tqi_aifs
operator|=
name|INIT_AIFS
expr_stmt|;
name|qi
operator|->
name|tqi_cwmin
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
comment|/* NB: do at reset */
name|qi
operator|->
name|tqi_cwmax
operator|=
name|INIT_CWMAX
expr_stmt|;
name|qi
operator|->
name|tqi_shretry
operator|=
name|INIT_SH_RETRY
expr_stmt|;
name|qi
operator|->
name|tqi_lgretry
operator|=
name|INIT_LG_RETRY
expr_stmt|;
name|qi
operator|->
name|tqi_physCompBuf
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|qi
operator|->
name|tqi_physCompBuf
operator|=
name|qInfo
operator|->
name|tqi_compBuf
expr_stmt|;
operator|(
name|void
operator|)
name|ar5212SetTxQueueProps
argument_list|(
name|ah
argument_list|,
name|q
argument_list|,
name|qInfo
argument_list|)
expr_stmt|;
block|}
comment|/* NB: must be followed by ar5212ResetTxQueue */
return|return
name|q
return|;
block|}
end_function

begin_comment
comment|/*  * Update the h/w interrupt registers to reflect a tx q's configuration.  */
end_comment

begin_function
specifier|static
name|void
name|setTxQInterrupts
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_TX_QUEUE_INFO
modifier|*
name|qi
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_TXQUEUE
argument_list|,
literal|"%s: tx ok 0x%x err 0x%x desc 0x%x eol 0x%x urn 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ahp
operator|->
name|ah_txOkInterruptMask
argument_list|,
name|ahp
operator|->
name|ah_txErrInterruptMask
argument_list|,
name|ahp
operator|->
name|ah_txDescInterruptMask
argument_list|,
name|ahp
operator|->
name|ah_txEolInterruptMask
argument_list|,
name|ahp
operator|->
name|ah_txUrnInterruptMask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S0
argument_list|,
name|SM
argument_list|(
name|ahp
operator|->
name|ah_txOkInterruptMask
argument_list|,
name|AR_IMR_S0_QCU_TXOK
argument_list|)
operator||
name|SM
argument_list|(
name|ahp
operator|->
name|ah_txDescInterruptMask
argument_list|,
name|AR_IMR_S0_QCU_TXDESC
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S1
argument_list|,
name|SM
argument_list|(
name|ahp
operator|->
name|ah_txErrInterruptMask
argument_list|,
name|AR_IMR_S1_QCU_TXERR
argument_list|)
operator||
name|SM
argument_list|(
name|ahp
operator|->
name|ah_txEolInterruptMask
argument_list|,
name|AR_IMR_S1_QCU_TXEOL
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S2
argument_list|,
name|AR_IMR_S2_QCU_TXURN
argument_list|,
name|ahp
operator|->
name|ah_txUrnInterruptMask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a tx DCU/QCU combination.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212ReleaseTxQueue
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|q
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CAPABILITIES
modifier|*
name|pCap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
name|HAL_TX_QUEUE_INFO
modifier|*
name|qi
decl_stmt|;
if|if
condition|(
name|q
operator|>=
name|pCap
operator|->
name|halTotalQueues
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid queue num %u\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|qi
operator|=
operator|&
name|ahp
operator|->
name|ah_txq
index|[
name|q
index|]
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_type
operator|==
name|HAL_TX_QUEUE_INACTIVE
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_TXQUEUE
argument_list|,
literal|"%s: inactive queue %u\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_TXQUEUE
argument_list|,
literal|"%s: release queue %u\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|qi
operator|->
name|tqi_type
operator|=
name|HAL_TX_QUEUE_INACTIVE
expr_stmt|;
name|ahp
operator|->
name|ah_txOkInterruptMask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
name|ahp
operator|->
name|ah_txErrInterruptMask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
name|ahp
operator|->
name|ah_txDescInterruptMask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
name|ahp
operator|->
name|ah_txEolInterruptMask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
name|ahp
operator|->
name|ah_txUrnInterruptMask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
name|setTxQInterrupts
argument_list|(
name|ah
argument_list|,
name|qi
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Set the retry, aifs, cwmin/max, readyTime regs for specified queue  * Assumes:  *  phwChannel has been set to point to the current channel  */
end_comment

begin_define
define|#
directive|define
name|TU_TO_USEC
parameter_list|(
name|_tu
parameter_list|)
value|((_tu)<< 10)
end_define

begin_function
name|HAL_BOOL
name|ar5212ResetTxQueue
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|q
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CAPABILITIES
modifier|*
name|pCap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
decl_stmt|;
name|HAL_TX_QUEUE_INFO
modifier|*
name|qi
decl_stmt|;
name|uint32_t
name|cwMin
decl_stmt|,
name|chanCwMin
decl_stmt|,
name|qmisc
decl_stmt|,
name|dmisc
decl_stmt|;
if|if
condition|(
name|q
operator|>=
name|pCap
operator|->
name|halTotalQueues
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid queue num %u\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|qi
operator|=
operator|&
name|ahp
operator|->
name|ah_txq
index|[
name|q
index|]
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_type
operator|==
name|HAL_TX_QUEUE_INACTIVE
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_TXQUEUE
argument_list|,
literal|"%s: inactive queue %u\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
comment|/* XXX??? */
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_TXQUEUE
argument_list|,
literal|"%s: reset queue %u\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_cwmin
operator|==
name|HAL_TXQ_USEDEFAULT
condition|)
block|{
comment|/* 		 * Select cwmin according to channel type. 		 * NB: chan can be NULL during attach 		 */
if|if
condition|(
name|chan
operator|&&
name|IEEE80211_IS_CHAN_B
argument_list|(
name|chan
argument_list|)
condition|)
name|chanCwMin
operator|=
name|INIT_CWMIN_11B
expr_stmt|;
else|else
name|chanCwMin
operator|=
name|INIT_CWMIN
expr_stmt|;
comment|/* make sure that the CWmin is of the form (2^n - 1) */
for|for
control|(
name|cwMin
operator|=
literal|1
init|;
name|cwMin
operator|<
name|chanCwMin
condition|;
name|cwMin
operator|=
operator|(
name|cwMin
operator|<<
literal|1
operator|)
operator||
literal|1
control|)
empty_stmt|;
block|}
else|else
name|cwMin
operator|=
name|qi
operator|->
name|tqi_cwmin
expr_stmt|;
comment|/* set cwMin/Max and AIFS values */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DLCL_IFS
argument_list|(
name|q
argument_list|)
argument_list|,
name|SM
argument_list|(
name|cwMin
argument_list|,
name|AR_D_LCL_IFS_CWMIN
argument_list|)
operator||
name|SM
argument_list|(
name|qi
operator|->
name|tqi_cwmax
argument_list|,
name|AR_D_LCL_IFS_CWMAX
argument_list|)
operator||
name|SM
argument_list|(
name|qi
operator|->
name|tqi_aifs
argument_list|,
name|AR_D_LCL_IFS_AIFS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set retry limit values */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DRETRY_LIMIT
argument_list|(
name|q
argument_list|)
argument_list|,
name|SM
argument_list|(
name|INIT_SSH_RETRY
argument_list|,
name|AR_D_RETRY_LIMIT_STA_SH
argument_list|)
operator||
name|SM
argument_list|(
name|INIT_SLG_RETRY
argument_list|,
name|AR_D_RETRY_LIMIT_STA_LG
argument_list|)
operator||
name|SM
argument_list|(
name|qi
operator|->
name|tqi_lgretry
argument_list|,
name|AR_D_RETRY_LIMIT_FR_LG
argument_list|)
operator||
name|SM
argument_list|(
name|qi
operator|->
name|tqi_shretry
argument_list|,
name|AR_D_RETRY_LIMIT_FR_SH
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NB: always enable early termination on the QCU */
name|qmisc
operator|=
name|AR_Q_MISC_DCU_EARLY_TERM_REQ
operator||
name|SM
argument_list|(
name|AR_Q_MISC_FSP_ASAP
argument_list|,
name|AR_Q_MISC_FSP
argument_list|)
expr_stmt|;
comment|/* NB: always enable DCU to wait for next fragment from QCU */
name|dmisc
operator|=
name|AR_D_MISC_FRAG_WAIT_EN
expr_stmt|;
ifdef|#
directive|ifdef
name|AH_SUPPORT_5311
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|<
name|AR_SREV_VERSION_OAHU
condition|)
block|{
comment|/* Configure DCU to use the global sequence count */
name|dmisc
operator||=
name|AR5311_D_MISC_SEQ_NUM_CONTROL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* multiqueue support */
if|if
condition|(
name|qi
operator|->
name|tqi_cbrPeriod
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QCBRCFG
argument_list|(
name|q
argument_list|)
argument_list|,
name|SM
argument_list|(
name|qi
operator|->
name|tqi_cbrPeriod
argument_list|,
name|AR_Q_CBRCFG_CBR_INTERVAL
argument_list|)
operator||
name|SM
argument_list|(
name|qi
operator|->
name|tqi_cbrOverflowLimit
argument_list|,
name|AR_Q_CBRCFG_CBR_OVF_THRESH
argument_list|)
argument_list|)
expr_stmt|;
name|qmisc
operator|=
operator|(
name|qmisc
operator|&
operator|~
name|AR_Q_MISC_FSP
operator|)
operator||
name|AR_Q_MISC_FSP_CBR
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_cbrOverflowLimit
condition|)
name|qmisc
operator||=
name|AR_Q_MISC_CBR_EXP_CNTR_LIMIT
expr_stmt|;
block|}
if|if
condition|(
name|qi
operator|->
name|tqi_readyTime
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QRDYTIMECFG
argument_list|(
name|q
argument_list|)
argument_list|,
name|SM
argument_list|(
name|qi
operator|->
name|tqi_readyTime
argument_list|,
name|AR_Q_RDYTIMECFG_INT
argument_list|)
operator||
name|AR_Q_RDYTIMECFG_ENA
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DCHNTIME
argument_list|(
name|q
argument_list|)
argument_list|,
name|SM
argument_list|(
name|qi
operator|->
name|tqi_burstTime
argument_list|,
name|AR_D_CHNTIME_DUR
argument_list|)
operator||
operator|(
name|qi
operator|->
name|tqi_burstTime
condition|?
name|AR_D_CHNTIME_EN
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_readyTime
operator|&&
operator|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_RDYTIME_EXP_POLICY_ENABLE
operator|)
condition|)
name|qmisc
operator||=
name|AR_Q_MISC_RDYTIME_EXP_POLICY
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_DBA_GATED
condition|)
name|qmisc
operator|=
operator|(
name|qmisc
operator|&
operator|~
name|AR_Q_MISC_FSP
operator|)
operator||
name|AR_Q_MISC_FSP_DBA_GATED
expr_stmt|;
if|if
condition|(
name|MS
argument_list|(
name|qmisc
argument_list|,
name|AR_Q_MISC_FSP
argument_list|)
operator|!=
name|AR_Q_MISC_FSP_ASAP
condition|)
block|{
comment|/* 		 * These are meangingful only when not scheduled asap. 		 */
if|if
condition|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_CBR_DIS_BEMPTY
condition|)
name|qmisc
operator||=
name|AR_Q_MISC_CBR_INCR_DIS0
expr_stmt|;
else|else
name|qmisc
operator|&=
operator|~
name|AR_Q_MISC_CBR_INCR_DIS0
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_CBR_DIS_QEMPTY
condition|)
name|qmisc
operator||=
name|AR_Q_MISC_CBR_INCR_DIS1
expr_stmt|;
else|else
name|qmisc
operator|&=
operator|~
name|AR_Q_MISC_CBR_INCR_DIS1
expr_stmt|;
block|}
if|if
condition|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_BACKOFF_DISABLE
condition|)
name|dmisc
operator||=
name|AR_D_MISC_POST_FR_BKOFF_DIS
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_FRAG_BURST_BACKOFF_ENABLE
condition|)
name|dmisc
operator||=
name|AR_D_MISC_FRAG_BKOFF_EN
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_ARB_LOCKOUT_GLOBAL
condition|)
name|dmisc
operator||=
name|SM
argument_list|(
name|AR_D_MISC_ARB_LOCKOUT_CNTRL_GLOBAL
argument_list|,
name|AR_D_MISC_ARB_LOCKOUT_CNTRL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_ARB_LOCKOUT_INTRA
condition|)
name|dmisc
operator||=
name|SM
argument_list|(
name|AR_D_MISC_ARB_LOCKOUT_CNTRL_INTRA_FR
argument_list|,
name|AR_D_MISC_ARB_LOCKOUT_CNTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_IGNORE_VIRTCOL
condition|)
name|dmisc
operator||=
name|SM
argument_list|(
name|AR_D_MISC_VIR_COL_HANDLING_IGNORE
argument_list|,
name|AR_D_MISC_VIR_COL_HANDLING
argument_list|)
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_SEQNUM_INC_DIS
condition|)
name|dmisc
operator||=
name|AR_D_MISC_SEQ_NUM_INCR_DIS
expr_stmt|;
comment|/* 	 * Fillin type-dependent bits.  Most of this can be 	 * removed by specifying the queue parameters in the 	 * driver; it's here for backwards compatibility. 	 */
switch|switch
condition|(
name|qi
operator|->
name|tqi_type
condition|)
block|{
case|case
name|HAL_TX_QUEUE_BEACON
case|:
comment|/* beacon frames */
name|qmisc
operator||=
name|AR_Q_MISC_FSP_DBA_GATED
operator||
name|AR_Q_MISC_BEACON_USE
operator||
name|AR_Q_MISC_CBR_INCR_DIS1
expr_stmt|;
name|dmisc
operator||=
name|SM
argument_list|(
name|AR_D_MISC_ARB_LOCKOUT_CNTRL_GLOBAL
argument_list|,
name|AR_D_MISC_ARB_LOCKOUT_CNTRL
argument_list|)
operator||
name|AR_D_MISC_BEACON_USE
operator||
name|AR_D_MISC_POST_FR_BKOFF_DIS
expr_stmt|;
break|break;
case|case
name|HAL_TX_QUEUE_CAB
case|:
comment|/* CAB  frames */
comment|/*  		 * No longer Enable AR_Q_MISC_RDYTIME_EXP_POLICY, 		 * There is an issue with the CAB Queue 		 * not properly refreshing the Tx descriptor if 		 * the TXE clear setting is used. 		 */
name|qmisc
operator||=
name|AR_Q_MISC_FSP_DBA_GATED
operator||
name|AR_Q_MISC_CBR_INCR_DIS1
operator||
name|AR_Q_MISC_CBR_INCR_DIS0
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_readyTime
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_TXQUEUE
argument_list|,
literal|"%s: using tqi_readyTime\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QRDYTIMECFG
argument_list|(
name|q
argument_list|)
argument_list|,
name|SM
argument_list|(
name|qi
operator|->
name|tqi_readyTime
argument_list|,
name|AR_Q_RDYTIMECFG_INT
argument_list|)
operator||
name|AR_Q_RDYTIMECFG_ENA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|value
decl_stmt|;
comment|/* 			 * NB: don't set default ready time if driver 			 * has explicitly specified something.  This is 			 * here solely for backwards compatibility. 			 */
comment|/* 			 * XXX for now, hard-code a CAB interval of 70% 			 * XXX of the total beacon interval. 			 */
name|value
operator|=
operator|(
name|ahp
operator|->
name|ah_beaconInterval
operator|*
literal|70
operator|/
literal|100
operator|)
operator|-
operator|(
name|ah
operator|->
name|ah_config
operator|.
name|ah_sw_beacon_response_time
operator|-
operator|+
name|ah
operator|->
name|ah_config
operator|.
name|ah_dma_beacon_response_time
operator|)
operator|-
name|ah
operator|->
name|ah_config
operator|.
name|ah_additional_swba_backoff
expr_stmt|;
comment|/* 			 * XXX Ensure it isn't too low - nothing lower 			 * XXX than 10 TU 			 */
if|if
condition|(
name|value
operator|<
literal|10
condition|)
name|value
operator|=
literal|10
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_TXQUEUE
argument_list|,
literal|"%s: defaulting to rdytime = %d uS\n"
argument_list|,
name|__func__
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QRDYTIMECFG
argument_list|(
name|q
argument_list|)
argument_list|,
name|SM
argument_list|(
name|TU_TO_USEC
argument_list|(
name|value
argument_list|)
argument_list|,
name|AR_Q_RDYTIMECFG_INT
argument_list|)
operator||
name|AR_Q_RDYTIMECFG_ENA
argument_list|)
expr_stmt|;
block|}
name|dmisc
operator||=
name|SM
argument_list|(
name|AR_D_MISC_ARB_LOCKOUT_CNTRL_GLOBAL
argument_list|,
name|AR_D_MISC_ARB_LOCKOUT_CNTRL
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* NB: silence compiler */
break|break;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QMISC
argument_list|(
name|q
argument_list|)
argument_list|,
name|qmisc
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DMISC
argument_list|(
name|q
argument_list|)
argument_list|,
name|dmisc
argument_list|)
expr_stmt|;
comment|/* Setup compression scratchpad buffer */
comment|/*  	 * XXX: calling this asynchronously to queue operation can 	 *      cause unexpected behavior!!! 	 */
if|if
condition|(
name|qi
operator|->
name|tqi_physCompBuf
condition|)
block|{
name|HALASSERT
argument_list|(
name|qi
operator|->
name|tqi_type
operator|==
name|HAL_TX_QUEUE_DATA
operator|||
name|qi
operator|->
name|tqi_type
operator|==
name|HAL_TX_QUEUE_UAPSD
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_Q_CBBS
argument_list|,
operator|(
literal|80
operator|+
literal|2
operator|*
name|q
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_Q_CBBA
argument_list|,
name|qi
operator|->
name|tqi_physCompBuf
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_Q_CBC
argument_list|,
name|HAL_COMP_BUF_MAX_SIZE
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_Q0_MISC
operator|+
literal|4
operator|*
name|q
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_Q0_MISC
operator|+
literal|4
operator|*
name|q
argument_list|)
operator||
name|AR_Q_MISC_QCU_COMP_EN
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Always update the secondary interrupt mask registers - this 	 * could be a new queue getting enabled in a running system or 	 * hw getting re-initialized during a reset! 	 * 	 * Since we don't differentiate between tx interrupts corresponding 	 * to individual queues - secondary tx mask regs are always unmasked; 	 * tx interrupts are enabled/disabled for all queues collectively 	 * using the primary mask reg 	 */
if|if
condition|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_TXOKINT_ENABLE
condition|)
name|ahp
operator|->
name|ah_txOkInterruptMask
operator||=
literal|1
operator|<<
name|q
expr_stmt|;
else|else
name|ahp
operator|->
name|ah_txOkInterruptMask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_TXERRINT_ENABLE
condition|)
name|ahp
operator|->
name|ah_txErrInterruptMask
operator||=
literal|1
operator|<<
name|q
expr_stmt|;
else|else
name|ahp
operator|->
name|ah_txErrInterruptMask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_TXDESCINT_ENABLE
condition|)
name|ahp
operator|->
name|ah_txDescInterruptMask
operator||=
literal|1
operator|<<
name|q
expr_stmt|;
else|else
name|ahp
operator|->
name|ah_txDescInterruptMask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_TXEOLINT_ENABLE
condition|)
name|ahp
operator|->
name|ah_txEolInterruptMask
operator||=
literal|1
operator|<<
name|q
expr_stmt|;
else|else
name|ahp
operator|->
name|ah_txEolInterruptMask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_TXURNINT_ENABLE
condition|)
name|ahp
operator|->
name|ah_txUrnInterruptMask
operator||=
literal|1
operator|<<
name|q
expr_stmt|;
else|else
name|ahp
operator|->
name|ah_txUrnInterruptMask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
name|setTxQInterrupts
argument_list|(
name|ah
argument_list|,
name|qi
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|TU_TO_USEC
end_undef

begin_comment
comment|/*  * Get the TXDP for the specified queue  */
end_comment

begin_function
name|uint32_t
name|ar5212GetTxDP
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|q
parameter_list|)
block|{
name|HALASSERT
argument_list|(
name|q
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halTotalQueues
argument_list|)
expr_stmt|;
return|return
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_QTXDP
argument_list|(
name|q
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the TxDP for the specified queue  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212SetTxDP
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|q
parameter_list|,
name|uint32_t
name|txdp
parameter_list|)
block|{
name|HALASSERT
argument_list|(
name|q
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halTotalQueues
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|AH5212
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_txq
index|[
name|q
index|]
operator|.
name|tqi_type
operator|!=
name|HAL_TX_QUEUE_INACTIVE
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure that TXE is deasserted before setting the TXDP.  If TXE 	 * is still asserted, setting TXDP will have no effect. 	 */
name|HALASSERT
argument_list|(
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_Q_TXE
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|q
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QTXDP
argument_list|(
name|q
argument_list|)
argument_list|,
name|txdp
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Set Transmit Enable bits for the specified queue  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212StartTxDma
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|q
parameter_list|)
block|{
name|HALASSERT
argument_list|(
name|q
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halTotalQueues
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|AH5212
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_txq
index|[
name|q
index|]
operator|.
name|tqi_type
operator|!=
name|HAL_TX_QUEUE_INACTIVE
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_TXQUEUE
argument_list|,
literal|"%s: queue %u\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Check to be sure we're not enabling a q that has its TXD bit set. */
name|HALASSERT
argument_list|(
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_Q_TXD
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|q
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_Q_TXE
argument_list|,
literal|1
operator|<<
name|q
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of pending frames or 0 if the specified  * queue is stopped.  */
end_comment

begin_function
name|uint32_t
name|ar5212NumTxPending
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|q
parameter_list|)
block|{
name|uint32_t
name|npend
decl_stmt|;
name|HALASSERT
argument_list|(
name|q
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halTotalQueues
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|AH5212
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_txq
index|[
name|q
index|]
operator|.
name|tqi_type
operator|!=
name|HAL_TX_QUEUE_INACTIVE
argument_list|)
expr_stmt|;
name|npend
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_QSTS
argument_list|(
name|q
argument_list|)
argument_list|)
operator|&
name|AR_Q_STS_PEND_FR_CNT
expr_stmt|;
if|if
condition|(
name|npend
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Pending frame count (PFC) can momentarily go to zero 		 * while TXE remains asserted.  In other words a PFC of 		 * zero is not sufficient to say that the queue has stopped. 		 */
if|if
condition|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_Q_TXE
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|q
operator|)
condition|)
name|npend
operator|=
literal|1
expr_stmt|;
comment|/* arbitrarily return 1 */
block|}
return|return
name|npend
return|;
block|}
end_function

begin_comment
comment|/*  * Stop transmit on the specified queue  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212StopTxDma
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|q
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|u_int
name|wait
decl_stmt|;
name|HALASSERT
argument_list|(
name|q
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halTotalQueues
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|AH5212
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_txq
index|[
name|q
index|]
operator|.
name|tqi_type
operator|!=
name|HAL_TX_QUEUE_INACTIVE
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_Q_TXD
argument_list|,
literal|1
operator|<<
name|q
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|!=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|ar5212NumTxPending
argument_list|(
name|ah
argument_list|,
name|q
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|OS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* XXX get actual value */
block|}
ifdef|#
directive|ifdef
name|AH_DEBUG
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: queue %u DMA did not stop in 100 msec\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: QSTS 0x%x Q_TXE 0x%x Q_TXD 0x%x Q_CBR 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_QSTS
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_Q_TXE
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_Q_TXD
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_QCBRCFG
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: Q_MISC 0x%x Q_RDYTIMECFG 0x%x Q_RDYTIMESHDN 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_QMISC
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_QRDYTIMECFG
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_Q_RDYTIMESHDN
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AH_DEBUG */
comment|/* 2413+ and up can kill packets at the PCU level */
if|if
condition|(
name|ar5212NumTxPending
argument_list|(
name|ah
argument_list|,
name|q
argument_list|)
operator|&&
operator|(
name|IS_2413
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_5413
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_2425
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_2417
argument_list|(
name|ah
argument_list|)
operator|)
condition|)
block|{
name|uint32_t
name|tsfLow
decl_stmt|,
name|j
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_TXQUEUE
argument_list|,
literal|"%s: Num of pending TX Frames %d on Q %d\n"
argument_list|,
name|__func__
argument_list|,
name|ar5212NumTxPending
argument_list|(
name|ah
argument_list|,
name|q
argument_list|)
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Kill last PCU Tx Frame */
comment|/* TODO - save off and restore current values of Q1/Q2? */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|tsfLow
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QUIET2
argument_list|,
name|SM
argument_list|(
literal|100
argument_list|,
name|AR_QUIET2_QUIET_PER
argument_list|)
operator||
name|SM
argument_list|(
literal|10
argument_list|,
name|AR_QUIET2_QUIET_DUR
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QUIET1
argument_list|,
name|AR_QUIET1_QUIET_ENABLE
operator||
name|SM
argument_list|(
name|tsfLow
operator|>>
literal|10
argument_list|,
name|AR_QUIET1_NEXT_QUIET
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|)
operator|>>
literal|10
operator|)
operator|==
operator|(
name|tsfLow
operator|>>
literal|10
operator|)
condition|)
block|{
break|break;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: TSF moved while trying to set quiet time "
literal|"TSF: 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|tsfLow
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|j
operator|<
literal|1
argument_list|)
expr_stmt|;
comment|/* TSF shouldn't count twice or reg access is taking forever */
block|}
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|,
name|AR_DIAG_CHAN_IDLE
argument_list|)
expr_stmt|;
comment|/* Allow the quiet mechanism to do its work */
name|OS_DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_QUIET1
argument_list|,
name|AR_QUIET1_QUIET_ENABLE
argument_list|)
expr_stmt|;
comment|/* Give at least 1 millisec more to wait */
name|wait
operator|=
literal|100
expr_stmt|;
comment|/* Verify all transmit is dead */
while|while
condition|(
name|ar5212NumTxPending
argument_list|(
name|ah
argument_list|,
name|q
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|--
name|wait
operator|)
operator|==
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: Failed to stop Tx DMA in %d msec after killing last frame\n"
argument_list|,
name|__func__
argument_list|,
name|wait
argument_list|)
expr_stmt|;
break|break;
block|}
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|,
name|AR_DIAG_CHAN_IDLE
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_Q_TXD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Descriptor Access Functions  */
end_comment

begin_define
define|#
directive|define
name|VALID_PKT_TYPES
define|\
value|((1<<HAL_PKT_TYPE_NORMAL)|(1<<HAL_PKT_TYPE_ATIM)|\ 	 (1<<HAL_PKT_TYPE_PSPOLL)|(1<<HAL_PKT_TYPE_PROBE_RESP)|\ 	 (1<<HAL_PKT_TYPE_BEACON))
end_define

begin_define
define|#
directive|define
name|isValidPktType
parameter_list|(
name|_t
parameter_list|)
value|((1<<(_t))& VALID_PKT_TYPES)
end_define

begin_define
define|#
directive|define
name|VALID_TX_RATES
define|\
value|((1<<0x0b)|(1<<0x0f)|(1<<0x0a)|(1<<0x0e)|(1<<0x09)|(1<<0x0d)|\ 	 (1<<0x08)|(1<<0x0c)|(1<<0x1b)|(1<<0x1a)|(1<<0x1e)|(1<<0x19)|\ 	 (1<<0x1d)|(1<<0x18)|(1<<0x1c))
end_define

begin_define
define|#
directive|define
name|isValidTxRate
parameter_list|(
name|_r
parameter_list|)
value|((1<<(_r))& VALID_TX_RATES)
end_define

begin_function
name|HAL_BOOL
name|ar5212SetupTxDesc
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ath_desc
modifier|*
name|ds
parameter_list|,
name|u_int
name|pktLen
parameter_list|,
name|u_int
name|hdrLen
parameter_list|,
name|HAL_PKT_TYPE
name|type
parameter_list|,
name|u_int
name|txPower
parameter_list|,
name|u_int
name|txRate0
parameter_list|,
name|u_int
name|txTries0
parameter_list|,
name|u_int
name|keyIx
parameter_list|,
name|u_int
name|antMode
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|u_int
name|rtsctsRate
parameter_list|,
name|u_int
name|rtsctsDuration
parameter_list|,
name|u_int
name|compicvLen
parameter_list|,
name|u_int
name|compivLen
parameter_list|,
name|u_int
name|comp
parameter_list|)
block|{
define|#
directive|define
name|RTSCTS
value|(HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA)
name|struct
name|ar5212_desc
modifier|*
name|ads
init|=
name|AR5212DESC
argument_list|(
name|ds
argument_list|)
decl_stmt|;
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|hdrLen
expr_stmt|;
name|HALASSERT
argument_list|(
name|txTries0
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|isValidPktType
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|isValidTxRate
argument_list|(
name|txRate0
argument_list|)
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
operator|(
name|flags
operator|&
name|RTSCTS
operator|)
operator|!=
name|RTSCTS
argument_list|)
expr_stmt|;
comment|/* XXX validate antMode */
name|txPower
operator|=
operator|(
name|txPower
operator|+
name|ahp
operator|->
name|ah_txPowerIndexOffset
operator|)
expr_stmt|;
if|if
condition|(
name|txPower
operator|>
literal|63
condition|)
name|txPower
operator|=
literal|63
expr_stmt|;
name|ads
operator|->
name|ds_ctl0
operator|=
operator|(
name|pktLen
operator|&
name|AR_FrameLen
operator|)
operator||
operator|(
name|txPower
operator|<<
name|AR_XmitPower_S
operator|)
operator||
operator|(
name|flags
operator|&
name|HAL_TXDESC_VEOL
condition|?
name|AR_VEOL
else|:
literal|0
operator|)
operator||
operator|(
name|flags
operator|&
name|HAL_TXDESC_CLRDMASK
condition|?
name|AR_ClearDestMask
else|:
literal|0
operator|)
operator||
name|SM
argument_list|(
name|antMode
argument_list|,
name|AR_AntModeXmit
argument_list|)
operator||
operator|(
name|flags
operator|&
name|HAL_TXDESC_INTREQ
condition|?
name|AR_TxInterReq
else|:
literal|0
operator|)
expr_stmt|;
name|ads
operator|->
name|ds_ctl1
operator|=
operator|(
name|type
operator|<<
name|AR_FrmType_S
operator|)
operator||
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
condition|?
name|AR_NoAck
else|:
literal|0
operator|)
operator||
operator|(
name|comp
operator|<<
name|AR_CompProc_S
operator|)
operator||
operator|(
name|compicvLen
operator|<<
name|AR_CompICVLen_S
operator|)
operator||
operator|(
name|compivLen
operator|<<
name|AR_CompIVLen_S
operator|)
expr_stmt|;
name|ads
operator|->
name|ds_ctl2
operator|=
name|SM
argument_list|(
name|txTries0
argument_list|,
name|AR_XmitDataTries0
argument_list|)
operator||
operator|(
name|flags
operator|&
name|HAL_TXDESC_DURENA
condition|?
name|AR_DurUpdateEna
else|:
literal|0
operator|)
expr_stmt|;
name|ads
operator|->
name|ds_ctl3
operator|=
operator|(
name|txRate0
operator|<<
name|AR_XmitRate0_S
operator|)
expr_stmt|;
if|if
condition|(
name|keyIx
operator|!=
name|HAL_TXKEYIX_INVALID
condition|)
block|{
comment|/* XXX validate key index */
name|ads
operator|->
name|ds_ctl1
operator||=
name|SM
argument_list|(
name|keyIx
argument_list|,
name|AR_DestIdx
argument_list|)
expr_stmt|;
name|ads
operator|->
name|ds_ctl0
operator||=
name|AR_DestIdxValid
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|RTSCTS
condition|)
block|{
if|if
condition|(
operator|!
name|isValidTxRate
argument_list|(
name|rtsctsRate
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid rts/cts rate 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|rtsctsRate
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* XXX validate rtsctsDuration */
name|ads
operator|->
name|ds_ctl0
operator||=
operator|(
name|flags
operator|&
name|HAL_TXDESC_CTSENA
condition|?
name|AR_CTSEnable
else|:
literal|0
operator|)
operator||
operator|(
name|flags
operator|&
name|HAL_TXDESC_RTSENA
condition|?
name|AR_RTSCTSEnable
else|:
literal|0
operator|)
expr_stmt|;
name|ads
operator|->
name|ds_ctl2
operator||=
name|SM
argument_list|(
name|rtsctsDuration
argument_list|,
name|AR_RTSCTSDuration
argument_list|)
expr_stmt|;
name|ads
operator|->
name|ds_ctl3
operator||=
operator|(
name|rtsctsRate
operator|<<
name|AR_RTSCTSRate_S
operator|)
expr_stmt|;
block|}
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|RTSCTS
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5212SetupXTxDesc
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ath_desc
modifier|*
name|ds
parameter_list|,
name|u_int
name|txRate1
parameter_list|,
name|u_int
name|txTries1
parameter_list|,
name|u_int
name|txRate2
parameter_list|,
name|u_int
name|txTries2
parameter_list|,
name|u_int
name|txRate3
parameter_list|,
name|u_int
name|txTries3
parameter_list|)
block|{
name|struct
name|ar5212_desc
modifier|*
name|ads
init|=
name|AR5212DESC
argument_list|(
name|ds
argument_list|)
decl_stmt|;
if|if
condition|(
name|txTries1
condition|)
block|{
name|HALASSERT
argument_list|(
name|isValidTxRate
argument_list|(
name|txRate1
argument_list|)
argument_list|)
expr_stmt|;
name|ads
operator|->
name|ds_ctl2
operator||=
name|SM
argument_list|(
name|txTries1
argument_list|,
name|AR_XmitDataTries1
argument_list|)
operator||
name|AR_DurUpdateEna
expr_stmt|;
name|ads
operator|->
name|ds_ctl3
operator||=
operator|(
name|txRate1
operator|<<
name|AR_XmitRate1_S
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|txTries2
condition|)
block|{
name|HALASSERT
argument_list|(
name|isValidTxRate
argument_list|(
name|txRate2
argument_list|)
argument_list|)
expr_stmt|;
name|ads
operator|->
name|ds_ctl2
operator||=
name|SM
argument_list|(
name|txTries2
argument_list|,
name|AR_XmitDataTries2
argument_list|)
operator||
name|AR_DurUpdateEna
expr_stmt|;
name|ads
operator|->
name|ds_ctl3
operator||=
operator|(
name|txRate2
operator|<<
name|AR_XmitRate2_S
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|txTries3
condition|)
block|{
name|HALASSERT
argument_list|(
name|isValidTxRate
argument_list|(
name|txRate3
argument_list|)
argument_list|)
expr_stmt|;
name|ads
operator|->
name|ds_ctl2
operator||=
name|SM
argument_list|(
name|txTries3
argument_list|,
name|AR_XmitDataTries3
argument_list|)
operator||
name|AR_DurUpdateEna
expr_stmt|;
name|ads
operator|->
name|ds_ctl3
operator||=
operator|(
name|txRate3
operator|<<
name|AR_XmitRate3_S
operator|)
expr_stmt|;
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|void
name|ar5212IntrReqTxDesc
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ath_desc
modifier|*
name|ds
parameter_list|)
block|{
name|struct
name|ar5212_desc
modifier|*
name|ads
init|=
name|AR5212DESC
argument_list|(
name|ds
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|AH_NEED_DESC_SWAP
name|ads
operator|->
name|ds_ctl0
operator||=
name|__bswap32
argument_list|(
name|AR_TxInterReq
argument_list|)
expr_stmt|;
else|#
directive|else
name|ads
operator|->
name|ds_ctl0
operator||=
name|AR_TxInterReq
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5212FillTxDesc
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ath_desc
modifier|*
name|ds
parameter_list|,
name|HAL_DMA_ADDR
modifier|*
name|bufAddrList
parameter_list|,
name|uint32_t
modifier|*
name|segLenList
parameter_list|,
name|u_int
name|qcuId
parameter_list|,
name|u_int
name|descId
parameter_list|,
name|HAL_BOOL
name|firstSeg
parameter_list|,
name|HAL_BOOL
name|lastSeg
parameter_list|,
specifier|const
name|struct
name|ath_desc
modifier|*
name|ds0
parameter_list|)
block|{
name|struct
name|ar5212_desc
modifier|*
name|ads
init|=
name|AR5212DESC
argument_list|(
name|ds
argument_list|)
decl_stmt|;
name|uint32_t
name|segLen
init|=
name|segLenList
index|[
literal|0
index|]
decl_stmt|;
name|HALASSERT
argument_list|(
operator|(
name|segLen
operator|&
operator|~
name|AR_BufLen
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_data
operator|=
name|bufAddrList
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|firstSeg
condition|)
block|{
comment|/* 		 * First descriptor, don't clobber xmit control data 		 * setup by ar5212SetupTxDesc. 		 */
name|ads
operator|->
name|ds_ctl1
operator||=
name|segLen
operator||
operator|(
name|lastSeg
condition|?
literal|0
else|:
name|AR_More
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lastSeg
condition|)
block|{
comment|/* !firstSeg&& lastSeg */
comment|/* 		 * Last descriptor in a multi-descriptor frame, 		 * copy the multi-rate transmit parameters from 		 * the first frame for processing on completion.  		 */
name|ads
operator|->
name|ds_ctl1
operator|=
name|segLen
expr_stmt|;
ifdef|#
directive|ifdef
name|AH_NEED_DESC_SWAP
name|ads
operator|->
name|ds_ctl0
operator|=
name|__bswap32
argument_list|(
name|AR5212DESC_CONST
argument_list|(
name|ds0
argument_list|)
operator|->
name|ds_ctl0
argument_list|)
operator|&
name|AR_TxInterReq
expr_stmt|;
name|ads
operator|->
name|ds_ctl2
operator|=
name|__bswap32
argument_list|(
name|AR5212DESC_CONST
argument_list|(
name|ds0
argument_list|)
operator|->
name|ds_ctl2
argument_list|)
expr_stmt|;
name|ads
operator|->
name|ds_ctl3
operator|=
name|__bswap32
argument_list|(
name|AR5212DESC_CONST
argument_list|(
name|ds0
argument_list|)
operator|->
name|ds_ctl3
argument_list|)
expr_stmt|;
else|#
directive|else
name|ads
operator|->
name|ds_ctl0
operator|=
name|AR5212DESC_CONST
argument_list|(
name|ds0
argument_list|)
operator|->
name|ds_ctl0
operator|&
name|AR_TxInterReq
expr_stmt|;
name|ads
operator|->
name|ds_ctl2
operator|=
name|AR5212DESC_CONST
argument_list|(
name|ds0
argument_list|)
operator|->
name|ds_ctl2
expr_stmt|;
name|ads
operator|->
name|ds_ctl3
operator|=
name|AR5212DESC_CONST
argument_list|(
name|ds0
argument_list|)
operator|->
name|ds_ctl3
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* !firstSeg&& !lastSeg */
comment|/* 		 * Intermediate descriptor in a multi-descriptor frame. 		 */
ifdef|#
directive|ifdef
name|AH_NEED_DESC_SWAP
name|ads
operator|->
name|ds_ctl0
operator|=
name|__bswap32
argument_list|(
name|AR5212DESC_CONST
argument_list|(
name|ds0
argument_list|)
operator|->
name|ds_ctl0
argument_list|)
operator|&
name|AR_TxInterReq
expr_stmt|;
else|#
directive|else
name|ads
operator|->
name|ds_ctl0
operator|=
name|AR5212DESC_CONST
argument_list|(
name|ds0
argument_list|)
operator|->
name|ds_ctl0
operator|&
name|AR_TxInterReq
expr_stmt|;
endif|#
directive|endif
name|ads
operator|->
name|ds_ctl1
operator|=
name|segLen
operator||
name|AR_More
expr_stmt|;
name|ads
operator|->
name|ds_ctl2
operator|=
literal|0
expr_stmt|;
name|ads
operator|->
name|ds_ctl3
operator|=
literal|0
expr_stmt|;
block|}
name|ads
operator|->
name|ds_txstatus0
operator|=
name|ads
operator|->
name|ds_txstatus1
operator|=
literal|0
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AH_NEED_DESC_SWAP
end_ifdef

begin_comment
comment|/* Swap transmit descriptor */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ar5212SwapTxDesc
parameter_list|(
name|struct
name|ath_desc
modifier|*
name|ds
parameter_list|)
block|{
name|ds
operator|->
name|ds_data
operator|=
name|__bswap32
argument_list|(
name|ds
operator|->
name|ds_data
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_ctl0
operator|=
name|__bswap32
argument_list|(
name|ds
operator|->
name|ds_ctl0
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_ctl1
operator|=
name|__bswap32
argument_list|(
name|ds
operator|->
name|ds_ctl1
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_hw
index|[
literal|0
index|]
operator|=
name|__bswap32
argument_list|(
name|ds
operator|->
name|ds_hw
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_hw
index|[
literal|1
index|]
operator|=
name|__bswap32
argument_list|(
name|ds
operator|->
name|ds_hw
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_hw
index|[
literal|2
index|]
operator|=
name|__bswap32
argument_list|(
name|ds
operator|->
name|ds_hw
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_hw
index|[
literal|3
index|]
operator|=
name|__bswap32
argument_list|(
name|ds
operator|->
name|ds_hw
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Processing of HW TX descriptor.  */
end_comment

begin_function
name|HAL_STATUS
name|ar5212ProcTxDesc
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ath_desc
modifier|*
name|ds
parameter_list|,
name|struct
name|ath_tx_status
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|ar5212_desc
modifier|*
name|ads
init|=
name|AR5212DESC
argument_list|(
name|ds
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|AH_NEED_DESC_SWAP
if|if
condition|(
operator|(
name|ads
operator|->
name|ds_txstatus1
operator|&
name|__bswap32
argument_list|(
name|AR_Done
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|HAL_EINPROGRESS
return|;
name|ar5212SwapTxDesc
argument_list|(
name|ds
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|ads
operator|->
name|ds_txstatus1
operator|&
name|AR_Done
operator|)
operator|==
literal|0
condition|)
return|return
name|HAL_EINPROGRESS
return|;
endif|#
directive|endif
comment|/* Update software copies of the HW status */
name|ts
operator|->
name|ts_seqnum
operator|=
name|MS
argument_list|(
name|ads
operator|->
name|ds_txstatus1
argument_list|,
name|AR_SeqNum
argument_list|)
expr_stmt|;
name|ts
operator|->
name|ts_tstamp
operator|=
name|MS
argument_list|(
name|ads
operator|->
name|ds_txstatus0
argument_list|,
name|AR_SendTimestamp
argument_list|)
expr_stmt|;
name|ts
operator|->
name|ts_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ads
operator|->
name|ds_txstatus0
operator|&
name|AR_FrmXmitOK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ads
operator|->
name|ds_txstatus0
operator|&
name|AR_ExcessiveRetries
condition|)
name|ts
operator|->
name|ts_status
operator||=
name|HAL_TXERR_XRETRY
expr_stmt|;
if|if
condition|(
name|ads
operator|->
name|ds_txstatus0
operator|&
name|AR_Filtered
condition|)
name|ts
operator|->
name|ts_status
operator||=
name|HAL_TXERR_FILT
expr_stmt|;
if|if
condition|(
name|ads
operator|->
name|ds_txstatus0
operator|&
name|AR_FIFOUnderrun
condition|)
name|ts
operator|->
name|ts_status
operator||=
name|HAL_TXERR_FIFO
expr_stmt|;
block|}
comment|/* 	 * Extract the transmit rate used and mark the rate as 	 * ``alternate'' if it wasn't the series 0 rate. 	 */
name|ts
operator|->
name|ts_finaltsi
operator|=
name|MS
argument_list|(
name|ads
operator|->
name|ds_txstatus1
argument_list|,
name|AR_FinalTSIndex
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ts
operator|->
name|ts_finaltsi
condition|)
block|{
case|case
literal|0
case|:
name|ts
operator|->
name|ts_rate
operator|=
name|MS
argument_list|(
name|ads
operator|->
name|ds_ctl3
argument_list|,
name|AR_XmitRate0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ts
operator|->
name|ts_rate
operator|=
name|MS
argument_list|(
name|ads
operator|->
name|ds_ctl3
argument_list|,
name|AR_XmitRate1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ts
operator|->
name|ts_rate
operator|=
name|MS
argument_list|(
name|ads
operator|->
name|ds_ctl3
argument_list|,
name|AR_XmitRate2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|ts
operator|->
name|ts_rate
operator|=
name|MS
argument_list|(
name|ads
operator|->
name|ds_ctl3
argument_list|,
name|AR_XmitRate3
argument_list|)
expr_stmt|;
break|break;
block|}
name|ts
operator|->
name|ts_rssi
operator|=
name|MS
argument_list|(
name|ads
operator|->
name|ds_txstatus1
argument_list|,
name|AR_AckSigStrength
argument_list|)
expr_stmt|;
name|ts
operator|->
name|ts_shortretry
operator|=
name|MS
argument_list|(
name|ads
operator|->
name|ds_txstatus0
argument_list|,
name|AR_RTSFailCnt
argument_list|)
expr_stmt|;
name|ts
operator|->
name|ts_longretry
operator|=
name|MS
argument_list|(
name|ads
operator|->
name|ds_txstatus0
argument_list|,
name|AR_DataFailCnt
argument_list|)
expr_stmt|;
comment|/* 	 * The retry count has the number of un-acked tries for the 	 * final series used.  When doing multi-rate retry we must 	 * fixup the retry count by adding in the try counts for 	 * each series that was fully-processed.  Beware that this 	 * takes values from the try counts in the final descriptor. 	 * These are not required by the hardware.  We assume they 	 * are placed there by the driver as otherwise we have no 	 * access and the driver can't do the calculation because it 	 * doesn't know the descriptor format. 	 */
switch|switch
condition|(
name|ts
operator|->
name|ts_finaltsi
condition|)
block|{
case|case
literal|3
case|:
name|ts
operator|->
name|ts_longretry
operator|+=
name|MS
argument_list|(
name|ads
operator|->
name|ds_ctl2
argument_list|,
name|AR_XmitDataTries2
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|ts
operator|->
name|ts_longretry
operator|+=
name|MS
argument_list|(
name|ads
operator|->
name|ds_ctl2
argument_list|,
name|AR_XmitDataTries1
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|ts
operator|->
name|ts_longretry
operator|+=
name|MS
argument_list|(
name|ads
operator|->
name|ds_ctl2
argument_list|,
name|AR_XmitDataTries0
argument_list|)
expr_stmt|;
block|}
name|ts
operator|->
name|ts_virtcol
operator|=
name|MS
argument_list|(
name|ads
operator|->
name|ds_txstatus0
argument_list|,
name|AR_VirtCollCnt
argument_list|)
expr_stmt|;
name|ts
operator|->
name|ts_antenna
operator|=
operator|(
name|ads
operator|->
name|ds_txstatus1
operator|&
name|AR_XmitAtenna
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
return|return
name|HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * Determine which tx queues need interrupt servicing.  */
end_comment

begin_function
name|void
name|ar5212GetTxIntrQueue
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
modifier|*
name|txqs
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
operator|*
name|txqs
operator|&=
name|ahp
operator|->
name|ah_intrTxqs
expr_stmt|;
name|ahp
operator|->
name|ah_intrTxqs
operator|&=
operator|~
operator|(
operator|*
name|txqs
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retrieve the rate table from the given TX completion descriptor  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212GetTxCompletionRates
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ath_desc
modifier|*
name|ds0
parameter_list|,
name|int
modifier|*
name|rates
parameter_list|,
name|int
modifier|*
name|tries
parameter_list|)
block|{
specifier|const
name|struct
name|ar5212_desc
modifier|*
name|ads
init|=
name|AR5212DESC_CONST
argument_list|(
name|ds0
argument_list|)
decl_stmt|;
name|rates
index|[
literal|0
index|]
operator|=
name|MS
argument_list|(
name|ads
operator|->
name|ds_ctl3
argument_list|,
name|AR_XmitRate0
argument_list|)
expr_stmt|;
name|rates
index|[
literal|1
index|]
operator|=
name|MS
argument_list|(
name|ads
operator|->
name|ds_ctl3
argument_list|,
name|AR_XmitRate1
argument_list|)
expr_stmt|;
name|rates
index|[
literal|2
index|]
operator|=
name|MS
argument_list|(
name|ads
operator|->
name|ds_ctl3
argument_list|,
name|AR_XmitRate2
argument_list|)
expr_stmt|;
name|rates
index|[
literal|3
index|]
operator|=
name|MS
argument_list|(
name|ads
operator|->
name|ds_ctl3
argument_list|,
name|AR_XmitRate3
argument_list|)
expr_stmt|;
name|tries
index|[
literal|0
index|]
operator|=
name|MS
argument_list|(
name|ads
operator|->
name|ds_ctl2
argument_list|,
name|AR_XmitDataTries0
argument_list|)
expr_stmt|;
name|tries
index|[
literal|1
index|]
operator|=
name|MS
argument_list|(
name|ads
operator|->
name|ds_ctl2
argument_list|,
name|AR_XmitDataTries1
argument_list|)
expr_stmt|;
name|tries
index|[
literal|2
index|]
operator|=
name|MS
argument_list|(
name|ads
operator|->
name|ds_ctl2
argument_list|,
name|AR_XmitDataTries2
argument_list|)
expr_stmt|;
name|tries
index|[
literal|3
index|]
operator|=
name|MS
argument_list|(
name|ads
operator|->
name|ds_ctl2
argument_list|,
name|AR_XmitDataTries3
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|void
name|ar5212SetTxDescLink
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|void
modifier|*
name|ds
parameter_list|,
name|uint32_t
name|link
parameter_list|)
block|{
name|struct
name|ar5212_desc
modifier|*
name|ads
init|=
name|AR5212DESC
argument_list|(
name|ds
argument_list|)
decl_stmt|;
name|ads
operator|->
name|ds_link
operator|=
name|link
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ar5212GetTxDescLink
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|void
modifier|*
name|ds
parameter_list|,
name|uint32_t
modifier|*
name|link
parameter_list|)
block|{
name|struct
name|ar5212_desc
modifier|*
name|ads
init|=
name|AR5212DESC
argument_list|(
name|ds
argument_list|)
decl_stmt|;
operator|*
name|link
operator|=
name|ads
operator|->
name|ds_link
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ar5212GetTxDescLinkPtr
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|void
modifier|*
name|ds
parameter_list|,
name|uint32_t
modifier|*
modifier|*
name|linkptr
parameter_list|)
block|{
name|struct
name|ar5212_desc
modifier|*
name|ads
init|=
name|AR5212DESC
argument_list|(
name|ds
argument_list|)
decl_stmt|;
operator|*
name|linkptr
operator|=
operator|&
name|ads
operator|->
name|ds_link
expr_stmt|;
block|}
end_function

end_unit

