begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2002-2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_devid.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212phy.h"
end_include

begin_define
define|#
directive|define
name|AH_5212_COMMON
end_define

begin_include
include|#
directive|include
file|"ar5212/ar5212.ini"
end_include

begin_function_decl
specifier|static
name|void
name|ar5212ConfigPCIE
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|restore
parameter_list|,
name|HAL_BOOL
name|power_off
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5212DisablePCIE
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ath_hal_private
name|ar5212hal
init|=
block|{
block|{
operator|.
name|ah_magic
operator|=
name|AR5212_MAGIC
block|,
operator|.
name|ah_getRateTable
operator|=
name|ar5212GetRateTable
block|,
operator|.
name|ah_detach
operator|=
name|ar5212Detach
block|,
comment|/* Reset Functions */
operator|.
name|ah_reset
operator|=
name|ar5212Reset
block|,
operator|.
name|ah_phyDisable
operator|=
name|ar5212PhyDisable
block|,
operator|.
name|ah_disable
operator|=
name|ar5212Disable
block|,
operator|.
name|ah_configPCIE
operator|=
name|ar5212ConfigPCIE
block|,
operator|.
name|ah_disablePCIE
operator|=
name|ar5212DisablePCIE
block|,
operator|.
name|ah_setPCUConfig
operator|=
name|ar5212SetPCUConfig
block|,
operator|.
name|ah_perCalibration
operator|=
name|ar5212PerCalibration
block|,
operator|.
name|ah_perCalibrationN
operator|=
name|ar5212PerCalibrationN
block|,
operator|.
name|ah_resetCalValid
operator|=
name|ar5212ResetCalValid
block|,
operator|.
name|ah_setTxPowerLimit
operator|=
name|ar5212SetTxPowerLimit
block|,
operator|.
name|ah_getChanNoise
operator|=
name|ath_hal_getChanNoise
block|,
comment|/* Transmit functions */
operator|.
name|ah_updateTxTrigLevel
operator|=
name|ar5212UpdateTxTrigLevel
block|,
operator|.
name|ah_setupTxQueue
operator|=
name|ar5212SetupTxQueue
block|,
operator|.
name|ah_setTxQueueProps
operator|=
name|ar5212SetTxQueueProps
block|,
operator|.
name|ah_getTxQueueProps
operator|=
name|ar5212GetTxQueueProps
block|,
operator|.
name|ah_releaseTxQueue
operator|=
name|ar5212ReleaseTxQueue
block|,
operator|.
name|ah_resetTxQueue
operator|=
name|ar5212ResetTxQueue
block|,
operator|.
name|ah_getTxDP
operator|=
name|ar5212GetTxDP
block|,
operator|.
name|ah_setTxDP
operator|=
name|ar5212SetTxDP
block|,
operator|.
name|ah_numTxPending
operator|=
name|ar5212NumTxPending
block|,
operator|.
name|ah_startTxDma
operator|=
name|ar5212StartTxDma
block|,
operator|.
name|ah_stopTxDma
operator|=
name|ar5212StopTxDma
block|,
operator|.
name|ah_setupTxDesc
operator|=
name|ar5212SetupTxDesc
block|,
operator|.
name|ah_setupXTxDesc
operator|=
name|ar5212SetupXTxDesc
block|,
operator|.
name|ah_fillTxDesc
operator|=
name|ar5212FillTxDesc
block|,
operator|.
name|ah_procTxDesc
operator|=
name|ar5212ProcTxDesc
block|,
operator|.
name|ah_getTxIntrQueue
operator|=
name|ar5212GetTxIntrQueue
block|,
operator|.
name|ah_reqTxIntrDesc
operator|=
name|ar5212IntrReqTxDesc
block|,
operator|.
name|ah_getTxCompletionRates
operator|=
name|ar5212GetTxCompletionRates
block|,
operator|.
name|ah_setTxDescLink
operator|=
name|ar5212SetTxDescLink
block|,
operator|.
name|ah_getTxDescLink
operator|=
name|ar5212GetTxDescLink
block|,
operator|.
name|ah_getTxDescLinkPtr
operator|=
name|ar5212GetTxDescLinkPtr
block|,
comment|/* RX Functions */
operator|.
name|ah_getRxDP
operator|=
name|ar5212GetRxDP
block|,
operator|.
name|ah_setRxDP
operator|=
name|ar5212SetRxDP
block|,
operator|.
name|ah_enableReceive
operator|=
name|ar5212EnableReceive
block|,
operator|.
name|ah_stopDmaReceive
operator|=
name|ar5212StopDmaReceive
block|,
operator|.
name|ah_startPcuReceive
operator|=
name|ar5212StartPcuReceive
block|,
operator|.
name|ah_stopPcuReceive
operator|=
name|ar5212StopPcuReceive
block|,
operator|.
name|ah_setMulticastFilter
operator|=
name|ar5212SetMulticastFilter
block|,
operator|.
name|ah_setMulticastFilterIndex
operator|=
name|ar5212SetMulticastFilterIndex
block|,
operator|.
name|ah_clrMulticastFilterIndex
operator|=
name|ar5212ClrMulticastFilterIndex
block|,
operator|.
name|ah_getRxFilter
operator|=
name|ar5212GetRxFilter
block|,
operator|.
name|ah_setRxFilter
operator|=
name|ar5212SetRxFilter
block|,
operator|.
name|ah_setupRxDesc
operator|=
name|ar5212SetupRxDesc
block|,
operator|.
name|ah_procRxDesc
operator|=
name|ar5212ProcRxDesc
block|,
operator|.
name|ah_rxMonitor
operator|=
name|ar5212RxMonitor
block|,
operator|.
name|ah_aniPoll
operator|=
name|ar5212AniPoll
block|,
operator|.
name|ah_procMibEvent
operator|=
name|ar5212ProcessMibIntr
block|,
comment|/* Misc Functions */
operator|.
name|ah_getCapability
operator|=
name|ar5212GetCapability
block|,
operator|.
name|ah_setCapability
operator|=
name|ar5212SetCapability
block|,
operator|.
name|ah_getDiagState
operator|=
name|ar5212GetDiagState
block|,
operator|.
name|ah_getMacAddress
operator|=
name|ar5212GetMacAddress
block|,
operator|.
name|ah_setMacAddress
operator|=
name|ar5212SetMacAddress
block|,
operator|.
name|ah_getBssIdMask
operator|=
name|ar5212GetBssIdMask
block|,
operator|.
name|ah_setBssIdMask
operator|=
name|ar5212SetBssIdMask
block|,
operator|.
name|ah_setRegulatoryDomain
operator|=
name|ar5212SetRegulatoryDomain
block|,
operator|.
name|ah_setLedState
operator|=
name|ar5212SetLedState
block|,
operator|.
name|ah_writeAssocid
operator|=
name|ar5212WriteAssocid
block|,
operator|.
name|ah_gpioCfgInput
operator|=
name|ar5212GpioCfgInput
block|,
operator|.
name|ah_gpioCfgOutput
operator|=
name|ar5212GpioCfgOutput
block|,
operator|.
name|ah_gpioGet
operator|=
name|ar5212GpioGet
block|,
operator|.
name|ah_gpioSet
operator|=
name|ar5212GpioSet
block|,
operator|.
name|ah_gpioSetIntr
operator|=
name|ar5212GpioSetIntr
block|,
operator|.
name|ah_getTsf32
operator|=
name|ar5212GetTsf32
block|,
operator|.
name|ah_getTsf64
operator|=
name|ar5212GetTsf64
block|,
operator|.
name|ah_setTsf64
operator|=
name|ar5212SetTsf64
block|,
operator|.
name|ah_resetTsf
operator|=
name|ar5212ResetTsf
block|,
operator|.
name|ah_detectCardPresent
operator|=
name|ar5212DetectCardPresent
block|,
operator|.
name|ah_updateMibCounters
operator|=
name|ar5212UpdateMibCounters
block|,
operator|.
name|ah_getRfGain
operator|=
name|ar5212GetRfgain
block|,
operator|.
name|ah_getDefAntenna
operator|=
name|ar5212GetDefAntenna
block|,
operator|.
name|ah_setDefAntenna
operator|=
name|ar5212SetDefAntenna
block|,
operator|.
name|ah_getAntennaSwitch
operator|=
name|ar5212GetAntennaSwitch
block|,
operator|.
name|ah_setAntennaSwitch
operator|=
name|ar5212SetAntennaSwitch
block|,
operator|.
name|ah_setSifsTime
operator|=
name|ar5212SetSifsTime
block|,
operator|.
name|ah_getSifsTime
operator|=
name|ar5212GetSifsTime
block|,
operator|.
name|ah_setSlotTime
operator|=
name|ar5212SetSlotTime
block|,
operator|.
name|ah_getSlotTime
operator|=
name|ar5212GetSlotTime
block|,
operator|.
name|ah_setAckTimeout
operator|=
name|ar5212SetAckTimeout
block|,
operator|.
name|ah_getAckTimeout
operator|=
name|ar5212GetAckTimeout
block|,
operator|.
name|ah_setAckCTSRate
operator|=
name|ar5212SetAckCTSRate
block|,
operator|.
name|ah_getAckCTSRate
operator|=
name|ar5212GetAckCTSRate
block|,
operator|.
name|ah_setCTSTimeout
operator|=
name|ar5212SetCTSTimeout
block|,
operator|.
name|ah_getCTSTimeout
operator|=
name|ar5212GetCTSTimeout
block|,
operator|.
name|ah_setDecompMask
operator|=
name|ar5212SetDecompMask
block|,
operator|.
name|ah_setCoverageClass
operator|=
name|ar5212SetCoverageClass
block|,
operator|.
name|ah_setQuiet
operator|=
name|ar5212SetQuiet
block|,
operator|.
name|ah_getMibCycleCounts
operator|=
name|ar5212GetMibCycleCounts
block|,
operator|.
name|ah_setChainMasks
operator|=
name|ar5212SetChainMasks
block|,
comment|/* DFS Functions */
operator|.
name|ah_enableDfs
operator|=
name|ar5212EnableDfs
block|,
operator|.
name|ah_getDfsThresh
operator|=
name|ar5212GetDfsThresh
block|,
operator|.
name|ah_getDfsDefaultThresh
operator|=
name|ar5212GetDfsDefaultThresh
block|,
operator|.
name|ah_procRadarEvent
operator|=
name|ar5212ProcessRadarEvent
block|,
operator|.
name|ah_isFastClockEnabled
operator|=
name|ar5212IsFastClockEnabled
block|,
operator|.
name|ah_get11nExtBusy
operator|=
name|ar5212Get11nExtBusy
block|,
comment|/* Key Cache Functions */
operator|.
name|ah_getKeyCacheSize
operator|=
name|ar5212GetKeyCacheSize
block|,
operator|.
name|ah_resetKeyCacheEntry
operator|=
name|ar5212ResetKeyCacheEntry
block|,
operator|.
name|ah_isKeyCacheEntryValid
operator|=
name|ar5212IsKeyCacheEntryValid
block|,
operator|.
name|ah_setKeyCacheEntry
operator|=
name|ar5212SetKeyCacheEntry
block|,
operator|.
name|ah_setKeyCacheEntryMac
operator|=
name|ar5212SetKeyCacheEntryMac
block|,
comment|/* Power Management Functions */
operator|.
name|ah_setPowerMode
operator|=
name|ar5212SetPowerMode
block|,
operator|.
name|ah_getPowerMode
operator|=
name|ar5212GetPowerMode
block|,
comment|/* Beacon Functions */
operator|.
name|ah_setBeaconTimers
operator|=
name|ar5212SetBeaconTimers
block|,
operator|.
name|ah_beaconInit
operator|=
name|ar5212BeaconInit
block|,
operator|.
name|ah_setStationBeaconTimers
operator|=
name|ar5212SetStaBeaconTimers
block|,
operator|.
name|ah_resetStationBeaconTimers
operator|=
name|ar5212ResetStaBeaconTimers
block|,
operator|.
name|ah_getNextTBTT
operator|=
name|ar5212GetNextTBTT
block|,
comment|/* Interrupt Functions */
operator|.
name|ah_isInterruptPending
operator|=
name|ar5212IsInterruptPending
block|,
operator|.
name|ah_getPendingInterrupts
operator|=
name|ar5212GetPendingInterrupts
block|,
operator|.
name|ah_getInterrupts
operator|=
name|ar5212GetInterrupts
block|,
operator|.
name|ah_setInterrupts
operator|=
name|ar5212SetInterrupts
block|}
block|,
operator|.
name|ah_getChannelEdges
operator|=
name|ar5212GetChannelEdges
block|,
operator|.
name|ah_getWirelessModes
operator|=
name|ar5212GetWirelessModes
block|,
operator|.
name|ah_eepromRead
operator|=
name|ar5212EepromRead
block|,
ifdef|#
directive|ifdef
name|AH_SUPPORT_WRITE_EEPROM
operator|.
name|ah_eepromWrite
operator|=
name|ar5212EepromWrite
block|,
endif|#
directive|endif
operator|.
name|ah_getChipPowerLimits
operator|=
name|ar5212GetChipPowerLimits
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|uint32_t
name|ar5212GetRadioRev
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Read Radio Chip Rev Extract */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0x34
argument_list|)
argument_list|,
literal|0x00001c16
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0x20
argument_list|)
argument_list|,
literal|0x00010000
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|256
argument_list|)
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
operator|)
operator||
operator|(
operator|(
name|val
operator|&
literal|0x0f
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
return|return
name|ath_hal_reverseBits
argument_list|(
name|val
argument_list|,
literal|8
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar5212AniSetup
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|ar5212AniParams
name|aniparams
init|=
block|{
operator|.
name|maxNoiseImmunityLevel
operator|=
literal|4
block|,
comment|/* levels 0..4 */
operator|.
name|totalSizeDesired
operator|=
block|{
operator|-
literal|55
block|,
operator|-
literal|55
block|,
operator|-
literal|55
block|,
operator|-
literal|55
block|,
operator|-
literal|62
block|}
block|,
operator|.
name|coarseHigh
operator|=
block|{
operator|-
literal|14
block|,
operator|-
literal|14
block|,
operator|-
literal|14
block|,
operator|-
literal|14
block|,
operator|-
literal|12
block|}
block|,
operator|.
name|coarseLow
operator|=
block|{
operator|-
literal|64
block|,
operator|-
literal|64
block|,
operator|-
literal|64
block|,
operator|-
literal|64
block|,
operator|-
literal|70
block|}
block|,
operator|.
name|firpwr
operator|=
block|{
operator|-
literal|78
block|,
operator|-
literal|78
block|,
operator|-
literal|78
block|,
operator|-
literal|78
block|,
operator|-
literal|80
block|}
block|,
operator|.
name|maxSpurImmunityLevel
operator|=
literal|2
block|,
comment|/* NB: depends on chip rev */
operator|.
name|cycPwrThr1
operator|=
block|{
literal|2
block|,
literal|4
block|,
literal|6
block|,
literal|8
block|,
literal|10
block|,
literal|12
block|,
literal|14
block|,
literal|16
block|}
block|,
operator|.
name|maxFirstepLevel
operator|=
literal|2
block|,
comment|/* levels 0..2 */
operator|.
name|firstep
operator|=
block|{
literal|0
block|,
literal|4
block|,
literal|8
block|}
block|,
operator|.
name|ofdmTrigHigh
operator|=
literal|500
block|,
operator|.
name|ofdmTrigLow
operator|=
literal|200
block|,
operator|.
name|cckTrigHigh
operator|=
literal|200
block|,
operator|.
name|cckTrigLow
operator|=
literal|100
block|,
operator|.
name|rssiThrHigh
operator|=
literal|40
block|,
operator|.
name|rssiThrLow
operator|=
literal|7
block|,
operator|.
name|period
operator|=
literal|100
block|, 	}
decl_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|<
name|AR_SREV_VERSION_GRIFFIN
condition|)
block|{
name|struct
name|ar5212AniParams
name|tmp
decl_stmt|;
name|OS_MEMCPY
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|aniparams
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar5212AniParams
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|maxSpurImmunityLevel
operator|=
literal|7
expr_stmt|;
comment|/* Venice and earlier */
name|ar5212AniAttach
argument_list|(
name|ah
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|tmp
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
else|else
name|ar5212AniAttach
argument_list|(
name|ah
argument_list|,
operator|&
name|aniparams
argument_list|,
operator|&
name|aniparams
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
comment|/* Set overridable ANI methods */
name|AH5212
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_aniControl
operator|=
name|ar5212AniControl
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attach for an AR5212 part.  */
end_comment

begin_function
name|void
name|ar5212InitState
parameter_list|(
name|struct
name|ath_hal_5212
modifier|*
name|ahp
parameter_list|,
name|uint16_t
name|devid
parameter_list|,
name|HAL_SOFTC
name|sc
parameter_list|,
name|HAL_BUS_TAG
name|st
parameter_list|,
name|HAL_BUS_HANDLE
name|sh
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
specifier|static
specifier|const
name|uint8_t
name|defbssidmask
index|[
name|IEEE80211_ADDR_LEN
index|]
init|=
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
decl_stmt|;
name|ah
operator|=
operator|&
name|ahp
operator|->
name|ah_priv
operator|.
name|h
expr_stmt|;
comment|/* set initial values */
name|OS_MEMCPY
argument_list|(
operator|&
name|ahp
operator|->
name|ah_priv
argument_list|,
operator|&
name|ar5212hal
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ath_hal_private
argument_list|)
argument_list|)
expr_stmt|;
name|ah
operator|->
name|ah_sc
operator|=
name|sc
expr_stmt|;
name|ah
operator|->
name|ah_st
operator|=
name|st
expr_stmt|;
name|ah
operator|->
name|ah_sh
operator|=
name|sh
expr_stmt|;
name|ah
operator|->
name|ah_devid
operator|=
name|devid
expr_stmt|;
comment|/* NB: for alq */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_devid
operator|=
name|devid
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_subvendorid
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_powerLimit
operator|=
name|MAX_RATE_POWER
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tpScale
operator|=
name|HAL_TP_SCALE_MAX
expr_stmt|;
comment|/* no scaling */
name|ahp
operator|->
name|ah_antControl
operator|=
name|HAL_ANT_VARIABLE
expr_stmt|;
name|ahp
operator|->
name|ah_diversity
operator|=
name|AH_TRUE
expr_stmt|;
name|ahp
operator|->
name|ah_bIQCalibration
operator|=
name|AH_FALSE
expr_stmt|;
comment|/* 	 * Enable MIC handling. 	 */
name|ahp
operator|->
name|ah_staId1Defaults
operator|=
name|AR_STA_ID1_CRPT_MIC_ENABLE
expr_stmt|;
name|ahp
operator|->
name|ah_rssiThr
operator|=
name|INIT_RSSI_THR
expr_stmt|;
name|ahp
operator|->
name|ah_tpcEnabled
operator|=
name|AH_FALSE
expr_stmt|;
comment|/* disabled by default */
name|ahp
operator|->
name|ah_phyPowerOn
operator|=
name|AH_FALSE
expr_stmt|;
name|ahp
operator|->
name|ah_macTPC
operator|=
name|SM
argument_list|(
name|MAX_RATE_POWER
argument_list|,
name|AR_TPC_ACK
argument_list|)
operator||
name|SM
argument_list|(
name|MAX_RATE_POWER
argument_list|,
name|AR_TPC_CTS
argument_list|)
operator||
name|SM
argument_list|(
name|MAX_RATE_POWER
argument_list|,
name|AR_TPC_CHIRP
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_beaconInterval
operator|=
literal|100
expr_stmt|;
comment|/* XXX [20..1000] */
name|ahp
operator|->
name|ah_enable32kHzClock
operator|=
name|DONT_USE_32KHZ
expr_stmt|;
comment|/* XXX */
name|ahp
operator|->
name|ah_slottime
operator|=
operator|(
name|u_int
operator|)
operator|-
literal|1
expr_stmt|;
name|ahp
operator|->
name|ah_acktimeout
operator|=
operator|(
name|u_int
operator|)
operator|-
literal|1
expr_stmt|;
name|ahp
operator|->
name|ah_ctstimeout
operator|=
operator|(
name|u_int
operator|)
operator|-
literal|1
expr_stmt|;
name|ahp
operator|->
name|ah_sifstime
operator|=
operator|(
name|u_int
operator|)
operator|-
literal|1
expr_stmt|;
name|ahp
operator|->
name|ah_txTrigLev
operator|=
name|INIT_TX_FIFO_THRESHOLD
operator|,
name|ahp
operator|->
name|ah_maxTxTrigLev
operator|=
name|MAX_TX_FIFO_THRESHOLD
operator|,
name|OS_MEMCPY
argument_list|(
operator|&
name|ahp
operator|->
name|ah_bssidmask
argument_list|,
name|defbssidmask
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Validate MAC version and revision.   */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5212IsMacSupported
parameter_list|(
name|uint8_t
name|macVersion
parameter_list|,
name|uint8_t
name|macRev
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
specifier|static
specifier|const
struct|struct
block|{
name|uint8_t
name|version
decl_stmt|;
name|uint8_t
name|revMin
decl_stmt|,
name|revMax
decl_stmt|;
block|}
name|macs
index|[]
init|=
block|{
block|{
name|AR_SREV_VERSION_VENICE
block|,
name|AR_SREV_D2PLUS
block|,
name|AR_SREV_REVISION_MAX
block|}
block|,
block|{
name|AR_SREV_VERSION_GRIFFIN
block|,
name|AR_SREV_D2PLUS
block|,
name|AR_SREV_REVISION_MAX
block|}
block|,
block|{
name|AR_SREV_5413
block|,
name|AR_SREV_REVISION_MIN
block|,
name|AR_SREV_REVISION_MAX
block|}
block|,
block|{
name|AR_SREV_5424
block|,
name|AR_SREV_REVISION_MIN
block|,
name|AR_SREV_REVISION_MAX
block|}
block|,
block|{
name|AR_SREV_2425
block|,
name|AR_SREV_REVISION_MIN
block|,
name|AR_SREV_REVISION_MAX
block|}
block|,
block|{
name|AR_SREV_2417
block|,
name|AR_SREV_REVISION_MIN
block|,
name|AR_SREV_REVISION_MAX
block|}
block|, 	}
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|macs
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|macs
index|[
name|i
index|]
operator|.
name|version
operator|==
name|macVersion
operator|&&
name|macs
index|[
name|i
index|]
operator|.
name|revMin
operator|<=
name|macRev
operator|&&
name|macRev
operator|<=
name|macs
index|[
name|i
index|]
operator|.
name|revMax
condition|)
return|return
name|AH_TRUE
return|;
return|return
name|AH_FALSE
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Attach for an AR5212 part.  */
end_comment

begin_function
specifier|static
name|struct
name|ath_hal
modifier|*
name|ar5212Attach
parameter_list|(
name|uint16_t
name|devid
parameter_list|,
name|HAL_SOFTC
name|sc
parameter_list|,
name|HAL_BUS_TAG
name|st
parameter_list|,
name|HAL_BUS_HANDLE
name|sh
parameter_list|,
name|uint16_t
modifier|*
name|eepromdata
parameter_list|,
name|HAL_OPS_CONFIG
modifier|*
name|ah_config
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
define|#
directive|define
name|AH_EEPROM_PROTECT
parameter_list|(
name|ah
parameter_list|)
define|\
value|(AH_PRIVATE(ah)->ah_ispcie)? AR_EEPROM_PROTECT_PCIE : AR_EEPROM_PROTECT)
name|struct
name|ath_hal_5212
modifier|*
name|ahp
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
decl_stmt|;
name|struct
name|ath_hal_rf
modifier|*
name|rf
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|uint16_t
name|eeval
decl_stmt|;
name|HAL_STATUS
name|ecode
decl_stmt|;
name|HALDEBUG
argument_list|(
name|AH_NULL
argument_list|,
name|HAL_DEBUG_ATTACH
argument_list|,
literal|"%s: sc %p st %p sh %p\n"
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|st
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sh
argument_list|)
expr_stmt|;
comment|/* NB: memory is returned zero'd */
name|ahp
operator|=
name|ath_hal_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ath_hal_5212
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|AH_NULL
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: cannot allocate memory for state block\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|HAL_ENOMEM
expr_stmt|;
return|return
name|AH_NULL
return|;
block|}
name|ar5212InitState
argument_list|(
name|ahp
argument_list|,
name|devid
argument_list|,
name|sc
argument_list|,
name|st
argument_list|,
name|sh
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ah
operator|=
operator|&
name|ahp
operator|->
name|ah_priv
operator|.
name|h
expr_stmt|;
if|if
condition|(
operator|!
name|ar5212SetPowerMode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: couldn't wakeup chip\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Read Revisions from Chips before taking out of reset */
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_SREV
argument_list|)
operator|&
name|AR_SREV_ID
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|=
name|val
operator|>>
name|AR_SREV_ID_S
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macRev
operator|=
name|val
operator|&
name|AR_SREV_REVISION
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ispcie
operator|=
name|IS_5424
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_2425
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar5212IsMacSupported
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macRev
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: Mac Chip Rev 0x%02x.%x not supported\n"
argument_list|,
name|__func__
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macRev
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_ENOTSUPP
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* setup common ini data; rf backends handle remainder */
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ini_modes
argument_list|,
name|ar5212Modes
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ini_common
argument_list|,
name|ar5212Common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar5212ChipReset
argument_list|(
name|ah
argument_list|,
name|AH_NULL
argument_list|)
condition|)
block|{
comment|/* reset chip */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: chip reset failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyRev
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CHIP_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ispcie
condition|)
block|{
comment|/* XXX: build flag to disable this? */
name|ath_hal_configPCIE
argument_list|(
name|ah
argument_list|,
name|AH_FALSE
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ar5212ChipTest
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: hardware self-test failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_ESELFTEST
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Enable PCI core retry fix in software for Hainan and up */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|>=
name|AR_SREV_VERSION_VENICE
condition|)
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|,
name|AR_PCICFG_RETRYFIXEN
argument_list|)
expr_stmt|;
comment|/* 	 * Set correct Baseband to analog shift 	 * setting to access analog chips. 	 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0x00000007
argument_list|)
expr_stmt|;
comment|/* Read Radio Chip Rev Extract */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
operator|=
name|ar5212GetRadioRev
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|rf
operator|=
name|ath_hal_rfprobe
argument_list|(
name|ah
argument_list|,
operator|&
name|ecode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|==
name|AH_NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* NB: silently accept anything in release code per Atheros */
switch|switch
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
operator|&
name|AR_RADIO_SREV_MAJOR
condition|)
block|{
case|case
name|AR_RAD5111_SREV_MAJOR
case|:
case|case
name|AR_RAD5112_SREV_MAJOR
case|:
case|case
name|AR_RAD2112_SREV_MAJOR
case|:
case|case
name|AR_RAD2111_SREV_MAJOR
case|:
case|case
name|AR_RAD2413_SREV_MAJOR
case|:
case|case
name|AR_RAD5413_SREV_MAJOR
case|:
case|case
name|AR_RAD5424_SREV_MAJOR
case|:
break|break;
default|default:
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
operator|==
literal|0
condition|)
block|{
comment|/* 			 * When RF_Silent is used, the 			 * analog chip is reset.  So when the system boots 			 * up with the radio switch off we cannot determine 			 * the RF chip rev.  To workaround this check the 			 * mac+phy revs and if Hainan, set the radio rev 			 * to Derby. 			 */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|==
name|AR_SREV_VERSION_VENICE
operator|&&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macRev
operator|==
name|AR_SREV_HAINAN
operator|&&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyRev
operator|==
name|AR_PHYREV_HAINAN
condition|)
block|{
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
operator|=
name|AR_ANALOG5REV_HAINAN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IS_2413
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Griffin */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
operator|=
name|AR_RAD2413_SREV_MAJOR
operator||
literal|0x1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IS_5413
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Eagle */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
operator|=
name|AR_RAD5413_SREV_MAJOR
operator||
literal|0x2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IS_2425
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_2417
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Swan or Nala */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
operator|=
name|AR_RAD5424_SREV_MAJOR
operator||
literal|0x2
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|AH_DEBUG
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: 5G Radio Chip Rev 0x%02X is not supported by "
literal|"this driver\n"
argument_list|,
name|__func__
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_ENOTSUPP
expr_stmt|;
goto|goto
name|bad
goto|;
endif|#
directive|endif
block|}
if|if
condition|(
name|IS_RAD5112_REV1
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: 5112 Rev 1 is not supported by this "
literal|"driver (analog5GhzRev 0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_ENOTSUPP
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|)
expr_stmt|;
name|val
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_PCICFG_EEPROM_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ispcie
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: unsupported EEPROM size %u (0x%x) found\n"
argument_list|,
name|__func__
argument_list|,
name|val
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_EESIZE
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* XXX AH_PRIVATE(ah)->ah_isPciExpress = AH_TRUE; */
block|}
elseif|else
if|if
condition|(
name|val
operator|!=
name|AR_PCICFG_EEPROM_SIZE_16K
condition|)
block|{
if|if
condition|(
name|AR_PCICFG_EEPROM_SIZE_FAILED
operator|==
name|val
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: unsupported EEPROM size %u (0x%x) found\n"
argument_list|,
name|__func__
argument_list|,
name|val
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_EESIZE
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: EEPROM size = %d. Must be %d (16k).\n"
argument_list|,
name|__func__
argument_list|,
name|val
argument_list|,
name|AR_PCICFG_EEPROM_SIZE_16K
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_EESIZE
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ecode
operator|=
name|ath_hal_legacyEepromAttach
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecode
operator|!=
name|HAL_OK
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|ahp
operator|->
name|ah_isHb63
operator|=
name|IS_2425
argument_list|(
name|ah
argument_list|)
operator|&&
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_ISTALON
argument_list|)
expr_stmt|;
comment|/* 	 * If Bmode and AR5212, verify 2.4 analog exists 	 */
if|if
condition|(
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_BMODE
argument_list|)
operator|&&
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
operator|&
literal|0xF0
operator|)
operator|==
name|AR_RAD5111_SREV_MAJOR
condition|)
block|{
comment|/* 		 * Set correct Baseband to analog shift 		 * setting to access analog chips. 		 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0x00004007
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog2GhzRev
operator|=
name|ar5212GetRadioRev
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* Set baseband for 5GHz chip */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0x00000007
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog2GhzRev
operator|&
literal|0xF0
operator|)
operator|!=
name|AR_RAD2111_SREV_MAJOR
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: 2G Radio Chip Rev 0x%02X is not "
literal|"supported by this driver\n"
argument_list|,
name|__func__
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog2GhzRev
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_ENOTSUPP
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|ecode
operator|=
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_REGDMN_0
argument_list|,
operator|&
name|eeval
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecode
operator|!=
name|HAL_OK
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: cannot read regulatory domain from EEPROM\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_currentRD
operator|=
name|eeval
expr_stmt|;
comment|/* XXX record serial number */
comment|/* 	 * Got everything we need now to setup the capabilities. 	 */
if|if
condition|(
operator|!
name|ar5212FillCapabilityInfo
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: failed ar5212FillCapabilityInfo\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_EEREAD
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
name|rf
operator|->
name|attach
argument_list|(
name|ah
argument_list|,
operator|&
name|ecode
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: RF setup failed, status %u\n"
argument_list|,
name|__func__
argument_list|,
name|ecode
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Set noise floor adjust method; we arrange a 	 * direct call instead of thunking. 	 */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_getNfAdjust
operator|=
name|ahp
operator|->
name|ah_rfHal
operator|->
name|getNfAdjust
expr_stmt|;
comment|/* Initialize gain ladder thermal calibration structure */
name|ar5212InitializeGainValues
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_MACADDR
argument_list|,
name|ahp
operator|->
name|ah_macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecode
operator|!=
name|HAL_OK
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: error getting mac address from EEPROM\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ar5212AniSetup
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* Setup of Radar/AR structures happens in ath_hal_initchannels*/
name|ar5212InitNfCalHistBuffer
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* XXX EAR stuff goes here */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ATTACH
argument_list|,
literal|"%s: return\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ah
return|;
name|bad
label|:
if|if
condition|(
name|ahp
condition|)
name|ar5212Detach
argument_list|(
operator|(
expr|struct
name|ath_hal
operator|*
operator|)
name|ahp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
operator|*
name|status
operator|=
name|ecode
expr_stmt|;
return|return
name|AH_NULL
return|;
undef|#
directive|undef
name|AH_EEPROM_PROTECT
block|}
end_function

begin_function
name|void
name|ar5212Detach
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ATTACH
argument_list|,
literal|"%s:\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|ah
operator|!=
name|AH_NULL
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|ah
operator|->
name|ah_magic
operator|==
name|AR5212_MAGIC
argument_list|)
expr_stmt|;
name|ar5212AniDetach
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ar5212RfDetach
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ar5212Disable
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ar5212SetPowerMode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_FULL_SLEEP
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
name|ath_hal_eepromDetach
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ath_hal_free
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5212ChipTest
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|uint32_t
name|regAddr
index|[
literal|2
index|]
init|=
block|{
name|AR_STA_ID0
block|,
name|AR_PHY_BASE
operator|+
operator|(
literal|8
operator|<<
literal|2
operator|)
block|}
decl_stmt|;
name|uint32_t
name|regHold
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|patternData
index|[
literal|4
index|]
init|=
block|{
literal|0x55555555
block|,
literal|0xaaaaaaaa
block|,
literal|0x66666666
block|,
literal|0x99999999
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Test PHY& MAC registers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|addr
init|=
name|regAddr
index|[
name|i
index|]
decl_stmt|;
name|uint32_t
name|wrData
decl_stmt|,
name|rdData
decl_stmt|;
name|regHold
index|[
name|i
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|0x100
condition|;
name|j
operator|++
control|)
block|{
name|wrData
operator|=
operator|(
name|j
operator|<<
literal|16
operator|)
operator||
name|j
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
name|wrData
argument_list|)
expr_stmt|;
name|rdData
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdData
operator|!=
name|wrData
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: address test failed addr: 0x%08x - wr:0x%08x != rd:0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|addr
argument_list|,
name|wrData
argument_list|,
name|rdData
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|wrData
operator|=
name|patternData
index|[
name|j
index|]
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
name|wrData
argument_list|)
expr_stmt|;
name|rdData
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrData
operator|!=
name|rdData
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: address test failed addr: 0x%08x - wr:0x%08x != rd:0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|addr
argument_list|,
name|wrData
argument_list|,
name|rdData
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|regAddr
index|[
name|i
index|]
argument_list|,
name|regHold
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|OS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Store the channel edges for the requested operational mode  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212GetChannelEdges
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint16_t
name|flags
parameter_list|,
name|uint16_t
modifier|*
name|low
parameter_list|,
name|uint16_t
modifier|*
name|high
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CHAN_5GHZ
condition|)
block|{
operator|*
name|low
operator|=
literal|4915
expr_stmt|;
operator|*
name|high
operator|=
literal|6100
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|IEEE80211_CHAN_2GHZ
operator|)
operator|&&
operator|(
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_BMODE
argument_list|)
operator|||
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_GMODE
argument_list|)
operator|)
condition|)
block|{
operator|*
name|low
operator|=
literal|2312
expr_stmt|;
operator|*
name|high
operator|=
literal|2732
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Disable PLL when in L0s as well as receiver clock when in L1.  * This power saving option must be enabled through the Serdes.  *  * Programming the Serdes must go through the same 288 bit serial shift  * register as the other analog registers.  Hence the 9 writes.  *  * XXX Clean up the magic numbers.  */
end_comment

begin_function
specifier|static
name|void
name|ar5212ConfigPCIE
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|restore
parameter_list|,
name|HAL_BOOL
name|power_off
parameter_list|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_SERDES
argument_list|,
literal|0x9248fc00
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_SERDES
argument_list|,
literal|0x24924924
argument_list|)
expr_stmt|;
comment|/* RX shut off when elecidle is asserted */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_SERDES
argument_list|,
literal|0x28000039
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_SERDES
argument_list|,
literal|0x53160824
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_SERDES
argument_list|,
literal|0xe5980579
argument_list|)
expr_stmt|;
comment|/* Shut off PLL and CLKREQ active in L1 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_SERDES
argument_list|,
literal|0x001defff
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_SERDES
argument_list|,
literal|0x1aaabe40
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_SERDES
argument_list|,
literal|0xbe105554
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_SERDES
argument_list|,
literal|0x000e3007
argument_list|)
expr_stmt|;
comment|/* Load the new settings */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_SERDES2
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar5212DisablePCIE
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
comment|/* NB: fill in for 9100 */
block|}
end_function

begin_comment
comment|/*  * Fill all software cached or static hardware state information.  * Return failure if capabilities are to come from EEPROM and  * cannot be read.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212FillCapabilityInfo
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
define|#
directive|define
name|AR_KEYTABLE_SIZE
value|128
define|#
directive|define
name|IS_GRIFFIN_LITE
parameter_list|(
name|ah
parameter_list|)
define|\
value|(AH_PRIVATE(ah)->ah_macVersion == AR_SREV_VERSION_GRIFFIN&& \      AH_PRIVATE(ah)->ah_macRev == AR_SREV_GRIFFIN_LITE)
define|#
directive|define
name|IS_COBRA
parameter_list|(
name|ah
parameter_list|)
define|\
value|(AH_PRIVATE(ah)->ah_macVersion == AR_SREV_VERSION_COBRA)
define|#
directive|define
name|IS_2112
parameter_list|(
name|ah
parameter_list|)
define|\
value|((AH_PRIVATE(ah)->ah_analog5GhzRev& 0xF0) == AR_RAD2112_SREV_MAJOR)
name|struct
name|ath_hal_private
modifier|*
name|ahpriv
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CAPABILITIES
modifier|*
name|pCap
init|=
operator|&
name|ahpriv
operator|->
name|ah_caps
decl_stmt|;
name|uint16_t
name|capField
decl_stmt|,
name|val
decl_stmt|;
comment|/* Read the capability EEPROM location */
if|if
condition|(
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_OPCAP
argument_list|,
operator|&
name|capField
argument_list|)
operator|!=
name|HAL_OK
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: unable to read caps from eeprom\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
if|if
condition|(
name|IS_2112
argument_list|(
name|ah
argument_list|)
condition|)
name|ath_hal_eepromSet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_AMODE
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|capField
operator|==
literal|0
operator|&&
name|IS_GRIFFIN_LITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* 		 * For griffin-lite cards with unprogrammed capabilities. 		 */
name|ath_hal_eepromSet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_COMPRESS
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
name|ath_hal_eepromSet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_FASTFRAME
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
name|ath_hal_eepromSet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_TURBO5DISABLE
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
name|ath_hal_eepromSet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_TURBO2DISABLE
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ATTACH
argument_list|,
literal|"%s: override caps for griffin-lite, now 0x%x (+!turbo)\n"
argument_list|,
name|__func__
argument_list|,
name|capField
argument_list|)
expr_stmt|;
block|}
comment|/* Modify reg domain on newer cards that need to work with older sw */
if|if
condition|(
name|ahpriv
operator|->
name|ah_opmode
operator|!=
name|HAL_M_HOSTAP
operator|&&
name|ahpriv
operator|->
name|ah_subvendorid
operator|==
name|AR_SUBVENDOR_ID_NEW_A
condition|)
block|{
if|if
condition|(
name|ahpriv
operator|->
name|ah_currentRD
operator|==
literal|0x64
operator|||
name|ahpriv
operator|->
name|ah_currentRD
operator|==
literal|0x65
condition|)
name|ahpriv
operator|->
name|ah_currentRD
operator|+=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|ahpriv
operator|->
name|ah_currentRD
operator|==
literal|0x41
condition|)
name|ahpriv
operator|->
name|ah_currentRD
operator|=
literal|0x43
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ATTACH
argument_list|,
literal|"%s: regdomain mapped to 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ahpriv
operator|->
name|ah_currentRD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|==
name|AR_SREV_2417
operator|||
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|==
name|AR_SREV_2425
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ATTACH
argument_list|,
literal|"%s: enable Bmode and disable turbo for Swan/Nala\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ath_hal_eepromSet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_BMODE
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
name|ath_hal_eepromSet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_COMPRESS
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
name|ath_hal_eepromSet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_FASTFRAME
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
name|ath_hal_eepromSet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_TURBO5DISABLE
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
name|ath_hal_eepromSet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_TURBO2DISABLE
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* Construct wireless mode from EEPROM */
name|pCap
operator|->
name|halWirelessModes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_AMODE
argument_list|)
condition|)
block|{
name|pCap
operator|->
name|halWirelessModes
operator||=
name|HAL_MODE_11A
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_TURBO5DISABLE
argument_list|)
condition|)
name|pCap
operator|->
name|halWirelessModes
operator||=
name|HAL_MODE_TURBO
expr_stmt|;
block|}
if|if
condition|(
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_BMODE
argument_list|)
condition|)
name|pCap
operator|->
name|halWirelessModes
operator||=
name|HAL_MODE_11B
expr_stmt|;
if|if
condition|(
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_GMODE
argument_list|)
operator|&&
name|ahpriv
operator|->
name|ah_subvendorid
operator|!=
name|AR_SUBVENDOR_ID_NOG
condition|)
block|{
name|pCap
operator|->
name|halWirelessModes
operator||=
name|HAL_MODE_11G
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_TURBO2DISABLE
argument_list|)
condition|)
name|pCap
operator|->
name|halWirelessModes
operator||=
name|HAL_MODE_108G
expr_stmt|;
block|}
name|pCap
operator|->
name|halLow2GhzChan
operator|=
literal|2312
expr_stmt|;
comment|/* XXX 2417 too? */
if|if
condition|(
name|IS_RAD5112_ANY
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_5413
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_2425
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_2417
argument_list|(
name|ah
argument_list|)
condition|)
name|pCap
operator|->
name|halHigh2GhzChan
operator|=
literal|2500
expr_stmt|;
else|else
name|pCap
operator|->
name|halHigh2GhzChan
operator|=
literal|2732
expr_stmt|;
comment|/* 	 * For AR5111 version< 4, the lowest centre frequency supported is 	 * 5130MHz.  For AR5111 version 4, the 4.9GHz channels are supported 	 * but only in 10MHz increments. 	 * 	 * In addition, the programming method is wrong - it uses the IEEE 	 * channel number to calculate the frequency, rather than the 	 * channel centre.  Since half/quarter rates re-use some of the 	 * 5GHz channel IEEE numbers, this will result in a badly programmed 	 * synth. 	 * 	 * Until the relevant support is written, just limit lower frequency 	 * support for AR5111 so things aren't incorrectly programmed. 	 * 	 * XXX It's also possible this code doesn't correctly limit the 	 * centre frequencies of potential channels; this is very important 	 * for half/quarter rate! 	 */
if|if
condition|(
name|AH_RADIO_MAJOR
argument_list|(
name|ah
argument_list|)
operator|==
name|AR_RAD5111_SREV_MAJOR
condition|)
block|{
name|pCap
operator|->
name|halLow5GhzChan
operator|=
literal|5120
expr_stmt|;
comment|/* XXX lowest centre = 5130MHz */
block|}
else|else
block|{
name|pCap
operator|->
name|halLow5GhzChan
operator|=
literal|4915
expr_stmt|;
block|}
name|pCap
operator|->
name|halHigh5GhzChan
operator|=
literal|6100
expr_stmt|;
name|pCap
operator|->
name|halCipherCkipSupport
operator|=
name|AH_FALSE
expr_stmt|;
name|pCap
operator|->
name|halCipherTkipSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halCipherAesCcmSupport
operator|=
operator|(
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_AES
argument_list|)
operator|&&
operator|(
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|>
name|AR_SREV_VERSION_VENICE
operator|)
operator|||
operator|(
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|==
name|AR_SREV_VERSION_VENICE
operator|)
operator|&&
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macRev
operator|>=
name|AR_SREV_VERSION_OAHU
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
name|pCap
operator|->
name|halMicCkipSupport
operator|=
name|AH_FALSE
expr_stmt|;
name|pCap
operator|->
name|halMicTkipSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halMicAesCcmSupport
operator|=
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_AES
argument_list|)
expr_stmt|;
comment|/* 	 * Starting with Griffin TX+RX mic keys can be combined 	 * in one key cache slot. 	 */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|>=
name|AR_SREV_VERSION_GRIFFIN
condition|)
name|pCap
operator|->
name|halTkipMicTxRxKeySupport
operator|=
name|AH_TRUE
expr_stmt|;
else|else
name|pCap
operator|->
name|halTkipMicTxRxKeySupport
operator|=
name|AH_FALSE
expr_stmt|;
name|pCap
operator|->
name|halChanSpreadSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halSleepAfterBeaconBroken
operator|=
name|AH_TRUE
expr_stmt|;
if|if
condition|(
name|ahpriv
operator|->
name|ah_macRev
operator|>
literal|1
operator|||
name|IS_COBRA
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|pCap
operator|->
name|halCompressSupport
operator|=
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_COMPRESS
argument_list|)
operator|&&
operator|(
name|pCap
operator|->
name|halWirelessModes
operator|&
operator|(
name|HAL_MODE_11A
operator||
name|HAL_MODE_11G
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|pCap
operator|->
name|halBurstSupport
operator|=
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_BURST
argument_list|)
expr_stmt|;
name|pCap
operator|->
name|halFastFramesSupport
operator|=
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_FASTFRAME
argument_list|)
operator|&&
operator|(
name|pCap
operator|->
name|halWirelessModes
operator|&
operator|(
name|HAL_MODE_11A
operator||
name|HAL_MODE_11G
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|pCap
operator|->
name|halChapTuningSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halTurboPrimeSupport
operator|=
name|AH_TRUE
expr_stmt|;
block|}
name|pCap
operator|->
name|halTurboGSupport
operator|=
name|pCap
operator|->
name|halWirelessModes
operator|&
name|HAL_MODE_108G
expr_stmt|;
name|pCap
operator|->
name|halPSPollBroken
operator|=
name|AH_TRUE
expr_stmt|;
comment|/* XXX fixed in later revs? */
name|pCap
operator|->
name|halNumMRRetries
operator|=
literal|4
expr_stmt|;
comment|/* Hardware supports 4 MRR */
name|pCap
operator|->
name|halNumTxMaps
operator|=
literal|1
expr_stmt|;
comment|/* Single TX ptr per descr */
name|pCap
operator|->
name|halVEOLSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halBssIdMaskSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halMcastKeySrchSupport
operator|=
name|AH_TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|ahpriv
operator|->
name|ah_macVersion
operator|==
name|AR_SREV_VERSION_VENICE
operator|&&
name|ahpriv
operator|->
name|ah_macRev
operator|==
literal|8
operator|)
operator|||
name|ahpriv
operator|->
name|ah_macVersion
operator|>
name|AR_SREV_VERSION_VENICE
condition|)
name|pCap
operator|->
name|halTsfAddSupport
operator|=
name|AH_TRUE
expr_stmt|;
if|if
condition|(
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_MAXQCU
argument_list|,
operator|&
name|val
argument_list|)
operator|==
name|HAL_OK
condition|)
name|pCap
operator|->
name|halTotalQueues
operator|=
name|val
expr_stmt|;
else|else
name|pCap
operator|->
name|halTotalQueues
operator|=
name|HAL_NUM_TX_QUEUES
expr_stmt|;
if|if
condition|(
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_KCENTRIES
argument_list|,
operator|&
name|val
argument_list|)
operator|==
name|HAL_OK
condition|)
name|pCap
operator|->
name|halKeyCacheSize
operator|=
name|val
expr_stmt|;
else|else
name|pCap
operator|->
name|halKeyCacheSize
operator|=
name|AR_KEYTABLE_SIZE
expr_stmt|;
name|pCap
operator|->
name|halChanHalfRate
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halChanQuarterRate
operator|=
name|AH_TRUE
expr_stmt|;
comment|/* 	 * RSSI uses the combined field; some 11n NICs may use 	 * the control chain RSSI. 	 */
name|pCap
operator|->
name|halUseCombinedRadarRssi
operator|=
name|AH_TRUE
expr_stmt|;
if|if
condition|(
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_RFKILL
argument_list|)
operator|&&
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_RFSILENT
argument_list|,
operator|&
name|ahpriv
operator|->
name|ah_rfsilent
argument_list|)
operator|==
name|HAL_OK
condition|)
block|{
comment|/* NB: enabled by default */
name|ahpriv
operator|->
name|ah_rfkillEnabled
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halRfSilentSupport
operator|=
name|AH_TRUE
expr_stmt|;
block|}
comment|/* NB: this is a guess, noone seems to know the answer */
name|ahpriv
operator|->
name|ah_rxornIsFatal
operator|=
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|<
name|AR_SREV_VERSION_VENICE
operator|)
expr_stmt|;
comment|/* enable features that first appeared in Hainan */
if|if
condition|(
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|==
name|AR_SREV_VERSION_VENICE
operator|&&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macRev
operator|==
name|AR_SREV_HAINAN
operator|)
operator|||
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|>
name|AR_SREV_VERSION_VENICE
condition|)
block|{
comment|/* h/w phy counters */
name|pCap
operator|->
name|halHwPhyCounterSupport
operator|=
name|AH_TRUE
expr_stmt|;
comment|/* bssid match disable */
name|pCap
operator|->
name|halBssidMatchSupport
operator|=
name|AH_TRUE
expr_stmt|;
block|}
name|pCap
operator|->
name|halTstampPrecision
operator|=
literal|15
expr_stmt|;
name|pCap
operator|->
name|halIntrMask
operator|=
name|HAL_INT_COMMON
operator||
name|HAL_INT_RX
operator||
name|HAL_INT_TX
operator||
name|HAL_INT_FATAL
operator||
name|HAL_INT_BNR
operator||
name|HAL_INT_BMISC
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|<
name|AR_SREV_VERSION_GRIFFIN
condition|)
name|pCap
operator|->
name|halIntrMask
operator|&=
operator|~
name|HAL_INT_TBTT
expr_stmt|;
name|pCap
operator|->
name|hal4kbSplitTransSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halHasRxSelfLinkedTail
operator|=
name|AH_TRUE
expr_stmt|;
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|IS_COBRA
undef|#
directive|undef
name|IS_GRIFFIN_LITE
undef|#
directive|undef
name|AR_KEYTABLE_SIZE
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ar5212Probe
parameter_list|(
name|uint16_t
name|vendorid
parameter_list|,
name|uint16_t
name|devid
parameter_list|)
block|{
if|if
condition|(
name|vendorid
operator|==
name|ATHEROS_VENDOR_ID
operator|||
name|vendorid
operator|==
name|ATHEROS_3COM_VENDOR_ID
operator|||
name|vendorid
operator|==
name|ATHEROS_3COM2_VENDOR_ID
condition|)
block|{
switch|switch
condition|(
name|devid
condition|)
block|{
case|case
name|AR5212_FPGA
case|:
return|return
literal|"Atheros 5212 (FPGA)"
return|;
case|case
name|AR5212_DEVID
case|:
case|case
name|AR5212_DEVID_IBM
case|:
case|case
name|AR5212_DEFAULT
case|:
return|return
literal|"Atheros 5212"
return|;
case|case
name|AR5212_AR2413
case|:
return|return
literal|"Atheros 2413"
return|;
case|case
name|AR5212_AR2417
case|:
return|return
literal|"Atheros 2417"
return|;
case|case
name|AR5212_AR5413
case|:
return|return
literal|"Atheros 5413"
return|;
case|case
name|AR5212_AR5424
case|:
return|return
literal|"Atheros 5424/2424"
return|;
block|}
block|}
return|return
name|AH_NULL
return|;
block|}
end_function

begin_expr_stmt
name|AH_CHIP
argument_list|(
name|AR5212
argument_list|,
name|ar5212Probe
argument_list|,
name|ar5212Attach
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

