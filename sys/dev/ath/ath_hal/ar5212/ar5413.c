begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2008 Sam Leffler, Errno Consulting  * Copyright (c) 2002-2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $Id: ar5413.c,v 1.8 2008/11/15 22:15:46 sam Exp $  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_eeprom_v3.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212phy.h"
end_include

begin_define
define|#
directive|define
name|AH_5212_5413
end_define

begin_include
include|#
directive|include
file|"ar5212/ar5212.ini"
end_include

begin_define
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
end_define

begin_struct
struct|struct
name|ar5413State
block|{
name|RF_HAL_FUNCS
name|base
decl_stmt|;
comment|/* public state, must be first */
name|uint16_t
name|pcdacTable
index|[
name|PWR_TABLE_SIZE_2413
index|]
decl_stmt|;
name|uint32_t
name|Bank1Data
index|[
name|N
argument_list|(
name|ar5212Bank1_5413
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|Bank2Data
index|[
name|N
argument_list|(
name|ar5212Bank2_5413
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|Bank3Data
index|[
name|N
argument_list|(
name|ar5212Bank3_5413
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|Bank6Data
index|[
name|N
argument_list|(
name|ar5212Bank6_5413
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|Bank7Data
index|[
name|N
argument_list|(
name|ar5212Bank7_5413
argument_list|)
index|]
decl_stmt|;
comment|/* 	 * Private state for reduced stack usage. 	 */
comment|/* filled out Vpd table for all pdGains (chanL) */
name|uint16_t
name|vpdTable_L
index|[
name|MAX_NUM_PDGAINS_PER_CHANNEL
index|]
index|[
name|MAX_PWR_RANGE_IN_HALF_DB
index|]
decl_stmt|;
comment|/* filled out Vpd table for all pdGains (chanR) */
name|uint16_t
name|vpdTable_R
index|[
name|MAX_NUM_PDGAINS_PER_CHANNEL
index|]
index|[
name|MAX_PWR_RANGE_IN_HALF_DB
index|]
decl_stmt|;
comment|/* filled out Vpd table for all pdGains (interpolated) */
name|uint16_t
name|vpdTable_I
index|[
name|MAX_NUM_PDGAINS_PER_CHANNEL
index|]
index|[
name|MAX_PWR_RANGE_IN_HALF_DB
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|AR5413
parameter_list|(
name|ah
parameter_list|)
value|((struct ar5413State *) AH5212(ah)->ah_rfHal)
end_define

begin_function_decl
specifier|extern
name|void
name|ar5212ModifyRfBuffer
parameter_list|(
name|uint32_t
modifier|*
name|rfBuf
parameter_list|,
name|uint32_t
name|reg32
parameter_list|,
name|uint32_t
name|numBits
parameter_list|,
name|uint32_t
name|firstBit
parameter_list|,
name|uint32_t
name|column
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|ar5413WriteRegs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|modesIndex
parameter_list|,
name|u_int
name|freqIndex
parameter_list|,
name|int
name|writes
parameter_list|)
block|{
name|HAL_INI_WRITE_ARRAY
argument_list|(
name|ah
argument_list|,
name|ar5212Modes_5413
argument_list|,
name|modesIndex
argument_list|,
name|writes
argument_list|)
expr_stmt|;
name|HAL_INI_WRITE_ARRAY
argument_list|(
name|ah
argument_list|,
name|ar5212Common_5413
argument_list|,
literal|1
argument_list|,
name|writes
argument_list|)
expr_stmt|;
name|HAL_INI_WRITE_ARRAY
argument_list|(
name|ah
argument_list|,
name|ar5212BB_RfGain_5413
argument_list|,
name|freqIndex
argument_list|,
name|writes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take the MHz channel value and set the Channel value  *  * ASSUMES: Writes enabled to analog bus  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5413SetChannel
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|chan
parameter_list|)
block|{
name|uint32_t
name|channelSel
init|=
literal|0
decl_stmt|;
name|uint32_t
name|bModeSynth
init|=
literal|0
decl_stmt|;
name|uint32_t
name|aModeRefSel
init|=
literal|0
decl_stmt|;
name|uint32_t
name|reg32
init|=
literal|0
decl_stmt|;
name|uint16_t
name|freq
decl_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_SETCHANNEL
argument_list|,
name|chan
operator|->
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|channel
operator|<
literal|4800
condition|)
block|{
name|uint32_t
name|txctl
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|chan
operator|->
name|channel
operator|-
literal|2192
operator|)
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
block|{
name|channelSel
operator|=
operator|(
operator|(
name|chan
operator|->
name|channel
operator|-
literal|672
operator|)
operator|*
literal|2
operator|-
literal|3040
operator|)
operator|/
literal|10
expr_stmt|;
name|bModeSynth
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|chan
operator|->
name|channel
operator|-
literal|2224
operator|)
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
block|{
name|channelSel
operator|=
operator|(
operator|(
name|chan
operator|->
name|channel
operator|-
literal|704
operator|)
operator|*
literal|2
operator|-
literal|3040
operator|)
operator|/
literal|10
expr_stmt|;
name|bModeSynth
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel %u MHz\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|channel
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|channelSel
operator|=
operator|(
name|channelSel
operator|<<
literal|2
operator|)
operator|&
literal|0xff
expr_stmt|;
name|channelSel
operator|=
name|ath_hal_reverseBits
argument_list|(
name|channelSel
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|txctl
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_TX_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|channel
operator|==
literal|2484
condition|)
block|{
comment|/* Enable channel spreading for channel 14 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_TX_CTRL
argument_list|,
name|txctl
operator||
name|AR_PHY_CCK_TX_CTRL_JAPAN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_TX_CTRL
argument_list|,
name|txctl
operator|&
operator|~
name|AR_PHY_CCK_TX_CTRL_JAPAN
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|chan
operator|->
name|channel
operator|%
literal|5
operator|)
operator|==
literal|2
operator|)
operator|&&
operator|(
name|chan
operator|->
name|channel
operator|<=
literal|5435
operator|)
condition|)
block|{
name|freq
operator|=
name|chan
operator|->
name|channel
operator|-
literal|2
expr_stmt|;
comment|/* Align to even 5MHz raster */
name|channelSel
operator|=
name|ath_hal_reverseBits
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
operator|(
operator|(
name|freq
operator|-
literal|4800
operator|)
operator|*
literal|10
operator|)
operator|/
literal|25
operator|+
literal|1
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|aModeRefSel
operator|=
name|ath_hal_reverseBits
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|chan
operator|->
name|channel
operator|%
literal|20
operator|)
operator|==
literal|0
operator|&&
name|chan
operator|->
name|channel
operator|>=
literal|5120
condition|)
block|{
name|channelSel
operator|=
name|ath_hal_reverseBits
argument_list|(
operator|(
operator|(
name|chan
operator|->
name|channel
operator|-
literal|4800
operator|)
operator|/
literal|20
operator|<<
literal|2
operator|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|aModeRefSel
operator|=
name|ath_hal_reverseBits
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|chan
operator|->
name|channel
operator|%
literal|10
operator|)
operator|==
literal|0
condition|)
block|{
name|channelSel
operator|=
name|ath_hal_reverseBits
argument_list|(
operator|(
operator|(
name|chan
operator|->
name|channel
operator|-
literal|4800
operator|)
operator|/
literal|10
operator|<<
literal|1
operator|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|aModeRefSel
operator|=
name|ath_hal_reverseBits
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|chan
operator|->
name|channel
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
block|{
name|channelSel
operator|=
name|ath_hal_reverseBits
argument_list|(
operator|(
name|chan
operator|->
name|channel
operator|-
literal|4800
operator|)
operator|/
literal|5
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|aModeRefSel
operator|=
name|ath_hal_reverseBits
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel %u MHz\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|channel
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|reg32
operator|=
operator|(
name|channelSel
operator|<<
literal|4
operator|)
operator||
operator|(
name|aModeRefSel
operator|<<
literal|2
operator|)
operator||
operator|(
name|bModeSynth
operator|<<
literal|1
operator|)
operator||
operator|(
literal|1
operator|<<
literal|12
operator|)
operator||
literal|0x1
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0x27
argument_list|)
argument_list|,
name|reg32
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|reg32
operator|>>=
literal|8
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0x36
argument_list|)
argument_list|,
name|reg32
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|=
name|chan
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Reads EEPROM header info from device structure and programs  * all rf registers  *  * REQUIRES: Access to the analog rf device  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5413SetRfRegs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|chan
parameter_list|,
name|uint16_t
name|modesIndex
parameter_list|,
name|uint16_t
modifier|*
name|rfXpdGain
parameter_list|)
block|{
define|#
directive|define
name|RF_BANK_SETUP
parameter_list|(
name|_priv
parameter_list|,
name|_ix
parameter_list|,
name|_col
parameter_list|)
value|do {				    \ 	int i;								    \ 	for (i = 0; i< N(ar5212Bank##_ix##_5413); i++)			    \ 		(_priv)->Bank##_ix##Data[i] = ar5212Bank##_ix##_5413[i][_col];\ } while (0)
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
specifier|const
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|uint16_t
name|ob5GHz
init|=
literal|0
decl_stmt|,
name|db5GHz
init|=
literal|0
decl_stmt|;
name|uint16_t
name|ob2GHz
init|=
literal|0
decl_stmt|,
name|db2GHz
init|=
literal|0
decl_stmt|;
name|struct
name|ar5413State
modifier|*
name|priv
init|=
name|AR5413
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|regWrites
init|=
literal|0
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RFPARAM
argument_list|,
literal|"%s: chan 0x%x flag 0x%x modesIndex 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|channel
argument_list|,
name|chan
operator|->
name|channelFlags
argument_list|,
name|modesIndex
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|priv
operator|!=
name|AH_NULL
argument_list|)
expr_stmt|;
comment|/* Setup rf parameters */
switch|switch
condition|(
name|chan
operator|->
name|channelFlags
operator|&
name|CHANNEL_ALL
condition|)
block|{
case|case
name|CHANNEL_A
case|:
case|case
name|CHANNEL_T
case|:
if|if
condition|(
name|chan
operator|->
name|channel
operator|>
literal|4000
operator|&&
name|chan
operator|->
name|channel
operator|<
literal|5260
condition|)
block|{
name|ob5GHz
operator|=
name|ee
operator|->
name|ee_ob1
expr_stmt|;
name|db5GHz
operator|=
name|ee
operator|->
name|ee_db1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chan
operator|->
name|channel
operator|>=
literal|5260
operator|&&
name|chan
operator|->
name|channel
operator|<
literal|5500
condition|)
block|{
name|ob5GHz
operator|=
name|ee
operator|->
name|ee_ob2
expr_stmt|;
name|db5GHz
operator|=
name|ee
operator|->
name|ee_db2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chan
operator|->
name|channel
operator|>=
literal|5500
operator|&&
name|chan
operator|->
name|channel
operator|<
literal|5725
condition|)
block|{
name|ob5GHz
operator|=
name|ee
operator|->
name|ee_ob3
expr_stmt|;
name|db5GHz
operator|=
name|ee
operator|->
name|ee_db3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chan
operator|->
name|channel
operator|>=
literal|5725
condition|)
block|{
name|ob5GHz
operator|=
name|ee
operator|->
name|ee_ob4
expr_stmt|;
name|db5GHz
operator|=
name|ee
operator|->
name|ee_db4
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX else */
block|}
break|break;
case|case
name|CHANNEL_B
case|:
name|ob2GHz
operator|=
name|ee
operator|->
name|ee_obFor24
expr_stmt|;
name|db2GHz
operator|=
name|ee
operator|->
name|ee_dbFor24
expr_stmt|;
break|break;
case|case
name|CHANNEL_G
case|:
case|case
name|CHANNEL_108G
case|:
name|ob2GHz
operator|=
name|ee
operator|->
name|ee_obFor24g
expr_stmt|;
name|db2GHz
operator|=
name|ee
operator|->
name|ee_dbFor24g
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|channelFlags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* Bank 1 Write */
name|RF_BANK_SETUP
argument_list|(
name|priv
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Bank 2 Write */
name|RF_BANK_SETUP
argument_list|(
name|priv
argument_list|,
literal|2
argument_list|,
name|modesIndex
argument_list|)
expr_stmt|;
comment|/* Bank 3 Write */
name|RF_BANK_SETUP
argument_list|(
name|priv
argument_list|,
literal|3
argument_list|,
name|modesIndex
argument_list|)
expr_stmt|;
comment|/* Bank 6 Write */
name|RF_BANK_SETUP
argument_list|(
name|priv
argument_list|,
literal|6
argument_list|,
name|modesIndex
argument_list|)
expr_stmt|;
comment|/* Only the 5 or 2 GHz OB/DB need to be set for a mode */
if|if
condition|(
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|ob2GHz
argument_list|,
literal|3
argument_list|,
literal|241
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|db2GHz
argument_list|,
literal|3
argument_list|,
literal|238
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* TODO - only for Eagle 1.0 2GHz - remove for production */
comment|/* XXX: but without this bit G doesn't work. */
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|291
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Optimum value for rf_pwd_iclobuf2G for PCIe chips only */
if|if
condition|(
name|IS_PCIE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|ath_hal_reverseBits
argument_list|(
literal|6
argument_list|,
literal|3
argument_list|)
argument_list|,
literal|3
argument_list|,
literal|131
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|ob5GHz
argument_list|,
literal|3
argument_list|,
literal|247
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|db5GHz
argument_list|,
literal|3
argument_list|,
literal|244
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Bank 7 Setup */
name|RF_BANK_SETUP
argument_list|(
name|priv
argument_list|,
literal|7
argument_list|,
name|modesIndex
argument_list|)
expr_stmt|;
comment|/* Write Analog registers */
name|HAL_INI_WRITE_BANK
argument_list|(
name|ah
argument_list|,
name|ar5212Bank1_5413
argument_list|,
name|priv
operator|->
name|Bank1Data
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
name|HAL_INI_WRITE_BANK
argument_list|(
name|ah
argument_list|,
name|ar5212Bank2_5413
argument_list|,
name|priv
operator|->
name|Bank2Data
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
name|HAL_INI_WRITE_BANK
argument_list|(
name|ah
argument_list|,
name|ar5212Bank3_5413
argument_list|,
name|priv
operator|->
name|Bank3Data
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
name|HAL_INI_WRITE_BANK
argument_list|(
name|ah
argument_list|,
name|ar5212Bank6_5413
argument_list|,
name|priv
operator|->
name|Bank6Data
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
name|HAL_INI_WRITE_BANK
argument_list|(
name|ah
argument_list|,
name|ar5212Bank7_5413
argument_list|,
name|priv
operator|->
name|Bank7Data
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
comment|/* Now that we have reprogrammed rfgain value, clear the flag. */
name|ahp
operator|->
name|ah_rfgainState
operator|=
name|HAL_RFGAIN_INACTIVE
expr_stmt|;
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|RF_BANK_SETUP
block|}
end_function

begin_comment
comment|/*  * Return a reference to the requested RF Bank.  */
end_comment

begin_function
specifier|static
name|uint32_t
modifier|*
name|ar5413GetRfBank
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|bank
parameter_list|)
block|{
name|struct
name|ar5413State
modifier|*
name|priv
init|=
name|AR5413
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HALASSERT
argument_list|(
name|priv
operator|!=
name|AH_NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bank
condition|)
block|{
case|case
literal|1
case|:
return|return
name|priv
operator|->
name|Bank1Data
return|;
case|case
literal|2
case|:
return|return
name|priv
operator|->
name|Bank2Data
return|;
case|case
literal|3
case|:
return|return
name|priv
operator|->
name|Bank3Data
return|;
case|case
literal|6
case|:
return|return
name|priv
operator|->
name|Bank6Data
return|;
case|case
literal|7
case|:
return|return
name|priv
operator|->
name|Bank7Data
return|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: unknown RF Bank %d requested\n"
argument_list|,
name|__func__
argument_list|,
name|bank
argument_list|)
expr_stmt|;
return|return
name|AH_NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Return indices surrounding the value in sorted integer lists.  *  * NB: the input list is assumed to be sorted in ascending order  */
end_comment

begin_function
specifier|static
name|void
name|GetLowerUpperIndex
parameter_list|(
name|int16_t
name|v
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|lp
parameter_list|,
name|uint16_t
name|listSize
parameter_list|,
name|uint32_t
modifier|*
name|vlo
parameter_list|,
name|uint32_t
modifier|*
name|vhi
parameter_list|)
block|{
name|int16_t
name|target
init|=
name|v
decl_stmt|;
specifier|const
name|uint16_t
modifier|*
name|ep
init|=
name|lp
operator|+
name|listSize
decl_stmt|;
specifier|const
name|uint16_t
modifier|*
name|tp
decl_stmt|;
comment|/* 	 * Check first and last elements for out-of-bounds conditions. 	 */
if|if
condition|(
name|target
operator|<
name|lp
index|[
literal|0
index|]
condition|)
block|{
operator|*
name|vlo
operator|=
operator|*
name|vhi
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|target
operator|>=
name|ep
index|[
operator|-
literal|1
index|]
condition|)
block|{
operator|*
name|vlo
operator|=
operator|*
name|vhi
operator|=
name|listSize
operator|-
literal|1
expr_stmt|;
return|return;
block|}
comment|/* look for value being near or between 2 values in list */
for|for
control|(
name|tp
operator|=
name|lp
init|;
name|tp
operator|<
name|ep
condition|;
name|tp
operator|++
control|)
block|{
comment|/* 		 * If value is close to the current value of the list 		 * then target is not between values, it is one of the values 		 */
if|if
condition|(
operator|*
name|tp
operator|==
name|target
condition|)
block|{
operator|*
name|vlo
operator|=
operator|*
name|vhi
operator|=
name|tp
operator|-
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|lp
expr_stmt|;
return|return;
block|}
comment|/* 		 * Look for value being between current value and next value 		 * if so return these 2 values 		 */
if|if
condition|(
name|target
operator|<
name|tp
index|[
literal|1
index|]
condition|)
block|{
operator|*
name|vlo
operator|=
name|tp
operator|-
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|lp
expr_stmt|;
operator|*
name|vhi
operator|=
operator|*
name|vlo
operator|+
literal|1
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Fill the Vpdlist for indices Pmax-Pmin  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5413FillVpdTable
parameter_list|(
name|uint32_t
name|pdGainIdx
parameter_list|,
name|int16_t
name|Pmin
parameter_list|,
name|int16_t
name|Pmax
parameter_list|,
specifier|const
name|int16_t
modifier|*
name|pwrList
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|VpdList
parameter_list|,
name|uint16_t
name|numIntercepts
parameter_list|,
name|uint16_t
name|retVpdList
index|[]
index|[
literal|64
index|]
parameter_list|)
block|{
name|uint16_t
name|ii
decl_stmt|,
name|jj
decl_stmt|,
name|kk
decl_stmt|;
name|int16_t
name|currPwr
init|=
call|(
name|int16_t
call|)
argument_list|(
literal|2
operator|*
name|Pmin
argument_list|)
decl_stmt|;
comment|/* since Pmin is pwr*2 and pwrList is 4*pwr */
name|uint32_t
name|idxL
decl_stmt|,
name|idxR
decl_stmt|;
name|ii
operator|=
literal|0
expr_stmt|;
name|jj
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|numIntercepts
operator|<
literal|2
condition|)
return|return
name|AH_FALSE
return|;
while|while
condition|(
name|ii
operator|<=
call|(
name|uint16_t
call|)
argument_list|(
name|Pmax
operator|-
name|Pmin
argument_list|)
condition|)
block|{
name|GetLowerUpperIndex
argument_list|(
name|currPwr
argument_list|,
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|pwrList
argument_list|,
name|numIntercepts
argument_list|,
operator|&
operator|(
name|idxL
operator|)
argument_list|,
operator|&
operator|(
name|idxR
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idxR
operator|<
literal|1
condition|)
name|idxR
operator|=
literal|1
expr_stmt|;
comment|/* extrapolate below */
if|if
condition|(
name|idxL
operator|==
call|(
name|uint32_t
call|)
argument_list|(
name|numIntercepts
operator|-
literal|1
argument_list|)
condition|)
name|idxL
operator|=
name|numIntercepts
operator|-
literal|2
expr_stmt|;
comment|/* extrapolate above */
if|if
condition|(
name|pwrList
index|[
name|idxL
index|]
operator|==
name|pwrList
index|[
name|idxR
index|]
condition|)
name|kk
operator|=
name|VpdList
index|[
name|idxL
index|]
expr_stmt|;
else|else
name|kk
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
operator|(
name|currPwr
operator|-
name|pwrList
index|[
name|idxL
index|]
operator|)
operator|*
name|VpdList
index|[
name|idxR
index|]
operator|+
operator|(
name|pwrList
index|[
name|idxR
index|]
operator|-
name|currPwr
operator|)
operator|*
name|VpdList
index|[
name|idxL
index|]
operator|)
operator|/
operator|(
name|pwrList
index|[
name|idxR
index|]
operator|-
name|pwrList
index|[
name|idxL
index|]
operator|)
argument_list|)
expr_stmt|;
name|retVpdList
index|[
name|pdGainIdx
index|]
index|[
name|ii
index|]
operator|=
name|kk
expr_stmt|;
name|ii
operator|++
expr_stmt|;
name|currPwr
operator|+=
literal|2
expr_stmt|;
comment|/* half dB steps */
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Returns interpolated or the scaled up interpolated value  */
end_comment

begin_function
specifier|static
name|int16_t
name|interpolate_signed
parameter_list|(
name|uint16_t
name|target
parameter_list|,
name|uint16_t
name|srcLeft
parameter_list|,
name|uint16_t
name|srcRight
parameter_list|,
name|int16_t
name|targetLeft
parameter_list|,
name|int16_t
name|targetRight
parameter_list|)
block|{
name|int16_t
name|rv
decl_stmt|;
if|if
condition|(
name|srcRight
operator|!=
name|srcLeft
condition|)
block|{
name|rv
operator|=
operator|(
operator|(
name|target
operator|-
name|srcLeft
operator|)
operator|*
name|targetRight
operator|+
operator|(
name|srcRight
operator|-
name|target
operator|)
operator|*
name|targetLeft
operator|)
operator|/
operator|(
name|srcRight
operator|-
name|srcLeft
operator|)
expr_stmt|;
block|}
else|else
block|{
name|rv
operator|=
name|targetLeft
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/*  * Uses the data points read from EEPROM to reconstruct the pdadc power table  * Called by ar5413SetPowerTable()  */
end_comment

begin_function
specifier|static
name|int
name|ar5413getGainBoundariesAndPdadcsForPowers
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint16_t
name|channel
parameter_list|,
specifier|const
name|RAW_DATA_STRUCT_2413
modifier|*
name|pRawDataset
parameter_list|,
name|uint16_t
name|pdGainOverlap_t2
parameter_list|,
name|int16_t
modifier|*
name|pMinCalPower
parameter_list|,
name|uint16_t
name|pPdGainBoundaries
index|[]
parameter_list|,
name|uint16_t
name|pPdGainValues
index|[]
parameter_list|,
name|uint16_t
name|pPDADCValues
index|[]
parameter_list|)
block|{
name|struct
name|ar5413State
modifier|*
name|priv
init|=
name|AR5413
argument_list|(
name|ah
argument_list|)
decl_stmt|;
define|#
directive|define
name|VpdTable_L
value|priv->vpdTable_L
define|#
directive|define
name|VpdTable_R
value|priv->vpdTable_R
define|#
directive|define
name|VpdTable_I
value|priv->vpdTable_I
name|uint32_t
name|ii
decl_stmt|,
name|jj
decl_stmt|,
name|kk
decl_stmt|;
name|int32_t
name|ss
decl_stmt|;
comment|/* potentially -ve index for taking care of pdGainOverlap */
name|uint32_t
name|idxL
decl_stmt|,
name|idxR
decl_stmt|;
name|uint32_t
name|numPdGainsUsed
init|=
literal|0
decl_stmt|;
comment|/*  	 * If desired to support -ve power levels in future, just 	 * change pwr_I_0 to signed 5-bits. 	 */
name|int16_t
name|Pmin_t2
index|[
name|MAX_NUM_PDGAINS_PER_CHANNEL
index|]
decl_stmt|;
comment|/* to accomodate -ve power levels later on. */
name|int16_t
name|Pmax_t2
index|[
name|MAX_NUM_PDGAINS_PER_CHANNEL
index|]
decl_stmt|;
comment|/* to accomodate -ve power levels later on */
name|uint16_t
name|numVpd
init|=
literal|0
decl_stmt|;
name|uint16_t
name|Vpd_step
decl_stmt|;
name|int16_t
name|tmpVal
decl_stmt|;
name|uint32_t
name|sizeCurrVpdTable
decl_stmt|,
name|maxIndex
decl_stmt|,
name|tgtIndex
decl_stmt|;
comment|/* Get upper lower index */
name|GetLowerUpperIndex
argument_list|(
name|channel
argument_list|,
name|pRawDataset
operator|->
name|pChannels
argument_list|,
name|pRawDataset
operator|->
name|numChannels
argument_list|,
operator|&
operator|(
name|idxL
operator|)
argument_list|,
operator|&
operator|(
name|idxR
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|MAX_NUM_PDGAINS_PER_CHANNEL
condition|;
name|ii
operator|++
control|)
block|{
name|jj
operator|=
name|MAX_NUM_PDGAINS_PER_CHANNEL
operator|-
name|ii
operator|-
literal|1
expr_stmt|;
comment|/* work backwards 'cause highest pdGain for lowest power */
name|numVpd
operator|=
name|pRawDataset
operator|->
name|pDataPerChannel
index|[
name|idxL
index|]
operator|.
name|pDataPerPDGain
index|[
name|jj
index|]
operator|.
name|numVpd
expr_stmt|;
if|if
condition|(
name|numVpd
operator|>
literal|0
condition|)
block|{
name|pPdGainValues
index|[
name|numPdGainsUsed
index|]
operator|=
name|pRawDataset
operator|->
name|pDataPerChannel
index|[
name|idxL
index|]
operator|.
name|pDataPerPDGain
index|[
name|jj
index|]
operator|.
name|pd_gain
expr_stmt|;
name|Pmin_t2
index|[
name|numPdGainsUsed
index|]
operator|=
name|pRawDataset
operator|->
name|pDataPerChannel
index|[
name|idxL
index|]
operator|.
name|pDataPerPDGain
index|[
name|jj
index|]
operator|.
name|pwr_t4
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|Pmin_t2
index|[
name|numPdGainsUsed
index|]
operator|>
name|pRawDataset
operator|->
name|pDataPerChannel
index|[
name|idxR
index|]
operator|.
name|pDataPerPDGain
index|[
name|jj
index|]
operator|.
name|pwr_t4
index|[
literal|0
index|]
condition|)
block|{
name|Pmin_t2
index|[
name|numPdGainsUsed
index|]
operator|=
name|pRawDataset
operator|->
name|pDataPerChannel
index|[
name|idxR
index|]
operator|.
name|pDataPerPDGain
index|[
name|jj
index|]
operator|.
name|pwr_t4
index|[
literal|0
index|]
expr_stmt|;
block|}
name|Pmin_t2
index|[
name|numPdGainsUsed
index|]
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|Pmin_t2
index|[
name|numPdGainsUsed
index|]
operator|/
literal|2
argument_list|)
expr_stmt|;
name|Pmax_t2
index|[
name|numPdGainsUsed
index|]
operator|=
name|pRawDataset
operator|->
name|pDataPerChannel
index|[
name|idxL
index|]
operator|.
name|pDataPerPDGain
index|[
name|jj
index|]
operator|.
name|pwr_t4
index|[
name|numVpd
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|Pmax_t2
index|[
name|numPdGainsUsed
index|]
operator|>
name|pRawDataset
operator|->
name|pDataPerChannel
index|[
name|idxR
index|]
operator|.
name|pDataPerPDGain
index|[
name|jj
index|]
operator|.
name|pwr_t4
index|[
name|numVpd
operator|-
literal|1
index|]
condition|)
name|Pmax_t2
index|[
name|numPdGainsUsed
index|]
operator|=
name|pRawDataset
operator|->
name|pDataPerChannel
index|[
name|idxR
index|]
operator|.
name|pDataPerPDGain
index|[
name|jj
index|]
operator|.
name|pwr_t4
index|[
name|numVpd
operator|-
literal|1
index|]
expr_stmt|;
name|Pmax_t2
index|[
name|numPdGainsUsed
index|]
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|Pmax_t2
index|[
name|numPdGainsUsed
index|]
operator|/
literal|2
argument_list|)
expr_stmt|;
name|ar5413FillVpdTable
argument_list|(
name|numPdGainsUsed
argument_list|,
name|Pmin_t2
index|[
name|numPdGainsUsed
index|]
argument_list|,
name|Pmax_t2
index|[
name|numPdGainsUsed
index|]
argument_list|,
operator|&
operator|(
name|pRawDataset
operator|->
name|pDataPerChannel
index|[
name|idxL
index|]
operator|.
name|pDataPerPDGain
index|[
name|jj
index|]
operator|.
name|pwr_t4
index|[
literal|0
index|]
operator|)
argument_list|,
operator|&
operator|(
name|pRawDataset
operator|->
name|pDataPerChannel
index|[
name|idxL
index|]
operator|.
name|pDataPerPDGain
index|[
name|jj
index|]
operator|.
name|Vpd
index|[
literal|0
index|]
operator|)
argument_list|,
name|numVpd
argument_list|,
name|VpdTable_L
argument_list|)
expr_stmt|;
name|ar5413FillVpdTable
argument_list|(
name|numPdGainsUsed
argument_list|,
name|Pmin_t2
index|[
name|numPdGainsUsed
index|]
argument_list|,
name|Pmax_t2
index|[
name|numPdGainsUsed
index|]
argument_list|,
operator|&
operator|(
name|pRawDataset
operator|->
name|pDataPerChannel
index|[
name|idxR
index|]
operator|.
name|pDataPerPDGain
index|[
name|jj
index|]
operator|.
name|pwr_t4
index|[
literal|0
index|]
operator|)
argument_list|,
operator|&
operator|(
name|pRawDataset
operator|->
name|pDataPerChannel
index|[
name|idxR
index|]
operator|.
name|pDataPerPDGain
index|[
name|jj
index|]
operator|.
name|Vpd
index|[
literal|0
index|]
operator|)
argument_list|,
name|numVpd
argument_list|,
name|VpdTable_R
argument_list|)
expr_stmt|;
for|for
control|(
name|kk
operator|=
literal|0
init|;
name|kk
operator|<
call|(
name|uint16_t
call|)
argument_list|(
name|Pmax_t2
index|[
name|numPdGainsUsed
index|]
operator|-
name|Pmin_t2
index|[
name|numPdGainsUsed
index|]
argument_list|)
condition|;
name|kk
operator|++
control|)
block|{
name|VpdTable_I
index|[
name|numPdGainsUsed
index|]
index|[
name|kk
index|]
operator|=
name|interpolate_signed
argument_list|(
name|channel
argument_list|,
name|pRawDataset
operator|->
name|pChannels
index|[
name|idxL
index|]
argument_list|,
name|pRawDataset
operator|->
name|pChannels
index|[
name|idxR
index|]
argument_list|,
operator|(
name|int16_t
operator|)
name|VpdTable_L
index|[
name|numPdGainsUsed
index|]
index|[
name|kk
index|]
argument_list|,
operator|(
name|int16_t
operator|)
name|VpdTable_R
index|[
name|numPdGainsUsed
index|]
index|[
name|kk
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* fill VpdTable_I for this pdGain */
name|numPdGainsUsed
operator|++
expr_stmt|;
block|}
comment|/* if this pdGain is used */
block|}
operator|*
name|pMinCalPower
operator|=
name|Pmin_t2
index|[
literal|0
index|]
expr_stmt|;
name|kk
operator|=
literal|0
expr_stmt|;
comment|/* index for the final table */
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|numPdGainsUsed
condition|;
name|ii
operator|++
control|)
block|{
if|if
condition|(
name|ii
operator|==
operator|(
name|numPdGainsUsed
operator|-
literal|1
operator|)
condition|)
name|pPdGainBoundaries
index|[
name|ii
index|]
operator|=
name|Pmax_t2
index|[
name|ii
index|]
operator|+
name|PD_GAIN_BOUNDARY_STRETCH_IN_HALF_DB
expr_stmt|;
else|else
name|pPdGainBoundaries
index|[
name|ii
index|]
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|Pmax_t2
index|[
name|ii
index|]
operator|+
name|Pmin_t2
index|[
name|ii
operator|+
literal|1
index|]
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pPdGainBoundaries
index|[
name|ii
index|]
operator|>
literal|63
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: clamp pPdGainBoundaries[%d] %d\n"
argument_list|,
name|__func__
argument_list|,
name|ii
argument_list|,
name|pPdGainBoundaries
index|[
name|ii
index|]
argument_list|)
expr_stmt|;
comment|/*XXX*/
name|pPdGainBoundaries
index|[
name|ii
index|]
operator|=
literal|63
expr_stmt|;
block|}
comment|/* Find starting index for this pdGain */
if|if
condition|(
name|ii
operator|==
literal|0
condition|)
name|ss
operator|=
literal|0
expr_stmt|;
comment|/* for the first pdGain, start from index 0 */
else|else
name|ss
operator|=
operator|(
name|pPdGainBoundaries
index|[
name|ii
operator|-
literal|1
index|]
operator|-
name|Pmin_t2
index|[
name|ii
index|]
operator|)
operator|-
name|pdGainOverlap_t2
expr_stmt|;
name|Vpd_step
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|VpdTable_I
index|[
name|ii
index|]
index|[
literal|1
index|]
operator|-
name|VpdTable_I
index|[
name|ii
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|Vpd_step
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|Vpd_step
operator|<
literal|1
operator|)
condition|?
literal|1
else|:
name|Vpd_step
argument_list|)
expr_stmt|;
comment|/* 		 *-ve ss indicates need to extrapolate data below for this pdGain 		 */
while|while
condition|(
name|ss
operator|<
literal|0
condition|)
block|{
name|tmpVal
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|VpdTable_I
index|[
name|ii
index|]
index|[
literal|0
index|]
operator|+
name|ss
operator|*
name|Vpd_step
argument_list|)
expr_stmt|;
name|pPDADCValues
index|[
name|kk
operator|++
index|]
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|tmpVal
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|tmpVal
argument_list|)
expr_stmt|;
name|ss
operator|++
expr_stmt|;
block|}
name|sizeCurrVpdTable
operator|=
name|Pmax_t2
index|[
name|ii
index|]
operator|-
name|Pmin_t2
index|[
name|ii
index|]
expr_stmt|;
name|tgtIndex
operator|=
name|pPdGainBoundaries
index|[
name|ii
index|]
operator|+
name|pdGainOverlap_t2
operator|-
name|Pmin_t2
index|[
name|ii
index|]
expr_stmt|;
name|maxIndex
operator|=
operator|(
name|tgtIndex
operator|<
name|sizeCurrVpdTable
operator|)
condition|?
name|tgtIndex
else|:
name|sizeCurrVpdTable
expr_stmt|;
while|while
condition|(
name|ss
operator|<
operator|(
name|int16_t
operator|)
name|maxIndex
condition|)
name|pPDADCValues
index|[
name|kk
operator|++
index|]
operator|=
name|VpdTable_I
index|[
name|ii
index|]
index|[
name|ss
operator|++
index|]
expr_stmt|;
name|Vpd_step
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|VpdTable_I
index|[
name|ii
index|]
index|[
name|sizeCurrVpdTable
operator|-
literal|1
index|]
operator|-
name|VpdTable_I
index|[
name|ii
index|]
index|[
name|sizeCurrVpdTable
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|Vpd_step
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|Vpd_step
operator|<
literal|1
operator|)
condition|?
literal|1
else|:
name|Vpd_step
argument_list|)
expr_stmt|;
comment|/* 		 * for last gain, pdGainBoundary == Pmax_t2, so will  		 * have to extrapolate 		 */
if|if
condition|(
name|tgtIndex
operator|>
name|maxIndex
condition|)
block|{
comment|/* need to extrapolate above */
while|while
condition|(
name|ss
operator|<
operator|(
name|int16_t
operator|)
name|tgtIndex
condition|)
block|{
name|tmpVal
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|VpdTable_I
index|[
name|ii
index|]
index|[
name|sizeCurrVpdTable
operator|-
literal|1
index|]
operator|+
operator|(
name|ss
operator|-
name|maxIndex
operator|)
operator|*
name|Vpd_step
argument_list|)
expr_stmt|;
name|pPDADCValues
index|[
name|kk
operator|++
index|]
operator|=
operator|(
name|tmpVal
operator|>
literal|127
operator|)
condition|?
literal|127
else|:
name|tmpVal
expr_stmt|;
name|ss
operator|++
expr_stmt|;
block|}
block|}
comment|/* extrapolated above */
block|}
comment|/* for all pdGainUsed */
while|while
condition|(
name|ii
operator|<
name|MAX_NUM_PDGAINS_PER_CHANNEL
condition|)
block|{
name|pPdGainBoundaries
index|[
name|ii
index|]
operator|=
name|pPdGainBoundaries
index|[
name|ii
operator|-
literal|1
index|]
expr_stmt|;
name|ii
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|kk
operator|<
literal|128
condition|)
block|{
name|pPDADCValues
index|[
name|kk
index|]
operator|=
name|pPDADCValues
index|[
name|kk
operator|-
literal|1
index|]
expr_stmt|;
name|kk
operator|++
expr_stmt|;
block|}
return|return
name|numPdGainsUsed
return|;
undef|#
directive|undef
name|VpdTable_L
undef|#
directive|undef
name|VpdTable_R
undef|#
directive|undef
name|VpdTable_I
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|ar5413SetPowerTable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int16_t
modifier|*
name|minPower
parameter_list|,
name|int16_t
modifier|*
name|maxPower
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|chan
parameter_list|,
name|uint16_t
modifier|*
name|rfXpdGain
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
specifier|const
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
specifier|const
name|RAW_DATA_STRUCT_2413
modifier|*
name|pRawDataset
init|=
name|AH_NULL
decl_stmt|;
name|uint16_t
name|pdGainOverlap_t2
decl_stmt|;
name|int16_t
name|minCalPower5413_t2
decl_stmt|;
name|uint16_t
modifier|*
name|pdadcValues
init|=
name|ahp
operator|->
name|ah_pcdacTable
decl_stmt|;
name|uint16_t
name|gainBoundaries
index|[
literal|4
index|]
decl_stmt|;
name|uint32_t
name|reg32
decl_stmt|,
name|regoffset
decl_stmt|;
name|int
name|i
decl_stmt|,
name|numPdGainsUsed
decl_stmt|;
ifndef|#
directive|ifndef
name|AH_USE_INIPDGAIN
name|uint32_t
name|tpcrg1
decl_stmt|;
endif|#
directive|endif
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RFPARAM
argument_list|,
literal|"%s: chan 0x%x flag 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|channel
argument_list|,
name|chan
operator|->
name|channelFlags
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_CHAN_G
argument_list|(
name|chan
argument_list|)
operator|||
name|IS_CHAN_108G
argument_list|(
name|chan
argument_list|)
condition|)
name|pRawDataset
operator|=
operator|&
name|ee
operator|->
name|ee_rawDataset2413
index|[
name|headerInfo11G
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_CHAN_B
argument_list|(
name|chan
argument_list|)
condition|)
name|pRawDataset
operator|=
operator|&
name|ee
operator|->
name|ee_rawDataset2413
index|[
name|headerInfo11B
index|]
expr_stmt|;
else|else
block|{
name|HALASSERT
argument_list|(
name|IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
name|pRawDataset
operator|=
operator|&
name|ee
operator|->
name|ee_rawDataset2413
index|[
name|headerInfo11A
index|]
expr_stmt|;
block|}
name|pdGainOverlap_t2
operator|=
operator|(
name|uint16_t
operator|)
name|SM
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPCRG5
argument_list|)
argument_list|,
name|AR_PHY_TPCRG5_PD_GAIN_OVERLAP
argument_list|)
expr_stmt|;
name|numPdGainsUsed
operator|=
name|ar5413getGainBoundariesAndPdadcsForPowers
argument_list|(
name|ah
argument_list|,
name|chan
operator|->
name|channel
argument_list|,
name|pRawDataset
argument_list|,
name|pdGainOverlap_t2
argument_list|,
operator|&
name|minCalPower5413_t2
argument_list|,
name|gainBoundaries
argument_list|,
name|rfXpdGain
argument_list|,
name|pdadcValues
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
literal|1
operator|<=
name|numPdGainsUsed
operator|&&
name|numPdGainsUsed
operator|<=
literal|3
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AH_USE_INIPDGAIN
comment|/* 	 * Use pd_gains curve from eeprom; Atheros always uses 	 * the default curve from the ini file but some vendors 	 * (e.g. Zcomax) want to override this curve and not 	 * honoring their settings results in tx power 5dBm low. 	 */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPCRG1
argument_list|,
name|AR_PHY_TPCRG1_NUM_PD_GAIN
argument_list|,
operator|(
name|pRawDataset
operator|->
name|pDataPerChannel
index|[
literal|0
index|]
operator|.
name|numPdGains
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|tpcrg1
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPCRG1
argument_list|)
expr_stmt|;
name|tpcrg1
operator|=
operator|(
name|tpcrg1
operator|&
operator|~
name|AR_PHY_TPCRG1_NUM_PD_GAIN
operator|)
operator||
name|SM
argument_list|(
name|numPdGainsUsed
operator|-
literal|1
argument_list|,
name|AR_PHY_TPCRG1_NUM_PD_GAIN
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|numPdGainsUsed
condition|)
block|{
case|case
literal|3
case|:
name|tpcrg1
operator|&=
operator|~
name|AR_PHY_TPCRG1_PDGAIN_SETTING3
expr_stmt|;
name|tpcrg1
operator||=
name|SM
argument_list|(
name|rfXpdGain
index|[
literal|2
index|]
argument_list|,
name|AR_PHY_TPCRG1_PDGAIN_SETTING3
argument_list|)
expr_stmt|;
comment|/* fall thru... */
case|case
literal|2
case|:
name|tpcrg1
operator|&=
operator|~
name|AR_PHY_TPCRG1_PDGAIN_SETTING2
expr_stmt|;
name|tpcrg1
operator||=
name|SM
argument_list|(
name|rfXpdGain
index|[
literal|1
index|]
argument_list|,
name|AR_PHY_TPCRG1_PDGAIN_SETTING2
argument_list|)
expr_stmt|;
comment|/* fall thru... */
case|case
literal|1
case|:
name|tpcrg1
operator|&=
operator|~
name|AR_PHY_TPCRG1_PDGAIN_SETTING1
expr_stmt|;
name|tpcrg1
operator||=
name|SM
argument_list|(
name|rfXpdGain
index|[
literal|0
index|]
argument_list|,
name|AR_PHY_TPCRG1_PDGAIN_SETTING1
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|AH_DEBUG
if|if
condition|(
name|tpcrg1
operator|!=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPCRG1
argument_list|)
condition|)
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RFPARAM
argument_list|,
literal|"%s: using non-default "
literal|"pd_gains (default 0x%x, calculated 0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPCRG1
argument_list|)
argument_list|,
name|tpcrg1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPCRG1
argument_list|,
name|tpcrg1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Note the pdadc table may not start at 0 dBm power, could be 	 * negative or greater than 0.  Need to offset the power 	 * values by the amount of minPower for griffin 	 */
if|if
condition|(
name|minCalPower5413_t2
operator|!=
literal|0
condition|)
name|ahp
operator|->
name|ah_txPowerIndexOffset
operator|=
call|(
name|int16_t
call|)
argument_list|(
literal|0
operator|-
name|minCalPower5413_t2
argument_list|)
expr_stmt|;
else|else
name|ahp
operator|->
name|ah_txPowerIndexOffset
operator|=
literal|0
expr_stmt|;
comment|/* Finally, write the power values into the baseband power table */
name|regoffset
operator|=
literal|0x9800
operator|+
operator|(
literal|672
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* beginning of pdadc table in griffin */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|reg32
operator|=
operator|(
operator|(
name|pdadcValues
index|[
literal|4
operator|*
name|i
operator|+
literal|0
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|0
operator|)
operator||
operator|(
operator|(
name|pdadcValues
index|[
literal|4
operator|*
name|i
operator|+
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|pdadcValues
index|[
literal|4
operator|*
name|i
operator|+
literal|2
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|pdadcValues
index|[
literal|4
operator|*
name|i
operator|+
literal|3
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|24
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|regoffset
argument_list|,
name|reg32
argument_list|)
expr_stmt|;
name|regoffset
operator|+=
literal|4
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPCRG5
argument_list|,
name|SM
argument_list|(
name|pdGainOverlap_t2
argument_list|,
name|AR_PHY_TPCRG5_PD_GAIN_OVERLAP
argument_list|)
operator||
name|SM
argument_list|(
name|gainBoundaries
index|[
literal|0
index|]
argument_list|,
name|AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_1
argument_list|)
operator||
name|SM
argument_list|(
name|gainBoundaries
index|[
literal|1
index|]
argument_list|,
name|AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_2
argument_list|)
operator||
name|SM
argument_list|(
name|gainBoundaries
index|[
literal|2
index|]
argument_list|,
name|AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_3
argument_list|)
operator||
name|SM
argument_list|(
name|gainBoundaries
index|[
literal|3
index|]
argument_list|,
name|AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_4
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int16_t
name|ar5413GetMinPower
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|RAW_DATA_PER_CHANNEL_2413
modifier|*
name|data
parameter_list|)
block|{
name|uint32_t
name|ii
decl_stmt|,
name|jj
decl_stmt|;
name|uint16_t
name|Pmin
init|=
literal|0
decl_stmt|,
name|numVpd
decl_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|MAX_NUM_PDGAINS_PER_CHANNEL
condition|;
name|ii
operator|++
control|)
block|{
name|jj
operator|=
name|MAX_NUM_PDGAINS_PER_CHANNEL
operator|-
name|ii
operator|-
literal|1
expr_stmt|;
comment|/* work backwards 'cause highest pdGain for lowest power */
name|numVpd
operator|=
name|data
operator|->
name|pDataPerPDGain
index|[
name|jj
index|]
operator|.
name|numVpd
expr_stmt|;
if|if
condition|(
name|numVpd
operator|>
literal|0
condition|)
block|{
name|Pmin
operator|=
name|data
operator|->
name|pDataPerPDGain
index|[
name|jj
index|]
operator|.
name|pwr_t4
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|Pmin
operator|)
return|;
block|}
block|}
return|return
operator|(
name|Pmin
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int16_t
name|ar5413GetMaxPower
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|RAW_DATA_PER_CHANNEL_2413
modifier|*
name|data
parameter_list|)
block|{
name|uint32_t
name|ii
decl_stmt|;
name|uint16_t
name|Pmax
init|=
literal|0
decl_stmt|,
name|numVpd
decl_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|MAX_NUM_PDGAINS_PER_CHANNEL
condition|;
name|ii
operator|++
control|)
block|{
comment|/* work forwards cuase lowest pdGain for highest power */
name|numVpd
operator|=
name|data
operator|->
name|pDataPerPDGain
index|[
name|ii
index|]
operator|.
name|numVpd
expr_stmt|;
if|if
condition|(
name|numVpd
operator|>
literal|0
condition|)
block|{
name|Pmax
operator|=
name|data
operator|->
name|pDataPerPDGain
index|[
name|ii
index|]
operator|.
name|pwr_t4
index|[
name|numVpd
operator|-
literal|1
index|]
expr_stmt|;
return|return
operator|(
name|Pmax
operator|)
return|;
block|}
block|}
return|return
operator|(
name|Pmax
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|ar5413GetChannelMaxMinPower
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|,
name|int16_t
modifier|*
name|maxPow
parameter_list|,
name|int16_t
modifier|*
name|minPow
parameter_list|)
block|{
specifier|const
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
specifier|const
name|RAW_DATA_STRUCT_2413
modifier|*
name|pRawDataset
init|=
name|AH_NULL
decl_stmt|;
specifier|const
name|RAW_DATA_PER_CHANNEL_2413
modifier|*
name|data
init|=
name|AH_NULL
decl_stmt|;
name|uint16_t
name|numChannels
decl_stmt|;
name|int
name|totalD
decl_stmt|,
name|totalF
decl_stmt|,
name|totalMin
decl_stmt|,
name|last
decl_stmt|,
name|i
decl_stmt|;
operator|*
name|maxPow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_CHAN_G
argument_list|(
name|chan
argument_list|)
operator|||
name|IS_CHAN_108G
argument_list|(
name|chan
argument_list|)
condition|)
name|pRawDataset
operator|=
operator|&
name|ee
operator|->
name|ee_rawDataset2413
index|[
name|headerInfo11G
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_CHAN_B
argument_list|(
name|chan
argument_list|)
condition|)
name|pRawDataset
operator|=
operator|&
name|ee
operator|->
name|ee_rawDataset2413
index|[
name|headerInfo11B
index|]
expr_stmt|;
else|else
block|{
name|HALASSERT
argument_list|(
name|IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
name|pRawDataset
operator|=
operator|&
name|ee
operator|->
name|ee_rawDataset2413
index|[
name|headerInfo11A
index|]
expr_stmt|;
block|}
name|numChannels
operator|=
name|pRawDataset
operator|->
name|numChannels
expr_stmt|;
name|data
operator|=
name|pRawDataset
operator|->
name|pDataPerChannel
expr_stmt|;
comment|/* Make sure the channel is in the range of the TP values  	 *  (freq piers) 	 */
if|if
condition|(
name|numChannels
operator|<
literal|1
condition|)
return|return
operator|(
name|AH_FALSE
operator|)
return|;
if|if
condition|(
operator|(
name|chan
operator|->
name|channel
operator|<
name|data
index|[
literal|0
index|]
operator|.
name|channelValue
operator|)
operator|||
operator|(
name|chan
operator|->
name|channel
operator|>
name|data
index|[
name|numChannels
operator|-
literal|1
index|]
operator|.
name|channelValue
operator|)
condition|)
block|{
if|if
condition|(
name|chan
operator|->
name|channel
operator|<
name|data
index|[
literal|0
index|]
operator|.
name|channelValue
condition|)
block|{
operator|*
name|maxPow
operator|=
name|ar5413GetMaxPower
argument_list|(
name|ah
argument_list|,
operator|&
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|minPow
operator|=
name|ar5413GetMinPower
argument_list|(
name|ah
argument_list|,
operator|&
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|AH_TRUE
operator|)
return|;
block|}
else|else
block|{
operator|*
name|maxPow
operator|=
name|ar5413GetMaxPower
argument_list|(
name|ah
argument_list|,
operator|&
name|data
index|[
name|numChannels
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|minPow
operator|=
name|ar5413GetMinPower
argument_list|(
name|ah
argument_list|,
operator|&
name|data
index|[
name|numChannels
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|AH_TRUE
operator|)
return|;
block|}
block|}
comment|/* Linearly interpolate the power value now */
for|for
control|(
name|last
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|numChannels
operator|)
operator|&&
operator|(
name|chan
operator|->
name|channel
operator|>
name|data
index|[
name|i
index|]
operator|.
name|channelValue
operator|)
condition|;
name|last
operator|=
name|i
operator|++
control|)
empty_stmt|;
name|totalD
operator|=
name|data
index|[
name|i
index|]
operator|.
name|channelValue
operator|-
name|data
index|[
name|last
index|]
operator|.
name|channelValue
expr_stmt|;
if|if
condition|(
name|totalD
operator|>
literal|0
condition|)
block|{
name|totalF
operator|=
name|ar5413GetMaxPower
argument_list|(
name|ah
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
operator|-
name|ar5413GetMaxPower
argument_list|(
name|ah
argument_list|,
operator|&
name|data
index|[
name|last
index|]
argument_list|)
expr_stmt|;
operator|*
name|maxPow
operator|=
call|(
name|int8_t
call|)
argument_list|(
operator|(
name|totalF
operator|*
operator|(
name|chan
operator|->
name|channel
operator|-
name|data
index|[
name|last
index|]
operator|.
name|channelValue
operator|)
operator|+
name|ar5413GetMaxPower
argument_list|(
name|ah
argument_list|,
operator|&
name|data
index|[
name|last
index|]
argument_list|)
operator|*
name|totalD
operator|)
operator|/
name|totalD
argument_list|)
expr_stmt|;
name|totalMin
operator|=
name|ar5413GetMinPower
argument_list|(
name|ah
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
operator|-
name|ar5413GetMinPower
argument_list|(
name|ah
argument_list|,
operator|&
name|data
index|[
name|last
index|]
argument_list|)
expr_stmt|;
operator|*
name|minPow
operator|=
call|(
name|int8_t
call|)
argument_list|(
operator|(
name|totalMin
operator|*
operator|(
name|chan
operator|->
name|channel
operator|-
name|data
index|[
name|last
index|]
operator|.
name|channelValue
operator|)
operator|+
name|ar5413GetMinPower
argument_list|(
name|ah
argument_list|,
operator|&
name|data
index|[
name|last
index|]
argument_list|)
operator|*
name|totalD
operator|)
operator|/
name|totalD
argument_list|)
expr_stmt|;
return|return
operator|(
name|AH_TRUE
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|chan
operator|->
name|channel
operator|==
name|data
index|[
name|i
index|]
operator|.
name|channelValue
condition|)
block|{
operator|*
name|maxPow
operator|=
name|ar5413GetMaxPower
argument_list|(
name|ah
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|*
name|minPow
operator|=
name|ar5413GetMinPower
argument_list|(
name|ah
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|AH_TRUE
operator|)
return|;
block|}
else|else
return|return
operator|(
name|AH_FALSE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Free memory for analog bank scratch buffers  */
end_comment

begin_function
specifier|static
name|void
name|ar5413RfDetach
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HALASSERT
argument_list|(
name|ahp
operator|->
name|ah_rfHal
operator|!=
name|AH_NULL
argument_list|)
expr_stmt|;
name|ath_hal_free
argument_list|(
name|ahp
operator|->
name|ah_rfHal
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_rfHal
operator|=
name|AH_NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate memory for analog bank scratch buffers  * Scratch Buffer will be reinitialized every reset so no need to zero now  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5413RfAttach
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar5413State
modifier|*
name|priv
decl_stmt|;
name|HALASSERT
argument_list|(
name|ah
operator|->
name|ah_magic
operator|==
name|AR5212_MAGIC
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|ahp
operator|->
name|ah_rfHal
operator|==
name|AH_NULL
argument_list|)
expr_stmt|;
name|priv
operator|=
name|ath_hal_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ar5413State
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: cannot allocate private state\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|HAL_ENOMEM
expr_stmt|;
comment|/* XXX */
return|return
name|AH_FALSE
return|;
block|}
name|priv
operator|->
name|base
operator|.
name|rfDetach
operator|=
name|ar5413RfDetach
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|writeRegs
operator|=
name|ar5413WriteRegs
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|getRfBank
operator|=
name|ar5413GetRfBank
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|setChannel
operator|=
name|ar5413SetChannel
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|setRfRegs
operator|=
name|ar5413SetRfRegs
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|setPowerTable
operator|=
name|ar5413SetPowerTable
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|getChannelMaxMinPower
operator|=
name|ar5413GetChannelMaxMinPower
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|getNfAdjust
operator|=
name|ar5212GetNfAdjust
expr_stmt|;
name|ahp
operator|->
name|ah_pcdacTable
operator|=
name|priv
operator|->
name|pcdacTable
expr_stmt|;
name|ahp
operator|->
name|ah_pcdacTableSize
operator|=
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|pcdacTable
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_rfHal
operator|=
operator|&
name|priv
operator|->
name|base
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|ar5413Probe
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|IS_5413
argument_list|(
name|ah
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|AH_RF
argument_list|(
name|RF5413
argument_list|,
name|ar5413Probe
argument_list|,
name|ar5413RfAttach
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

