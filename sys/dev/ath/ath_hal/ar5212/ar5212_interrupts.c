begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2008 Sam Leffler, Errno Consulting  * Copyright (c) 2002-2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212phy.h"
end_include

begin_comment
comment|/*  * Checks to see if an interrupt is pending on our NIC  *  * Returns: TRUE    if an interrupt is pending  *          FALSE   if not  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212IsInterruptPending
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
comment|/*  	 * Some platforms trigger our ISR before applying power to 	 * the card, so make sure the INTPEND is really 1, not 0xffffffff. 	 */
return|return
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_INTPEND
argument_list|)
operator|==
name|AR_INTPEND_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reads the Interrupt Status Register value from the NIC, thus deasserting  * the interrupt line, and returns both the masked and unmasked mapped ISR  * values.  The value returned is mapped to abstract the hw-specific bit  * locations in the Interrupt Status Register.  *  * Returns: A hardware-abstracted bitmap of all non-masked-out  *          interrupts pending, as well as an unmasked value  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212GetPendingInterrupts
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_INT
modifier|*
name|masked
parameter_list|)
block|{
name|uint32_t
name|isr
decl_stmt|,
name|isr0
decl_stmt|,
name|isr1
decl_stmt|;
name|uint32_t
name|mask2
decl_stmt|;
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|isr
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR
argument_list|)
expr_stmt|;
name|mask2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isr
operator|&
name|AR_ISR_BCNMISC
condition|)
block|{
name|uint32_t
name|isr2
init|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S2
argument_list|)
decl_stmt|;
if|if
condition|(
name|isr2
operator|&
name|AR_ISR_S2_TIM
condition|)
name|mask2
operator||=
name|HAL_INT_TIM
expr_stmt|;
if|if
condition|(
name|isr2
operator|&
name|AR_ISR_S2_DTIM
condition|)
name|mask2
operator||=
name|HAL_INT_DTIM
expr_stmt|;
if|if
condition|(
name|isr2
operator|&
name|AR_ISR_S2_DTIMSYNC
condition|)
name|mask2
operator||=
name|HAL_INT_DTIMSYNC
expr_stmt|;
if|if
condition|(
name|isr2
operator|&
name|AR_ISR_S2_CABEND
condition|)
name|mask2
operator||=
name|HAL_INT_CABEND
expr_stmt|;
if|if
condition|(
name|isr2
operator|&
name|AR_ISR_S2_TBTT
condition|)
name|mask2
operator||=
name|HAL_INT_TBTT
expr_stmt|;
block|}
name|isr
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_RAC
argument_list|)
expr_stmt|;
if|if
condition|(
name|isr
operator|==
literal|0xffffffff
condition|)
block|{
operator|*
name|masked
operator|=
literal|0
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
operator|*
name|masked
operator|=
name|isr
operator|&
name|HAL_INT_COMMON
expr_stmt|;
if|if
condition|(
name|isr
operator|&
name|AR_ISR_HIUERR
condition|)
operator|*
name|masked
operator||=
name|HAL_INT_FATAL
expr_stmt|;
if|if
condition|(
name|isr
operator|&
operator|(
name|AR_ISR_RXOK
operator||
name|AR_ISR_RXERR
operator|)
condition|)
operator|*
name|masked
operator||=
name|HAL_INT_RX
expr_stmt|;
if|if
condition|(
name|isr
operator|&
operator|(
name|AR_ISR_TXOK
operator||
name|AR_ISR_TXDESC
operator||
name|AR_ISR_TXERR
operator||
name|AR_ISR_TXEOL
operator|)
condition|)
block|{
operator|*
name|masked
operator||=
name|HAL_INT_TX
expr_stmt|;
name|isr0
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S0_S
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_intrTxqs
operator||=
name|MS
argument_list|(
name|isr0
argument_list|,
name|AR_ISR_S0_QCU_TXOK
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_intrTxqs
operator||=
name|MS
argument_list|(
name|isr0
argument_list|,
name|AR_ISR_S0_QCU_TXDESC
argument_list|)
expr_stmt|;
name|isr1
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S1_S
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_intrTxqs
operator||=
name|MS
argument_list|(
name|isr1
argument_list|,
name|AR_ISR_S1_QCU_TXERR
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_intrTxqs
operator||=
name|MS
argument_list|(
name|isr1
argument_list|,
name|AR_ISR_S1_QCU_TXEOL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Receive overrun is usually non-fatal on Oahu/Spirit. 	 * BUT on some parts rx could fail and the chip must be reset. 	 * So we force a hardware reset in all cases. 	 */
if|if
condition|(
operator|(
name|isr
operator|&
name|AR_ISR_RXORN
operator|)
operator|&&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rxornIsFatal
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: receive FIFO overrun interrupt\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|*
name|masked
operator||=
name|HAL_INT_FATAL
expr_stmt|;
block|}
operator|*
name|masked
operator||=
name|mask2
expr_stmt|;
comment|/* 	 * On fatal errors collect ISR state for debugging. 	 */
if|if
condition|(
operator|*
name|masked
operator|&
name|HAL_INT_FATAL
condition|)
block|{
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_fatalState
index|[
literal|0
index|]
operator|=
name|isr
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_fatalState
index|[
literal|1
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S0_S
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_fatalState
index|[
literal|2
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S1_S
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_fatalState
index|[
literal|3
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S2_S
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_fatalState
index|[
literal|4
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S3_S
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_fatalState
index|[
literal|5
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S4_S
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: fatal error, ISR_RAC=0x%x ISR_S2_S=0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|isr
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_fatalState
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|HAL_INT
name|ar5212GetInterrupts
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|AH5212
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_maskReg
return|;
block|}
end_function

begin_comment
comment|/*  * Atomically enables NIC interrupts.  Interrupts are passed in  * via the enumerated bitmask in ints.  */
end_comment

begin_function
name|HAL_INT
name|ar5212SetInterrupts
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_INT
name|ints
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|uint32_t
name|omask
init|=
name|ahp
operator|->
name|ah_maskReg
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|,
name|mask2
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: 0x%x => 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|omask
argument_list|,
name|ints
argument_list|)
expr_stmt|;
if|if
condition|(
name|omask
operator|&
name|HAL_INT_GLOBAL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: disable IER\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IER
argument_list|,
name|AR_IER_DISABLE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_IER
argument_list|)
expr_stmt|;
comment|/* flush write to HW */
block|}
name|mask
operator|=
name|ints
operator|&
name|HAL_INT_COMMON
expr_stmt|;
name|mask2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_TX
condition|)
block|{
if|if
condition|(
name|ahp
operator|->
name|ah_txOkInterruptMask
condition|)
name|mask
operator||=
name|AR_IMR_TXOK
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_txErrInterruptMask
condition|)
name|mask
operator||=
name|AR_IMR_TXERR
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_txDescInterruptMask
condition|)
name|mask
operator||=
name|AR_IMR_TXDESC
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_txEolInterruptMask
condition|)
name|mask
operator||=
name|AR_IMR_TXEOL
expr_stmt|;
block|}
if|if
condition|(
name|ints
operator|&
name|HAL_INT_RX
condition|)
name|mask
operator||=
name|AR_IMR_RXOK
operator||
name|AR_IMR_RXERR
operator||
name|AR_IMR_RXDESC
expr_stmt|;
if|if
condition|(
name|ints
operator|&
operator|(
name|HAL_INT_BMISC
operator|)
condition|)
block|{
name|mask
operator||=
name|AR_IMR_BCNMISC
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_TIM
condition|)
name|mask2
operator||=
name|AR_IMR_S2_TIM
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_DTIM
condition|)
name|mask2
operator||=
name|AR_IMR_S2_DTIM
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_DTIMSYNC
condition|)
name|mask2
operator||=
name|AR_IMR_S2_DTIMSYNC
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_CABEND
condition|)
name|mask2
operator||=
name|AR_IMR_S2_CABEND
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_TBTT
condition|)
name|mask2
operator||=
name|AR_IMR_S2_TBTT
expr_stmt|;
block|}
if|if
condition|(
name|ints
operator|&
name|HAL_INT_FATAL
condition|)
block|{
comment|/* 		 * NB: ar5212Reset sets MCABT+SSERR+DPERR in AR_IMR_S2 		 *     so enabling HIUERR enables delivery. 		 */
name|mask
operator||=
name|AR_IMR_HIUERR
expr_stmt|;
block|}
comment|/* Write the new IMR and store off our SW copy. */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: new IMR 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S2
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S2
argument_list|)
operator|&
operator|~
name|AR_IMR_SR2_BCNMISC
operator|)
operator||
name|mask2
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_maskReg
operator|=
name|ints
expr_stmt|;
comment|/* Re-enable interrupts if they were enabled before. */
if|if
condition|(
name|ints
operator|&
name|HAL_INT_GLOBAL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: enable IER\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IER
argument_list|,
name|AR_IER_ENABLE
argument_list|)
expr_stmt|;
block|}
return|return
name|omask
return|;
block|}
end_function

end_unit

