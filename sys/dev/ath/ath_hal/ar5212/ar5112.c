begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2002-2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_eeprom_v3.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212phy.h"
end_include

begin_define
define|#
directive|define
name|AH_5212_5112
end_define

begin_include
include|#
directive|include
file|"ar5212/ar5212.ini"
end_include

begin_define
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
end_define

begin_struct
struct|struct
name|ar5112State
block|{
name|RF_HAL_FUNCS
name|base
decl_stmt|;
comment|/* public state, must be first */
name|uint16_t
name|pcdacTable
index|[
name|PWR_TABLE_SIZE
index|]
decl_stmt|;
name|uint32_t
name|Bank1Data
index|[
name|N
argument_list|(
name|ar5212Bank1_5112
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|Bank2Data
index|[
name|N
argument_list|(
name|ar5212Bank2_5112
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|Bank3Data
index|[
name|N
argument_list|(
name|ar5212Bank3_5112
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|Bank6Data
index|[
name|N
argument_list|(
name|ar5212Bank6_5112
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|Bank7Data
index|[
name|N
argument_list|(
name|ar5212Bank7_5112
argument_list|)
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|AR5112
parameter_list|(
name|ah
parameter_list|)
value|((struct ar5112State *) AH5212(ah)->ah_rfHal)
end_define

begin_function_decl
specifier|static
name|void
name|ar5212GetLowerUpperIndex
parameter_list|(
name|uint16_t
name|v
parameter_list|,
name|uint16_t
modifier|*
name|lp
parameter_list|,
name|uint16_t
name|listSize
parameter_list|,
name|uint32_t
modifier|*
name|vlo
parameter_list|,
name|uint32_t
modifier|*
name|vhi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|getFullPwrTable
parameter_list|(
name|uint16_t
name|numPcdacs
parameter_list|,
name|uint16_t
modifier|*
name|pcdacs
parameter_list|,
name|int16_t
modifier|*
name|power
parameter_list|,
name|int16_t
name|maxPower
parameter_list|,
name|int16_t
modifier|*
name|retVals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int16_t
name|getPminAndPcdacTableFromPowerTable
parameter_list|(
name|int16_t
modifier|*
name|pwrTableT4
parameter_list|,
name|uint16_t
name|retVals
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int16_t
name|getPminAndPcdacTableFromTwoPowerTables
parameter_list|(
name|int16_t
modifier|*
name|pwrTableLXpdT4
parameter_list|,
name|int16_t
modifier|*
name|pwrTableHXpdT4
parameter_list|,
name|uint16_t
name|retVals
index|[]
parameter_list|,
name|int16_t
modifier|*
name|pMid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int16_t
name|interpolate_signed
parameter_list|(
name|uint16_t
name|target
parameter_list|,
name|uint16_t
name|srcLeft
parameter_list|,
name|uint16_t
name|srcRight
parameter_list|,
name|int16_t
name|targetLeft
parameter_list|,
name|int16_t
name|targetRight
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|ar5212ModifyRfBuffer
parameter_list|(
name|uint32_t
modifier|*
name|rfBuf
parameter_list|,
name|uint32_t
name|reg32
parameter_list|,
name|uint32_t
name|numBits
parameter_list|,
name|uint32_t
name|firstBit
parameter_list|,
name|uint32_t
name|column
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|ar5112WriteRegs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|modesIndex
parameter_list|,
name|u_int
name|freqIndex
parameter_list|,
name|int
name|writes
parameter_list|)
block|{
name|HAL_INI_WRITE_ARRAY
argument_list|(
name|ah
argument_list|,
name|ar5212Modes_5112
argument_list|,
name|modesIndex
argument_list|,
name|writes
argument_list|)
expr_stmt|;
name|HAL_INI_WRITE_ARRAY
argument_list|(
name|ah
argument_list|,
name|ar5212Common_5112
argument_list|,
literal|1
argument_list|,
name|writes
argument_list|)
expr_stmt|;
name|HAL_INI_WRITE_ARRAY
argument_list|(
name|ah
argument_list|,
name|ar5212BB_RfGain_5112
argument_list|,
name|freqIndex
argument_list|,
name|writes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take the MHz channel value and set the Channel value  *  * ASSUMES: Writes enabled to analog bus  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5112SetChannel
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|uint16_t
name|freq
init|=
name|ath_hal_gethwchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|uint32_t
name|channelSel
init|=
literal|0
decl_stmt|;
name|uint32_t
name|bModeSynth
init|=
literal|0
decl_stmt|;
name|uint32_t
name|aModeRefSel
init|=
literal|0
decl_stmt|;
name|uint32_t
name|reg32
init|=
literal|0
decl_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_SETCHANNEL
argument_list|,
name|freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq
operator|<
literal|4800
condition|)
block|{
name|uint32_t
name|txctl
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|freq
operator|-
literal|2192
operator|)
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
block|{
name|channelSel
operator|=
operator|(
operator|(
name|freq
operator|-
literal|672
operator|)
operator|*
literal|2
operator|-
literal|3040
operator|)
operator|/
literal|10
expr_stmt|;
name|bModeSynth
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|freq
operator|-
literal|2224
operator|)
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
block|{
name|channelSel
operator|=
operator|(
operator|(
name|freq
operator|-
literal|704
operator|)
operator|*
literal|2
operator|-
literal|3040
operator|)
operator|/
literal|10
expr_stmt|;
name|bModeSynth
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel %u MHz\n"
argument_list|,
name|__func__
argument_list|,
name|freq
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|channelSel
operator|=
operator|(
name|channelSel
operator|<<
literal|2
operator|)
operator|&
literal|0xff
expr_stmt|;
name|channelSel
operator|=
name|ath_hal_reverseBits
argument_list|(
name|channelSel
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|txctl
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_TX_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq
operator|==
literal|2484
condition|)
block|{
comment|/* Enable channel spreading for channel 14 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_TX_CTRL
argument_list|,
name|txctl
operator||
name|AR_PHY_CCK_TX_CTRL_JAPAN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_TX_CTRL
argument_list|,
name|txctl
operator|&
operator|~
name|AR_PHY_CCK_TX_CTRL_JAPAN
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|freq
operator|%
literal|5
operator|)
operator|==
literal|2
operator|)
operator|&&
operator|(
name|freq
operator|<=
literal|5435
operator|)
condition|)
block|{
name|freq
operator|=
name|freq
operator|-
literal|2
expr_stmt|;
comment|/* Align to even 5MHz raster */
name|channelSel
operator|=
name|ath_hal_reverseBits
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
operator|(
operator|(
name|freq
operator|-
literal|4800
operator|)
operator|*
literal|10
operator|)
operator|/
literal|25
operator|+
literal|1
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|aModeRefSel
operator|=
name|ath_hal_reverseBits
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|freq
operator|%
literal|20
operator|)
operator|==
literal|0
operator|&&
name|freq
operator|>=
literal|5120
condition|)
block|{
name|channelSel
operator|=
name|ath_hal_reverseBits
argument_list|(
operator|(
operator|(
name|freq
operator|-
literal|4800
operator|)
operator|/
literal|20
operator|<<
literal|2
operator|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|aModeRefSel
operator|=
name|ath_hal_reverseBits
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|freq
operator|%
literal|10
operator|)
operator|==
literal|0
condition|)
block|{
name|channelSel
operator|=
name|ath_hal_reverseBits
argument_list|(
operator|(
operator|(
name|freq
operator|-
literal|4800
operator|)
operator|/
literal|10
operator|<<
literal|1
operator|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|aModeRefSel
operator|=
name|ath_hal_reverseBits
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|freq
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
block|{
name|channelSel
operator|=
name|ath_hal_reverseBits
argument_list|(
operator|(
name|freq
operator|-
literal|4800
operator|)
operator|/
literal|5
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|aModeRefSel
operator|=
name|ath_hal_reverseBits
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel %u MHz\n"
argument_list|,
name|__func__
argument_list|,
name|freq
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|reg32
operator|=
operator|(
name|channelSel
operator|<<
literal|4
operator|)
operator||
operator|(
name|aModeRefSel
operator|<<
literal|2
operator|)
operator||
operator|(
name|bModeSynth
operator|<<
literal|1
operator|)
operator||
operator|(
literal|1
operator|<<
literal|12
operator|)
operator||
literal|0x1
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0x27
argument_list|)
argument_list|,
name|reg32
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|reg32
operator|>>=
literal|8
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0x36
argument_list|)
argument_list|,
name|reg32
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|=
name|chan
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Return a reference to the requested RF Bank.  */
end_comment

begin_function
specifier|static
name|uint32_t
modifier|*
name|ar5112GetRfBank
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|bank
parameter_list|)
block|{
name|struct
name|ar5112State
modifier|*
name|priv
init|=
name|AR5112
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HALASSERT
argument_list|(
name|priv
operator|!=
name|AH_NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bank
condition|)
block|{
case|case
literal|1
case|:
return|return
name|priv
operator|->
name|Bank1Data
return|;
case|case
literal|2
case|:
return|return
name|priv
operator|->
name|Bank2Data
return|;
case|case
literal|3
case|:
return|return
name|priv
operator|->
name|Bank3Data
return|;
case|case
literal|6
case|:
return|return
name|priv
operator|->
name|Bank6Data
return|;
case|case
literal|7
case|:
return|return
name|priv
operator|->
name|Bank7Data
return|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: unknown RF Bank %d requested\n"
argument_list|,
name|__func__
argument_list|,
name|bank
argument_list|)
expr_stmt|;
return|return
name|AH_NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Reads EEPROM header info from device structure and programs  * all rf registers  *  * REQUIRES: Access to the analog rf device  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5112SetRfRegs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|uint16_t
name|modesIndex
parameter_list|,
name|uint16_t
modifier|*
name|rfXpdGain
parameter_list|)
block|{
define|#
directive|define
name|RF_BANK_SETUP
parameter_list|(
name|_priv
parameter_list|,
name|_ix
parameter_list|,
name|_col
parameter_list|)
value|do {				    \ 	int i;								    \ 	for (i = 0; i< N(ar5212Bank##_ix##_5112); i++)			    \ 		(_priv)->Bank##_ix##Data[i] = ar5212Bank##_ix##_5112[i][_col];\ } while (0)
name|uint16_t
name|freq
init|=
name|ath_hal_gethwchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
specifier|const
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|uint16_t
name|rfXpdSel
decl_stmt|,
name|gainI
decl_stmt|;
name|uint16_t
name|ob5GHz
init|=
literal|0
decl_stmt|,
name|db5GHz
init|=
literal|0
decl_stmt|;
name|uint16_t
name|ob2GHz
init|=
literal|0
decl_stmt|,
name|db2GHz
init|=
literal|0
decl_stmt|;
name|struct
name|ar5112State
modifier|*
name|priv
init|=
name|AR5112
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|GAIN_VALUES
modifier|*
name|gv
init|=
operator|&
name|ahp
operator|->
name|ah_gainValues
decl_stmt|;
name|int
name|regWrites
init|=
literal|0
decl_stmt|;
name|HALASSERT
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RFPARAM
argument_list|,
literal|"%s: chan %u/0x%x modesIndex %u\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|,
name|modesIndex
argument_list|)
expr_stmt|;
comment|/* Setup rf parameters */
switch|switch
condition|(
name|chan
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_ALLFULL
condition|)
block|{
case|case
name|IEEE80211_CHAN_A
case|:
if|if
condition|(
name|freq
operator|>
literal|4000
operator|&&
name|freq
operator|<
literal|5260
condition|)
block|{
name|ob5GHz
operator|=
name|ee
operator|->
name|ee_ob1
expr_stmt|;
name|db5GHz
operator|=
name|ee
operator|->
name|ee_db1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|freq
operator|>=
literal|5260
operator|&&
name|freq
operator|<
literal|5500
condition|)
block|{
name|ob5GHz
operator|=
name|ee
operator|->
name|ee_ob2
expr_stmt|;
name|db5GHz
operator|=
name|ee
operator|->
name|ee_db2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|freq
operator|>=
literal|5500
operator|&&
name|freq
operator|<
literal|5725
condition|)
block|{
name|ob5GHz
operator|=
name|ee
operator|->
name|ee_ob3
expr_stmt|;
name|db5GHz
operator|=
name|ee
operator|->
name|ee_db3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|freq
operator|>=
literal|5725
condition|)
block|{
name|ob5GHz
operator|=
name|ee
operator|->
name|ee_ob4
expr_stmt|;
name|db5GHz
operator|=
name|ee
operator|->
name|ee_db4
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX else */
block|}
name|rfXpdSel
operator|=
name|ee
operator|->
name|ee_xpd
index|[
name|headerInfo11A
index|]
expr_stmt|;
name|gainI
operator|=
name|ee
operator|->
name|ee_gainI
index|[
name|headerInfo11A
index|]
expr_stmt|;
break|break;
case|case
name|IEEE80211_CHAN_B
case|:
name|ob2GHz
operator|=
name|ee
operator|->
name|ee_ob2GHz
index|[
literal|0
index|]
expr_stmt|;
name|db2GHz
operator|=
name|ee
operator|->
name|ee_db2GHz
index|[
literal|0
index|]
expr_stmt|;
name|rfXpdSel
operator|=
name|ee
operator|->
name|ee_xpd
index|[
name|headerInfo11B
index|]
expr_stmt|;
name|gainI
operator|=
name|ee
operator|->
name|ee_gainI
index|[
name|headerInfo11B
index|]
expr_stmt|;
break|break;
case|case
name|IEEE80211_CHAN_G
case|:
case|case
name|IEEE80211_CHAN_PUREG
case|:
comment|/* NB: really 108G */
name|ob2GHz
operator|=
name|ee
operator|->
name|ee_ob2GHz
index|[
literal|1
index|]
expr_stmt|;
name|db2GHz
operator|=
name|ee
operator|->
name|ee_ob2GHz
index|[
literal|1
index|]
expr_stmt|;
name|rfXpdSel
operator|=
name|ee
operator|->
name|ee_xpd
index|[
name|headerInfo11G
index|]
expr_stmt|;
name|gainI
operator|=
name|ee
operator|->
name|ee_gainI
index|[
name|headerInfo11G
index|]
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* Setup Bank 1 Write */
name|RF_BANK_SETUP
argument_list|(
name|priv
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Setup Bank 2 Write */
name|RF_BANK_SETUP
argument_list|(
name|priv
argument_list|,
literal|2
argument_list|,
name|modesIndex
argument_list|)
expr_stmt|;
comment|/* Setup Bank 3 Write */
name|RF_BANK_SETUP
argument_list|(
name|priv
argument_list|,
literal|3
argument_list|,
name|modesIndex
argument_list|)
expr_stmt|;
comment|/* Setup Bank 6 Write */
name|RF_BANK_SETUP
argument_list|(
name|priv
argument_list|,
literal|6
argument_list|,
name|modesIndex
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|rfXpdSel
argument_list|,
literal|1
argument_list|,
literal|302
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|rfXpdGain
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|,
literal|270
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|rfXpdGain
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|,
literal|257
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_OFDM
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|gv
operator|->
name|currStep
operator|->
name|paramVal
index|[
name|GP_PWD_138
index|]
argument_list|,
literal|1
argument_list|,
literal|168
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|gv
operator|->
name|currStep
operator|->
name|paramVal
index|[
name|GP_PWD_137
index|]
argument_list|,
literal|1
argument_list|,
literal|169
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|gv
operator|->
name|currStep
operator|->
name|paramVal
index|[
name|GP_PWD_136
index|]
argument_list|,
literal|1
argument_list|,
literal|170
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|gv
operator|->
name|currStep
operator|->
name|paramVal
index|[
name|GP_PWD_132
index|]
argument_list|,
literal|1
argument_list|,
literal|174
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|gv
operator|->
name|currStep
operator|->
name|paramVal
index|[
name|GP_PWD_131
index|]
argument_list|,
literal|1
argument_list|,
literal|175
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|gv
operator|->
name|currStep
operator|->
name|paramVal
index|[
name|GP_PWD_130
index|]
argument_list|,
literal|1
argument_list|,
literal|176
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/* Only the 5 or 2 GHz OB/DB need to be set for a mode */
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|ob2GHz
argument_list|,
literal|3
argument_list|,
literal|287
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|db2GHz
argument_list|,
literal|3
argument_list|,
literal|290
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|ob5GHz
argument_list|,
literal|3
argument_list|,
literal|279
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
name|db5GHz
argument_list|,
literal|3
argument_list|,
literal|282
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Lower synth voltage for X112 Rev 2.0 only */
if|if
condition|(
name|IS_RADX112_REV2
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Non-Reversed analyg registers - so values are pre-reversed */
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|90
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|92
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|94
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|254
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Decrease Power Consumption for 5312/5213 and up */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyRev
operator|>=
name|AR_PHY_CHIP_ID_REV_2
condition|)
block|{
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|281
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|139
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank6Data
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|140
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/* Setup Bank 7 Setup */
name|RF_BANK_SETUP
argument_list|(
name|priv
argument_list|,
literal|7
argument_list|,
name|modesIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_OFDM
argument_list|(
name|chan
argument_list|)
condition|)
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank7Data
argument_list|,
name|gv
operator|->
name|currStep
operator|->
name|paramVal
index|[
name|GP_MIXGAIN_OVR
index|]
argument_list|,
literal|2
argument_list|,
literal|37
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank7Data
argument_list|,
name|gainI
argument_list|,
literal|6
argument_list|,
literal|14
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Adjust params for Derby TX power control */
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
operator|||
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|uint32_t
name|rfDelay
decl_stmt|,
name|rfPeriod
decl_stmt|;
name|rfDelay
operator|=
literal|0xf
expr_stmt|;
name|rfPeriod
operator|=
operator|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
operator|)
condition|?
literal|0x8
else|:
literal|0xf
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank7Data
argument_list|,
name|rfDelay
argument_list|,
literal|4
argument_list|,
literal|58
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|priv
operator|->
name|Bank7Data
argument_list|,
name|rfPeriod
argument_list|,
literal|4
argument_list|,
literal|70
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notyet
comment|/* Analog registers are setup - EAR can modify */
if|if
condition|(
name|ar5212IsEarEngaged
argument_list|(
name|pDev
argument_list|,
name|chan
argument_list|)
condition|)
name|uint32_t
name|modifier
decl_stmt|;
name|ar5212EarModify
argument_list|(
name|pDev
argument_list|,
name|EAR_LC_RF_WRITE
argument_list|,
name|chan
argument_list|,
operator|&
name|modifier
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Write Analog registers */
name|HAL_INI_WRITE_BANK
argument_list|(
name|ah
argument_list|,
name|ar5212Bank1_5112
argument_list|,
name|priv
operator|->
name|Bank1Data
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
name|HAL_INI_WRITE_BANK
argument_list|(
name|ah
argument_list|,
name|ar5212Bank2_5112
argument_list|,
name|priv
operator|->
name|Bank2Data
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
name|HAL_INI_WRITE_BANK
argument_list|(
name|ah
argument_list|,
name|ar5212Bank3_5112
argument_list|,
name|priv
operator|->
name|Bank3Data
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
name|HAL_INI_WRITE_BANK
argument_list|(
name|ah
argument_list|,
name|ar5212Bank6_5112
argument_list|,
name|priv
operator|->
name|Bank6Data
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
name|HAL_INI_WRITE_BANK
argument_list|(
name|ah
argument_list|,
name|ar5212Bank7_5112
argument_list|,
name|priv
operator|->
name|Bank7Data
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
comment|/* Now that we have reprogrammed rfgain value, clear the flag. */
name|ahp
operator|->
name|ah_rfgainState
operator|=
name|HAL_RFGAIN_INACTIVE
expr_stmt|;
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|RF_BANK_SETUP
block|}
end_function

begin_comment
comment|/*  * Read the transmit power levels from the structures taken from EEPROM  * Interpolate read transmit power values for this channel  * Organize the transmit power values into a table for writing into the hardware  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5112SetPowerTable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int16_t
modifier|*
name|pPowerMin
parameter_list|,
name|int16_t
modifier|*
name|pPowerMax
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|uint16_t
modifier|*
name|rfXpdGain
parameter_list|)
block|{
name|uint16_t
name|freq
init|=
name|ath_hal_gethwchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
specifier|const
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|uint32_t
name|numXpdGain
init|=
name|IS_RADX112_REV2
argument_list|(
name|ah
argument_list|)
condition|?
literal|2
else|:
literal|1
decl_stmt|;
name|uint32_t
name|xpdGainMask
init|=
literal|0
decl_stmt|;
name|int16_t
name|powerMid
decl_stmt|,
modifier|*
name|pPowerMid
init|=
operator|&
name|powerMid
decl_stmt|;
specifier|const
name|EXPN_DATA_PER_CHANNEL_5112
modifier|*
name|pRawCh
decl_stmt|;
specifier|const
name|EEPROM_POWER_EXPN_5112
modifier|*
name|pPowerExpn
init|=
name|AH_NULL
decl_stmt|;
name|uint32_t
name|ii
decl_stmt|,
name|jj
decl_stmt|,
name|kk
decl_stmt|;
name|int16_t
name|minPwr_t4
decl_stmt|,
name|maxPwr_t4
decl_stmt|,
name|Pmin
decl_stmt|,
name|Pmid
decl_stmt|;
name|uint32_t
name|chan_idx_L
init|=
literal|0
decl_stmt|,
name|chan_idx_R
init|=
literal|0
decl_stmt|;
name|uint16_t
name|chan_L
decl_stmt|,
name|chan_R
decl_stmt|;
name|int16_t
name|pwr_table0
index|[
literal|64
index|]
decl_stmt|;
name|int16_t
name|pwr_table1
index|[
literal|64
index|]
decl_stmt|;
name|uint16_t
name|pcdacs
index|[
literal|10
index|]
decl_stmt|;
name|int16_t
name|powers
index|[
literal|10
index|]
decl_stmt|;
name|uint16_t
name|numPcd
decl_stmt|;
name|int16_t
name|powTableLXPD
index|[
literal|2
index|]
index|[
literal|64
index|]
decl_stmt|;
name|int16_t
name|powTableHXPD
index|[
literal|2
index|]
index|[
literal|64
index|]
decl_stmt|;
name|int16_t
name|tmpPowerTable
index|[
literal|64
index|]
decl_stmt|;
name|uint16_t
name|xgainList
index|[
literal|2
index|]
decl_stmt|;
name|uint16_t
name|xpdMask
decl_stmt|;
switch|switch
condition|(
name|chan
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_ALLTURBOFULL
condition|)
block|{
case|case
name|IEEE80211_CHAN_A
case|:
case|case
name|IEEE80211_CHAN_ST
case|:
name|pPowerExpn
operator|=
operator|&
name|ee
operator|->
name|ee_modePowerArray5112
index|[
name|headerInfo11A
index|]
expr_stmt|;
name|xpdGainMask
operator|=
name|ee
operator|->
name|ee_xgain
index|[
name|headerInfo11A
index|]
expr_stmt|;
break|break;
case|case
name|IEEE80211_CHAN_B
case|:
name|pPowerExpn
operator|=
operator|&
name|ee
operator|->
name|ee_modePowerArray5112
index|[
name|headerInfo11B
index|]
expr_stmt|;
name|xpdGainMask
operator|=
name|ee
operator|->
name|ee_xgain
index|[
name|headerInfo11B
index|]
expr_stmt|;
break|break;
case|case
name|IEEE80211_CHAN_G
case|:
case|case
name|IEEE80211_CHAN_108G
case|:
name|pPowerExpn
operator|=
operator|&
name|ee
operator|->
name|ee_modePowerArray5112
index|[
name|headerInfo11G
index|]
expr_stmt|;
name|xpdGainMask
operator|=
name|ee
operator|->
name|ee_xgain
index|[
name|headerInfo11G
index|]
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: unknown channel flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
if|if
condition|(
operator|(
name|xpdGainMask
operator|&
name|pPowerExpn
operator|->
name|xpdMask
operator|)
operator|<
literal|1
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: desired xpdGainMask 0x%x not supported by "
literal|"calibrated xpdMask 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|xpdGainMask
argument_list|,
name|pPowerExpn
operator|->
name|xpdMask
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|maxPwr_t4
operator|=
call|(
name|int16_t
call|)
argument_list|(
literal|2
operator|*
operator|(
operator|*
name|pPowerMax
operator|)
argument_list|)
expr_stmt|;
comment|/* pwr_t2 -> pwr_t4 */
name|minPwr_t4
operator|=
call|(
name|int16_t
call|)
argument_list|(
literal|2
operator|*
operator|(
operator|*
name|pPowerMin
operator|)
argument_list|)
expr_stmt|;
comment|/* pwr_t2 -> pwr_t4 */
name|xgainList
index|[
literal|0
index|]
operator|=
literal|0xDEAD
expr_stmt|;
name|xgainList
index|[
literal|1
index|]
operator|=
literal|0xDEAD
expr_stmt|;
name|kk
operator|=
literal|0
expr_stmt|;
name|xpdMask
operator|=
name|pPowerExpn
operator|->
name|xpdMask
expr_stmt|;
for|for
control|(
name|jj
operator|=
literal|0
init|;
name|jj
operator|<
name|NUM_XPD_PER_CHANNEL
condition|;
name|jj
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|xpdMask
operator|>>
name|jj
operator|)
operator|&
literal|1
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|kk
operator|>
literal|1
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"A maximum of 2 xpdGains supported"
literal|"in pExpnPower data\n"
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|xgainList
index|[
name|kk
operator|++
index|]
operator|=
operator|(
name|uint16_t
operator|)
name|jj
expr_stmt|;
block|}
block|}
name|ar5212GetLowerUpperIndex
argument_list|(
name|freq
argument_list|,
operator|&
name|pPowerExpn
operator|->
name|pChannels
index|[
literal|0
index|]
argument_list|,
name|pPowerExpn
operator|->
name|numChannels
argument_list|,
operator|&
name|chan_idx_L
argument_list|,
operator|&
name|chan_idx_R
argument_list|)
expr_stmt|;
name|kk
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ii
operator|=
name|chan_idx_L
init|;
name|ii
operator|<=
name|chan_idx_R
condition|;
name|ii
operator|++
control|)
block|{
name|pRawCh
operator|=
operator|&
operator|(
name|pPowerExpn
operator|->
name|pDataPerChannel
index|[
name|ii
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|xgainList
index|[
literal|1
index|]
operator|==
literal|0xDEAD
condition|)
block|{
name|jj
operator|=
name|xgainList
index|[
literal|0
index|]
expr_stmt|;
name|numPcd
operator|=
name|pRawCh
operator|->
name|pDataPerXPD
index|[
name|jj
index|]
operator|.
name|numPcdacs
expr_stmt|;
name|OS_MEMCPY
argument_list|(
operator|&
name|pcdacs
index|[
literal|0
index|]
argument_list|,
operator|&
name|pRawCh
operator|->
name|pDataPerXPD
index|[
name|jj
index|]
operator|.
name|pcdac
index|[
literal|0
index|]
argument_list|,
name|numPcd
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|OS_MEMCPY
argument_list|(
operator|&
name|powers
index|[
literal|0
index|]
argument_list|,
operator|&
name|pRawCh
operator|->
name|pDataPerXPD
index|[
name|jj
index|]
operator|.
name|pwr_t4
index|[
literal|0
index|]
argument_list|,
name|numPcd
operator|*
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getFullPwrTable
argument_list|(
name|numPcd
argument_list|,
operator|&
name|pcdacs
index|[
literal|0
index|]
argument_list|,
operator|&
name|powers
index|[
literal|0
index|]
argument_list|,
name|pRawCh
operator|->
name|maxPower_t4
argument_list|,
operator|&
name|tmpPowerTable
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
name|OS_MEMCPY
argument_list|(
operator|&
name|powTableLXPD
index|[
name|kk
index|]
index|[
literal|0
index|]
argument_list|,
operator|&
name|tmpPowerTable
index|[
literal|0
index|]
argument_list|,
literal|64
operator|*
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jj
operator|=
name|xgainList
index|[
literal|0
index|]
expr_stmt|;
name|numPcd
operator|=
name|pRawCh
operator|->
name|pDataPerXPD
index|[
name|jj
index|]
operator|.
name|numPcdacs
expr_stmt|;
name|OS_MEMCPY
argument_list|(
operator|&
name|pcdacs
index|[
literal|0
index|]
argument_list|,
operator|&
name|pRawCh
operator|->
name|pDataPerXPD
index|[
name|jj
index|]
operator|.
name|pcdac
index|[
literal|0
index|]
argument_list|,
name|numPcd
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|OS_MEMCPY
argument_list|(
operator|&
name|powers
index|[
literal|0
index|]
argument_list|,
operator|&
name|pRawCh
operator|->
name|pDataPerXPD
index|[
name|jj
index|]
operator|.
name|pwr_t4
index|[
literal|0
index|]
argument_list|,
name|numPcd
operator|*
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getFullPwrTable
argument_list|(
name|numPcd
argument_list|,
operator|&
name|pcdacs
index|[
literal|0
index|]
argument_list|,
operator|&
name|powers
index|[
literal|0
index|]
argument_list|,
name|pRawCh
operator|->
name|maxPower_t4
argument_list|,
operator|&
name|tmpPowerTable
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
name|OS_MEMCPY
argument_list|(
operator|&
name|powTableLXPD
index|[
name|kk
index|]
index|[
literal|0
index|]
argument_list|,
operator|&
name|tmpPowerTable
index|[
literal|0
index|]
argument_list|,
literal|64
operator|*
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
argument_list|)
expr_stmt|;
name|jj
operator|=
name|xgainList
index|[
literal|1
index|]
expr_stmt|;
name|numPcd
operator|=
name|pRawCh
operator|->
name|pDataPerXPD
index|[
name|jj
index|]
operator|.
name|numPcdacs
expr_stmt|;
name|OS_MEMCPY
argument_list|(
operator|&
name|pcdacs
index|[
literal|0
index|]
argument_list|,
operator|&
name|pRawCh
operator|->
name|pDataPerXPD
index|[
name|jj
index|]
operator|.
name|pcdac
index|[
literal|0
index|]
argument_list|,
name|numPcd
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|OS_MEMCPY
argument_list|(
operator|&
name|powers
index|[
literal|0
index|]
argument_list|,
operator|&
name|pRawCh
operator|->
name|pDataPerXPD
index|[
name|jj
index|]
operator|.
name|pwr_t4
index|[
literal|0
index|]
argument_list|,
name|numPcd
operator|*
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getFullPwrTable
argument_list|(
name|numPcd
argument_list|,
operator|&
name|pcdacs
index|[
literal|0
index|]
argument_list|,
operator|&
name|powers
index|[
literal|0
index|]
argument_list|,
name|pRawCh
operator|->
name|maxPower_t4
argument_list|,
operator|&
name|tmpPowerTable
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
name|OS_MEMCPY
argument_list|(
operator|&
name|powTableHXPD
index|[
name|kk
index|]
index|[
literal|0
index|]
argument_list|,
operator|&
name|tmpPowerTable
index|[
literal|0
index|]
argument_list|,
literal|64
operator|*
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kk
operator|++
expr_stmt|;
block|}
name|chan_L
operator|=
name|pPowerExpn
operator|->
name|pChannels
index|[
name|chan_idx_L
index|]
expr_stmt|;
name|chan_R
operator|=
name|pPowerExpn
operator|->
name|pChannels
index|[
name|chan_idx_R
index|]
expr_stmt|;
name|kk
operator|=
name|chan_idx_R
operator|-
name|chan_idx_L
expr_stmt|;
if|if
condition|(
name|xgainList
index|[
literal|1
index|]
operator|==
literal|0xDEAD
condition|)
block|{
for|for
control|(
name|jj
operator|=
literal|0
init|;
name|jj
operator|<
literal|64
condition|;
name|jj
operator|++
control|)
block|{
name|pwr_table0
index|[
name|jj
index|]
operator|=
name|interpolate_signed
argument_list|(
name|freq
argument_list|,
name|chan_L
argument_list|,
name|chan_R
argument_list|,
name|powTableLXPD
index|[
literal|0
index|]
index|[
name|jj
index|]
argument_list|,
name|powTableLXPD
index|[
name|kk
index|]
index|[
name|jj
index|]
argument_list|)
expr_stmt|;
block|}
name|Pmin
operator|=
name|getPminAndPcdacTableFromPowerTable
argument_list|(
operator|&
name|pwr_table0
index|[
literal|0
index|]
argument_list|,
name|ahp
operator|->
name|ah_pcdacTable
argument_list|)
expr_stmt|;
operator|*
name|pPowerMin
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|Pmin
operator|/
literal|2
argument_list|)
expr_stmt|;
operator|*
name|pPowerMid
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|pwr_table0
index|[
literal|63
index|]
operator|/
literal|2
argument_list|)
expr_stmt|;
operator|*
name|pPowerMax
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|pwr_table0
index|[
literal|63
index|]
operator|/
literal|2
argument_list|)
expr_stmt|;
name|rfXpdGain
index|[
literal|0
index|]
operator|=
name|xgainList
index|[
literal|0
index|]
expr_stmt|;
name|rfXpdGain
index|[
literal|1
index|]
operator|=
name|rfXpdGain
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|jj
operator|=
literal|0
init|;
name|jj
operator|<
literal|64
condition|;
name|jj
operator|++
control|)
block|{
name|pwr_table0
index|[
name|jj
index|]
operator|=
name|interpolate_signed
argument_list|(
name|freq
argument_list|,
name|chan_L
argument_list|,
name|chan_R
argument_list|,
name|powTableLXPD
index|[
literal|0
index|]
index|[
name|jj
index|]
argument_list|,
name|powTableLXPD
index|[
name|kk
index|]
index|[
name|jj
index|]
argument_list|)
expr_stmt|;
name|pwr_table1
index|[
name|jj
index|]
operator|=
name|interpolate_signed
argument_list|(
name|freq
argument_list|,
name|chan_L
argument_list|,
name|chan_R
argument_list|,
name|powTableHXPD
index|[
literal|0
index|]
index|[
name|jj
index|]
argument_list|,
name|powTableHXPD
index|[
name|kk
index|]
index|[
name|jj
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numXpdGain
operator|==
literal|2
condition|)
block|{
name|Pmin
operator|=
name|getPminAndPcdacTableFromTwoPowerTables
argument_list|(
operator|&
name|pwr_table0
index|[
literal|0
index|]
argument_list|,
operator|&
name|pwr_table1
index|[
literal|0
index|]
argument_list|,
name|ahp
operator|->
name|ah_pcdacTable
argument_list|,
operator|&
name|Pmid
argument_list|)
expr_stmt|;
operator|*
name|pPowerMin
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|Pmin
operator|/
literal|2
argument_list|)
expr_stmt|;
operator|*
name|pPowerMid
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|Pmid
operator|/
literal|2
argument_list|)
expr_stmt|;
operator|*
name|pPowerMax
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|pwr_table0
index|[
literal|63
index|]
operator|/
literal|2
argument_list|)
expr_stmt|;
name|rfXpdGain
index|[
literal|0
index|]
operator|=
name|xgainList
index|[
literal|0
index|]
expr_stmt|;
name|rfXpdGain
index|[
literal|1
index|]
operator|=
name|xgainList
index|[
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minPwr_t4
operator|<=
name|pwr_table1
index|[
literal|63
index|]
operator|&&
name|maxPwr_t4
operator|<=
name|pwr_table1
index|[
literal|63
index|]
condition|)
block|{
name|Pmin
operator|=
name|getPminAndPcdacTableFromPowerTable
argument_list|(
operator|&
name|pwr_table1
index|[
literal|0
index|]
argument_list|,
name|ahp
operator|->
name|ah_pcdacTable
argument_list|)
expr_stmt|;
name|rfXpdGain
index|[
literal|0
index|]
operator|=
name|xgainList
index|[
literal|1
index|]
expr_stmt|;
name|rfXpdGain
index|[
literal|1
index|]
operator|=
name|rfXpdGain
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|pPowerMin
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|Pmin
operator|/
literal|2
argument_list|)
expr_stmt|;
operator|*
name|pPowerMid
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|pwr_table1
index|[
literal|63
index|]
operator|/
literal|2
argument_list|)
expr_stmt|;
operator|*
name|pPowerMax
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|pwr_table1
index|[
literal|63
index|]
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Pmin
operator|=
name|getPminAndPcdacTableFromPowerTable
argument_list|(
operator|&
name|pwr_table0
index|[
literal|0
index|]
argument_list|,
name|ahp
operator|->
name|ah_pcdacTable
argument_list|)
expr_stmt|;
name|rfXpdGain
index|[
literal|0
index|]
operator|=
name|xgainList
index|[
literal|0
index|]
expr_stmt|;
name|rfXpdGain
index|[
literal|1
index|]
operator|=
name|rfXpdGain
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|pPowerMin
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|Pmin
operator|/
literal|2
argument_list|)
expr_stmt|;
operator|*
name|pPowerMid
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|pwr_table0
index|[
literal|63
index|]
operator|/
literal|2
argument_list|)
expr_stmt|;
operator|*
name|pPowerMax
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|pwr_table0
index|[
literal|63
index|]
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Move 5112 rates to match power tables where the max 	 * power table entry corresponds with maxPower. 	 */
name|HALASSERT
argument_list|(
operator|*
name|pPowerMax
operator|<=
name|PCDAC_STOP
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_txPowerIndexOffset
operator|=
name|PCDAC_STOP
operator|-
operator|*
name|pPowerMax
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Returns interpolated or the scaled up interpolated value  */
end_comment

begin_function
specifier|static
name|int16_t
name|interpolate_signed
parameter_list|(
name|uint16_t
name|target
parameter_list|,
name|uint16_t
name|srcLeft
parameter_list|,
name|uint16_t
name|srcRight
parameter_list|,
name|int16_t
name|targetLeft
parameter_list|,
name|int16_t
name|targetRight
parameter_list|)
block|{
name|int16_t
name|rv
decl_stmt|;
if|if
condition|(
name|srcRight
operator|!=
name|srcLeft
condition|)
block|{
name|rv
operator|=
operator|(
operator|(
name|target
operator|-
name|srcLeft
operator|)
operator|*
name|targetRight
operator|+
operator|(
name|srcRight
operator|-
name|target
operator|)
operator|*
name|targetLeft
operator|)
operator|/
operator|(
name|srcRight
operator|-
name|srcLeft
operator|)
expr_stmt|;
block|}
else|else
block|{
name|rv
operator|=
name|targetLeft
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/*  * Return indices surrounding the value in sorted integer lists.  *  * NB: the input list is assumed to be sorted in ascending order  */
end_comment

begin_function
specifier|static
name|void
name|ar5212GetLowerUpperIndex
parameter_list|(
name|uint16_t
name|v
parameter_list|,
name|uint16_t
modifier|*
name|lp
parameter_list|,
name|uint16_t
name|listSize
parameter_list|,
name|uint32_t
modifier|*
name|vlo
parameter_list|,
name|uint32_t
modifier|*
name|vhi
parameter_list|)
block|{
name|uint32_t
name|target
init|=
name|v
decl_stmt|;
name|uint16_t
modifier|*
name|ep
init|=
name|lp
operator|+
name|listSize
decl_stmt|;
name|uint16_t
modifier|*
name|tp
decl_stmt|;
comment|/* 	 * Check first and last elements for out-of-bounds conditions. 	 */
if|if
condition|(
name|target
operator|<
name|lp
index|[
literal|0
index|]
condition|)
block|{
operator|*
name|vlo
operator|=
operator|*
name|vhi
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|target
operator|>=
name|ep
index|[
operator|-
literal|1
index|]
condition|)
block|{
operator|*
name|vlo
operator|=
operator|*
name|vhi
operator|=
name|listSize
operator|-
literal|1
expr_stmt|;
return|return;
block|}
comment|/* look for value being near or between 2 values in list */
for|for
control|(
name|tp
operator|=
name|lp
init|;
name|tp
operator|<
name|ep
condition|;
name|tp
operator|++
control|)
block|{
comment|/* 		 * If value is close to the current value of the list 		 * then target is not between values, it is one of the values 		 */
if|if
condition|(
operator|*
name|tp
operator|==
name|target
condition|)
block|{
operator|*
name|vlo
operator|=
operator|*
name|vhi
operator|=
name|tp
operator|-
name|lp
expr_stmt|;
return|return;
block|}
comment|/* 		 * Look for value being between current value and next value 		 * if so return these 2 values 		 */
if|if
condition|(
name|target
operator|<
name|tp
index|[
literal|1
index|]
condition|)
block|{
operator|*
name|vlo
operator|=
name|tp
operator|-
name|lp
expr_stmt|;
operator|*
name|vhi
operator|=
operator|*
name|vlo
operator|+
literal|1
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|getFullPwrTable
parameter_list|(
name|uint16_t
name|numPcdacs
parameter_list|,
name|uint16_t
modifier|*
name|pcdacs
parameter_list|,
name|int16_t
modifier|*
name|power
parameter_list|,
name|int16_t
name|maxPower
parameter_list|,
name|int16_t
modifier|*
name|retVals
parameter_list|)
block|{
name|uint16_t
name|ii
decl_stmt|;
name|uint16_t
name|idxL
init|=
literal|0
decl_stmt|;
name|uint16_t
name|idxR
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|numPcdacs
operator|<
literal|2
condition|)
block|{
name|HALDEBUG_G
argument_list|(
name|AH_NULL
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: at least 2 pcdac values needed [%d]\n"
argument_list|,
name|__func__
argument_list|,
name|numPcdacs
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
literal|64
condition|;
name|ii
operator|++
control|)
block|{
if|if
condition|(
name|ii
operator|>
name|pcdacs
index|[
name|idxR
index|]
operator|&&
name|idxR
operator|<
name|numPcdacs
operator|-
literal|1
condition|)
block|{
name|idxL
operator|++
expr_stmt|;
name|idxR
operator|++
expr_stmt|;
block|}
name|retVals
index|[
name|ii
index|]
operator|=
name|interpolate_signed
argument_list|(
name|ii
argument_list|,
name|pcdacs
index|[
name|idxL
index|]
argument_list|,
name|pcdacs
index|[
name|idxR
index|]
argument_list|,
name|power
index|[
name|idxL
index|]
argument_list|,
name|power
index|[
name|idxR
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retVals
index|[
name|ii
index|]
operator|>=
name|maxPower
condition|)
block|{
while|while
condition|(
name|ii
operator|<
literal|64
condition|)
name|retVals
index|[
name|ii
operator|++
index|]
operator|=
name|maxPower
expr_stmt|;
block|}
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Takes a single calibration curve and creates a power table.  * Adjusts the new power table so the max power is relative  * to the maximum index in the power table.  *  * WARNING: rates must be adjusted for this relative power table  */
end_comment

begin_function
specifier|static
name|int16_t
name|getPminAndPcdacTableFromPowerTable
parameter_list|(
name|int16_t
modifier|*
name|pwrTableT4
parameter_list|,
name|uint16_t
name|retVals
index|[]
parameter_list|)
block|{
name|int16_t
name|ii
decl_stmt|,
name|jj
decl_stmt|,
name|jjMax
decl_stmt|;
name|int16_t
name|pMin
decl_stmt|,
name|currPower
decl_stmt|,
name|pMax
decl_stmt|;
comment|/* If the spread is> 31.5dB, keep the upper 31.5dB range */
if|if
condition|(
operator|(
name|pwrTableT4
index|[
literal|63
index|]
operator|-
name|pwrTableT4
index|[
literal|0
index|]
operator|)
operator|>
literal|126
condition|)
block|{
name|pMin
operator|=
name|pwrTableT4
index|[
literal|63
index|]
operator|-
literal|126
expr_stmt|;
block|}
else|else
block|{
name|pMin
operator|=
name|pwrTableT4
index|[
literal|0
index|]
expr_stmt|;
block|}
name|pMax
operator|=
name|pwrTableT4
index|[
literal|63
index|]
expr_stmt|;
name|jjMax
operator|=
literal|63
expr_stmt|;
comment|/* Search for highest pcdac 0.25dB below maxPower */
while|while
condition|(
operator|(
name|pwrTableT4
index|[
name|jjMax
index|]
operator|>
operator|(
name|pMax
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|jjMax
operator|>=
literal|0
operator|)
condition|)
block|{
name|jjMax
operator|--
expr_stmt|;
block|}
name|jj
operator|=
name|jjMax
expr_stmt|;
name|currPower
operator|=
name|pMax
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|63
init|;
name|ii
operator|>=
literal|0
condition|;
name|ii
operator|--
control|)
block|{
while|while
condition|(
operator|(
name|jj
operator|<
literal|64
operator|)
operator|&&
operator|(
name|jj
operator|>
literal|0
operator|)
operator|&&
operator|(
name|pwrTableT4
index|[
name|jj
index|]
operator|>=
name|currPower
operator|)
condition|)
block|{
name|jj
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|jj
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|ii
operator|>=
literal|0
condition|)
block|{
name|retVals
index|[
name|ii
index|]
operator|=
name|retVals
index|[
name|ii
operator|+
literal|1
index|]
expr_stmt|;
name|ii
operator|--
expr_stmt|;
block|}
break|break;
block|}
name|retVals
index|[
name|ii
index|]
operator|=
name|jj
expr_stmt|;
name|currPower
operator|-=
literal|2
expr_stmt|;
comment|// corresponds to a 0.5dB step
block|}
return|return
name|pMin
return|;
block|}
end_function

begin_comment
comment|/*  * Combines the XPD curves from two calibration sets into a single  * power table and adjusts the power table so the max power is relative  * to the maximum index in the power table  *  * WARNING: rates must be adjusted for this relative power table  */
end_comment

begin_function
specifier|static
name|int16_t
name|getPminAndPcdacTableFromTwoPowerTables
parameter_list|(
name|int16_t
modifier|*
name|pwrTableLXpdT4
parameter_list|,
name|int16_t
modifier|*
name|pwrTableHXpdT4
parameter_list|,
name|uint16_t
name|retVals
index|[]
parameter_list|,
name|int16_t
modifier|*
name|pMid
parameter_list|)
block|{
name|int16_t
name|ii
decl_stmt|,
name|jj
decl_stmt|,
name|jjMax
decl_stmt|;
name|int16_t
name|pMin
decl_stmt|,
name|pMax
decl_stmt|,
name|currPower
decl_stmt|;
name|int16_t
modifier|*
name|pwrTableT4
decl_stmt|;
name|uint16_t
name|msbFlag
init|=
literal|0x40
decl_stmt|;
comment|// turns on the 7th bit of the pcdac
comment|/* If the spread is> 31.5dB, keep the upper 31.5dB range */
if|if
condition|(
operator|(
name|pwrTableLXpdT4
index|[
literal|63
index|]
operator|-
name|pwrTableHXpdT4
index|[
literal|0
index|]
operator|)
operator|>
literal|126
condition|)
block|{
name|pMin
operator|=
name|pwrTableLXpdT4
index|[
literal|63
index|]
operator|-
literal|126
expr_stmt|;
block|}
else|else
block|{
name|pMin
operator|=
name|pwrTableHXpdT4
index|[
literal|0
index|]
expr_stmt|;
block|}
name|pMax
operator|=
name|pwrTableLXpdT4
index|[
literal|63
index|]
expr_stmt|;
name|jjMax
operator|=
literal|63
expr_stmt|;
comment|/* Search for highest pcdac 0.25dB below maxPower */
while|while
condition|(
operator|(
name|pwrTableLXpdT4
index|[
name|jjMax
index|]
operator|>
operator|(
name|pMax
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|jjMax
operator|>=
literal|0
operator|)
condition|)
block|{
name|jjMax
operator|--
expr_stmt|;
block|}
operator|*
name|pMid
operator|=
name|pwrTableHXpdT4
index|[
literal|63
index|]
expr_stmt|;
name|jj
operator|=
name|jjMax
expr_stmt|;
name|ii
operator|=
literal|63
expr_stmt|;
name|currPower
operator|=
name|pMax
expr_stmt|;
name|pwrTableT4
operator|=
operator|&
operator|(
name|pwrTableLXpdT4
index|[
literal|0
index|]
operator|)
expr_stmt|;
while|while
condition|(
name|ii
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|currPower
operator|<=
operator|*
name|pMid
operator|)
operator|||
operator|(
operator|(
name|jj
operator|==
literal|0
operator|)
operator|&&
operator|(
name|msbFlag
operator|==
literal|0x40
operator|)
operator|)
condition|)
block|{
name|msbFlag
operator|=
literal|0x00
expr_stmt|;
name|pwrTableT4
operator|=
operator|&
operator|(
name|pwrTableHXpdT4
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|jj
operator|=
literal|63
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|jj
operator|>
literal|0
operator|)
operator|&&
operator|(
name|pwrTableT4
index|[
name|jj
index|]
operator|>=
name|currPower
operator|)
condition|)
block|{
name|jj
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|jj
operator|==
literal|0
operator|)
operator|&&
operator|(
name|msbFlag
operator|==
literal|0x00
operator|)
condition|)
block|{
while|while
condition|(
name|ii
operator|>=
literal|0
condition|)
block|{
name|retVals
index|[
name|ii
index|]
operator|=
name|retVals
index|[
name|ii
operator|+
literal|1
index|]
expr_stmt|;
name|ii
operator|--
expr_stmt|;
block|}
break|break;
block|}
name|retVals
index|[
name|ii
index|]
operator|=
name|jj
operator||
name|msbFlag
expr_stmt|;
name|currPower
operator|-=
literal|2
expr_stmt|;
comment|// corresponds to a 0.5dB step
name|ii
operator|--
expr_stmt|;
block|}
return|return
name|pMin
return|;
block|}
end_function

begin_function
specifier|static
name|int16_t
name|ar5112GetMinPower
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|EXPN_DATA_PER_CHANNEL_5112
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|minIndex
decl_stmt|;
name|int16_t
name|minGain
decl_stmt|,
name|minPwr
decl_stmt|,
name|minPcdac
decl_stmt|,
name|retVal
decl_stmt|;
comment|/* Assume NUM_POINTS_XPD0> 0 */
name|minGain
operator|=
name|data
operator|->
name|pDataPerXPD
index|[
literal|0
index|]
operator|.
name|xpd_gain
expr_stmt|;
for|for
control|(
name|minIndex
operator|=
literal|0
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NUM_XPD_PER_CHANNEL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
operator|->
name|pDataPerXPD
index|[
name|i
index|]
operator|.
name|xpd_gain
operator|<
name|minGain
condition|)
block|{
name|minIndex
operator|=
name|i
expr_stmt|;
name|minGain
operator|=
name|data
operator|->
name|pDataPerXPD
index|[
name|i
index|]
operator|.
name|xpd_gain
expr_stmt|;
block|}
block|}
name|minPwr
operator|=
name|data
operator|->
name|pDataPerXPD
index|[
name|minIndex
index|]
operator|.
name|pwr_t4
index|[
literal|0
index|]
expr_stmt|;
name|minPcdac
operator|=
name|data
operator|->
name|pDataPerXPD
index|[
name|minIndex
index|]
operator|.
name|pcdac
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NUM_POINTS_XPD0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
operator|->
name|pDataPerXPD
index|[
name|minIndex
index|]
operator|.
name|pwr_t4
index|[
name|i
index|]
operator|<
name|minPwr
condition|)
block|{
name|minPwr
operator|=
name|data
operator|->
name|pDataPerXPD
index|[
name|minIndex
index|]
operator|.
name|pwr_t4
index|[
name|i
index|]
expr_stmt|;
name|minPcdac
operator|=
name|data
operator|->
name|pDataPerXPD
index|[
name|minIndex
index|]
operator|.
name|pcdac
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|retVal
operator|=
name|minPwr
operator|-
operator|(
name|minPcdac
operator|*
literal|2
operator|)
expr_stmt|;
return|return
operator|(
name|retVal
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|ar5112GetChannelMaxMinPower
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|int16_t
modifier|*
name|maxPow
parameter_list|,
name|int16_t
modifier|*
name|minPow
parameter_list|)
block|{
name|uint16_t
name|freq
init|=
name|chan
operator|->
name|ic_freq
decl_stmt|;
comment|/* NB: never mapped */
specifier|const
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|int
name|numChannels
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|last
decl_stmt|;
name|int
name|totalD
decl_stmt|,
name|totalF
decl_stmt|,
name|totalMin
decl_stmt|;
specifier|const
name|EXPN_DATA_PER_CHANNEL_5112
modifier|*
name|data
init|=
name|AH_NULL
decl_stmt|;
specifier|const
name|EEPROM_POWER_EXPN_5112
modifier|*
name|powerArray
init|=
name|AH_NULL
decl_stmt|;
operator|*
name|maxPow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|powerArray
operator|=
name|ee
operator|->
name|ee_modePowerArray5112
expr_stmt|;
name|data
operator|=
name|powerArray
index|[
name|headerInfo11A
index|]
operator|.
name|pDataPerChannel
expr_stmt|;
name|numChannels
operator|=
name|powerArray
index|[
name|headerInfo11A
index|]
operator|.
name|numChannels
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_G
argument_list|(
name|chan
argument_list|)
operator|||
name|IEEE80211_IS_CHAN_108G
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* XXX - is this correct? Should we also use the same power for turbo G? */
name|powerArray
operator|=
name|ee
operator|->
name|ee_modePowerArray5112
expr_stmt|;
name|data
operator|=
name|powerArray
index|[
name|headerInfo11G
index|]
operator|.
name|pDataPerChannel
expr_stmt|;
name|numChannels
operator|=
name|powerArray
index|[
name|headerInfo11G
index|]
operator|.
name|numChannels
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|powerArray
operator|=
name|ee
operator|->
name|ee_modePowerArray5112
expr_stmt|;
name|data
operator|=
name|powerArray
index|[
name|headerInfo11B
index|]
operator|.
name|pDataPerChannel
expr_stmt|;
name|numChannels
operator|=
name|powerArray
index|[
name|headerInfo11B
index|]
operator|.
name|numChannels
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|AH_TRUE
operator|)
return|;
block|}
comment|/* Make sure the channel is in the range of the TP values  	 *  (freq piers) 	 */
if|if
condition|(
name|numChannels
operator|<
literal|1
condition|)
return|return
operator|(
name|AH_FALSE
operator|)
return|;
if|if
condition|(
operator|(
name|freq
operator|<
name|data
index|[
literal|0
index|]
operator|.
name|channelValue
operator|)
operator|||
operator|(
name|freq
operator|>
name|data
index|[
name|numChannels
operator|-
literal|1
index|]
operator|.
name|channelValue
operator|)
condition|)
block|{
if|if
condition|(
name|freq
operator|<
name|data
index|[
literal|0
index|]
operator|.
name|channelValue
condition|)
block|{
operator|*
name|maxPow
operator|=
name|data
index|[
literal|0
index|]
operator|.
name|maxPower_t4
expr_stmt|;
operator|*
name|minPow
operator|=
name|ar5112GetMinPower
argument_list|(
name|ah
argument_list|,
operator|&
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|AH_TRUE
operator|)
return|;
block|}
else|else
block|{
operator|*
name|maxPow
operator|=
name|data
index|[
name|numChannels
operator|-
literal|1
index|]
operator|.
name|maxPower_t4
expr_stmt|;
operator|*
name|minPow
operator|=
name|ar5112GetMinPower
argument_list|(
name|ah
argument_list|,
operator|&
name|data
index|[
name|numChannels
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|AH_TRUE
operator|)
return|;
block|}
block|}
comment|/* Linearly interpolate the power value now */
for|for
control|(
name|last
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|numChannels
operator|)
operator|&&
operator|(
name|freq
operator|>
name|data
index|[
name|i
index|]
operator|.
name|channelValue
operator|)
condition|;
name|last
operator|=
name|i
operator|++
control|)
empty_stmt|;
name|totalD
operator|=
name|data
index|[
name|i
index|]
operator|.
name|channelValue
operator|-
name|data
index|[
name|last
index|]
operator|.
name|channelValue
expr_stmt|;
if|if
condition|(
name|totalD
operator|>
literal|0
condition|)
block|{
name|totalF
operator|=
name|data
index|[
name|i
index|]
operator|.
name|maxPower_t4
operator|-
name|data
index|[
name|last
index|]
operator|.
name|maxPower_t4
expr_stmt|;
operator|*
name|maxPow
operator|=
call|(
name|int8_t
call|)
argument_list|(
operator|(
name|totalF
operator|*
operator|(
name|freq
operator|-
name|data
index|[
name|last
index|]
operator|.
name|channelValue
operator|)
operator|+
name|data
index|[
name|last
index|]
operator|.
name|maxPower_t4
operator|*
name|totalD
operator|)
operator|/
name|totalD
argument_list|)
expr_stmt|;
name|totalMin
operator|=
name|ar5112GetMinPower
argument_list|(
name|ah
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
operator|-
name|ar5112GetMinPower
argument_list|(
name|ah
argument_list|,
operator|&
name|data
index|[
name|last
index|]
argument_list|)
expr_stmt|;
operator|*
name|minPow
operator|=
call|(
name|int8_t
call|)
argument_list|(
operator|(
name|totalMin
operator|*
operator|(
name|freq
operator|-
name|data
index|[
name|last
index|]
operator|.
name|channelValue
operator|)
operator|+
name|ar5112GetMinPower
argument_list|(
name|ah
argument_list|,
operator|&
name|data
index|[
name|last
index|]
argument_list|)
operator|*
name|totalD
operator|)
operator|/
name|totalD
argument_list|)
expr_stmt|;
return|return
operator|(
name|AH_TRUE
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|freq
operator|==
name|data
index|[
name|i
index|]
operator|.
name|channelValue
condition|)
block|{
operator|*
name|maxPow
operator|=
name|data
index|[
name|i
index|]
operator|.
name|maxPower_t4
expr_stmt|;
operator|*
name|minPow
operator|=
name|ar5112GetMinPower
argument_list|(
name|ah
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|AH_TRUE
operator|)
return|;
block|}
else|else
return|return
operator|(
name|AH_FALSE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Free memory for analog bank scratch buffers  */
end_comment

begin_function
specifier|static
name|void
name|ar5112RfDetach
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HALASSERT
argument_list|(
name|ahp
operator|->
name|ah_rfHal
operator|!=
name|AH_NULL
argument_list|)
expr_stmt|;
name|ath_hal_free
argument_list|(
name|ahp
operator|->
name|ah_rfHal
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_rfHal
operator|=
name|AH_NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate memory for analog bank scratch buffers  * Scratch Buffer will be reinitialized every reset so no need to zero now  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5112RfAttach
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar5112State
modifier|*
name|priv
decl_stmt|;
name|HALASSERT
argument_list|(
name|ah
operator|->
name|ah_magic
operator|==
name|AR5212_MAGIC
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|ahp
operator|->
name|ah_rfHal
operator|==
name|AH_NULL
argument_list|)
expr_stmt|;
name|priv
operator|=
name|ath_hal_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ar5112State
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: cannot allocate private state\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|HAL_ENOMEM
expr_stmt|;
comment|/* XXX */
return|return
name|AH_FALSE
return|;
block|}
name|priv
operator|->
name|base
operator|.
name|rfDetach
operator|=
name|ar5112RfDetach
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|writeRegs
operator|=
name|ar5112WriteRegs
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|getRfBank
operator|=
name|ar5112GetRfBank
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|setChannel
operator|=
name|ar5112SetChannel
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|setRfRegs
operator|=
name|ar5112SetRfRegs
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|setPowerTable
operator|=
name|ar5112SetPowerTable
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|getChannelMaxMinPower
operator|=
name|ar5112GetChannelMaxMinPower
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|getNfAdjust
operator|=
name|ar5212GetNfAdjust
expr_stmt|;
name|ahp
operator|->
name|ah_pcdacTable
operator|=
name|priv
operator|->
name|pcdacTable
expr_stmt|;
name|ahp
operator|->
name|ah_pcdacTableSize
operator|=
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|pcdacTable
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_rfHal
operator|=
operator|&
name|priv
operator|->
name|base
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|ar5112Probe
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|IS_RAD5112
argument_list|(
name|ah
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|AH_RF
argument_list|(
name|RF5112
argument_list|,
name|ar5112Probe
argument_list|,
name|ar5112RfAttach
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

