begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2002-2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_devid.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212phy.h"
end_include

begin_include
include|#
directive|include
file|"ah_eeprom_v3.h"
end_include

begin_comment
comment|/* Additional Time delay to wait after activiting the Base band */
end_comment

begin_define
define|#
directive|define
name|BASE_ACTIVATE_DELAY
value|100
end_define

begin_comment
comment|/* 100 usec */
end_comment

begin_define
define|#
directive|define
name|PLL_SETTLE_DELAY
value|300
end_define

begin_comment
comment|/* 300 usec */
end_comment

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5212SetResetReg
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|uint32_t
name|resetMask
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* NB: public for 5312 use */
end_comment

begin_function_decl
name|HAL_BOOL
name|ar5212IsSpurChannel
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|HAL_BOOL
name|ar5212ChannelChange
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int16_t
name|ar5212GetNf
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|HAL_BOOL
name|ar5212SetBoardValues
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ar5212SetDeltaSlope
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|HAL_BOOL
name|ar5212SetTransmitPower
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|uint16_t
modifier|*
name|rfXpdGain
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5212SetRateTable
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
parameter_list|,
name|int16_t
name|tpcScaleReduction
parameter_list|,
name|int16_t
name|powerLimit
parameter_list|,
name|HAL_BOOL
name|commit
parameter_list|,
name|int16_t
modifier|*
name|minPower
parameter_list|,
name|int16_t
modifier|*
name|maxPower
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5212CorrectGainDelta
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|int
name|twiceOfdmCckDelta
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5212GetTargetPowers
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
parameter_list|,
specifier|const
name|TRGT_POWER_INFO
modifier|*
name|pPowerInfo
parameter_list|,
name|uint16_t
name|numChannels
parameter_list|,
name|TRGT_POWER_INFO
modifier|*
name|pNewPower
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|ar5212GetMaxEdgePower
parameter_list|(
name|uint16_t
name|channel
parameter_list|,
specifier|const
name|RD_EDGES_POWER
modifier|*
name|pRdEdgesPower
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ar5212SetRateDurationTable
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ar5212SetIFSTiming
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* NB: public for RF backend use */
end_comment

begin_function_decl
name|void
name|ar5212GetLowerUpperValues
parameter_list|(
name|uint16_t
name|value
parameter_list|,
name|uint16_t
modifier|*
name|pList
parameter_list|,
name|uint16_t
name|listSize
parameter_list|,
name|uint16_t
modifier|*
name|pLowerValue
parameter_list|,
name|uint16_t
modifier|*
name|pUpperValue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ar5212ModifyRfBuffer
parameter_list|(
name|uint32_t
modifier|*
name|rfBuf
parameter_list|,
name|uint32_t
name|reg32
parameter_list|,
name|uint32_t
name|numBits
parameter_list|,
name|uint32_t
name|firstBit
parameter_list|,
name|uint32_t
name|column
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|write_common
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_INI_ARRAY
modifier|*
name|ia
parameter_list|,
name|HAL_BOOL
name|bChannelChange
parameter_list|,
name|int
name|writes
parameter_list|)
block|{
define|#
directive|define
name|IS_NO_RESET_TIMER_ADDR
parameter_list|(
name|x
parameter_list|)
define|\
value|( (((x)>= AR_BEACON)&& ((x)<= AR_CFP_DUR)) || \       (((x)>= AR_SLEEP1)&& ((x)<= AR_SLEEP3)))
define|#
directive|define
name|V
parameter_list|(
name|r
parameter_list|,
name|c
parameter_list|)
value|(ia)->data[((r)*(ia)->cols) + (c)]
name|int
name|r
decl_stmt|;
comment|/* Write Common Array Parameters */
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|ia
operator|->
name|rows
condition|;
name|r
operator|++
control|)
block|{
name|uint32_t
name|reg
init|=
name|V
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* XXX timer/beacon setup registers? */
comment|/* On channel change, don't reset the PCU registers */
if|if
condition|(
operator|!
operator|(
name|bChannelChange
operator|&&
name|IS_NO_RESET_TIMER_ADDR
argument_list|(
name|reg
argument_list|)
operator|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|reg
argument_list|,
name|V
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|DMA_YIELD
argument_list|(
name|writes
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|writes
return|;
undef|#
directive|undef
name|IS_NO_RESET_TIMER_ADDR
undef|#
directive|undef
name|V
block|}
end_function

begin_define
define|#
directive|define
name|IS_DISABLE_FAST_ADC_CHAN
parameter_list|(
name|x
parameter_list|)
value|(((x) == 2462) || ((x) == 2467))
end_define

begin_comment
comment|/*  * XXX NDIS 5.x code had MAX_RESET_WAIT set to 2000 for AP code  * and 10 for Client code  */
end_comment

begin_define
define|#
directive|define
name|MAX_RESET_WAIT
value|10
end_define

begin_define
define|#
directive|define
name|TX_QUEUEPEND_CHECK
value|1
end_define

begin_define
define|#
directive|define
name|TX_ENABLE_CHECK
value|2
end_define

begin_define
define|#
directive|define
name|RX_ENABLE_CHECK
value|4
end_define

begin_comment
comment|/*  * Places the device in and out of reset and then places sane  * values in the registers based on EEPROM config, initialization  * vectors (as determined by the mode), and station configuration  *  * bChannelChange is used to preserve DMA/PCU registers across  * a HW Reset during channel change.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212Reset
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_OPMODE
name|opmode
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|HAL_BOOL
name|bChannelChange
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) / sizeof (a[0]))
define|#
directive|define
name|FAIL
parameter_list|(
name|_code
parameter_list|)
value|do { ecode = _code; goto bad; } while (0)
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
init|=
name|AH_NULL
decl_stmt|;
specifier|const
name|HAL_EEPROM
modifier|*
name|ee
decl_stmt|;
name|uint32_t
name|softLedCfg
decl_stmt|,
name|softLedState
decl_stmt|;
name|uint32_t
name|saveFrameSeqCount
decl_stmt|,
name|saveDefAntenna
decl_stmt|,
name|saveLedState
decl_stmt|;
name|uint32_t
name|macStaId1
decl_stmt|,
name|synthDelay
decl_stmt|,
name|txFrm2TxDStart
decl_stmt|;
name|uint16_t
name|rfXpdGain
index|[
name|MAX_NUM_PDGAINS_PER_CHANNEL
index|]
decl_stmt|;
name|int16_t
name|cckOfdmPwrDelta
init|=
literal|0
decl_stmt|;
name|u_int
name|modesIndex
decl_stmt|,
name|freqIndex
decl_stmt|;
name|HAL_STATUS
name|ecode
decl_stmt|;
name|int
name|i
decl_stmt|,
name|regWrites
decl_stmt|;
name|uint32_t
name|testReg
decl_stmt|,
name|powerVal
decl_stmt|;
name|int8_t
name|twiceAntennaGain
decl_stmt|,
name|twiceAntennaReduction
decl_stmt|;
name|uint32_t
name|ackTpcPow
decl_stmt|,
name|ctsTpcPow
decl_stmt|,
name|chirpTpcPow
decl_stmt|;
name|HAL_BOOL
name|isBmode
init|=
name|AH_FALSE
decl_stmt|;
name|HALASSERT
argument_list|(
name|ah
operator|->
name|ah_magic
operator|==
name|AR5212_MAGIC
argument_list|)
expr_stmt|;
name|ee
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
expr_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET
argument_list|,
name|bChannelChange
argument_list|)
expr_stmt|;
comment|/* Bring out of sleep mode */
if|if
condition|(
operator|!
name|ar5212SetPowerMode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: chip did not wakeup\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Map public channel to private. 	 */
name|ichan
operator|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ichan
operator|==
name|AH_NULL
condition|)
name|FAIL
argument_list|(
name|HAL_EINVAL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opmode
condition|)
block|{
case|case
name|HAL_M_STA
case|:
case|case
name|HAL_M_IBSS
case|:
case|case
name|HAL_M_HOSTAP
case|:
case|case
name|HAL_M_MONITOR
case|:
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid operating mode %u\n"
argument_list|,
name|__func__
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EINVAL
argument_list|)
expr_stmt|;
break|break;
block|}
name|HALASSERT
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeversion
operator|>=
name|AR_EEPROM_VER3
argument_list|)
expr_stmt|;
name|SAVE_CCK
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|isBmode
argument_list|)
expr_stmt|;
comment|/* Preserve certain DMA hardware registers on a channel change */
if|if
condition|(
name|bChannelChange
condition|)
block|{
comment|/* 		 * On Venice, the TSF is almost preserved across a reset; 		 * it requires doubling writes to the RESET_TSF 		 * bit in the AR_BEACON register; it also has the quirk 		 * of the TSF going back in time on the station (station 		 * latches onto the last beacon's tsf during a reset 50% 		 * of the times); the latter is not a problem for adhoc 		 * stations since as long as the TSF is behind, it will 		 * get resynchronized on receiving the next beacon; the 		 * TSF going backwards in time could be a problem for the 		 * sleep operation (supported on infrastructure stations 		 * only) - the best and most general fix for this situation 		 * is to resynchronize the various sleep/beacon timers on 		 * the receipt of the next beacon i.e. when the TSF itself 		 * gets resynchronized to the AP's TSF - power save is 		 * needed to be temporarily disabled until that time 		 * 		 * Need to save the sequence number to restore it after 		 * the reset! 		 */
name|saveFrameSeqCount
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_D_SEQNUM
argument_list|)
expr_stmt|;
block|}
else|else
name|saveFrameSeqCount
operator|=
literal|0
expr_stmt|;
comment|/* NB: silence compiler */
comment|/* Blank the channel survey statistics */
name|OS_MEMZERO
argument_list|(
operator|&
name|ahp
operator|->
name|ah_chansurvey
argument_list|,
sizeof|sizeof
argument_list|(
name|ahp
operator|->
name|ah_chansurvey
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * XXX disable for now; this appears to sometimes cause OFDM 	 * XXX timing error floods when ani is enabled and bg scanning 	 * XXX kicks in 	 */
comment|/* If the channel change is across the same mode - perform a fast channel change */
block|if (IS_2413(ah) || IS_5413(ah)) {
comment|/* 		 * Fast channel change can only be used when: 		 *  -channel change requested - so it's not the initial reset. 		 *  -it's not a change to the current channel - 		 *	often called when switching modes on a channel 		 *  -the modes of the previous and requested channel are the 		 *	same 		 * XXX opmode shouldn't change either? 		 */
block|if (bChannelChange&& 		    (AH_PRIVATE(ah)->ah_curchan != AH_NULL)&& 		    (chan->ic_freq != AH_PRIVATE(ah)->ah_curchan->ic_freq)&& 		    ((chan->ic_flags& IEEE80211_CHAN_ALLTURBO) == 		     (AH_PRIVATE(ah)->ah_curchan->ic_flags& IEEE80211_CHAN_ALLTURBO))) { 			if (ar5212ChannelChange(ah, chan)) {
comment|/* If ChannelChange completed - skip the rest of reset */
comment|/* XXX ani? */
block|goto done; 			} 		} 	}
endif|#
directive|endif
comment|/* 	 * Preserve the antenna on a channel change 	 */
name|saveDefAntenna
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_DEF_ANTENNA
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveDefAntenna
operator|==
literal|0
condition|)
comment|/* XXX magic constants */
name|saveDefAntenna
operator|=
literal|1
expr_stmt|;
comment|/* Save hardware flag before chip reset clears the register */
name|macStaId1
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|)
operator|&
operator|(
name|AR_STA_ID1_BASE_RATE_11B
operator||
name|AR_STA_ID1_USE_DEFANT
operator|)
expr_stmt|;
comment|/* Save led state from pci config register */
name|saveLedState
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|)
operator|&
operator|(
name|AR_PCICFG_LEDCTL
operator||
name|AR_PCICFG_LEDMODE
operator||
name|AR_PCICFG_LEDBLINK
operator||
name|AR_PCICFG_LEDSLOW
operator|)
expr_stmt|;
name|softLedCfg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_GPIOCR
argument_list|)
expr_stmt|;
name|softLedState
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_GPIODO
argument_list|)
expr_stmt|;
name|ar5212RestoreClock
argument_list|(
name|ah
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
comment|/* move to refclk operation */
comment|/* 	 * Adjust gain parameters before reset if 	 * there's an outstanding gain updated. 	 */
operator|(
name|void
operator|)
name|ar5212GetRfgain
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar5212ChipReset
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: chip reset failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
comment|/* Setup the indices for the next set of register array writes */
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|freqIndex
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_108G
argument_list|(
name|chan
argument_list|)
condition|)
name|modesIndex
operator|=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_G
argument_list|(
name|chan
argument_list|)
condition|)
name|modesIndex
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|chan
argument_list|)
condition|)
name|modesIndex
operator|=
literal|3
expr_stmt|;
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel %u/0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EINVAL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|freqIndex
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
condition|)
name|modesIndex
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|chan
argument_list|)
condition|)
name|modesIndex
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel %u/0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EINVAL
argument_list|)
expr_stmt|;
block|}
block|}
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_LINE
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* Set correct Baseband to analog shift setting to access analog chips. */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0x00000007
argument_list|)
expr_stmt|;
name|regWrites
operator|=
name|ath_hal_ini_write
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_ini_modes
argument_list|,
name|modesIndex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regWrites
operator|=
name|write_common
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_ini_common
argument_list|,
name|bChannelChange
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AH_RXCFG_SDMAMW_4BYTES
comment|/* 	 * Nala doesn't work with 128 byte bursts on pb42(hydra) (ar71xx), 	 * use 4 instead.  Enabling it on all platforms would hurt performance, 	 * so we only enable it on the ones that are affected by it. 	 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RXCFG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ahp
operator|->
name|ah_rfHal
operator|->
name|writeRegs
argument_list|(
name|ah
argument_list|,
name|modesIndex
argument_list|,
name|freqIndex
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_LINE
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
operator|||
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|ar5212SetIFSTiming
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_5413
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* 			 * Force window_length for 1/2 and 1/4 rate channels, 			 * the ini file sets this to zero otherwise. 			 */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_FRAME_CTL
argument_list|,
name|AR_PHY_FRAME_CTL_WINLEN
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Overwrite INI values for revised chipsets */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyRev
operator|>=
name|AR_PHY_CHIP_ID_REV_2
condition|)
block|{
comment|/* ADC_CTL */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ADC_CTL
argument_list|,
name|SM
argument_list|(
literal|2
argument_list|,
name|AR_PHY_ADC_CTL_OFF_INBUFGAIN
argument_list|)
operator||
name|SM
argument_list|(
literal|2
argument_list|,
name|AR_PHY_ADC_CTL_ON_INBUFGAIN
argument_list|)
operator||
name|AR_PHY_ADC_CTL_OFF_PWDDAC
operator||
name|AR_PHY_ADC_CTL_OFF_PWDADC
argument_list|)
expr_stmt|;
comment|/* TX_PWR_ADJ */
if|if
condition|(
name|ichan
operator|->
name|channel
operator|==
literal|2484
condition|)
block|{
name|cckOfdmPwrDelta
operator|=
name|SCALE_OC_DELTA
argument_list|(
name|ee
operator|->
name|ee_cckOfdmPwrDelta
operator|-
name|ee
operator|->
name|ee_scaledCh14FilterCckDelta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cckOfdmPwrDelta
operator|=
name|SCALE_OC_DELTA
argument_list|(
name|ee
operator|->
name|ee_cckOfdmPwrDelta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_G
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TXPWRADJ
argument_list|,
name|SM
argument_list|(
operator|(
name|ee
operator|->
name|ee_cckOfdmPwrDelta
operator|*
operator|-
literal|1
operator|)
argument_list|,
name|AR_PHY_TXPWRADJ_CCK_GAIN_DELTA
argument_list|)
operator||
name|SM
argument_list|(
operator|(
name|cckOfdmPwrDelta
operator|*
operator|-
literal|1
operator|)
argument_list|,
name|AR_PHY_TXPWRADJ_CCK_PCDAC_INDEX
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TXPWRADJ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Add barker RSSI thresh enable as disabled */
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_DAG_CTRLCCK
argument_list|,
name|AR_PHY_DAG_CTRLCCK_EN_RSSI_THR
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_DAG_CTRLCCK
argument_list|,
name|AR_PHY_DAG_CTRLCCK_RSSI_THR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Set the mute mask to the correct default */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_SEQ_MASK
argument_list|,
literal|0x0000000F
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyRev
operator|>=
name|AR_PHY_CHIP_ID_REV_3
condition|)
block|{
comment|/* Clear reg to alllow RX_CLEAR line debug */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BLUETOOTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyRev
operator|>=
name|AR_PHY_CHIP_ID_REV_4
condition|)
block|{
ifdef|#
directive|ifdef
name|notyet
comment|/* Enable burst prefetch for the data queues */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_D_FPCTL
argument_list|,
operator|...
argument_list|)
expr_stmt|;
comment|/* Enable double-buffering */
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_TXCFG
argument_list|,
name|AR_TXCFG_DBL_BUF_DIS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Set ADC/DAC select values */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SLEEP_SCAL
argument_list|,
literal|0x0e
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_5413
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_2417
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|uint32_t
name|newReg
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|IS_DISABLE_FAST_ADC_CHAN
argument_list|(
name|ichan
operator|->
name|channel
argument_list|)
condition|)
name|newReg
operator|=
literal|0
expr_stmt|;
comment|/* As it's a clock changing register, only write when the value needs to be changed */
if|if
condition|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_FAST_ADC
argument_list|)
operator|!=
name|newReg
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_FAST_ADC
argument_list|,
name|newReg
argument_list|)
expr_stmt|;
block|}
comment|/* Setup the transmit power values. */
if|if
condition|(
operator|!
name|ar5212SetTransmitPower
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|rfXpdGain
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: error init'ing transmit power\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
comment|/* Write the analog registers */
if|if
condition|(
operator|!
name|ahp
operator|->
name|ah_rfHal
operator|->
name|setRfRegs
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|modesIndex
argument_list|,
name|rfXpdGain
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: ar5212SetRfRegs failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
comment|/* Write delta slope for OFDM enabled modes (A, G, Turbo) */
if|if
condition|(
name|IEEE80211_IS_CHAN_OFDM
argument_list|(
name|chan
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_5413
argument_list|(
name|ah
argument_list|)
operator|||
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeversion
operator|>=
name|AR_EEPROM_VER5_3
condition|)
name|ar5212SetSpurMitigation
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|ar5212SetDeltaSlope
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
comment|/* Setup board specific options for EEPROM version 3 */
if|if
condition|(
operator|!
name|ar5212SetBoardValues
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: error setting board options\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
comment|/* Restore certain DMA hardware registers on a channel change */
if|if
condition|(
name|bChannelChange
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_D_SEQNUM
argument_list|,
name|saveFrameSeqCount
argument_list|)
expr_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_LINE
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID0
argument_list|,
name|LE_READ_4
argument_list|(
name|ahp
operator|->
name|ah_macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|LE_READ_2
argument_list|(
name|ahp
operator|->
name|ah_macaddr
operator|+
literal|4
argument_list|)
operator||
name|macStaId1
operator||
name|AR_STA_ID1_RTS_USE_DEF
operator||
name|ahp
operator|->
name|ah_staId1Defaults
argument_list|)
expr_stmt|;
name|ar5212SetOperatingMode
argument_list|(
name|ah
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
comment|/* Set Venice BSSID mask according to current state */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSSMSKL
argument_list|,
name|LE_READ_4
argument_list|(
name|ahp
operator|->
name|ah_bssidmask
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSSMSKU
argument_list|,
name|LE_READ_2
argument_list|(
name|ahp
operator|->
name|ah_bssidmask
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore previous led state */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|)
operator||
name|saveLedState
argument_list|)
expr_stmt|;
comment|/* Restore soft Led state to GPIO */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_GPIOCR
argument_list|,
name|softLedCfg
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_GPIODO
argument_list|,
name|softLedState
argument_list|)
expr_stmt|;
comment|/* Restore previous antenna */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DEF_ANTENNA
argument_list|,
name|saveDefAntenna
argument_list|)
expr_stmt|;
comment|/* then our BSSID and associate id */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSS_ID0
argument_list|,
name|LE_READ_4
argument_list|(
name|ahp
operator|->
name|ah_bssid
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSS_ID1
argument_list|,
name|LE_READ_2
argument_list|(
name|ahp
operator|->
name|ah_bssid
operator|+
literal|4
argument_list|)
operator||
operator|(
name|ahp
operator|->
name|ah_assocId
operator|&
literal|0x3fff
operator|)
operator|<<
name|AR_BSS_ID1_AID_S
argument_list|)
expr_stmt|;
comment|/* Restore bmiss rssi& count thresholds */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RSSI_THR
argument_list|,
name|ahp
operator|->
name|ah_rssiThr
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_ISR
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
comment|/* cleared on write */
if|if
condition|(
operator|!
name|ar5212SetChannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_LINE
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|ar5212SetCoverageClass
argument_list|(
name|ah
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_coverageClass
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ar5212SetRateDurationTable
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* Set Tx frame start to tx data start delay */
if|if
condition|(
name|IS_RAD5112_ANY
argument_list|(
name|ah
argument_list|)
operator|&&
operator|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
operator|||
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|chan
argument_list|)
operator|)
condition|)
block|{
name|txFrm2TxDStart
operator|=
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
condition|?
name|TX_FRAME_D_START_HALF_RATE
else|:
name|TX_FRAME_D_START_QUARTER_RATE
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_CTL
argument_list|,
name|AR_PHY_TX_FRAME_TO_TX_DATA_START
argument_list|,
name|txFrm2TxDStart
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Setup fast diversity. 	 * Fast diversity can be enabled or disabled via regadd.txt. 	 * Default is enabled. 	 * For reference, 	 *    Disable: reg        val 	 *             0x00009860 0x00009d18 (if 11a / 11g, else no change) 	 *             0x00009970 0x192bb514 	 *             0x0000a208 0xd03e4648 	 * 	 *    Enable:  0x00009860 0x00009d10 (if 11a / 11g, else no change) 	 *             0x00009970 0x192fb514 	 *             0x0000a208 0xd03e6788 	 */
comment|/* XXX Setup pre PHY ENABLE EAR additions */
comment|/* 	 * Wait for the frequency synth to settle (synth goes on 	 * via AR_PHY_ACTIVE_EN).  Read the phy active delay register. 	 * Value is in 100ns increments. 	 */
name|synthDelay
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RX_DELAY
argument_list|)
operator|&
name|AR_PHY_RX_DELAY_DELAY
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|synthDelay
operator|=
operator|(
literal|4
operator|*
name|synthDelay
operator|)
operator|/
literal|22
expr_stmt|;
block|}
else|else
block|{
name|synthDelay
operator|/=
literal|10
expr_stmt|;
block|}
comment|/* Activate the PHY (includes baseband activate and synthesizer on) */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ACTIVE
argument_list|,
name|AR_PHY_ACTIVE_EN
argument_list|)
expr_stmt|;
comment|/*  	 * There is an issue if the AP starts the calibration before 	 * the base band timeout completes.  This could result in the 	 * rx_clear false triggering.  As a workaround we add delay an 	 * extra BASE_ACTIVATE_DELAY usecs to ensure this condition 	 * does not happen. 	 */
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|OS_DELAY
argument_list|(
operator|(
name|synthDelay
operator|<<
literal|1
operator|)
operator|+
name|BASE_ACTIVATE_DELAY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|OS_DELAY
argument_list|(
operator|(
name|synthDelay
operator|<<
literal|2
operator|)
operator|+
name|BASE_ACTIVATE_DELAY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_DELAY
argument_list|(
name|synthDelay
operator|+
name|BASE_ACTIVATE_DELAY
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The udelay method is not reliable with notebooks. 	 * Need to check to see if the baseband is ready 	 */
name|testReg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TESTCTRL
argument_list|)
expr_stmt|;
comment|/* Selects the Tx hold */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TESTCTRL
argument_list|,
name|AR_PHY_TESTCTRL_TXHOLD
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|++
operator|<
literal|20
operator|)
operator|&&
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
literal|0x9c24
argument_list|)
operator|&
literal|0x10
operator|)
condition|)
comment|/* test if baseband not ready */
name|OS_DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TESTCTRL
argument_list|,
name|testReg
argument_list|)
expr_stmt|;
comment|/* Calibrate the AGC and start a NF calculation */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
operator||
name|AR_PHY_AGC_CONTROL_CAL
operator||
name|AR_PHY_AGC_CONTROL_NF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_B
argument_list|(
name|chan
argument_list|)
operator|&&
name|ahp
operator|->
name|ah_bIQCalibration
operator|!=
name|IQ_CAL_DONE
condition|)
block|{
comment|/* Start IQ calibration w/ 2^(INIT_IQCAL_LOG_COUNT_MAX+1) samples */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|,
name|AR_PHY_TIMING_CTRL4_IQCAL_LOG_COUNT_MAX
argument_list|,
name|INIT_IQCAL_LOG_COUNT_MAX
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|,
name|AR_PHY_TIMING_CTRL4_DO_IQCAL
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_bIQCalibration
operator|=
name|IQ_CAL_RUNNING
expr_stmt|;
block|}
else|else
name|ahp
operator|->
name|ah_bIQCalibration
operator|=
name|IQ_CAL_INACTIVE
expr_stmt|;
comment|/* Setup compression registers */
name|ar5212SetCompRegs
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* Set 1:1 QCU to DCU mapping for all queues */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR_NUM_DCU
condition|;
name|i
operator|++
control|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DQCUMASK
argument_list|(
name|i
argument_list|)
argument_list|,
literal|1
operator|<<
name|i
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_intrTxqs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halTotalQueues
condition|;
name|i
operator|++
control|)
name|ar5212ResetTxQueue
argument_list|(
name|ah
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Setup interrupt handling.  Note that ar5212ResetTxQueue 	 * manipulates the secondary IMR's as queues are enabled 	 * and disabled.  This is done with RMW ops to insure the 	 * settings we make here are preserved. 	 */
name|ahp
operator|->
name|ah_maskReg
operator|=
name|AR_IMR_TXOK
operator||
name|AR_IMR_TXERR
operator||
name|AR_IMR_TXURN
operator||
name|AR_IMR_RXOK
operator||
name|AR_IMR_RXERR
operator||
name|AR_IMR_RXORN
operator||
name|AR_IMR_HIUERR
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
name|HAL_M_HOSTAP
condition|)
name|ahp
operator|->
name|ah_maskReg
operator||=
name|AR_IMR_MIB
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR
argument_list|,
name|ahp
operator|->
name|ah_maskReg
argument_list|)
expr_stmt|;
comment|/* Enable bus errors that are OR'd to set the HIUERR bit */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S2
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S2
argument_list|)
operator||
name|AR_IMR_S2_MCABT
operator||
name|AR_IMR_S2_SSERR
operator||
name|AR_IMR_S2_DPERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rfkillEnabled
condition|)
name|ar5212EnableRfKill
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_CAL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: offset calibration failed to complete in 1ms;"
literal|" noisy environment?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set clocks back to 32kHz if they had been using refClk, then 	 * use an external 32kHz crystal when sleeping, if one exists. 	 */
name|ar5212SetupClock
argument_list|(
name|ah
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
comment|/* 	 * Writing to AR_BEACON will start timers. Hence it should 	 * be the last register to be written. Do not reset tsf, do 	 * not enable beacons at this point, but preserve other values 	 * like beaconInterval. 	 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BEACON
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_BEACON
argument_list|)
operator|&
operator|~
operator|(
name|AR_BEACON_EN
operator||
name|AR_BEACON_RESET_TSF
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX Setup post reset EAR additions */
comment|/* QoS support */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|>
name|AR_SREV_VERSION_VENICE
operator|||
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|==
name|AR_SREV_VERSION_VENICE
operator|&&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macRev
operator|>=
name|AR_SREV_GRIFFIN_LITE
operator|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QOS_CONTROL
argument_list|,
literal|0x100aa
argument_list|)
expr_stmt|;
comment|/* XXX magic */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QOS_SELECT
argument_list|,
literal|0x3210
argument_list|)
expr_stmt|;
comment|/* XXX magic */
block|}
comment|/* Turn on NOACK Support for QoS packets */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_NOACK
argument_list|,
name|SM
argument_list|(
literal|2
argument_list|,
name|AR_NOACK_2BIT_VALUE
argument_list|)
operator||
name|SM
argument_list|(
literal|5
argument_list|,
name|AR_NOACK_BIT_OFFSET
argument_list|)
operator||
name|SM
argument_list|(
literal|0
argument_list|,
name|AR_NOACK_BYTE_OFFSET
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get Antenna Gain reduction */
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_ANTGAINMAX_5
argument_list|,
operator|&
name|twiceAntennaGain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_ANTGAINMAX_2
argument_list|,
operator|&
name|twiceAntennaGain
argument_list|)
expr_stmt|;
block|}
name|twiceAntennaReduction
operator|=
name|ath_hal_getantennareduction
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|twiceAntennaGain
argument_list|)
expr_stmt|;
comment|/* TPC for self-generated frames */
name|ackTpcPow
operator|=
name|MS
argument_list|(
name|ahp
operator|->
name|ah_macTPC
argument_list|,
name|AR_TPC_ACK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ackTpcPow
operator|-
name|ahp
operator|->
name|ah_txPowerIndexOffset
operator|)
operator|>
name|chan
operator|->
name|ic_maxpower
condition|)
name|ackTpcPow
operator|=
name|chan
operator|->
name|ic_maxpower
operator|+
name|ahp
operator|->
name|ah_txPowerIndexOffset
expr_stmt|;
if|if
condition|(
name|ackTpcPow
operator|>
operator|(
literal|2
operator|*
name|chan
operator|->
name|ic_maxregpower
operator|-
name|twiceAntennaReduction
operator|)
condition|)
name|ackTpcPow
operator|=
operator|(
literal|2
operator|*
name|chan
operator|->
name|ic_maxregpower
operator|-
name|twiceAntennaReduction
operator|)
operator|+
name|ahp
operator|->
name|ah_txPowerIndexOffset
expr_stmt|;
name|ctsTpcPow
operator|=
name|MS
argument_list|(
name|ahp
operator|->
name|ah_macTPC
argument_list|,
name|AR_TPC_CTS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctsTpcPow
operator|-
name|ahp
operator|->
name|ah_txPowerIndexOffset
operator|)
operator|>
name|chan
operator|->
name|ic_maxpower
condition|)
name|ctsTpcPow
operator|=
name|chan
operator|->
name|ic_maxpower
operator|+
name|ahp
operator|->
name|ah_txPowerIndexOffset
expr_stmt|;
if|if
condition|(
name|ctsTpcPow
operator|>
operator|(
literal|2
operator|*
name|chan
operator|->
name|ic_maxregpower
operator|-
name|twiceAntennaReduction
operator|)
condition|)
name|ctsTpcPow
operator|=
operator|(
literal|2
operator|*
name|chan
operator|->
name|ic_maxregpower
operator|-
name|twiceAntennaReduction
operator|)
operator|+
name|ahp
operator|->
name|ah_txPowerIndexOffset
expr_stmt|;
name|chirpTpcPow
operator|=
name|MS
argument_list|(
name|ahp
operator|->
name|ah_macTPC
argument_list|,
name|AR_TPC_CHIRP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chirpTpcPow
operator|-
name|ahp
operator|->
name|ah_txPowerIndexOffset
operator|)
operator|>
name|chan
operator|->
name|ic_maxpower
condition|)
name|chirpTpcPow
operator|=
name|chan
operator|->
name|ic_maxpower
operator|+
name|ahp
operator|->
name|ah_txPowerIndexOffset
expr_stmt|;
if|if
condition|(
name|chirpTpcPow
operator|>
operator|(
literal|2
operator|*
name|chan
operator|->
name|ic_maxregpower
operator|-
name|twiceAntennaReduction
operator|)
condition|)
name|chirpTpcPow
operator|=
operator|(
literal|2
operator|*
name|chan
operator|->
name|ic_maxregpower
operator|-
name|twiceAntennaReduction
operator|)
operator|+
name|ahp
operator|->
name|ah_txPowerIndexOffset
expr_stmt|;
if|if
condition|(
name|ackTpcPow
operator|>
literal|63
condition|)
name|ackTpcPow
operator|=
literal|63
expr_stmt|;
if|if
condition|(
name|ctsTpcPow
operator|>
literal|63
condition|)
name|ctsTpcPow
operator|=
literal|63
expr_stmt|;
if|if
condition|(
name|chirpTpcPow
operator|>
literal|63
condition|)
name|chirpTpcPow
operator|=
literal|63
expr_stmt|;
name|powerVal
operator|=
name|SM
argument_list|(
name|ackTpcPow
argument_list|,
name|AR_TPC_ACK
argument_list|)
operator||
name|SM
argument_list|(
name|ctsTpcPow
argument_list|,
name|AR_TPC_CTS
argument_list|)
operator||
name|SM
argument_list|(
name|chirpTpcPow
argument_list|,
name|AR_TPC_CHIRP
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TPC
argument_list|,
name|powerVal
argument_list|)
expr_stmt|;
comment|/* Restore user-specified settings */
if|if
condition|(
name|ahp
operator|->
name|ah_miscMode
operator|!=
literal|0
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MISC_MODE
argument_list|,
name|ahp
operator|->
name|ah_miscMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_sifstime
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ar5212SetSifsTime
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_sifstime
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_slottime
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ar5212SetSlotTime
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_slottime
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_acktimeout
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ar5212SetAckTimeout
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_acktimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_ctstimeout
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ar5212SetCTSTimeout
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_ctstimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diagreg
operator|!=
literal|0
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diagreg
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
operator|=
name|opmode
expr_stmt|;
comment|/* record operating mode */
if|#
directive|if
literal|0
block|done:
endif|#
directive|endif
if|if
condition|(
name|bChannelChange
operator|&&
operator|!
name|IEEE80211_IS_CHAN_DFS
argument_list|(
name|chan
argument_list|)
condition|)
name|chan
operator|->
name|ic_state
operator|&=
operator|~
name|IEEE80211_CHANSTATE_CWINT
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s: done\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|RESTORE_CCK
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|isBmode
argument_list|)
expr_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_DONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
name|bad
label|:
name|RESTORE_CCK
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|isBmode
argument_list|)
expr_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_DONE
argument_list|,
name|ecode
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|AH_NULL
condition|)
operator|*
name|status
operator|=
name|ecode
expr_stmt|;
return|return
name|AH_FALSE
return|;
undef|#
directive|undef
name|FAIL
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Call the rf backend to change the channel.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212SetChannel
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
comment|/* Change the synth */
if|if
condition|(
operator|!
name|ahp
operator|->
name|ah_rfHal
operator|->
name|setChannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * This channel change evaluates whether the selected hardware can  * perform a synthesizer-only channel change (no reset).  If the  * TX is not stopped, or the RFBus cannot be granted in the given  * time, the function returns false as a reset is necessary  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212ChannelChange
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|uint32_t
name|ulCount
decl_stmt|;
name|uint32_t
name|data
decl_stmt|,
name|synthDelay
decl_stmt|,
name|qnum
decl_stmt|;
name|uint16_t
name|rfXpdGain
index|[
name|MAX_NUM_PDGAINS_PER_CHANNEL
index|]
decl_stmt|;
name|HAL_BOOL
name|txStopped
init|=
name|AH_TRUE
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
decl_stmt|;
comment|/* 	 * Map public channel to private. 	 */
name|ichan
operator|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* TX must be stopped or RF Bus grant will not work */
for|for
control|(
name|qnum
operator|=
literal|0
init|;
name|qnum
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halTotalQueues
condition|;
name|qnum
operator|++
control|)
block|{
if|if
condition|(
name|ar5212NumTxPending
argument_list|(
name|ah
argument_list|,
name|qnum
argument_list|)
condition|)
block|{
name|txStopped
operator|=
name|AH_FALSE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|txStopped
condition|)
return|return
name|AH_FALSE
return|;
comment|/* Kill last Baseband Rx Frame */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RFBUS_REQ
argument_list|,
name|AR_PHY_RFBUS_REQ_REQUEST
argument_list|)
expr_stmt|;
comment|/* Request analog bus grant */
for|for
control|(
name|ulCount
operator|=
literal|0
init|;
name|ulCount
operator|<
literal|100
condition|;
name|ulCount
operator|++
control|)
block|{
if|if
condition|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RFBUS_GNT
argument_list|)
condition|)
break|break;
name|OS_DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ulCount
operator|>=
literal|100
condition|)
return|return
name|AH_FALSE
return|;
comment|/* Change the synth */
if|if
condition|(
operator|!
name|ar5212SetChannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
comment|/* 	 * Wait for the frequency synth to settle (synth goes on via PHY_ACTIVE_EN). 	 * Read the phy active delay register. Value is in 100ns increments. 	 */
name|data
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RX_DELAY
argument_list|)
operator|&
name|AR_PHY_RX_DELAY_DELAY
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|synthDelay
operator|=
operator|(
literal|4
operator|*
name|data
operator|)
operator|/
literal|22
expr_stmt|;
block|}
else|else
block|{
name|synthDelay
operator|=
name|data
operator|/
literal|10
expr_stmt|;
block|}
name|OS_DELAY
argument_list|(
name|synthDelay
operator|+
name|BASE_ACTIVATE_DELAY
argument_list|)
expr_stmt|;
comment|/* Setup the transmit power values. */
if|if
condition|(
operator|!
name|ar5212SetTransmitPower
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|rfXpdGain
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: error init'ing transmit power\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* Write delta slope for OFDM enabled modes (A, G, Turbo) */
if|if
condition|(
name|IEEE80211_IS_CHAN_OFDM
argument_list|(
name|chan
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_5413
argument_list|(
name|ah
argument_list|)
operator|||
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeversion
operator|>=
name|AR_EEPROM_VER5_3
condition|)
name|ar5212SetSpurMitigation
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|ar5212SetDeltaSlope
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
comment|/* Release the RFBus Grant */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RFBUS_REQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Start Noise Floor Cal */
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_NF
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|void
name|ar5212SetOperatingMode
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|opmode
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|AR_STA_ID1_STA_AP
operator||
name|AR_STA_ID1_ADHOC
operator|)
expr_stmt|;
switch|switch
condition|(
name|opmode
condition|)
block|{
case|case
name|HAL_M_HOSTAP
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|val
operator||
name|AR_STA_ID1_STA_AP
operator||
name|AR_STA_ID1_KSRCH_MODE
argument_list|)
expr_stmt|;
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_CFG
argument_list|,
name|AR_CFG_AP_ADHOC_INDICATION
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_M_IBSS
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|val
operator||
name|AR_STA_ID1_ADHOC
operator||
name|AR_STA_ID1_KSRCH_MODE
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_CFG
argument_list|,
name|AR_CFG_AP_ADHOC_INDICATION
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_M_STA
case|:
case|case
name|HAL_M_MONITOR
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|val
operator||
name|AR_STA_ID1_KSRCH_MODE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Places the PHY and Radio chips into reset.  A full reset  * must be called to leave this state.  The PCI/MAC/PCU are  * not placed into reset as we must receive interrupt to  * re-enable the hardware.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212PhyDisable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|ar5212SetResetReg
argument_list|(
name|ah
argument_list|,
name|AR_RC_BB
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Places all of hardware into reset  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212Disable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ar5212SetPowerMode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
comment|/* 	 * Reset the HW - PCI must be reset after the rest of the 	 * device has been reset. 	 */
return|return
name|ar5212SetResetReg
argument_list|(
name|ah
argument_list|,
name|AR_RC_MAC
operator||
name|AR_RC_BB
operator||
name|AR_RC_PCI
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Places the hardware into reset and then pulls it out of reset  *  * TODO: Only write the PLL if we're changing to or from CCK mode  *   * WARNING: The order of the PLL and mode registers must be correct.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212ChipReset
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_CHIPRESET
argument_list|,
name|chan
condition|?
name|chan
operator|->
name|ic_freq
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the HW - PCI must be reset after the rest of the 	 * device has been reset 	 */
if|if
condition|(
operator|!
name|ar5212SetResetReg
argument_list|(
name|ah
argument_list|,
name|AR_RC_MAC
operator||
name|AR_RC_BB
operator||
name|AR_RC_PCI
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
comment|/* Bring out of sleep mode (AGAIN) */
if|if
condition|(
operator|!
name|ar5212SetPowerMode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
comment|/* Clear warm reset register */
if|if
condition|(
operator|!
name|ar5212SetResetReg
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
comment|/* 	 * Perform warm reset before the mode/PLL/turbo registers 	 * are changed in order to deactivate the radio.  Mode changes 	 * with an active radio can result in corrupted shifts to the 	 * radio device. 	 */
comment|/* 	 * Set CCK and Turbo modes correctly. 	 */
if|if
condition|(
name|chan
operator|!=
name|AH_NULL
condition|)
block|{
comment|/* NB: can be null during attach */
name|uint32_t
name|rfMode
decl_stmt|,
name|phyPLL
init|=
literal|0
decl_stmt|,
name|curPhyPLL
decl_stmt|,
name|turbo
decl_stmt|;
if|if
condition|(
name|IS_5413
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* NB: =>'s 5424 also */
name|rfMode
operator|=
name|AR_PHY_MODE_AR5112
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
condition|)
name|rfMode
operator||=
name|AR_PHY_MODE_HALF
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|chan
argument_list|)
condition|)
name|rfMode
operator||=
name|AR_PHY_MODE_QUARTER
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
condition|)
name|phyPLL
operator|=
name|AR_PHY_PLL_CTL_44_5112
expr_stmt|;
else|else
name|phyPLL
operator|=
name|AR_PHY_PLL_CTL_40_5413
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_RAD5111
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|rfMode
operator|=
name|AR_PHY_MODE_AR5111
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
condition|)
name|phyPLL
operator|=
name|AR_PHY_PLL_CTL_44
expr_stmt|;
else|else
name|phyPLL
operator|=
name|AR_PHY_PLL_CTL_40
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
condition|)
name|phyPLL
operator|=
name|AR_PHY_PLL_CTL_HALF
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|chan
argument_list|)
condition|)
name|phyPLL
operator|=
name|AR_PHY_PLL_CTL_QUARTER
expr_stmt|;
block|}
else|else
block|{
comment|/* 5112, 2413, 2316, 2317 */
name|rfMode
operator|=
name|AR_PHY_MODE_AR5112
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
condition|)
name|phyPLL
operator|=
name|AR_PHY_PLL_CTL_44_5112
expr_stmt|;
else|else
name|phyPLL
operator|=
name|AR_PHY_PLL_CTL_40_5112
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
condition|)
name|phyPLL
operator||=
name|AR_PHY_PLL_CTL_HALF
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|chan
argument_list|)
condition|)
name|phyPLL
operator||=
name|AR_PHY_PLL_CTL_QUARTER
expr_stmt|;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_G
argument_list|(
name|chan
argument_list|)
condition|)
name|rfMode
operator||=
name|AR_PHY_MODE_DYNAMIC
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_OFDM
argument_list|(
name|chan
argument_list|)
condition|)
name|rfMode
operator||=
name|AR_PHY_MODE_OFDM
expr_stmt|;
else|else
name|rfMode
operator||=
name|AR_PHY_MODE_CCK
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|)
name|rfMode
operator||=
name|AR_PHY_MODE_RF5GHZ
expr_stmt|;
else|else
name|rfMode
operator||=
name|AR_PHY_MODE_RF2GHZ
expr_stmt|;
name|turbo
operator|=
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
condition|?
operator|(
name|AR_PHY_FC_TURBO_MODE
operator||
name|AR_PHY_FC_TURBO_SHORT
operator|)
else|:
literal|0
expr_stmt|;
name|curPhyPLL
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_CTL
argument_list|)
expr_stmt|;
comment|/* 		 * PLL, Mode, and Turbo values must be written in the correct 		 * order to ensure: 		 * - The PLL cannot be set to 44 unless the CCK or DYNAMIC 		 *   mode bit is set 		 * - Turbo cannot be set at the same time as CCK or DYNAMIC 		 */
if|if
condition|(
name|IEEE80211_IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TURBO
argument_list|,
name|turbo
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MODE
argument_list|,
name|rfMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|curPhyPLL
operator|!=
name|phyPLL
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_CTL
argument_list|,
name|phyPLL
argument_list|)
expr_stmt|;
comment|/* Wait for the PLL to settle */
name|OS_DELAY
argument_list|(
name|PLL_SETTLE_DELAY
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|curPhyPLL
operator|!=
name|phyPLL
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_CTL
argument_list|,
name|phyPLL
argument_list|)
expr_stmt|;
comment|/* Wait for the PLL to settle */
name|OS_DELAY
argument_list|(
name|PLL_SETTLE_DELAY
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TURBO
argument_list|,
name|turbo
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MODE
argument_list|,
name|rfMode
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Recalibrate the lower PHY chips to account for temperature/environment  * changes.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212PerCalibrationN
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|u_int
name|chainMask
parameter_list|,
name|HAL_BOOL
name|longCal
parameter_list|,
name|HAL_BOOL
modifier|*
name|isCalDone
parameter_list|)
block|{
define|#
directive|define
name|IQ_CAL_TRIES
value|10
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
decl_stmt|;
name|int32_t
name|qCoff
decl_stmt|,
name|qCoffDenom
decl_stmt|;
name|int32_t
name|iqCorrMeas
decl_stmt|,
name|iCoff
decl_stmt|,
name|iCoffDenom
decl_stmt|;
name|uint32_t
name|powerMeasQ
decl_stmt|,
name|powerMeasI
decl_stmt|;
name|HAL_BOOL
name|isBmode
init|=
name|AH_FALSE
decl_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_PERCAL
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
operator|*
name|isCalDone
operator|=
name|AH_FALSE
expr_stmt|;
name|ichan
operator|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ichan
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel %u/0x%x; no mapping\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|SAVE_CCK
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|isBmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_bIQCalibration
operator|==
name|IQ_CAL_DONE
operator|||
name|ahp
operator|->
name|ah_bIQCalibration
operator|==
name|IQ_CAL_INACTIVE
condition|)
operator|*
name|isCalDone
operator|=
name|AH_TRUE
expr_stmt|;
comment|/* IQ calibration in progress. Check to see if it has finished. */
if|if
condition|(
name|ahp
operator|->
name|ah_bIQCalibration
operator|==
name|IQ_CAL_RUNNING
operator|&&
operator|!
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|)
operator|&
name|AR_PHY_TIMING_CTRL4_DO_IQCAL
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* IQ Calibration has finished. */
name|ahp
operator|->
name|ah_bIQCalibration
operator|=
name|IQ_CAL_INACTIVE
expr_stmt|;
operator|*
name|isCalDone
operator|=
name|AH_TRUE
expr_stmt|;
comment|/* workaround for misgated IQ Cal results */
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Read calibration results. */
name|powerMeasI
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_IQCAL_RES_PWR_MEAS_I
argument_list|)
expr_stmt|;
name|powerMeasQ
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_IQCAL_RES_PWR_MEAS_Q
argument_list|)
expr_stmt|;
name|iqCorrMeas
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_IQCAL_RES_IQ_CORR_MEAS
argument_list|)
expr_stmt|;
if|if
condition|(
name|powerMeasI
operator|&&
name|powerMeasQ
condition|)
break|break;
comment|/* Do we really need this??? */
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|,
name|AR_PHY_TIMING_CTRL4_DO_IQCAL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|IQ_CAL_TRIES
condition|)
do|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"%s: IQ cal finished: %d tries\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"%s: powerMeasI %u powerMeasQ %u iqCorrMeas %d\n"
argument_list|,
name|__func__
argument_list|,
name|powerMeasI
argument_list|,
name|powerMeasQ
argument_list|,
name|iqCorrMeas
argument_list|)
expr_stmt|;
comment|/* 		 * Prescale these values to remove 64-bit operation 		 * requirement at the loss of a little precision. 		 */
name|iCoffDenom
operator|=
operator|(
name|powerMeasI
operator|/
literal|2
operator|+
name|powerMeasQ
operator|/
literal|2
operator|)
operator|/
literal|128
expr_stmt|;
name|qCoffDenom
operator|=
name|powerMeasQ
operator|/
literal|128
expr_stmt|;
comment|/* Protect against divide-by-0 and loss of sign bits. */
if|if
condition|(
name|iCoffDenom
operator|!=
literal|0
operator|&&
name|qCoffDenom
operator|>=
literal|2
condition|)
block|{
name|iCoff
operator|=
call|(
name|int8_t
call|)
argument_list|(
operator|-
name|iqCorrMeas
argument_list|)
operator|/
name|iCoffDenom
expr_stmt|;
comment|/* IQCORR_Q_I_COFF is a signed 6 bit number */
if|if
condition|(
name|iCoff
operator|<
operator|-
literal|32
condition|)
block|{
name|iCoff
operator|=
operator|-
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iCoff
operator|>
literal|31
condition|)
block|{
name|iCoff
operator|=
literal|31
expr_stmt|;
block|}
comment|/* IQCORR_Q_Q_COFF is a signed 5 bit number */
name|qCoff
operator|=
operator|(
name|powerMeasI
operator|/
name|qCoffDenom
operator|)
operator|-
literal|128
expr_stmt|;
if|if
condition|(
name|qCoff
operator|<
operator|-
literal|16
condition|)
block|{
name|qCoff
operator|=
operator|-
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qCoff
operator|>
literal|15
condition|)
block|{
name|qCoff
operator|=
literal|15
expr_stmt|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"%s: iCoff %d qCoff %d\n"
argument_list|,
name|__func__
argument_list|,
name|iCoff
argument_list|,
name|qCoff
argument_list|)
expr_stmt|;
comment|/* Write values and enable correction */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|,
name|AR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF
argument_list|,
name|iCoff
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|,
name|AR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF
argument_list|,
name|qCoff
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|,
name|AR_PHY_TIMING_CTRL4_IQCORR_ENABLE
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_bIQCalibration
operator|=
name|IQ_CAL_DONE
expr_stmt|;
name|ichan
operator|->
name|privFlags
operator||=
name|CHANNEL_IQVALID
expr_stmt|;
name|ichan
operator|->
name|iCoff
operator|=
name|iCoff
expr_stmt|;
name|ichan
operator|->
name|qCoff
operator|=
name|qCoff
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_B
argument_list|(
name|chan
argument_list|)
operator|&&
name|ahp
operator|->
name|ah_bIQCalibration
operator|==
name|IQ_CAL_DONE
operator|&&
operator|(
name|ichan
operator|->
name|privFlags
operator|&
name|CHANNEL_IQVALID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Start IQ calibration if configured channel has changed. 		 * Use a magic number of 15 based on default value. 		 */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|,
name|AR_PHY_TIMING_CTRL4_IQCAL_LOG_COUNT_MAX
argument_list|,
name|INIT_IQCAL_LOG_COUNT_MAX
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|,
name|AR_PHY_TIMING_CTRL4_DO_IQCAL
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_bIQCalibration
operator|=
name|IQ_CAL_RUNNING
expr_stmt|;
block|}
comment|/* XXX EAR */
if|if
condition|(
name|longCal
condition|)
block|{
comment|/* Check noise floor results */
name|ar5212GetNf
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_CWINT
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* Perform cal for 5Ghz channels and any OFDM on 5112 */
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
operator|||
operator|(
name|IS_RAD5112
argument_list|(
name|ah
argument_list|)
operator|&&
name|IEEE80211_IS_CHAN_OFDM
argument_list|(
name|chan
argument_list|)
operator|)
condition|)
name|ar5212RequestRfgain
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
block|}
name|RESTORE_CCK
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|isBmode
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|IQ_CAL_TRIES
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5212PerCalibration
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|HAL_BOOL
modifier|*
name|isIQdone
parameter_list|)
block|{
return|return
name|ar5212PerCalibrationN
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
literal|0x1
argument_list|,
name|AH_TRUE
argument_list|,
name|isIQdone
argument_list|)
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5212ResetCalValid
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
decl_stmt|;
name|ichan
operator|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ichan
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel %u/0x%x; no mapping\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|ichan
operator|->
name|privFlags
operator|&=
operator|~
name|CHANNEL_IQVALID
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/**************************************************************  * ar5212MacStop  *  * Disables all active QCUs and ensure that the mac is in a  * quiessence state.  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5212MacStop
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|HAL_BOOL
name|status
decl_stmt|;
name|uint32_t
name|count
decl_stmt|;
name|uint32_t
name|pendFrameCount
decl_stmt|;
name|uint32_t
name|macStateFlag
decl_stmt|;
name|uint32_t
name|queue
decl_stmt|;
name|status
operator|=
name|AH_FALSE
expr_stmt|;
comment|/* Disable Rx Operation ***********************************/
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_CR
argument_list|,
name|AR_CR_RXD
argument_list|)
expr_stmt|;
comment|/* Disable TX Operation ***********************************/
ifdef|#
directive|ifdef
name|NOT_YET
name|ar5212SetTxdpInvalid
argument_list|(
name|ah
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_Q_TXD
argument_list|,
name|AR_Q_TXD_M
argument_list|)
expr_stmt|;
comment|/* Polling operation for completion of disable ************/
name|macStateFlag
operator|=
name|TX_ENABLE_CHECK
operator||
name|RX_ENABLE_CHECK
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|MAX_RESET_WAIT
condition|;
name|count
operator|++
control|)
block|{
if|if
condition|(
name|macStateFlag
operator|&
name|RX_ENABLE_CHECK
condition|)
block|{
if|if
condition|(
operator|!
name|OS_REG_IS_BIT_SET
argument_list|(
name|ah
argument_list|,
name|AR_CR
argument_list|,
name|AR_CR_RXE
argument_list|)
condition|)
block|{
name|macStateFlag
operator|&=
operator|~
name|RX_ENABLE_CHECK
expr_stmt|;
block|}
block|}
if|if
condition|(
name|macStateFlag
operator|&
name|TX_ENABLE_CHECK
condition|)
block|{
if|if
condition|(
operator|!
name|OS_REG_IS_BIT_SET
argument_list|(
name|ah
argument_list|,
name|AR_Q_TXE
argument_list|,
name|AR_Q_TXE_M
argument_list|)
condition|)
block|{
name|macStateFlag
operator|&=
operator|~
name|TX_ENABLE_CHECK
expr_stmt|;
name|macStateFlag
operator||=
name|TX_QUEUEPEND_CHECK
expr_stmt|;
block|}
block|}
if|if
condition|(
name|macStateFlag
operator|&
name|TX_QUEUEPEND_CHECK
condition|)
block|{
name|pendFrameCount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|queue
operator|=
literal|0
init|;
name|queue
operator|<
name|AR_NUM_DCU
condition|;
name|queue
operator|++
control|)
block|{
name|pendFrameCount
operator|+=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_Q0_STS
operator|+
operator|(
name|queue
operator|*
literal|4
operator|)
argument_list|)
operator|&
name|AR_Q_STS_PEND_FR_CNT
expr_stmt|;
block|}
if|if
condition|(
name|pendFrameCount
operator|==
literal|0
condition|)
block|{
name|macStateFlag
operator|&=
operator|~
name|TX_QUEUEPEND_CHECK
expr_stmt|;
block|}
block|}
if|if
condition|(
name|macStateFlag
operator|==
literal|0
condition|)
block|{
name|status
operator|=
name|AH_TRUE
expr_stmt|;
break|break;
block|}
name|OS_DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|AH_TRUE
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s:Failed to stop the MAC state 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|macStateFlag
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Write the given reset bit mask into the reset register  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5212SetResetReg
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|resetMask
parameter_list|)
block|{
name|uint32_t
name|mask
init|=
name|resetMask
condition|?
name|resetMask
else|:
operator|~
literal|0
decl_stmt|;
name|HAL_BOOL
name|rt
decl_stmt|;
comment|/* Never reset the PCIE core */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ispcie
condition|)
block|{
name|resetMask
operator|&=
operator|~
name|AR_RC_PCI
expr_stmt|;
block|}
if|if
condition|(
name|resetMask
operator|&
operator|(
name|AR_RC_MAC
operator||
name|AR_RC_PCI
operator|)
condition|)
block|{
comment|/* 		 * To ensure that the driver can reset the 		 * MAC, wake up the chip 		 */
name|rt
operator|=
name|ar5212SetPowerMode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
name|AH_TRUE
condition|)
block|{
return|return
name|rt
return|;
block|}
comment|/* 		 * Disable interrupts 		 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IER
argument_list|,
name|AR_IER_DISABLE
argument_list|)
expr_stmt|;
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_IER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar5212MacStop
argument_list|(
name|ah
argument_list|)
operator|!=
name|AH_TRUE
condition|)
block|{
comment|/* 			 * Failed to stop the MAC gracefully; let's be more forceful then 			 */
comment|/* need some delay before flush any pending MMR writes */
name|OS_DELAY
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RXDP
argument_list|)
expr_stmt|;
name|resetMask
operator||=
name|AR_RC_MAC
operator||
name|AR_RC_BB
expr_stmt|;
comment|/* _Never_ reset PCI Express core */
if|if
condition|(
operator|!
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ispcie
condition|)
block|{
name|resetMask
operator||=
name|AR_RC_PCI
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* 			 * Flush the park address of the PCI controller 			*/
comment|/* Read PCI slot information less than Hainan revision */
block|if (AH_PRIVATE(ah)->ah_bustype == HAL_BUS_TYPE_PCI) { 				if (!IS_5112_REV5_UP(ah)) {
define|#
directive|define
name|PCI_COMMON_CONFIG_STATUS
value|0x06
block|u_int32_t    i; 					u_int16_t    reg16;  					for (i = 0; i< 32; i++) { 						ath_hal_read_pci_config_space(ah, 						    PCI_COMMON_CONFIG_STATUS,&reg16, sizeof(reg16)); 					} 				}
undef|#
directive|undef
name|PCI_COMMON_CONFIG_STATUS
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 			 * MAC stopped gracefully; no need to warm-reset the PCI bus 			 */
name|resetMask
operator|&=
operator|~
name|AR_RC_PCI
expr_stmt|;
comment|/* need some delay before flush any pending MMR writes */
name|OS_DELAY
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RXDP
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RXDP
argument_list|)
expr_stmt|;
comment|/* flush any pending MMR writes */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RC
argument_list|,
name|resetMask
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|15
argument_list|)
expr_stmt|;
comment|/* need to wait at least 128 clocks 					   when reseting PCI before read */
name|mask
operator|&=
operator|(
name|AR_RC_MAC
operator||
name|AR_RC_BB
operator|)
expr_stmt|;
name|resetMask
operator|&=
operator|(
name|AR_RC_MAC
operator||
name|AR_RC_BB
operator|)
expr_stmt|;
name|rt
operator|=
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_RC
argument_list|,
name|mask
argument_list|,
name|resetMask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|resetMask
operator|&
name|AR_RC_MAC
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isBigEndian
argument_list|()
condition|)
block|{
comment|/* 			 * Set CFG, little-endian for descriptor accesses. 			 */
name|mask
operator|=
name|INIT_CONFIG_STATUS
operator||
name|AR_CFG_SWRD
expr_stmt|;
ifndef|#
directive|ifndef
name|AH_NEED_DESC_SWAP
name|mask
operator||=
name|AR_CFG_SWTD
expr_stmt|;
endif|#
directive|endif
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CFG
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CFG
argument_list|,
name|INIT_CONFIG_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar5212SetPowerMode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
operator|(
name|void
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_RAC
argument_list|)
expr_stmt|;
block|}
comment|/* track PHY power state so we don't try to r/w BB registers */
name|AH5212
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyPowerOn
operator|=
operator|(
operator|(
name|resetMask
operator|&
name|AR_RC_BB
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
return|return
name|rt
return|;
block|}
end_function

begin_function
name|int16_t
name|ar5212GetNoiseFloor
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|int16_t
name|nf
init|=
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|25
argument_list|)
argument_list|)
operator|>>
literal|19
operator|)
operator|&
literal|0x1ff
decl_stmt|;
if|if
condition|(
name|nf
operator|&
literal|0x100
condition|)
name|nf
operator|=
literal|0
operator|-
operator|(
operator|(
name|nf
operator|^
literal|0x1ff
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
return|return
name|nf
return|;
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|getNoiseFloorThresh
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|int16_t
modifier|*
name|nft
parameter_list|)
block|{
specifier|const
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|HALASSERT
argument_list|(
name|ah
operator|->
name|ah_magic
operator|==
name|AR5212_MAGIC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|chan
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_ALLFULL
condition|)
block|{
case|case
name|IEEE80211_CHAN_A
case|:
operator|*
name|nft
operator|=
name|ee
operator|->
name|ee_noiseFloorThresh
index|[
name|headerInfo11A
index|]
expr_stmt|;
break|break;
case|case
name|IEEE80211_CHAN_B
case|:
operator|*
name|nft
operator|=
name|ee
operator|->
name|ee_noiseFloorThresh
index|[
name|headerInfo11B
index|]
expr_stmt|;
break|break;
case|case
name|IEEE80211_CHAN_G
case|:
case|case
name|IEEE80211_CHAN_PUREG
case|:
comment|/* NB: really 108G */
operator|*
name|nft
operator|=
name|ee
operator|->
name|ee_noiseFloorThresh
index|[
name|headerInfo11G
index|]
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel flags %u/0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Setup the noise floor cal history buffer.  */
end_comment

begin_function
name|void
name|ar5212InitNfCalHistBuffer
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ahp
operator|->
name|ah_nfCalHist
operator|.
name|first_run
operator|=
literal|1
expr_stmt|;
name|ahp
operator|->
name|ah_nfCalHist
operator|.
name|currIndex
operator|=
literal|0
expr_stmt|;
name|ahp
operator|->
name|ah_nfCalHist
operator|.
name|privNF
operator|=
name|AR5212_CCA_MAX_GOOD_VALUE
expr_stmt|;
name|ahp
operator|->
name|ah_nfCalHist
operator|.
name|invalidNFcount
operator|=
name|AR512_NF_CAL_HIST_MAX
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR512_NF_CAL_HIST_MAX
condition|;
name|i
operator|++
control|)
name|ahp
operator|->
name|ah_nfCalHist
operator|.
name|nfCalBuffer
index|[
name|i
index|]
operator|=
name|AR5212_CCA_MAX_GOOD_VALUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a noise floor value to the ring buffer.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|updateNFHistBuff
parameter_list|(
name|struct
name|ar5212NfCalHist
modifier|*
name|h
parameter_list|,
name|int16_t
name|nf
parameter_list|)
block|{
name|h
operator|->
name|nfCalBuffer
index|[
name|h
operator|->
name|currIndex
index|]
operator|=
name|nf
expr_stmt|;
if|if
condition|(
operator|++
name|h
operator|->
name|currIndex
operator|>=
name|AR512_NF_CAL_HIST_MAX
condition|)
name|h
operator|->
name|currIndex
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the median noise floor value in the ring buffer.  */
end_comment

begin_function
name|int16_t
name|ar5212GetNfHistMid
parameter_list|(
specifier|const
name|int16_t
name|calData
index|[
name|AR512_NF_CAL_HIST_MAX
index|]
parameter_list|)
block|{
name|int16_t
name|sort
index|[
name|AR512_NF_CAL_HIST_MAX
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|OS_MEMCPY
argument_list|(
name|sort
argument_list|,
name|calData
argument_list|,
name|AR512_NF_CAL_HIST_MAX
operator|*
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR512_NF_CAL_HIST_MAX
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|AR512_NF_CAL_HIST_MAX
operator|-
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|sort
index|[
name|j
index|]
operator|>
name|sort
index|[
name|j
operator|-
literal|1
index|]
condition|)
block|{
name|int16_t
name|nf
init|=
name|sort
index|[
name|j
index|]
decl_stmt|;
name|sort
index|[
name|j
index|]
operator|=
name|sort
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|sort
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|nf
expr_stmt|;
block|}
block|}
block|}
return|return
name|sort
index|[
operator|(
name|AR512_NF_CAL_HIST_MAX
operator|-
literal|1
operator|)
operator|>>
literal|1
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Read the NF and check it against the noise floor threshhold  */
end_comment

begin_function
name|int16_t
name|ar5212GetNf
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar5212NfCalHist
modifier|*
name|h
init|=
operator|&
name|ahp
operator|->
name|ah_nfCalHist
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
init|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|int16_t
name|nf
decl_stmt|,
name|nfThresh
decl_stmt|;
name|int32_t
name|val
decl_stmt|;
if|if
condition|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
operator|&
name|AR_PHY_AGC_CONTROL_NF
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: NF did not complete in calibration window\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ichan
operator|->
name|rawNoiseFloor
operator|=
name|h
operator|->
name|privNF
expr_stmt|;
comment|/* most recent value */
return|return
name|ichan
operator|->
name|rawNoiseFloor
return|;
block|}
comment|/* 	 * Finished NF cal, check against threshold. 	 */
name|nf
operator|=
name|ar5212GetNoiseFloor
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|getNoiseFloorThresh
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|&
name|nfThresh
argument_list|)
condition|)
block|{
if|if
condition|(
name|nf
operator|>
name|nfThresh
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: noise floor failed detected; detected %u, "
literal|"threshold %u\n"
argument_list|,
name|__func__
argument_list|,
name|nf
argument_list|,
name|nfThresh
argument_list|)
expr_stmt|;
comment|/* 			 * NB: Don't discriminate 2.4 vs 5Ghz, if this 			 *     happens it indicates a problem regardless 			 *     of the band. 			 */
name|chan
operator|->
name|ic_state
operator||=
name|IEEE80211_CHANSTATE_CWINT
expr_stmt|;
name|nf
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|nf
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Pass through histogram and write median value as 	 * calculated from the accrued window.  We require a 	 * full window of in-range values to be seen before we 	 * start using the history. 	 */
name|updateNFHistBuff
argument_list|(
name|h
argument_list|,
name|nf
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|first_run
condition|)
block|{
if|if
condition|(
name|nf
operator|<
name|AR5212_CCA_MIN_BAD_VALUE
operator|||
name|nf
operator|>
name|AR5212_CCA_MAX_HIGH_VALUE
condition|)
block|{
name|nf
operator|=
name|AR5212_CCA_MAX_GOOD_VALUE
expr_stmt|;
name|h
operator|->
name|invalidNFcount
operator|=
name|AR512_NF_CAL_HIST_MAX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|--
operator|(
name|h
operator|->
name|invalidNFcount
operator|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|first_run
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|privNF
operator|=
name|nf
operator|=
name|ar5212GetNfHistMid
argument_list|(
name|h
operator|->
name|nfCalBuffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nf
operator|=
name|AR5212_CCA_MAX_GOOD_VALUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|h
operator|->
name|privNF
operator|=
name|nf
operator|=
name|ar5212GetNfHistMid
argument_list|(
name|h
operator|->
name|nfCalBuffer
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|25
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|0xFFFFFE00
expr_stmt|;
name|val
operator||=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|nf
operator|<<
literal|1
operator|)
operator|&
literal|0x1FF
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|25
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_ENABLE_NF
argument_list|)
expr_stmt|;
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_NO_UPDATE_NF
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_NF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_NF
argument_list|,
literal|0
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|AH_DEBUG
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"%s: AGC not ready AGC_CONTROL 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Now load a high maxCCAPower value again so that we're 	 * not capped by the median we just loaded 	 */
name|val
operator|&=
literal|0xFFFFFE00
expr_stmt|;
name|val
operator||=
operator|(
operator|(
call|(
name|uint32_t
call|)
argument_list|(
operator|-
literal|50
argument_list|)
operator|<<
literal|1
operator|)
operator|&
literal|0x1FF
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|25
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_ENABLE_NF
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_NO_UPDATE_NF
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_NF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ichan
operator|->
name|rawNoiseFloor
operator|=
name|nf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up compression configuration registers  */
end_comment

begin_function
name|void
name|ar5212SetCompRegs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Check if h/w supports compression */
if|if
condition|(
operator|!
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halCompressSupport
condition|)
return|return;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DCCFG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CCFG
argument_list|,
operator|(
name|AR_COMPRESSION_WINDOW_SIZE
operator|>>
literal|8
operator|)
operator|&
name|AR_CCFG_WIN_M
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CCFG
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_CCFG
argument_list|)
operator||
name|AR_CCFG_MIB_INT_EN
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CCUCFG
argument_list|,
name|AR_CCUCFG_RESET_VAL
operator||
name|AR_CCUCFG_CATCHUP_EN
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CPCOVF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* reset decompression mask */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_DECOMP_MASK_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DCM_A
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DCM_D
argument_list|,
name|ahp
operator|->
name|ah_decompMask
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5212SetAntennaSwitchInternal
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_ANT_SETTING
name|settings
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
define|#
directive|define
name|ANT_SWITCH_TABLE1
value|AR_PHY(88)
define|#
directive|define
name|ANT_SWITCH_TABLE2
value|AR_PHY(89)
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
specifier|const
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|uint32_t
name|antSwitchA
decl_stmt|,
name|antSwitchB
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|HALASSERT
argument_list|(
name|ah
operator|->
name|ah_magic
operator|==
name|AR5212_MAGIC
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|ahp
operator|->
name|ah_phyPowerOn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|chan
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_ALLFULL
condition|)
block|{
case|case
name|IEEE80211_CHAN_A
case|:
name|ix
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IEEE80211_CHAN_G
case|:
case|case
name|IEEE80211_CHAN_PUREG
case|:
comment|/* NB: 108G */
name|ix
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|IEEE80211_CHAN_B
case|:
if|if
condition|(
name|IS_2425
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_2417
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* NB: Nala/Swan: 11b is handled using 11g */
name|ix
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|ix
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|antSwitchA
operator|=
name|ee
operator|->
name|ee_antennaControl
index|[
literal|1
index|]
index|[
name|ix
index|]
operator||
operator|(
name|ee
operator|->
name|ee_antennaControl
index|[
literal|2
index|]
index|[
name|ix
index|]
operator|<<
literal|6
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_antennaControl
index|[
literal|3
index|]
index|[
name|ix
index|]
operator|<<
literal|12
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_antennaControl
index|[
literal|4
index|]
index|[
name|ix
index|]
operator|<<
literal|18
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_antennaControl
index|[
literal|5
index|]
index|[
name|ix
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|antSwitchB
operator|=
name|ee
operator|->
name|ee_antennaControl
index|[
literal|6
index|]
index|[
name|ix
index|]
operator||
operator|(
name|ee
operator|->
name|ee_antennaControl
index|[
literal|7
index|]
index|[
name|ix
index|]
operator|<<
literal|6
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_antennaControl
index|[
literal|8
index|]
index|[
name|ix
index|]
operator|<<
literal|12
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_antennaControl
index|[
literal|9
index|]
index|[
name|ix
index|]
operator|<<
literal|18
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_antennaControl
index|[
literal|10
index|]
index|[
name|ix
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
comment|/* 	 * For fixed antenna, give the same setting for both switch banks 	 */
switch|switch
condition|(
name|settings
condition|)
block|{
case|case
name|HAL_ANT_FIXED_A
case|:
name|antSwitchB
operator|=
name|antSwitchA
expr_stmt|;
break|break;
case|case
name|HAL_ANT_FIXED_B
case|:
name|antSwitchA
operator|=
name|antSwitchB
expr_stmt|;
break|break;
case|case
name|HAL_ANT_VARIABLE
case|:
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: bad antenna setting %u\n"
argument_list|,
name|__func__
argument_list|,
name|settings
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
if|if
condition|(
name|antSwitchB
operator|==
name|antSwitchA
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RFPARAM
argument_list|,
literal|"%s: Setting fast diversity off.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_DETECT
argument_list|,
name|AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_diversity
operator|=
name|AH_FALSE
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RFPARAM
argument_list|,
literal|"%s: Setting fast diversity on.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_DETECT
argument_list|,
name|AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_diversity
operator|=
name|AH_TRUE
expr_stmt|;
block|}
name|ahp
operator|->
name|ah_antControl
operator|=
name|settings
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|ANT_SWITCH_TABLE1
argument_list|,
name|antSwitchA
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|ANT_SWITCH_TABLE2
argument_list|,
name|antSwitchB
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|ANT_SWITCH_TABLE2
undef|#
directive|undef
name|ANT_SWITCH_TABLE1
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5212IsSpurChannel
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|uint16_t
name|freq
init|=
name|ath_hal_gethwchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|uint32_t
name|clockFreq
init|=
operator|(
operator|(
name|IS_5413
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_RAD5112_ANY
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_2417
argument_list|(
name|ah
argument_list|)
operator|)
condition|?
literal|40
else|:
literal|32
operator|)
decl_stmt|;
return|return
operator|(
operator|(
operator|(
name|freq
operator|%
name|clockFreq
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|freq
operator|%
name|clockFreq
operator|)
operator|<
literal|10
operator|)
operator|||
operator|(
operator|(
operator|(
name|freq
operator|)
operator|%
name|clockFreq
operator|)
operator|>
literal|22
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read EEPROM header info and program the device for correct operation  * given the channel value.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212SetBoardValues
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
define|#
directive|define
name|NO_FALSE_DETECT_BACKOFF
value|2
define|#
directive|define
name|CB22_FALSE_DETECT_BACKOFF
value|6
define|#
directive|define
name|AR_PHY_BIS
parameter_list|(
name|_ah
parameter_list|,
name|_reg
parameter_list|,
name|_mask
parameter_list|,
name|_val
parameter_list|)
define|\
value|OS_REG_WRITE(_ah, AR_PHY(_reg), \ 		(OS_REG_READ(_ah, AR_PHY(_reg))& _mask) | (_val));
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
specifier|const
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|int
name|arrayMode
decl_stmt|,
name|falseDectectBackoff
decl_stmt|;
name|int
name|is2GHz
init|=
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
init|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|int8_t
name|adcDesiredSize
decl_stmt|,
name|pgaDesiredSize
decl_stmt|;
name|uint16_t
name|switchSettling
decl_stmt|,
name|txrxAtten
decl_stmt|,
name|rxtxMargin
decl_stmt|;
name|int
name|iCoff
decl_stmt|,
name|qCoff
decl_stmt|;
name|HALASSERT
argument_list|(
name|ah
operator|->
name|ah_magic
operator|==
name|AR5212_MAGIC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|chan
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_ALLTURBOFULL
condition|)
block|{
case|case
name|IEEE80211_CHAN_A
case|:
case|case
name|IEEE80211_CHAN_ST
case|:
name|arrayMode
operator|=
name|headerInfo11A
expr_stmt|;
if|if
condition|(
operator|!
name|IS_RAD5112_ANY
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|IS_2413
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|IS_5413
argument_list|(
name|ah
argument_list|)
condition|)
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_FRAME_CTL
argument_list|,
name|AR_PHY_FRAME_CTL_TX_CLIP
argument_list|,
name|ahp
operator|->
name|ah_gainValues
operator|.
name|currStep
operator|->
name|paramVal
index|[
name|GP_TXCLIP
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_CHAN_B
case|:
name|arrayMode
operator|=
name|headerInfo11B
expr_stmt|;
break|break;
case|case
name|IEEE80211_CHAN_G
case|:
case|case
name|IEEE80211_CHAN_108G
case|:
name|arrayMode
operator|=
name|headerInfo11G
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* Set the antenna register(s) correctly for the chip revision */
name|AR_PHY_BIS
argument_list|(
name|ah
argument_list|,
literal|68
argument_list|,
literal|0xFFFFFC06
argument_list|,
operator|(
name|ee
operator|->
name|ee_antennaControl
index|[
literal|0
index|]
index|[
name|arrayMode
index|]
operator|<<
literal|4
operator|)
operator||
literal|0x1
argument_list|)
expr_stmt|;
name|ar5212SetAntennaSwitchInternal
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_antControl
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* Set the Noise Floor Thresh on ar5211 devices */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|90
argument_list|)
argument_list|,
operator|(
name|ee
operator|->
name|ee_noiseFloorThresh
index|[
name|arrayMode
index|]
operator|&
literal|0x1FF
operator|)
operator||
operator|(
literal|1
operator|<<
literal|9
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ee
operator|->
name|ee_version
operator|>=
name|AR_EEPROM_VER5_0
operator|&&
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|switchSettling
operator|=
name|ee
operator|->
name|ee_switchSettlingTurbo
index|[
name|is2GHz
index|]
expr_stmt|;
name|adcDesiredSize
operator|=
name|ee
operator|->
name|ee_adcDesiredSizeTurbo
index|[
name|is2GHz
index|]
expr_stmt|;
name|pgaDesiredSize
operator|=
name|ee
operator|->
name|ee_pgaDesiredSizeTurbo
index|[
name|is2GHz
index|]
expr_stmt|;
name|txrxAtten
operator|=
name|ee
operator|->
name|ee_txrxAttenTurbo
index|[
name|is2GHz
index|]
expr_stmt|;
name|rxtxMargin
operator|=
name|ee
operator|->
name|ee_rxtxMarginTurbo
index|[
name|is2GHz
index|]
expr_stmt|;
block|}
else|else
block|{
name|switchSettling
operator|=
name|ee
operator|->
name|ee_switchSettling
index|[
name|arrayMode
index|]
expr_stmt|;
name|adcDesiredSize
operator|=
name|ee
operator|->
name|ee_adcDesiredSize
index|[
name|arrayMode
index|]
expr_stmt|;
name|pgaDesiredSize
operator|=
name|ee
operator|->
name|ee_pgaDesiredSize
index|[
name|is2GHz
index|]
expr_stmt|;
name|txrxAtten
operator|=
name|ee
operator|->
name|ee_txrxAtten
index|[
name|is2GHz
index|]
expr_stmt|;
name|rxtxMargin
operator|=
name|ee
operator|->
name|ee_rxtxMargin
index|[
name|is2GHz
index|]
expr_stmt|;
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SETTLING
argument_list|,
name|AR_PHY_SETTLING_SWITCH
argument_list|,
name|switchSettling
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_DESIRED_SZ
argument_list|,
name|AR_PHY_DESIRED_SZ_ADC
argument_list|,
name|adcDesiredSize
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_DESIRED_SZ
argument_list|,
name|AR_PHY_DESIRED_SZ_PGA
argument_list|,
name|pgaDesiredSize
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RXGAIN
argument_list|,
name|AR_PHY_RXGAIN_TXRX_ATTEN
argument_list|,
name|txrxAtten
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|13
argument_list|)
argument_list|,
operator|(
name|ee
operator|->
name|ee_txEndToXPAOff
index|[
name|arrayMode
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_txEndToXPAOff
index|[
name|arrayMode
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|ee
operator|->
name|ee_txFrameToXPAOn
index|[
name|arrayMode
index|]
operator|<<
literal|8
operator|)
operator||
name|ee
operator|->
name|ee_txFrameToXPAOn
index|[
name|arrayMode
index|]
argument_list|)
expr_stmt|;
name|AR_PHY_BIS
argument_list|(
name|ah
argument_list|,
literal|10
argument_list|,
literal|0xFFFF00FF
argument_list|,
name|ee
operator|->
name|ee_txEndToXLNAOn
index|[
name|arrayMode
index|]
operator|<<
literal|8
argument_list|)
expr_stmt|;
name|AR_PHY_BIS
argument_list|(
name|ah
argument_list|,
literal|25
argument_list|,
literal|0xFFF80FFF
argument_list|,
operator|(
name|ee
operator|->
name|ee_thresh62
index|[
name|arrayMode
index|]
operator|<<
literal|12
operator|)
operator|&
literal|0x7F000
argument_list|)
expr_stmt|;
comment|/* 	 * False detect backoff - suspected 32 MHz spur causes false 	 * detects in OFDM, causing Tx Hangs.  Decrease weak signal 	 * sensitivity for this card. 	 */
name|falseDectectBackoff
operator|=
name|NO_FALSE_DETECT_BACKOFF
expr_stmt|;
if|if
condition|(
name|ee
operator|->
name|ee_version
operator|<
name|AR_EEPROM_VER3_3
condition|)
block|{
comment|/* XXX magic number */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_subvendorid
operator|==
literal|0x1022
operator|&&
name|IEEE80211_IS_CHAN_OFDM
argument_list|(
name|chan
argument_list|)
condition|)
name|falseDectectBackoff
operator|+=
name|CB22_FALSE_DETECT_BACKOFF
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ar5212IsSpurChannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
name|falseDectectBackoff
operator|+=
name|ee
operator|->
name|ee_falseDetectBackoff
index|[
name|arrayMode
index|]
expr_stmt|;
block|}
name|AR_PHY_BIS
argument_list|(
name|ah
argument_list|,
literal|73
argument_list|,
literal|0xFFFFFF01
argument_list|,
operator|(
name|falseDectectBackoff
operator|<<
literal|1
operator|)
operator|&
literal|0xFE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ichan
operator|->
name|privFlags
operator|&
name|CHANNEL_IQVALID
condition|)
block|{
name|iCoff
operator|=
name|ichan
operator|->
name|iCoff
expr_stmt|;
name|qCoff
operator|=
name|ichan
operator|->
name|qCoff
expr_stmt|;
block|}
else|else
block|{
name|iCoff
operator|=
name|ee
operator|->
name|ee_iqCalI
index|[
name|is2GHz
index|]
expr_stmt|;
name|qCoff
operator|=
name|ee
operator|->
name|ee_iqCalQ
index|[
name|is2GHz
index|]
expr_stmt|;
block|}
comment|/* write previous IQ results */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|,
name|AR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF
argument_list|,
name|iCoff
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|,
name|AR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF
argument_list|,
name|qCoff
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|,
name|AR_PHY_TIMING_CTRL4_IQCORR_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ee
operator|->
name|ee_version
operator|>=
name|AR_EEPROM_VER4_1
condition|)
block|{
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_108G
argument_list|(
name|chan
argument_list|)
operator|||
name|ee
operator|->
name|ee_version
operator|>=
name|AR_EEPROM_VER5_0
condition|)
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GAIN_2GHZ
argument_list|,
name|AR_PHY_GAIN_2GHZ_RXTX_MARGIN
argument_list|,
name|rxtxMargin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ee
operator|->
name|ee_version
operator|>=
name|AR_EEPROM_VER5_1
condition|)
block|{
comment|/* for now always disabled */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_HEAVY_CLIP_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|AR_PHY_BIS
undef|#
directive|undef
name|NO_FALSE_DETECT_BACKOFF
undef|#
directive|undef
name|CB22_FALSE_DETECT_BACKOFF
block|}
end_function

begin_comment
comment|/*  * Apply Spur Immunity to Boards that require it.  * Applies only to OFDM RX operation.  */
end_comment

begin_function
name|void
name|ar5212SetSpurMitigation
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|uint32_t
name|pilotMask
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|,
name|binMagMask
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|uint16_t
name|i
decl_stmt|,
name|finalSpur
decl_stmt|,
name|curChanAsSpur
decl_stmt|,
name|binWidth
init|=
literal|0
decl_stmt|,
name|spurDetectWidth
decl_stmt|,
name|spurChan
decl_stmt|;
name|int32_t
name|spurDeltaPhase
init|=
literal|0
decl_stmt|,
name|spurFreqSd
init|=
literal|0
decl_stmt|,
name|spurOffset
decl_stmt|,
name|binOffsetNumT16
decl_stmt|,
name|curBinOffset
decl_stmt|;
name|int16_t
name|numBinOffsets
decl_stmt|;
specifier|static
specifier|const
name|uint16_t
name|magMapFor4
index|[
literal|4
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
specifier|static
specifier|const
name|uint16_t
name|magMapFor3
index|[
literal|3
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
specifier|const
name|uint16_t
modifier|*
name|pMagMap
decl_stmt|;
name|HAL_BOOL
name|is2GHz
init|=
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
init|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
define|#
directive|define
name|CHAN_TO_SPUR
parameter_list|(
name|_f
parameter_list|,
name|_freq
parameter_list|)
value|( ((_freq) - ((_f) ? 2300 : 4900)) * 10 )
if|if
condition|(
name|IS_2417
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RFPARAM
argument_list|,
literal|"%s: no spur mitigation\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|curChanAsSpur
operator|=
name|CHAN_TO_SPUR
argument_list|(
name|is2GHz
argument_list|,
name|ichan
operator|->
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|ichan
operator|->
name|mainSpur
condition|)
block|{
comment|/* Pull out the saved spur value */
name|finalSpur
operator|=
name|ichan
operator|->
name|mainSpur
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Check if spur immunity should be performed for this channel 		 * Should only be performed once per channel and then saved 		 */
name|finalSpur
operator|=
name|AR_NO_SPUR
expr_stmt|;
name|spurDetectWidth
operator|=
name|HAL_SPUR_CHAN_WIDTH
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
condition|)
name|spurDetectWidth
operator|*=
literal|2
expr_stmt|;
comment|/* Decide if any spur affects the current channel */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR_EEPROM_MODAL_SPURS
condition|;
name|i
operator|++
control|)
block|{
name|spurChan
operator|=
name|ath_hal_getSpurChan
argument_list|(
name|ah
argument_list|,
name|i
argument_list|,
name|is2GHz
argument_list|)
expr_stmt|;
if|if
condition|(
name|spurChan
operator|==
name|AR_NO_SPUR
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
name|curChanAsSpur
operator|-
name|spurDetectWidth
operator|<=
operator|(
name|spurChan
operator|&
name|HAL_SPUR_VAL_MASK
operator|)
operator|)
operator|&&
operator|(
name|curChanAsSpur
operator|+
name|spurDetectWidth
operator|>=
operator|(
name|spurChan
operator|&
name|HAL_SPUR_VAL_MASK
operator|)
operator|)
condition|)
block|{
name|finalSpur
operator|=
name|spurChan
operator|&
name|HAL_SPUR_VAL_MASK
expr_stmt|;
break|break;
block|}
block|}
comment|/* Save detected spur (or no spur) for this channel */
name|ichan
operator|->
name|mainSpur
operator|=
name|finalSpur
expr_stmt|;
block|}
comment|/* Write spur immunity data */
if|if
condition|(
name|finalSpur
operator|==
name|AR_NO_SPUR
condition|)
block|{
comment|/* Disable Spur Immunity Regs if they appear set */
if|if
condition|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|)
operator|&
name|AR_PHY_TIMING_CTRL4_ENABLE_SPUR_FILTER
condition|)
block|{
comment|/* Clear Spur Delta Phase, Spur Freq, and enable bits */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MASK_CTL
argument_list|,
name|AR_PHY_MASK_CTL_RATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|AR_PHY_TIMING_CTRL4_ENABLE_SPUR_FILTER
operator||
name|AR_PHY_TIMING_CTRL4_ENABLE_CHAN_MASK
operator||
name|AR_PHY_TIMING_CTRL4_ENABLE_PILOT_MASK
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MASK_CTL
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING11
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear pilot masks */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING8
argument_list|,
name|AR_PHY_TIMING8_PILOT_MASK_2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING9
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING10
argument_list|,
name|AR_PHY_TIMING10_PILOT_MASK_2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear magnitude masks */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK_2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK_3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MASK_CTL
argument_list|,
name|AR_PHY_MASK_CTL_MASK_4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK2_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK2_2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK2_3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK2_4
argument_list|,
name|AR_PHY_BIN_MASK2_4_MASK_4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|spurOffset
operator|=
name|finalSpur
operator|-
name|curChanAsSpur
expr_stmt|;
comment|/* 		 * Spur calculations: 		 * spurDeltaPhase is (spurOffsetIn100KHz / chipFrequencyIn100KHz)<< 21 		 * spurFreqSd is (spurOffsetIn100KHz / sampleFrequencyIn100KHz)<< 11 		 */
if|if
condition|(
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* Chip Frequency& sampleFrequency are 80 MHz */
name|spurDeltaPhase
operator|=
operator|(
name|spurOffset
operator|<<
literal|16
operator|)
operator|/
literal|25
expr_stmt|;
name|spurFreqSd
operator|=
name|spurDeltaPhase
operator|>>
literal|10
expr_stmt|;
name|binWidth
operator|=
name|HAL_BIN_WIDTH_TURBO_100HZ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_G
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* Chip Frequency is 44MHz, sampleFrequency is 40 MHz */
name|spurFreqSd
operator|=
operator|(
name|spurOffset
operator|<<
literal|8
operator|)
operator|/
literal|55
expr_stmt|;
name|spurDeltaPhase
operator|=
operator|(
name|spurOffset
operator|<<
literal|17
operator|)
operator|/
literal|25
expr_stmt|;
name|binWidth
operator|=
name|HAL_BIN_WIDTH_BASE_100HZ
expr_stmt|;
block|}
else|else
block|{
name|HALASSERT
argument_list|(
operator|!
name|IEEE80211_IS_CHAN_B
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Chip Frequency& sampleFrequency are 40 MHz */
name|spurDeltaPhase
operator|=
operator|(
name|spurOffset
operator|<<
literal|17
operator|)
operator|/
literal|25
expr_stmt|;
name|spurFreqSd
operator|=
name|spurDeltaPhase
operator|>>
literal|10
expr_stmt|;
name|binWidth
operator|=
name|HAL_BIN_WIDTH_BASE_100HZ
expr_stmt|;
block|}
comment|/* Compute Pilot Mask */
name|binOffsetNumT16
operator|=
operator|(
operator|(
name|spurOffset
operator|*
literal|1000
operator|)
operator|<<
literal|4
operator|)
operator|/
name|binWidth
expr_stmt|;
comment|/* The spur is on a bin if it's remainder at times 16 is 0 */
if|if
condition|(
name|binOffsetNumT16
operator|&
literal|0xF
condition|)
block|{
name|numBinOffsets
operator|=
literal|4
expr_stmt|;
name|pMagMap
operator|=
name|magMapFor4
expr_stmt|;
block|}
else|else
block|{
name|numBinOffsets
operator|=
literal|3
expr_stmt|;
name|pMagMap
operator|=
name|magMapFor3
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numBinOffsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|binOffsetNumT16
operator|>>
literal|4
operator|)
operator|>
name|HAL_MAX_BINS_ALLOWED
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"Too man bins in spur mitigation\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get Pilot Mask values */
name|curBinOffset
operator|=
operator|(
name|binOffsetNumT16
operator|>>
literal|4
operator|)
operator|+
name|i
operator|+
literal|25
expr_stmt|;
if|if
condition|(
operator|(
name|curBinOffset
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|curBinOffset
operator|<=
literal|32
operator|)
condition|)
block|{
if|if
condition|(
name|curBinOffset
operator|<=
literal|25
condition|)
name|pilotMask
index|[
literal|0
index|]
operator||=
literal|1
operator|<<
name|curBinOffset
expr_stmt|;
elseif|else
if|if
condition|(
name|curBinOffset
operator|>=
literal|27
condition|)
name|pilotMask
index|[
literal|0
index|]
operator||=
literal|1
operator|<<
operator|(
name|curBinOffset
operator|-
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|curBinOffset
operator|>=
literal|33
operator|)
operator|&&
operator|(
name|curBinOffset
operator|<=
literal|52
operator|)
condition|)
name|pilotMask
index|[
literal|1
index|]
operator||=
literal|1
operator|<<
operator|(
name|curBinOffset
operator|-
literal|33
operator|)
expr_stmt|;
comment|/* Get viterbi values */
if|if
condition|(
operator|(
name|curBinOffset
operator|>=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|curBinOffset
operator|<=
literal|14
operator|)
condition|)
name|binMagMask
index|[
literal|0
index|]
operator||=
name|pMagMap
index|[
name|i
index|]
operator|<<
operator|(
name|curBinOffset
operator|+
literal|1
operator|)
operator|*
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|curBinOffset
operator|>=
literal|15
operator|)
operator|&&
operator|(
name|curBinOffset
operator|<=
literal|30
operator|)
condition|)
name|binMagMask
index|[
literal|1
index|]
operator||=
name|pMagMap
index|[
name|i
index|]
operator|<<
operator|(
name|curBinOffset
operator|-
literal|15
operator|)
operator|*
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|curBinOffset
operator|>=
literal|31
operator|)
operator|&&
operator|(
name|curBinOffset
operator|<=
literal|46
operator|)
condition|)
name|binMagMask
index|[
literal|2
index|]
operator||=
name|pMagMap
index|[
name|i
index|]
operator|<<
operator|(
name|curBinOffset
operator|-
literal|31
operator|)
operator|*
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|curBinOffset
operator|>=
literal|47
operator|)
operator|&&
operator|(
name|curBinOffset
operator|<=
literal|53
operator|)
condition|)
name|binMagMask
index|[
literal|3
index|]
operator||=
name|pMagMap
index|[
name|i
index|]
operator|<<
operator|(
name|curBinOffset
operator|-
literal|47
operator|)
operator|*
literal|2
expr_stmt|;
block|}
comment|/* Write Spur Delta Phase, Spur Freq, and enable bits */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MASK_CTL
argument_list|,
name|AR_PHY_MASK_CTL_RATE
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
name|AR_PHY_TIMING_CTRL4_ENABLE_SPUR_FILTER
operator||
name|AR_PHY_TIMING_CTRL4_ENABLE_CHAN_MASK
operator||
name|AR_PHY_TIMING_CTRL4_ENABLE_PILOT_MASK
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING11
argument_list|,
name|AR_PHY_TIMING11_USE_SPUR_IN_AGC
operator||
name|SM
argument_list|(
name|spurFreqSd
argument_list|,
name|AR_PHY_TIMING11_SPUR_FREQ_SD
argument_list|)
operator||
name|SM
argument_list|(
name|spurDeltaPhase
argument_list|,
name|AR_PHY_TIMING11_SPUR_DELTA_PHASE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write pilot masks */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING7
argument_list|,
name|pilotMask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING8
argument_list|,
name|AR_PHY_TIMING8_PILOT_MASK_2
argument_list|,
name|pilotMask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING9
argument_list|,
name|pilotMask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING10
argument_list|,
name|AR_PHY_TIMING10_PILOT_MASK_2
argument_list|,
name|pilotMask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Write magnitude masks */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK_1
argument_list|,
name|binMagMask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK_2
argument_list|,
name|binMagMask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK_3
argument_list|,
name|binMagMask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MASK_CTL
argument_list|,
name|AR_PHY_MASK_CTL_MASK_4
argument_list|,
name|binMagMask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK2_1
argument_list|,
name|binMagMask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK2_2
argument_list|,
name|binMagMask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK2_3
argument_list|,
name|binMagMask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK2_4
argument_list|,
name|AR_PHY_BIN_MASK2_4_MASK_4
argument_list|,
name|binMagMask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|CHAN_TO_SPUR
block|}
end_function

begin_comment
comment|/*  * Delta slope coefficient computation.  * Required for OFDM operation.  */
end_comment

begin_function
name|void
name|ar5212SetDeltaSlope
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
define|#
directive|define
name|COEF_SCALE_S
value|24
define|#
directive|define
name|INIT_CLOCKMHZSCALED
value|0x64000000
name|uint16_t
name|freq
init|=
name|ath_hal_gethwchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|coef_scaled
decl_stmt|,
name|coef_exp
decl_stmt|,
name|coef_man
decl_stmt|,
name|ds_coef_exp
decl_stmt|,
name|ds_coef_man
decl_stmt|;
name|unsigned
name|long
name|clockMhzScaled
init|=
name|INIT_CLOCKMHZSCALED
decl_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
condition|)
name|clockMhzScaled
operator|*=
literal|2
expr_stmt|;
comment|/* half and quarter rate can divide the scaled clock by 2 or 4 respectively */
comment|/* scale for selected channel bandwidth */
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|clockMhzScaled
operator|=
name|clockMhzScaled
operator|>>
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|clockMhzScaled
operator|=
name|clockMhzScaled
operator|>>
literal|2
expr_stmt|;
block|}
comment|/* 	 * ALGO -> coef = 1e8/fcarrier*fclock/40; 	 * scaled coef to provide precision for this floating calculation  	 */
name|coef_scaled
operator|=
name|clockMhzScaled
operator|/
name|freq
expr_stmt|;
comment|/* 	 * ALGO -> coef_exp = 14-floor(log2(coef));  	 * floor(log2(x)) is the highest set bit position 	 */
for|for
control|(
name|coef_exp
operator|=
literal|31
init|;
name|coef_exp
operator|>
literal|0
condition|;
name|coef_exp
operator|--
control|)
if|if
condition|(
operator|(
name|coef_scaled
operator|>>
name|coef_exp
operator|)
operator|&
literal|0x1
condition|)
break|break;
comment|/* A coef_exp of 0 is a legal bit position but an unexpected coef_exp */
name|HALASSERT
argument_list|(
name|coef_exp
argument_list|)
expr_stmt|;
name|coef_exp
operator|=
literal|14
operator|-
operator|(
name|coef_exp
operator|-
name|COEF_SCALE_S
operator|)
expr_stmt|;
comment|/* 	 * ALGO -> coef_man = floor(coef* 2^coef_exp+0.5); 	 * The coefficient is already shifted up for scaling 	 */
name|coef_man
operator|=
name|coef_scaled
operator|+
operator|(
literal|1
operator|<<
operator|(
name|COEF_SCALE_S
operator|-
name|coef_exp
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|ds_coef_man
operator|=
name|coef_man
operator|>>
operator|(
name|COEF_SCALE_S
operator|-
name|coef_exp
operator|)
expr_stmt|;
name|ds_coef_exp
operator|=
name|coef_exp
operator|-
literal|16
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING3
argument_list|,
name|AR_PHY_TIMING3_DSC_MAN
argument_list|,
name|ds_coef_man
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING3
argument_list|,
name|AR_PHY_TIMING3_DSC_EXP
argument_list|,
name|ds_coef_exp
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|INIT_CLOCKMHZSCALED
undef|#
directive|undef
name|COEF_SCALE_S
block|}
end_function

begin_comment
comment|/*  * Set a limit on the overall output power.  Used for dynamic  * transmit power control and the like.  *  * NB: limit is in units of 0.5 dbM.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212SetTxPowerLimit
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|limit
parameter_list|)
block|{
comment|/* XXX blech, construct local writable copy */
name|struct
name|ieee80211_channel
name|dummy
init|=
operator|*
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
decl_stmt|;
name|uint16_t
name|dummyXpdGains
index|[
literal|2
index|]
decl_stmt|;
name|HAL_BOOL
name|isBmode
decl_stmt|;
name|SAVE_CCK
argument_list|(
name|ah
argument_list|,
operator|&
name|dummy
argument_list|,
name|isBmode
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_powerLimit
operator|=
name|AH_MIN
argument_list|(
name|limit
argument_list|,
name|MAX_RATE_POWER
argument_list|)
expr_stmt|;
return|return
name|ar5212SetTransmitPower
argument_list|(
name|ah
argument_list|,
operator|&
name|dummy
argument_list|,
name|dummyXpdGains
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the transmit power in the baseband for the given  * operating channel and mode.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212SetTransmitPower
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|uint16_t
modifier|*
name|rfXpdGain
parameter_list|)
block|{
define|#
directive|define
name|POW_OFDM
parameter_list|(
name|_r
parameter_list|,
name|_s
parameter_list|)
value|(((0& 1)<< ((_s)+6)) | (((_r)& 0x3f)<< (_s)))
define|#
directive|define
name|POW_CCK
parameter_list|(
name|_r
parameter_list|,
name|_s
parameter_list|)
value|(((_r)& 0x3f)<< (_s))
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) / sizeof (a[0]))
specifier|static
specifier|const
name|uint16_t
name|tpcScaleReductionTable
index|[
literal|5
index|]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|6
block|,
literal|9
block|,
name|MAX_RATE_POWER
block|}
decl_stmt|;
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|uint16_t
name|freq
init|=
name|ath_hal_gethwchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
specifier|const
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|int16_t
name|minPower
decl_stmt|,
name|maxPower
decl_stmt|,
name|tpcInDb
decl_stmt|,
name|powerLimit
decl_stmt|;
name|int
name|i
decl_stmt|;
name|HALASSERT
argument_list|(
name|ah
operator|->
name|ah_magic
operator|==
name|AR5212_MAGIC
argument_list|)
expr_stmt|;
name|OS_MEMZERO
argument_list|(
name|ahp
operator|->
name|ah_pcdacTable
argument_list|,
name|ahp
operator|->
name|ah_pcdacTableSize
argument_list|)
expr_stmt|;
name|OS_MEMZERO
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
argument_list|,
sizeof|sizeof
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
argument_list|)
argument_list|)
expr_stmt|;
name|powerLimit
operator|=
name|AH_MIN
argument_list|(
name|MAX_RATE_POWER
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_powerLimit
argument_list|)
expr_stmt|;
if|if
condition|(
name|powerLimit
operator|>=
name|MAX_RATE_POWER
operator|||
name|powerLimit
operator|==
literal|0
condition|)
name|tpcInDb
operator|=
name|tpcScaleReductionTable
index|[
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tpScale
index|]
expr_stmt|;
else|else
name|tpcInDb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ar5212SetRateTable
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|tpcInDb
argument_list|,
name|powerLimit
argument_list|,
name|AH_TRUE
argument_list|,
operator|&
name|minPower
argument_list|,
operator|&
name|maxPower
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: unable to set rate table\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
if|if
condition|(
operator|!
name|ahp
operator|->
name|ah_rfHal
operator|->
name|setPowerTable
argument_list|(
name|ah
argument_list|,
operator|&
name|minPower
argument_list|,
operator|&
name|maxPower
argument_list|,
name|chan
argument_list|,
name|rfXpdGain
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: unable to set power table\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/*  	 * Adjust XR power/rate up by 2 dB to account for greater peak 	 * to avg ratio - except in newer avg power designs 	 */
if|if
condition|(
operator|!
name|IS_2413
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|IS_5413
argument_list|(
name|ah
argument_list|)
condition|)
name|ahp
operator|->
name|ah_ratesArray
index|[
literal|15
index|]
operator|+=
literal|4
expr_stmt|;
comment|/*  	 * txPowerIndexOffset is set by the SetPowerTable() call - 	 *  adjust the rate table  	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ahp
operator|->
name|ah_ratesArray
index|[
name|i
index|]
operator|+=
name|ahp
operator|->
name|ah_txPowerIndexOffset
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_ratesArray
index|[
name|i
index|]
operator|>
literal|63
condition|)
name|ahp
operator|->
name|ah_ratesArray
index|[
name|i
index|]
operator|=
literal|63
expr_stmt|;
block|}
if|if
condition|(
name|ee
operator|->
name|ee_eepMap
operator|<
literal|2
condition|)
block|{
comment|/*  		 * Correct gain deltas for 5212 G operation - 		 * Removed with revised chipset 		 */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyRev
operator|<
name|AR_PHY_CHIP_ID_REV_2
operator|&&
name|IEEE80211_IS_CHAN_G
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|uint16_t
name|cckOfdmPwrDelta
decl_stmt|;
if|if
condition|(
name|freq
operator|==
literal|2484
condition|)
name|cckOfdmPwrDelta
operator|=
name|SCALE_OC_DELTA
argument_list|(
name|ee
operator|->
name|ee_cckOfdmPwrDelta
operator|-
name|ee
operator|->
name|ee_scaledCh14FilterCckDelta
argument_list|)
expr_stmt|;
else|else
name|cckOfdmPwrDelta
operator|=
name|SCALE_OC_DELTA
argument_list|(
name|ee
operator|->
name|ee_cckOfdmPwrDelta
argument_list|)
expr_stmt|;
name|ar5212CorrectGainDelta
argument_list|(
name|ah
argument_list|,
name|cckOfdmPwrDelta
argument_list|)
expr_stmt|;
block|}
comment|/*  		 * Finally, write the power values into the 		 * baseband power table 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|PWR_TABLE_SIZE
operator|/
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PCDAC_TX_POWER
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
operator|(
operator|(
operator|(
name|ahp
operator|->
name|ah_pcdacTable
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
literal|0xff
operator|)
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|ahp
operator|->
name|ah_pcdacTable
index|[
literal|2
operator|*
name|i
index|]
operator|<<
literal|8
operator|)
operator||
literal|0xff
operator|)
operator|&
literal|0xffff
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Write the OFDM power per rate set */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_RATE1
argument_list|,
name|POW_OFDM
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
index|[
literal|3
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_OFDM
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
index|[
literal|2
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_OFDM
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
index|[
literal|1
index|]
argument_list|,
literal|8
argument_list|)
operator||
name|POW_OFDM
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_RATE2
argument_list|,
name|POW_OFDM
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
index|[
literal|7
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_OFDM
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
index|[
literal|6
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_OFDM
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
index|[
literal|5
index|]
argument_list|,
literal|8
argument_list|)
operator||
name|POW_OFDM
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
index|[
literal|4
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write the CCK power per rate set */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_RATE3
argument_list|,
name|POW_CCK
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
index|[
literal|10
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_CCK
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
index|[
literal|9
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_CCK
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
index|[
literal|15
index|]
argument_list|,
literal|8
argument_list|)
comment|/* XR target power */
operator||
name|POW_CCK
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
index|[
literal|8
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_RATE4
argument_list|,
name|POW_CCK
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
index|[
literal|14
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_CCK
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
index|[
literal|13
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_CCK
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
index|[
literal|12
index|]
argument_list|,
literal|8
argument_list|)
operator||
name|POW_CCK
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
index|[
literal|11
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set max power to 30 dBm and, optionally, 	 * enable TPC in tx descriptors. 	 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_RATE_MAX
argument_list|,
name|MAX_RATE_POWER
operator||
operator|(
name|ahp
operator|->
name|ah_tpcEnabled
condition|?
name|AR_PHY_POWER_TX_RATE_MAX_TPC_ENABLE
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|N
undef|#
directive|undef
name|POW_CCK
undef|#
directive|undef
name|POW_OFDM
block|}
end_function

begin_comment
comment|/*  * Sets the transmit power in the baseband for the given  * operating channel and mode.  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5212SetRateTable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|int16_t
name|tpcScaleReduction
parameter_list|,
name|int16_t
name|powerLimit
parameter_list|,
name|HAL_BOOL
name|commit
parameter_list|,
name|int16_t
modifier|*
name|pMinPower
parameter_list|,
name|int16_t
modifier|*
name|pMaxPower
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|uint16_t
name|freq
init|=
name|ath_hal_gethwchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
specifier|const
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|uint16_t
modifier|*
name|rpow
init|=
name|ahp
operator|->
name|ah_ratesArray
decl_stmt|;
name|uint16_t
name|twiceMaxEdgePower
init|=
name|MAX_RATE_POWER
decl_stmt|;
name|uint16_t
name|twiceMaxEdgePowerCck
init|=
name|MAX_RATE_POWER
decl_stmt|;
name|uint16_t
name|twiceMaxRDPower
init|=
name|MAX_RATE_POWER
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint8_t
name|cfgCtl
decl_stmt|;
name|int8_t
name|twiceAntennaGain
decl_stmt|,
name|twiceAntennaReduction
decl_stmt|;
specifier|const
name|RD_EDGES_POWER
modifier|*
name|rep
decl_stmt|;
name|TRGT_POWER_INFO
name|targetPowerOfdm
decl_stmt|,
name|targetPowerCck
decl_stmt|;
name|int16_t
name|scaledPower
decl_stmt|,
name|maxAvailPower
init|=
literal|0
decl_stmt|;
name|int16_t
name|r13
decl_stmt|,
name|r9
decl_stmt|,
name|r7
decl_stmt|,
name|r0
decl_stmt|;
name|HALASSERT
argument_list|(
name|ah
operator|->
name|ah_magic
operator|==
name|AR5212_MAGIC
argument_list|)
expr_stmt|;
name|twiceMaxRDPower
operator|=
name|chan
operator|->
name|ic_maxregpower
operator|*
literal|2
expr_stmt|;
operator|*
name|pMaxPower
operator|=
operator|-
name|MAX_RATE_POWER
expr_stmt|;
operator|*
name|pMinPower
operator|=
name|MAX_RATE_POWER
expr_stmt|;
comment|/* Get conformance test limit maximum for this channel */
name|cfgCtl
operator|=
name|ath_hal_getctl
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ee
operator|->
name|ee_numCtls
condition|;
name|i
operator|++
control|)
block|{
name|uint16_t
name|twiceMinEdgePower
decl_stmt|;
if|if
condition|(
name|ee
operator|->
name|ee_ctl
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ee
operator|->
name|ee_ctl
index|[
name|i
index|]
operator|==
name|cfgCtl
operator|||
name|cfgCtl
operator|==
operator|(
operator|(
name|ee
operator|->
name|ee_ctl
index|[
name|i
index|]
operator|&
name|CTL_MODE_M
operator|)
operator||
name|SD_NO_CTL
operator|)
condition|)
block|{
name|rep
operator|=
operator|&
name|ee
operator|->
name|ee_rdEdgesPower
index|[
name|i
operator|*
name|NUM_EDGES
index|]
expr_stmt|;
name|twiceMinEdgePower
operator|=
name|ar5212GetMaxEdgePower
argument_list|(
name|freq
argument_list|,
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cfgCtl
operator|&
operator|~
name|CTL_MODE_M
operator|)
operator|==
name|SD_NO_CTL
condition|)
block|{
comment|/* Find the minimum of all CTL edge powers that apply to this channel */
name|twiceMaxEdgePower
operator|=
name|AH_MIN
argument_list|(
name|twiceMaxEdgePower
argument_list|,
name|twiceMinEdgePower
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|twiceMaxEdgePower
operator|=
name|twiceMinEdgePower
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_G
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* Check for a CCK CTL for 11G CCK powers */
name|cfgCtl
operator|=
operator|(
name|cfgCtl
operator|&
operator|~
name|CTL_MODE_M
operator|)
operator||
name|CTL_11B
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ee
operator|->
name|ee_numCtls
condition|;
name|i
operator|++
control|)
block|{
name|uint16_t
name|twiceMinEdgePowerCck
decl_stmt|;
if|if
condition|(
name|ee
operator|->
name|ee_ctl
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ee
operator|->
name|ee_ctl
index|[
name|i
index|]
operator|==
name|cfgCtl
operator|||
name|cfgCtl
operator|==
operator|(
operator|(
name|ee
operator|->
name|ee_ctl
index|[
name|i
index|]
operator|&
name|CTL_MODE_M
operator|)
operator||
name|SD_NO_CTL
operator|)
condition|)
block|{
name|rep
operator|=
operator|&
name|ee
operator|->
name|ee_rdEdgesPower
index|[
name|i
operator|*
name|NUM_EDGES
index|]
expr_stmt|;
name|twiceMinEdgePowerCck
operator|=
name|ar5212GetMaxEdgePower
argument_list|(
name|freq
argument_list|,
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cfgCtl
operator|&
operator|~
name|CTL_MODE_M
operator|)
operator|==
name|SD_NO_CTL
condition|)
block|{
comment|/* Find the minimum of all CTL edge powers that apply to this channel */
name|twiceMaxEdgePowerCck
operator|=
name|AH_MIN
argument_list|(
name|twiceMaxEdgePowerCck
argument_list|,
name|twiceMinEdgePowerCck
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|twiceMaxEdgePowerCck
operator|=
name|twiceMinEdgePowerCck
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* Set the 11B cck edge power to the one found before */
name|twiceMaxEdgePowerCck
operator|=
name|twiceMaxEdgePower
expr_stmt|;
block|}
comment|/* Get Antenna Gain reduction */
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_ANTGAINMAX_5
argument_list|,
operator|&
name|twiceAntennaGain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_ANTGAINMAX_2
argument_list|,
operator|&
name|twiceAntennaGain
argument_list|)
expr_stmt|;
block|}
name|twiceAntennaReduction
operator|=
name|ath_hal_getantennareduction
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|twiceAntennaGain
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_OFDM
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* Get final OFDM target powers */
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|ar5212GetTargetPowers
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|ee
operator|->
name|ee_trgtPwr_11g
argument_list|,
name|ee
operator|->
name|ee_numTargetPwr_11g
argument_list|,
operator|&
name|targetPowerOfdm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ar5212GetTargetPowers
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|ee
operator|->
name|ee_trgtPwr_11a
argument_list|,
name|ee
operator|->
name|ee_numTargetPwr_11a
argument_list|,
operator|&
name|targetPowerOfdm
argument_list|)
expr_stmt|;
block|}
comment|/* Get Maximum OFDM power */
comment|/* Minimum of target and edge powers */
name|scaledPower
operator|=
name|AH_MIN
argument_list|(
name|twiceMaxEdgePower
argument_list|,
name|twiceMaxRDPower
operator|-
name|twiceAntennaReduction
argument_list|)
expr_stmt|;
comment|/* 		 * If turbo is set, reduce power to keep power 		 * consumption under 2 Watts.  Note that we always do 		 * this unless specially configured.  Then we limit 		 * power only for non-AP operation. 		 */
if|if
condition|(
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
ifdef|#
directive|ifdef
name|AH_ENABLE_AP_SUPPORT
operator|&&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
operator|!=
name|HAL_M_HOSTAP
endif|#
directive|endif
condition|)
block|{
comment|/* 			 * If turbo is set, reduce power to keep power 			 * consumption under 2 Watts 			 */
if|if
condition|(
name|ee
operator|->
name|ee_version
operator|>=
name|AR_EEPROM_VER3_1
condition|)
name|scaledPower
operator|=
name|AH_MIN
argument_list|(
name|scaledPower
argument_list|,
name|ee
operator|->
name|ee_turbo2WMaxPower5
argument_list|)
expr_stmt|;
comment|/* 			 * EEPROM version 4.0 added an additional 			 * constraint on 2.4GHz channels. 			 */
if|if
condition|(
name|ee
operator|->
name|ee_version
operator|>=
name|AR_EEPROM_VER4_0
operator|&&
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
name|scaledPower
operator|=
name|AH_MIN
argument_list|(
name|scaledPower
argument_list|,
name|ee
operator|->
name|ee_turbo2WMaxPower2
argument_list|)
expr_stmt|;
block|}
name|maxAvailPower
operator|=
name|AH_MIN
argument_list|(
name|scaledPower
argument_list|,
name|targetPowerOfdm
operator|.
name|twicePwr6_24
argument_list|)
expr_stmt|;
comment|/* Reduce power by max regulatory domain allowed restrictions */
name|scaledPower
operator|=
name|maxAvailPower
operator|-
operator|(
name|tpcScaleReduction
operator|*
literal|2
operator|)
expr_stmt|;
name|scaledPower
operator|=
operator|(
name|scaledPower
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|scaledPower
expr_stmt|;
name|scaledPower
operator|=
name|AH_MIN
argument_list|(
name|scaledPower
argument_list|,
name|powerLimit
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
condition|)
block|{
comment|/* Set OFDM rates 9, 12, 18, 24 */
name|r0
operator|=
name|rpow
index|[
literal|0
index|]
operator|=
name|rpow
index|[
literal|1
index|]
operator|=
name|rpow
index|[
literal|2
index|]
operator|=
name|rpow
index|[
literal|3
index|]
operator|=
name|rpow
index|[
literal|4
index|]
operator|=
name|scaledPower
expr_stmt|;
comment|/* Set OFDM rates 36, 48, 54, XR */
name|rpow
index|[
literal|5
index|]
operator|=
name|AH_MIN
argument_list|(
name|rpow
index|[
literal|0
index|]
argument_list|,
name|targetPowerOfdm
operator|.
name|twicePwr36
argument_list|)
expr_stmt|;
name|rpow
index|[
literal|6
index|]
operator|=
name|AH_MIN
argument_list|(
name|rpow
index|[
literal|0
index|]
argument_list|,
name|targetPowerOfdm
operator|.
name|twicePwr48
argument_list|)
expr_stmt|;
name|r7
operator|=
name|rpow
index|[
literal|7
index|]
operator|=
name|AH_MIN
argument_list|(
name|rpow
index|[
literal|0
index|]
argument_list|,
name|targetPowerOfdm
operator|.
name|twicePwr54
argument_list|)
expr_stmt|;
if|if
condition|(
name|ee
operator|->
name|ee_version
operator|>=
name|AR_EEPROM_VER4_0
condition|)
block|{
comment|/* Setup XR target power from EEPROM */
name|rpow
index|[
literal|15
index|]
operator|=
name|AH_MIN
argument_list|(
name|scaledPower
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|?
name|ee
operator|->
name|ee_xrTargetPower2
else|:
name|ee
operator|->
name|ee_xrTargetPower5
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XR uses 6mb power */
name|rpow
index|[
literal|15
index|]
operator|=
name|rpow
index|[
literal|0
index|]
expr_stmt|;
block|}
name|ahp
operator|->
name|ah_ofdmTxPower
operator|=
operator|*
name|pMaxPower
expr_stmt|;
block|}
else|else
block|{
name|r0
operator|=
name|scaledPower
expr_stmt|;
name|r7
operator|=
name|AH_MIN
argument_list|(
name|r0
argument_list|,
name|targetPowerOfdm
operator|.
name|twicePwr54
argument_list|)
expr_stmt|;
block|}
operator|*
name|pMinPower
operator|=
name|r7
expr_stmt|;
operator|*
name|pMaxPower
operator|=
name|r0
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RFPARAM
argument_list|,
literal|"%s: MaxRD: %d TurboMax: %d MaxCTL: %d "
literal|"TPC_Reduction %d chan=%d (0x%x) maxAvailPower=%d pwr6_24=%d, maxPower=%d\n"
argument_list|,
name|__func__
argument_list|,
name|twiceMaxRDPower
argument_list|,
name|ee
operator|->
name|ee_turbo2WMaxPower5
argument_list|,
name|twiceMaxEdgePower
argument_list|,
name|tpcScaleReduction
operator|*
literal|2
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|,
name|maxAvailPower
argument_list|,
name|targetPowerOfdm
operator|.
name|twicePwr6_24
argument_list|,
operator|*
name|pMaxPower
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* Get final CCK target powers */
name|ar5212GetTargetPowers
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|ee
operator|->
name|ee_trgtPwr_11b
argument_list|,
name|ee
operator|->
name|ee_numTargetPwr_11b
argument_list|,
operator|&
name|targetPowerCck
argument_list|)
expr_stmt|;
comment|/* Reduce power by max regulatory domain allowed restrictions */
name|scaledPower
operator|=
name|AH_MIN
argument_list|(
name|twiceMaxEdgePowerCck
argument_list|,
name|twiceMaxRDPower
operator|-
name|twiceAntennaReduction
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxAvailPower
operator|<
name|AH_MIN
argument_list|(
name|scaledPower
argument_list|,
name|targetPowerCck
operator|.
name|twicePwr6_24
argument_list|)
condition|)
name|maxAvailPower
operator|=
name|AH_MIN
argument_list|(
name|scaledPower
argument_list|,
name|targetPowerCck
operator|.
name|twicePwr6_24
argument_list|)
expr_stmt|;
comment|/* Reduce power by user selection */
name|scaledPower
operator|=
name|AH_MIN
argument_list|(
name|scaledPower
argument_list|,
name|targetPowerCck
operator|.
name|twicePwr6_24
argument_list|)
operator|-
operator|(
name|tpcScaleReduction
operator|*
literal|2
operator|)
expr_stmt|;
name|scaledPower
operator|=
operator|(
name|scaledPower
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|scaledPower
expr_stmt|;
name|scaledPower
operator|=
name|AH_MIN
argument_list|(
name|scaledPower
argument_list|,
name|powerLimit
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
condition|)
block|{
comment|/* Set CCK rates 2L, 2S, 5.5L, 5.5S, 11L, 11S */
name|rpow
index|[
literal|8
index|]
operator|=
name|AH_MIN
argument_list|(
name|scaledPower
argument_list|,
name|targetPowerCck
operator|.
name|twicePwr6_24
argument_list|)
expr_stmt|;
name|r9
operator|=
name|rpow
index|[
literal|9
index|]
operator|=
name|AH_MIN
argument_list|(
name|scaledPower
argument_list|,
name|targetPowerCck
operator|.
name|twicePwr36
argument_list|)
expr_stmt|;
name|rpow
index|[
literal|10
index|]
operator|=
name|rpow
index|[
literal|9
index|]
expr_stmt|;
name|rpow
index|[
literal|11
index|]
operator|=
name|AH_MIN
argument_list|(
name|scaledPower
argument_list|,
name|targetPowerCck
operator|.
name|twicePwr48
argument_list|)
expr_stmt|;
name|rpow
index|[
literal|12
index|]
operator|=
name|rpow
index|[
literal|11
index|]
expr_stmt|;
name|r13
operator|=
name|rpow
index|[
literal|13
index|]
operator|=
name|AH_MIN
argument_list|(
name|scaledPower
argument_list|,
name|targetPowerCck
operator|.
name|twicePwr54
argument_list|)
expr_stmt|;
name|rpow
index|[
literal|14
index|]
operator|=
name|rpow
index|[
literal|13
index|]
expr_stmt|;
block|}
else|else
block|{
name|r9
operator|=
name|AH_MIN
argument_list|(
name|scaledPower
argument_list|,
name|targetPowerCck
operator|.
name|twicePwr36
argument_list|)
expr_stmt|;
name|r13
operator|=
name|AH_MIN
argument_list|(
name|scaledPower
argument_list|,
name|targetPowerCck
operator|.
name|twicePwr54
argument_list|)
expr_stmt|;
block|}
comment|/* Set min/max power based off OFDM values or initialization */
if|if
condition|(
name|r13
operator|<
operator|*
name|pMinPower
condition|)
operator|*
name|pMinPower
operator|=
name|r13
expr_stmt|;
if|if
condition|(
name|r9
operator|>
operator|*
name|pMaxPower
condition|)
operator|*
name|pMaxPower
operator|=
name|r9
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RFPARAM
argument_list|,
literal|"%s: cck: MaxRD: %d MaxCTL: %d "
literal|"TPC_Reduction %d chan=%d (0x%x) maxAvailPower=%d pwr6_24=%d, maxPower=%d\n"
argument_list|,
name|__func__
argument_list|,
name|twiceMaxRDPower
argument_list|,
name|twiceMaxEdgePowerCck
argument_list|,
name|tpcScaleReduction
operator|*
literal|2
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|,
name|maxAvailPower
argument_list|,
name|targetPowerCck
operator|.
name|twicePwr6_24
argument_list|,
operator|*
name|pMaxPower
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commit
condition|)
block|{
name|ahp
operator|->
name|ah_tx6PowerInHalfDbm
operator|=
operator|*
name|pMaxPower
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_maxPowerLevel
operator|=
name|ahp
operator|->
name|ah_tx6PowerInHalfDbm
expr_stmt|;
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5212GetChipPowerLimits
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
block|static const uint16_t tpcScaleReductionTable[5] = 		{ 0, 3, 6, 9, MAX_RATE_POWER }; 	int16_t tpcInDb, powerLimit;
endif|#
directive|endif
name|int16_t
name|minPower
decl_stmt|,
name|maxPower
decl_stmt|;
comment|/* 	 * Get Pier table max and min powers. 	 */
if|if
condition|(
name|ahp
operator|->
name|ah_rfHal
operator|->
name|getChannelMaxMinPower
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|&
name|maxPower
argument_list|,
operator|&
name|minPower
argument_list|)
condition|)
block|{
comment|/* NB: rf code returns 1/4 dBm units, convert */
name|chan
operator|->
name|ic_maxpower
operator|=
name|maxPower
operator|/
literal|2
expr_stmt|;
name|chan
operator|->
name|ic_minpower
operator|=
name|minPower
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: no min/max power for %u/0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|chan
operator|->
name|ic_maxpower
operator|=
name|MAX_RATE_POWER
expr_stmt|;
name|chan
operator|->
name|ic_minpower
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* 	 * Now adjust to reflect any global scale and/or CTL's. 	 * (XXX is that correct?) 	 */
block|powerLimit = AH_MIN(MAX_RATE_POWER, AH_PRIVATE(ah)->ah_powerLimit); 	if (powerLimit>= MAX_RATE_POWER || powerLimit == 0) 		tpcInDb = tpcScaleReductionTable[AH_PRIVATE(ah)->ah_tpScale]; 	else 		tpcInDb = 0; 	if (!ar5212SetRateTable(ah, chan, tpcInDb, powerLimit, 				AH_FALSE,&minPower,&maxPower)) { 		HALDEBUG(ah, HAL_DEBUG_ANY, 		    "%s: unable to find max/min power\n",__func__); 		return AH_FALSE; 	} 	if (maxPower< chan->ic_maxpower) 		chan->ic_maxpower = maxPower; 	if (minPower< chan->ic_minpower) 		chan->ic_minpower = minPower; 	HALDEBUG(ah, HAL_DEBUG_RESET, 	    "Chan %d: MaxPow = %d MinPow = %d\n", 	    chan->ic_freq, chan->ic_maxpower, chans->ic_minpower);
endif|#
directive|endif
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Correct for the gain-delta between ofdm and cck mode target  * powers. Write the results to the rate table and the power table.  *  *   Conventions :  *   1. rpow[ii] is the integer value of 2*(desired power  *    for the rate ii in dBm) to provide 0.5dB resolution. rate  *    mapping is as following :  *     [0..7]  --> ofdm 6, 9, .. 48, 54  *     [8..14] --> cck 1L, 2L, 2S, .. 11L, 11S  *     [15]    --> XR (all rates get the same power)  *   2. powv[ii]  is the pcdac corresponding to ii/2 dBm.  */
end_comment

begin_function
specifier|static
name|void
name|ar5212CorrectGainDelta
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|twiceOfdmCckDelta
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|_a
parameter_list|)
value|(sizeof(_a) / sizeof(_a[0]))
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
specifier|const
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|int16_t
name|ratesIndex
index|[
name|N
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
argument_list|)
index|]
decl_stmt|;
name|uint16_t
name|ii
decl_stmt|,
name|jj
decl_stmt|,
name|iter
decl_stmt|;
name|int32_t
name|cckIndex
decl_stmt|;
name|int16_t
name|gainDeltaAdjust
decl_stmt|;
name|HALASSERT
argument_list|(
name|ah
operator|->
name|ah_magic
operator|==
name|AR5212_MAGIC
argument_list|)
expr_stmt|;
name|gainDeltaAdjust
operator|=
name|ee
operator|->
name|ee_cckOfdmGainDelta
expr_stmt|;
comment|/* make a local copy of desired powers as initial indices */
name|OS_MEMCPY
argument_list|(
name|ratesIndex
argument_list|,
name|ahp
operator|->
name|ah_ratesArray
argument_list|,
sizeof|sizeof
argument_list|(
name|ratesIndex
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fix only the CCK indices */
for|for
control|(
name|ii
operator|=
literal|8
init|;
name|ii
operator|<
literal|15
condition|;
name|ii
operator|++
control|)
block|{
comment|/* apply a gain_delta correction of -15 for CCK */
name|ratesIndex
index|[
name|ii
index|]
operator|-=
name|gainDeltaAdjust
expr_stmt|;
comment|/* Now check for contention with all ofdm target powers */
name|jj
operator|=
literal|0
expr_stmt|;
name|iter
operator|=
literal|0
expr_stmt|;
comment|/* indicates not all ofdm rates checked forcontention yet */
while|while
condition|(
name|jj
operator|<
literal|16
condition|)
block|{
if|if
condition|(
name|ratesIndex
index|[
name|ii
index|]
operator|<
literal|0
condition|)
name|ratesIndex
index|[
name|ii
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|jj
operator|==
literal|8
condition|)
block|{
comment|/* skip CCK rates */
name|jj
operator|=
literal|15
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ratesIndex
index|[
name|ii
index|]
operator|==
name|ahp
operator|->
name|ah_ratesArray
index|[
name|jj
index|]
condition|)
block|{
if|if
condition|(
name|ahp
operator|->
name|ah_ratesArray
index|[
name|jj
index|]
operator|==
literal|0
condition|)
name|ratesIndex
index|[
name|ii
index|]
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|iter
operator|>
literal|50
condition|)
block|{
comment|/* 					 * To avoid pathological case of of 					 * dm target powers 0 and 0.5dBm 					 */
name|ratesIndex
index|[
name|ii
index|]
operator|++
expr_stmt|;
block|}
else|else
name|ratesIndex
index|[
name|ii
index|]
operator|--
expr_stmt|;
comment|/* check with all rates again */
name|jj
operator|=
literal|0
expr_stmt|;
name|iter
operator|++
expr_stmt|;
block|}
else|else
name|jj
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ratesIndex
index|[
name|ii
index|]
operator|>=
name|PWR_TABLE_SIZE
condition|)
name|ratesIndex
index|[
name|ii
index|]
operator|=
name|PWR_TABLE_SIZE
operator|-
literal|1
expr_stmt|;
name|cckIndex
operator|=
name|ahp
operator|->
name|ah_ratesArray
index|[
name|ii
index|]
operator|-
name|twiceOfdmCckDelta
expr_stmt|;
if|if
condition|(
name|cckIndex
operator|<
literal|0
condition|)
name|cckIndex
operator|=
literal|0
expr_stmt|;
comment|/*  		 * Validate that the indexes for the powv are not 		 * out of bounds. 		 */
name|HALASSERT
argument_list|(
name|cckIndex
operator|<
name|PWR_TABLE_SIZE
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|ratesIndex
index|[
name|ii
index|]
operator|<
name|PWR_TABLE_SIZE
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_pcdacTable
index|[
name|ratesIndex
index|[
name|ii
index|]
index|]
operator|=
name|ahp
operator|->
name|ah_pcdacTable
index|[
name|cckIndex
index|]
expr_stmt|;
block|}
comment|/* Override rate per power table with new values */
for|for
control|(
name|ii
operator|=
literal|8
init|;
name|ii
operator|<
literal|15
condition|;
name|ii
operator|++
control|)
name|ahp
operator|->
name|ah_ratesArray
index|[
name|ii
index|]
operator|=
name|ratesIndex
index|[
name|ii
index|]
expr_stmt|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Find the maximum conformance test limit for the given channel and CTL info  */
end_comment

begin_function
specifier|static
name|uint16_t
name|ar5212GetMaxEdgePower
parameter_list|(
name|uint16_t
name|channel
parameter_list|,
specifier|const
name|RD_EDGES_POWER
modifier|*
name|pRdEdgesPower
parameter_list|)
block|{
comment|/* temp array for holding edge channels */
name|uint16_t
name|tempChannelList
index|[
name|NUM_EDGES
index|]
decl_stmt|;
name|uint16_t
name|clo
decl_stmt|,
name|chi
decl_stmt|,
name|twiceMaxEdgePower
decl_stmt|;
name|int
name|i
decl_stmt|,
name|numEdges
decl_stmt|;
comment|/* Get the edge power */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EDGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pRdEdgesPower
index|[
name|i
index|]
operator|.
name|rdEdge
operator|==
literal|0
condition|)
break|break;
name|tempChannelList
index|[
name|i
index|]
operator|=
name|pRdEdgesPower
index|[
name|i
index|]
operator|.
name|rdEdge
expr_stmt|;
block|}
name|numEdges
operator|=
name|i
expr_stmt|;
name|ar5212GetLowerUpperValues
argument_list|(
name|channel
argument_list|,
name|tempChannelList
argument_list|,
name|numEdges
argument_list|,
operator|&
name|clo
argument_list|,
operator|&
name|chi
argument_list|)
expr_stmt|;
comment|/* Get the index for the lower channel */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numEdges
operator|&&
name|clo
operator|!=
name|tempChannelList
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* Is lower channel ever outside the rdEdge? */
name|HALASSERT
argument_list|(
name|i
operator|!=
name|numEdges
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|clo
operator|==
name|chi
operator|&&
name|clo
operator|==
name|channel
operator|)
operator|||
operator|(
name|pRdEdgesPower
index|[
name|i
index|]
operator|.
name|flag
operator|)
condition|)
block|{
comment|/*  		 * If there's an exact channel match or an inband flag set 		 * on the lower channel use the given rdEdgePower  		 */
name|twiceMaxEdgePower
operator|=
name|pRdEdgesPower
index|[
name|i
index|]
operator|.
name|twice_rdEdgePower
expr_stmt|;
name|HALASSERT
argument_list|(
name|twiceMaxEdgePower
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|twiceMaxEdgePower
operator|=
name|MAX_RATE_POWER
expr_stmt|;
return|return
name|twiceMaxEdgePower
return|;
block|}
end_function

begin_comment
comment|/*  * Returns interpolated or the scaled up interpolated value  */
end_comment

begin_function
specifier|static
name|uint16_t
name|interpolate
parameter_list|(
name|uint16_t
name|target
parameter_list|,
name|uint16_t
name|srcLeft
parameter_list|,
name|uint16_t
name|srcRight
parameter_list|,
name|uint16_t
name|targetLeft
parameter_list|,
name|uint16_t
name|targetRight
parameter_list|)
block|{
name|uint16_t
name|rv
decl_stmt|;
name|int16_t
name|lRatio
decl_stmt|;
comment|/* to get an accurate ratio, always scale, if want to scale, then don't scale back down */
if|if
condition|(
operator|(
name|targetLeft
operator|*
name|targetRight
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|srcRight
operator|!=
name|srcLeft
condition|)
block|{
comment|/* 		 * Note the ratio always need to be scaled, 		 * since it will be a fraction. 		 */
name|lRatio
operator|=
operator|(
name|target
operator|-
name|srcLeft
operator|)
operator|*
name|EEP_SCALE
operator|/
operator|(
name|srcRight
operator|-
name|srcLeft
operator|)
expr_stmt|;
if|if
condition|(
name|lRatio
operator|<
literal|0
condition|)
block|{
comment|/* Return as Left target if value would be negative */
name|rv
operator|=
name|targetLeft
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lRatio
operator|>
name|EEP_SCALE
condition|)
block|{
comment|/* Return as Right target if Ratio is greater than 100% (SCALE) */
name|rv
operator|=
name|targetRight
expr_stmt|;
block|}
else|else
block|{
name|rv
operator|=
operator|(
name|lRatio
operator|*
name|targetRight
operator|+
operator|(
name|EEP_SCALE
operator|-
name|lRatio
operator|)
operator|*
name|targetLeft
operator|)
operator|/
name|EEP_SCALE
expr_stmt|;
block|}
block|}
else|else
block|{
name|rv
operator|=
name|targetLeft
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/*  * Return the four rates of target power for the given target power table   * channel, and number of channels  */
end_comment

begin_function
specifier|static
name|void
name|ar5212GetTargetPowers
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
specifier|const
name|TRGT_POWER_INFO
modifier|*
name|powInfo
parameter_list|,
name|uint16_t
name|numChannels
parameter_list|,
name|TRGT_POWER_INFO
modifier|*
name|pNewPower
parameter_list|)
block|{
name|uint16_t
name|freq
init|=
name|ath_hal_gethwchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
comment|/* temp array for holding target power channels */
name|uint16_t
name|tempChannelList
index|[
name|NUM_TEST_FREQUENCIES
index|]
decl_stmt|;
name|uint16_t
name|clo
decl_stmt|,
name|chi
decl_stmt|,
name|ixlo
decl_stmt|,
name|ixhi
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Copy the target powers into the temp channel list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numChannels
condition|;
name|i
operator|++
control|)
name|tempChannelList
index|[
name|i
index|]
operator|=
name|powInfo
index|[
name|i
index|]
operator|.
name|testChannel
expr_stmt|;
name|ar5212GetLowerUpperValues
argument_list|(
name|freq
argument_list|,
name|tempChannelList
argument_list|,
name|numChannels
argument_list|,
operator|&
name|clo
argument_list|,
operator|&
name|chi
argument_list|)
expr_stmt|;
comment|/* Get the indices for the channel */
name|ixlo
operator|=
name|ixhi
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numChannels
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|clo
operator|==
name|tempChannelList
index|[
name|i
index|]
condition|)
block|{
name|ixlo
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|chi
operator|==
name|tempChannelList
index|[
name|i
index|]
condition|)
block|{
name|ixhi
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Get the lower and upper channels, target powers, 	 * and interpolate between them. 	 */
name|pNewPower
operator|->
name|twicePwr6_24
operator|=
name|interpolate
argument_list|(
name|freq
argument_list|,
name|clo
argument_list|,
name|chi
argument_list|,
name|powInfo
index|[
name|ixlo
index|]
operator|.
name|twicePwr6_24
argument_list|,
name|powInfo
index|[
name|ixhi
index|]
operator|.
name|twicePwr6_24
argument_list|)
expr_stmt|;
name|pNewPower
operator|->
name|twicePwr36
operator|=
name|interpolate
argument_list|(
name|freq
argument_list|,
name|clo
argument_list|,
name|chi
argument_list|,
name|powInfo
index|[
name|ixlo
index|]
operator|.
name|twicePwr36
argument_list|,
name|powInfo
index|[
name|ixhi
index|]
operator|.
name|twicePwr36
argument_list|)
expr_stmt|;
name|pNewPower
operator|->
name|twicePwr48
operator|=
name|interpolate
argument_list|(
name|freq
argument_list|,
name|clo
argument_list|,
name|chi
argument_list|,
name|powInfo
index|[
name|ixlo
index|]
operator|.
name|twicePwr48
argument_list|,
name|powInfo
index|[
name|ixhi
index|]
operator|.
name|twicePwr48
argument_list|)
expr_stmt|;
name|pNewPower
operator|->
name|twicePwr54
operator|=
name|interpolate
argument_list|(
name|freq
argument_list|,
name|clo
argument_list|,
name|chi
argument_list|,
name|powInfo
index|[
name|ixlo
index|]
operator|.
name|twicePwr54
argument_list|,
name|powInfo
index|[
name|ixhi
index|]
operator|.
name|twicePwr54
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|udiff
parameter_list|(
name|uint32_t
name|u
parameter_list|,
name|uint32_t
name|v
parameter_list|)
block|{
return|return
operator|(
name|u
operator|>=
name|v
condition|?
name|u
operator|-
name|v
else|:
name|v
operator|-
name|u
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search a list for a specified value v that is within  * EEP_DELTA of the search values.  Return the closest  * values in the list above and below the desired value.  * EEP_DELTA is a factional value; everything is scaled  * so only integer arithmetic is used.  *  * NB: the input list is assumed to be sorted in ascending order  */
end_comment

begin_function
name|void
name|ar5212GetLowerUpperValues
parameter_list|(
name|uint16_t
name|v
parameter_list|,
name|uint16_t
modifier|*
name|lp
parameter_list|,
name|uint16_t
name|listSize
parameter_list|,
name|uint16_t
modifier|*
name|vlo
parameter_list|,
name|uint16_t
modifier|*
name|vhi
parameter_list|)
block|{
name|uint32_t
name|target
init|=
name|v
operator|*
name|EEP_SCALE
decl_stmt|;
name|uint16_t
modifier|*
name|ep
init|=
name|lp
operator|+
name|listSize
decl_stmt|;
comment|/* 	 * Check first and last elements for out-of-bounds conditions. 	 */
if|if
condition|(
name|target
operator|<
call|(
name|uint32_t
call|)
argument_list|(
name|lp
index|[
literal|0
index|]
operator|*
name|EEP_SCALE
operator|-
name|EEP_DELTA
argument_list|)
condition|)
block|{
operator|*
name|vlo
operator|=
operator|*
name|vhi
operator|=
name|lp
index|[
literal|0
index|]
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|target
operator|>
call|(
name|uint32_t
call|)
argument_list|(
name|ep
index|[
operator|-
literal|1
index|]
operator|*
name|EEP_SCALE
operator|+
name|EEP_DELTA
argument_list|)
condition|)
block|{
operator|*
name|vlo
operator|=
operator|*
name|vhi
operator|=
name|ep
index|[
operator|-
literal|1
index|]
expr_stmt|;
return|return;
block|}
comment|/* look for value being near or between 2 values in list */
for|for
control|(
init|;
name|lp
operator|<
name|ep
condition|;
name|lp
operator|++
control|)
block|{
comment|/* 		 * If value is close to the current value of the list 		 * then target is not between values, it is one of the values 		 */
if|if
condition|(
name|udiff
argument_list|(
name|lp
index|[
literal|0
index|]
operator|*
name|EEP_SCALE
argument_list|,
name|target
argument_list|)
operator|<
name|EEP_DELTA
condition|)
block|{
operator|*
name|vlo
operator|=
operator|*
name|vhi
operator|=
name|lp
index|[
literal|0
index|]
expr_stmt|;
return|return;
block|}
comment|/* 		 * Look for value being between current value and next value 		 * if so return these 2 values 		 */
if|if
condition|(
name|target
operator|<
call|(
name|uint32_t
call|)
argument_list|(
name|lp
index|[
literal|1
index|]
operator|*
name|EEP_SCALE
operator|-
name|EEP_DELTA
argument_list|)
condition|)
block|{
operator|*
name|vlo
operator|=
name|lp
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|vhi
operator|=
name|lp
index|[
literal|1
index|]
expr_stmt|;
return|return;
block|}
block|}
name|HALASSERT
argument_list|(
name|AH_FALSE
argument_list|)
expr_stmt|;
comment|/* should not reach here */
block|}
end_function

begin_comment
comment|/*  * Perform analog "swizzling" of parameters into their location  *  * NB: used by RF backends  */
end_comment

begin_function
name|void
name|ar5212ModifyRfBuffer
parameter_list|(
name|uint32_t
modifier|*
name|rfBuf
parameter_list|,
name|uint32_t
name|reg32
parameter_list|,
name|uint32_t
name|numBits
parameter_list|,
name|uint32_t
name|firstBit
parameter_list|,
name|uint32_t
name|column
parameter_list|)
block|{
define|#
directive|define
name|MAX_ANALOG_START
value|319
comment|/* XXX */
name|uint32_t
name|tmp32
decl_stmt|,
name|mask
decl_stmt|,
name|arrayEntry
decl_stmt|,
name|lastBit
decl_stmt|;
name|int32_t
name|bitPosition
decl_stmt|,
name|bitsLeft
decl_stmt|;
name|HALASSERT
argument_list|(
name|column
operator|<=
literal|3
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|numBits
operator|<=
literal|32
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|firstBit
operator|+
name|numBits
operator|<=
name|MAX_ANALOG_START
argument_list|)
expr_stmt|;
name|tmp32
operator|=
name|ath_hal_reverseBits
argument_list|(
name|reg32
argument_list|,
name|numBits
argument_list|)
expr_stmt|;
name|arrayEntry
operator|=
operator|(
name|firstBit
operator|-
literal|1
operator|)
operator|/
literal|8
expr_stmt|;
name|bitPosition
operator|=
operator|(
name|firstBit
operator|-
literal|1
operator|)
operator|%
literal|8
expr_stmt|;
name|bitsLeft
operator|=
name|numBits
expr_stmt|;
while|while
condition|(
name|bitsLeft
operator|>
literal|0
condition|)
block|{
name|lastBit
operator|=
operator|(
name|bitPosition
operator|+
name|bitsLeft
operator|>
literal|8
operator|)
condition|?
literal|8
else|:
name|bitPosition
operator|+
name|bitsLeft
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
operator|(
literal|1
operator|<<
name|lastBit
operator|)
operator|-
literal|1
operator|)
operator|^
operator|(
operator|(
literal|1
operator|<<
name|bitPosition
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|column
operator|*
literal|8
operator|)
expr_stmt|;
name|rfBuf
index|[
name|arrayEntry
index|]
operator|&=
operator|~
name|mask
expr_stmt|;
name|rfBuf
index|[
name|arrayEntry
index|]
operator||=
operator|(
operator|(
name|tmp32
operator|<<
name|bitPosition
operator|)
operator|<<
operator|(
name|column
operator|*
literal|8
operator|)
operator|)
operator|&
name|mask
expr_stmt|;
name|bitsLeft
operator|-=
literal|8
operator|-
name|bitPosition
expr_stmt|;
name|tmp32
operator|=
name|tmp32
operator|>>
operator|(
literal|8
operator|-
name|bitPosition
operator|)
expr_stmt|;
name|bitPosition
operator|=
literal|0
expr_stmt|;
name|arrayEntry
operator|++
expr_stmt|;
block|}
undef|#
directive|undef
name|MAX_ANALOG_START
block|}
end_function

begin_comment
comment|/*  * Sets the rate to duration values in MAC - used for multi-  * rate retry.  * The rate duration table needs to cover all valid rate codes;  * the 11g table covers all ofdm rates, while the 11b table  * covers all cck rates => all valid rates get covered between  * these two mode's ratetables!  * But if we're turbo, the ofdm phy is replaced by the turbo phy  * and cck is not valid with turbo => all rates get covered  * by the turbo ratetable only  */
end_comment

begin_function
name|void
name|ar5212SetRateDurationTable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* NB: band doesn't matter for 1/2 and 1/4 rate */
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|rt
operator|=
name|ar5212GetRateTable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11A_HALF_RATE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|rt
operator|=
name|ar5212GetRateTable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11A_QUARTER_RATE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rt
operator|=
name|ar5212GetRateTable
argument_list|(
name|ah
argument_list|,
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
condition|?
name|HAL_MODE_TURBO
else|:
name|HAL_MODE_11G
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rt
operator|->
name|rateCount
condition|;
operator|++
name|i
control|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RATE_DURATION
argument_list|(
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|rateCode
argument_list|)
argument_list|,
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|WLAN_CTRL_FRAME_SIZE
argument_list|,
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|controlRate
argument_list|,
name|AH_FALSE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* 11g Table is used to cover the CCK rates. */
name|rt
operator|=
name|ar5212GetRateTable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11G
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rt
operator|->
name|rateCount
condition|;
operator|++
name|i
control|)
block|{
name|uint32_t
name|reg
init|=
name|AR_RATE_DURATION
argument_list|(
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|rateCode
argument_list|)
decl_stmt|;
if|if
condition|(
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|phy
operator|!=
name|IEEE80211_T_CCK
condition|)
continue|continue;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|reg
argument_list|,
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|WLAN_CTRL_FRAME_SIZE
argument_list|,
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|controlRate
argument_list|,
name|AH_FALSE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* cck rates have short preamble option also */
if|if
condition|(
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|shortPreamble
condition|)
block|{
name|reg
operator|+=
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|shortPreamble
operator|<<
literal|2
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|reg
argument_list|,
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|WLAN_CTRL_FRAME_SIZE
argument_list|,
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|controlRate
argument_list|,
name|AH_TRUE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Adjust various register settings based on half/quarter rate clock setting.  * This includes: +USEC, TX/RX latency,   *                + IFS params: slot, eifs, misc etc.  */
end_comment

begin_function
name|void
name|ar5212SetIFSTiming
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|uint32_t
name|txLat
decl_stmt|,
name|rxLat
decl_stmt|,
name|usec
decl_stmt|,
name|slot
decl_stmt|,
name|refClock
decl_stmt|,
name|eifs
decl_stmt|,
name|init_usec
decl_stmt|;
name|HALASSERT
argument_list|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
operator|||
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
name|refClock
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_USEC
argument_list|)
operator|&
name|AR_USEC_USEC32
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|slot
operator|=
name|IFS_SLOT_HALF_RATE
expr_stmt|;
name|rxLat
operator|=
name|RX_NON_FULL_RATE_LATENCY
operator|<<
name|AR5212_USEC_RX_LAT_S
expr_stmt|;
name|txLat
operator|=
name|TX_HALF_RATE_LATENCY
operator|<<
name|AR5212_USEC_TX_LAT_S
expr_stmt|;
name|usec
operator|=
name|HALF_RATE_USEC
expr_stmt|;
name|eifs
operator|=
name|IFS_EIFS_HALF_RATE
expr_stmt|;
name|init_usec
operator|=
name|INIT_USEC
operator|>>
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* quarter rate */
name|slot
operator|=
name|IFS_SLOT_QUARTER_RATE
expr_stmt|;
name|rxLat
operator|=
name|RX_NON_FULL_RATE_LATENCY
operator|<<
name|AR5212_USEC_RX_LAT_S
expr_stmt|;
name|txLat
operator|=
name|TX_QUARTER_RATE_LATENCY
operator|<<
name|AR5212_USEC_TX_LAT_S
expr_stmt|;
name|usec
operator|=
name|QUARTER_RATE_USEC
expr_stmt|;
name|eifs
operator|=
name|IFS_EIFS_QUARTER_RATE
expr_stmt|;
name|init_usec
operator|=
name|INIT_USEC
operator|>>
literal|2
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_USEC
argument_list|,
operator|(
name|usec
operator||
name|refClock
operator||
name|txLat
operator||
name|rxLat
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_D_GBL_IFS_SLOT
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_D_GBL_IFS_EIFS
argument_list|,
name|eifs
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_D_GBL_IFS_MISC
argument_list|,
name|AR_D_GBL_IFS_MISC_USEC_DURATION
argument_list|,
name|init_usec
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

