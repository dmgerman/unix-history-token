begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2009 Rui Paulo<rpaulo@FreeBSD.org>  * Copyright (c) 2008 Sam Leffler, Errno Consulting  * Copyright (c) 2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_eeprom_v14.h"
end_include

begin_include
include|#
directive|include
file|"ah_eeprom_v4k.h"
end_include

begin_function
specifier|static
name|HAL_STATUS
name|v4kEepromGet
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|param
parameter_list|,
name|void
modifier|*
name|val
parameter_list|)
block|{
define|#
directive|define
name|CHAN_A_IDX
value|0
define|#
directive|define
name|CHAN_B_IDX
value|1
define|#
directive|define
name|IS_VERS
parameter_list|(
name|op
parameter_list|,
name|v
parameter_list|)
value|((pBase->version& AR5416_EEP_VER_MINOR_MASK) op (v))
name|HAL_EEPROM_v4k
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
specifier|const
name|MODAL_EEP4K_HEADER
modifier|*
name|pModal
init|=
operator|&
name|ee
operator|->
name|ee_base
operator|.
name|modalHeader
decl_stmt|;
specifier|const
name|BASE_EEP4K_HEADER
modifier|*
name|pBase
init|=
operator|&
name|ee
operator|->
name|ee_base
operator|.
name|baseEepHeader
decl_stmt|;
name|uint32_t
name|sum
decl_stmt|;
name|uint8_t
modifier|*
name|macaddr
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|AR_EEP_NFTHRESH_5
case|:
operator|*
operator|(
name|int16_t
operator|*
operator|)
name|val
operator|=
name|pModal
index|[
literal|0
index|]
operator|.
name|noiseFloorThreshCh
index|[
literal|0
index|]
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|AR_EEP_NFTHRESH_2
case|:
operator|*
operator|(
name|int16_t
operator|*
operator|)
name|val
operator|=
name|pModal
index|[
literal|1
index|]
operator|.
name|noiseFloorThreshCh
index|[
literal|0
index|]
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|AR_EEP_MACADDR
case|:
comment|/* Get MAC Address */
name|sum
operator|=
literal|0
expr_stmt|;
name|macaddr
operator|=
name|val
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|macaddr
index|[
name|i
index|]
operator|=
name|pBase
operator|->
name|macAddr
index|[
name|i
index|]
expr_stmt|;
name|sum
operator|+=
name|pBase
operator|->
name|macAddr
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|sum
operator|==
literal|0
operator|||
name|sum
operator|==
literal|0xffff
operator|*
literal|3
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: bad mac address %s\n"
argument_list|,
name|__func__
argument_list|,
name|ath_hal_ether_sprintf
argument_list|(
name|macaddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|HAL_EEBADMAC
return|;
block|}
return|return
name|HAL_OK
return|;
case|case
name|AR_EEP_REGDMN_0
case|:
return|return
name|pBase
operator|->
name|regDmn
index|[
literal|0
index|]
return|;
case|case
name|AR_EEP_REGDMN_1
case|:
return|return
name|pBase
operator|->
name|regDmn
index|[
literal|1
index|]
return|;
case|case
name|AR_EEP_OPCAP
case|:
return|return
name|pBase
operator|->
name|deviceCap
return|;
case|case
name|AR_EEP_OPMODE
case|:
return|return
name|pBase
operator|->
name|opCapFlags
return|;
case|case
name|AR_EEP_RFSILENT
case|:
return|return
name|pBase
operator|->
name|rfSilent
return|;
case|case
name|AR_EEP_OB_5
case|:
return|return
name|pModal
index|[
name|CHAN_A_IDX
index|]
operator|.
name|ob
return|;
case|case
name|AR_EEP_DB_5
case|:
return|return
name|pModal
index|[
name|CHAN_A_IDX
index|]
operator|.
name|db
return|;
case|case
name|AR_EEP_OB_2
case|:
return|return
name|pModal
index|[
name|CHAN_B_IDX
index|]
operator|.
name|ob
return|;
case|case
name|AR_EEP_DB_2
case|:
return|return
name|pModal
index|[
name|CHAN_B_IDX
index|]
operator|.
name|db
return|;
case|case
name|AR_EEP_TXMASK
case|:
return|return
name|pBase
operator|->
name|txMask
return|;
case|case
name|AR_EEP_RXMASK
case|:
return|return
name|pBase
operator|->
name|rxMask
return|;
case|case
name|AR_EEP_RXGAIN_TYPE
case|:
return|return
name|AR5416_EEP_RXGAIN_ORIG
return|;
case|case
name|AR_EEP_TXGAIN_TYPE
case|:
return|return
name|IS_VERS
argument_list|(
operator|>=
argument_list|,
name|AR5416_EEP_MINOR_VER_19
argument_list|)
condition|?
name|pBase
operator|->
name|txGainType
else|:
name|AR5416_EEP_TXGAIN_ORIG
return|;
if|#
directive|if
literal|0
block|case AR_EEP_OL_PWRCTRL: 		HALASSERT(val == AH_NULL); 		return pBase->openLoopPwrCntl ?  HAL_OK : HAL_EIO;
endif|#
directive|endif
case|case
name|AR_EEP_AMODE
case|:
name|HALASSERT
argument_list|(
name|val
operator|==
name|AH_NULL
argument_list|)
expr_stmt|;
return|return
name|pBase
operator|->
name|opCapFlags
operator|&
name|AR5416_OPFLAGS_11A
condition|?
name|HAL_OK
else|:
name|HAL_EIO
return|;
case|case
name|AR_EEP_BMODE
case|:
case|case
name|AR_EEP_GMODE
case|:
name|HALASSERT
argument_list|(
name|val
operator|==
name|AH_NULL
argument_list|)
expr_stmt|;
return|return
name|pBase
operator|->
name|opCapFlags
operator|&
name|AR5416_OPFLAGS_11G
condition|?
name|HAL_OK
else|:
name|HAL_EIO
return|;
case|case
name|AR_EEP_32KHZCRYSTAL
case|:
case|case
name|AR_EEP_COMPRESS
case|:
case|case
name|AR_EEP_FASTFRAME
case|:
comment|/* XXX policy decision, h/w can do it */
case|case
name|AR_EEP_WRITEPROTECT
case|:
comment|/* NB: no write protect bit */
name|HALASSERT
argument_list|(
name|val
operator|==
name|AH_NULL
argument_list|)
expr_stmt|;
comment|/* fall thru... */
case|case
name|AR_EEP_MAXQCU
case|:
comment|/* NB: not in opCapFlags */
case|case
name|AR_EEP_KCENTRIES
case|:
comment|/* NB: not in opCapFlags */
return|return
name|HAL_EIO
return|;
case|case
name|AR_EEP_AES
case|:
case|case
name|AR_EEP_BURST
case|:
case|case
name|AR_EEP_RFKILL
case|:
case|case
name|AR_EEP_TURBO5DISABLE
case|:
case|case
name|AR_EEP_TURBO2DISABLE
case|:
name|HALASSERT
argument_list|(
name|val
operator|==
name|AH_NULL
argument_list|)
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|AR_EEP_ANTGAINMAX_2
case|:
operator|*
operator|(
name|int8_t
operator|*
operator|)
name|val
operator|=
name|ee
operator|->
name|ee_antennaGainMax
index|[
literal|1
index|]
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|AR_EEP_ANTGAINMAX_5
case|:
operator|*
operator|(
name|int8_t
operator|*
operator|)
name|val
operator|=
name|ee
operator|->
name|ee_antennaGainMax
index|[
literal|0
index|]
expr_stmt|;
return|return
name|HAL_OK
return|;
default|default:
name|HALASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|HAL_EINVAL
return|;
block|}
undef|#
directive|undef
name|IS_VERS
undef|#
directive|undef
name|CHAN_A_IDX
undef|#
directive|undef
name|CHAN_B_IDX
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|v4kEepromSet
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|param
parameter_list|,
name|int
name|v
parameter_list|)
block|{
name|HAL_EEPROM_v4k
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|AR_EEP_ANTGAINMAX_2
case|:
name|ee
operator|->
name|ee_antennaGainMax
index|[
literal|1
index|]
operator|=
operator|(
name|int8_t
operator|)
name|v
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|AR_EEP_ANTGAINMAX_5
case|:
name|ee
operator|->
name|ee_antennaGainMax
index|[
literal|0
index|]
operator|=
operator|(
name|int8_t
operator|)
name|v
expr_stmt|;
return|return
name|HAL_OK
return|;
block|}
return|return
name|HAL_EINVAL
return|;
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|v4kEepromDiag
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|request
parameter_list|,
specifier|const
name|void
modifier|*
name|args
parameter_list|,
name|uint32_t
name|argsize
parameter_list|,
name|void
modifier|*
modifier|*
name|result
parameter_list|,
name|uint32_t
modifier|*
name|resultsize
parameter_list|)
block|{
name|HAL_EEPROM_v4k
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
switch|switch
condition|(
name|request
condition|)
block|{
case|case
name|HAL_DIAG_EEPROM
case|:
operator|*
name|result
operator|=
operator|&
name|ee
operator|->
name|ee_base
expr_stmt|;
operator|*
name|resultsize
operator|=
sizeof|sizeof
argument_list|(
name|ee
operator|->
name|ee_base
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/* Do structure specific swaps if Eeprom format is non native to host */
end_comment

begin_function
specifier|static
name|void
name|eepromSwap
parameter_list|(
name|struct
name|ar5416eeprom_4k
modifier|*
name|ee
parameter_list|)
block|{
name|uint32_t
name|integer
decl_stmt|,
name|i
decl_stmt|;
name|uint16_t
name|word
decl_stmt|;
name|MODAL_EEP4K_HEADER
modifier|*
name|pModal
decl_stmt|;
comment|/* convert Base Eep header */
name|word
operator|=
name|__bswap16
argument_list|(
name|ee
operator|->
name|baseEepHeader
operator|.
name|length
argument_list|)
expr_stmt|;
name|ee
operator|->
name|baseEepHeader
operator|.
name|length
operator|=
name|word
expr_stmt|;
name|word
operator|=
name|__bswap16
argument_list|(
name|ee
operator|->
name|baseEepHeader
operator|.
name|checksum
argument_list|)
expr_stmt|;
name|ee
operator|->
name|baseEepHeader
operator|.
name|checksum
operator|=
name|word
expr_stmt|;
name|word
operator|=
name|__bswap16
argument_list|(
name|ee
operator|->
name|baseEepHeader
operator|.
name|version
argument_list|)
expr_stmt|;
name|ee
operator|->
name|baseEepHeader
operator|.
name|version
operator|=
name|word
expr_stmt|;
name|word
operator|=
name|__bswap16
argument_list|(
name|ee
operator|->
name|baseEepHeader
operator|.
name|regDmn
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ee
operator|->
name|baseEepHeader
operator|.
name|regDmn
index|[
literal|0
index|]
operator|=
name|word
expr_stmt|;
name|word
operator|=
name|__bswap16
argument_list|(
name|ee
operator|->
name|baseEepHeader
operator|.
name|regDmn
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ee
operator|->
name|baseEepHeader
operator|.
name|regDmn
index|[
literal|1
index|]
operator|=
name|word
expr_stmt|;
name|word
operator|=
name|__bswap16
argument_list|(
name|ee
operator|->
name|baseEepHeader
operator|.
name|rfSilent
argument_list|)
expr_stmt|;
name|ee
operator|->
name|baseEepHeader
operator|.
name|rfSilent
operator|=
name|word
expr_stmt|;
name|word
operator|=
name|__bswap16
argument_list|(
name|ee
operator|->
name|baseEepHeader
operator|.
name|blueToothOptions
argument_list|)
expr_stmt|;
name|ee
operator|->
name|baseEepHeader
operator|.
name|blueToothOptions
operator|=
name|word
expr_stmt|;
name|word
operator|=
name|__bswap16
argument_list|(
name|ee
operator|->
name|baseEepHeader
operator|.
name|deviceCap
argument_list|)
expr_stmt|;
name|ee
operator|->
name|baseEepHeader
operator|.
name|deviceCap
operator|=
name|word
expr_stmt|;
comment|/* convert Modal Eep header */
name|pModal
operator|=
operator|&
name|ee
operator|->
name|modalHeader
expr_stmt|;
comment|/* XXX linux/ah_osdep.h only defines __bswap32 for BE */
name|integer
operator|=
name|__bswap32
argument_list|(
name|pModal
operator|->
name|antCtrlCommon
argument_list|)
expr_stmt|;
name|pModal
operator|->
name|antCtrlCommon
operator|=
name|integer
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR5416_4K_MAX_CHAINS
condition|;
name|i
operator|++
control|)
block|{
name|integer
operator|=
name|__bswap32
argument_list|(
name|pModal
operator|->
name|antCtrlChain
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pModal
operator|->
name|antCtrlChain
index|[
name|i
index|]
operator|=
name|integer
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR5416_EEPROM_MODAL_SPURS
condition|;
name|i
operator|++
control|)
block|{
name|word
operator|=
name|__bswap16
argument_list|(
name|pModal
operator|->
name|spurChans
index|[
name|i
index|]
operator|.
name|spurChan
argument_list|)
expr_stmt|;
name|pModal
operator|->
name|spurChans
index|[
name|i
index|]
operator|.
name|spurChan
operator|=
name|word
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|v4kEepromGetSpurChan
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|ix
parameter_list|,
name|HAL_BOOL
name|is2GHz
parameter_list|)
block|{
name|HAL_EEPROM_v4k
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|HALASSERT
argument_list|(
literal|0
operator|<=
name|ix
operator|&&
name|ix
operator|<
name|AR5416_EEPROM_MODAL_SPURS
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|is2GHz
argument_list|)
expr_stmt|;
return|return
name|ee
operator|->
name|ee_base
operator|.
name|modalHeader
operator|.
name|spurChans
index|[
name|ix
index|]
operator|.
name|spurChan
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************  * fbin2freq  *  * Get channel value from binary representation held in eeprom  * RETURNS: the frequency in MHz  */
end_comment

begin_function
specifier|static
name|uint16_t
name|fbin2freq
parameter_list|(
name|uint8_t
name|fbin
parameter_list|,
name|HAL_BOOL
name|is2GHz
parameter_list|)
block|{
comment|/* 	 * Reserved value 0xFF provides an empty definition both as 	 * an fbin and as a frequency - do not convert 	 */
if|if
condition|(
name|fbin
operator|==
name|AR5416_BCHAN_UNUSED
condition|)
return|return
name|fbin
return|;
return|return
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|is2GHz
operator|)
condition|?
operator|(
literal|2300
operator|+
name|fbin
operator|)
else|:
operator|(
literal|4800
operator|+
literal|5
operator|*
name|fbin
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy EEPROM Conformance Testing Limits contents   * into the allocated space  */
end_comment

begin_comment
comment|/* USE CTLS from chain zero */
end_comment

begin_define
define|#
directive|define
name|CTL_CHAIN
value|0
end_define

begin_function
specifier|static
name|void
name|v4kEepromReadCTLInfo
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_EEPROM_v4k
modifier|*
name|ee
parameter_list|)
block|{
name|RD_EDGES_POWER
modifier|*
name|rep
init|=
name|ee
operator|->
name|ee_rdEdgesPower
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|HALASSERT
argument_list|(
name|AR5416_NUM_CTLS
operator|<=
sizeof|sizeof
argument_list|(
name|ee
operator|->
name|ee_rdEdgesPower
argument_list|)
operator|/
name|NUM_EDGES
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ee
operator|->
name|ee_base
operator|.
name|ctlIndex
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|i
operator|<
name|AR5416_4K_NUM_CTLS
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_EDGES
condition|;
name|j
operator|++
control|)
block|{
comment|/* XXX Confirm this is the right thing to do when an invalid channel is stored */
if|if
condition|(
name|ee
operator|->
name|ee_base
operator|.
name|ctlData
index|[
name|i
index|]
operator|.
name|ctlEdges
index|[
name|CTL_CHAIN
index|]
index|[
name|j
index|]
operator|.
name|bChannel
operator|==
name|AR5416_BCHAN_UNUSED
condition|)
block|{
name|rep
index|[
name|j
index|]
operator|.
name|rdEdge
operator|=
literal|0
expr_stmt|;
name|rep
index|[
name|j
index|]
operator|.
name|twice_rdEdgePower
operator|=
literal|0
expr_stmt|;
name|rep
index|[
name|j
index|]
operator|.
name|flag
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rep
index|[
name|j
index|]
operator|.
name|rdEdge
operator|=
name|fbin2freq
argument_list|(
name|ee
operator|->
name|ee_base
operator|.
name|ctlData
index|[
name|i
index|]
operator|.
name|ctlEdges
index|[
name|CTL_CHAIN
index|]
index|[
name|j
index|]
operator|.
name|bChannel
argument_list|,
operator|(
name|ee
operator|->
name|ee_base
operator|.
name|ctlIndex
index|[
name|i
index|]
operator|&
name|CTL_MODE_M
operator|)
operator|!=
name|CTL_11A
argument_list|)
expr_stmt|;
name|rep
index|[
name|j
index|]
operator|.
name|twice_rdEdgePower
operator|=
name|MS
argument_list|(
name|ee
operator|->
name|ee_base
operator|.
name|ctlData
index|[
name|i
index|]
operator|.
name|ctlEdges
index|[
name|CTL_CHAIN
index|]
index|[
name|j
index|]
operator|.
name|tPowerFlag
argument_list|,
name|CAL_CTL_EDGES_POWER
argument_list|)
expr_stmt|;
name|rep
index|[
name|j
index|]
operator|.
name|flag
operator|=
name|MS
argument_list|(
name|ee
operator|->
name|ee_base
operator|.
name|ctlData
index|[
name|i
index|]
operator|.
name|ctlEdges
index|[
name|CTL_CHAIN
index|]
index|[
name|j
index|]
operator|.
name|tPowerFlag
argument_list|,
name|CAL_CTL_EDGES_FLAG
argument_list|)
operator|!=
literal|0
expr_stmt|;
block|}
block|}
name|rep
operator|+=
name|NUM_EDGES
expr_stmt|;
block|}
name|ee
operator|->
name|ee_numCtls
operator|=
name|i
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ATTACH
operator||
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s Numctls = %u\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim any EEPROM-related storage.  */
end_comment

begin_function
specifier|static
name|void
name|v4kEepromDetach
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|HAL_EEPROM_v4k
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|ath_hal_free
argument_list|(
name|ee
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
operator|=
name|AH_NULL
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|owl_get_eep_ver
parameter_list|(
name|_ee
parameter_list|)
define|\
value|(((_ee)->ee_base.baseEepHeader.version>> 12)& 0xF)
end_define

begin_define
define|#
directive|define
name|owl_get_eep_rev
parameter_list|(
name|_ee
parameter_list|)
define|\
value|(((_ee)->ee_base.baseEepHeader.version)& 0xFFF)
end_define

begin_function
name|HAL_STATUS
name|ath_hal_v4kEepromAttach
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
define|#
directive|define
name|NW
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a) / sizeof(uint16_t))
name|HAL_EEPROM_v4k
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|uint16_t
modifier|*
name|eep_data
decl_stmt|,
name|magic
decl_stmt|;
name|HAL_BOOL
name|need_swap
decl_stmt|;
name|u_int
name|w
decl_stmt|,
name|off
decl_stmt|,
name|len
decl_stmt|;
name|uint32_t
name|sum
decl_stmt|;
name|HALASSERT
argument_list|(
name|ee
operator|==
name|AH_NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_eepromRead
argument_list|(
name|ah
argument_list|,
name|AR5416_EEPROM_MAGIC_OFFSET
argument_list|,
operator|&
name|magic
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s Error reading Eeprom MAGIC\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|HAL_EEREAD
return|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ATTACH
argument_list|,
literal|"%s Eeprom Magic = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|magic
operator|!=
name|AR5416_EEPROM_MAGIC
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"Bad magic number\n"
argument_list|)
expr_stmt|;
return|return
name|HAL_EEMAGIC
return|;
block|}
name|ee
operator|=
name|ath_hal_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HAL_EEPROM_v4k
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ee
operator|==
name|AH_NULL
condition|)
block|{
comment|/* XXX message */
return|return
name|HAL_ENOMEM
return|;
block|}
name|eep_data
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|ee
operator|->
name|ee_base
expr_stmt|;
for|for
control|(
name|w
operator|=
literal|0
init|;
name|w
operator|<
name|NW
argument_list|(
expr|struct
name|ar5416eeprom_4k
argument_list|)
condition|;
name|w
operator|++
control|)
block|{
name|off
operator|=
name|owl_eep_start_loc
operator|+
name|w
expr_stmt|;
comment|/* NB: AP71 starts at 0 */
if|if
condition|(
operator|!
name|ath_hal_eepromRead
argument_list|(
name|ah
argument_list|,
name|off
argument_list|,
operator|&
name|eep_data
index|[
name|w
index|]
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s eeprom read error at offset 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
name|HAL_EEREAD
return|;
block|}
block|}
comment|/* Convert to eeprom native eeprom endian format */
if|if
condition|(
name|isBigEndian
argument_list|()
condition|)
block|{
for|for
control|(
name|w
operator|=
literal|0
init|;
name|w
operator|<
name|NW
argument_list|(
expr|struct
name|ar5416eeprom_4k
argument_list|)
condition|;
name|w
operator|++
control|)
name|eep_data
index|[
name|w
index|]
operator|=
name|__bswap16
argument_list|(
name|eep_data
index|[
name|w
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * At this point, we're in the native eeprom endian format 	 * Now, determine the eeprom endian by looking at byte 26?? 	 */
name|need_swap
operator|=
operator|(
operator|(
name|ee
operator|->
name|ee_base
operator|.
name|baseEepHeader
operator|.
name|eepMisc
operator|&
name|AR5416_EEPMISC_BIG_ENDIAN
operator|)
operator|!=
literal|0
operator|)
operator|^
name|isBigEndian
argument_list|()
expr_stmt|;
if|if
condition|(
name|need_swap
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ATTACH
operator||
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"Byte swap EEPROM contents.\n"
argument_list|)
expr_stmt|;
name|len
operator|=
name|__bswap16
argument_list|(
name|ee
operator|->
name|ee_base
operator|.
name|baseEepHeader
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|ee
operator|->
name|ee_base
operator|.
name|baseEepHeader
operator|.
name|length
expr_stmt|;
block|}
name|len
operator|=
name|AH_MIN
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar5416eeprom_4k
argument_list|)
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
comment|/* Apply the checksum, done in native eeprom format */
comment|/* XXX - Need to check to make sure checksum calculation is done 	 * in the correct endian format.  Right now, it seems it would 	 * cast the raw data to host format and do the calculation, which may 	 * not be correct as the calculation may need to be done in the native 	 * eeprom format  	 */
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|w
operator|=
literal|0
init|;
name|w
operator|<
name|len
condition|;
name|w
operator|++
control|)
block|{
name|sum
operator|^=
name|eep_data
index|[
name|w
index|]
expr_stmt|;
block|}
comment|/* Check CRC - Attach should fail on a bad checksum */
if|if
condition|(
name|sum
operator|!=
literal|0xffff
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"Bad EEPROM checksum 0x%x (Len=%u)\n"
argument_list|,
name|sum
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|HAL_EEBADSUM
return|;
block|}
if|if
condition|(
name|need_swap
condition|)
name|eepromSwap
argument_list|(
operator|&
name|ee
operator|->
name|ee_base
argument_list|)
expr_stmt|;
comment|/* byte swap multi-byte data */
comment|/* swap words 0+2 so version is at the front */
name|magic
operator|=
name|eep_data
index|[
literal|0
index|]
expr_stmt|;
name|eep_data
index|[
literal|0
index|]
operator|=
name|eep_data
index|[
literal|2
index|]
expr_stmt|;
name|eep_data
index|[
literal|2
index|]
operator|=
name|magic
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ATTACH
operator||
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s Eeprom Version %u.%u\n"
argument_list|,
name|__func__
argument_list|,
name|owl_get_eep_ver
argument_list|(
name|ee
argument_list|)
argument_list|,
name|owl_get_eep_rev
argument_list|(
name|ee
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NB: must be after all byte swapping */
if|if
condition|(
name|owl_get_eep_ver
argument_list|(
name|ee
argument_list|)
operator|!=
name|AR5416_EEP_VER
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"Bad EEPROM version 0x%x\n"
argument_list|,
name|owl_get_eep_ver
argument_list|(
name|ee
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|HAL_EEBADSUM
return|;
block|}
name|v4kEepromReadCTLInfo
argument_list|(
name|ah
argument_list|,
name|ee
argument_list|)
expr_stmt|;
comment|/* Get CTLs */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
operator|=
name|ee
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeversion
operator|=
name|ee
operator|->
name|ee_base
operator|.
name|baseEepHeader
operator|.
name|version
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eepromDetach
operator|=
name|v4kEepromDetach
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eepromGet
operator|=
name|v4kEepromGet
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eepromSet
operator|=
name|v4kEepromSet
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_getSpurChan
operator|=
name|v4kEepromGetSpurChan
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eepromDiag
operator|=
name|v4kEepromDiag
expr_stmt|;
return|return
name|HAL_OK
return|;
undef|#
directive|undef
name|NW
block|}
end_function

end_unit

