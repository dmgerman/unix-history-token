begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2008-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_comment
comment|/*  * NB: Merlin and later have a simpler RF backend.  */
end_comment

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_eeprom_v14.h"
end_include

begin_include
include|#
directive|include
file|"ar9002/ar9280.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416phy.h"
end_include

begin_define
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
end_define

begin_struct
struct|struct
name|ar9280State
block|{
name|RF_HAL_FUNCS
name|base
decl_stmt|;
comment|/* public state, must be first */
name|uint16_t
name|pcdacTable
index|[
literal|1
index|]
decl_stmt|;
comment|/* XXX */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|AR9280
parameter_list|(
name|ah
parameter_list|)
value|((struct ar9280State *) AH5212(ah)->ah_rfHal)
end_define

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar9280GetChannelMaxMinPower
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
parameter_list|,
name|int16_t
modifier|*
name|maxPow
parameter_list|,
name|int16_t
modifier|*
name|minPow
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int16_t
name|ar9280GetNfAdjust
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_CHANNEL_INTERNAL
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|ar9280WriteRegs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|modesIndex
parameter_list|,
name|u_int
name|freqIndex
parameter_list|,
name|int
name|writes
parameter_list|)
block|{
operator|(
name|void
operator|)
name|ath_hal_ini_write
argument_list|(
name|ah
argument_list|,
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_bb_rfgain
argument_list|,
name|freqIndex
argument_list|,
name|writes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take the MHz channel value and set the Channel value  *  * ASSUMES: Writes enabled to analog bus  *  * Actual Expression,  *  * For 2GHz channel,   * Channel Frequency = (3/4) * freq_ref * (chansel[8:0] + chanfrac[16:0]/2^17)   * (freq_ref = 40MHz)  *  * For 5GHz channel,  * Channel Frequency = (3/2) * freq_ref * (chansel[8:0] + chanfrac[16:0]/2^10)  * (freq_ref = 40MHz/(24>>amodeRefSel))  *  * For 5GHz channels which are 5MHz spaced,  * Channel Frequency = (3/2) * freq_ref * (chansel[8:0] + chanfrac[16:0]/2^17)  * (freq_ref = 40MHz)  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar9280SetChannel
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|uint16_t
name|bMode
decl_stmt|,
name|fracMode
decl_stmt|,
name|aModeRefSel
init|=
literal|0
decl_stmt|;
name|uint32_t
name|freq
decl_stmt|,
name|ndiv
decl_stmt|,
name|channelSel
init|=
literal|0
decl_stmt|,
name|channelFrac
init|=
literal|0
decl_stmt|,
name|reg32
init|=
literal|0
decl_stmt|;
name|CHAN_CENTERS
name|centers
decl_stmt|;
name|uint32_t
name|refDivA
init|=
literal|24
decl_stmt|;
name|uint8_t
name|frac_n_5g
decl_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_SETCHANNEL
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|ar5416GetChannelCenters
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|&
name|centers
argument_list|)
expr_stmt|;
name|freq
operator|=
name|centers
operator|.
name|synth_center
expr_stmt|;
name|reg32
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SYNTH_CONTROL
argument_list|)
expr_stmt|;
name|reg32
operator|&=
literal|0xc0000000
expr_stmt|;
if|if
condition|(
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_FRAC_N_5G
argument_list|,
operator|&
name|frac_n_5g
argument_list|)
operator|!=
name|HAL_OK
condition|)
name|frac_n_5g
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|freq
operator|<
literal|4800
condition|)
block|{
comment|/* 2 GHz, fractional mode */
name|uint32_t
name|txctl
decl_stmt|;
name|bMode
operator|=
literal|1
expr_stmt|;
name|fracMode
operator|=
literal|1
expr_stmt|;
name|aModeRefSel
operator|=
literal|0
expr_stmt|;
name|channelSel
operator|=
operator|(
name|freq
operator|*
literal|0x10000
operator|)
operator|/
literal|15
expr_stmt|;
name|txctl
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_TX_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq
operator|==
literal|2484
condition|)
block|{
comment|/* Enable channel spreading for channel 14 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_TX_CTRL
argument_list|,
name|txctl
operator||
name|AR_PHY_CCK_TX_CTRL_JAPAN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_TX_CTRL
argument_list|,
name|txctl
operator|&
operator|~
name|AR_PHY_CCK_TX_CTRL_JAPAN
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|bMode
operator|=
literal|0
expr_stmt|;
name|fracMode
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|frac_n_5g
condition|)
block|{
case|case
literal|0
case|:
comment|/* 			 * Enable fractional mode for half/quarter rate 			 * channels. 			 * 			 * This is from the Linux ath9k code, rather than 			 * the Atheros HAL code. 			 */
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|chan
argument_list|)
operator|||
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
condition|)
name|aModeRefSel
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|freq
operator|%
literal|20
operator|)
operator|==
literal|0
condition|)
block|{
name|aModeRefSel
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|freq
operator|%
literal|10
operator|)
operator|==
literal|0
condition|)
block|{
name|aModeRefSel
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|aModeRefSel
condition|)
break|break;
case|case
literal|1
case|:
default|default:
name|aModeRefSel
operator|=
literal|0
expr_stmt|;
comment|/* Enable 2G (fractional) mode for channels which are 5MHz spaced */
comment|/* 			 * Workaround for talking on PSB non-5MHz channels; 			 * the pre-Merlin chips only had a 2.5MHz channel 			 * spacing so some channels aren't reachable.  			 * 			 * This interoperates on the quarter rate channels 			 * with the AR5112 and later RF synths.  Please note 			 * that the synthesiser isn't able to completely 			 * accurately represent these frequencies (as the 			 * resolution in this reference is 2.5MHz) and thus 			 * it will be slightly "off centre."  This matches 			 * the same slightly incorrect centre frequency 			 * behaviour that the AR5112 and later channel 			 * selection code has. 			 * 			 * This also interoperates with the AR5416 			 * synthesiser modification for programming 			 * fractional frequencies in 5GHz mode.  However 			 * that modification is also disabled by default. 			 * 			 * This is disabled because it hasn't been tested for 			 * regulatory compliance and neither have the NICs 			 * which would use it.  So if you enable this code, 			 * you must first ensure that you've re-certified the 			 * NICs in question beforehand or you will be 			 * violating your local regulatory rules and breaking 			 * the law. 			 */
if|#
directive|if
literal|0
block|if (freq % 5 == 0) {
endif|#
directive|endif
comment|/* Normal */
name|fracMode
operator|=
literal|1
expr_stmt|;
name|refDivA
operator|=
literal|1
expr_stmt|;
name|channelSel
operator|=
operator|(
name|freq
operator|*
literal|0x8000
operator|)
operator|/
literal|15
expr_stmt|;
if|#
directive|if
literal|0
block|} else {
comment|/* Offset by 500KHz */
block|uint32_t f, ch, ch2;  				fracMode = 1; 				refDivA = 1;
comment|/* Calculate the "adjusted" frequency */
block|f = freq - 2; 				ch = (((f - 4800) * 10) / 25) + 1;  				ch2 = ((ch * 25) / 5) + 9600; 				channelSel = (ch2 * 0x4000) / 15;
comment|//ath_hal_printf(ah,
comment|//    "%s: freq=%d, ch=%d, ch2=%d, "
comment|//    "channelSel=%d\n",
comment|//    __func__, freq, ch, ch2, channelSel);
block|}
endif|#
directive|endif
comment|/* RefDivA setting */
name|OS_A_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_AN_SYNTH9
argument_list|,
name|AR_AN_SYNTH9_REFDIVA
argument_list|,
name|refDivA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fracMode
condition|)
block|{
name|ndiv
operator|=
operator|(
name|freq
operator|*
operator|(
name|refDivA
operator|>>
name|aModeRefSel
operator|)
operator|)
operator|/
literal|60
expr_stmt|;
name|channelSel
operator|=
name|ndiv
operator|&
literal|0x1ff
expr_stmt|;
name|channelFrac
operator|=
operator|(
name|ndiv
operator|&
literal|0xfffffe00
operator|)
operator|*
literal|2
expr_stmt|;
name|channelSel
operator|=
operator|(
name|channelSel
operator|<<
literal|17
operator|)
operator||
name|channelFrac
expr_stmt|;
block|}
block|}
name|reg32
operator|=
name|reg32
operator||
operator|(
name|bMode
operator|<<
literal|29
operator|)
operator||
operator|(
name|fracMode
operator|<<
literal|28
operator|)
operator||
operator|(
name|aModeRefSel
operator|<<
literal|26
operator|)
operator||
operator|(
name|channelSel
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SYNTH_CONTROL
argument_list|,
name|reg32
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|=
name|chan
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Return a reference to the requested RF Bank.  */
end_comment

begin_function
specifier|static
name|uint32_t
modifier|*
name|ar9280GetRfBank
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|bank
parameter_list|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: unknown RF Bank %d requested\n"
argument_list|,
name|__func__
argument_list|,
name|bank
argument_list|)
expr_stmt|;
return|return
name|AH_NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Reads EEPROM header info from device structure and programs  * all rf registers  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar9280SetRfRegs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|uint16_t
name|modesIndex
parameter_list|,
name|uint16_t
modifier|*
name|rfXpdGain
parameter_list|)
block|{
return|return
name|AH_TRUE
return|;
comment|/* nothing to do */
block|}
end_function

begin_comment
comment|/*  * Read the transmit power levels from the structures taken from EEPROM  * Interpolate read transmit power values for this channel  * Organize the transmit power values into a table for writing into the hardware  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar9280SetPowerTable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int16_t
modifier|*
name|pPowerMin
parameter_list|,
name|int16_t
modifier|*
name|pPowerMax
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|uint16_t
modifier|*
name|rfXpdGain
parameter_list|)
block|{
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static int16_t ar9280GetMinPower(struct ath_hal *ah, EXPN_DATA_PER_CHANNEL_5112 *data) {     int i, minIndex;     int16_t minGain,minPwr,minPcdac,retVal;
comment|/* Assume NUM_POINTS_XPD0> 0 */
end_comment

begin_endif
unit|minGain = data->pDataPerXPD[0].xpd_gain;     for (minIndex=0,i=1; i<NUM_XPD_PER_CHANNEL; i++) {         if (data->pDataPerXPD[i].xpd_gain< minGain) {             minIndex = i;             minGain = data->pDataPerXPD[i].xpd_gain;         }     }     minPwr = data->pDataPerXPD[minIndex].pwr_t4[0];     minPcdac = data->pDataPerXPD[minIndex].pcdac[0];     for (i=1; i<NUM_POINTS_XPD0; i++) {         if (data->pDataPerXPD[minIndex].pwr_t4[i]< minPwr) {             minPwr = data->pDataPerXPD[minIndex].pwr_t4[i];             minPcdac = data->pDataPerXPD[minIndex].pcdac[i];         }     }     retVal = minPwr - (minPcdac*2);     return(retVal); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|HAL_BOOL
name|ar9280GetChannelMaxMinPower
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|int16_t
modifier|*
name|maxPow
parameter_list|,
name|int16_t
modifier|*
name|minPow
parameter_list|)
block|{
if|#
directive|if
literal|0
block|struct ath_hal_5212 *ahp = AH5212(ah);     int numChannels=0,i,last;     int totalD, totalF,totalMin;     EXPN_DATA_PER_CHANNEL_5112 *data=AH_NULL;     EEPROM_POWER_EXPN_5112 *powerArray=AH_NULL;      *maxPow = 0;     if (IS_CHAN_A(chan)) {         powerArray = ahp->ah_modePowerArray5112;         data = powerArray[headerInfo11A].pDataPerChannel;         numChannels = powerArray[headerInfo11A].numChannels;     } else if (IS_CHAN_G(chan) || IS_CHAN_108G(chan)) {
comment|/* XXX - is this correct? Should we also use the same power for turbo G? */
block|powerArray = ahp->ah_modePowerArray5112;         data = powerArray[headerInfo11G].pDataPerChannel;         numChannels = powerArray[headerInfo11G].numChannels;     } else if (IS_CHAN_B(chan)) {         powerArray = ahp->ah_modePowerArray5112;         data = powerArray[headerInfo11B].pDataPerChannel;         numChannels = powerArray[headerInfo11B].numChannels;     } else {         return (AH_TRUE);     }
comment|/* Make sure the channel is in the range of the TP values      *  (freq piers)      */
block|if ((numChannels< 1) ||         (chan->channel< data[0].channelValue) ||         (chan->channel> data[numChannels-1].channelValue))         return(AH_FALSE);
comment|/* Linearly interpolate the power value now */
block|for (last=0,i=0;          (i<numChannels)&& (chan->channel> data[i].channelValue);          last=i++);     totalD = data[i].channelValue - data[last].channelValue;     if (totalD> 0) {         totalF = data[i].maxPower_t4 - data[last].maxPower_t4;         *maxPow = (int8_t) ((totalF*(chan->channel-data[last].channelValue) + data[last].maxPower_t4*totalD)/totalD);          totalMin = ar9280GetMinPower(ah,&data[i]) - ar9280GetMinPower(ah,&data[last]);         *minPow = (int8_t) ((totalMin*(chan->channel-data[last].channelValue) + ar9280GetMinPower(ah,&data[last])*totalD)/totalD);         return (AH_TRUE);     } else {         if (chan->channel == data[i].channelValue) {             *maxPow = data[i].maxPower_t4;             *minPow = ar9280GetMinPower(ah,&data[i]);             return(AH_TRUE);         } else             return(AH_FALSE);     }
else|#
directive|else
operator|*
name|maxPow
operator|=
operator|*
name|minPow
operator|=
literal|0
expr_stmt|;
return|return
name|AH_FALSE
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * The ordering of nfarray is thus:  *  * nfarray[0]: Chain 0 ctl  * nfarray[1]: Chain 1 ctl  * nfarray[2]: Chain 2 ctl  * nfarray[3]: Chain 0 ext  * nfarray[4]: Chain 1 ext  * nfarray[5]: Chain 2 ext  */
end_comment

begin_function
specifier|static
name|void
name|ar9280GetNoiseFloor
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int16_t
name|nfarray
index|[]
parameter_list|)
block|{
name|int16_t
name|nf
decl_stmt|;
name|nf
operator|=
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCA
argument_list|)
argument_list|,
name|AR9280_PHY_MINCCA_PWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
operator|&
literal|0x100
condition|)
name|nf
operator|=
literal|0
operator|-
operator|(
operator|(
name|nf
operator|^
literal|0x1ff
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"NF calibrated [ctl] [chain 0] is %d\n"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|nfarray
index|[
literal|0
index|]
operator|=
name|nf
expr_stmt|;
name|nf
operator|=
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CH1_CCA
argument_list|)
argument_list|,
name|AR9280_PHY_CH1_MINCCA_PWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
operator|&
literal|0x100
condition|)
name|nf
operator|=
literal|0
operator|-
operator|(
operator|(
name|nf
operator|^
literal|0x1ff
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"NF calibrated [ctl] [chain 1] is %d\n"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|nfarray
index|[
literal|1
index|]
operator|=
name|nf
expr_stmt|;
name|nf
operator|=
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_EXT_CCA
argument_list|)
argument_list|,
name|AR9280_PHY_EXT_MINCCA_PWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
operator|&
literal|0x100
condition|)
name|nf
operator|=
literal|0
operator|-
operator|(
operator|(
name|nf
operator|^
literal|0x1ff
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"NF calibrated [ext] [chain 0] is %d\n"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|nfarray
index|[
literal|3
index|]
operator|=
name|nf
expr_stmt|;
name|nf
operator|=
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CH1_EXT_CCA
argument_list|)
argument_list|,
name|AR9280_PHY_CH1_EXT_MINCCA_PWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
operator|&
literal|0x100
condition|)
name|nf
operator|=
literal|0
operator|-
operator|(
operator|(
name|nf
operator|^
literal|0x1ff
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NFCAL
argument_list|,
literal|"NF calibrated [ext] [chain 1] is %d\n"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|nfarray
index|[
literal|4
index|]
operator|=
name|nf
expr_stmt|;
comment|/* Chain 2 - invalid */
name|nfarray
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|nfarray
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Adjust NF based on statistical values for 5GHz frequencies.  * Stubbed:Not used by Fowl  */
end_comment

begin_function
name|int16_t
name|ar9280GetNfAdjust
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_CHANNEL_INTERNAL
modifier|*
name|c
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Free memory for analog bank scratch buffers  */
end_comment

begin_function
specifier|static
name|void
name|ar9280RfDetach
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HALASSERT
argument_list|(
name|ahp
operator|->
name|ah_rfHal
operator|!=
name|AH_NULL
argument_list|)
expr_stmt|;
name|ath_hal_free
argument_list|(
name|ahp
operator|->
name|ah_rfHal
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_rfHal
operator|=
name|AH_NULL
expr_stmt|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar9280RfAttach
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar9280State
modifier|*
name|priv
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ATTACH
argument_list|,
literal|"%s: attach AR9280 radio\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|ahp
operator|->
name|ah_rfHal
operator|==
name|AH_NULL
argument_list|)
expr_stmt|;
name|priv
operator|=
name|ath_hal_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ar9280State
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: cannot allocate private state\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|HAL_ENOMEM
expr_stmt|;
comment|/* XXX */
return|return
name|AH_FALSE
return|;
block|}
name|priv
operator|->
name|base
operator|.
name|rfDetach
operator|=
name|ar9280RfDetach
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|writeRegs
operator|=
name|ar9280WriteRegs
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|getRfBank
operator|=
name|ar9280GetRfBank
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|setChannel
operator|=
name|ar9280SetChannel
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|setRfRegs
operator|=
name|ar9280SetRfRegs
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|setPowerTable
operator|=
name|ar9280SetPowerTable
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|getChannelMaxMinPower
operator|=
name|ar9280GetChannelMaxMinPower
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|getNfAdjust
operator|=
name|ar9280GetNfAdjust
expr_stmt|;
name|ahp
operator|->
name|ah_pcdacTable
operator|=
name|priv
operator|->
name|pcdacTable
expr_stmt|;
name|ahp
operator|->
name|ah_pcdacTableSize
operator|=
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|pcdacTable
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_rfHal
operator|=
operator|&
name|priv
operator|->
name|base
expr_stmt|;
comment|/* 	 * Set noise floor adjust method; we arrange a 	 * direct call instead of thunking. 	 */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_getNfAdjust
operator|=
name|priv
operator|->
name|base
operator|.
name|getNfAdjust
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_getNoiseFloor
operator|=
name|ar9280GetNoiseFloor
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|ar9280RfProbe
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
operator|(
name|AR_SREV_MERLIN
argument_list|(
name|ah
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|AH_RF
argument_list|(
name|RF9280
argument_list|,
name|ar9280RfProbe
argument_list|,
name|ar9280RfAttach
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

