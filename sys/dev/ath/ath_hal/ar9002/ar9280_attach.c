begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2008-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_devid.h"
end_include

begin_include
include|#
directive|include
file|"ah_eeprom_v14.h"
end_include

begin_comment
comment|/* XXX for tx/rx gain */
end_comment

begin_include
include|#
directive|include
file|"ar9002/ar9280.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416phy.h"
end_include

begin_include
include|#
directive|include
file|"ar9002/ar9280v1.ini"
end_include

begin_include
include|#
directive|include
file|"ar9002/ar9280v2.ini"
end_include

begin_include
include|#
directive|include
file|"ar9002/ar9280_olc.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|HAL_PERCAL_DATA
name|ar9280_iq_cal
init|=
block|{
comment|/* single sample */
operator|.
name|calName
operator|=
literal|"IQ"
block|,
operator|.
name|calType
operator|=
name|IQ_MISMATCH_CAL
block|,
operator|.
name|calNumSamples
operator|=
name|MIN_CAL_SAMPLES
block|,
operator|.
name|calCountMax
operator|=
name|PER_MAX_LOG_COUNT
block|,
operator|.
name|calCollect
operator|=
name|ar5416IQCalCollect
block|,
operator|.
name|calPostProc
operator|=
name|ar5416IQCalibration
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|HAL_PERCAL_DATA
name|ar9280_adc_gain_cal
init|=
block|{
comment|/* single sample */
operator|.
name|calName
operator|=
literal|"ADC Gain"
block|,
operator|.
name|calType
operator|=
name|ADC_GAIN_CAL
block|,
operator|.
name|calNumSamples
operator|=
name|MIN_CAL_SAMPLES
block|,
operator|.
name|calCountMax
operator|=
name|PER_MAX_LOG_COUNT
block|,
operator|.
name|calCollect
operator|=
name|ar5416AdcGainCalCollect
block|,
operator|.
name|calPostProc
operator|=
name|ar5416AdcGainCalibration
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|HAL_PERCAL_DATA
name|ar9280_adc_dc_cal
init|=
block|{
comment|/* single sample */
operator|.
name|calName
operator|=
literal|"ADC DC"
block|,
operator|.
name|calType
operator|=
name|ADC_DC_CAL
block|,
operator|.
name|calNumSamples
operator|=
name|MIN_CAL_SAMPLES
block|,
operator|.
name|calCountMax
operator|=
name|PER_MAX_LOG_COUNT
block|,
operator|.
name|calCollect
operator|=
name|ar5416AdcDcCalCollect
block|,
operator|.
name|calPostProc
operator|=
name|ar5416AdcDcCalibration
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|HAL_PERCAL_DATA
name|ar9280_adc_init_dc_cal
init|=
block|{
operator|.
name|calName
operator|=
literal|"ADC Init DC"
block|,
operator|.
name|calType
operator|=
name|ADC_DC_INIT_CAL
block|,
operator|.
name|calNumSamples
operator|=
name|MIN_CAL_SAMPLES
block|,
operator|.
name|calCountMax
operator|=
name|INIT_LOG_COUNT
block|,
operator|.
name|calCollect
operator|=
name|ar5416AdcDcCalCollect
block|,
operator|.
name|calPostProc
operator|=
name|ar5416AdcDcCalibration
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ar9280ConfigPCIE
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|restore
parameter_list|,
name|HAL_BOOL
name|power_off
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar9280DisablePCIE
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar9280FillCapabilityInfo
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar9280WriteIni
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|ar9280AniSetup
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
comment|/* 	 * These are the parameters from the AR5416 ANI code; 	 * they likely need quite a bit of adjustment for the 	 * AR9280. 	 */
specifier|static
specifier|const
name|struct
name|ar5212AniParams
name|aniparams
init|=
block|{
operator|.
name|maxNoiseImmunityLevel
operator|=
literal|4
block|,
comment|/* levels 0..4 */
operator|.
name|totalSizeDesired
operator|=
block|{
operator|-
literal|55
block|,
operator|-
literal|55
block|,
operator|-
literal|55
block|,
operator|-
literal|55
block|,
operator|-
literal|62
block|}
block|,
operator|.
name|coarseHigh
operator|=
block|{
operator|-
literal|14
block|,
operator|-
literal|14
block|,
operator|-
literal|14
block|,
operator|-
literal|14
block|,
operator|-
literal|12
block|}
block|,
operator|.
name|coarseLow
operator|=
block|{
operator|-
literal|64
block|,
operator|-
literal|64
block|,
operator|-
literal|64
block|,
operator|-
literal|64
block|,
operator|-
literal|70
block|}
block|,
operator|.
name|firpwr
operator|=
block|{
operator|-
literal|78
block|,
operator|-
literal|78
block|,
operator|-
literal|78
block|,
operator|-
literal|78
block|,
operator|-
literal|80
block|}
block|,
operator|.
name|maxSpurImmunityLevel
operator|=
literal|7
block|,
operator|.
name|cycPwrThr1
operator|=
block|{
literal|2
block|,
literal|4
block|,
literal|6
block|,
literal|8
block|,
literal|10
block|,
literal|12
block|,
literal|14
block|,
literal|16
block|}
block|,
operator|.
name|maxFirstepLevel
operator|=
literal|2
block|,
comment|/* levels 0..2 */
operator|.
name|firstep
operator|=
block|{
literal|0
block|,
literal|4
block|,
literal|8
block|}
block|,
operator|.
name|ofdmTrigHigh
operator|=
literal|500
block|,
operator|.
name|ofdmTrigLow
operator|=
literal|200
block|,
operator|.
name|cckTrigHigh
operator|=
literal|200
block|,
operator|.
name|cckTrigLow
operator|=
literal|100
block|,
operator|.
name|rssiThrHigh
operator|=
literal|40
block|,
operator|.
name|rssiThrLow
operator|=
literal|7
block|,
operator|.
name|period
operator|=
literal|100
block|,         }
decl_stmt|;
comment|/* NB: disable ANI noise immmunity for reliable RIFS rx */
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ani_function
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|HAL_ANI_NOISE_IMMUNITY_LEVEL
operator|)
expr_stmt|;
comment|/* NB: ANI is not enabled yet */
name|ar5416AniAttach
argument_list|(
name|ah
argument_list|,
operator|&
name|aniparams
argument_list|,
operator|&
name|aniparams
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ar9280InitPLL
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|uint32_t
name|pll
init|=
name|SM
argument_list|(
literal|0x5
argument_list|,
name|AR_RTC_SOWL_PLL_REFDIV
argument_list|)
decl_stmt|;
if|if
condition|(
name|AR_SREV_MERLIN_20
argument_list|(
name|ah
argument_list|)
operator|&&
name|chan
operator|!=
name|AH_NULL
operator|&&
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* 		 * PLL WAR for Merlin 2.0/2.1 		 * When doing fast clock, set PLL to 0x142c 		 * Else, set PLL to 0x2850 to prevent reset-to-reset variation  		 */
name|pll
operator|=
name|IS_5GHZ_FAST_CLOCK_EN
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|?
literal|0x142c
else|:
literal|0x2850
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
condition|)
name|pll
operator||=
name|SM
argument_list|(
literal|0x1
argument_list|,
name|AR_RTC_SOWL_PLL_CLKSEL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|chan
argument_list|)
condition|)
name|pll
operator||=
name|SM
argument_list|(
literal|0x2
argument_list|,
name|AR_RTC_SOWL_PLL_CLKSEL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_MERLIN_10_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|pll
operator|=
name|SM
argument_list|(
literal|0x5
argument_list|,
name|AR_RTC_SOWL_PLL_REFDIV
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
name|AH_NULL
condition|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
condition|)
name|pll
operator||=
name|SM
argument_list|(
literal|0x1
argument_list|,
name|AR_RTC_SOWL_PLL_CLKSEL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|chan
argument_list|)
condition|)
name|pll
operator||=
name|SM
argument_list|(
literal|0x2
argument_list|,
name|AR_RTC_SOWL_PLL_CLKSEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|)
name|pll
operator||=
name|SM
argument_list|(
literal|0x28
argument_list|,
name|AR_RTC_SOWL_PLL_DIV
argument_list|)
expr_stmt|;
else|else
name|pll
operator||=
name|SM
argument_list|(
literal|0x2c
argument_list|,
name|AR_RTC_SOWL_PLL_DIV
argument_list|)
expr_stmt|;
block|}
else|else
name|pll
operator||=
name|SM
argument_list|(
literal|0x2c
argument_list|,
name|AR_RTC_SOWL_PLL_DIV
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_PLL_CONTROL
argument_list|,
name|pll
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
name|RTC_PLL_SETTLE_DELAY
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_SLEEP_CLK
argument_list|,
name|AR_RTC_SLEEP_DERIVED_CLK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX shouldn't be here! */
end_comment

begin_define
define|#
directive|define
name|EEP_MINOR
parameter_list|(
name|_ah
parameter_list|)
define|\
value|(AH_PRIVATE(_ah)->ah_eeversion& AR5416_EEP_VER_MINOR_MASK)
end_define

begin_comment
comment|/*  * Attach for an AR9280 part.  */
end_comment

begin_function
specifier|static
name|struct
name|ath_hal
modifier|*
name|ar9280Attach
parameter_list|(
name|uint16_t
name|devid
parameter_list|,
name|HAL_SOFTC
name|sc
parameter_list|,
name|HAL_BUS_TAG
name|st
parameter_list|,
name|HAL_BUS_HANDLE
name|sh
parameter_list|,
name|uint16_t
modifier|*
name|eepromdata
parameter_list|,
name|HAL_OPS_CONFIG
modifier|*
name|ah_config
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
name|struct
name|ath_hal_9280
modifier|*
name|ahp9280
decl_stmt|;
name|struct
name|ath_hal_5212
modifier|*
name|ahp
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|HAL_STATUS
name|ecode
decl_stmt|;
name|HAL_BOOL
name|rfStatus
decl_stmt|;
name|int8_t
name|pwr_table_offset
decl_stmt|;
name|uint8_t
name|pwr
decl_stmt|;
name|HALDEBUG
argument_list|(
name|AH_NULL
argument_list|,
name|HAL_DEBUG_ATTACH
argument_list|,
literal|"%s: sc %p st %p sh %p\n"
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|st
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sh
argument_list|)
expr_stmt|;
comment|/* NB: memory is returned zero'd */
name|ahp9280
operator|=
name|ath_hal_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ath_hal_9280
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp9280
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|AH_NULL
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: cannot allocate memory for state block\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|HAL_ENOMEM
expr_stmt|;
return|return
name|AH_NULL
return|;
block|}
name|ahp
operator|=
name|AH5212
argument_list|(
name|ahp9280
argument_list|)
expr_stmt|;
name|ah
operator|=
operator|&
name|ahp
operator|->
name|ah_priv
operator|.
name|h
expr_stmt|;
name|ar5416InitState
argument_list|(
name|AH5416
argument_list|(
name|ah
argument_list|)
argument_list|,
name|devid
argument_list|,
name|sc
argument_list|,
name|st
argument_list|,
name|sh
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* 	 * Use the "local" EEPROM data given to us by the higher layers. 	 * This is a private copy out of system flash. The Linux ath9k 	 * commit for the initial AR9130 support mentions MMIO flash 	 * access is "unreliable." -adrian 	 */
if|if
condition|(
name|eepromdata
operator|!=
name|AH_NULL
condition|)
block|{
name|AH_PRIVATE
argument_list|(
operator|(
name|ah
operator|)
argument_list|)
operator|->
name|ah_eepromRead
operator|=
name|ath_hal_EepromDataRead
expr_stmt|;
name|AH_PRIVATE
argument_list|(
operator|(
name|ah
operator|)
argument_list|)
operator|->
name|ah_eepromWrite
operator|=
name|NULL
expr_stmt|;
name|ah
operator|->
name|ah_eepromdata
operator|=
name|eepromdata
expr_stmt|;
block|}
comment|/* XXX override with 9280 specific state */
comment|/* override 5416 methods for our needs */
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_initPLL
operator|=
name|ar9280InitPLL
expr_stmt|;
name|ah
operator|->
name|ah_setAntennaSwitch
operator|=
name|ar9280SetAntennaSwitch
expr_stmt|;
name|ah
operator|->
name|ah_configPCIE
operator|=
name|ar9280ConfigPCIE
expr_stmt|;
name|ah
operator|->
name|ah_disablePCIE
operator|=
name|ar9280DisablePCIE
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
operator|.
name|iqCalData
operator|.
name|calData
operator|=
operator|&
name|ar9280_iq_cal
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
operator|.
name|adcGainCalData
operator|.
name|calData
operator|=
operator|&
name|ar9280_adc_gain_cal
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
operator|.
name|adcDcCalData
operator|.
name|calData
operator|=
operator|&
name|ar9280_adc_dc_cal
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
operator|.
name|adcDcCalInitData
operator|.
name|calData
operator|=
operator|&
name|ar9280_adc_init_dc_cal
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
operator|.
name|suppCals
operator|=
name|ADC_GAIN_CAL
operator||
name|ADC_DC_CAL
operator||
name|IQ_MISMATCH_CAL
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_spurMitigate
operator|=
name|ar9280SpurMitigate
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_writeIni
operator|=
name|ar9280WriteIni
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_olcInit
operator|=
name|ar9280olcInit
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_olcTempCompensation
operator|=
name|ar9280olcTemperatureCompensation
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_setPowerCalTable
operator|=
name|ar9280SetPowerCalTable
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rx_chainmask
operator|=
name|AR9280_DEFAULT_RXCHAINMASK
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tx_chainmask
operator|=
name|AR9280_DEFAULT_TXCHAINMASK
expr_stmt|;
if|if
condition|(
operator|!
name|ar5416SetResetReg
argument_list|(
name|ah
argument_list|,
name|HAL_RESET_POWER_ON
argument_list|)
condition|)
block|{
comment|/* reset chip */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: couldn't reset chip\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
name|ar5416SetPowerMode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: couldn't wakeup chip\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Read Revisions from Chips before taking out of reset */
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_SREV
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ATTACH
argument_list|,
literal|"%s: ID 0x%x VERSION 0x%x TYPE 0x%x REVISION 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|MS
argument_list|(
name|val
argument_list|,
name|AR_XSREV_ID
argument_list|)
argument_list|,
name|MS
argument_list|(
name|val
argument_list|,
name|AR_XSREV_VERSION
argument_list|)
argument_list|,
name|MS
argument_list|(
name|val
argument_list|,
name|AR_XSREV_TYPE
argument_list|)
argument_list|,
name|MS
argument_list|(
name|val
argument_list|,
name|AR_XSREV_REVISION
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NB: include chip type to differentiate from pre-Sowl versions */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|=
operator|(
name|val
operator|&
name|AR_XSREV_VERSION
operator|)
operator|>>
name|AR_XSREV_TYPE_S
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macRev
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_XSREV_REVISION
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ispcie
operator|=
operator|(
name|val
operator|&
name|AR_XSREV_TYPE_HOST_MODE
operator|)
operator|==
literal|0
expr_stmt|;
comment|/* setup common ini data; rf backends handle remainder */
if|if
condition|(
name|AR_SREV_MERLIN_20_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ini_modes
argument_list|,
name|ar9280Modes_v2
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ini_common
argument_list|,
name|ar9280Common_v2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|HAL_INI_INIT
argument_list|(
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_pcieserdes
argument_list|,
name|ar9280PciePhy_clkreq_always_on_L1_v2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp9280
operator|->
name|ah_ini_xmodes
argument_list|,
name|ar9280Modes_fast_clock_v2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ini_modes
argument_list|,
name|ar9280Modes_v1
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ini_common
argument_list|,
name|ar9280Common_v1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|HAL_INI_INIT
argument_list|(
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_pcieserdes
argument_list|,
name|ar9280PciePhy_v1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|ar5416AttachPCIE
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|ath_hal_v14EepromAttach
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecode
operator|!=
name|HAL_OK
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|!
name|ar5416ChipReset
argument_list|(
name|ah
argument_list|,
name|AH_NULL
argument_list|)
condition|)
block|{
comment|/* reset chip */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: chip reset failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyRev
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CHIP_ID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar5212ChipTest
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: hardware self-test failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_ESELFTEST
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Set correct Baseband to analog shift 	 * setting to access analog chips. 	 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0x00000007
argument_list|)
expr_stmt|;
comment|/* Read Radio Chip Rev Extract */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
operator|=
name|ar5416GetRadioRev
argument_list|(
name|ah
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
operator|&
name|AR_RADIO_SREV_MAJOR
condition|)
block|{
case|case
name|AR_RAD2133_SREV_MAJOR
case|:
comment|/* Sowl: 2G/3x3 */
case|case
name|AR_RAD5133_SREV_MAJOR
case|:
comment|/* Sowl: 2+5G/3x3 */
break|break;
default|default:
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
operator|==
literal|0
condition|)
block|{
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
operator|=
name|AR_RAD5133_SREV_MAJOR
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|AH_DEBUG
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: 5G Radio Chip Rev 0x%02X is not supported by "
literal|"this driver\n"
argument_list|,
name|__func__
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_ENOTSUPP
expr_stmt|;
goto|goto
name|bad
goto|;
endif|#
directive|endif
block|}
name|rfStatus
operator|=
name|ar9280RfAttach
argument_list|(
name|ah
argument_list|,
operator|&
name|ecode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rfStatus
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: RF setup failed, status %u\n"
argument_list|,
name|__func__
argument_list|,
name|ecode
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Enable fixup for AR_AN_TOP2 if necessary */
comment|/* 	 * The v14 EEPROM layer returns HAL_EIO if PWDCLKIND isn't supported 	 * by the EEPROM version. 	 * 	 * ath9k checks the EEPROM minor version is>= 0x0a here, instead of 	 * the abstracted EEPROM access layer. 	 */
name|ecode
operator|=
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_PWDCLKIND
argument_list|,
operator|&
name|pwr
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_MERLIN_20_OR_LATER
argument_list|(
name|ah
argument_list|)
operator|&&
name|ecode
operator|==
name|HAL_OK
operator|&&
name|pwr
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"[ath] enabling AN_TOP2_FIXUP\n"
argument_list|)
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_need_an_top2_fixup
operator|=
literal|1
expr_stmt|;
block|}
comment|/*          * Check whether the power table offset isn't the default.          * This can occur with eeprom minor V21 or greater on Merlin.          */
operator|(
name|void
operator|)
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_PWR_TABLE_OFFSET
argument_list|,
operator|&
name|pwr_table_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwr_table_offset
operator|!=
name|AR5416_PWR_TABLE_OFFSET_DB
condition|)
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"[ath]: default pwr offset: %d dBm != EEPROM pwr offset: %d dBm; curves will be adjusted.\n"
argument_list|,
name|AR5416_PWR_TABLE_OFFSET_DB
argument_list|,
operator|(
name|int
operator|)
name|pwr_table_offset
argument_list|)
expr_stmt|;
comment|/* XXX check for>= minor ver 17 */
if|if
condition|(
name|AR_SREV_MERLIN_20
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* setup rxgain table */
switch|switch
condition|(
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_RXGAIN_TYPE
argument_list|,
name|AH_NULL
argument_list|)
condition|)
block|{
case|case
name|AR5416_EEP_RXGAIN_13dB_BACKOFF
case|:
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp9280
operator|->
name|ah_ini_rxgain
argument_list|,
name|ar9280Modes_backoff_13db_rxgain_v2
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
case|case
name|AR5416_EEP_RXGAIN_23dB_BACKOFF
case|:
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp9280
operator|->
name|ah_ini_rxgain
argument_list|,
name|ar9280Modes_backoff_23db_rxgain_v2
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
case|case
name|AR5416_EEP_RXGAIN_ORIG
case|:
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp9280
operator|->
name|ah_ini_rxgain
argument_list|,
name|ar9280Modes_original_rxgain_v2
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
default|default:
name|HALASSERT
argument_list|(
name|AH_FALSE
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
comment|/* XXX ? try to continue */
block|}
block|}
comment|/* XXX check for>= minor ver 19 */
if|if
condition|(
name|AR_SREV_MERLIN_20
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* setp txgain table */
switch|switch
condition|(
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_TXGAIN_TYPE
argument_list|,
name|AH_NULL
argument_list|)
condition|)
block|{
case|case
name|AR5416_EEP_TXGAIN_HIGH_POWER
case|:
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp9280
operator|->
name|ah_ini_txgain
argument_list|,
name|ar9280Modes_high_power_tx_gain_v2
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
case|case
name|AR5416_EEP_TXGAIN_ORIG
case|:
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp9280
operator|->
name|ah_ini_txgain
argument_list|,
name|ar9280Modes_original_tx_gain_v2
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
default|default:
name|HALASSERT
argument_list|(
name|AH_FALSE
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
comment|/* XXX ? try to continue */
block|}
block|}
comment|/* 	 * Got everything we need now to setup the capabilities. 	 */
if|if
condition|(
operator|!
name|ar9280FillCapabilityInfo
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|ecode
operator|=
name|HAL_EEREAD
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ecode
operator|=
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_MACADDR
argument_list|,
name|ahp
operator|->
name|ah_macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecode
operator|!=
name|HAL_OK
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: error getting mac address from EEPROM\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* XXX How about the serial number ? */
comment|/* Read Reg Domain */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_currentRD
operator|=
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_REGDMN_0
argument_list|,
name|AH_NULL
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_currentRDext
operator|=
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_REGDMN_1
argument_list|,
name|AH_NULL
argument_list|)
expr_stmt|;
comment|/* 	 * ah_miscMode is populated by ar5416FillCapabilityInfo() 	 * starting from griffin. Set here to make sure that 	 * AR_MISC_MODE_MIC_NEW_LOC_ENABLE is set before a GTK is 	 * placed into hardware. 	 */
if|if
condition|(
name|ahp
operator|->
name|ah_miscMode
operator|!=
literal|0
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MISC_MODE
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_MISC_MODE
argument_list|)
operator||
name|ahp
operator|->
name|ah_miscMode
argument_list|)
expr_stmt|;
name|ar9280AniSetup
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* Anti Noise Immunity */
comment|/* Setup noise floor min/max/nominal values */
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_2g
operator|.
name|max
operator|=
name|AR_PHY_CCA_MAX_GOOD_VAL_9280_2GHZ
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_2g
operator|.
name|min
operator|=
name|AR_PHY_CCA_MIN_GOOD_VAL_9280_2GHZ
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_2g
operator|.
name|nominal
operator|=
name|AR_PHY_CCA_NOM_VAL_9280_2GHZ
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_5g
operator|.
name|max
operator|=
name|AR_PHY_CCA_MAX_GOOD_VAL_9280_5GHZ
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_5g
operator|.
name|min
operator|=
name|AR_PHY_CCA_MIN_GOOD_VAL_9280_5GHZ
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_5g
operator|.
name|nominal
operator|=
name|AR_PHY_CCA_NOM_VAL_9280_5GHZ
expr_stmt|;
name|ar5416InitNfHistBuff
argument_list|(
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
operator|.
name|nfCalHist
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ATTACH
argument_list|,
literal|"%s: return\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ah
return|;
name|bad
label|:
if|if
condition|(
name|ah
operator|!=
name|AH_NULL
condition|)
name|ah
operator|->
name|ah_detach
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
operator|*
name|status
operator|=
name|ecode
expr_stmt|;
return|return
name|AH_NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar9280ConfigPCIE
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|restore
parameter_list|,
name|HAL_BOOL
name|power_off
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ispcie
operator|&&
operator|!
name|restore
condition|)
block|{
name|ath_hal_ini_write
argument_list|(
name|ah
argument_list|,
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_pcieserdes
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set PCIe workaround bits 	 * 	 * NOTE: 	 * 	 * In Merlin and Kite, bit 14 in WA register (disable L1) should only 	 * be set when device enters D3 and be cleared when device comes back 	 * to D0. 	 */
if|if
condition|(
name|power_off
condition|)
block|{
comment|/* Power-off */
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_PM_CTRL
argument_list|,
name|AR_PCIE_PM_CTRL_ENA
argument_list|)
expr_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WA
argument_list|)
expr_stmt|;
comment|/* 		 * Disable bit 6 and 7 before entering D3 to prevent 		 * system hang. 		 */
name|val
operator|&=
operator|~
operator|(
name|AR_WA_BIT6
operator||
name|AR_WA_BIT7
operator|)
expr_stmt|;
comment|/* 		 * XXX Not sure, is specified in the reference HAL. 		 */
name|val
operator||=
name|AR_WA_BIT22
expr_stmt|;
comment|/* 		 * See above: set AR_WA_D3_L1_DISABLE when entering D3 state. 		 * 		 * XXX The reference HAL does it this way - it only sets 		 * AR_WA_D3_L1_DISABLE if it's set in AR9280_WA_DEFAULT, 		 * which it (currently) isn't.  So the following statement 		 * is currently a NOP. 		 */
if|if
condition|(
name|AR9280_WA_DEFAULT
operator|&
name|AR_WA_D3_L1_DISABLE
condition|)
name|val
operator||=
name|AR_WA_D3_L1_DISABLE
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WA
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Power-on */
name|val
operator|=
name|AR9280_WA_DEFAULT
expr_stmt|;
comment|/* 		 * See note above: make sure L1_DISABLE is not set. 		 */
name|val
operator|&=
operator|(
operator|~
name|AR_WA_D3_L1_DISABLE
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WA
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* set bit 19 to allow forcing of pcie core into L1 state */
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_PM_CTRL
argument_list|,
name|AR_PCIE_PM_CTRL_ENA
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ar9280DisablePCIE
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|ar9280WriteIni
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|u_int
name|modesIndex
decl_stmt|,
name|freqIndex
decl_stmt|;
name|int
name|regWrites
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|HAL_INI_ARRAY
modifier|*
name|ia
decl_stmt|;
comment|/* Setup the indices for the next set of register array writes */
comment|/* XXX Ignore 11n dynamic mode on the AR5416 for the moment */
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|freqIndex
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
name|modesIndex
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_108G
argument_list|(
name|chan
argument_list|)
condition|)
name|modesIndex
operator|=
literal|5
expr_stmt|;
else|else
name|modesIndex
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|freqIndex
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
operator|||
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
condition|)
name|modesIndex
operator|=
literal|2
expr_stmt|;
else|else
name|modesIndex
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Set correct Baseband to analog shift setting to access analog chips. */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0x00000007
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ADC_SERIAL_CTL
argument_list|,
name|AR_PHY_SEL_INTERNAL_ADDAC
argument_list|)
expr_stmt|;
comment|/* 	 * This is unwound because at the moment, there's a requirement 	 * for Merlin (and later, perhaps) to have a specific bit fixed 	 * in the AR_AN_TOP2 register before writing it. 	 */
name|ia
operator|=
operator|&
name|AH5212
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_modes
expr_stmt|;
if|#
directive|if
literal|0
block|regWrites = ath_hal_ini_write(ah,&AH5212(ah)->ah_ini_modes, 	    modesIndex, regWrites);
endif|#
directive|endif
name|HALASSERT
argument_list|(
name|modesIndex
operator|<
name|ia
operator|->
name|cols
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ia
operator|->
name|rows
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|reg
init|=
name|HAL_INI_VAL
argument_list|(
name|ia
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|uint32_t
name|val
init|=
name|HAL_INI_VAL
argument_list|(
name|ia
argument_list|,
name|i
argument_list|,
name|modesIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|AR_AN_TOP2
operator|&&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_need_an_top2_fixup
condition|)
name|val
operator|&=
operator|~
name|AR_AN_TOP2_PWDCLKIND
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Analog shift register delay seems needed for Merlin - PR kern/154220 */
if|if
condition|(
name|reg
operator|>=
literal|0x7800
operator|&&
name|reg
operator|<
literal|0x7900
condition|)
name|OS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|DMA_YIELD
argument_list|(
name|regWrites
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AR_SREV_MERLIN_20_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|regWrites
operator|=
name|ath_hal_ini_write
argument_list|(
name|ah
argument_list|,
operator|&
name|AH9280
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_rxgain
argument_list|,
name|modesIndex
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
name|regWrites
operator|=
name|ath_hal_ini_write
argument_list|(
name|ah
argument_list|,
operator|&
name|AH9280
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_txgain
argument_list|,
name|modesIndex
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
block|}
comment|/* XXX Merlin 100us delay for shift registers */
name|regWrites
operator|=
name|ath_hal_ini_write
argument_list|(
name|ah
argument_list|,
operator|&
name|AH5212
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_common
argument_list|,
literal|1
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_MERLIN_20
argument_list|(
name|ah
argument_list|)
operator|&&
name|IS_5GHZ_FAST_CLOCK_EN
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
comment|/* 5GHz channels w/ Fast Clock use different modal values */
name|regWrites
operator|=
name|ath_hal_ini_write
argument_list|(
name|ah
argument_list|,
operator|&
name|AH9280
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_xmodes
argument_list|,
name|modesIndex
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|AR_BASE_FREQ_2GHZ
value|2300
end_define

begin_define
define|#
directive|define
name|AR_BASE_FREQ_5GHZ
value|4900
end_define

begin_define
define|#
directive|define
name|AR_SPUR_FEEQ_BOUND_HT40
value|19
end_define

begin_define
define|#
directive|define
name|AR_SPUR_FEEQ_BOUND_HT20
value|10
end_define

begin_function
name|void
name|ar9280SpurMitigate
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|pilot_mask_reg
index|[
literal|4
index|]
init|=
block|{
name|AR_PHY_TIMING7
block|,
name|AR_PHY_TIMING8
block|,
name|AR_PHY_PILOT_MASK_01_30
block|,
name|AR_PHY_PILOT_MASK_31_60
block|}
decl_stmt|;
specifier|static
specifier|const
name|int
name|chan_mask_reg
index|[
literal|4
index|]
init|=
block|{
name|AR_PHY_TIMING9
block|,
name|AR_PHY_TIMING10
block|,
name|AR_PHY_CHANNEL_MASK_01_30
block|,
name|AR_PHY_CHANNEL_MASK_31_60
block|}
decl_stmt|;
specifier|static
name|int
name|inc
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|100
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|bb_spur
init|=
name|AR_NO_SPUR
decl_stmt|;
name|int
name|freq
decl_stmt|;
name|int
name|bin
decl_stmt|,
name|cur_bin
decl_stmt|;
name|int
name|bb_spur_off
decl_stmt|,
name|spur_subchannel_sd
decl_stmt|;
name|int
name|spur_freq_sd
decl_stmt|;
name|int
name|spur_delta_phase
decl_stmt|;
name|int
name|denominator
decl_stmt|;
name|int
name|upper
decl_stmt|,
name|lower
decl_stmt|,
name|cur_vit_mask
decl_stmt|;
name|int
name|tmp
decl_stmt|,
name|newVal
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CHAN_CENTERS
name|centers
decl_stmt|;
name|int8_t
name|mask_m
index|[
literal|123
index|]
decl_stmt|;
name|int8_t
name|mask_p
index|[
literal|123
index|]
decl_stmt|;
name|int8_t
name|mask_amt
decl_stmt|;
name|int
name|tmp_mask
decl_stmt|;
name|int
name|cur_bb_spur
decl_stmt|;
name|HAL_BOOL
name|is2GHz
init|=
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
decl_stmt|;
name|OS_MEMZERO
argument_list|(
operator|&
name|mask_m
argument_list|,
sizeof|sizeof
argument_list|(
name|int8_t
argument_list|)
operator|*
literal|123
argument_list|)
expr_stmt|;
name|OS_MEMZERO
argument_list|(
operator|&
name|mask_p
argument_list|,
sizeof|sizeof
argument_list|(
name|int8_t
argument_list|)
operator|*
literal|123
argument_list|)
expr_stmt|;
name|ar5416GetChannelCenters
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|&
name|centers
argument_list|)
expr_stmt|;
name|freq
operator|=
name|centers
operator|.
name|synth_center
expr_stmt|;
comment|/*      * Need to verify range +/- 9.38 for static ht20 and +/- 18.75 for ht40,      * otherwise spur is out-of-band and can be ignored.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR5416_EEPROM_MODAL_SPURS
condition|;
name|i
operator|++
control|)
block|{
name|cur_bb_spur
operator|=
name|ath_hal_getSpurChan
argument_list|(
name|ah
argument_list|,
name|i
argument_list|,
name|is2GHz
argument_list|)
expr_stmt|;
comment|/* Get actual spur freq in MHz from EEPROM read value */
if|if
condition|(
name|is2GHz
condition|)
block|{
name|cur_bb_spur
operator|=
operator|(
name|cur_bb_spur
operator|/
literal|10
operator|)
operator|+
name|AR_BASE_FREQ_2GHZ
expr_stmt|;
block|}
else|else
block|{
name|cur_bb_spur
operator|=
operator|(
name|cur_bb_spur
operator|/
literal|10
operator|)
operator|+
name|AR_BASE_FREQ_5GHZ
expr_stmt|;
block|}
if|if
condition|(
name|AR_NO_SPUR
operator|==
name|cur_bb_spur
condition|)
break|break;
name|cur_bb_spur
operator|=
name|cur_bb_spur
operator|-
name|freq
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|cur_bb_spur
operator|>
operator|-
name|AR_SPUR_FEEQ_BOUND_HT40
operator|)
operator|&&
operator|(
name|cur_bb_spur
operator|<
name|AR_SPUR_FEEQ_BOUND_HT40
operator|)
condition|)
block|{
name|bb_spur
operator|=
name|cur_bb_spur
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|cur_bb_spur
operator|>
operator|-
name|AR_SPUR_FEEQ_BOUND_HT20
operator|)
operator|&&
operator|(
name|cur_bb_spur
operator|<
name|AR_SPUR_FEEQ_BOUND_HT20
operator|)
condition|)
block|{
name|bb_spur
operator|=
name|cur_bb_spur
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|AR_NO_SPUR
operator|==
name|bb_spur
condition|)
block|{
if|#
directive|if
literal|1
comment|/*          * MRC CCK can interfere with beacon detection and cause deaf/mute.          * Disable MRC CCK for now.          */
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_FORCE_CLKEN_CCK
argument_list|,
name|AR_PHY_FORCE_CLKEN_CCK_MRC_MUX
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Enable MRC CCK if no spur is found in this channel. */
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_FORCE_CLKEN_CCK
argument_list|,
name|AR_PHY_FORCE_CLKEN_CCK_MRC_MUX
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
else|else
block|{
comment|/*           * For Merlin, spur can break CCK MRC algorithm. Disable CCK MRC if spur          * is found in this channel.          */
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_FORCE_CLKEN_CCK
argument_list|,
name|AR_PHY_FORCE_CLKEN_CCK_MRC_MUX
argument_list|)
expr_stmt|;
block|}
name|bin
operator|=
name|bb_spur
operator|*
literal|320
expr_stmt|;
name|tmp
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4_CHAIN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|newVal
operator|=
name|tmp
operator||
operator|(
name|AR_PHY_TIMING_CTRL4_ENABLE_SPUR_RSSI
operator||
name|AR_PHY_TIMING_CTRL4_ENABLE_SPUR_FILTER
operator||
name|AR_PHY_TIMING_CTRL4_ENABLE_CHAN_MASK
operator||
name|AR_PHY_TIMING_CTRL4_ENABLE_PILOT_MASK
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4_CHAIN
argument_list|(
literal|0
argument_list|)
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
name|newVal
operator|=
operator|(
name|AR_PHY_SPUR_REG_MASK_RATE_CNTL
operator||
name|AR_PHY_SPUR_REG_ENABLE_MASK_PPM
operator||
name|AR_PHY_SPUR_REG_MASK_RATE_SELECT
operator||
name|AR_PHY_SPUR_REG_ENABLE_VIT_SPUR_RSSI
operator||
name|SM
argument_list|(
name|AR5416_SPUR_RSSI_THRESH
argument_list|,
name|AR_PHY_SPUR_REG_SPUR_RSSI_THRESH
argument_list|)
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SPUR_REG
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
comment|/* Pick control or extn channel to cancel the spur */
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
if|if
condition|(
name|bb_spur
operator|<
literal|0
condition|)
block|{
name|spur_subchannel_sd
operator|=
literal|1
expr_stmt|;
name|bb_spur_off
operator|=
name|bb_spur
operator|+
literal|10
expr_stmt|;
block|}
else|else
block|{
name|spur_subchannel_sd
operator|=
literal|0
expr_stmt|;
name|bb_spur_off
operator|=
name|bb_spur
operator|-
literal|10
expr_stmt|;
block|}
block|}
else|else
block|{
name|spur_subchannel_sd
operator|=
literal|0
expr_stmt|;
name|bb_spur_off
operator|=
name|bb_spur
expr_stmt|;
block|}
comment|/*      * spur_delta_phase = bb_spur/40 * 2**21 for static ht20,      * /80 for dyn2040.      */
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
name|spur_delta_phase
operator|=
operator|(
operator|(
name|bb_spur
operator|*
literal|262144
operator|)
operator|/
literal|10
operator|)
operator|&
name|AR_PHY_TIMING11_SPUR_DELTA_PHASE
expr_stmt|;
else|else
name|spur_delta_phase
operator|=
operator|(
operator|(
name|bb_spur
operator|*
literal|524288
operator|)
operator|/
literal|10
operator|)
operator|&
name|AR_PHY_TIMING11_SPUR_DELTA_PHASE
expr_stmt|;
comment|/*      * in 11A mode the denominator of spur_freq_sd should be 40 and      * it should be 44 in 11G      */
name|denominator
operator|=
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|?
literal|44
else|:
literal|40
expr_stmt|;
name|spur_freq_sd
operator|=
operator|(
operator|(
name|bb_spur_off
operator|*
literal|2048
operator|)
operator|/
name|denominator
operator|)
operator|&
literal|0x3ff
expr_stmt|;
name|newVal
operator|=
operator|(
name|AR_PHY_TIMING11_USE_SPUR_IN_AGC
operator||
name|SM
argument_list|(
name|spur_freq_sd
argument_list|,
name|AR_PHY_TIMING11_SPUR_FREQ_SD
argument_list|)
operator||
name|SM
argument_list|(
name|spur_delta_phase
argument_list|,
name|AR_PHY_TIMING11_SPUR_DELTA_PHASE
argument_list|)
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING11
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
comment|/* Choose to cancel between control and extension channels */
name|newVal
operator|=
name|spur_subchannel_sd
operator|<<
name|AR_PHY_SFCORR_SPUR_SUBCHNL_SD_S
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_EXT
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
comment|/*      * ============================================      * Set Pilot and Channel Masks      *      * pilot mask 1 [31:0] = +6..-26, no 0 bin      * pilot mask 2 [19:0] = +26..+7      *      * channel mask 1 [31:0] = +6..-26, no 0 bin      * channel mask 2 [19:0] = +26..+7      */
name|cur_bin
operator|=
operator|-
literal|6000
expr_stmt|;
name|upper
operator|=
name|bin
operator|+
literal|100
expr_stmt|;
name|lower
operator|=
name|bin
operator|-
literal|100
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pilot_mask
init|=
literal|0
decl_stmt|;
name|int
name|chan_mask
init|=
literal|0
decl_stmt|;
name|int
name|bp
init|=
literal|0
decl_stmt|;
for|for
control|(
name|bp
operator|=
literal|0
init|;
name|bp
operator|<
literal|30
condition|;
name|bp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cur_bin
operator|>
name|lower
operator|)
operator|&&
operator|(
name|cur_bin
operator|<
name|upper
operator|)
condition|)
block|{
name|pilot_mask
operator|=
name|pilot_mask
operator||
literal|0x1
operator|<<
name|bp
expr_stmt|;
name|chan_mask
operator|=
name|chan_mask
operator||
literal|0x1
operator|<<
name|bp
expr_stmt|;
block|}
name|cur_bin
operator|+=
literal|100
expr_stmt|;
block|}
name|cur_bin
operator|+=
name|inc
index|[
name|i
index|]
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|pilot_mask_reg
index|[
name|i
index|]
argument_list|,
name|pilot_mask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|chan_mask_reg
index|[
name|i
index|]
argument_list|,
name|chan_mask
argument_list|)
expr_stmt|;
block|}
comment|/* =================================================      * viterbi mask 1 based on channel magnitude      * four levels 0-3      *  - mask (-27 to 27) (reg 64,0x9900 to 67,0x990c)      *      [1 2 2 1] for -9.6 or [1 2 1] for +16      *  - enable_mask_ppm, all bins move with freq      *      *  - mask_select,    8 bits for rates (reg 67,0x990c)      *  - mask_rate_cntl, 8 bits for rates (reg 67,0x990c)      *      choose which mask to use mask or mask2      */
comment|/*      * viterbi mask 2  2nd set for per data rate puncturing      * four levels 0-3      *  - mask_select, 8 bits for rates (reg 67)      *  - mask (-27 to 27) (reg 98,0x9988 to 101,0x9994)      *      [1 2 2 1] for -9.6 or [1 2 1] for +16      */
name|cur_vit_mask
operator|=
literal|6100
expr_stmt|;
name|upper
operator|=
name|bin
operator|+
literal|120
expr_stmt|;
name|lower
operator|=
name|bin
operator|-
literal|120
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|123
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cur_vit_mask
operator|>
name|lower
operator|)
operator|&&
operator|(
name|cur_vit_mask
operator|<
name|upper
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|abs
argument_list|(
name|cur_vit_mask
operator|-
name|bin
argument_list|)
operator|)
operator|<
literal|75
condition|)
block|{
name|mask_amt
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mask_amt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cur_vit_mask
operator|<
literal|0
condition|)
block|{
name|mask_m
index|[
name|abs
argument_list|(
name|cur_vit_mask
operator|/
literal|100
argument_list|)
index|]
operator|=
name|mask_amt
expr_stmt|;
block|}
else|else
block|{
name|mask_p
index|[
name|cur_vit_mask
operator|/
literal|100
index|]
operator|=
name|mask_amt
expr_stmt|;
block|}
block|}
name|cur_vit_mask
operator|-=
literal|100
expr_stmt|;
block|}
name|tmp_mask
operator|=
operator|(
name|mask_m
index|[
literal|46
index|]
operator|<<
literal|30
operator|)
operator||
operator|(
name|mask_m
index|[
literal|47
index|]
operator|<<
literal|28
operator|)
operator||
operator|(
name|mask_m
index|[
literal|48
index|]
operator|<<
literal|26
operator|)
operator||
operator|(
name|mask_m
index|[
literal|49
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|mask_m
index|[
literal|50
index|]
operator|<<
literal|22
operator|)
operator||
operator|(
name|mask_m
index|[
literal|51
index|]
operator|<<
literal|20
operator|)
operator||
operator|(
name|mask_m
index|[
literal|52
index|]
operator|<<
literal|18
operator|)
operator||
operator|(
name|mask_m
index|[
literal|53
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|mask_m
index|[
literal|54
index|]
operator|<<
literal|14
operator|)
operator||
operator|(
name|mask_m
index|[
literal|55
index|]
operator|<<
literal|12
operator|)
operator||
operator|(
name|mask_m
index|[
literal|56
index|]
operator|<<
literal|10
operator|)
operator||
operator|(
name|mask_m
index|[
literal|57
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|mask_m
index|[
literal|58
index|]
operator|<<
literal|6
operator|)
operator||
operator|(
name|mask_m
index|[
literal|59
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|mask_m
index|[
literal|60
index|]
operator|<<
literal|2
operator|)
operator||
operator|(
name|mask_m
index|[
literal|61
index|]
operator|<<
literal|0
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK_1
argument_list|,
name|tmp_mask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_VIT_MASK2_M_46_61
argument_list|,
name|tmp_mask
argument_list|)
expr_stmt|;
name|tmp_mask
operator|=
operator|(
name|mask_m
index|[
literal|31
index|]
operator|<<
literal|28
operator|)
operator||
operator|(
name|mask_m
index|[
literal|32
index|]
operator|<<
literal|26
operator|)
operator||
operator|(
name|mask_m
index|[
literal|33
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|mask_m
index|[
literal|34
index|]
operator|<<
literal|22
operator|)
operator||
operator|(
name|mask_m
index|[
literal|35
index|]
operator|<<
literal|20
operator|)
operator||
operator|(
name|mask_m
index|[
literal|36
index|]
operator|<<
literal|18
operator|)
operator||
operator|(
name|mask_m
index|[
literal|37
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|mask_m
index|[
literal|48
index|]
operator|<<
literal|14
operator|)
operator||
operator|(
name|mask_m
index|[
literal|39
index|]
operator|<<
literal|12
operator|)
operator||
operator|(
name|mask_m
index|[
literal|40
index|]
operator|<<
literal|10
operator|)
operator||
operator|(
name|mask_m
index|[
literal|41
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|mask_m
index|[
literal|42
index|]
operator|<<
literal|6
operator|)
operator||
operator|(
name|mask_m
index|[
literal|43
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|mask_m
index|[
literal|44
index|]
operator|<<
literal|2
operator|)
operator||
operator|(
name|mask_m
index|[
literal|45
index|]
operator|<<
literal|0
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK_2
argument_list|,
name|tmp_mask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MASK2_M_31_45
argument_list|,
name|tmp_mask
argument_list|)
expr_stmt|;
name|tmp_mask
operator|=
operator|(
name|mask_m
index|[
literal|16
index|]
operator|<<
literal|30
operator|)
operator||
operator|(
name|mask_m
index|[
literal|16
index|]
operator|<<
literal|28
operator|)
operator||
operator|(
name|mask_m
index|[
literal|18
index|]
operator|<<
literal|26
operator|)
operator||
operator|(
name|mask_m
index|[
literal|18
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|mask_m
index|[
literal|20
index|]
operator|<<
literal|22
operator|)
operator||
operator|(
name|mask_m
index|[
literal|20
index|]
operator|<<
literal|20
operator|)
operator||
operator|(
name|mask_m
index|[
literal|22
index|]
operator|<<
literal|18
operator|)
operator||
operator|(
name|mask_m
index|[
literal|22
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|mask_m
index|[
literal|24
index|]
operator|<<
literal|14
operator|)
operator||
operator|(
name|mask_m
index|[
literal|24
index|]
operator|<<
literal|12
operator|)
operator||
operator|(
name|mask_m
index|[
literal|25
index|]
operator|<<
literal|10
operator|)
operator||
operator|(
name|mask_m
index|[
literal|26
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|mask_m
index|[
literal|27
index|]
operator|<<
literal|6
operator|)
operator||
operator|(
name|mask_m
index|[
literal|28
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|mask_m
index|[
literal|29
index|]
operator|<<
literal|2
operator|)
operator||
operator|(
name|mask_m
index|[
literal|30
index|]
operator|<<
literal|0
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK_3
argument_list|,
name|tmp_mask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MASK2_M_16_30
argument_list|,
name|tmp_mask
argument_list|)
expr_stmt|;
name|tmp_mask
operator|=
operator|(
name|mask_m
index|[
literal|0
index|]
operator|<<
literal|30
operator|)
operator||
operator|(
name|mask_m
index|[
literal|1
index|]
operator|<<
literal|28
operator|)
operator||
operator|(
name|mask_m
index|[
literal|2
index|]
operator|<<
literal|26
operator|)
operator||
operator|(
name|mask_m
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|mask_m
index|[
literal|4
index|]
operator|<<
literal|22
operator|)
operator||
operator|(
name|mask_m
index|[
literal|5
index|]
operator|<<
literal|20
operator|)
operator||
operator|(
name|mask_m
index|[
literal|6
index|]
operator|<<
literal|18
operator|)
operator||
operator|(
name|mask_m
index|[
literal|7
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|mask_m
index|[
literal|8
index|]
operator|<<
literal|14
operator|)
operator||
operator|(
name|mask_m
index|[
literal|9
index|]
operator|<<
literal|12
operator|)
operator||
operator|(
name|mask_m
index|[
literal|10
index|]
operator|<<
literal|10
operator|)
operator||
operator|(
name|mask_m
index|[
literal|11
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|mask_m
index|[
literal|12
index|]
operator|<<
literal|6
operator|)
operator||
operator|(
name|mask_m
index|[
literal|13
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|mask_m
index|[
literal|14
index|]
operator|<<
literal|2
operator|)
operator||
operator|(
name|mask_m
index|[
literal|15
index|]
operator|<<
literal|0
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MASK_CTL
argument_list|,
name|tmp_mask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MASK2_M_00_15
argument_list|,
name|tmp_mask
argument_list|)
expr_stmt|;
name|tmp_mask
operator|=
operator|(
name|mask_p
index|[
literal|15
index|]
operator|<<
literal|28
operator|)
operator||
operator|(
name|mask_p
index|[
literal|14
index|]
operator|<<
literal|26
operator|)
operator||
operator|(
name|mask_p
index|[
literal|13
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|mask_p
index|[
literal|12
index|]
operator|<<
literal|22
operator|)
operator||
operator|(
name|mask_p
index|[
literal|11
index|]
operator|<<
literal|20
operator|)
operator||
operator|(
name|mask_p
index|[
literal|10
index|]
operator|<<
literal|18
operator|)
operator||
operator|(
name|mask_p
index|[
literal|9
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|mask_p
index|[
literal|8
index|]
operator|<<
literal|14
operator|)
operator||
operator|(
name|mask_p
index|[
literal|7
index|]
operator|<<
literal|12
operator|)
operator||
operator|(
name|mask_p
index|[
literal|6
index|]
operator|<<
literal|10
operator|)
operator||
operator|(
name|mask_p
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|mask_p
index|[
literal|4
index|]
operator|<<
literal|6
operator|)
operator||
operator|(
name|mask_p
index|[
literal|3
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|mask_p
index|[
literal|2
index|]
operator|<<
literal|2
operator|)
operator||
operator|(
name|mask_p
index|[
literal|1
index|]
operator|<<
literal|0
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK2_1
argument_list|,
name|tmp_mask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MASK2_P_15_01
argument_list|,
name|tmp_mask
argument_list|)
expr_stmt|;
name|tmp_mask
operator|=
operator|(
name|mask_p
index|[
literal|30
index|]
operator|<<
literal|28
operator|)
operator||
operator|(
name|mask_p
index|[
literal|29
index|]
operator|<<
literal|26
operator|)
operator||
operator|(
name|mask_p
index|[
literal|28
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|mask_p
index|[
literal|27
index|]
operator|<<
literal|22
operator|)
operator||
operator|(
name|mask_p
index|[
literal|26
index|]
operator|<<
literal|20
operator|)
operator||
operator|(
name|mask_p
index|[
literal|25
index|]
operator|<<
literal|18
operator|)
operator||
operator|(
name|mask_p
index|[
literal|24
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|mask_p
index|[
literal|23
index|]
operator|<<
literal|14
operator|)
operator||
operator|(
name|mask_p
index|[
literal|22
index|]
operator|<<
literal|12
operator|)
operator||
operator|(
name|mask_p
index|[
literal|21
index|]
operator|<<
literal|10
operator|)
operator||
operator|(
name|mask_p
index|[
literal|20
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|mask_p
index|[
literal|19
index|]
operator|<<
literal|6
operator|)
operator||
operator|(
name|mask_p
index|[
literal|18
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|mask_p
index|[
literal|17
index|]
operator|<<
literal|2
operator|)
operator||
operator|(
name|mask_p
index|[
literal|16
index|]
operator|<<
literal|0
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK2_2
argument_list|,
name|tmp_mask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MASK2_P_30_16
argument_list|,
name|tmp_mask
argument_list|)
expr_stmt|;
name|tmp_mask
operator|=
operator|(
name|mask_p
index|[
literal|45
index|]
operator|<<
literal|28
operator|)
operator||
operator|(
name|mask_p
index|[
literal|44
index|]
operator|<<
literal|26
operator|)
operator||
operator|(
name|mask_p
index|[
literal|43
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|mask_p
index|[
literal|42
index|]
operator|<<
literal|22
operator|)
operator||
operator|(
name|mask_p
index|[
literal|41
index|]
operator|<<
literal|20
operator|)
operator||
operator|(
name|mask_p
index|[
literal|40
index|]
operator|<<
literal|18
operator|)
operator||
operator|(
name|mask_p
index|[
literal|39
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|mask_p
index|[
literal|38
index|]
operator|<<
literal|14
operator|)
operator||
operator|(
name|mask_p
index|[
literal|37
index|]
operator|<<
literal|12
operator|)
operator||
operator|(
name|mask_p
index|[
literal|36
index|]
operator|<<
literal|10
operator|)
operator||
operator|(
name|mask_p
index|[
literal|35
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|mask_p
index|[
literal|34
index|]
operator|<<
literal|6
operator|)
operator||
operator|(
name|mask_p
index|[
literal|33
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|mask_p
index|[
literal|32
index|]
operator|<<
literal|2
operator|)
operator||
operator|(
name|mask_p
index|[
literal|31
index|]
operator|<<
literal|0
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK2_3
argument_list|,
name|tmp_mask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MASK2_P_45_31
argument_list|,
name|tmp_mask
argument_list|)
expr_stmt|;
name|tmp_mask
operator|=
operator|(
name|mask_p
index|[
literal|61
index|]
operator|<<
literal|30
operator|)
operator||
operator|(
name|mask_p
index|[
literal|60
index|]
operator|<<
literal|28
operator|)
operator||
operator|(
name|mask_p
index|[
literal|59
index|]
operator|<<
literal|26
operator|)
operator||
operator|(
name|mask_p
index|[
literal|58
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|mask_p
index|[
literal|57
index|]
operator|<<
literal|22
operator|)
operator||
operator|(
name|mask_p
index|[
literal|56
index|]
operator|<<
literal|20
operator|)
operator||
operator|(
name|mask_p
index|[
literal|55
index|]
operator|<<
literal|18
operator|)
operator||
operator|(
name|mask_p
index|[
literal|54
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|mask_p
index|[
literal|53
index|]
operator|<<
literal|14
operator|)
operator||
operator|(
name|mask_p
index|[
literal|52
index|]
operator|<<
literal|12
operator|)
operator||
operator|(
name|mask_p
index|[
literal|51
index|]
operator|<<
literal|10
operator|)
operator||
operator|(
name|mask_p
index|[
literal|50
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|mask_p
index|[
literal|49
index|]
operator|<<
literal|6
operator|)
operator||
operator|(
name|mask_p
index|[
literal|48
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|mask_p
index|[
literal|47
index|]
operator|<<
literal|2
operator|)
operator||
operator|(
name|mask_p
index|[
literal|46
index|]
operator|<<
literal|0
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BIN_MASK2_4
argument_list|,
name|tmp_mask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MASK2_P_61_45
argument_list|,
name|tmp_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fill all software cached or static hardware state information.  * Return failure if capabilities are to come from EEPROM and  * cannot be read.  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar9280FillCapabilityInfo
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|HAL_CAPABILITIES
modifier|*
name|pCap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
if|if
condition|(
operator|!
name|ar5416FillCapabilityInfo
argument_list|(
name|ah
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
name|pCap
operator|->
name|halNumGpioPins
operator|=
literal|10
expr_stmt|;
name|pCap
operator|->
name|halWowSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halWowMatchPatternExact
operator|=
name|AH_TRUE
expr_stmt|;
if|#
directive|if
literal|0
block|pCap->halWowMatchPatternDword = AH_TRUE;
endif|#
directive|endif
name|pCap
operator|->
name|halCSTSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halRifsRxSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halRifsTxSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halRtsAggrLimit
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
comment|/* 802.11n max */
name|pCap
operator|->
name|halExtChanDfsSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halUseCombinedRadarRssi
operator|=
name|AH_TRUE
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX bluetooth */
block|pCap->halBtCoexSupport = AH_TRUE;
endif|#
directive|endif
name|pCap
operator|->
name|halAutoSleepSupport
operator|=
name|AH_FALSE
expr_stmt|;
comment|/* XXX? */
name|pCap
operator|->
name|hal4kbSplitTransSupport
operator|=
name|AH_FALSE
expr_stmt|;
comment|/* Disable this so Block-ACK works correctly */
name|pCap
operator|->
name|halHasRxSelfLinkedTail
operator|=
name|AH_FALSE
expr_stmt|;
name|pCap
operator|->
name|halMbssidAggrSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|hal4AddrAggrSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halSpectralScanSupport
operator|=
name|AH_TRUE
expr_stmt|;
if|if
condition|(
name|AR_SREV_MERLIN_20
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|pCap
operator|->
name|halPSPollBroken
operator|=
name|AH_FALSE
expr_stmt|;
comment|/* 		 * This just enables the support; it doesn't 		 * state 5ghz fast clock will always be used. 		 */
name|pCap
operator|->
name|halSupportsFastClock5GHz
operator|=
name|AH_TRUE
expr_stmt|;
block|}
name|pCap
operator|->
name|halRxStbcSupport
operator|=
literal|1
expr_stmt|;
name|pCap
operator|->
name|halTxStbcSupport
operator|=
literal|1
expr_stmt|;
name|pCap
operator|->
name|halEnhancedDfsSupport
operator|=
name|AH_TRUE
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * This has been disabled - having the HAL flip chainmasks on/off  * when attempting to implement 11n disrupts things. For now, just  * leave this flipped off and worry about implementing TX diversity  * for legacy and MCS0-7 when 11n is fully functioning.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9280SetAntennaSwitch
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_ANT_SETTING
name|settings
parameter_list|)
block|{
define|#
directive|define
name|ANTENNA0_CHAINMASK
value|0x1
define|#
directive|define
name|ANTENNA1_CHAINMASK
value|0x2
if|#
directive|if
literal|0
block|struct ath_hal_5416 *ahp = AH5416(ah);
comment|/* Antenna selection is done by setting the tx/rx chainmasks approp. */
block|switch (settings) { 	case HAL_ANT_FIXED_A:
comment|/* Enable first antenna only */
block|ahp->ah_tx_chainmask = ANTENNA0_CHAINMASK; 		ahp->ah_rx_chainmask = ANTENNA0_CHAINMASK; 		break; 	case HAL_ANT_FIXED_B:
comment|/* Enable second antenna only, after checking capability */
block|if (AH_PRIVATE(ah)->ah_caps.halTxChainMask> ANTENNA1_CHAINMASK) 			ahp->ah_tx_chainmask = ANTENNA1_CHAINMASK; 		ahp->ah_rx_chainmask = ANTENNA1_CHAINMASK; 		break; 	case HAL_ANT_VARIABLE:
comment|/* Restore original chainmask settings */
comment|/* XXX */
block|ahp->ah_tx_chainmask = AR9280_DEFAULT_TXCHAINMASK; 		ahp->ah_rx_chainmask = AR9280_DEFAULT_RXCHAINMASK; 		break; 	}  	HALDEBUG(ah, HAL_DEBUG_ANY, "%s: settings=%d, tx/rx chainmask=%d/%d\n", 	    __func__, settings, ahp->ah_tx_chainmask, ahp->ah_rx_chainmask);
endif|#
directive|endif
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|ANTENNA0_CHAINMASK
undef|#
directive|undef
name|ANTENNA1_CHAINMASK
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ar9280Probe
parameter_list|(
name|uint16_t
name|vendorid
parameter_list|,
name|uint16_t
name|devid
parameter_list|)
block|{
if|if
condition|(
name|vendorid
operator|==
name|ATHEROS_VENDOR_ID
condition|)
block|{
if|if
condition|(
name|devid
operator|==
name|AR9280_DEVID_PCI
condition|)
return|return
literal|"Atheros 9220"
return|;
if|if
condition|(
name|devid
operator|==
name|AR9280_DEVID_PCIE
condition|)
return|return
literal|"Atheros 9280"
return|;
block|}
return|return
name|AH_NULL
return|;
block|}
end_function

begin_expr_stmt
name|AH_CHIP
argument_list|(
name|AR9280
argument_list|,
name|ar9280Probe
argument_list|,
name|ar9280Attach
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

