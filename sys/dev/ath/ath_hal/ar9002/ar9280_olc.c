begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2011 Adrian Chadd, Xenion Pty Ltd.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_eeprom_v14.h"
end_include

begin_include
include|#
directive|include
file|"ar9002/ar9280.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416phy.h"
end_include

begin_include
include|#
directive|include
file|"ar9002/ar9002phy.h"
end_include

begin_include
include|#
directive|include
file|"ar9002/ar9280_olc.h"
end_include

begin_function
name|void
name|ar9280olcInit
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
comment|/* Only do OLC if it's enabled for this chipset */
if|if
condition|(
operator|!
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_OL_PWRCTRL
argument_list|)
condition|)
return|return;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s: Setting up TX gain tables.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR9280_TX_GAIN_TABLE_SIZE
condition|;
name|i
operator|++
control|)
name|AH9280
argument_list|(
name|ah
argument_list|)
operator|->
name|originalGain
index|[
name|i
index|]
operator|=
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_GAIN_TBL1
operator|+
name|i
operator|*
literal|4
argument_list|)
argument_list|,
name|AR_PHY_TX_GAIN
argument_list|)
expr_stmt|;
name|AH9280
argument_list|(
name|ah
argument_list|)
operator|->
name|PDADCdelta
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ar9280olcGetTxGainIndex
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|struct
name|calDataPerFreqOpLoop
modifier|*
name|rawDatasetOpLoop
parameter_list|,
name|uint8_t
modifier|*
name|calChans
parameter_list|,
name|uint16_t
name|availPiers
parameter_list|,
name|uint8_t
modifier|*
name|pwr
parameter_list|,
name|uint8_t
modifier|*
name|pcdacIdx
parameter_list|)
block|{
name|uint8_t
name|pcdac
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|uint16_t
name|idxL
init|=
literal|0
decl_stmt|,
name|idxR
init|=
literal|0
decl_stmt|,
name|numPiers
decl_stmt|;
name|HAL_BOOL
name|match
decl_stmt|;
name|CHAN_CENTERS
name|centers
decl_stmt|;
name|ar5416GetChannelCenters
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|&
name|centers
argument_list|)
expr_stmt|;
for|for
control|(
name|numPiers
operator|=
literal|0
init|;
name|numPiers
operator|<
name|availPiers
condition|;
name|numPiers
operator|++
control|)
if|if
condition|(
name|calChans
index|[
name|numPiers
index|]
operator|==
name|AR5416_BCHAN_UNUSED
condition|)
break|break;
name|match
operator|=
name|ath_ee_getLowerUpperIndex
argument_list|(
operator|(
name|uint8_t
operator|)
name|FREQ2FBIN
argument_list|(
name|centers
operator|.
name|synth_center
argument_list|,
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
argument_list|,
name|calChans
argument_list|,
name|numPiers
argument_list|,
operator|&
name|idxL
argument_list|,
operator|&
name|idxR
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
condition|)
block|{
name|pcdac
operator|=
name|rawDatasetOpLoop
index|[
name|idxL
index|]
operator|.
name|pcdac
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|pwr
operator|=
name|rawDatasetOpLoop
index|[
name|idxL
index|]
operator|.
name|pwrPdg
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|pcdac
operator|=
name|rawDatasetOpLoop
index|[
name|idxR
index|]
operator|.
name|pcdac
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|pwr
operator|=
operator|(
name|rawDatasetOpLoop
index|[
name|idxL
index|]
operator|.
name|pwrPdg
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
name|rawDatasetOpLoop
index|[
name|idxR
index|]
operator|.
name|pwrPdg
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|)
operator|/
literal|2
expr_stmt|;
block|}
while|while
condition|(
name|pcdac
operator|>
name|AH9280
argument_list|(
name|ah
argument_list|)
operator|->
name|originalGain
index|[
name|i
index|]
operator|&&
name|i
operator|<
operator|(
name|AR9280_TX_GAIN_TABLE_SIZE
operator|-
literal|1
operator|)
condition|)
name|i
operator|++
expr_stmt|;
operator|*
name|pcdacIdx
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX txPower here is likely not the target txPower in the traditional  * XXX sense, but is set by a call to ar9280olcGetTxGainIndex().  * XXX Thus, be careful if you're trying to use this routine yourself.  */
end_comment

begin_function
name|void
name|ar9280olcGetPDADCs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|initTxGain
parameter_list|,
name|int
name|txPower
parameter_list|,
name|uint8_t
modifier|*
name|pPDADCValues
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_PWRCTRL6_0
argument_list|,
name|AR_PHY_TX_PWRCTRL_ERR_EST_MODE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_PWRCTRL6_1
argument_list|,
name|AR_PHY_TX_PWRCTRL_ERR_EST_MODE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_PWRCTRL7
argument_list|,
name|AR_PHY_TX_PWRCTRL_INIT_TX_GAIN
argument_list|,
name|initTxGain
argument_list|)
expr_stmt|;
name|offset
operator|=
name|txPower
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR5416_NUM_PDADC_VALUES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|<
name|offset
condition|)
name|pPDADCValues
index|[
name|i
index|]
operator|=
literal|0x0
expr_stmt|;
else|else
name|pPDADCValues
index|[
name|i
index|]
operator|=
literal|0xFF
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Run temperature compensation calibration.  *  * The TX gain table is adjusted depending upon the difference  * between the initial PDADC value and the currently read  * average TX power sample value. This value is only valid if  * frames have been transmitted, so currPDADC will be 0 if  * no frames have yet been transmitted.  */
end_comment

begin_function
name|void
name|ar9280olcTemperatureCompensation
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|uint32_t
name|rddata
decl_stmt|,
name|i
decl_stmt|;
name|int
name|delta
decl_stmt|,
name|currPDADC
decl_stmt|,
name|regval
decl_stmt|;
name|uint8_t
name|hpwr_5g
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_OL_PWRCTRL
argument_list|)
condition|)
return|return;
name|rddata
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_PWRCTRL4
argument_list|)
expr_stmt|;
name|currPDADC
operator|=
name|MS
argument_list|(
name|rddata
argument_list|,
name|AR_PHY_TX_PWRCTRL_PD_AVG_OUT
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"%s: called: initPDADC=%d, currPDADC=%d\n"
argument_list|,
name|__func__
argument_list|,
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|initPDADC
argument_list|,
name|currPDADC
argument_list|)
expr_stmt|;
if|if
condition|(
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|initPDADC
operator|==
literal|0
operator|||
name|currPDADC
operator|==
literal|0
condition|)
return|return;
call|(
name|void
call|)
argument_list|(
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_DAC_HPWR_5G
argument_list|,
operator|&
name|hpwr_5g
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpwr_5g
condition|)
name|delta
operator|=
operator|(
name|currPDADC
operator|-
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|initPDADC
operator|+
literal|4
operator|)
operator|/
literal|8
expr_stmt|;
else|else
name|delta
operator|=
operator|(
name|currPDADC
operator|-
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|initPDADC
operator|+
literal|5
operator|)
operator|/
literal|10
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PERCAL
argument_list|,
literal|"%s: delta=%d, PDADCdelta=%d\n"
argument_list|,
name|__func__
argument_list|,
name|delta
argument_list|,
name|AH9280
argument_list|(
name|ah
argument_list|)
operator|->
name|PDADCdelta
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|!=
name|AH9280
argument_list|(
name|ah
argument_list|)
operator|->
name|PDADCdelta
condition|)
block|{
name|AH9280
argument_list|(
name|ah
argument_list|)
operator|->
name|PDADCdelta
operator|=
name|delta
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|AR9280_TX_GAIN_TABLE_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|regval
operator|=
name|AH9280
argument_list|(
name|ah
argument_list|)
operator|->
name|originalGain
index|[
name|i
index|]
operator|-
name|delta
expr_stmt|;
if|if
condition|(
name|regval
operator|<
literal|0
condition|)
name|regval
operator|=
literal|0
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_GAIN_TBL1
operator|+
name|i
operator|*
literal|4
argument_list|,
name|AR_PHY_TX_GAIN
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int16_t
name|ar9280ChangeGainBoundarySettings
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint16_t
modifier|*
name|gb
parameter_list|,
name|uint16_t
name|numXpdGain
parameter_list|,
name|uint16_t
name|pdGainOverlap_t2
parameter_list|,
name|int8_t
name|pwr_table_offset
parameter_list|,
name|int16_t
modifier|*
name|diff
parameter_list|)
block|{
name|uint16_t
name|k
decl_stmt|;
comment|/* Prior to writing the boundaries or the pdadc vs. power table 	 * into the chip registers the default starting point on the pdadc 	 * vs. power table needs to be checked and the curve boundaries 	 * adjusted accordingly 	 */
if|if
condition|(
name|AR_SREV_MERLIN_20_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|uint16_t
name|gb_limit
decl_stmt|;
if|if
condition|(
name|AR5416_PWR_TABLE_OFFSET_DB
operator|!=
name|pwr_table_offset
condition|)
block|{
comment|/* get the difference in dB */
operator|*
name|diff
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|pwr_table_offset
operator|-
name|AR5416_PWR_TABLE_OFFSET_DB
argument_list|)
expr_stmt|;
comment|/* get the number of half dB steps */
operator|*
name|diff
operator|*=
literal|2
expr_stmt|;
comment|/* change the original gain boundary settings 			 * by the number of half dB steps 			 */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|numXpdGain
condition|;
name|k
operator|++
control|)
name|gb
index|[
name|k
index|]
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|gb
index|[
name|k
index|]
operator|-
operator|*
name|diff
argument_list|)
expr_stmt|;
block|}
comment|/* Because of a hardware limitation, ensure the gain boundary 		 * is not larger than (63 - overlap) 		 */
name|gb_limit
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|AR5416_MAX_RATE_POWER
operator|-
name|pdGainOverlap_t2
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|numXpdGain
condition|;
name|k
operator|++
control|)
name|gb
index|[
name|k
index|]
operator|=
operator|(
name|uint16_t
operator|)
name|min
argument_list|(
name|gb_limit
argument_list|,
name|gb
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|diff
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar9280AdjustPDADCValues
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int8_t
name|pwr_table_offset
parameter_list|,
name|int16_t
name|diff
parameter_list|,
name|uint8_t
modifier|*
name|pdadcValues
parameter_list|)
block|{
define|#
directive|define
name|NUM_PDADC
parameter_list|(
name|diff
parameter_list|)
value|(AR5416_NUM_PDADC_VALUES - diff)
name|uint16_t
name|k
decl_stmt|;
comment|/* If this is a board that has a pwrTableOffset that differs from 	 * the default AR5416_PWR_TABLE_OFFSET_DB then the start of the 	 * pdadc vs pwr table needs to be adjusted prior to writing to the 	 * chip. 	 */
if|if
condition|(
name|AR_SREV_MERLIN_20_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|AR5416_PWR_TABLE_OFFSET_DB
operator|!=
name|pwr_table_offset
condition|)
block|{
comment|/* shift the table to start at the new offset */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
operator|(
name|uint16_t
operator|)
name|NUM_PDADC
argument_list|(
name|diff
argument_list|)
condition|;
name|k
operator|++
control|)
block|{
name|pdadcValues
index|[
name|k
index|]
operator|=
name|pdadcValues
index|[
name|k
operator|+
name|diff
index|]
expr_stmt|;
block|}
comment|/* fill the back of the table */
for|for
control|(
name|k
operator|=
operator|(
name|uint16_t
operator|)
name|NUM_PDADC
argument_list|(
name|diff
argument_list|)
init|;
name|k
operator|<
name|NUM_PDADC
argument_list|(
literal|0
argument_list|)
condition|;
name|k
operator|++
control|)
block|{
name|pdadcValues
index|[
name|k
index|]
operator|=
name|pdadcValues
index|[
name|NUM_PDADC
argument_list|(
name|diff
argument_list|)
index|]
expr_stmt|;
block|}
block|}
block|}
undef|#
directive|undef
name|NUM_PDADC
block|}
end_function

begin_comment
comment|/*  * This effectively disables the gain boundaries leaving it  * to the open-loop TX power control.  */
end_comment

begin_function
specifier|static
name|void
name|ar9280SetGainBoundariesOpenLoop
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|i
parameter_list|,
name|uint16_t
name|pdGainOverlap_t2
parameter_list|,
name|uint16_t
name|gainBoundaries
index|[]
parameter_list|)
block|{
name|int
name|regChainOffset
decl_stmt|;
name|regChainOffset
operator|=
name|ar5416GetRegChainOffset
argument_list|(
name|ah
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* These are unused for OLC */
operator|(
name|void
operator|)
name|pdGainOverlap_t2
expr_stmt|;
operator|(
name|void
operator|)
name|gainBoundaries
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: chain %d: writing closed loop values\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPCRG5
operator|+
name|regChainOffset
argument_list|,
name|SM
argument_list|(
literal|0x6
argument_list|,
name|AR_PHY_TPCRG5_PD_GAIN_OVERLAP
argument_list|)
operator||
name|SM
argument_list|(
literal|0x38
argument_list|,
name|AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_1
argument_list|)
operator||
name|SM
argument_list|(
literal|0x38
argument_list|,
name|AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_2
argument_list|)
operator||
name|SM
argument_list|(
literal|0x38
argument_list|,
name|AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_3
argument_list|)
operator||
name|SM
argument_list|(
literal|0x38
argument_list|,
name|AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_4
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Eeprom versioning macros. Returns true if the version is equal or newer than the ver specified */
end_comment

begin_comment
comment|/* XXX shouldn't be here! */
end_comment

begin_define
define|#
directive|define
name|EEP_MINOR
parameter_list|(
name|_ah
parameter_list|)
define|\
value|(AH_PRIVATE(_ah)->ah_eeversion& AR5416_EEP_VER_MINOR_MASK)
end_define

begin_define
define|#
directive|define
name|IS_EEP_MINOR_V2
parameter_list|(
name|_ah
parameter_list|)
value|(EEP_MINOR(_ah)>= AR5416_EEP_MINOR_VER_2)
end_define

begin_define
define|#
directive|define
name|IS_EEP_MINOR_V3
parameter_list|(
name|_ah
parameter_list|)
value|(EEP_MINOR(_ah)>= AR5416_EEP_MINOR_VER_3)
end_define

begin_comment
comment|/**************************************************************  * ar9280SetPowerCalTable  *  * Pull the PDADC piers from cal data and interpolate them across the given  * points as well as from the nearest pier(s) to get a power detector  * linear voltage to power level table.  *  * Handle OLC for Merlin where required.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9280SetPowerCalTable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ar5416eeprom
modifier|*
name|pEepData
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|int16_t
modifier|*
name|pTxPowerIndexOffset
parameter_list|)
block|{
name|CAL_DATA_PER_FREQ
modifier|*
name|pRawDataset
decl_stmt|;
name|uint8_t
modifier|*
name|pCalBChans
init|=
name|AH_NULL
decl_stmt|;
name|uint16_t
name|pdGainOverlap_t2
decl_stmt|;
specifier|static
name|uint8_t
name|pdadcValues
index|[
name|AR5416_NUM_PDADC_VALUES
index|]
decl_stmt|;
name|uint16_t
name|gainBoundaries
index|[
name|AR5416_PD_GAINS_IN_MASK
index|]
decl_stmt|;
name|uint16_t
name|numPiers
decl_stmt|,
name|i
decl_stmt|;
name|int16_t
name|tMinCalPower
decl_stmt|;
name|uint16_t
name|numXpdGain
decl_stmt|,
name|xpdMask
decl_stmt|;
name|uint16_t
name|xpdGainValues
index|[
name|AR5416_NUM_PD_GAINS
index|]
decl_stmt|;
name|uint32_t
name|regChainOffset
decl_stmt|;
name|int8_t
name|pwr_table_offset
decl_stmt|;
name|OS_MEMZERO
argument_list|(
name|xpdGainValues
argument_list|,
sizeof|sizeof
argument_list|(
name|xpdGainValues
argument_list|)
argument_list|)
expr_stmt|;
name|xpdMask
operator|=
name|pEepData
operator|->
name|modalHeader
index|[
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
index|]
operator|.
name|xpdGain
expr_stmt|;
operator|(
name|void
operator|)
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_PWR_TABLE_OFFSET
argument_list|,
operator|&
name|pwr_table_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_EEP_MINOR_V2
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|pdGainOverlap_t2
operator|=
name|pEepData
operator|->
name|modalHeader
index|[
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
index|]
operator|.
name|pdGainOverlap
expr_stmt|;
block|}
else|else
block|{
name|pdGainOverlap_t2
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPCRG5
argument_list|)
argument_list|,
name|AR_PHY_TPCRG5_PD_GAIN_OVERLAP
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|pCalBChans
operator|=
name|pEepData
operator|->
name|calFreqPier2G
expr_stmt|;
name|numPiers
operator|=
name|AR5416_NUM_2G_CAL_PIERS
expr_stmt|;
block|}
else|else
block|{
name|pCalBChans
operator|=
name|pEepData
operator|->
name|calFreqPier5G
expr_stmt|;
name|numPiers
operator|=
name|AR5416_NUM_5G_CAL_PIERS
expr_stmt|;
block|}
comment|/* If OLC is being done, set the init PDADC value appropriately */
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
operator|&&
name|AR_SREV_MERLIN_20_OR_LATER
argument_list|(
name|ah
argument_list|)
operator|&&
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_OL_PWRCTRL
argument_list|)
condition|)
block|{
name|struct
name|calDataPerFreq
modifier|*
name|pRawDataset
init|=
name|pEepData
operator|->
name|calPierData2G
index|[
literal|0
index|]
decl_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|initPDADC
operator|=
operator|(
operator|(
expr|struct
name|calDataPerFreqOpLoop
operator|*
operator|)
name|pRawDataset
operator|)
operator|->
name|vpdPdg
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * XXX ath9k doesn't clear this for 5ghz mode if 		 * it were set in 2ghz mode before! 		 * The Merlin OLC temperature compensation code 		 * uses this to calculate the PDADC delta during 		 * calibration ; 0 here effectively stops the 		 * temperature compensation calibration from 		 * occuring. 		 */
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|initPDADC
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Calculate the value of xpdgains from the xpdGain Mask */
name|numXpdGain
operator|=
name|ar5416GetXpdGainValues
argument_list|(
name|ah
argument_list|,
name|xpdMask
argument_list|,
name|xpdGainValues
argument_list|)
expr_stmt|;
comment|/* Write the detector gain biases and their number */
name|ar5416WriteDetectorGainBiases
argument_list|(
name|ah
argument_list|,
name|numXpdGain
argument_list|,
name|xpdGainValues
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR5416_MAX_CHAINS
condition|;
name|i
operator|++
control|)
block|{
name|regChainOffset
operator|=
name|ar5416GetRegChainOffset
argument_list|(
name|ah
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|pEepData
operator|->
name|baseEepHeader
operator|.
name|txMask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|uint16_t
name|diff
decl_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|pRawDataset
operator|=
name|pEepData
operator|->
name|calPierData2G
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|pRawDataset
operator|=
name|pEepData
operator|->
name|calPierData5G
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Fetch the gain boundaries and the PDADC values */
if|if
condition|(
name|AR_SREV_MERLIN_20_OR_LATER
argument_list|(
name|ah
argument_list|)
operator|&&
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_OL_PWRCTRL
argument_list|)
condition|)
block|{
name|uint8_t
name|pcdacIdx
decl_stmt|;
name|uint8_t
name|txPower
decl_stmt|;
name|ar9280olcGetTxGainIndex
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|(
expr|struct
name|calDataPerFreqOpLoop
operator|*
operator|)
name|pRawDataset
argument_list|,
name|pCalBChans
argument_list|,
name|numPiers
argument_list|,
operator|&
name|txPower
argument_list|,
operator|&
name|pcdacIdx
argument_list|)
expr_stmt|;
name|ar9280olcGetPDADCs
argument_list|(
name|ah
argument_list|,
name|pcdacIdx
argument_list|,
name|txPower
operator|/
literal|2
argument_list|,
name|pdadcValues
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ar5416GetGainBoundariesAndPdadcs
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|pRawDataset
argument_list|,
name|pCalBChans
argument_list|,
name|numPiers
argument_list|,
name|pdGainOverlap_t2
argument_list|,
operator|&
name|tMinCalPower
argument_list|,
name|gainBoundaries
argument_list|,
name|pdadcValues
argument_list|,
name|numXpdGain
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Prior to writing the boundaries or the pdadc vs. power table 			 * into the chip registers the default starting point on the pdadc 			 * vs. power table needs to be checked and the curve boundaries 			 * adjusted accordingly 			 */
name|diff
operator|=
name|ar9280ChangeGainBoundarySettings
argument_list|(
name|ah
argument_list|,
name|gainBoundaries
argument_list|,
name|numXpdGain
argument_list|,
name|pdGainOverlap_t2
argument_list|,
name|pwr_table_offset
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|||
name|AR_SREV_5416_V20_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Set gain boundaries for either open- or closed-loop TPC */
if|if
condition|(
name|AR_SREV_MERLIN_20_OR_LATER
argument_list|(
name|ah
argument_list|)
operator|&&
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_OL_PWRCTRL
argument_list|)
condition|)
name|ar9280SetGainBoundariesOpenLoop
argument_list|(
name|ah
argument_list|,
name|i
argument_list|,
name|pdGainOverlap_t2
argument_list|,
name|gainBoundaries
argument_list|)
expr_stmt|;
else|else
name|ar5416SetGainBoundariesClosedLoop
argument_list|(
name|ah
argument_list|,
name|i
argument_list|,
name|pdGainOverlap_t2
argument_list|,
name|gainBoundaries
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If this is a board that has a pwrTableOffset that differs from 			 * the default AR5416_PWR_TABLE_OFFSET_DB then the start of the 			 * pdadc vs pwr table needs to be adjusted prior to writing to the 			 * chip. 			 */
name|ar9280AdjustPDADCValues
argument_list|(
name|ah
argument_list|,
name|pwr_table_offset
argument_list|,
name|diff
argument_list|,
name|pdadcValues
argument_list|)
expr_stmt|;
comment|/* Write the power values into the baseband power table */
name|ar5416WritePdadcValues
argument_list|(
name|ah
argument_list|,
name|i
argument_list|,
name|pdadcValues
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|pTxPowerIndexOffset
operator|=
literal|0
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

end_unit

