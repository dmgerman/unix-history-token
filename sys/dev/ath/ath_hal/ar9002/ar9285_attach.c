begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2008-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_devid.h"
end_include

begin_include
include|#
directive|include
file|"ah_eeprom_v4k.h"
end_include

begin_comment
comment|/* XXX for tx/rx gain */
end_comment

begin_include
include|#
directive|include
file|"ar9002/ar9280.h"
end_include

begin_include
include|#
directive|include
file|"ar9002/ar9285.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5416/ar5416phy.h"
end_include

begin_include
include|#
directive|include
file|"ar9002/ar9285.ini"
end_include

begin_include
include|#
directive|include
file|"ar9002/ar9285v2.ini"
end_include

begin_include
include|#
directive|include
file|"ar9002/ar9280v2.ini"
end_include

begin_comment
comment|/* XXX ini for tx/rx gain */
end_comment

begin_include
include|#
directive|include
file|"ar9002/ar9285_cal.h"
end_include

begin_include
include|#
directive|include
file|"ar9002/ar9285_phy.h"
end_include

begin_include
include|#
directive|include
file|"ar9002/ar9285_diversity.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|HAL_PERCAL_DATA
name|ar9280_iq_cal
init|=
block|{
comment|/* single sample */
operator|.
name|calName
operator|=
literal|"IQ"
block|,
operator|.
name|calType
operator|=
name|IQ_MISMATCH_CAL
block|,
operator|.
name|calNumSamples
operator|=
name|MIN_CAL_SAMPLES
block|,
operator|.
name|calCountMax
operator|=
name|PER_MAX_LOG_COUNT
block|,
operator|.
name|calCollect
operator|=
name|ar5416IQCalCollect
block|,
operator|.
name|calPostProc
operator|=
name|ar5416IQCalibration
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|HAL_PERCAL_DATA
name|ar9280_adc_gain_cal
init|=
block|{
comment|/* single sample */
operator|.
name|calName
operator|=
literal|"ADC Gain"
block|,
operator|.
name|calType
operator|=
name|ADC_GAIN_CAL
block|,
operator|.
name|calNumSamples
operator|=
name|MIN_CAL_SAMPLES
block|,
operator|.
name|calCountMax
operator|=
name|PER_MIN_LOG_COUNT
block|,
operator|.
name|calCollect
operator|=
name|ar5416AdcGainCalCollect
block|,
operator|.
name|calPostProc
operator|=
name|ar5416AdcGainCalibration
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|HAL_PERCAL_DATA
name|ar9280_adc_dc_cal
init|=
block|{
comment|/* single sample */
operator|.
name|calName
operator|=
literal|"ADC DC"
block|,
operator|.
name|calType
operator|=
name|ADC_DC_CAL
block|,
operator|.
name|calNumSamples
operator|=
name|MIN_CAL_SAMPLES
block|,
operator|.
name|calCountMax
operator|=
name|PER_MIN_LOG_COUNT
block|,
operator|.
name|calCollect
operator|=
name|ar5416AdcDcCalCollect
block|,
operator|.
name|calPostProc
operator|=
name|ar5416AdcDcCalibration
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|HAL_PERCAL_DATA
name|ar9280_adc_init_dc_cal
init|=
block|{
operator|.
name|calName
operator|=
literal|"ADC Init DC"
block|,
operator|.
name|calType
operator|=
name|ADC_DC_INIT_CAL
block|,
operator|.
name|calNumSamples
operator|=
name|MIN_CAL_SAMPLES
block|,
operator|.
name|calCountMax
operator|=
name|INIT_LOG_COUNT
block|,
operator|.
name|calCollect
operator|=
name|ar5416AdcDcCalCollect
block|,
operator|.
name|calPostProc
operator|=
name|ar5416AdcDcCalibration
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ar9285ConfigPCIE
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|restore
parameter_list|,
name|HAL_BOOL
name|power_off
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar9285DisablePCIE
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar9285FillCapabilityInfo
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar9285WriteIni
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|ar9285AniSetup
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
comment|/* 	 * These are the parameters from the AR5416 ANI code; 	 * they likely need quite a bit of adjustment for the 	 * AR9285. 	 */
specifier|static
specifier|const
name|struct
name|ar5212AniParams
name|aniparams
init|=
block|{
operator|.
name|maxNoiseImmunityLevel
operator|=
literal|4
block|,
comment|/* levels 0..4 */
operator|.
name|totalSizeDesired
operator|=
block|{
operator|-
literal|55
block|,
operator|-
literal|55
block|,
operator|-
literal|55
block|,
operator|-
literal|55
block|,
operator|-
literal|62
block|}
block|,
operator|.
name|coarseHigh
operator|=
block|{
operator|-
literal|14
block|,
operator|-
literal|14
block|,
operator|-
literal|14
block|,
operator|-
literal|14
block|,
operator|-
literal|12
block|}
block|,
operator|.
name|coarseLow
operator|=
block|{
operator|-
literal|64
block|,
operator|-
literal|64
block|,
operator|-
literal|64
block|,
operator|-
literal|64
block|,
operator|-
literal|70
block|}
block|,
operator|.
name|firpwr
operator|=
block|{
operator|-
literal|78
block|,
operator|-
literal|78
block|,
operator|-
literal|78
block|,
operator|-
literal|78
block|,
operator|-
literal|80
block|}
block|,
operator|.
name|maxSpurImmunityLevel
operator|=
literal|7
block|,
operator|.
name|cycPwrThr1
operator|=
block|{
literal|2
block|,
literal|4
block|,
literal|6
block|,
literal|8
block|,
literal|10
block|,
literal|12
block|,
literal|14
block|,
literal|16
block|}
block|,
operator|.
name|maxFirstepLevel
operator|=
literal|2
block|,
comment|/* levels 0..2 */
operator|.
name|firstep
operator|=
block|{
literal|0
block|,
literal|4
block|,
literal|8
block|}
block|,
operator|.
name|ofdmTrigHigh
operator|=
literal|500
block|,
operator|.
name|ofdmTrigLow
operator|=
literal|200
block|,
operator|.
name|cckTrigHigh
operator|=
literal|200
block|,
operator|.
name|cckTrigLow
operator|=
literal|100
block|,
operator|.
name|rssiThrHigh
operator|=
literal|40
block|,
operator|.
name|rssiThrLow
operator|=
literal|7
block|,
operator|.
name|period
operator|=
literal|100
block|,         }
decl_stmt|;
comment|/* NB: disable ANI noise immmunity for reliable RIFS rx */
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ani_function
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|HAL_ANI_NOISE_IMMUNITY_LEVEL
operator|)
expr_stmt|;
name|ar5416AniAttach
argument_list|(
name|ah
argument_list|,
operator|&
name|aniparams
argument_list|,
operator|&
name|aniparams
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ar9285_lna_conf
index|[]
init|=
block|{
literal|"LNA1-LNA2"
block|,
literal|"LNA2"
block|,
literal|"LNA1"
block|,
literal|"LNA1+LNA2"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ar9285_eeprom_print_diversity_settings
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
specifier|const
name|HAL_EEPROM_v4k
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
specifier|const
name|MODAL_EEP4K_HEADER
modifier|*
name|pModal
init|=
operator|&
name|ee
operator|->
name|ee_base
operator|.
name|modalHeader
decl_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"[ath] AR9285 Main LNA config: %s\n"
argument_list|,
name|ar9285_lna_conf
index|[
operator|(
name|pModal
operator|->
name|antdiv_ctl2
operator|>>
literal|2
operator|)
operator|&
literal|0x3
index|]
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"[ath] AR9285 Alt LNA config: %s\n"
argument_list|,
name|ar9285_lna_conf
index|[
name|pModal
operator|->
name|antdiv_ctl2
operator|&
literal|0x3
index|]
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"[ath] LNA diversity %s, Diversity %s\n"
argument_list|,
operator|(
operator|(
name|pModal
operator|->
name|antdiv_ctl1
operator|&
literal|0x1
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
operator|)
argument_list|,
operator|(
operator|(
name|pModal
operator|->
name|antdiv_ctl1
operator|&
literal|0x8
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attach for an AR9285 part.  */
end_comment

begin_function
specifier|static
name|struct
name|ath_hal
modifier|*
name|ar9285Attach
parameter_list|(
name|uint16_t
name|devid
parameter_list|,
name|HAL_SOFTC
name|sc
parameter_list|,
name|HAL_BUS_TAG
name|st
parameter_list|,
name|HAL_BUS_HANDLE
name|sh
parameter_list|,
name|uint16_t
modifier|*
name|eepromdata
parameter_list|,
name|HAL_OPS_CONFIG
modifier|*
name|ah_config
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
name|struct
name|ath_hal_9285
modifier|*
name|ahp9285
decl_stmt|;
name|struct
name|ath_hal_5212
modifier|*
name|ahp
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|HAL_STATUS
name|ecode
decl_stmt|;
name|HAL_BOOL
name|rfStatus
decl_stmt|;
name|HALDEBUG
argument_list|(
name|AH_NULL
argument_list|,
name|HAL_DEBUG_ATTACH
argument_list|,
literal|"%s: sc %p st %p sh %p\n"
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|st
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sh
argument_list|)
expr_stmt|;
comment|/* NB: memory is returned zero'd */
name|ahp9285
operator|=
name|ath_hal_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ath_hal_9285
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp9285
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|AH_NULL
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: cannot allocate memory for state block\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|HAL_ENOMEM
expr_stmt|;
return|return
name|AH_NULL
return|;
block|}
name|ahp
operator|=
name|AH5212
argument_list|(
name|ahp9285
argument_list|)
expr_stmt|;
name|ah
operator|=
operator|&
name|ahp
operator|->
name|ah_priv
operator|.
name|h
expr_stmt|;
name|ar5416InitState
argument_list|(
name|AH5416
argument_list|(
name|ah
argument_list|)
argument_list|,
name|devid
argument_list|,
name|sc
argument_list|,
name|st
argument_list|,
name|sh
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* 	 * Use the "local" EEPROM data given to us by the higher layers. 	 * This is a private copy out of system flash. The Linux ath9k 	 * commit for the initial AR9130 support mentions MMIO flash 	 * access is "unreliable." -adrian 	 */
if|if
condition|(
name|eepromdata
operator|!=
name|AH_NULL
condition|)
block|{
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eepromRead
operator|=
name|ath_hal_EepromDataRead
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eepromWrite
operator|=
name|NULL
expr_stmt|;
name|ah
operator|->
name|ah_eepromdata
operator|=
name|eepromdata
expr_stmt|;
block|}
comment|/* override with 9285 specific state */
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_initPLL
operator|=
name|ar9280InitPLL
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_btCoexSetDiversity
operator|=
name|ar9285BTCoexAntennaDiversity
expr_stmt|;
name|ah
operator|->
name|ah_setAntennaSwitch
operator|=
name|ar9285SetAntennaSwitch
expr_stmt|;
name|ah
operator|->
name|ah_configPCIE
operator|=
name|ar9285ConfigPCIE
expr_stmt|;
name|ah
operator|->
name|ah_disablePCIE
operator|=
name|ar9285DisablePCIE
expr_stmt|;
name|ah
operator|->
name|ah_setTxPower
operator|=
name|ar9285SetTransmitPower
expr_stmt|;
name|ah
operator|->
name|ah_setBoardValues
operator|=
name|ar9285SetBoardValues
expr_stmt|;
name|ah
operator|->
name|ah_btCoexSetParameter
operator|=
name|ar9285BTCoexSetParameter
expr_stmt|;
name|ah
operator|->
name|ah_divLnaConfGet
operator|=
name|ar9285_antdiv_comb_conf_get
expr_stmt|;
name|ah
operator|->
name|ah_divLnaConfSet
operator|=
name|ar9285_antdiv_comb_conf_set
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
operator|.
name|iqCalData
operator|.
name|calData
operator|=
operator|&
name|ar9280_iq_cal
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
operator|.
name|adcGainCalData
operator|.
name|calData
operator|=
operator|&
name|ar9280_adc_gain_cal
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
operator|.
name|adcDcCalData
operator|.
name|calData
operator|=
operator|&
name|ar9280_adc_dc_cal
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
operator|.
name|adcDcCalInitData
operator|.
name|calData
operator|=
operator|&
name|ar9280_adc_init_dc_cal
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
operator|.
name|suppCals
operator|=
name|ADC_GAIN_CAL
operator||
name|ADC_DC_CAL
operator||
name|IQ_MISMATCH_CAL
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_spurMitigate
operator|=
name|ar9280SpurMitigate
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_writeIni
operator|=
name|ar9285WriteIni
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rx_chainmask
operator|=
name|AR9285_DEFAULT_RXCHAINMASK
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tx_chainmask
operator|=
name|AR9285_DEFAULT_TXCHAINMASK
expr_stmt|;
name|ahp
operator|->
name|ah_maxTxTrigLev
operator|=
name|MAX_TX_FIFO_THRESHOLD
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|ar5416SetResetReg
argument_list|(
name|ah
argument_list|,
name|HAL_RESET_POWER_ON
argument_list|)
condition|)
block|{
comment|/* reset chip */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: couldn't reset chip\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
name|ar5416SetPowerMode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: couldn't wakeup chip\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Read Revisions from Chips before taking out of reset */
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_SREV
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ATTACH
argument_list|,
literal|"%s: ID 0x%x VERSION 0x%x TYPE 0x%x REVISION 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|MS
argument_list|(
name|val
argument_list|,
name|AR_XSREV_ID
argument_list|)
argument_list|,
name|MS
argument_list|(
name|val
argument_list|,
name|AR_XSREV_VERSION
argument_list|)
argument_list|,
name|MS
argument_list|(
name|val
argument_list|,
name|AR_XSREV_TYPE
argument_list|)
argument_list|,
name|MS
argument_list|(
name|val
argument_list|,
name|AR_XSREV_REVISION
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NB: include chip type to differentiate from pre-Sowl versions */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|=
operator|(
name|val
operator|&
name|AR_XSREV_VERSION
operator|)
operator|>>
name|AR_XSREV_TYPE_S
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macRev
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_XSREV_REVISION
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ispcie
operator|=
operator|(
name|val
operator|&
name|AR_XSREV_TYPE_HOST_MODE
operator|)
operator|==
literal|0
expr_stmt|;
comment|/* setup common ini data; rf backends handle remainder */
if|if
condition|(
name|AR_SREV_KITE_12_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ini_modes
argument_list|,
name|ar9285Modes_v2
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ini_common
argument_list|,
name|ar9285Common_v2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|HAL_INI_INIT
argument_list|(
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_pcieserdes
argument_list|,
name|ar9285PciePhy_clkreq_always_on_L1_v2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ini_modes
argument_list|,
name|ar9285Modes
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ini_common
argument_list|,
name|ar9285Common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|HAL_INI_INIT
argument_list|(
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_pcieserdes
argument_list|,
name|ar9285PciePhy_clkreq_always_on_L1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|ar5416AttachPCIE
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* Attach methods that require MAC version/revision info */
if|if
condition|(
name|AR_SREV_KITE_12_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal_initcal
operator|=
name|ar9285InitCalHardware
expr_stmt|;
if|if
condition|(
name|AR_SREV_KITE_11_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal_pacal
operator|=
name|ar9002_hw_pa_cal
expr_stmt|;
name|ecode
operator|=
name|ath_hal_v4kEepromAttach
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecode
operator|!=
name|HAL_OK
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|!
name|ar5416ChipReset
argument_list|(
name|ah
argument_list|,
name|AH_NULL
argument_list|)
condition|)
block|{
comment|/* reset chip */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: chip reset failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyRev
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CHIP_ID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar5212ChipTest
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: hardware self-test failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_ESELFTEST
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Set correct Baseband to analog shift 	 * setting to access analog chips. 	 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0x00000007
argument_list|)
expr_stmt|;
comment|/* Read Radio Chip Rev Extract */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
operator|=
name|ar5416GetRadioRev
argument_list|(
name|ah
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
operator|&
name|AR_RADIO_SREV_MAJOR
condition|)
block|{
case|case
name|AR_RAD2133_SREV_MAJOR
case|:
comment|/* Sowl: 2G/3x3 */
case|case
name|AR_RAD5133_SREV_MAJOR
case|:
comment|/* Sowl: 2+5G/3x3 */
break|break;
default|default:
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
operator|==
literal|0
condition|)
block|{
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
operator|=
name|AR_RAD5133_SREV_MAJOR
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|AH_DEBUG
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: 5G Radio Chip Rev 0x%02X is not supported by "
literal|"this driver\n"
argument_list|,
name|__func__
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_analog5GhzRev
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|HAL_ENOTSUPP
expr_stmt|;
goto|goto
name|bad
goto|;
endif|#
directive|endif
block|}
name|rfStatus
operator|=
name|ar9285RfAttach
argument_list|(
name|ah
argument_list|,
operator|&
name|ecode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rfStatus
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: RF setup failed, status %u\n"
argument_list|,
name|__func__
argument_list|,
name|ecode
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp9285
operator|->
name|ah_ini_rxgain
argument_list|,
name|ar9280Modes_original_rxgain_v2
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_9285E_20
argument_list|(
name|ah
argument_list|)
condition|)
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"[ath] AR9285E_20 detected; using XE TX gain tables\n"
argument_list|)
expr_stmt|;
comment|/* setup txgain table */
switch|switch
condition|(
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_TXGAIN_TYPE
argument_list|,
name|AH_NULL
argument_list|)
condition|)
block|{
case|case
name|AR5416_EEP_TXGAIN_HIGH_POWER
case|:
if|if
condition|(
name|AR_SREV_9285E_20
argument_list|(
name|ah
argument_list|)
condition|)
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp9285
operator|->
name|ah_ini_txgain
argument_list|,
name|ar9285Modes_XE2_0_high_power
argument_list|,
literal|6
argument_list|)
expr_stmt|;
else|else
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp9285
operator|->
name|ah_ini_txgain
argument_list|,
name|ar9285Modes_high_power_tx_gain_v2
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
case|case
name|AR5416_EEP_TXGAIN_ORIG
case|:
if|if
condition|(
name|AR_SREV_9285E_20
argument_list|(
name|ah
argument_list|)
condition|)
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp9285
operator|->
name|ah_ini_txgain
argument_list|,
name|ar9285Modes_XE2_0_normal_power
argument_list|,
literal|6
argument_list|)
expr_stmt|;
else|else
name|HAL_INI_INIT
argument_list|(
operator|&
name|ahp9285
operator|->
name|ah_ini_txgain
argument_list|,
name|ar9285Modes_original_tx_gain_v2
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
default|default:
name|HALASSERT
argument_list|(
name|AH_FALSE
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
comment|/* XXX ? try to continue */
block|}
comment|/* 	 * Got everything we need now to setup the capabilities. 	 */
if|if
condition|(
operator|!
name|ar9285FillCapabilityInfo
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|ecode
operator|=
name|HAL_EEREAD
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Print out the EEPROM antenna configuration mapping. 	 * Some devices have a hard-coded LNA configuration profile; 	 * others enable diversity. 	 */
name|ar9285_eeprom_print_diversity_settings
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* Print out whether the EEPROM settings enable AR9285 diversity */
if|if
condition|(
name|ar9285_check_div_comb
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"[ath] Enabling diversity for Kite\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Disable 11n for the AR2427 */
if|if
condition|(
name|devid
operator|==
name|AR2427_DEVID_PCIE
condition|)
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halHTSupport
operator|=
name|AH_FALSE
expr_stmt|;
name|ecode
operator|=
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_MACADDR
argument_list|,
name|ahp
operator|->
name|ah_macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecode
operator|!=
name|HAL_OK
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: error getting mac address from EEPROM\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* XXX How about the serial number ? */
comment|/* Read Reg Domain */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_currentRD
operator|=
name|ath_hal_eepromGet
argument_list|(
name|ah
argument_list|,
name|AR_EEP_REGDMN_0
argument_list|,
name|AH_NULL
argument_list|)
expr_stmt|;
comment|/*          * For Kite and later chipsets, the following bits are not 	 * programmed in EEPROM and so are set as enabled always. 	 */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_currentRDext
operator|=
name|AR9285_RDEXT_DEFAULT
expr_stmt|;
comment|/* 	 * ah_miscMode is populated by ar5416FillCapabilityInfo() 	 * starting from griffin. Set here to make sure that 	 * AR_MISC_MODE_MIC_NEW_LOC_ENABLE is set before a GTK is 	 * placed into hardware. 	 */
if|if
condition|(
name|ahp
operator|->
name|ah_miscMode
operator|!=
literal|0
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MISC_MODE
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_MISC_MODE
argument_list|)
operator||
name|ahp
operator|->
name|ah_miscMode
argument_list|)
expr_stmt|;
name|ar9285AniSetup
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* Anti Noise Immunity */
comment|/* Setup noise floor min/max/nominal values */
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_2g
operator|.
name|max
operator|=
name|AR_PHY_CCA_MAX_GOOD_VAL_9285_2GHZ
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_2g
operator|.
name|min
operator|=
name|AR_PHY_CCA_MIN_GOOD_VAL_9285_2GHZ
expr_stmt|;
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_2g
operator|.
name|nominal
operator|=
name|AR_PHY_CCA_NOM_VAL_9285_2GHZ
expr_stmt|;
comment|/* XXX no 5ghz values? */
name|ar5416InitNfHistBuff
argument_list|(
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_cal
operator|.
name|nfCalHist
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ATTACH
argument_list|,
literal|"%s: return\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ah
return|;
name|bad
label|:
if|if
condition|(
name|ah
operator|!=
name|AH_NULL
condition|)
name|ah
operator|->
name|ah_detach
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
operator|*
name|status
operator|=
name|ecode
expr_stmt|;
return|return
name|AH_NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar9285ConfigPCIE
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|restore
parameter_list|,
name|HAL_BOOL
name|power_off
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
comment|/* 	 * This workaround needs some integration work with the HAL 	 * config parameters and the if_ath_pci.c glue. 	 * Specifically, read the value of the PCI register 0x70c 	 * (4 byte PCI config space register) and store it in ath_hal_war70c. 	 * Then if it's non-zero, the below WAR would override register 	 * 0x570c upon suspend/resume. 	 */
if|#
directive|if
literal|0
block|if (AR_SREV_9285E_20(ah)) { 		val = AH_PRIVATE(ah)->ah_config.ath_hal_war70c; 		if (val) { 			val&= 0xffff00ff; 			val |= 0x6f00; 			OS_REG_WRITE(ah, 0x570c, val); 		} 	}
endif|#
directive|endif
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ispcie
operator|&&
operator|!
name|restore
condition|)
block|{
name|ath_hal_ini_write
argument_list|(
name|ah
argument_list|,
operator|&
name|AH5416
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_pcieserdes
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set PCIe workaround bits 	 * 	 * NOTE: 	 * 	 * In Merlin and Kite, bit 14 in WA register (disable L1) should only 	 * be set when device enters D3 and be cleared when device comes back 	 * to D0. 	 */
if|if
condition|(
name|power_off
condition|)
block|{
comment|/* Power-off */
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_PM_CTRL
argument_list|,
name|AR_PCIE_PM_CTRL_ENA
argument_list|)
expr_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WA
argument_list|)
expr_stmt|;
comment|/* 		 * Disable bit 6 and 7 before entering D3 to prevent 		 * system hang. 		 */
name|val
operator|&=
operator|~
operator|(
name|AR_WA_BIT6
operator||
name|AR_WA_BIT7
operator|)
expr_stmt|;
comment|/* 		 * See above: set AR_WA_D3_L1_DISABLE when entering D3 state. 		 * 		 * XXX The reference HAL does it this way - it only sets 		 * AR_WA_D3_L1_DISABLE if it's set in AR9280_WA_DEFAULT, 		 * which it (currently) isn't.  So the following statement 		 * is currently a NOP. 		 */
if|if
condition|(
name|AR9285_WA_DEFAULT
operator|&
name|AR_WA_D3_L1_DISABLE
condition|)
name|val
operator||=
name|AR_WA_D3_L1_DISABLE
expr_stmt|;
if|if
condition|(
name|AR_SREV_9285E_20
argument_list|(
name|ah
argument_list|)
condition|)
name|val
operator||=
name|AR_WA_BIT23
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WA
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Power-on */
name|val
operator|=
name|AR9285_WA_DEFAULT
expr_stmt|;
comment|/* 		 * See note above: make sure L1_DISABLE is not set. 		 */
name|val
operator|&=
operator|(
operator|~
name|AR_WA_D3_L1_DISABLE
operator|)
expr_stmt|;
comment|/* Software workaroud for ASPM system hang. */
name|val
operator||=
operator|(
name|AR_WA_BIT6
operator||
name|AR_WA_BIT7
operator|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_9285E_20
argument_list|(
name|ah
argument_list|)
condition|)
name|val
operator||=
name|AR_WA_BIT23
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WA
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* set bit 19 to allow forcing of pcie core into L1 state */
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_PM_CTRL
argument_list|,
name|AR_PCIE_PM_CTRL_ENA
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ar9285DisablePCIE
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|ar9285WriteIni
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|u_int
name|modesIndex
decl_stmt|,
name|freqIndex
decl_stmt|;
name|int
name|regWrites
init|=
literal|0
decl_stmt|;
comment|/* Setup the indices for the next set of register array writes */
comment|/* XXX Ignore 11n dynamic mode on the AR5416 for the moment */
name|freqIndex
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
name|modesIndex
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_108G
argument_list|(
name|chan
argument_list|)
condition|)
name|modesIndex
operator|=
literal|5
expr_stmt|;
else|else
name|modesIndex
operator|=
literal|4
expr_stmt|;
comment|/* Set correct Baseband to analog shift setting to access analog chips. */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0x00000007
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ADC_SERIAL_CTL
argument_list|,
name|AR_PHY_SEL_INTERNAL_ADDAC
argument_list|)
expr_stmt|;
name|regWrites
operator|=
name|ath_hal_ini_write
argument_list|(
name|ah
argument_list|,
operator|&
name|AH5212
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_modes
argument_list|,
name|modesIndex
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_KITE_12_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|regWrites
operator|=
name|ath_hal_ini_write
argument_list|(
name|ah
argument_list|,
operator|&
name|AH9285
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_txgain
argument_list|,
name|modesIndex
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
block|}
name|regWrites
operator|=
name|ath_hal_ini_write
argument_list|(
name|ah
argument_list|,
operator|&
name|AH5212
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ini_common
argument_list|,
literal|1
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fill all software cached or static hardware state information.  * Return failure if capabilities are to come from EEPROM and  * cannot be read.  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar9285FillCapabilityInfo
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|HAL_CAPABILITIES
modifier|*
name|pCap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
if|if
condition|(
operator|!
name|ar5416FillCapabilityInfo
argument_list|(
name|ah
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
name|pCap
operator|->
name|halNumGpioPins
operator|=
literal|12
expr_stmt|;
name|pCap
operator|->
name|halWowSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halWowMatchPatternExact
operator|=
name|AH_TRUE
expr_stmt|;
if|#
directive|if
literal|0
block|pCap->halWowMatchPatternDword = AH_TRUE;
endif|#
directive|endif
comment|/* AR9285 has 2 antennas but is a 1x1 stream device */
name|pCap
operator|->
name|halTxStreams
operator|=
literal|1
expr_stmt|;
name|pCap
operator|->
name|halRxStreams
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ar9285_check_div_comb
argument_list|(
name|ah
argument_list|)
condition|)
name|pCap
operator|->
name|halAntDivCombSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halCSTSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halRifsRxSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halRifsTxSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halRtsAggrLimit
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
comment|/* 802.11n max */
name|pCap
operator|->
name|halExtChanDfsSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halUseCombinedRadarRssi
operator|=
name|AH_TRUE
expr_stmt|;
if|#
directive|if
literal|1
comment|/* XXX bluetooth */
name|pCap
operator|->
name|halBtCoexSupport
operator|=
name|AH_TRUE
expr_stmt|;
endif|#
directive|endif
name|pCap
operator|->
name|halAutoSleepSupport
operator|=
name|AH_FALSE
expr_stmt|;
comment|/* XXX? */
name|pCap
operator|->
name|hal4kbSplitTransSupport
operator|=
name|AH_FALSE
expr_stmt|;
comment|/* Disable this so Block-ACK works correctly */
name|pCap
operator|->
name|halHasRxSelfLinkedTail
operator|=
name|AH_FALSE
expr_stmt|;
name|pCap
operator|->
name|halMbssidAggrSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|hal4AddrAggrSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halSpectralScanSupport
operator|=
name|AH_TRUE
expr_stmt|;
name|pCap
operator|->
name|halRxUsingLnaMixing
operator|=
name|AH_TRUE
expr_stmt|;
if|if
condition|(
name|AR_SREV_KITE_12_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
name|pCap
operator|->
name|halPSPollBroken
operator|=
name|AH_FALSE
expr_stmt|;
comment|/* Only RX STBC supported */
name|pCap
operator|->
name|halRxStbcSupport
operator|=
literal|1
expr_stmt|;
name|pCap
operator|->
name|halTxStbcSupport
operator|=
literal|0
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ar9285Probe
parameter_list|(
name|uint16_t
name|vendorid
parameter_list|,
name|uint16_t
name|devid
parameter_list|)
block|{
if|if
condition|(
name|vendorid
operator|==
name|ATHEROS_VENDOR_ID
operator|&&
name|devid
operator|==
name|AR9285_DEVID_PCIE
condition|)
return|return
literal|"Atheros 9285"
return|;
if|if
condition|(
name|vendorid
operator|==
name|ATHEROS_VENDOR_ID
operator|&&
operator|(
name|devid
operator|==
name|AR2427_DEVID_PCIE
operator|)
condition|)
return|return
literal|"Atheros 2427"
return|;
return|return
name|AH_NULL
return|;
block|}
end_function

begin_expr_stmt
name|AH_CHIP
argument_list|(
name|AR9285
argument_list|,
name|ar9285Probe
argument_list|,
name|ar9285Attach
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

