begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for the Atheros Wireless LAN controller.  *  * This software is derived from work of Atsushi Onoe; his contribution  * is greatly appreciated.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ath.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_superg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_tdma.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ath/if_athvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/ath_hal/ah_devid.h>
end_include

begin_comment
comment|/* XXX for softled */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
end_ifdef

begin_include
include|#
directive|include
file|<dev/ath/ath_tx99/ath_tx99.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * ATH_BCBUF determines the number of vap's that can transmit  * beacons and also (currently) the number of vap's that can  * have unique mac addresses/bssid.  When staggering beacons  * 4 is probably a good max as otherwise the beacons become  * very closely spaced and there is limited time for cab q traffic  * to go out.  You can burst beacons instead but that is not good  * for stations in power save and at some point you really want  * another radio (and channel).  *  * The limit on the number of mac addresses is tied to our use of  * the U/L bit and tracking addresses in a byte; it would be  * worthwhile to allow more for applications like proxy sta.  */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
name|ATH_BCBUF
operator|<=
literal|8
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* unaligned little endian access */
end_comment

begin_define
define|#
directive|define
name|LE_READ_2
parameter_list|(
name|p
parameter_list|)
define|\
value|((u_int16_t)							\ 	 ((((u_int8_t *)(p))[0]      ) | (((u_int8_t *)(p))[1]<<  8)))
end_define

begin_define
define|#
directive|define
name|LE_READ_4
parameter_list|(
name|p
parameter_list|)
define|\
value|((u_int32_t)							\ 	 ((((u_int8_t *)(p))[0]      ) | (((u_int8_t *)(p))[1]<<  8) |	\ 	  (((u_int8_t *)(p))[2]<< 16) | (((u_int8_t *)(p))[3]<< 24)))
end_define

begin_function_decl
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|ath_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_stop_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_reset
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_reset_vap
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_watchdog
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_fatal_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_bmiss_vap
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_bmiss_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_keyset
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_key_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
name|ieee80211_keyix
modifier|*
parameter_list|,
name|ieee80211_keyix
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_key_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_key_set
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
specifier|const
name|u_int8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_key_update_begin
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_key_update_end
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_update_mcast
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_update_promisc
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_mode_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_setslottime
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_updateslot
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_beaconq_setup
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_beacon_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_beacon_update
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|int
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_beacon_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ath_buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_beacon_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ath_buf
modifier|*
name|ath_beacon_generate
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_bstuck_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_beacon_return
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ath_buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_beacon_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_beacon_config
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_descdma_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_descdma
modifier|*
parameter_list|,
name|ath_bufhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_desc_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_desc_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|ath_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_node_free
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_node_getsignal
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int8_t
modifier|*
parameter_list|,
name|int8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_rxbuf_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ath_buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_recv_mgmt
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|subtype
parameter_list|,
name|int
name|rssi
parameter_list|,
name|int
name|nf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_setdefantenna
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_rx_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_txq_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ath_txq
modifier|*
name|ath_txq_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|int
name|qtype
parameter_list|,
name|int
name|subtype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_tx_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_wme_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_cleanupq
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ath_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_freetx
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_tx_start
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|ath_buf
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_proc_q0
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_proc_q0123
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_draintxq
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ath_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_chan_set
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_draintxq
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_stoprecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_startrecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_chan_change
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_calibrate
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_setup_stationkey
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_newassoc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_setregdomain
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|struct
name|ieee80211_regdomain
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ieee80211_channel
type|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_getradiocaps
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
type|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_getchannels
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_led_event
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_rate_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|u_int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_setcurmode
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|enum
name|ieee80211_phymode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_sysctlattach
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_announce
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_function_decl
specifier|static
name|void
name|ath_tdma_settimers
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|nexttbtt
parameter_list|,
name|u_int32_t
name|bintval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tdma_bintvalsetup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ieee80211_tdma_state
modifier|*
name|tdma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tdma_config
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tdma_update
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_tdma_param
modifier|*
name|tdma
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tdma_beacon_send
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|void
name|ath_hal_setcca
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|ena
parameter_list|)
block|{
comment|/* 	 * NB: fill me in; this is not provided by default because disabling 	 *     CCA in most locales violates regulatory. 	 */
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|ath_hal_getcca
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|u_int32_t
name|diag
decl_stmt|;
if|if
condition|(
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_DIAG
argument_list|,
literal|0
argument_list|,
operator|&
name|diag
argument_list|)
operator|!=
name|HAL_OK
condition|)
return|return
literal|1
return|;
return|return
operator|(
operator|(
name|diag
operator|&
literal|0x500000
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TDMA_EP_MULTIPLIER
value|(1<<10)
end_define

begin_comment
comment|/* pow2 to optimize out * and / */
end_comment

begin_define
define|#
directive|define
name|TDMA_LPF_LEN
value|6
end_define

begin_define
define|#
directive|define
name|TDMA_DUMMY_MARKER
value|0x127
end_define

begin_define
define|#
directive|define
name|TDMA_EP_MUL
parameter_list|(
name|x
parameter_list|,
name|mul
parameter_list|)
value|((x) * (mul))
end_define

begin_define
define|#
directive|define
name|TDMA_IN
parameter_list|(
name|x
parameter_list|)
value|(TDMA_EP_MUL((x), TDMA_EP_MULTIPLIER))
end_define

begin_define
define|#
directive|define
name|TDMA_LPF
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|len
parameter_list|)
define|\
value|((x != TDMA_DUMMY_MARKER) ? (((x) * ((len)-1) + (y)) / (len)) : (y))
end_define

begin_define
define|#
directive|define
name|TDMA_SAMPLE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|do {					\ 	x = TDMA_LPF((x), TDMA_IN(y), TDMA_LPF_LEN);		\ } while (0)
end_define

begin_define
define|#
directive|define
name|TDMA_EP_RND
parameter_list|(
name|x
parameter_list|,
name|mul
parameter_list|)
define|\
value|((((x)%(mul))>= ((mul)/2)) ? ((x) + ((mul) - 1)) / (mul) : (x)/(mul))
end_define

begin_define
define|#
directive|define
name|TDMA_AVG
parameter_list|(
name|x
parameter_list|)
value|TDMA_EP_RND(x, TDMA_EP_MULTIPLIER)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IEEE80211_SUPPORT_TDMA */
end_comment

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_ath
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* XXX validate sysctl values */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ath_longcalinterval
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* long cals every 30 secs */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|longcal
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_longcalinterval
argument_list|,
literal|0
argument_list|,
literal|"long chip calibration interval (secs)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_shortcalinterval
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* short cals every 100 ms */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|shortcal
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_shortcalinterval
argument_list|,
literal|0
argument_list|,
literal|"short chip calibration interval (msecs)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_resetcalinterval
init|=
literal|20
operator|*
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reset cal state 20 mins */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|resetcal
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_resetcalinterval
argument_list|,
literal|0
argument_list|,
literal|"reset chip calibration results (secs)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_rxbuf
init|=
name|ATH_RXBUF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # rx buffers to allocate */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|rxbuf
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_rxbuf
argument_list|,
literal|0
argument_list|,
literal|"rx buffers allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ath.rxbuf"
argument_list|,
operator|&
name|ath_rxbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_txbuf
init|=
name|ATH_TXBUF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # tx buffers to allocate */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|txbuf
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_txbuf
argument_list|,
literal|0
argument_list|,
literal|"tx buffers allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ath.txbuf"
argument_list|,
operator|&
name|ath_txbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_bstuck_threshold
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max missed beacons */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|bstuck
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_bstuck_threshold
argument_list|,
literal|0
argument_list|,
literal|"max missed beacon xmits before chip reset"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_DEBUG
end_ifdef

begin_enum
enum|enum
block|{
name|ATH_DEBUG_XMIT
init|=
literal|0x00000001
block|,
comment|/* basic xmit operation */
name|ATH_DEBUG_XMIT_DESC
init|=
literal|0x00000002
block|,
comment|/* xmit descriptors */
name|ATH_DEBUG_RECV
init|=
literal|0x00000004
block|,
comment|/* basic recv operation */
name|ATH_DEBUG_RECV_DESC
init|=
literal|0x00000008
block|,
comment|/* recv descriptors */
name|ATH_DEBUG_RATE
init|=
literal|0x00000010
block|,
comment|/* rate control */
name|ATH_DEBUG_RESET
init|=
literal|0x00000020
block|,
comment|/* reset processing */
name|ATH_DEBUG_MODE
init|=
literal|0x00000040
block|,
comment|/* mode init/setup */
name|ATH_DEBUG_BEACON
init|=
literal|0x00000080
block|,
comment|/* beacon handling */
name|ATH_DEBUG_WATCHDOG
init|=
literal|0x00000100
block|,
comment|/* watchdog timeout */
name|ATH_DEBUG_INTR
init|=
literal|0x00001000
block|,
comment|/* ISR */
name|ATH_DEBUG_TX_PROC
init|=
literal|0x00002000
block|,
comment|/* tx ISR proc */
name|ATH_DEBUG_RX_PROC
init|=
literal|0x00004000
block|,
comment|/* rx ISR proc */
name|ATH_DEBUG_BEACON_PROC
init|=
literal|0x00008000
block|,
comment|/* beacon ISR proc */
name|ATH_DEBUG_CALIBRATE
init|=
literal|0x00010000
block|,
comment|/* periodic calibration */
name|ATH_DEBUG_KEYCACHE
init|=
literal|0x00020000
block|,
comment|/* key cache management */
name|ATH_DEBUG_STATE
init|=
literal|0x00040000
block|,
comment|/* 802.11 state transitions */
name|ATH_DEBUG_NODE
init|=
literal|0x00080000
block|,
comment|/* node management */
name|ATH_DEBUG_LED
init|=
literal|0x00100000
block|,
comment|/* led management */
name|ATH_DEBUG_FF
init|=
literal|0x00200000
block|,
comment|/* fast frames */
name|ATH_DEBUG_DFS
init|=
literal|0x00400000
block|,
comment|/* DFS processing */
name|ATH_DEBUG_TDMA
init|=
literal|0x00800000
block|,
comment|/* TDMA processing */
name|ATH_DEBUG_TDMA_TIMER
init|=
literal|0x01000000
block|,
comment|/* TDMA timer processing */
name|ATH_DEBUG_REGDOMAIN
init|=
literal|0x02000000
block|,
comment|/* regulatory processing */
name|ATH_DEBUG_FATAL
init|=
literal|0x80000000
block|,
comment|/* fatal errors */
name|ATH_DEBUG_ANY
init|=
literal|0xffffffff
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|int
name|ath_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_debug
argument_list|,
literal|0
argument_list|,
literal|"control debugging printfs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ath.debug"
argument_list|,
operator|&
name|ath_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|IFF_DUMPPKTS
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|)
define|\
value|((sc->sc_debug& (m)) || \ 	    (sc->sc_ifp->if_flags& (IFF_DEBUG|IFF_LINK2)) == (IFF_DEBUG|IFF_LINK2))
end_define

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {				\ 	if (sc->sc_debug& (m))					\ 		printf(fmt, __VA_ARGS__);			\ } while (0)
end_define

begin_define
define|#
directive|define
name|KEYPRINTF
parameter_list|(
name|sc
parameter_list|,
name|ix
parameter_list|,
name|hk
parameter_list|,
name|mac
parameter_list|)
value|do {				\ 	if (sc->sc_debug& ATH_DEBUG_KEYCACHE)			\ 		ath_keyprint(sc, __func__, ix, hk, mac);	\ } while (0)
end_define

begin_function_decl
specifier|static
name|void
name|ath_printrxbuf
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|u_int
name|ix
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_printtxbuf
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|u_int
name|qnum
parameter_list|,
name|u_int
name|ix
parameter_list|,
name|int
name|done
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IFF_DUMPPKTS
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|)
define|\
value|((sc->sc_ifp->if_flags& (IFF_DEBUG|IFF_LINK2)) == (IFF_DEBUG|IFF_LINK2))
end_define

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {				\ 	(void) sc;						\ } while (0)
end_define

begin_define
define|#
directive|define
name|KEYPRINTF
parameter_list|(
name|sc
parameter_list|,
name|k
parameter_list|,
name|ix
parameter_list|,
name|mac
parameter_list|)
value|do {				\ 	(void) sc;						\ } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_ATHDEV
argument_list|,
literal|"athdev"
argument_list|,
literal|"ath driver dma buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|ath_attach
parameter_list|(
name|u_int16_t
name|devid
parameter_list|,
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|NULL
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|u_int
name|wmodes
decl_stmt|;
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: devid 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|devid
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_IEEE80211
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can not if_alloc()\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ic
operator|=
name|ifp
operator|->
name|if_l2com
expr_stmt|;
comment|/* set these up early for if_printf use */
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|ah
operator|=
name|ath_hal_attach
argument_list|(
name|devid
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_sh
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ah
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to attach hardware; HAL status %u\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|sc_ah
operator|=
name|ah
expr_stmt|;
name|sc
operator|->
name|sc_invalid
operator|=
literal|0
expr_stmt|;
comment|/* ready to go, enable interrupt handling */
ifdef|#
directive|ifdef
name|ATH_DEBUG
name|sc
operator|->
name|sc_debug
operator|=
name|ath_debug
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Check if the MAC has multi-rate retry support. 	 * We do this by trying to setup a fake extended 	 * descriptor.  MAC's that don't have support will 	 * return false w/o doing anything.  MAC's that do 	 * support it will return true w/o doing anything. 	 */
name|sc
operator|->
name|sc_mrretry
operator|=
name|ath_hal_setupxtxdesc
argument_list|(
name|ah
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Check if the device has hardware counters for PHY 	 * errors.  If so we need to enable the MIB interrupt 	 * so we can act on stat triggers. 	 */
if|if
condition|(
name|ath_hal_hwphycounters
argument_list|(
name|ah
argument_list|)
condition|)
name|sc
operator|->
name|sc_needmib
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Get the hardware key cache size. 	 */
name|sc
operator|->
name|sc_keymax
operator|=
name|ath_hal_keycachesize
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_keymax
operator|>
name|ATH_KEYMAX
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Warning, using only %u of %u key cache slots\n"
argument_list|,
name|ATH_KEYMAX
argument_list|,
name|sc
operator|->
name|sc_keymax
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_keymax
operator|=
name|ATH_KEYMAX
expr_stmt|;
block|}
comment|/* 	 * Reset the key cache since some parts do not 	 * reset the contents on initial power up. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_keymax
condition|;
name|i
operator|++
control|)
name|ath_hal_keyreset
argument_list|(
name|ah
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Collect the default channel list. 	 */
name|error
operator|=
name|ath_getchannels
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Setup rate tables for all potential media types. 	 */
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11A
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11B
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_TURBO_A
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_TURBO_G
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_STURBO_A
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11NA
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11NG
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_HALF
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_QUARTER
argument_list|)
expr_stmt|;
comment|/* NB: setup here so ath_rate_update is happy */
name|ath_setcurmode
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11A
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate tx+rx descriptors and populate the lists. 	 */
name|error
operator|=
name|ath_desc_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"failed to allocate descriptors: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_wd_ch
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ATH_TXBUF_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tq
operator|=
name|taskqueue_create
argument_list|(
literal|"ath_taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|sc_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxtask
argument_list|,
literal|0
argument_list|,
name|ath_rx_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bmisstask
argument_list|,
literal|0
argument_list|,
name|ath_bmiss_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bstucktask
argument_list|,
literal|0
argument_list|,
name|ath_bstuck_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate hardware transmit queues: one queue for 	 * beacon frames and one data queue for each QoS 	 * priority.  Note that the hal handles reseting 	 * these queues at the needed time. 	 * 	 * XXX PS-Poll 	 */
name|sc
operator|->
name|sc_bhalq
operator|=
name|ath_beaconq_setup
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bhalq
operator|==
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to setup a beacon xmit queue!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|sc
operator|->
name|sc_cabq
operator|=
name|ath_txq_setup
argument_list|(
name|sc
argument_list|,
name|HAL_TX_QUEUE_CAB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cabq
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to setup CAB xmit queue!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
comment|/* NB: insure BK queue is the lowest priority h/w queue */
if|if
condition|(
operator|!
name|ath_tx_setup
argument_list|(
name|sc
argument_list|,
name|WME_AC_BK
argument_list|,
name|HAL_WME_AC_BK
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to setup xmit queue for %s traffic!\n"
argument_list|,
name|ieee80211_wme_acnames
index|[
name|WME_AC_BK
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
if|if
condition|(
operator|!
name|ath_tx_setup
argument_list|(
name|sc
argument_list|,
name|WME_AC_BE
argument_list|,
name|HAL_WME_AC_BE
argument_list|)
operator|||
operator|!
name|ath_tx_setup
argument_list|(
name|sc
argument_list|,
name|WME_AC_VI
argument_list|,
name|HAL_WME_AC_VI
argument_list|)
operator|||
operator|!
name|ath_tx_setup
argument_list|(
name|sc
argument_list|,
name|WME_AC_VO
argument_list|,
name|HAL_WME_AC_VO
argument_list|)
condition|)
block|{
comment|/* 		 * Not enough hardware tx queues to properly do WME; 		 * just punt and assign them all to the same h/w queue. 		 * We could do a better job of this if, for example, 		 * we allocate queues when we switch from station to 		 * AP mode. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_VI
index|]
operator|!=
name|NULL
condition|)
name|ath_tx_cleanupq
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_VI
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BE
index|]
operator|!=
name|NULL
condition|)
name|ath_tx_cleanupq
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BE
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BE
index|]
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BK
index|]
expr_stmt|;
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_VI
index|]
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BK
index|]
expr_stmt|;
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_VO
index|]
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BK
index|]
expr_stmt|;
block|}
comment|/* 	 * Special case certain configurations.  Note the 	 * CAB queue is handled by these specially so don't 	 * include them when checking the txq setup mask. 	 */
switch|switch
condition|(
name|sc
operator|->
name|sc_txqsetup
operator|&
operator|~
operator|(
literal|1
operator|<<
name|sc
operator|->
name|sc_cabq
operator|->
name|axq_qnum
operator|)
condition|)
block|{
case|case
literal|0x01
case|:
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txtask
argument_list|,
literal|0
argument_list|,
name|ath_tx_proc_q0
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0f
case|:
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txtask
argument_list|,
literal|0
argument_list|,
name|ath_tx_proc_q0123
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txtask
argument_list|,
literal|0
argument_list|,
name|ath_tx_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Setup rate control.  Some rate control modules 	 * call back to change the anntena state so expose 	 * the necessary entry points. 	 * XXX maybe belongs in struct ath_ratectrl? 	 */
name|sc
operator|->
name|sc_setdefantenna
operator|=
name|ath_setdefantenna
expr_stmt|;
name|sc
operator|->
name|sc_rc
operator|=
name|ath_rate_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rc
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|sc
operator|->
name|sc_blinking
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ledstate
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_ledon
operator|=
literal|0
expr_stmt|;
comment|/* low true */
name|sc
operator|->
name|sc_ledidle
operator|=
operator|(
literal|2700
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
comment|/* 2.7sec */
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_ledtimer
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
comment|/* 	 * Auto-enable soft led processing for IBM cards and for 	 * 5211 minipci cards.  Users can also manually enable/disable 	 * support with a sysctl. 	 */
name|sc
operator|->
name|sc_softled
operator|=
operator|(
name|devid
operator|==
name|AR5212_DEVID_IBM
operator|||
name|devid
operator|==
name|AR5211_DEVID
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
block|{
name|ath_hal_gpioCfgOutput
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
name|HAL_GPIO_MUX_MAC_NETWORK_LED
argument_list|)
expr_stmt|;
name|ath_hal_gpioset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
operator|!
name|sc
operator|->
name|sc_ledon
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_SIMPLEX
operator||
name|IFF_BROADCAST
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ath_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ath_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ath_init
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|IFQ_MAXLEN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_ifp
operator|=
name|ifp
expr_stmt|;
comment|/* XXX not right but it's not used anywhere important */
name|ic
operator|->
name|ic_phytype
operator|=
name|IEEE80211_T_OFDM
expr_stmt|;
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_STA
expr_stmt|;
name|ic
operator|->
name|ic_caps
operator|=
name|IEEE80211_C_STA
comment|/* station mode */
operator||
name|IEEE80211_C_IBSS
comment|/* ibss, nee adhoc, mode */
operator||
name|IEEE80211_C_HOSTAP
comment|/* hostap mode */
operator||
name|IEEE80211_C_MONITOR
comment|/* monitor mode */
operator||
name|IEEE80211_C_AHDEMO
comment|/* adhoc demo mode */
operator||
name|IEEE80211_C_WDS
comment|/* 4-address traffic works */
operator||
name|IEEE80211_C_MBSS
comment|/* mesh point link mode */
operator||
name|IEEE80211_C_SHPREAMBLE
comment|/* short preamble supported */
operator||
name|IEEE80211_C_SHSLOT
comment|/* short slot time supported */
operator||
name|IEEE80211_C_WPA
comment|/* capable of WPA1+WPA2 */
operator||
name|IEEE80211_C_BGSCAN
comment|/* capable of bg scanning */
operator||
name|IEEE80211_C_TXFRAG
comment|/* handle tx frags */
expr_stmt|;
comment|/* 	 * Query the hal to figure out h/w crypto support. 	 */
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_WEP
argument_list|)
condition|)
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_WEP
expr_stmt|;
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_AES_OCB
argument_list|)
condition|)
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_AES_OCB
expr_stmt|;
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_AES_CCM
argument_list|)
condition|)
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_AES_CCM
expr_stmt|;
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_CKIP
argument_list|)
condition|)
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_CKIP
expr_stmt|;
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_TKIP
argument_list|)
condition|)
block|{
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_TKIP
expr_stmt|;
comment|/* 		 * Check if h/w does the MIC and/or whether the 		 * separate key cache entries are required to 		 * handle both tx+rx MIC keys. 		 */
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_MIC
argument_list|)
condition|)
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_TKIPMIC
expr_stmt|;
comment|/* 		 * If the h/w supports storing tx+rx MIC keys 		 * in one cache slot automatically enable use. 		 */
if|if
condition|(
name|ath_hal_hastkipsplit
argument_list|(
name|ah
argument_list|)
operator|||
operator|!
name|ath_hal_settkipsplit
argument_list|(
name|ah
argument_list|,
name|AH_FALSE
argument_list|)
condition|)
name|sc
operator|->
name|sc_splitmic
operator|=
literal|1
expr_stmt|;
comment|/* 		 * If the h/w can do TKIP MIC together with WME then 		 * we use it; otherwise we force the MIC to be done 		 * in software by the net80211 layer. 		 */
if|if
condition|(
name|ath_hal_haswmetkipmic
argument_list|(
name|ah
argument_list|)
condition|)
name|sc
operator|->
name|sc_wmetkipmic
operator|=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|sc_hasclrkey
operator|=
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_CLR
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mcastkey
operator|=
name|ath_hal_getmcastkeysearch
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 	 * Mark key cache slots associated with global keys 	 * as in use.  If we knew TKIP was not to be used we 	 * could leave the +32, +64, and +32+64 slots free. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_WEP_NKID
condition|;
name|i
operator|++
control|)
block|{
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|i
operator|+
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_splitmic
condition|)
block|{
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|i
operator|+
literal|32
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|i
operator|+
literal|32
operator|+
literal|64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * TPC support can be done either with a global cap or 	 * per-packet support.  The latter is not available on 	 * all parts.  We're a bit pedantic here as all parts 	 * support a global cap. 	 */
if|if
condition|(
name|ath_hal_hastpc
argument_list|(
name|ah
argument_list|)
operator|||
name|ath_hal_hastxpowlimit
argument_list|(
name|ah
argument_list|)
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_TXPMGT
expr_stmt|;
comment|/* 	 * Mark WME capability only if we have sufficient 	 * hardware queues to do proper priority scheduling. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BE
index|]
operator|!=
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BK
index|]
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_WME
expr_stmt|;
comment|/* 	 * Check for misc other capabilities. 	 */
if|if
condition|(
name|ath_hal_hasbursting
argument_list|(
name|ah
argument_list|)
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_BURST
expr_stmt|;
name|sc
operator|->
name|sc_hasbmask
operator|=
name|ath_hal_hasbssidmask
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_hasbmatch
operator|=
name|ath_hal_hasbssidmatch
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_hastsfadd
operator|=
name|ath_hal_hastsfadjust
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_hal_hasfastframes
argument_list|(
name|ah
argument_list|)
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_FF
expr_stmt|;
name|wmodes
operator|=
name|ath_hal_getwirelessmodes
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|wmodes
operator|&
operator|(
name|HAL_MODE_108G
operator||
name|HAL_MODE_TURBO
operator|)
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_TURBOP
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|ath_hal_macversion
argument_list|(
name|ah
argument_list|)
operator|>
literal|0x78
condition|)
block|{
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_TDMA
expr_stmt|;
comment|/* capable of TDMA */
name|ic
operator|->
name|ic_tdma_update
operator|=
name|ath_tdma_update
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Indicate we need the 802.11 header padded to a 	 * 32-bit boundary for 4-address and QoS frames. 	 */
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_DATAPAD
expr_stmt|;
comment|/* 	 * Query the hal about antenna support. 	 */
name|sc
operator|->
name|sc_defant
operator|=
name|ath_hal_getdefantenna
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 	 * Not all chips have the VEOL support we want to 	 * use with IBSS beacons; check here for it. 	 */
name|sc
operator|->
name|sc_hasveol
operator|=
name|ath_hal_hasveol
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* get mac address from hardware */
name|ath_hal_getmac
argument_list|(
name|ah
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hasbmask
condition|)
name|ath_hal_getbssidmask
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_hwbssidmask
argument_list|)
expr_stmt|;
comment|/* NB: used to size node table key mapping array */
name|ic
operator|->
name|ic_max_keyix
operator|=
name|sc
operator|->
name|sc_keymax
expr_stmt|;
comment|/* call MI attach routine. */
name|ieee80211_ifattach
argument_list|(
name|ic
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_setregdomain
operator|=
name|ath_setregdomain
expr_stmt|;
name|ic
operator|->
name|ic_getradiocaps
operator|=
name|ath_getradiocaps
expr_stmt|;
name|sc
operator|->
name|sc_opmode
operator|=
name|HAL_M_STA
expr_stmt|;
comment|/* override default methods */
name|ic
operator|->
name|ic_newassoc
operator|=
name|ath_newassoc
expr_stmt|;
name|ic
operator|->
name|ic_updateslot
operator|=
name|ath_updateslot
expr_stmt|;
name|ic
operator|->
name|ic_wme
operator|.
name|wme_update
operator|=
name|ath_wme_update
expr_stmt|;
name|ic
operator|->
name|ic_vap_create
operator|=
name|ath_vap_create
expr_stmt|;
name|ic
operator|->
name|ic_vap_delete
operator|=
name|ath_vap_delete
expr_stmt|;
name|ic
operator|->
name|ic_raw_xmit
operator|=
name|ath_raw_xmit
expr_stmt|;
name|ic
operator|->
name|ic_update_mcast
operator|=
name|ath_update_mcast
expr_stmt|;
name|ic
operator|->
name|ic_update_promisc
operator|=
name|ath_update_promisc
expr_stmt|;
name|ic
operator|->
name|ic_node_alloc
operator|=
name|ath_node_alloc
expr_stmt|;
name|sc
operator|->
name|sc_node_free
operator|=
name|ic
operator|->
name|ic_node_free
expr_stmt|;
name|ic
operator|->
name|ic_node_free
operator|=
name|ath_node_free
expr_stmt|;
name|ic
operator|->
name|ic_node_getsignal
operator|=
name|ath_node_getsignal
expr_stmt|;
name|ic
operator|->
name|ic_scan_start
operator|=
name|ath_scan_start
expr_stmt|;
name|ic
operator|->
name|ic_scan_end
operator|=
name|ath_scan_end
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
operator|=
name|ath_set_channel
expr_stmt|;
name|ieee80211_radiotap_attach
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_tx_th
argument_list|)
argument_list|,
name|ATH_TX_RADIOTAP_PRESENT
argument_list|,
operator|&
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rx_th
argument_list|)
argument_list|,
name|ATH_RX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
comment|/* 	 * Setup dynamic sysctl's now that country code and 	 * regdomain are available from the hal. 	 */
name|ath_sysctlattach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ieee80211_announce
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ath_announce
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad2
label|:
name|ath_tx_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_desc_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bad
label|:
if|if
condition|(
name|ah
condition|)
name|ath_hal_detach
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_invalid
operator|=
literal|1
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|ath_detach
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: if_flags %x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
comment|/*  	 * NB: the order of these is important: 	 * o stop the chip so no more interrupts will fire 	 * o call the 802.11 layer before detaching the hal to 	 *   insure callbacks into the driver to delete global 	 *   key cache entries can be handled 	 * o free the taskqueue which drains any pending tasks 	 * o reclaim the tx queue data structures after calling 	 *   the 802.11 layer as we'll get called back to reclaim 	 *   node state and potentially want to use them 	 * o to cleanup the tx queues the hal is called, so detach 	 *   it last 	 * Other than that, it's straightforward... 	 */
name|ath_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ieee80211_ifdetach
argument_list|(
name|ifp
operator|->
name|if_l2com
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
if|if
condition|(
name|sc
operator|->
name|sc_tx99
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_tx99
operator|->
name|detach
argument_list|(
name|sc
operator|->
name|sc_tx99
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ath_rate_detach
argument_list|(
name|sc
operator|->
name|sc_rc
argument_list|)
expr_stmt|;
name|ath_desc_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_tx_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_detach
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
comment|/* NB: sets chip in full sleep */
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * MAC address handling for multiple BSS on the same radio.  * The first vap uses the MAC address from the EEPROM.  For  * subsequent vap's we set the U/L bit (bit 1) in the MAC  * address and use the next six bits as an index.  */
end_comment

begin_function
specifier|static
name|void
name|assign_address
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|int
name|clone
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|clone
operator|&&
name|sc
operator|->
name|sc_hasbmask
condition|)
block|{
comment|/* NB: we only do this if h/w supports multiple bssid */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_bssidmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|mac
index|[
literal|0
index|]
operator||=
operator|(
name|i
operator|<<
literal|2
operator|)
operator||
literal|0x2
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_bssidmask
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
name|sc
operator|->
name|sc_hwbssidmask
index|[
literal|0
index|]
operator|&=
operator|~
name|mac
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_nbssid0
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reclaim_address
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|int
name|i
init|=
name|mac
index|[
literal|0
index|]
operator|>>
literal|2
decl_stmt|;
name|uint8_t
name|mask
decl_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|||
operator|--
name|sc
operator|->
name|sc_nbssid0
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_bssidmask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
comment|/* recalculate bssid mask from remaining addresses */
name|mask
operator|=
literal|0xff
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_bssidmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|mask
operator|&=
operator|~
operator|(
operator|(
name|i
operator|<<
literal|2
operator|)
operator||
literal|0x2
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_hwbssidmask
index|[
literal|0
index|]
operator||=
name|mask
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Assign a beacon xmit slot.  We try to space out  * assignments so when beacons are staggered the  * traffic coming out of the cab q has maximal time  * to go out before the next beacon is scheduled.  */
end_comment

begin_function
specifier|static
name|int
name|assign_bslot
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|slot
decl_stmt|,
name|free
decl_stmt|;
name|free
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|ATH_BCBUF
condition|;
name|slot
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_bslot
index|[
name|slot
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_bslot
index|[
operator|(
name|slot
operator|+
literal|1
operator|)
operator|%
name|ATH_BCBUF
index|]
operator|==
name|NULL
operator|&&
name|sc
operator|->
name|sc_bslot
index|[
operator|(
name|slot
operator|-
literal|1
operator|)
operator|%
name|ATH_BCBUF
index|]
operator|==
name|NULL
condition|)
return|return
name|slot
return|;
name|free
operator|=
name|slot
expr_stmt|;
comment|/* NB: keep looking for a double slot */
block|}
return|return
name|free
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|ath_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac0
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|int
name|ic_opmode
decl_stmt|,
name|needbeacon
decl_stmt|,
name|error
decl_stmt|;
name|avp
operator|=
operator|(
expr|struct
name|ath_vap
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ath_vap
argument_list|)
argument_list|,
name|M_80211_VAP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|needbeacon
operator|=
literal|0
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|mac
argument_list|,
name|mac0
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ic_opmode
operator|=
name|opmode
expr_stmt|;
comment|/* default to opmode of new vap */
switch|switch
condition|(
name|opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
if|if
condition|(
name|sc
operator|->
name|sc_nstavaps
operator|!=
literal|0
condition|)
block|{
comment|/* XXX only 1 for now */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"only 1 sta vap supported\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
condition|)
block|{
comment|/* 			 * With multiple vaps we must fall back 			 * to s/w beacon miss handling. 			 */
name|flags
operator||=
name|IEEE80211_CLONE_NOBEACONS
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CLONE_NOBEACONS
condition|)
block|{
comment|/* 			 * Station mode w/o beacons are implemented w/ AP mode. 			 */
name|ic_opmode
operator|=
name|IEEE80211_M_HOSTAP
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_M_IBSS
case|:
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
operator|!=
literal|0
condition|)
block|{
comment|/* XXX only 1 for now */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"only 1 ibss vap supported\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|needbeacon
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_AHDEMO
case|:
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CLONE_TDMA
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"only 1 tdma vap supported\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|needbeacon
operator|=
literal|1
expr_stmt|;
name|flags
operator||=
name|IEEE80211_CLONE_NOBEACONS
expr_stmt|;
block|}
comment|/* fall thru... */
endif|#
directive|endif
case|case
name|IEEE80211_M_MONITOR
case|:
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
operator|!=
literal|0
operator|&&
name|ic
operator|->
name|ic_opmode
operator|!=
name|opmode
condition|)
block|{
comment|/* 			 * Adopt existing mode.  Adding a monitor or ahdemo 			 * vap to an existing configuration is of dubious 			 * value but should be ok. 			 */
comment|/* XXX not right for monitor mode */
name|ic_opmode
operator|=
name|ic
operator|->
name|ic_opmode
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_M_HOSTAP
case|:
case|case
name|IEEE80211_M_MBSS
case|:
name|needbeacon
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_WDS
case|:
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
operator|!=
literal|0
operator|&&
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"wds not supported in sta mode\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * Silently remove any request for a unique 		 * bssid; WDS vap's always share the local 		 * mac address. 		 */
name|flags
operator|&=
operator|~
name|IEEE80211_CLONE_BSSID
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
operator|==
literal|0
condition|)
name|ic_opmode
operator|=
name|IEEE80211_M_HOSTAP
expr_stmt|;
else|else
name|ic_opmode
operator|=
name|ic
operator|->
name|ic_opmode
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unknown opmode %d\n"
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Check that a beacon buffer is available; the code below assumes it. 	 */
if|if
condition|(
name|needbeacon
operator|&
name|STAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"no beacon buffer available\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* STA, AHDEMO? */
if|if
condition|(
name|opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
name|assign_address
argument_list|(
name|sc
argument_list|,
name|mac
argument_list|,
name|flags
operator|&
name|IEEE80211_CLONE_BSSID
argument_list|)
expr_stmt|;
name|ath_hal_setbssidmask
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_hwbssidmask
argument_list|)
expr_stmt|;
block|}
name|vap
operator|=
operator|&
name|avp
operator|->
name|av_vap
expr_stmt|;
comment|/* XXX can't hold mutex across if_alloc */
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|ieee80211_vap_setup
argument_list|(
name|ic
argument_list|,
name|vap
argument_list|,
name|name
argument_list|,
name|unit
argument_list|,
name|opmode
argument_list|,
name|flags
argument_list|,
name|bssid
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: error %d creating vap\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
comment|/* h/w crypto support */
name|vap
operator|->
name|iv_key_alloc
operator|=
name|ath_key_alloc
expr_stmt|;
name|vap
operator|->
name|iv_key_delete
operator|=
name|ath_key_delete
expr_stmt|;
name|vap
operator|->
name|iv_key_set
operator|=
name|ath_key_set
expr_stmt|;
name|vap
operator|->
name|iv_key_update_begin
operator|=
name|ath_key_update_begin
expr_stmt|;
name|vap
operator|->
name|iv_key_update_end
operator|=
name|ath_key_update_end
expr_stmt|;
comment|/* override various methods */
name|avp
operator|->
name|av_recv_mgmt
operator|=
name|vap
operator|->
name|iv_recv_mgmt
expr_stmt|;
name|vap
operator|->
name|iv_recv_mgmt
operator|=
name|ath_recv_mgmt
expr_stmt|;
name|vap
operator|->
name|iv_reset
operator|=
name|ath_reset_vap
expr_stmt|;
name|vap
operator|->
name|iv_update_beacon
operator|=
name|ath_beacon_update
expr_stmt|;
name|avp
operator|->
name|av_newstate
operator|=
name|vap
operator|->
name|iv_newstate
expr_stmt|;
name|vap
operator|->
name|iv_newstate
operator|=
name|ath_newstate
expr_stmt|;
name|avp
operator|->
name|av_bmiss
operator|=
name|vap
operator|->
name|iv_bmiss
expr_stmt|;
name|vap
operator|->
name|iv_bmiss
operator|=
name|ath_bmiss_vap
expr_stmt|;
name|avp
operator|->
name|av_bslot
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|needbeacon
condition|)
block|{
comment|/* 		 * Allocate beacon state and setup the q for buffered 		 * multicast frames.  We know a beacon buffer is 		 * available because we checked above. 		 */
name|avp
operator|->
name|av_bcbuf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|!=
name|IEEE80211_M_IBSS
operator|||
operator|!
name|sc
operator|->
name|sc_hasveol
condition|)
block|{
comment|/* 			 * Assign the vap to a beacon xmit slot.  As above 			 * this cannot fail to find a free one. 			 */
name|avp
operator|->
name|av_bslot
operator|=
name|assign_bslot
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_bslot
index|[
name|avp
operator|->
name|av_bslot
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"beacon slot %u not empty"
operator|,
name|avp
operator|->
name|av_bslot
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bslot
index|[
name|avp
operator|->
name|av_bslot
index|]
operator|=
name|vap
expr_stmt|;
name|sc
operator|->
name|sc_nbcnvaps
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_hastsfadd
operator|&&
name|sc
operator|->
name|sc_nbcnvaps
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Multple vaps are to transmit beacons and we 			 * have h/w support for TSF adjusting; enable 			 * use of staggered beacons. 			 */
name|sc
operator|->
name|sc_stagbeacons
operator|=
literal|1
expr_stmt|;
block|}
name|ath_txq_init
argument_list|(
name|sc
argument_list|,
operator|&
name|avp
operator|->
name|av_mcastq
argument_list|,
name|ATH_TXQ_SWQ
argument_list|)
expr_stmt|;
block|}
name|ic
operator|->
name|ic_opmode
operator|=
name|ic_opmode
expr_stmt|;
if|if
condition|(
name|opmode
operator|!=
name|IEEE80211_M_WDS
condition|)
block|{
name|sc
operator|->
name|sc_nvaps
operator|++
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|sc
operator|->
name|sc_nstavaps
operator|++
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
name|sc
operator|->
name|sc_nmeshvaps
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|ic_opmode
condition|)
block|{
case|case
name|IEEE80211_M_IBSS
case|:
name|sc
operator|->
name|sc_opmode
operator|=
name|HAL_M_IBSS
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_STA
case|:
name|sc
operator|->
name|sc_opmode
operator|=
name|HAL_M_STA
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_AHDEMO
case|:
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
condition|)
block|{
name|sc
operator|->
name|sc_tdma
operator|=
literal|1
expr_stmt|;
comment|/* NB: disable tsf adjust */
name|sc
operator|->
name|sc_stagbeacons
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * NB: adhoc demo mode is a pseudo mode; to the hal it's 		 * just ap mode. 		 */
comment|/* fall thru... */
endif|#
directive|endif
case|case
name|IEEE80211_M_HOSTAP
case|:
case|case
name|IEEE80211_M_MBSS
case|:
name|sc
operator|->
name|sc_opmode
operator|=
name|HAL_M_HOSTAP
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
name|sc
operator|->
name|sc_opmode
operator|=
name|HAL_M_MONITOR
expr_stmt|;
break|break;
default|default:
comment|/* XXX should not happen */
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_hastsfadd
condition|)
block|{
comment|/* 		 * Configure whether or not TSF adjust should be done. 		 */
name|ath_hal_settsfadjust
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_stagbeacons
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CLONE_NOBEACONS
condition|)
block|{
comment|/* 		 * Enable s/w beacon miss handling. 		 */
name|sc
operator|->
name|sc_swbmiss
operator|=
literal|1
expr_stmt|;
block|}
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* complete setup */
name|ieee80211_vap_attach
argument_list|(
name|vap
argument_list|,
name|ath_media_change
argument_list|,
name|ieee80211_media_status
argument_list|)
expr_stmt|;
return|return
name|vap
return|;
name|bad2
label|:
name|reclaim_address
argument_list|(
name|sc
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|ath_hal_setbssidmask
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_hwbssidmask
argument_list|)
expr_stmt|;
name|bad
label|:
name|free
argument_list|(
name|avp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* 		 * Quiesce the hardware while we remove the vap.  In 		 * particular we need to reclaim all references to 		 * the vap state by any frames pending on the tx queues. 		 */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|ath_draintxq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* stop xmit side */
name|ath_stoprecv
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* stop recv side */
block|}
name|ieee80211_vap_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Reclaim beacon state.  Note this must be done before 	 * the vap instance is reclaimed as we may have a reference 	 * to it in the buffer for the beacon frame. 	 */
if|if
condition|(
name|avp
operator|->
name|av_bcbuf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|avp
operator|->
name|av_bslot
operator|!=
operator|-
literal|1
condition|)
block|{
name|sc
operator|->
name|sc_bslot
index|[
name|avp
operator|->
name|av_bslot
index|]
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_nbcnvaps
operator|--
expr_stmt|;
block|}
name|ath_beacon_return
argument_list|(
name|sc
argument_list|,
name|avp
operator|->
name|av_bcbuf
argument_list|)
expr_stmt|;
name|avp
operator|->
name|av_bcbuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nbcnvaps
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stagbeacons
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hastsfadd
condition|)
name|ath_hal_settsfadjust
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Reclaim any pending mcast frames for the vap. 		 */
name|ath_tx_draintxq
argument_list|(
name|sc
argument_list|,
operator|&
name|avp
operator|->
name|av_mcastq
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK_DESTROY
argument_list|(
operator|&
name|avp
operator|->
name|av_mcastq
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update bookkeeping. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
name|sc
operator|->
name|sc_nstavaps
operator|--
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nstavaps
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_swbmiss
condition|)
name|sc
operator|->
name|sc_swbmiss
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
name|reclaim_address
argument_list|(
name|sc
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|ath_hal_setbssidmask
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_hwbssidmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
name|sc
operator|->
name|sc_nmeshvaps
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_WDS
condition|)
name|sc
operator|->
name|sc_nvaps
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
comment|/* TDMA operation ceases when the last vap is destroyed */
if|if
condition|(
name|sc
operator|->
name|sc_tdma
operator|&&
name|sc
operator|->
name|sc_nvaps
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_tdma
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_swbmiss
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|avp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* 		 * Restart rx+tx machines if still running (RUNNING will 		 * be reset if we just destroyed the last vap). 		 */
if|if
condition|(
name|ath_startrecv
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: unable to restart recv logic\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_beacons
condition|)
block|{
comment|/* restart beacons */
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|sc
operator|->
name|sc_tdma
condition|)
name|ath_tdma_config
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ath_beacon_config
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ath_suspend
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: if_flags %x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_resume_up
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|ath_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|else
name|ieee80211_suspend_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * NB: don't worry about putting the chip in low power 	 * mode; pci will power off our socket on suspend and 	 * cardbus detaches the device. 	 */
block|}
end_function

begin_comment
comment|/*  * Reset the key cache since some parts do not reset the  * contents on resume.  First we clear all entries, then  * re-load keys that the 802.11 layer assumes are setup  * in h/w.  */
end_comment

begin_function
specifier|static
name|void
name|ath_reset_keycache
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_keymax
condition|;
name|i
operator|++
control|)
name|ath_hal_keyreset
argument_list|(
name|ah
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ieee80211_crypto_reload_keys
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ath_resume
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: if_flags %x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
comment|/* 	 * Must reset the chip before we reload the 	 * keycache as we were powered down on suspend. 	 */
name|ath_hal_reset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_opmode
argument_list|,
name|sc
operator|->
name|sc_curchan
operator|!=
name|NULL
condition|?
name|sc
operator|->
name|sc_curchan
else|:
name|ic
operator|->
name|ic_curchan
argument_list|,
name|AH_FALSE
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|ath_reset_keycache
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_resume_up
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
name|ath_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 			 * Program the beacon registers using the last rx'd 			 * beacon frame and enable sync on the next beacon 			 * we see.  This should handle the case where we 			 * wakeup and find the same AP and also the case where 			 * we wakeup and need to roam.  For the latter we 			 * should get bmiss events that trigger a roam. 			 */
name|ath_beacon_config
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|ieee80211_resume_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
block|{
name|ath_hal_gpioCfgOutput
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
name|HAL_GPIO_MUX_MAC_NETWORK_LED
argument_list|)
expr_stmt|;
name|ath_hal_gpioset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
operator|!
name|sc
operator|->
name|sc_ledon
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ath_shutdown
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: if_flags %x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|ath_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* NB: no point powering down chip as we're about to reboot */
block|}
end_function

begin_comment
comment|/*  * Interrupt handler.  Most of the actual processing is deferred.  */
end_comment

begin_function
name|void
name|ath_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_INT
name|status
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_invalid
condition|)
block|{
comment|/* 		 * The hardware is not ready/present, don't touch anything. 		 * Note this can happen early on if the IRQ is shared. 		 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: invalid; ignored\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ath_hal_intrpend
argument_list|(
name|ah
argument_list|)
condition|)
comment|/* shared irq, not for us */
return|return;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|||
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|HAL_INT
name|status
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: if_flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|ath_hal_getisr
argument_list|(
name|ah
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* clear ISR */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable further intr's */
return|return;
block|}
comment|/* 	 * Figure out the reason(s) for the interrupt.  Note 	 * that the hal returns a pseudo-ISR that may include 	 * bits we haven't explicitly enabled so we mask the 	 * value to insure we only process bits we requested. 	 */
name|ath_hal_getisr
argument_list|(
name|ah
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* NB: clears ISR too */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_INTR
argument_list|,
literal|"%s: status 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|status
operator|&=
name|sc
operator|->
name|sc_imask
expr_stmt|;
comment|/* discard unasked for bits */
if|if
condition|(
name|status
operator|&
name|HAL_INT_FATAL
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_hardware
operator|++
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable intr's until reset */
name|ath_fatal_proc
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|status
operator|&
name|HAL_INT_SWBA
condition|)
block|{
comment|/* 			 * Software beacon alert--time to send a beacon. 			 * Handle beacon transmission directly; deferring 			 * this is too slow to meet timing constraints 			 * under load. 			 */
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|sc
operator|->
name|sc_tdma
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_tdmaswba
operator|==
literal|0
condition|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|ath_tdma_beacon_send
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tdmaswba
operator|=
name|vap
operator|->
name|iv_tdma
operator|->
name|tdma_bintval
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_tdmaswba
operator|--
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|ath_beacon_proc
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
comment|/* 				 * Schedule the rx taskq in case there's no 				 * traffic so any frames held on the staging 				 * queue are aged and potentially flushed. 				 */
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtask
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_RXEOL
condition|)
block|{
comment|/* 			 * NB: the hardware should re-read the link when 			 *     RXE bit is written, but it doesn't work at 			 *     least on older hardware revs. 			 */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rxeol
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_rxlink
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_TXURN
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_txurn
operator|++
expr_stmt|;
comment|/* bump tx trigger level */
name|ath_hal_updatetxtriglevel
argument_list|(
name|ah
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_RX
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|HAL_INT_TX
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_txtask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|HAL_INT_BMISS
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_bmiss
operator|++
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_bmisstask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_MIB
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_mib
operator|++
expr_stmt|;
comment|/* 			 * Disable interrupts until we service the MIB 			 * interrupt; otherwise it will continue to fire. 			 */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Let the hal handle the event.  We assume it will 			 * clear whatever condition caused the interrupt. 			 */
name|ath_hal_mibevent
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_halstats
argument_list|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_RXORN
condition|)
block|{
comment|/* NB: hal marks HAL_INT_FATAL when RXORN is fatal */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rxorn
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_fatal_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|u_int32_t
modifier|*
name|state
decl_stmt|;
name|u_int32_t
name|len
decl_stmt|;
name|void
modifier|*
name|sp
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"hardware error; resetting\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Fatal errors are unrecoverable.  Typically these 	 * are caused by DMA errors.  Collect h/w state from 	 * the hal so we can diagnose what's going on. 	 */
if|if
condition|(
name|ath_hal_getfatalstate
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|sp
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|len
operator|>=
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
operator|(
literal|"len %u bytes"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|sp
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"0x%08x 0x%08x 0x%08x, 0x%08x 0x%08x 0x%08x\n"
argument_list|,
name|state
index|[
literal|0
index|]
argument_list|,
name|state
index|[
literal|1
index|]
argument_list|,
name|state
index|[
literal|2
index|]
argument_list|,
name|state
index|[
literal|3
index|]
argument_list|,
name|state
index|[
literal|4
index|]
argument_list|,
name|state
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
name|ath_reset
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_bmiss_vap
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
comment|/* 	 * Workaround phantom bmiss interrupts by sanity-checking 	 * the time of our last rx'd frame.  If it is within the 	 * beacon miss interval then ignore the interrupt.  If it's 	 * truly a bmiss we'll get another interrupt soon and that'll 	 * be dispatched up for processing.  Note this applies only 	 * for h/w beacon miss events. 	 */
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_SWBMISS
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u_int64_t
name|lastrx
init|=
name|sc
operator|->
name|sc_lastrx
decl_stmt|;
name|u_int64_t
name|tsf
init|=
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
decl_stmt|;
name|u_int
name|bmisstimeout
init|=
name|vap
operator|->
name|iv_bmissthreshold
operator|*
name|vap
operator|->
name|iv_bss
operator|->
name|ni_intval
operator|*
literal|1024
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: tsf %llu lastrx %lld (%llu) bmiss %u\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|tsf
argument_list|,
call|(
name|unsigned
name|long
name|long
call|)
argument_list|(
name|tsf
operator|-
name|lastrx
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|lastrx
argument_list|,
name|bmisstimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsf
operator|-
name|lastrx
operator|<=
name|bmisstimeout
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_bmiss_phantom
operator|++
expr_stmt|;
return|return;
block|}
block|}
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|av_bmiss
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_hal_gethangstate
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|mask
parameter_list|,
name|uint32_t
modifier|*
name|hangs
parameter_list|)
block|{
name|uint32_t
name|rsize
decl_stmt|;
name|void
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|!
name|ath_hal_getdiagstate
argument_list|(
name|ah
argument_list|,
literal|32
argument_list|,
operator|&
name|mask
argument_list|,
sizeof|sizeof
argument_list|(
name|mask
argument_list|)
argument_list|,
operator|&
name|sp
argument_list|,
operator|&
name|rsize
argument_list|)
condition|)
return|return
literal|0
return|;
name|KASSERT
argument_list|(
name|rsize
operator|==
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
literal|"resultsize %u"
operator|,
name|rsize
operator|)
argument_list|)
expr_stmt|;
operator|*
name|hangs
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|sp
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_bmiss_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|uint32_t
name|hangs
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: pending %u\n"
argument_list|,
name|__func__
argument_list|,
name|pending
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_hal_gethangstate
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0xff
argument_list|,
operator|&
name|hangs
argument_list|)
operator|&&
name|hangs
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"bb hang detected (0x%x), reseting\n"
argument_list|,
name|hangs
argument_list|)
expr_stmt|;
name|ath_reset
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
name|ieee80211_beacon_miss
argument_list|(
name|ifp
operator|->
name|if_l2com
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle TKIP MIC setup to deal hardware that doesn't do MIC  * calcs together with WME.  If necessary disable the crypto  * hardware and mark the 802.11 state so keys will be setup  * with the MIC work done in software.  */
end_comment

begin_function
specifier|static
name|void
name|ath_settkipmic
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_cryptocaps
operator|&
name|IEEE80211_CRYPTO_TKIP
operator|)
operator|&&
operator|!
name|sc
operator|->
name|sc_wmetkipmic
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WME
condition|)
block|{
name|ath_hal_settkipmic
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_cryptocaps
operator|&=
operator|~
name|IEEE80211_CRYPTO_TKIPMIC
expr_stmt|;
block|}
else|else
block|{
name|ath_hal_settkipmic
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_TKIPMIC
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ath_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: if_flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Stop anything previously setup.  This is safe 	 * whether this is the first time through or not. 	 */
name|ath_stop_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * The basic interface to setting the hardware in a good 	 * state is ``reset''.  On return the hardware is known to 	 * be powered up and with interrupts disabled.  This must 	 * be followed by initialization of the appropriate bits 	 * and then setup of the interrupt mask. 	 */
name|ath_settkipmic
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_reset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_opmode
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|,
name|AH_FALSE
argument_list|,
operator|&
name|status
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to reset hardware; hal status %u\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|ath_chan_change
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* 	 * Likewise this is set during reset so update 	 * state cached in the driver. 	 */
name|sc
operator|->
name|sc_diversity
operator|=
name|ath_hal_getdiversity
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_lastlongcal
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_resetcal
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_lastcalreset
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Setup the hardware after reset: the key cache 	 * is filled as needed and the receive engine is 	 * set going.  Frame transmit is handled entirely 	 * in the frame output path; there's nothing to do 	 * here except setup the interrupt mask. 	 */
if|if
condition|(
name|ath_startrecv
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to start recv logic\n"
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Enable interrupts. 	 */
name|sc
operator|->
name|sc_imask
operator|=
name|HAL_INT_RX
operator||
name|HAL_INT_TX
operator||
name|HAL_INT_RXEOL
operator||
name|HAL_INT_RXORN
operator||
name|HAL_INT_FATAL
operator||
name|HAL_INT_GLOBAL
expr_stmt|;
comment|/* 	 * Enable MIB interrupts when there are hardware phy counters. 	 * Note we only do this (at the moment) for station mode. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_needmib
operator|&&
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_MIB
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_wd_ch
argument_list|,
name|hz
argument_list|,
name|ath_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
if|if
condition|(
name|sc
operator|->
name|sc_tx99
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_tx99
operator|->
name|start
argument_list|(
name|sc
operator|->
name|sc_tx99
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* start all vap's */
block|}
end_function

begin_function
specifier|static
name|void
name|ath_stop_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: invalid %u if_flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_invalid
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|ATH_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* 		 * Shutdown the hardware and driver: 		 *    reset 802.11 state machine 		 *    turn off timers 		 *    disable interrupts 		 *    turn off the radio 		 *    clear transmit machinery 		 *    clear receive machinery 		 *    drain and release tx queues 		 *    reclaim beacon resources 		 *    power down hardware 		 * 		 * Note that some of this work is not possible if the 		 * hardware is gone (invalid). 		 */
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
if|if
condition|(
name|sc
operator|->
name|sc_tx99
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_tx99
operator|->
name|stop
argument_list|(
name|sc
operator|->
name|sc_tx99
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_wd_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_ledtimer
argument_list|)
expr_stmt|;
name|ath_hal_gpioset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
operator|!
name|sc
operator|->
name|sc_ledon
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_blinking
operator|=
literal|0
expr_stmt|;
block|}
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ath_draintxq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
block|{
name|ath_stoprecv
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_phydisable
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_rxlink
operator|=
name|NULL
expr_stmt|;
name|ath_beacon_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX not needed */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_stop_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the hardware w/o losing operational state.  This is  * basically a more efficient way of doing ath_stop, ath_init,  * followed by state transitions to the current 802.11  * operational state.  Used to recover from various errors and  * to reset or reload hardware state.  */
end_comment

begin_function
specifier|static
name|int
name|ath_reset
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|ath_draintxq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* stop xmit side */
name|ath_stoprecv
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* stop recv side */
name|ath_settkipmic
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* configure TKIP MIC handling */
comment|/* NB: indicate channel change so we do a full reset */
if|if
condition|(
operator|!
name|ath_hal_reset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_opmode
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|,
name|AH_TRUE
argument_list|,
operator|&
name|status
argument_list|)
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: unable to reset hardware; hal status %u\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_diversity
operator|=
name|ath_hal_getdiversity
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_startrecv
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
comment|/* restart recv */
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: unable to start recv logic\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * We may be doing a reset in response to an ioctl 	 * that changes the channel so update any state that 	 * might change as a result. 	 */
name|ath_chan_change
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_beacons
condition|)
block|{
comment|/* restart beacons */
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|sc
operator|->
name|sc_tdma
condition|)
name|ath_tdma_config
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ath_beacon_config
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|ath_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* restart xmit */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_reset_vap
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|u_long
name|cmd
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|IEEE80211_IOC_TXPOWER
case|:
comment|/* 		 * If per-packet TPC is enabled, then we have nothing 		 * to do; otherwise we need to force the global limit. 		 * All this can happen directly; no need to reset. 		 */
if|if
condition|(
operator|!
name|ath_hal_gettpc
argument_list|(
name|ah
argument_list|)
condition|)
name|ath_hal_settxpowlimit
argument_list|(
name|ah
argument_list|,
name|ic
operator|->
name|ic_txpowlimit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ath_reset
argument_list|(
name|ifp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ath_buf
modifier|*
name|_ath_getbuf_locked
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|ATH_TXBUF_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
operator|&&
operator|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_BUSY
operator|)
operator|==
literal|0
condition|)
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
else|else
name|bf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|__func__
argument_list|,
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|)
operator|==
name|NULL
condition|?
literal|"out of xmit buffers"
else|:
literal|"xmit buffer busy"
argument_list|)
expr_stmt|;
block|}
return|return
name|bf
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ath_buf
modifier|*
name|ath_getbuf
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bf
operator|=
name|_ath_getbuf_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: stop queue\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_qstop
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|bf
return|;
block|}
end_function

begin_comment
comment|/*  * Cleanup driver resources when we run out of buffers  * while processing fragments; return the tx buffers  * allocated and drop node references.  */
end_comment

begin_function
specifier|static
name|void
name|ath_txfrag_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ath_bufhead
modifier|*
name|frags
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|ATH_TXBUF_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|bf
argument_list|,
argument|frags
argument_list|,
argument|bf_list
argument_list|,
argument|next
argument_list|)
block|{
comment|/* NB: bf assumed clean */
name|STAILQ_REMOVE_HEAD
argument_list|(
name|frags
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ieee80211_node_decref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Setup xmit of a fragmented frame.  Allocate a buffer  * for each frag and bump the node reference count to  * reflect the held reference to be setup by ath_tx_start.  */
end_comment

begin_function
specifier|static
name|int
name|ath_txfrag_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ath_bufhead
modifier|*
name|frags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
operator|->
name|m_nextpkt
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_nextpkt
control|)
block|{
name|bf
operator|=
name|_ath_getbuf_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
comment|/* out of buffers, cleanup */
name|ath_txfrag_cleanup
argument_list|(
name|sc
argument_list|,
name|frags
argument_list|,
name|ni
argument_list|)
expr_stmt|;
break|break;
block|}
name|ieee80211_node_incref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|frags
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|!
name|STAILQ_EMPTY
argument_list|(
name|frags
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|ath_bufhead
name|frags
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|sc_invalid
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Grab a TX buffer and associated resources. 		 */
name|bf
operator|=
name|ath_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
break|break;
name|IFQ_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
comment|/* 		 * Check for fragmentation.  If this frame 		 * has been broken up verify we have enough 		 * buffers to send all the fragments so all 		 * go out or none... 		 */
name|STAILQ_INIT
argument_list|(
operator|&
name|frags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_FRAG
operator|)
operator|&&
operator|!
name|ath_txfrag_setup
argument_list|(
name|sc
argument_list|,
operator|&
name|frags
argument_list|,
name|m
argument_list|,
name|ni
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: out of txfrag buffers\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nofrag
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ath_freetx
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|nextfrag
label|:
comment|/* 		 * Pass the frame to the h/w for transmission. 		 * Fragmented frames have each frag chained together 		 * with m_nextpkt.  We know there are sufficient ath_buf's 		 * to send all the frags because of work done by 		 * ath_txfrag_setup.  We leave m_nextpkt set while 		 * calling ath_tx_start so it can use it to extend the 		 * the tx duration to cover the subsequent frag and 		 * so it can reclaim all the mbufs in case of an error; 		 * ath_tx_start clears m_nextpkt once it commits to 		 * handing the frame to the hardware. 		 */
name|next
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
if|if
condition|(
name|ath_tx_start
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|bad
label|:
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|reclaim
label|:
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_txfrag_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|frags
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Beware of state changing between frags. 			 * XXX check sta power-save state? 			 */
if|if
condition|(
name|ni
operator|->
name|ni_vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: flush fragmented packet, state %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ni
operator|->
name|ni_vap
operator|->
name|iv_state
index|]
argument_list|)
expr_stmt|;
name|ath_freetx
argument_list|(
name|next
argument_list|)
expr_stmt|;
goto|goto
name|reclaim
goto|;
block|}
name|m
operator|=
name|next
expr_stmt|;
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|frags
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no buf for txfrag"
operator|)
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|frags
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
goto|goto
name|nextfrag
goto|;
block|}
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|5
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ath_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|error
init|=
name|ieee80211_media_change
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
comment|/* NB: only the fixed rate can change and that doesn't need a reset */
return|return
operator|(
name|error
operator|==
name|ENETRESET
condition|?
literal|0
else|:
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|ath_keyprint
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|u_int
name|ix
parameter_list|,
specifier|const
name|HAL_KEYVAL
modifier|*
name|hk
parameter_list|,
specifier|const
name|u_int8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|ciphers
index|[]
init|=
block|{
literal|"WEP"
block|,
literal|"AES-OCB"
block|,
literal|"AES-CCM"
block|,
literal|"CKIP"
block|,
literal|"TKIP"
block|,
literal|"CLR"
block|, 	}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|printf
argument_list|(
literal|"%s: [%02u] %-7s "
argument_list|,
name|tag
argument_list|,
name|ix
argument_list|,
name|ciphers
index|[
name|hk
operator|->
name|kv_type
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|n
operator|=
name|hk
operator|->
name|kv_len
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|hk
operator|->
name|kv_val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" mac %s"
argument_list|,
name|ether_sprintf
argument_list|(
name|mac
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hk
operator|->
name|kv_type
operator|==
name|HAL_CIPHER_TKIP
condition|)
block|{
name|printf
argument_list|(
literal|" %s "
argument_list|,
name|sc
operator|->
name|sc_splitmic
condition|?
literal|"mic"
else|:
literal|"rxmic"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|hk
operator|->
name|kv_mic
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_splitmic
condition|)
block|{
name|printf
argument_list|(
literal|" txmic "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_txmic
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|hk
operator|->
name|kv_txmic
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Set a TKIP key into the hardware.  This handles the  * potential distribution of key state to multiple key  * cache slots for TKIP.  */
end_comment

begin_function
specifier|static
name|int
name|ath_keyset_tkip
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
name|HAL_KEYVAL
modifier|*
name|hk
parameter_list|,
specifier|const
name|u_int8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
define|#
directive|define
name|IEEE80211_KEY_XR
value|(IEEE80211_KEY_XMIT | IEEE80211_KEY_RECV)
specifier|static
specifier|const
name|u_int8_t
name|zerobssid
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|KASSERT
argument_list|(
name|k
operator|->
name|wk_cipher
operator|->
name|ic_cipher
operator|==
name|IEEE80211_CIPHER_TKIP
argument_list|,
operator|(
literal|"got a non-TKIP key, cipher %u"
operator|,
name|k
operator|->
name|wk_cipher
operator|->
name|ic_cipher
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_XR
operator|)
operator|==
name|IEEE80211_KEY_XR
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_splitmic
condition|)
block|{
comment|/* 			 * TX key goes at first index, RX key at the rx index. 			 * The hal handles the MIC keys at index+64. 			 */
name|memcpy
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|,
name|k
operator|->
name|wk_txmic
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|)
argument_list|)
expr_stmt|;
name|KEYPRINTF
argument_list|(
name|sc
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|zerobssid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_keyset
argument_list|(
name|ah
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|zerobssid
argument_list|)
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|,
name|k
operator|->
name|wk_rxmic
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|)
argument_list|)
expr_stmt|;
name|KEYPRINTF
argument_list|(
name|sc
argument_list|,
name|k
operator|->
name|wk_keyix
operator|+
literal|32
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
expr_stmt|;
comment|/* XXX delete tx key on failure? */
return|return
name|ath_hal_keyset
argument_list|(
name|ah
argument_list|,
name|k
operator|->
name|wk_keyix
operator|+
literal|32
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
return|;
block|}
else|else
block|{
comment|/* 			 * Room for both TX+RX MIC keys in one key cache 			 * slot, just set key at the first index; the hal 			 * will handle the rest. 			 */
name|memcpy
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|,
name|k
operator|->
name|wk_rxmic
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hk
operator|->
name|kv_txmic
argument_list|,
name|k
operator|->
name|wk_txmic
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_txmic
argument_list|)
argument_list|)
expr_stmt|;
name|KEYPRINTF
argument_list|(
name|sc
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
expr_stmt|;
return|return
name|ath_hal_keyset
argument_list|(
name|ah
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_XMIT
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_splitmic
condition|)
block|{
comment|/* 			 * NB: must pass MIC key in expected location when 			 * the keycache only holds one MIC key per entry. 			 */
name|memcpy
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|,
name|k
operator|->
name|wk_txmic
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_txmic
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|hk
operator|->
name|kv_txmic
argument_list|,
name|k
operator|->
name|wk_txmic
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_txmic
argument_list|)
argument_list|)
expr_stmt|;
name|KEYPRINTF
argument_list|(
name|sc
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
expr_stmt|;
return|return
name|ath_hal_keyset
argument_list|(
name|ah
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_RECV
condition|)
block|{
name|memcpy
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|,
name|k
operator|->
name|wk_rxmic
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|)
argument_list|)
expr_stmt|;
name|KEYPRINTF
argument_list|(
name|sc
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
expr_stmt|;
return|return
name|ath_hal_keyset
argument_list|(
name|ah
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
return|;
block|}
return|return
literal|0
return|;
undef|#
directive|undef
name|IEEE80211_KEY_XR
block|}
end_function

begin_comment
comment|/*  * Set a net80211 key into the hardware.  This handles the  * potential distribution of key state to multiple key  * cache slots for TKIP with hardware MIC support.  */
end_comment

begin_function
specifier|static
name|int
name|ath_keyset
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|bss
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
specifier|static
specifier|const
name|u_int8_t
name|ciphermap
index|[]
init|=
block|{
name|HAL_CIPHER_WEP
block|,
comment|/* IEEE80211_CIPHER_WEP */
name|HAL_CIPHER_TKIP
block|,
comment|/* IEEE80211_CIPHER_TKIP */
name|HAL_CIPHER_AES_OCB
block|,
comment|/* IEEE80211_CIPHER_AES_OCB */
name|HAL_CIPHER_AES_CCM
block|,
comment|/* IEEE80211_CIPHER_AES_CCM */
operator|(
name|u_int8_t
operator|)
operator|-
literal|1
block|,
comment|/* 4 is not allocated */
name|HAL_CIPHER_CKIP
block|,
comment|/* IEEE80211_CIPHER_CKIP */
name|HAL_CIPHER_CLR
block|,
comment|/* IEEE80211_CIPHER_NONE */
block|}
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
specifier|const
name|struct
name|ieee80211_cipher
modifier|*
name|cip
init|=
name|k
operator|->
name|wk_cipher
decl_stmt|;
name|u_int8_t
name|gmac
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
specifier|const
name|u_int8_t
modifier|*
name|mac
decl_stmt|;
name|HAL_KEYVAL
name|hk
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hk
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Software crypto uses a "clear key" so non-crypto 	 * state kept in the key cache are maintained and 	 * so that rx frames have an entry to match. 	 */
if|if
condition|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWCRYPT
operator|)
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|cip
operator|->
name|ic_cipher
operator|<
name|N
argument_list|(
name|ciphermap
argument_list|)
argument_list|,
operator|(
literal|"invalid cipher type %u"
operator|,
name|cip
operator|->
name|ic_cipher
operator|)
argument_list|)
expr_stmt|;
name|hk
operator|.
name|kv_type
operator|=
name|ciphermap
index|[
name|cip
operator|->
name|ic_cipher
index|]
expr_stmt|;
name|hk
operator|.
name|kv_len
operator|=
name|k
operator|->
name|wk_keylen
expr_stmt|;
name|memcpy
argument_list|(
name|hk
operator|.
name|kv_val
argument_list|,
name|k
operator|->
name|wk_key
argument_list|,
name|k
operator|->
name|wk_keylen
argument_list|)
expr_stmt|;
block|}
else|else
name|hk
operator|.
name|kv_type
operator|=
name|HAL_CIPHER_CLR
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_GROUP
operator|)
operator|&&
name|sc
operator|->
name|sc_mcastkey
condition|)
block|{
comment|/* 		 * Group keys on hardware that supports multicast frame 		 * key search use a mac that is the sender's address with 		 * the high bit set instead of the app-specified address. 		 */
name|IEEE80211_ADDR_COPY
argument_list|(
name|gmac
argument_list|,
name|bss
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
name|gmac
index|[
literal|0
index|]
operator||=
literal|0x80
expr_stmt|;
name|mac
operator|=
name|gmac
expr_stmt|;
block|}
else|else
name|mac
operator|=
name|k
operator|->
name|wk_macaddr
expr_stmt|;
if|if
condition|(
name|hk
operator|.
name|kv_type
operator|==
name|HAL_CIPHER_TKIP
operator|&&
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWMIC
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|ath_keyset_tkip
argument_list|(
name|sc
argument_list|,
name|k
argument_list|,
operator|&
name|hk
argument_list|,
name|mac
argument_list|)
return|;
block|}
else|else
block|{
name|KEYPRINTF
argument_list|(
name|sc
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
operator|&
name|hk
argument_list|,
name|mac
argument_list|)
expr_stmt|;
return|return
name|ath_hal_keyset
argument_list|(
name|ah
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
operator|&
name|hk
argument_list|,
name|mac
argument_list|)
return|;
block|}
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Allocate tx/rx key slots for TKIP.  We allocate two slots for  * each key, one for decrypt/encrypt and the other for the MIC.  */
end_comment

begin_function
specifier|static
name|u_int16_t
name|key_alloc_2pair
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ieee80211_keyix
modifier|*
name|txkeyix
parameter_list|,
name|ieee80211_keyix
modifier|*
name|rxkeyix
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|u_int
name|i
decl_stmt|,
name|keyix
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_splitmic
argument_list|,
operator|(
literal|"key cache !split"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX could optimize */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|u_int8_t
name|b
init|=
name|sc
operator|->
name|sc_keymap
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|0xff
condition|)
block|{
comment|/* 			 * One or more slots in this byte are free. 			 */
name|keyix
operator|=
name|i
operator|*
name|NBBY
expr_stmt|;
while|while
condition|(
name|b
operator|&
literal|1
condition|)
block|{
name|again
label|:
name|keyix
operator|++
expr_stmt|;
name|b
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* XXX IEEE80211_KEY_XMIT | IEEE80211_KEY_RECV */
if|if
condition|(
name|isset
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|32
argument_list|)
operator|||
name|isset
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|64
argument_list|)
operator|||
name|isset
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|32
operator|+
literal|64
argument_list|)
condition|)
block|{
comment|/* full pair unavailable */
comment|/* XXX statistic */
if|if
condition|(
name|keyix
operator|==
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|NBBY
condition|)
block|{
comment|/* no slots were appropriate, advance */
continue|continue;
block|}
goto|goto
name|again
goto|;
block|}
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|64
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|32
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|32
operator|+
literal|64
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: key pair %u,%u %u,%u\n"
argument_list|,
name|__func__
argument_list|,
name|keyix
argument_list|,
name|keyix
operator|+
literal|64
argument_list|,
name|keyix
operator|+
literal|32
argument_list|,
name|keyix
operator|+
literal|32
operator|+
literal|64
argument_list|)
expr_stmt|;
operator|*
name|txkeyix
operator|=
name|keyix
expr_stmt|;
operator|*
name|rxkeyix
operator|=
name|keyix
operator|+
literal|32
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: out of pair space\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Allocate tx/rx key slots for TKIP.  We allocate two slots for  * each key, one for decrypt/encrypt and the other for the MIC.  */
end_comment

begin_function
specifier|static
name|u_int16_t
name|key_alloc_pair
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ieee80211_keyix
modifier|*
name|txkeyix
parameter_list|,
name|ieee80211_keyix
modifier|*
name|rxkeyix
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|u_int
name|i
decl_stmt|,
name|keyix
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
name|sc
operator|->
name|sc_splitmic
argument_list|,
operator|(
literal|"key cache split"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX could optimize */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|u_int8_t
name|b
init|=
name|sc
operator|->
name|sc_keymap
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|0xff
condition|)
block|{
comment|/* 			 * One or more slots in this byte are free. 			 */
name|keyix
operator|=
name|i
operator|*
name|NBBY
expr_stmt|;
while|while
condition|(
name|b
operator|&
literal|1
condition|)
block|{
name|again
label|:
name|keyix
operator|++
expr_stmt|;
name|b
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|isset
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|64
argument_list|)
condition|)
block|{
comment|/* full pair unavailable */
comment|/* XXX statistic */
if|if
condition|(
name|keyix
operator|==
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|NBBY
condition|)
block|{
comment|/* no slots were appropriate, advance */
continue|continue;
block|}
goto|goto
name|again
goto|;
block|}
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|64
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: key pair %u,%u\n"
argument_list|,
name|__func__
argument_list|,
name|keyix
argument_list|,
name|keyix
operator|+
literal|64
argument_list|)
expr_stmt|;
operator|*
name|txkeyix
operator|=
operator|*
name|rxkeyix
operator|=
name|keyix
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: out of pair space\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Allocate a single key cache slot.  */
end_comment

begin_function
specifier|static
name|int
name|key_alloc_single
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ieee80211_keyix
modifier|*
name|txkeyix
parameter_list|,
name|ieee80211_keyix
modifier|*
name|rxkeyix
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|u_int
name|i
decl_stmt|,
name|keyix
decl_stmt|;
comment|/* XXX try i,i+32,i+64,i+32+64 to minimize key pair conflicts */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|u_int8_t
name|b
init|=
name|sc
operator|->
name|sc_keymap
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|0xff
condition|)
block|{
comment|/* 			 * One or more slots are free. 			 */
name|keyix
operator|=
name|i
operator|*
name|NBBY
expr_stmt|;
while|while
condition|(
name|b
operator|&
literal|1
condition|)
name|keyix
operator|++
operator|,
name|b
operator|>>=
literal|1
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: key %u\n"
argument_list|,
name|__func__
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
operator|*
name|txkeyix
operator|=
operator|*
name|rxkeyix
operator|=
name|keyix
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: out of space\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Allocate one or more key cache slots for a uniacst key.  The  * key itself is needed only to identify the cipher.  For hardware  * TKIP with split cipher+MIC keys we allocate two key cache slot  * pairs so that we can setup separate TX and RX MIC keys.  Note  * that the MIC key for a TKIP key at slot i is assumed by the  * hardware to be at slot i+64.  This limits TKIP keys to the first  * 64 entries.  */
end_comment

begin_function
specifier|static
name|int
name|ath_key_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
name|ieee80211_keyix
modifier|*
name|keyix
parameter_list|,
name|ieee80211_keyix
modifier|*
name|rxkeyix
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
comment|/* 	 * Group key allocation must be handled specially for 	 * parts that do not support multicast key cache search 	 * functionality.  For those parts the key id must match 	 * the h/w key index so lookups find the right key.  On 	 * parts w/ the key search facility we install the sender's 	 * mac address (with the high bit set) and let the hardware 	 * find the key w/o using the key id.  This is preferred as 	 * it permits us to support multiple users for adhoc and/or 	 * multi-station operation. 	 */
if|if
condition|(
name|k
operator|->
name|wk_keyix
operator|!=
name|IEEE80211_KEYIX_NONE
operator|||
comment|/* global key */
operator|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_GROUP
operator|)
operator|&&
operator|!
name|sc
operator|->
name|sc_mcastkey
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|&
name|vap
operator|->
name|iv_nw_keys
index|[
literal|0
index|]
operator|<=
name|k
operator|&&
name|k
operator|<
operator|&
name|vap
operator|->
name|iv_nw_keys
index|[
name|IEEE80211_WEP_NKID
index|]
operator|)
condition|)
block|{
comment|/* should not happen */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: bogus group key\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 		 * XXX we pre-allocate the global keys so 		 * have no way to check if they've already been allocated. 		 */
operator|*
name|keyix
operator|=
operator|*
name|rxkeyix
operator|=
name|k
operator|-
name|vap
operator|->
name|iv_nw_keys
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * We allocate two pair for TKIP when using the h/w to do 	 * the MIC.  For everything else, including software crypto, 	 * we allocate a single entry.  Note that s/w crypto requires 	 * a pass-through slot on the 5211 and 5212.  The 5210 does 	 * not support pass-through cache entries and we map all 	 * those requests to slot 0. 	 */
if|if
condition|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWCRYPT
condition|)
block|{
return|return
name|key_alloc_single
argument_list|(
name|sc
argument_list|,
name|keyix
argument_list|,
name|rxkeyix
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|k
operator|->
name|wk_cipher
operator|->
name|ic_cipher
operator|==
name|IEEE80211_CIPHER_TKIP
operator|&&
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWMIC
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_splitmic
condition|)
return|return
name|key_alloc_2pair
argument_list|(
name|sc
argument_list|,
name|keyix
argument_list|,
name|rxkeyix
argument_list|)
return|;
else|else
return|return
name|key_alloc_pair
argument_list|(
name|sc
argument_list|,
name|keyix
argument_list|,
name|rxkeyix
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|key_alloc_single
argument_list|(
name|sc
argument_list|,
name|keyix
argument_list|,
name|rxkeyix
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Delete an entry in the key cache allocated by ath_key_alloc.  */
end_comment

begin_function
specifier|static
name|int
name|ath_key_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
specifier|const
name|struct
name|ieee80211_cipher
modifier|*
name|cip
init|=
name|k
operator|->
name|wk_cipher
decl_stmt|;
name|u_int
name|keyix
init|=
name|k
operator|->
name|wk_keyix
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: delete key %u\n"
argument_list|,
name|__func__
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
name|ath_hal_keyreset
argument_list|(
name|ah
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
comment|/* 	 * Handle split tx/rx keying required for TKIP with h/w MIC. 	 */
if|if
condition|(
name|cip
operator|->
name|ic_cipher
operator|==
name|IEEE80211_CIPHER_TKIP
operator|&&
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWMIC
operator|)
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_splitmic
condition|)
name|ath_hal_keyreset
argument_list|(
name|ah
argument_list|,
name|keyix
operator|+
literal|32
argument_list|)
expr_stmt|;
comment|/* RX key */
if|if
condition|(
name|keyix
operator|>=
name|IEEE80211_WEP_NKID
condition|)
block|{
comment|/* 		 * Don't touch keymap entries for global keys so 		 * they are never considered for dynamic allocation. 		 */
name|clrbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
if|if
condition|(
name|cip
operator|->
name|ic_cipher
operator|==
name|IEEE80211_CIPHER_TKIP
operator|&&
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWMIC
operator|)
operator|==
literal|0
condition|)
block|{
name|clrbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|64
argument_list|)
expr_stmt|;
comment|/* TX key MIC */
if|if
condition|(
name|sc
operator|->
name|sc_splitmic
condition|)
block|{
comment|/* +32 for RX key, +32+64 for RX key MIC */
name|clrbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|32
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|32
operator|+
literal|64
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Set the key cache contents for the specified key.  Key cache  * slot(s) must already have been allocated by ath_key_alloc.  */
end_comment

begin_function
specifier|static
name|int
name|ath_key_set
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
specifier|const
name|u_int8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
return|return
name|ath_keyset
argument_list|(
name|sc
argument_list|,
name|k
argument_list|,
name|vap
operator|->
name|iv_bss
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Block/unblock tx+rx processing while a key change is done.  * We assume the caller serializes key management operations  * so we only need to worry about synchronization with other  * uses that originate in the driver.  */
end_comment

begin_function
specifier|static
name|void
name|ath_key_update_begin
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s:\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|taskqueue_block
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|IF_LOCK
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/* NB: doesn't block mgmt frames */
block|}
end_function

begin_function
specifier|static
name|void
name|ath_key_update_end
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s:\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IF_UNLOCK
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|taskqueue_unblock
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Calculate the receive filter according to the  * operating mode and state:  *  * o always accept unicast, broadcast, and multicast traffic  * o accept PHY error frames when hardware doesn't have MIB support  *   to count and we need them for ANI (sta mode only until recently)  *   and we are not scanning (ANI is disabled)  *   NB: older hal's add rx filter bits out of sight and we need to  *	 blindly preserve them  * o probe request frames are accepted only when operating in  *   hostap, adhoc, mesh, or monitor modes  * o enable promiscuous mode  *   - when in monitor mode  *   - if interface marked PROMISC (assumes bridge setting is filtered)  * o accept beacons:  *   - when operating in station mode for collecting rssi data when  *     the station is otherwise quiet, or  *   - when operating in adhoc mode so the 802.11 layer creates  *     node table entries for peers,  *   - when scanning  *   - when doing s/w beacon miss (e.g. for ap+sta)  *   - when operating in ap mode in 11g to detect overlapping bss that  *     require protection  *   - when operating in mesh mode to detect neighbors  * o accept control frames:  *   - when in monitor mode  * XXX BAR frames for 11n  * XXX HT protection for 11n  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|ath_calcrxfilter
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
name|rfilt
operator|=
name|HAL_RX_FILTER_UCAST
operator||
name|HAL_RX_FILTER_BCAST
operator||
name|HAL_RX_FILTER_MCAST
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_needmib
operator|&&
operator|!
name|sc
operator|->
name|sc_scanning
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_PHYERR
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_STA
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_PROBEREQ
expr_stmt|;
comment|/* XXX ic->ic_monvaps != 0? */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_PROM
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|||
name|sc
operator|->
name|sc_swbmiss
operator|||
name|sc
operator|->
name|sc_scanning
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_BEACON
expr_stmt|;
comment|/* 	 * NB: We don't recalculate the rx filter when 	 * ic_protmode changes; otherwise we could do 	 * this only when ic_protmode != NONE. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|&&
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_BEACON
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nmeshvaps
condition|)
block|{
name|rfilt
operator||=
name|HAL_RX_FILTER_BEACON
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hasbmatch
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_BSSID
expr_stmt|;
else|else
name|rfilt
operator||=
name|HAL_RX_FILTER_PROM
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_CONTROL
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_MODE
argument_list|,
literal|"%s: RX filter 0x%x, %s if_flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|rfilt
argument_list|,
name|ieee80211_opmode_name
index|[
name|ic
operator|->
name|ic_opmode
index|]
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
return|return
name|rfilt
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_update_promisc
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
comment|/* configure rx filter */
name|rfilt
operator|=
name|ath_calcrxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_setrxfilter
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_MODE
argument_list|,
literal|"%s: RX filter 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_update_mcast
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u_int32_t
name|mfilt
index|[
literal|2
index|]
decl_stmt|;
comment|/* calculate and install multicast filter */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
comment|/* 		 * Merge multicast addresses to form the hardware filter. 		 */
name|mfilt
index|[
literal|0
index|]
operator|=
name|mfilt
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* XXX need some fiddling to remove? */
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
name|caddr_t
name|dl
decl_stmt|;
name|u_int32_t
name|val
decl_stmt|;
name|u_int8_t
name|pos
decl_stmt|;
comment|/* calculate XOR of eight 6bit values */
name|dl
operator|=
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
name|val
operator|=
name|LE_READ_4
argument_list|(
name|dl
operator|+
literal|0
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|(
name|val
operator|>>
literal|18
operator|)
operator|^
operator|(
name|val
operator|>>
literal|12
operator|)
operator|^
operator|(
name|val
operator|>>
literal|6
operator|)
operator|^
name|val
expr_stmt|;
name|val
operator|=
name|LE_READ_4
argument_list|(
name|dl
operator|+
literal|3
argument_list|)
expr_stmt|;
name|pos
operator|^=
operator|(
name|val
operator|>>
literal|18
operator|)
operator|^
operator|(
name|val
operator|>>
literal|12
operator|)
operator|^
operator|(
name|val
operator|>>
literal|6
operator|)
operator|^
name|val
expr_stmt|;
name|pos
operator|&=
literal|0x3f
expr_stmt|;
name|mfilt
index|[
name|pos
operator|/
literal|32
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|pos
operator|%
literal|32
operator|)
operator|)
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
name|mfilt
index|[
literal|0
index|]
operator|=
name|mfilt
index|[
literal|1
index|]
operator|=
operator|~
literal|0
expr_stmt|;
name|ath_hal_setmcastfilter
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|mfilt
index|[
literal|0
index|]
argument_list|,
name|mfilt
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_MODE
argument_list|,
literal|"%s: MC filter %08x:%08x\n"
argument_list|,
name|__func__
argument_list|,
name|mfilt
index|[
literal|0
index|]
argument_list|,
name|mfilt
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_mode_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
comment|/* configure rx filter */
name|rfilt
operator|=
name|ath_calcrxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
comment|/* configure operational mode */
name|ath_hal_setopmode
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* handle any link-level address change */
name|ath_hal_setmac
argument_list|(
name|ah
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* calculate and install multicast filter */
name|ath_update_mcast
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the slot time based on the current setting.  */
end_comment

begin_function
specifier|static
name|void
name|ath_setslottime
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|sc
operator|->
name|sc_ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|u_int
name|usec
decl_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|usec
operator|=
literal|13
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|usec
operator|=
literal|21
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
block|{
comment|/* honor short/long slot time only in 11g */
comment|/* XXX shouldn't honor on pure g or turbo g channel */
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|)
name|usec
operator|=
name|HAL_SLOT_TIME_9
expr_stmt|;
else|else
name|usec
operator|=
name|HAL_SLOT_TIME_20
expr_stmt|;
block|}
else|else
name|usec
operator|=
name|HAL_SLOT_TIME_9
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: chan %u MHz flags 0x%x %s slot, %u usec\n"
argument_list|,
name|__func__
argument_list|,
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_freq
argument_list|,
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_flags
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|?
literal|"short"
else|:
literal|"long"
argument_list|,
name|usec
argument_list|)
expr_stmt|;
name|ath_hal_setslottime
argument_list|(
name|ah
argument_list|,
name|usec
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_updateslot
operator|=
name|OK
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from the 802.11 layer to update the  * slot time based on the current setting.  */
end_comment

begin_function
specifier|static
name|void
name|ath_updateslot
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
comment|/* 	 * When not coordinating the BSS, change the hardware 	 * immediately.  For other operation we defer the change 	 * until beacon updates have propagated to the stations. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
name|sc
operator|->
name|sc_updateslot
operator|=
name|UPDATE
expr_stmt|;
else|else
name|ath_setslottime
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup a h/w transmit queue for beacons.  */
end_comment

begin_function
specifier|static
name|int
name|ath_beaconq_setup
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|HAL_TXQ_INFO
name|qi
decl_stmt|;
name|memset
argument_list|(
operator|&
name|qi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|qi
argument_list|)
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_aifs
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmin
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmax
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
comment|/* NB: for dynamic turbo, don't enable any other interrupts */
name|qi
operator|.
name|tqi_qflags
operator|=
name|HAL_TXQ_TXDESCINT_ENABLE
expr_stmt|;
return|return
name|ath_hal_setuptxqueue
argument_list|(
name|ah
argument_list|,
name|HAL_TX_QUEUE_BEACON
argument_list|,
operator|&
name|qi
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Setup the transmit queue parameters for the beacon queue.  */
end_comment

begin_function
specifier|static
name|int
name|ath_beaconq_config
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
define|#
directive|define
name|ATH_EXPONENT_TO_VALUE
parameter_list|(
name|v
parameter_list|)
value|((1<<(v))-1)
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|sc
operator|->
name|sc_ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_TXQ_INFO
name|qi
decl_stmt|;
name|ath_hal_gettxqueueprops
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
operator|&
name|qi
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
comment|/* 		 * Always burst out beacon and CAB traffic. 		 */
name|qi
operator|.
name|tqi_aifs
operator|=
name|ATH_BEACON_AIFS_DEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmin
operator|=
name|ATH_BEACON_CWMIN_DEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmax
operator|=
name|ATH_BEACON_CWMAX_DEFAULT
expr_stmt|;
block|}
else|else
block|{
name|struct
name|wmeParams
modifier|*
name|wmep
init|=
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|WME_AC_BE
index|]
decl_stmt|;
comment|/* 		 * Adhoc mode; important thing is to use 2x cwmin. 		 */
name|qi
operator|.
name|tqi_aifs
operator|=
name|wmep
operator|->
name|wmep_aifsn
expr_stmt|;
name|qi
operator|.
name|tqi_cwmin
operator|=
literal|2
operator|*
name|ATH_EXPONENT_TO_VALUE
argument_list|(
name|wmep
operator|->
name|wmep_logcwmin
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_cwmax
operator|=
name|ATH_EXPONENT_TO_VALUE
argument_list|(
name|wmep
operator|->
name|wmep_logcwmax
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ath_hal_settxqueueprops
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
operator|&
name|qi
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to update parameters for "
literal|"beacon hardware queue!\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|ath_hal_resettxqueue
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
comment|/* push to h/w */
return|return
literal|1
return|;
block|}
undef|#
directive|undef
name|ATH_EXPONENT_TO_VALUE
block|}
end_function

begin_comment
comment|/*  * Allocate and setup an initial beacon frame.  */
end_comment

begin_function
specifier|static
name|int
name|ath_beacon_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bf
operator|=
name|avp
operator|->
name|av_bcbuf
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_node
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * NB: the beacon data buffer must be 32-bit aligned; 	 * we assume the mbuf routines will return us something 	 * with this alignment (perhaps should assert). 	 */
name|m
operator|=
name|ieee80211_beacon_alloc
argument_list|(
name|ni
argument_list|,
operator|&
name|avp
operator|->
name|av_boff
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cannot get mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_nombuf
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cannot map mbuf, bus_dmamap_load_mbuf_sg returns %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Calculate a TSF adjustment factor required for staggered 	 * beacons.  Note that we assume the format of the beacon 	 * frame leaves the tstamp field immediately following the 	 * header. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_stagbeacons
operator|&&
name|avp
operator|->
name|av_bslot
operator|>
literal|0
condition|)
block|{
name|uint64_t
name|tsfadjust
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
comment|/* 		 * The beacon interval is in TU's; the TSF is in usecs. 		 * We figure out how many TU's to add to align the timestamp 		 * then convert to TSF units and handle byte swapping before 		 * inserting it in the frame.  The hardware will then add this 		 * each time a beacon frame is sent.  Note that we align vap's 		 * 1..N and leave vap 0 untouched.  This means vap 0 has a 		 * timestamp in one beacon interval while the others get a 		 * timstamp aligned to the next interval. 		 */
name|tsfadjust
operator|=
name|ni
operator|->
name|ni_intval
operator|*
operator|(
name|ATH_BCBUF
operator|-
name|avp
operator|->
name|av_bslot
operator|)
operator|/
name|ATH_BCBUF
expr_stmt|;
name|tsfadjust
operator|=
name|htole64
argument_list|(
name|tsfadjust
operator|<<
literal|10
argument_list|)
expr_stmt|;
comment|/* TU -> TSF */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: %s beacons bslot %d intval %u tsfadjust %llu\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_stagbeacons
condition|?
literal|"stagger"
else|:
literal|"burst"
argument_list|,
name|avp
operator|->
name|av_bslot
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|,
operator|(
name|long
name|long
name|unsigned
operator|)
name|le64toh
argument_list|(
name|tsfadjust
argument_list|)
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|wh
index|[
literal|1
index|]
argument_list|,
operator|&
name|tsfadjust
argument_list|,
sizeof|sizeof
argument_list|(
name|tsfadjust
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bf
operator|->
name|bf_m
operator|=
name|m
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Setup the beacon frame for transmit.  */
end_comment

begin_function
specifier|static
name|void
name|ath_beacon_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
define|#
directive|define
name|USE_SHPREAMBLE
parameter_list|(
name|_ic
parameter_list|)
define|\
value|(((_ic)->ic_flags& (IEEE80211_F_SHPREAMBLE | IEEE80211_F_USEBARKER))\ 		== IEEE80211_F_SHPREAMBLE)
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|bf
operator|->
name|bf_m
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|antenna
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|u_int8_t
name|rix
decl_stmt|,
name|rate
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON_PROC
argument_list|,
literal|"%s: m %p len %u\n"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
comment|/* setup descriptors */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|flags
operator|=
name|HAL_TXDESC_NOACK
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|&&
name|sc
operator|->
name|sc_hasveol
condition|)
block|{
name|ds
operator|->
name|ds_link
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
comment|/* self-linked */
name|flags
operator||=
name|HAL_TXDESC_VEOL
expr_stmt|;
comment|/* 		 * Let hardware handle antenna switching. 		 */
name|antenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
block|}
else|else
block|{
name|ds
operator|->
name|ds_link
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Switch antenna every 4 beacons. 		 * XXX assumes two antenna 		 */
if|if
condition|(
name|sc
operator|->
name|sc_txantenna
operator|!=
literal|0
condition|)
name|antenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_stagbeacons
operator|&&
name|sc
operator|->
name|sc_nbcnvaps
operator|!=
literal|0
condition|)
name|antenna
operator|=
operator|(
operator|(
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_xmit
operator|/
name|sc
operator|->
name|sc_nbcnvaps
operator|)
operator|&
literal|4
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
else|else
name|antenna
operator|=
operator|(
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_xmit
operator|&
literal|4
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|bf
operator|->
name|bf_nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"multi-segment beacon frame; nseg %u"
operator|,
name|bf
operator|->
name|bf_nseg
operator|)
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_data
operator|=
name|bf
operator|->
name|bf_segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
comment|/* 	 * Calculate rate code. 	 * XXX everything at min xmit rate 	 */
name|rix
operator|=
literal|0
expr_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
name|rate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|USE_SHPREAMBLE
argument_list|(
name|ic
argument_list|)
condition|)
name|rate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|ath_hal_setuptxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|m
operator|->
name|m_len
operator|+
name|IEEE80211_CRC_LEN
comment|/* frame length */
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
comment|/* header length */
argument_list|,
name|HAL_PKT_TYPE_BEACON
comment|/* Atheros packet type */
argument_list|,
name|ni
operator|->
name|ni_txpower
comment|/* txpower XXX */
argument_list|,
name|rate
argument_list|,
literal|1
comment|/* series 0 rate/tries */
argument_list|,
name|HAL_TXKEYIX_INVALID
comment|/* no encryption */
argument_list|,
name|antenna
comment|/* antenna mode */
argument_list|,
name|flags
comment|/* no ack, veol for beacons */
argument_list|,
literal|0
comment|/* rts/cts rate */
argument_list|,
literal|0
comment|/* rts/cts duration */
argument_list|)
expr_stmt|;
comment|/* NB: beacon's BufLen must be a multiple of 4 bytes */
name|ath_hal_filltxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|roundup
argument_list|(
name|m
operator|->
name|m_len
argument_list|,
literal|4
argument_list|)
comment|/* buffer length */
argument_list|,
name|AH_TRUE
comment|/* first segment */
argument_list|,
name|AH_TRUE
comment|/* last segment */
argument_list|,
name|ds
comment|/* first descriptor */
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|ath_desc_swap(ds);
endif|#
directive|endif
undef|#
directive|undef
name|USE_SHPREAMBLE
block|}
end_function

begin_function
specifier|static
name|void
name|ath_beacon_update
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|item
parameter_list|)
block|{
name|struct
name|ieee80211_beacon_offsets
modifier|*
name|bo
init|=
operator|&
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|av_boff
decl_stmt|;
name|setbit
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append the contents of src to dst; both queues  * are assumed to be locked.  */
end_comment

begin_function
specifier|static
name|void
name|ath_txqmove
parameter_list|(
name|struct
name|ath_txq
modifier|*
name|dst
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|src
parameter_list|)
block|{
name|STAILQ_CONCAT
argument_list|(
operator|&
name|dst
operator|->
name|axq_q
argument_list|,
operator|&
name|src
operator|->
name|axq_q
argument_list|)
expr_stmt|;
name|dst
operator|->
name|axq_link
operator|=
name|src
operator|->
name|axq_link
expr_stmt|;
name|src
operator|->
name|axq_link
operator|=
name|NULL
expr_stmt|;
name|dst
operator|->
name|axq_depth
operator|+=
name|src
operator|->
name|axq_depth
expr_stmt|;
name|src
operator|->
name|axq_depth
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Transmit a beacon frame at SWBA.  Dynamic updates to the  * frame contents are done as needed and the slot time is  * also adjusted based on current state.  */
end_comment

begin_function
specifier|static
name|void
name|ath_beacon_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|otherant
decl_stmt|;
name|uint32_t
name|bfaddr
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON_PROC
argument_list|,
literal|"%s: pending %u\n"
argument_list|,
name|__func__
argument_list|,
name|pending
argument_list|)
expr_stmt|;
comment|/* 	 * Check if the previous beacon has gone out.  If 	 * not don't try to post another, skip this period 	 * and wait for the next.  Missed beacons indicate 	 * a problem and should not occur.  If we miss too 	 * many consecutive beacons reset the device. 	 */
if|if
condition|(
name|ath_hal_numtxpending
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_bmisscount
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: missed %u consecutive beacons\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bmisscount
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bmisscount
operator|>=
name|ath_bstuck_threshold
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_bstucktask
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_bmisscount
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: resume beacon xmit after %u misses\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bmisscount
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bmisscount
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_stagbeacons
condition|)
block|{
comment|/* staggered beacons */
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|sc
operator|->
name|sc_ifp
operator|->
name|if_l2com
decl_stmt|;
name|uint32_t
name|tsftu
decl_stmt|;
name|tsftu
operator|=
name|ath_hal_gettsf32
argument_list|(
name|ah
argument_list|)
operator|>>
literal|10
expr_stmt|;
comment|/* XXX lintval */
name|slot
operator|=
operator|(
operator|(
name|tsftu
operator|%
name|ic
operator|->
name|ic_lintval
operator|)
operator|*
name|ATH_BCBUF
operator|)
operator|/
name|ic
operator|->
name|ic_lintval
expr_stmt|;
name|vap
operator|=
name|sc
operator|->
name|sc_bslot
index|[
operator|(
name|slot
operator|+
literal|1
operator|)
operator|%
name|ATH_BCBUF
index|]
expr_stmt|;
name|bfaddr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vap
operator|!=
name|NULL
operator|&&
name|vap
operator|->
name|iv_state
operator|>=
name|IEEE80211_S_RUN
condition|)
block|{
name|bf
operator|=
name|ath_beacon_generate
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
name|bfaddr
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* burst'd beacons */
name|uint32_t
modifier|*
name|bflink
init|=
operator|&
name|bfaddr
decl_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|ATH_BCBUF
condition|;
name|slot
operator|++
control|)
block|{
name|vap
operator|=
name|sc
operator|->
name|sc_bslot
index|[
name|slot
index|]
expr_stmt|;
if|if
condition|(
name|vap
operator|!=
name|NULL
operator|&&
name|vap
operator|->
name|iv_state
operator|>=
name|IEEE80211_S_RUN
condition|)
block|{
name|bf
operator|=
name|ath_beacon_generate
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
block|{
operator|*
name|bflink
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
name|bflink
operator|=
operator|&
name|bf
operator|->
name|bf_desc
operator|->
name|ds_link
expr_stmt|;
block|}
block|}
block|}
operator|*
name|bflink
operator|=
literal|0
expr_stmt|;
comment|/* terminate list */
block|}
comment|/* 	 * Handle slot time change when a non-ERP station joins/leaves 	 * an 11g network.  The 802.11 layer notifies us via callback, 	 * we mark updateslot, then wait one beacon before effecting 	 * the change.  This gives associated stations at least one 	 * beacon interval to note the state change. 	 */
comment|/* XXX locking */
if|if
condition|(
name|sc
operator|->
name|sc_updateslot
operator|==
name|UPDATE
condition|)
block|{
name|sc
operator|->
name|sc_updateslot
operator|=
name|COMMIT
expr_stmt|;
comment|/* commit next beacon */
name|sc
operator|->
name|sc_slotupdate
operator|=
name|slot
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_updateslot
operator|==
name|COMMIT
operator|&&
name|sc
operator|->
name|sc_slotupdate
operator|==
name|slot
condition|)
name|ath_setslottime
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* commit change to h/w */
comment|/* 	 * Check recent per-antenna transmit statistics and flip 	 * the default antenna if noticeably more frames went out 	 * on the non-default antenna. 	 * XXX assumes 2 anntenae 	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_diversity
operator|&&
operator|(
operator|!
name|sc
operator|->
name|sc_stagbeacons
operator|||
name|slot
operator|==
literal|0
operator|)
condition|)
block|{
name|otherant
operator|=
name|sc
operator|->
name|sc_defant
operator|&
literal|1
condition|?
literal|2
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ant_tx
index|[
name|otherant
index|]
operator|>
name|sc
operator|->
name|sc_ant_tx
index|[
name|sc
operator|->
name|sc_defant
index|]
operator|+
literal|2
condition|)
name|ath_setdefantenna
argument_list|(
name|sc
argument_list|,
name|otherant
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ant_tx
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|sc_ant_tx
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bfaddr
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Stop any current dma and put the new frame on the queue. 		 * This should never fail since we check above that no frames 		 * are still pending on the queue. 		 */
if|if
condition|(
operator|!
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: beacon queue %u did not stop?\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
block|}
comment|/* NB: cabq traffic should already be queued and primed */
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
name|bfaddr
argument_list|)
expr_stmt|;
name|ath_hal_txstart
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_xmit
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|ath_buf
modifier|*
name|ath_beacon_generate
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|cabq
init|=
name|sc
operator|->
name|sc_cabq
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|nmcastq
decl_stmt|,
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_state
operator|>=
name|IEEE80211_S_RUN
argument_list|,
operator|(
literal|"not running, state %d"
operator|,
name|vap
operator|->
name|iv_state
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|avp
operator|->
name|av_bcbuf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no beacon buffer"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Update dynamic beacon contents.  If this returns 	 * non-zero then we need to remap the memory because 	 * the beacon frame changed size (probably because 	 * of the TIM bitmap). 	 */
name|bf
operator|=
name|avp
operator|->
name|av_bcbuf
expr_stmt|;
name|m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
name|nmcastq
operator|=
name|avp
operator|->
name|av_mcastq
operator|.
name|axq_depth
expr_stmt|;
if|if
condition|(
name|ieee80211_beacon_update
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|,
operator|&
name|avp
operator|->
name|av_boff
argument_list|,
name|m
argument_list|,
name|nmcastq
argument_list|)
condition|)
block|{
comment|/* XXX too conservative? */
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|vap
operator|->
name|iv_ifp
argument_list|,
literal|"%s: bus_dmamap_load_mbuf_sg failed, error %u\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
operator|(
name|avp
operator|->
name|av_boff
operator|.
name|bo_tim
index|[
literal|4
index|]
operator|&
literal|1
operator|)
operator|&&
name|cabq
operator|->
name|axq_depth
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: cabq did not drain, mcastq %u cabq %u\n"
argument_list|,
name|__func__
argument_list|,
name|nmcastq
argument_list|,
name|cabq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_cabq_busy
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
operator|>
literal|1
operator|&&
name|sc
operator|->
name|sc_stagbeacons
condition|)
block|{
comment|/* 			 * CABQ traffic from a previous vap is still pending. 			 * We must drain the q before this beacon frame goes 			 * out as otherwise this vap's stations will get cab 			 * frames from a different vap. 			 * XXX could be slow causing us to miss DBA 			 */
name|ath_tx_draintxq
argument_list|(
name|sc
argument_list|,
name|cabq
argument_list|)
expr_stmt|;
block|}
block|}
name|ath_beacon_setup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Enable the CAB queue before the beacon queue to 	 * insure cab frames are triggered by this beacon. 	 */
if|if
condition|(
name|avp
operator|->
name|av_boff
operator|.
name|bo_tim
index|[
literal|4
index|]
operator|&
literal|1
condition|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
comment|/* NB: only at DTIM */
name|ATH_TXQ_LOCK
argument_list|(
name|cabq
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK
argument_list|(
operator|&
name|avp
operator|->
name|av_mcastq
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmcastq
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|bfm
decl_stmt|;
comment|/* 			 * Move frames from the s/w mcast q to the h/w cab q. 			 * XXX MORE_DATA bit 			 */
name|bfm
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|avp
operator|->
name|av_mcastq
operator|.
name|axq_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|cabq
operator|->
name|axq_link
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cabq
operator|->
name|axq_link
operator|=
name|bfm
operator|->
name|bf_daddr
expr_stmt|;
block|}
else|else
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|cabq
operator|->
name|axq_qnum
argument_list|,
name|bfm
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|ath_txqmove
argument_list|(
name|cabq
argument_list|,
operator|&
name|avp
operator|->
name|av_mcastq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_cabq_xmit
operator|+=
name|nmcastq
expr_stmt|;
block|}
comment|/* NB: gated by beacon so safe to start here */
name|ath_hal_txstart
argument_list|(
name|ah
argument_list|,
name|cabq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|cabq
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
operator|&
name|avp
operator|->
name|av_mcastq
argument_list|)
expr_stmt|;
block|}
return|return
name|bf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_beacon_start_adhoc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|avp
operator|->
name|av_bcbuf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no beacon buffer"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Update dynamic beacon contents.  If this returns 	 * non-zero then we need to remap the memory because 	 * the beacon frame changed size (probably because 	 * of the TIM bitmap). 	 */
name|bf
operator|=
name|avp
operator|->
name|av_bcbuf
expr_stmt|;
name|m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
if|if
condition|(
name|ieee80211_beacon_update
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|,
operator|&
name|avp
operator|->
name|av_boff
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* XXX too conservative? */
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|vap
operator|->
name|iv_ifp
argument_list|,
literal|"%s: bus_dmamap_load_mbuf_sg failed, error %u\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ath_beacon_setup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* NB: caller is known to have already stopped tx dma */
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|ath_hal_txstart
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the hardware after detecting beacons have stopped.  */
end_comment

begin_function
specifier|static
name|void
name|ath_bstuck_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"stuck beacon; resetting (bmiss count %u)\n"
argument_list|,
name|sc
operator|->
name|sc_bmisscount
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_bstuck
operator|++
expr_stmt|;
name|ath_reset
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim beacon resources and return buffer to the pool.  */
end_comment

begin_function
specifier|static
name|void
name|ath_beacon_return
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_node
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim beacon resources.  */
end_comment

begin_function
specifier|static
name|void
name|ath_beacon_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->sc_bbuf
argument_list|,
argument|bf_list
argument_list|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_node
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Configure the beacon and sleep timers.  *  * When operating as an AP this resets the TSF and sets  * up the hardware to notify us when we need to issue beacons.  *  * When operating in station mode this sets up the beacon  * timers according to the timestamp of the last received  * beacon and the current TSF, configures PCF and DTIM  * handling, programs the sleep registers so the hardware  * will wakeup in time to receive beacons, and configures  * the beacon miss handling so we'll receive a BMISS  * interrupt when we stop seeing beacons from the AP  * we've associated with.  */
end_comment

begin_function
specifier|static
name|void
name|ath_beacon_config
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
define|#
directive|define
name|TSF_TO_TU
parameter_list|(
name|_h
parameter_list|,
name|_l
parameter_list|)
define|\
value|((((u_int32_t)(_h))<< 22) | (((u_int32_t)(_l))>> 10))
define|#
directive|define
name|FUDGE
value|2
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|sc
operator|->
name|sc_ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|u_int32_t
name|nexttbtt
decl_stmt|,
name|intval
decl_stmt|,
name|tsftu
decl_stmt|;
name|u_int64_t
name|tsf
decl_stmt|;
if|if
condition|(
name|vap
operator|==
name|NULL
condition|)
name|vap
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
expr_stmt|;
comment|/* XXX */
name|ni
operator|=
name|vap
operator|->
name|iv_bss
expr_stmt|;
comment|/* extract tstamp from last beacon and convert to TU */
name|nexttbtt
operator|=
name|TSF_TO_TU
argument_list|(
name|LE_READ_4
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
operator|+
literal|4
argument_list|)
argument_list|,
name|LE_READ_4
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
comment|/* 		 * For multi-bss ap/mesh support beacons are either staggered 		 * evenly over N slots or burst together.  For the former 		 * arrange for the SWBA to be delivered for each slot. 		 * Slots that are not occupied will generate nothing. 		 */
comment|/* NB: the beacon interval is kept internally in TU's */
name|intval
operator|=
name|ni
operator|->
name|ni_intval
operator|&
name|HAL_BEACON_PERIOD
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_stagbeacons
condition|)
name|intval
operator|/=
name|ATH_BCBUF
expr_stmt|;
block|}
else|else
block|{
comment|/* NB: the beacon interval is kept internally in TU's */
name|intval
operator|=
name|ni
operator|->
name|ni_intval
operator|&
name|HAL_BEACON_PERIOD
expr_stmt|;
block|}
if|if
condition|(
name|nexttbtt
operator|==
literal|0
condition|)
comment|/* e.g. for ap mode */
name|nexttbtt
operator|=
name|intval
expr_stmt|;
elseif|else
if|if
condition|(
name|intval
condition|)
comment|/* NB: can be 0 for monitor mode */
name|nexttbtt
operator|=
name|roundup
argument_list|(
name|nexttbtt
argument_list|,
name|intval
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: nexttbtt %u intval %u (%u)\n"
argument_list|,
name|__func__
argument_list|,
name|nexttbtt
argument_list|,
name|intval
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
operator|!
name|sc
operator|->
name|sc_swbmiss
condition|)
block|{
name|HAL_BEACON_STATE
name|bs
decl_stmt|;
name|int
name|dtimperiod
decl_stmt|,
name|dtimcount
decl_stmt|;
name|int
name|cfpperiod
decl_stmt|,
name|cfpcount
decl_stmt|;
comment|/* 		 * Setup dtim and cfp parameters according to 		 * last beacon we received (which may be none). 		 */
name|dtimperiod
operator|=
name|ni
operator|->
name|ni_dtim_period
expr_stmt|;
if|if
condition|(
name|dtimperiod
operator|<=
literal|0
condition|)
comment|/* NB: 0 if not known */
name|dtimperiod
operator|=
literal|1
expr_stmt|;
name|dtimcount
operator|=
name|ni
operator|->
name|ni_dtim_count
expr_stmt|;
if|if
condition|(
name|dtimcount
operator|>=
name|dtimperiod
condition|)
comment|/* NB: sanity check */
name|dtimcount
operator|=
literal|0
expr_stmt|;
comment|/* XXX? */
name|cfpperiod
operator|=
literal|1
expr_stmt|;
comment|/* NB: no PCF support yet */
name|cfpcount
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Pull nexttbtt forward to reflect the current 		 * TSF and calculate dtim+cfp state for the result. 		 */
name|tsf
operator|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|tsftu
operator|=
name|TSF_TO_TU
argument_list|(
name|tsf
operator|>>
literal|32
argument_list|,
name|tsf
argument_list|)
operator|+
name|FUDGE
expr_stmt|;
do|do
block|{
name|nexttbtt
operator|+=
name|intval
expr_stmt|;
if|if
condition|(
operator|--
name|dtimcount
operator|<
literal|0
condition|)
block|{
name|dtimcount
operator|=
name|dtimperiod
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|--
name|cfpcount
operator|<
literal|0
condition|)
name|cfpcount
operator|=
name|cfpperiod
operator|-
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|nexttbtt
operator|<
name|tsftu
condition|)
do|;
name|memset
argument_list|(
operator|&
name|bs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bs
argument_list|)
argument_list|)
expr_stmt|;
name|bs
operator|.
name|bs_intval
operator|=
name|intval
expr_stmt|;
name|bs
operator|.
name|bs_nexttbtt
operator|=
name|nexttbtt
expr_stmt|;
name|bs
operator|.
name|bs_dtimperiod
operator|=
name|dtimperiod
operator|*
name|intval
expr_stmt|;
name|bs
operator|.
name|bs_nextdtim
operator|=
name|bs
operator|.
name|bs_nexttbtt
operator|+
name|dtimcount
operator|*
name|intval
expr_stmt|;
name|bs
operator|.
name|bs_cfpperiod
operator|=
name|cfpperiod
operator|*
name|bs
operator|.
name|bs_dtimperiod
expr_stmt|;
name|bs
operator|.
name|bs_cfpnext
operator|=
name|bs
operator|.
name|bs_nextdtim
operator|+
name|cfpcount
operator|*
name|bs
operator|.
name|bs_dtimperiod
expr_stmt|;
name|bs
operator|.
name|bs_cfpmaxduration
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 		 * The 802.11 layer records the offset to the DTIM 		 * bitmap while receiving beacons; use it here to 		 * enable h/w detection of our AID being marked in 		 * the bitmap vector (to indicate frames for us are 		 * pending at the AP). 		 * XXX do DTIM handling in s/w to WAR old h/w bugs 		 * XXX enable based on h/w rev for newer chips 		 */
block|bs.bs_timoffset = ni->ni_timoff;
endif|#
directive|endif
comment|/* 		 * Calculate the number of consecutive beacons to miss 		 * before taking a BMISS interrupt. 		 * Note that we clamp the result to at most 10 beacons. 		 */
name|bs
operator|.
name|bs_bmissthreshold
operator|=
name|vap
operator|->
name|iv_bmissthreshold
expr_stmt|;
if|if
condition|(
name|bs
operator|.
name|bs_bmissthreshold
operator|>
literal|10
condition|)
name|bs
operator|.
name|bs_bmissthreshold
operator|=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|bs
operator|.
name|bs_bmissthreshold
operator|<=
literal|0
condition|)
name|bs
operator|.
name|bs_bmissthreshold
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Calculate sleep duration.  The configuration is 		 * given in ms.  We insure a multiple of the beacon 		 * period is used.  Also, if the sleep duration is 		 * greater than the DTIM period then it makes senses 		 * to make it a multiple of that. 		 * 		 * XXX fixed at 100ms 		 */
name|bs
operator|.
name|bs_sleepduration
operator|=
name|roundup
argument_list|(
name|IEEE80211_MS_TO_TU
argument_list|(
literal|100
argument_list|)
argument_list|,
name|bs
operator|.
name|bs_intval
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs
operator|.
name|bs_sleepduration
operator|>
name|bs
operator|.
name|bs_dtimperiod
condition|)
name|bs
operator|.
name|bs_sleepduration
operator|=
name|roundup
argument_list|(
name|bs
operator|.
name|bs_sleepduration
argument_list|,
name|bs
operator|.
name|bs_dtimperiod
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: tsf %ju tsf:tu %u intval %u nexttbtt %u dtim %u nextdtim %u bmiss %u sleep %u cfp:period %u maxdur %u next %u timoffset %u\n"
argument_list|,
name|__func__
argument_list|,
name|tsf
argument_list|,
name|tsftu
argument_list|,
name|bs
operator|.
name|bs_intval
argument_list|,
name|bs
operator|.
name|bs_nexttbtt
argument_list|,
name|bs
operator|.
name|bs_dtimperiod
argument_list|,
name|bs
operator|.
name|bs_nextdtim
argument_list|,
name|bs
operator|.
name|bs_bmissthreshold
argument_list|,
name|bs
operator|.
name|bs_sleepduration
argument_list|,
name|bs
operator|.
name|bs_cfpperiod
argument_list|,
name|bs
operator|.
name|bs_cfpmaxduration
argument_list|,
name|bs
operator|.
name|bs_cfpnext
argument_list|,
name|bs
operator|.
name|bs_timoffset
argument_list|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ath_hal_beacontimers
argument_list|(
name|ah
argument_list|,
operator|&
name|bs
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_BMISS
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nexttbtt
operator|==
name|intval
condition|)
name|intval
operator||=
name|HAL_BEACON_RESET_TSF
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
comment|/* 			 * In IBSS mode enable the beacon timers but only 			 * enable SWBA interrupts if we need to manually 			 * prepare beacon frames.  Otherwise we use a 			 * self-linked tx descriptor and let the hardware 			 * deal with things. 			 */
name|intval
operator||=
name|HAL_BEACON_ENA
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_hasveol
condition|)
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_SWBA
expr_stmt|;
if|if
condition|(
operator|(
name|intval
operator|&
name|HAL_BEACON_RESET_TSF
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Pull nexttbtt forward to reflect 				 * the current TSF. 				 */
name|tsf
operator|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|tsftu
operator|=
name|TSF_TO_TU
argument_list|(
name|tsf
operator|>>
literal|32
argument_list|,
name|tsf
argument_list|)
operator|+
name|FUDGE
expr_stmt|;
do|do
block|{
name|nexttbtt
operator|+=
name|intval
expr_stmt|;
block|}
do|while
condition|(
name|nexttbtt
operator|<
name|tsftu
condition|)
do|;
block|}
name|ath_beaconq_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
comment|/* 			 * In AP/mesh mode we enable the beacon timers 			 * and SWBA interrupts to prepare beacon frames. 			 */
name|intval
operator||=
name|HAL_BEACON_ENA
expr_stmt|;
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_SWBA
expr_stmt|;
comment|/* beacon prepare */
name|ath_beaconq_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|ath_hal_beaconinit
argument_list|(
name|ah
argument_list|,
name|nexttbtt
argument_list|,
name|intval
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bmisscount
operator|=
literal|0
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
comment|/* 		 * When using a self-linked beacon descriptor in 		 * ibss mode load it once here. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|&&
name|sc
operator|->
name|sc_hasveol
condition|)
name|ath_beacon_start_adhoc
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|0
expr_stmt|;
undef|#
directive|undef
name|FUDGE
undef|#
directive|undef
name|TSF_TO_TU
block|}
end_function

begin_function
specifier|static
name|void
name|ath_load_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|paddr
init|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
decl_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"error %u on bus_dma callback"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
operator|*
name|paddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_descdma_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_descdma
modifier|*
name|dd
parameter_list|,
name|ath_bufhead
modifier|*
name|head
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nbuf
parameter_list|,
name|int
name|ndesc
parameter_list|)
block|{
define|#
directive|define
name|DS2PHYS
parameter_list|(
name|_dd
parameter_list|,
name|_ds
parameter_list|)
define|\
value|((_dd)->dd_desc_paddr + ((caddr_t)(_ds) - (caddr_t)(_dd)->dd_desc))
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bsize
decl_stmt|,
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: %s DMA: %u buffers %u desc/buf\n"
argument_list|,
name|__func__
argument_list|,
name|name
argument_list|,
name|nbuf
argument_list|,
name|ndesc
argument_list|)
expr_stmt|;
name|dd
operator|->
name|dd_name
operator|=
name|name
expr_stmt|;
name|dd
operator|->
name|dd_desc_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ath_desc
argument_list|)
operator|*
name|nbuf
operator|*
name|ndesc
expr_stmt|;
comment|/* 	 * Setup DMA descriptor area. 	 */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
comment|/* parent */
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|dd
operator|->
name|dd_desc_len
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|dd
operator|->
name|dd_desc_len
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockarg */
operator|&
name|dd
operator|->
name|dd_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"cannot allocate %s DMA tag\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* allocate descriptors */
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to create dmamap for %s descriptors, "
literal|"error %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail0
goto|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dd
operator|->
name|dd_desc
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to alloc memory for %u %s descriptors, "
literal|"error %u\n"
argument_list|,
name|nbuf
operator|*
name|ndesc
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|,
name|dd
operator|->
name|dd_desc
argument_list|,
name|dd
operator|->
name|dd_desc_len
argument_list|,
name|ath_load_cb
argument_list|,
operator|&
name|dd
operator|->
name|dd_desc_paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to map %s descriptors, error %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|ds
operator|=
name|dd
operator|->
name|dd_desc
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: %s DMA map: %p (%lu) -> %p (%lu)\n"
argument_list|,
name|__func__
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|ds
argument_list|,
operator|(
name|u_long
operator|)
name|dd
operator|->
name|dd_desc_len
argument_list|,
operator|(
name|caddr_t
operator|)
name|dd
operator|->
name|dd_desc_paddr
argument_list|,
comment|/*XXX*/
operator|(
name|u_long
operator|)
name|dd
operator|->
name|dd_desc_len
argument_list|)
expr_stmt|;
comment|/* allocate rx buffers */
name|bsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ath_buf
argument_list|)
operator|*
name|nbuf
expr_stmt|;
name|bf
operator|=
name|malloc
argument_list|(
name|bsize
argument_list|,
name|M_ATHDEV
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"malloc of %s buffers failed, size %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
name|dd
operator|->
name|dd_bufptr
operator|=
name|bf
expr_stmt|;
name|STAILQ_INIT
argument_list|(
name|head
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
operator|,
name|bf
operator|++
operator|,
name|ds
operator|+=
name|ndesc
control|)
block|{
name|bf
operator|->
name|bf_desc
operator|=
name|ds
expr_stmt|;
name|bf
operator|->
name|bf_daddr
operator|=
name|DS2PHYS
argument_list|(
name|dd
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to create dmamap for %s "
literal|"buffer %u, error %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
name|dd
argument_list|,
name|head
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
name|head
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|fail3
label|:
name|bus_dmamap_unload
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|fail2
label|:
name|bus_dmamem_free
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_desc
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|fail1
label|:
name|bus_dmamap_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|fail0
label|:
name|bus_dma_tag_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
undef|#
directive|undef
name|DS2PHYS
block|}
end_function

begin_function
specifier|static
name|void
name|ath_descdma_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_descdma
modifier|*
name|dd
parameter_list|,
name|ath_bufhead
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_desc
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|head
argument_list|,
argument|bf_list
argument_list|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_m
condition|)
block|{
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_dmamap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_dmamap
operator|=
name|NULL
expr_stmt|;
block|}
name|ni
operator|=
name|bf
operator|->
name|bf_node
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Reclaim node reference. 			 */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
name|STAILQ_INIT
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dd
operator|->
name|dd_bufptr
argument_list|,
name|M_ATHDEV
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_desc_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ath_descdma_setup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
literal|"rx"
argument_list|,
name|ath_rxbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|error
operator|=
name|ath_descdma_setup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
literal|"tx"
argument_list|,
name|ath_txbuf
argument_list|,
name|ATH_TXDESC
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|ath_descdma_setup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_bdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|,
literal|"beacon"
argument_list|,
name|ATH_BCBUF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|)
expr_stmt|;
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_desc_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_bdma
operator|.
name|dd_desc_len
operator|!=
literal|0
condition|)
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_bdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_txdma
operator|.
name|dd_desc_len
operator|!=
literal|0
condition|)
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rxdma
operator|.
name|dd_desc_len
operator|!=
literal|0
condition|)
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|ath_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
specifier|const
name|size_t
name|space
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ath_node
argument_list|)
operator|+
name|sc
operator|->
name|sc_rc
operator|->
name|arc_space
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
name|an
operator|=
name|malloc
argument_list|(
name|space
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|an
operator|==
name|NULL
condition|)
block|{
comment|/* XXX stat+msg */
return|return
name|NULL
return|;
block|}
name|ath_rate_node_init
argument_list|(
name|sc
argument_list|,
name|an
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE
argument_list|,
literal|"%s: an %p\n"
argument_list|,
name|__func__
argument_list|,
name|an
argument_list|)
expr_stmt|;
return|return
operator|&
name|an
operator|->
name|an_node
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_node_free
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE
argument_list|,
literal|"%s: ni %p\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|ath_rate_node_cleanup
argument_list|(
name|sc
argument_list|,
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_node_free
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_node_getsignal
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int8_t
modifier|*
name|rssi
parameter_list|,
name|int8_t
modifier|*
name|noise
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
operator|*
name|rssi
operator|=
name|ic
operator|->
name|ic_node_getrssi
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_chan
operator|!=
name|IEEE80211_CHAN_ANYC
condition|)
operator|*
name|noise
operator|=
name|ath_hal_getchannoise
argument_list|(
name|ah
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
else|else
operator|*
name|noise
operator|=
operator|-
literal|95
expr_stmt|;
comment|/* nominally correct */
block|}
end_function

begin_function
specifier|static
name|int
name|ath_rxbuf_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * NB: by assigning a page to the rx dma buffer we 		 * implicitly satisfy the Atheros requirement that 		 * this buffer be cache-line-aligned and sized to be 		 * multiple of the cache line size.  Not doing this 		 * causes weird stuff to happen (for the 5210 at least). 		 */
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: no mbuf/cluster\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_nombuf
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: bus_dmamap_load_mbuf_sg failed; error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_busdma
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|KASSERT
argument_list|(
name|bf
operator|->
name|bf_nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"multi-segment packet; nseg %u"
operator|,
name|bf
operator|->
name|bf_nseg
operator|)
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|m
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* 	 * Setup descriptors.  For receive we always terminate 	 * the descriptor list with a self-linked entry so we'll 	 * not get overrun under high load (as can happen with a 	 * 5212 when ANI processing enables PHY error frames). 	 * 	 * To insure the last descriptor is self-linked we create 	 * each descriptor as self-linked and add it to the end.  As 	 * each additional descriptor is added the previous self-linked 	 * entry is ``fixed'' naturally.  This should be safe even 	 * if DMA is happening.  When processing RX interrupts we 	 * never remove/process the last, self-linked, entry on the 	 * descriptor list.  This insures the hardware always has 	 * someplace to write a new frame. 	 */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|ds
operator|->
name|ds_link
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
comment|/* link to self */
name|ds
operator|->
name|ds_data
operator|=
name|bf
operator|->
name|bf_segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|ath_hal_setuprxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|m
operator|->
name|m_len
comment|/* buffer size */
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rxlink
operator|!=
name|NULL
condition|)
operator|*
name|sc
operator|->
name|sc_rxlink
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
name|sc
operator|->
name|sc_rxlink
operator|=
operator|&
name|ds
operator|->
name|ds_link
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Extend 15-bit time stamp from rx descriptor to  * a full 64-bit TSF using the specified TSF.  */
end_comment

begin_function
specifier|static
name|__inline
name|u_int64_t
name|ath_extend_tsf
parameter_list|(
name|u_int32_t
name|rstamp
parameter_list|,
name|u_int64_t
name|tsf
parameter_list|)
block|{
if|if
condition|(
operator|(
name|tsf
operator|&
literal|0x7fff
operator|)
operator|<
name|rstamp
condition|)
name|tsf
operator|-=
literal|0x8000
expr_stmt|;
return|return
operator|(
operator|(
name|tsf
operator|&
operator|~
literal|0x7fff
operator|)
operator||
name|rstamp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Intercept management frames to collect beacon rssi data  * and to do ibss merges.  */
end_comment

begin_function
specifier|static
name|void
name|ath_recv_mgmt
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|subtype
parameter_list|,
name|int
name|rssi
parameter_list|,
name|int
name|nf
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
comment|/* 	 * Call up first so subsequent work can use information 	 * potentially stored in the node (e.g. for ibss merge). 	 */
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|av_recv_mgmt
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|subtype
argument_list|,
name|rssi
argument_list|,
name|nf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_BEACON
case|:
comment|/* update rssi statistics for use by the hal */
name|ATH_RSSI_LPF
argument_list|(
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgbrssi
argument_list|,
name|rssi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_syncbeacon
operator|&&
name|ni
operator|==
name|vap
operator|->
name|iv_bss
operator|&&
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* 			 * Resync beacon timers using the tsf of the beacon 			 * frame we just received. 			 */
name|ath_beacon_config
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
comment|/* fall thru... */
case|case
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
case|:
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
operator|&&
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
name|uint32_t
name|rstamp
init|=
name|sc
operator|->
name|sc_lastrs
operator|->
name|rs_tstamp
decl_stmt|;
name|u_int64_t
name|tsf
init|=
name|ath_extend_tsf
argument_list|(
name|rstamp
argument_list|,
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
argument_list|)
decl_stmt|;
comment|/* 			 * Handle ibss merge as needed; check the tsf on the 			 * frame before attempting the merge.  The 802.11 spec 			 * says the station should change it's bssid to match 			 * the oldest station with the same ssid, where oldest 			 * is determined by the tsf.  Note that hardware 			 * reconfiguration happens through callback to 			 * ath_newstate as the state machine will go from 			 * RUN -> RUN when this happens. 			 */
if|if
condition|(
name|le64toh
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|tsf
argument_list|)
operator|>=
name|tsf
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"ibss merge, rstamp %u tsf %ju "
literal|"tstamp %ju\n"
argument_list|,
name|rstamp
argument_list|,
operator|(
name|uintmax_t
operator|)
name|tsf
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ni
operator|->
name|ni_tstamp
operator|.
name|tsf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ieee80211_ibss_merge
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the default antenna.  */
end_comment

begin_function
specifier|static
name|void
name|ath_setdefantenna
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|antenna
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
comment|/* XXX block beacon interrupts */
name|ath_hal_setdefantenna
argument_list|(
name|ah
argument_list|,
name|antenna
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_defant
operator|!=
name|antenna
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_ant_defswitch
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_defant
operator|=
name|antenna
expr_stmt|;
name|sc
operator|->
name|sc_rxotherant
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_rx_tap
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ath_rx_status
modifier|*
name|rs
parameter_list|,
name|u_int64_t
name|tsf
parameter_list|,
name|int16_t
name|nf
parameter_list|)
block|{
define|#
directive|define
name|CHAN_HT20
value|htole32(IEEE80211_CHAN_HT20)
define|#
directive|define
name|CHAN_HT40U
value|htole32(IEEE80211_CHAN_HT40U)
define|#
directive|define
name|CHAN_HT40D
value|htole32(IEEE80211_CHAN_HT40D)
define|#
directive|define
name|CHAN_HT
value|(CHAN_HT20|CHAN_HT40U|CHAN_HT40D)
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|uint8_t
name|rix
decl_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no rate table, mode %u"
operator|,
name|sc
operator|->
name|sc_curmode
operator|)
argument_list|)
expr_stmt|;
name|rix
operator|=
name|rt
operator|->
name|rateCodeToIndex
index|[
name|rs
operator|->
name|rs_rate
index|]
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_rate
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_flags
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|rxflags
expr_stmt|;
ifdef|#
directive|ifdef
name|AH_SUPPORT_AR5416
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator|&=
operator|~
name|CHAN_HT
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_rate
operator|&
name|IEEE80211_RATE_MCS
condition|)
block|{
comment|/* HT rate */
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
if|if
condition|(
operator|(
name|rs
operator|->
name|rs_flags
operator|&
name|HAL_RX_2040
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator||=
name|CHAN_HT20
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator||=
name|CHAN_HT40U
expr_stmt|;
else|else
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator||=
name|CHAN_HT40D
expr_stmt|;
if|if
condition|(
operator|(
name|rs
operator|->
name|rs_flags
operator|&
name|HAL_RX_GI
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_flags
operator||=
name|IEEE80211_RADIOTAP_F_SHORTGI
expr_stmt|;
block|}
endif|#
directive|endif
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_tsf
operator|=
name|htole64
argument_list|(
name|ath_extend_tsf
argument_list|(
name|rs
operator|->
name|rs_tstamp
argument_list|,
name|tsf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_CRC
condition|)
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_flags
operator||=
name|IEEE80211_RADIOTAP_F_BADFCS
expr_stmt|;
comment|/* XXX propagate other error flags from descriptor */
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_antnoise
operator|=
name|nf
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_antsignal
operator|=
name|nf
operator|+
name|rs
operator|->
name|rs_rssi
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_antenna
operator|=
name|rs
operator|->
name|rs_antenna
expr_stmt|;
undef|#
directive|undef
name|CHAN_HT
undef|#
directive|undef
name|CHAN_HT20
undef|#
directive|undef
name|CHAN_HT40U
undef|#
directive|undef
name|CHAN_HT40D
block|}
end_function

begin_function
specifier|static
name|void
name|ath_handle_micerror
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
name|int
name|keyix
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
comment|/* XXX recheck MIC to deal w/ chips that lie */
comment|/* XXX discard MIC errors on !data frames */
name|ni
operator|=
name|ieee80211_find_rxnode
argument_list|(
name|ic
argument_list|,
operator|(
specifier|const
expr|struct
name|ieee80211_frame_min
operator|*
operator|)
name|wh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_notify_michael_failure
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|wh
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_rx_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
define|#
directive|define
name|PA2DESC
parameter_list|(
name|_sc
parameter_list|,
name|_pa
parameter_list|)
define|\
value|((struct ath_desc *)((caddr_t)(_sc)->sc_rxdma.dd_desc + \ 		((_pa) - (_sc)->sc_rxdma.dd_desc_paddr)))
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|struct
name|ath_rx_status
modifier|*
name|rs
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|len
decl_stmt|,
name|type
decl_stmt|,
name|ngood
decl_stmt|;
name|u_int
name|phyerr
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|int16_t
name|nf
decl_stmt|;
name|u_int64_t
name|tsf
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RX_PROC
argument_list|,
literal|"%s: pending %u\n"
argument_list|,
name|__func__
argument_list|,
name|npending
argument_list|)
expr_stmt|;
name|ngood
operator|=
literal|0
expr_stmt|;
name|nf
operator|=
name|ath_hal_getchannoise
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_noise
operator|=
name|nf
expr_stmt|;
name|tsf
operator|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
expr_stmt|;
do|do
block|{
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
comment|/* NB: shouldn't happen */
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: no buffer!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* NB: shouldn't happen */
comment|/* 			 * If mbuf allocation failed previously there 			 * will be no mbuf; try again to re-populate it. 			 */
comment|/* XXX make debug msg */
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: no mbuf!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
goto|goto
name|rx_next
goto|;
block|}
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_link
operator|==
name|bf
operator|->
name|bf_daddr
condition|)
block|{
comment|/* NB: never process the self-linked entry at the end */
break|break;
block|}
comment|/* XXX sync descriptor memory */
comment|/* 		 * Must provide the virtual address of the current 		 * descriptor, the physical address, and the virtual 		 * address of the next descriptor in the h/w chain. 		 * This allows the HAL to look ahead to see if the 		 * hardware is done with a descriptor by checking the 		 * done bit in the following descriptor and the address 		 * of the current descriptor the DMA engine is working 		 * on.  All this is necessary because of our use of 		 * a self-linked list to avoid rx overruns. 		 */
name|rs
operator|=
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_rxstat
expr_stmt|;
name|status
operator|=
name|ath_hal_rxprocdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|,
name|PA2DESC
argument_list|(
name|sc
argument_list|,
name|ds
operator|->
name|ds_link
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_RECV_DESC
condition|)
name|ath_printrxbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|,
name|status
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|==
name|HAL_EINPROGRESS
condition|)
break|break;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_CRC
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_crcerr
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_FIFO
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_fifoerr
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_PHY
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_phyerr
operator|++
expr_stmt|;
name|phyerr
operator|=
name|rs
operator|->
name|rs_phyerr
operator|&
literal|0x1f
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_phy
index|[
name|phyerr
index|]
operator|++
expr_stmt|;
goto|goto
name|rx_error
goto|;
comment|/* NB: don't count in ierrors */
block|}
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_DECRYPT
condition|)
block|{
comment|/* 				 * Decrypt error.  If the error occurred 				 * because there was no hardware key, then 				 * let the frame through so the upper layers 				 * can process it.  This is necessary for 5210 				 * parts which have no way to setup a ``clear'' 				 * key cache entry. 				 * 				 * XXX do key cache faulting 				 */
if|if
condition|(
name|rs
operator|->
name|rs_keyix
operator|==
name|HAL_RXKEYIX_INVALID
condition|)
goto|goto
name|rx_accept
goto|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_badcrypt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_MIC
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_badmic
operator|++
expr_stmt|;
comment|/* 				 * Do minimal work required to hand off 				 * the 802.11 header for notification. 				 */
comment|/* XXX frag's and qos frames */
name|len
operator|=
name|rs
operator|->
name|rs_datalen
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|ath_handle_micerror
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_splitmic
condition|?
name|rs
operator|->
name|rs_keyix
operator|-
literal|32
else|:
name|rs
operator|->
name|rs_keyix
argument_list|)
expr_stmt|;
block|}
block|}
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|rx_error
label|:
comment|/* 			 * Cleanup any pending partial frame. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_rxpending
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_rxpending
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxpending
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 			 * When a tap is present pass error frames 			 * that have been requested.  By default we 			 * pass decrypt+mic errors but others may be 			 * interesting (e.g. crc). 			 */
if|if
condition|(
name|ieee80211_radiotap_active
argument_list|(
name|ic
argument_list|)
operator|&&
operator|(
name|rs
operator|->
name|rs_status
operator|&
name|sc
operator|->
name|sc_monpass
operator|)
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* NB: bpf needs the mbuf length setup */
name|len
operator|=
name|rs
operator|->
name|rs_datalen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|ath_rx_tap
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|rs
argument_list|,
name|tsf
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|ieee80211_radiotap_rx_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* XXX pass MIC errors up for s/w reclaculation */
goto|goto
name|rx_next
goto|;
block|}
name|rx_accept
label|:
comment|/* 		 * Sync and unmap the frame.  At this point we're 		 * committed to passing the mbuf somewhere so clear 		 * bf_m; this means a new mbuf must be allocated 		 * when the rx descriptor is setup again to receive 		 * another frame. 		 */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
name|rs
operator|->
name|rs_datalen
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_more
condition|)
block|{
comment|/* 			 * Frame spans multiple descriptors; save 			 * it for the next completed descriptor, it 			 * will be used to construct a jumbogram. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_rxpending
operator|!=
name|NULL
condition|)
block|{
comment|/* NB: max frame size is currently 2 clusters */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_toobig
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_rxpending
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|sc
operator|->
name|sc_rxpending
operator|=
name|m
expr_stmt|;
goto|goto
name|rx_next
goto|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_rxpending
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * This is the second part of a jumbogram, 			 * chain it to the first mbuf, adjust the 			 * frame length, and clear the rxpending state. 			 */
name|sc
operator|->
name|sc_rxpending
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|sc
operator|->
name|sc_rxpending
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|len
expr_stmt|;
name|m
operator|=
name|sc
operator|->
name|sc_rxpending
expr_stmt|;
name|sc
operator|->
name|sc_rxpending
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Normal single-descriptor receive; setup 			 * the rcvif and packet length. 			 */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_ant_rx
index|[
name|rs
operator|->
name|rs_antenna
index|]
operator|++
expr_stmt|;
comment|/* 		 * Populate the rx status block.  When there are bpf 		 * listeners we do the additional work to provide 		 * complete status.  Otherwise we fill in only the 		 * material required by ieee80211_input.  Note that 		 * noise setting is filled in above. 		 */
if|if
condition|(
name|ieee80211_radiotap_active
argument_list|(
name|ic
argument_list|)
condition|)
name|ath_rx_tap
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|rs
argument_list|,
name|tsf
argument_list|,
name|nf
argument_list|)
expr_stmt|;
comment|/* 		 * From this point on we assume the frame is at least 		 * as large as ieee80211_frame_min; verify that. 		 */
if|if
condition|(
name|len
operator|<
name|IEEE80211_MIN_LEN
condition|)
block|{
if|if
condition|(
operator|!
name|ieee80211_radiotap_active
argument_list|(
name|ic
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RECV
argument_list|,
literal|"%s: short packet %d\n"
argument_list|,
name|__func__
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_tooshort
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* NB: in particular this captures ack's */
name|ieee80211_radiotap_rx_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|rx_next
goto|;
block|}
if|if
condition|(
name|IFF_DUMPPKTS
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RECV
argument_list|)
condition|)
block|{
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
init|=
name|sc
operator|->
name|sc_currates
decl_stmt|;
name|uint8_t
name|rix
init|=
name|rt
operator|->
name|rateCodeToIndex
index|[
name|rs
operator|->
name|rs_rate
index|]
decl_stmt|;
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
argument_list|,
name|rs
operator|->
name|rs_rssi
argument_list|)
expr_stmt|;
block|}
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|IEEE80211_CRC_LEN
argument_list|)
expr_stmt|;
comment|/* 		 * Locate the node for sender, track state, and then 		 * pass the (referenced) node up to the 802.11 layer 		 * for its use. 		 */
name|ni
operator|=
name|ieee80211_find_rxnode_withkey
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
expr|struct
name|ieee80211_frame_min
operator|*
argument_list|)
argument_list|,
name|rs
operator|->
name|rs_keyix
operator|==
name|HAL_RXKEYIX_INVALID
condition|?
name|IEEE80211_KEYIX_NONE
else|:
name|rs
operator|->
name|rs_keyix
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Sending station is known, dispatch directly. 			 */
name|sc
operator|->
name|sc_lastrs
operator|=
name|rs
expr_stmt|;
name|type
operator|=
name|ieee80211_input
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|rs
operator|->
name|rs_rssi
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* 			 * Arrange to update the last rx timestamp only for 			 * frames from our ap when operating in station mode. 			 * This assumes the rx key is always setup when 			 * associated. 			 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
name|rs
operator|->
name|rs_keyix
operator|!=
name|HAL_RXKEYIX_INVALID
condition|)
name|ngood
operator|++
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|ieee80211_input_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
name|rs
operator|->
name|rs_rssi
argument_list|,
name|nf
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Track rx rssi and do any rx antenna management. 		 */
name|ATH_RSSI_LPF
argument_list|(
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgrssi
argument_list|,
name|rs
operator|->
name|rs_rssi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_diversity
condition|)
block|{
comment|/* 			 * When using fast diversity, change the default rx 			 * antenna if diversity chooses the other antenna 3 			 * times in a row. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_defant
operator|!=
name|rs
operator|->
name|rs_antenna
condition|)
block|{
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_rxotherant
operator|>=
literal|3
condition|)
name|ath_setdefantenna
argument_list|(
name|sc
argument_list|,
name|rs
operator|->
name|rs_antenna
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_rxotherant
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
block|{
comment|/* 			 * Blink for any data frame.  Otherwise do a 			 * heartbeat-style blink when idle.  The latter 			 * is mainly for station mode where we depend on 			 * periodic beacon frames to trigger the poll event. 			 */
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_DATA
condition|)
block|{
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
init|=
name|sc
operator|->
name|sc_currates
decl_stmt|;
name|ath_led_event
argument_list|(
name|sc
argument_list|,
name|rt
operator|->
name|rateCodeToIndex
index|[
name|rs
operator|->
name|rs_rate
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ticks
operator|-
name|sc
operator|->
name|sc_ledevent
operator|>=
name|sc
operator|->
name|sc_ledidle
condition|)
name|ath_led_event
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|rx_next
label|:
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ath_rxbuf_init
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
operator|==
literal|0
condition|)
do|;
comment|/* rx signal state monitoring */
name|ath_hal_rxmonitor
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_halstats
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngood
condition|)
name|sc
operator|->
name|sc_lastrx
operator|=
name|tsf
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
name|ieee80211_ff_age_all
argument_list|(
name|ic
argument_list|,
literal|100
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|IFQ_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|ath_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|PA2DESC
block|}
end_function

begin_function
specifier|static
name|void
name|ath_txq_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|int
name|qnum
parameter_list|)
block|{
name|txq
operator|->
name|axq_qnum
operator|=
name|qnum
expr_stmt|;
name|txq
operator|->
name|axq_ac
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|axq_depth
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|axq_intrcnt
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|axq_link
operator|=
name|NULL
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|txq
operator|->
name|axq_q
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK_INIT
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup a h/w transmit queue.  */
end_comment

begin_function
specifier|static
name|struct
name|ath_txq
modifier|*
name|ath_txq_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qtype
parameter_list|,
name|int
name|subtype
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_TXQ_INFO
name|qi
decl_stmt|;
name|int
name|qnum
decl_stmt|;
name|memset
argument_list|(
operator|&
name|qi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|qi
argument_list|)
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_subtype
operator|=
name|subtype
expr_stmt|;
name|qi
operator|.
name|tqi_aifs
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmin
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmax
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
comment|/* 	 * Enable interrupts only for EOL and DESC conditions. 	 * We mark tx descriptors to receive a DESC interrupt 	 * when a tx queue gets deep; otherwise waiting for the 	 * EOL to reap descriptors.  Note that this is done to 	 * reduce interrupt load and this only defers reaping 	 * descriptors, never transmitting frames.  Aside from 	 * reducing interrupts this also permits more concurrency. 	 * The only potential downside is if the tx queue backs 	 * up in which case the top half of the kernel may backup 	 * due to a lack of tx descriptors. 	 */
name|qi
operator|.
name|tqi_qflags
operator|=
name|HAL_TXQ_TXEOLINT_ENABLE
operator||
name|HAL_TXQ_TXDESCINT_ENABLE
expr_stmt|;
name|qnum
operator|=
name|ath_hal_setuptxqueue
argument_list|(
name|ah
argument_list|,
name|qtype
argument_list|,
operator|&
name|qi
argument_list|)
expr_stmt|;
if|if
condition|(
name|qnum
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * NB: don't print a message, this happens 		 * normally on parts with too few tx queues 		 */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|qnum
operator|>=
name|N
argument_list|(
name|sc
operator|->
name|sc_txq
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"hal qnum %u out of range, max %zu!\n"
argument_list|,
name|qnum
argument_list|,
name|N
argument_list|(
name|sc
operator|->
name|sc_txq
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_releasetxqueue
argument_list|(
name|ah
argument_list|,
name|qnum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|qnum
argument_list|)
condition|)
block|{
name|ath_txq_init
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|qnum
index|]
argument_list|,
name|qnum
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txqsetup
operator||=
literal|1
operator|<<
name|qnum
expr_stmt|;
block|}
return|return
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|qnum
index|]
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Setup a hardware data transmit queue for the specified  * access control.  The hal may not support all requested  * queues in which case it will return a reference to a  * previously setup queue.  We record the mapping from ac's  * to h/w queues for use by ath_tx_start and also track  * the set of h/w queues being used to optimize work in the  * transmit interrupt handler and related routines.  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ac
parameter_list|,
name|int
name|haltype
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|struct
name|ath_txq
modifier|*
name|txq
decl_stmt|;
if|if
condition|(
name|ac
operator|>=
name|N
argument_list|(
name|sc
operator|->
name|sc_ac2q
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"AC %u out of range, max %zu!\n"
argument_list|,
name|ac
argument_list|,
name|N
argument_list|(
name|sc
operator|->
name|sc_ac2q
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|txq
operator|=
name|ath_txq_setup
argument_list|(
name|sc
argument_list|,
name|HAL_TX_QUEUE_DATA
argument_list|,
name|haltype
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|!=
name|NULL
condition|)
block|{
name|txq
operator|->
name|axq_ac
operator|=
name|ac
expr_stmt|;
name|sc
operator|->
name|sc_ac2q
index|[
name|ac
index|]
operator|=
name|txq
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Update WME parameters for a transmit queue.  */
end_comment

begin_function
specifier|static
name|int
name|ath_txq_update
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ac
parameter_list|)
block|{
define|#
directive|define
name|ATH_EXPONENT_TO_VALUE
parameter_list|(
name|v
parameter_list|)
value|((1<<v)-1)
define|#
directive|define
name|ATH_TXOP_TO_US
parameter_list|(
name|v
parameter_list|)
value|(v<<5)
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
init|=
name|sc
operator|->
name|sc_ac2q
index|[
name|ac
index|]
decl_stmt|;
name|struct
name|wmeParams
modifier|*
name|wmep
init|=
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|ac
index|]
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_TXQ_INFO
name|qi
decl_stmt|;
name|ath_hal_gettxqueueprops
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|&
name|qi
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|sc
operator|->
name|sc_tdma
condition|)
block|{
comment|/* 		 * AIFS is zero so there's no pre-transmit wait.  The 		 * burst time defines the slot duration and is configured 		 * through net80211.  The QCU is setup to not do post-xmit 		 * back off, lockout all lower-priority QCU's, and fire 		 * off the DMA beacon alert timer which is setup based 		 * on the slot configuration. 		 */
name|qi
operator|.
name|tqi_qflags
operator|=
name|HAL_TXQ_TXOKINT_ENABLE
operator||
name|HAL_TXQ_TXERRINT_ENABLE
operator||
name|HAL_TXQ_TXURNINT_ENABLE
operator||
name|HAL_TXQ_TXEOLINT_ENABLE
operator||
name|HAL_TXQ_DBA_GATED
operator||
name|HAL_TXQ_BACKOFF_DISABLE
operator||
name|HAL_TXQ_ARB_LOCKOUT_GLOBAL
expr_stmt|;
name|qi
operator|.
name|tqi_aifs
operator|=
literal|0
expr_stmt|;
comment|/* XXX +dbaprep? */
name|qi
operator|.
name|tqi_readyTime
operator|=
name|sc
operator|->
name|sc_tdmaslotlen
expr_stmt|;
name|qi
operator|.
name|tqi_burstTime
operator|=
name|qi
operator|.
name|tqi_readyTime
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|qi
operator|.
name|tqi_qflags
operator|=
name|HAL_TXQ_TXOKINT_ENABLE
operator||
name|HAL_TXQ_TXERRINT_ENABLE
operator||
name|HAL_TXQ_TXDESCINT_ENABLE
operator||
name|HAL_TXQ_TXURNINT_ENABLE
expr_stmt|;
name|qi
operator|.
name|tqi_aifs
operator|=
name|wmep
operator|->
name|wmep_aifsn
expr_stmt|;
name|qi
operator|.
name|tqi_cwmin
operator|=
name|ATH_EXPONENT_TO_VALUE
argument_list|(
name|wmep
operator|->
name|wmep_logcwmin
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_cwmax
operator|=
name|ATH_EXPONENT_TO_VALUE
argument_list|(
name|wmep
operator|->
name|wmep_logcwmax
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_readyTime
operator|=
literal|0
expr_stmt|;
name|qi
operator|.
name|tqi_burstTime
operator|=
name|ATH_TXOP_TO_US
argument_list|(
name|wmep
operator|->
name|wmep_txopLimit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
block|}
endif|#
directive|endif
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: Q%u qflags 0x%x aifs %u cwmin %u cwmax %u burstTime %u\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|qi
operator|.
name|tqi_qflags
argument_list|,
name|qi
operator|.
name|tqi_aifs
argument_list|,
name|qi
operator|.
name|tqi_cwmin
argument_list|,
name|qi
operator|.
name|tqi_cwmax
argument_list|,
name|qi
operator|.
name|tqi_burstTime
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_settxqueueprops
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|&
name|qi
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to update hardware queue "
literal|"parameters for %s traffic!\n"
argument_list|,
name|ieee80211_wme_acnames
index|[
name|ac
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|ath_hal_resettxqueue
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
comment|/* push to h/w */
return|return
literal|1
return|;
block|}
undef|#
directive|undef
name|ATH_TXOP_TO_US
undef|#
directive|undef
name|ATH_EXPONENT_TO_VALUE
block|}
end_function

begin_comment
comment|/*  * Callback from the 802.11 layer to update WME parameters.  */
end_comment

begin_function
specifier|static
name|int
name|ath_wme_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
return|return
operator|!
name|ath_txq_update
argument_list|(
name|sc
argument_list|,
name|WME_AC_BE
argument_list|)
operator|||
operator|!
name|ath_txq_update
argument_list|(
name|sc
argument_list|,
name|WME_AC_BK
argument_list|)
operator|||
operator|!
name|ath_txq_update
argument_list|(
name|sc
argument_list|,
name|WME_AC_VI
argument_list|)
operator|||
operator|!
name|ath_txq_update
argument_list|(
name|sc
argument_list|,
name|WME_AC_VO
argument_list|)
condition|?
name|EIO
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Reclaim resources for a setup queue.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_cleanupq
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
name|ath_hal_releasetxqueue
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK_DESTROY
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txqsetup
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|txq
operator|->
name|axq_qnum
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim all tx queue resources.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ATH_TXBUF_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
condition|)
name|ath_tx_cleanupq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return h/w rate index for an IEEE rate (w/o basic rate bit)  * using the current rates in sc_rixmap.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|ath_tx_findrix
parameter_list|(
specifier|const
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|rate
parameter_list|)
block|{
name|int
name|rix
init|=
name|sc
operator|->
name|sc_rixmap
index|[
name|rate
index|]
decl_stmt|;
comment|/* NB: return lowest rix for invalid rate */
return|return
operator|(
name|rix
operator|==
literal|0xff
condition|?
literal|0
else|:
name|rix
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reclaim mbuf resources.  For fragmented frames we  * need to claim each frag chained with m_nextpkt.  */
end_comment

begin_function
specifier|static
name|void
name|ath_freetx
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
do|do
block|{
name|next
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|m
operator|=
name|next
operator|)
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_tx_dmasetup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Load the DMA map so any coalescing is done.  This 	 * also calculates the number of descriptors we need. 	 */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m0
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
comment|/* XXX packet requires too many descriptors */
name|bf
operator|->
name|bf_nseg
operator|=
name|ATH_TXDESC
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_busdma
operator|++
expr_stmt|;
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Discard null packets and check for packets that 	 * require too many TX descriptors.  We try to convert 	 * the latter to a cluster. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_nseg
operator|>
name|ATH_TXDESC
condition|)
block|{
comment|/* too many desc's, linearize */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_linear
operator|++
expr_stmt|;
name|m
operator|=
name|m_collapse
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|ATH_TXDESC
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nombuf
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|m0
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m0
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_busdma
operator|++
expr_stmt|;
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|KASSERT
argument_list|(
name|bf
operator|->
name|bf_nseg
operator|<=
name|ATH_TXDESC
argument_list|,
operator|(
literal|"too many segments after defrag; nseg %u"
operator|,
name|bf
operator|->
name|bf_nseg
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bf
operator|->
name|bf_nseg
operator|==
literal|0
condition|)
block|{
comment|/* null packet, discard */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nodata
operator|++
expr_stmt|;
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: m %p len %u\n"
argument_list|,
name|__func__
argument_list|,
name|m0
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|m0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tx_handoff
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|,
modifier|*
name|ds0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Fillin the remainder of the descriptor info. 	 */
name|ds0
operator|=
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bf
operator|->
name|bf_nseg
condition|;
name|i
operator|++
operator|,
name|ds
operator|++
control|)
block|{
name|ds
operator|->
name|ds_data
operator|=
name|bf
operator|->
name|bf_segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
condition|)
name|ds
operator|->
name|ds_link
operator|=
literal|0
expr_stmt|;
else|else
name|ds
operator|->
name|ds_link
operator|=
name|bf
operator|->
name|bf_daddr
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ds
argument_list|)
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|ath_hal_filltxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|bf
operator|->
name|bf_segs
index|[
name|i
index|]
operator|.
name|ds_len
comment|/* segment length */
argument_list|,
name|i
operator|==
literal|0
comment|/* first segment */
argument_list|,
name|i
operator|==
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
comment|/* last segment */
argument_list|,
name|ds0
comment|/* first descriptor */
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: %d: %08x %08x %08x %08x %08x %08x\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|ds
operator|->
name|ds_link
argument_list|,
name|ds
operator|->
name|ds_data
argument_list|,
name|ds
operator|->
name|ds_ctl0
argument_list|,
name|ds
operator|->
name|ds_ctl1
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|0
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Insert the frame on the outbound list and pass it on 	 * to the hardware.  Multicast frames buffered for power 	 * save stations and transmit from the CAB queue are stored 	 * on a s/w only queue and loaded on to the CAB queue in 	 * the SWBA handler since frames only go out on DTIM and 	 * to avoid possible races. 	 */
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_BUSY
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"busy status 0x%x"
operator|,
name|bf
operator|->
name|bf_flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|axq_qnum
operator|!=
name|ATH_TXQ_SWQ
condition|)
block|{
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
name|int
name|qbusy
decl_stmt|;
name|ATH_TXQ_INSERT_TAIL
argument_list|(
name|txq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|qbusy
operator|=
name|ath_hal_txqenabled
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|axq_link
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Be careful writing the address to TXDP.  If 			 * the tx q is enabled then this write will be 			 * ignored.  Normally this is not an issue but 			 * when tdma is in use and the q is beacon gated 			 * this race can occur.  If the q is busy then 			 * defer the work to later--either when another 			 * packet comes along or when we prepare a beacon 			 * frame at SWBA. 			 */
if|if
condition|(
operator|!
name|qbusy
condition|)
block|{
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|txq
operator|->
name|axq_flags
operator|&=
operator|~
name|ATH_TXQ_PUTPENDING
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: TXDP[%u] = %p (%p) depth %d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|(
name|caddr_t
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|txq
operator|->
name|axq_flags
operator||=
name|ATH_TXQ_PUTPENDING
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_TDMA
operator||
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: Q%u busy, defer enable\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|txq
operator|->
name|axq_link
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: link[%u](%p)=%p (%p) depth %d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|txq
operator|->
name|axq_link
argument_list|,
operator|(
name|caddr_t
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|txq
operator|->
name|axq_flags
operator|&
name|ATH_TXQ_PUTPENDING
operator|)
operator|&&
operator|!
name|qbusy
condition|)
block|{
comment|/* 				 * The q was busy when we previously tried 				 * to write the address of the first buffer 				 * in the chain.  Since it's not busy now 				 * handle this chore.  We are certain the 				 * buffer at the front is the right one since 				 * axq_link is NULL only when the buffer list 				 * is/was empty. 				 */
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|STAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|axq_q
argument_list|)
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|txq
operator|->
name|axq_flags
operator|&=
operator|~
name|ATH_TXQ_PUTPENDING
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_TDMA
operator||
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: Q%u restarted\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
name|ATH_TXQ_INSERT_TAIL
argument_list|(
name|txq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|axq_link
operator|==
name|NULL
condition|)
block|{
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: TXDP[%u] = %p (%p) depth %d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|(
name|caddr_t
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|txq
operator|->
name|axq_link
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: link[%u](%p)=%p (%p) depth %d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|txq
operator|->
name|axq_link
argument_list|,
operator|(
name|caddr_t
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IEEE80211_SUPPORT_TDMA */
name|txq
operator|->
name|axq_link
operator|=
operator|&
name|bf
operator|->
name|bf_desc
index|[
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
index|]
operator|.
name|ds_link
expr_stmt|;
name|ath_hal_txstart
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|txq
operator|->
name|axq_link
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|last
init|=
name|ATH_TXQ_LAST
argument_list|(
name|txq
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
comment|/* mark previous frame */
name|wh
operator|=
name|mtod
argument_list|(
name|last
operator|->
name|bf_m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_MORE_DATA
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|last
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* link descriptor */
operator|*
name|txq
operator|->
name|axq_link
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
block|}
name|ATH_TXQ_INSERT_TAIL
argument_list|(
name|txq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|txq
operator|->
name|axq_link
operator|=
operator|&
name|bf
operator|->
name|bf_desc
index|[
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
index|]
operator|.
name|ds_link
expr_stmt|;
block|}
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_tx_start
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
specifier|const
name|struct
name|chanAccParams
modifier|*
name|cap
init|=
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
decl_stmt|;
name|int
name|error
decl_stmt|,
name|iswep
decl_stmt|,
name|ismcast
decl_stmt|,
name|isfrag
decl_stmt|,
name|ismrr
decl_stmt|;
name|int
name|keyix
decl_stmt|,
name|hdrlen
decl_stmt|,
name|pktlen
decl_stmt|,
name|try0
decl_stmt|;
name|u_int8_t
name|rix
decl_stmt|,
name|txrate
decl_stmt|,
name|ctsrate
decl_stmt|;
name|u_int8_t
name|cix
init|=
literal|0xff
decl_stmt|;
comment|/* NB: silence compiler */
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|u_int
name|subtype
decl_stmt|,
name|flags
decl_stmt|,
name|ctsduration
decl_stmt|;
name|HAL_PKT_TYPE
name|atype
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|HAL_BOOL
name|shortPreamble
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
name|u_int
name|pri
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|iswep
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_WEP
expr_stmt|;
name|ismcast
operator|=
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
name|isfrag
operator|=
name|m0
operator|->
name|m_flags
operator|&
name|M_FRAG
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
comment|/* 	 * Packet length must not include any 	 * pad bytes; deduct them here. 	 */
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|hdrlen
operator|&
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|iswep
condition|)
block|{
specifier|const
name|struct
name|ieee80211_cipher
modifier|*
name|cip
decl_stmt|;
name|struct
name|ieee80211_key
modifier|*
name|k
decl_stmt|;
comment|/* 		 * Construct the 802.11 header+trailer for an encrypted 		 * frame. The only reason this can fail is because of an 		 * unknown or unsupported cipher/key type. 		 */
name|k
operator|=
name|ieee80211_crypto_encap
argument_list|(
name|ni
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * This can happen when the key is yanked after the 			 * frame was queued.  Just discard the frame; the 			 * 802.11 layer counts failures and provides 			 * debugging/diagnostics. 			 */
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* 		 * Adjust the packet + header lengths for the crypto 		 * additions and calculate the h/w key index.  When 		 * a s/w mic is done the frame will have had any mic 		 * added to it prior to entry so m0->m_pkthdr.len will 		 * account for it. Otherwise we need to add it to the 		 * packet length. 		 */
name|cip
operator|=
name|k
operator|->
name|wk_cipher
expr_stmt|;
name|hdrlen
operator|+=
name|cip
operator|->
name|ic_header
expr_stmt|;
name|pktlen
operator|+=
name|cip
operator|->
name|ic_header
operator|+
name|cip
operator|->
name|ic_trailer
expr_stmt|;
comment|/* NB: frags always have any TKIP MIC done in s/w */
if|if
condition|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWMIC
operator|)
operator|==
literal|0
operator|&&
operator|!
name|isfrag
condition|)
name|pktlen
operator|+=
name|cip
operator|->
name|ic_miclen
expr_stmt|;
name|keyix
operator|=
name|k
operator|->
name|wk_keyix
expr_stmt|;
comment|/* packet header may have moved, reset our local pointer */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_cipher
operator|==
operator|&
name|ieee80211_cipher_none
condition|)
block|{
comment|/* 		 * Use station key cache slot, if assigned. 		 */
name|keyix
operator|=
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_keyix
expr_stmt|;
if|if
condition|(
name|keyix
operator|==
name|IEEE80211_KEYIX_NONE
condition|)
name|keyix
operator|=
name|HAL_TXKEYIX_INVALID
expr_stmt|;
block|}
else|else
name|keyix
operator|=
name|HAL_TXKEYIX_INVALID
expr_stmt|;
name|pktlen
operator|+=
name|IEEE80211_CRC_LEN
expr_stmt|;
comment|/* 	 * Load the DMA map so any coalescing is done.  This 	 * also calculates the number of descriptors we need. 	 */
name|error
operator|=
name|ath_tx_dmasetup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|bf
operator|->
name|bf_node
operator|=
name|ni
expr_stmt|;
comment|/* NB: held reference */
name|m0
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
comment|/* NB: may have changed */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
comment|/* setup descriptors */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no rate table, mode %u"
operator|,
name|sc
operator|->
name|sc_curmode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * NB: the 802.11 layer marks whether or not we should 	 * use short preamble based on the current mode and 	 * negotiated parameters. 	 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
operator|)
operator|&&
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_SHORT_PREAMBLE
operator|)
condition|)
block|{
name|shortPreamble
operator|=
name|AH_TRUE
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_shortpre
operator|++
expr_stmt|;
block|}
else|else
block|{
name|shortPreamble
operator|=
name|AH_FALSE
expr_stmt|;
block|}
name|an
operator|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|flags
operator|=
name|HAL_TXDESC_CLRDMASK
expr_stmt|;
comment|/* XXX needed for crypto errs */
name|ismrr
operator|=
literal|0
expr_stmt|;
comment|/* default no multi-rate retry*/
name|pri
operator|=
name|M_WME_GETAC
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* honor classification */
comment|/* XXX use txparams instead of fixed values */
comment|/* 	 * Calculate Atheros packet type from IEEE80211 packet header, 	 * setup for rate calculations, and select h/w transmit queue. 	 */
switch|switch
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_TYPE_MGT
case|:
name|subtype
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_BEACON
condition|)
name|atype
operator|=
name|HAL_PKT_TYPE_BEACON
expr_stmt|;
elseif|else
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
condition|)
name|atype
operator|=
name|HAL_PKT_TYPE_PROBE_RESP
expr_stmt|;
elseif|else
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_ATIM
condition|)
name|atype
operator|=
name|HAL_PKT_TYPE_ATIM
expr_stmt|;
else|else
name|atype
operator|=
name|HAL_PKT_TYPE_NORMAL
expr_stmt|;
comment|/* XXX */
name|rix
operator|=
name|an
operator|->
name|an_mgmtrix
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|try0
operator|=
name|ATH_TXMGTTRY
expr_stmt|;
name|flags
operator||=
name|HAL_TXDESC_INTREQ
expr_stmt|;
comment|/* force interrupt */
break|break;
case|case
name|IEEE80211_FC0_TYPE_CTL
case|:
name|atype
operator|=
name|HAL_PKT_TYPE_PSPOLL
expr_stmt|;
comment|/* stop setting of duration */
name|rix
operator|=
name|an
operator|->
name|an_mgmtrix
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|try0
operator|=
name|ATH_TXMGTTRY
expr_stmt|;
name|flags
operator||=
name|HAL_TXDESC_INTREQ
expr_stmt|;
comment|/* force interrupt */
break|break;
case|case
name|IEEE80211_FC0_TYPE_DATA
case|:
name|atype
operator|=
name|HAL_PKT_TYPE_NORMAL
expr_stmt|;
comment|/* default */
comment|/* 		 * Data frames: multicast frames go out at a fixed rate, 		 * EAPOL frames use the mgmt frame rate; otherwise consult 		 * the rate control module for the rate to use. 		 */
if|if
condition|(
name|ismcast
condition|)
block|{
name|rix
operator|=
name|an
operator|->
name|an_mcastrix
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|try0
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_EAPOL
condition|)
block|{
comment|/* XXX? maybe always use long preamble? */
name|rix
operator|=
name|an
operator|->
name|an_mgmtrix
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|try0
operator|=
name|ATH_TXMAXTRY
expr_stmt|;
comment|/* XXX?too many? */
block|}
else|else
block|{
name|ath_rate_findrate
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|shortPreamble
argument_list|,
name|pktlen
argument_list|,
operator|&
name|rix
argument_list|,
operator|&
name|try0
argument_list|,
operator|&
name|txrate
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txrix
operator|=
name|rix
expr_stmt|;
comment|/* for LED blinking */
name|sc
operator|->
name|sc_lastdatarix
operator|=
name|rix
expr_stmt|;
comment|/* for fast frames */
if|if
condition|(
name|try0
operator|!=
name|ATH_TXMAXTRY
condition|)
name|ismrr
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cap
operator|->
name|cap_wmeParams
index|[
name|pri
index|]
operator|.
name|wmep_noackPolicy
condition|)
name|flags
operator||=
name|HAL_TXDESC_NOACK
expr_stmt|;
break|break;
default|default:
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"bogus frame type 0x%x (%s)\n"
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX statistic */
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|txq
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|pri
index|]
expr_stmt|;
comment|/* 	 * When servicing one or more stations in power-save mode 	 * (or) if there is some mcast data waiting on the mcast 	 * queue (to prevent out of order delivery) multicast 	 * frames must be buffered until after the beacon. 	 */
if|if
condition|(
name|ismcast
operator|&&
operator|(
name|vap
operator|->
name|iv_ps_sta
operator|||
name|avp
operator|->
name|av_mcastq
operator|.
name|axq_depth
operator|)
condition|)
name|txq
operator|=
operator|&
name|avp
operator|->
name|av_mcastq
expr_stmt|;
comment|/* 	 * Calculate miscellaneous flags. 	 */
if|if
condition|(
name|ismcast
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_NOACK
expr_stmt|;
comment|/* no ack on broad/multicast */
block|}
elseif|else
if|if
condition|(
name|pktlen
operator|>
name|vap
operator|->
name|iv_rtsthreshold
operator|&&
operator|(
name|ni
operator|->
name|ni_ath_flags
operator|&
name|IEEE80211_NODE_FF
operator|)
operator|==
literal|0
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_RTSENA
expr_stmt|;
comment|/* RTS based on frame length */
name|cix
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|controlRate
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_rts
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
condition|)
comment|/* NB: avoid double counting */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_noack
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|sc
operator|->
name|sc_tdma
operator|&&
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_TDMA
argument_list|,
literal|"%s: discard frame, ACK required w/ TDMA\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tdma_ack
operator|++
expr_stmt|;
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
endif|#
directive|endif
comment|/* 	 * If 802.11g protection is enabled, determine whether 	 * to use RTS/CTS or just CTS.  Note that this is only 	 * done for OFDM unicast frames. 	 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEPROT
operator|)
operator|&&
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|phy
operator|==
name|IEEE80211_T_OFDM
operator|&&
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* XXX fragments must use CCK rates w/ protection */
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|==
name|IEEE80211_PROT_RTSCTS
condition|)
name|flags
operator||=
name|HAL_TXDESC_RTSENA
expr_stmt|;
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|==
name|IEEE80211_PROT_CTSONLY
condition|)
name|flags
operator||=
name|HAL_TXDESC_CTSENA
expr_stmt|;
if|if
condition|(
name|isfrag
condition|)
block|{
comment|/* 			 * For frags it would be desirable to use the 			 * highest CCK rate for RTS/CTS.  But stations 			 * farther away may detect it at a lower CCK rate 			 * so use the configured protection rate instead 			 * (for now). 			 */
name|cix
operator|=
name|rt
operator|->
name|info
index|[
name|sc
operator|->
name|sc_protrix
index|]
operator|.
name|controlRate
expr_stmt|;
block|}
else|else
name|cix
operator|=
name|rt
operator|->
name|info
index|[
name|sc
operator|->
name|sc_protrix
index|]
operator|.
name|controlRate
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_protect
operator|++
expr_stmt|;
block|}
comment|/* 	 * Calculate duration.  This logically belongs in the 802.11 	 * layer but it lacks sufficient information to calculate it. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
operator|&&
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
operator|)
operator|!=
name|IEEE80211_FC0_TYPE_CTL
condition|)
block|{
name|u_int16_t
name|dur
decl_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|dur
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|spAckDuration
expr_stmt|;
else|else
name|dur
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|lpAckDuration
expr_stmt|;
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_MORE_FRAG
condition|)
block|{
name|dur
operator|+=
name|dur
expr_stmt|;
comment|/* additional SIFS+ACK */
name|KASSERT
argument_list|(
name|m0
operator|->
name|m_nextpkt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no fragment"
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Include the size of next fragment so NAV is 			 * updated properly.  The last fragment uses only 			 * the ACK duration 			 */
name|dur
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|m0
operator|->
name|m_nextpkt
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|rix
argument_list|,
name|shortPreamble
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isfrag
condition|)
block|{
comment|/* 			 * Force hardware to use computed duration for next 			 * fragment by disabling multi-rate retry which updates 			 * duration based on the multi-rate duration table. 			 */
name|ismrr
operator|=
literal|0
expr_stmt|;
name|try0
operator|=
name|ATH_TXMGTTRY
expr_stmt|;
comment|/* XXX? */
block|}
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|wh
operator|->
name|i_dur
operator|=
name|htole16
argument_list|(
name|dur
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Calculate RTS/CTS rate and duration if needed. 	 */
name|ctsduration
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|HAL_TXDESC_RTSENA
operator||
name|HAL_TXDESC_CTSENA
operator|)
condition|)
block|{
comment|/* 		 * CTS transmit rate is derived from the transmit rate 		 * by looking in the h/w rate table.  We must also factor 		 * in whether or not a short preamble is to be used. 		 */
comment|/* NB: cix is set above where RTS/CTS is enabled */
name|KASSERT
argument_list|(
name|cix
operator|!=
literal|0xff
argument_list|,
operator|(
literal|"cix not setup"
operator|)
argument_list|)
expr_stmt|;
name|ctsrate
operator|=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|rateCode
expr_stmt|;
comment|/* 		 * Compute the transmit duration based on the frame 		 * size and the size of an ACK frame.  We call into the 		 * HAL to do the computation since it depends on the 		 * characteristics of the actual PHY being used. 		 * 		 * NB: CTS is assumed the same size as an ACK so we can 		 *     use the precalculated ACK durations. 		 */
if|if
condition|(
name|shortPreamble
condition|)
block|{
name|ctsrate
operator||=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|shortPreamble
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_RTSENA
condition|)
comment|/* SIFS + CTS */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|spAckDuration
expr_stmt|;
name|ctsduration
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|pktlen
argument_list|,
name|rix
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
comment|/* SIFS + ACK */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|spAckDuration
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_RTSENA
condition|)
comment|/* SIFS + CTS */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|lpAckDuration
expr_stmt|;
name|ctsduration
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|pktlen
argument_list|,
name|rix
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
comment|/* SIFS + ACK */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|lpAckDuration
expr_stmt|;
block|}
comment|/* 		 * Must disable multi-rate retry when using RTS/CTS. 		 */
name|ismrr
operator|=
literal|0
expr_stmt|;
name|try0
operator|=
name|ATH_TXMGTTRY
expr_stmt|;
comment|/* XXX */
block|}
else|else
name|ctsrate
operator|=
literal|0
expr_stmt|;
comment|/* 	 * At this point we are committed to sending the frame 	 * and we don't need to look at m_nextpkt; clear it in 	 * case this frame is part of frag chain. 	 */
name|m0
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|IFF_DUMPPKTS
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|)
condition|)
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
specifier|const
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|m0
operator|->
name|m_len
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|u_int64_t
name|tsf
init|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_tsf
operator|=
name|htole64
argument_list|(
name|tsf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|txflags
expr_stmt|;
if|if
condition|(
name|iswep
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
if|if
condition|(
name|isfrag
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_FRAG
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_rate
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_txpower
operator|=
name|ni
operator|->
name|ni_txpower
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_antenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Determine if a tx interrupt should be generated for 	 * this descriptor.  We take a tx interrupt to reap 	 * descriptors when the h/w hits an EOL condition or 	 * when the descriptor is specifically marked to generate 	 * an interrupt.  We periodically mark descriptors in this 	 * way to insure timely replenishing of the supply needed 	 * for sending frames.  Defering interrupts reduces system 	 * load and potentially allows more concurrent work to be 	 * done but if done to aggressively can cause senders to 	 * backup. 	 * 	 * NB: use>= to deal with sc_txintrperiod changing 	 *     dynamically through sysctl. 	 */
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_INTREQ
condition|)
block|{
name|txq
operator|->
name|axq_intrcnt
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|txq
operator|->
name|axq_intrcnt
operator|>=
name|sc
operator|->
name|sc_txintrperiod
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_INTREQ
expr_stmt|;
name|txq
operator|->
name|axq_intrcnt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Formulate first tx descriptor with tx controls. 	 */
comment|/* XXX check return value? */
name|ath_hal_setuptxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|pktlen
comment|/* packet length */
argument_list|,
name|hdrlen
comment|/* header length */
argument_list|,
name|atype
comment|/* Atheros packet type */
argument_list|,
name|ni
operator|->
name|ni_txpower
comment|/* txpower */
argument_list|,
name|txrate
argument_list|,
name|try0
comment|/* series 0 rate/tries */
argument_list|,
name|keyix
comment|/* key cache index */
argument_list|,
name|sc
operator|->
name|sc_txantenna
comment|/* antenna mode */
argument_list|,
name|flags
comment|/* flags */
argument_list|,
name|ctsrate
comment|/* rts/cts rate */
argument_list|,
name|ctsduration
comment|/* rts/cts duration */
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_txflags
operator|=
name|flags
expr_stmt|;
comment|/* 	 * Setup the multi-rate retry state only when we're 	 * going to use it.  This assumes ath_hal_setuptxdesc 	 * initializes the descriptors (so we don't have to) 	 * when the hardware supports multi-rate retry and 	 * we don't use it. 	 */
if|if
condition|(
name|ismrr
condition|)
name|ath_rate_setupxtxdesc
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|ds
argument_list|,
name|shortPreamble
argument_list|,
name|rix
argument_list|)
expr_stmt|;
name|ath_tx_handoff
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Process completed xmit descriptors from the specified queue.  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_processq
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|,
modifier|*
name|ds0
decl_stmt|;
name|struct
name|ath_tx_status
modifier|*
name|ts
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
name|int
name|sr
decl_stmt|,
name|lr
decl_stmt|,
name|pri
decl_stmt|,
name|nacked
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_TX_PROC
argument_list|,
literal|"%s: tx queue %u head %p link %p\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ath_hal_gettxbuf
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
argument_list|,
name|txq
operator|->
name|axq_link
argument_list|)
expr_stmt|;
name|nacked
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|txq
operator|->
name|axq_intrcnt
operator|=
literal|0
expr_stmt|;
comment|/* reset periodic desc intr count */
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|axq_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
break|break;
block|}
name|ds0
operator|=
operator|&
name|bf
operator|->
name|bf_desc
index|[
literal|0
index|]
expr_stmt|;
name|ds
operator|=
operator|&
name|bf
operator|->
name|bf_desc
index|[
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
index|]
expr_stmt|;
name|ts
operator|=
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_txstat
expr_stmt|;
name|status
operator|=
name|ath_hal_txprocdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|ts
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_XMIT_DESC
condition|)
name|ath_printtxbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
literal|0
argument_list|,
name|status
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|==
name|HAL_EINPROGRESS
condition|)
block|{
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
break|break;
block|}
name|ATH_TXQ_REMOVE_HEAD
argument_list|(
name|txq
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|txq
operator|->
name|axq_depth
operator|>
literal|0
condition|)
block|{
comment|/* 			 * More frames follow.  Mark the buffer busy 			 * so it's not re-used while the hardware may 			 * still re-read the link field in the descriptor. 			 */
name|bf
operator|->
name|bf_flags
operator||=
name|ATH_BUF_BUSY
expr_stmt|;
block|}
elseif|else
else|#
directive|else
if|if
condition|(
name|txq
operator|->
name|axq_depth
operator|==
literal|0
condition|)
endif|#
directive|endif
name|txq
operator|->
name|axq_link
operator|=
name|NULL
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|ni
operator|=
name|bf
operator|->
name|bf_node
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|an
operator|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_status
operator|==
literal|0
condition|)
block|{
name|u_int8_t
name|txant
init|=
name|ts
operator|->
name|ts_antenna
decl_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_ant_tx
index|[
name|txant
index|]
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_ant_tx
index|[
name|txant
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_finaltsi
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_altrate
operator|++
expr_stmt|;
name|pri
operator|=
name|M_WME_GETAC
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
if|if
condition|(
name|pri
operator|>=
name|WME_AC_VO
condition|)
name|ic
operator|->
name|ic_wme
operator|.
name|wme_hipri_traffic
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|bf
operator|->
name|bf_txflags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
name|ni
operator|->
name|ni_inact
operator|=
name|ni
operator|->
name|ni_inact_reload
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TXERR_XRETRY
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_xretries
operator|++
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TXERR_FIFO
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_fifoerr
operator|++
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TXERR_FILT
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_filtered
operator|++
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|->
name|m_flags
operator|&
name|M_FF
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_ff_txerr
operator|++
expr_stmt|;
block|}
name|sr
operator|=
name|ts
operator|->
name|ts_shortretry
expr_stmt|;
name|lr
operator|=
name|ts
operator|->
name|ts_longretry
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_shortretry
operator|+=
name|sr
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_longretry
operator|+=
name|lr
expr_stmt|;
comment|/* 			 * Hand the descriptor to the rate control algorithm. 			 */
if|if
condition|(
operator|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TXERR_FILT
operator|)
operator|==
literal|0
operator|&&
operator|(
name|bf
operator|->
name|bf_txflags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * If frame was ack'd update statistics, 				 * including the last rx time used to 				 * workaround phantom bmiss interrupts. 				 */
if|if
condition|(
name|ts
operator|->
name|ts_status
operator|==
literal|0
condition|)
block|{
name|nacked
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_rssi
operator|=
name|ts
operator|->
name|ts_rssi
expr_stmt|;
name|ATH_RSSI_LPF
argument_list|(
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgtxrssi
argument_list|,
name|ts
operator|->
name|ts_rssi
argument_list|)
expr_stmt|;
block|}
name|ath_rate_tx_complete
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Do any tx complete callback.  Note this must 			 * be done before releasing the node reference. 			 */
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|->
name|m_flags
operator|&
name|M_TXCB
condition|)
name|ieee80211_process_callback
argument_list|(
name|ni
argument_list|,
name|bf
operator|->
name|bf_m
argument_list|,
operator|(
name|bf
operator|->
name|bf_txflags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|?
name|ts
operator|->
name|ts_status
else|:
name|HAL_TXERR_XRETRY
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|last
operator|=
name|STAILQ_LAST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|ath_buf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|!=
name|NULL
condition|)
name|last
operator|->
name|bf_flags
operator|&=
operator|~
name|ATH_BUF_BUSY
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
comment|/* 	 * Flush fast-frame staging queue when traffic slows. 	 */
if|if
condition|(
name|txq
operator|->
name|axq_depth
operator|<=
literal|1
condition|)
name|ieee80211_ff_flush
argument_list|(
name|ic
argument_list|,
name|txq
operator|->
name|axq_ac
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|nacked
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|txqactive
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|qnum
parameter_list|)
block|{
name|u_int32_t
name|txqs
init|=
literal|1
operator|<<
name|qnum
decl_stmt|;
name|ath_hal_gettxintrtxqs
argument_list|(
name|ah
argument_list|,
operator|&
name|txqs
argument_list|)
expr_stmt|;
return|return
operator|(
name|txqs
operator|&
operator|(
literal|1
operator|<<
name|qnum
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deferred processing of transmit interrupt; special-cased  * for a single hardware transmit queue (e.g. 5210 and 5211).  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_proc_q0
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
if|if
condition|(
name|txqactive
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0
argument_list|)
operator|&&
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|0
index|]
argument_list|)
condition|)
name|sc
operator|->
name|sc_lastrx
operator|=
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|txqactive
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_cabq
operator|->
name|axq_qnum
argument_list|)
condition|)
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_cabq
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
name|ath_led_event
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_txrix
argument_list|)
expr_stmt|;
name|ath_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deferred processing of transmit interrupt; special-cased  * for four hardware queues, 0-3 (e.g. 5212 w/ WME support).  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_proc_q0123
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|int
name|nacked
decl_stmt|;
comment|/* 	 * Process each active queue. 	 */
name|nacked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|txqactive
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0
argument_list|)
condition|)
name|nacked
operator|+=
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|txqactive
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|1
argument_list|)
condition|)
name|nacked
operator|+=
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|txqactive
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|2
argument_list|)
condition|)
name|nacked
operator|+=
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|txqactive
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|3
argument_list|)
condition|)
name|nacked
operator|+=
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|txqactive
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_cabq
operator|->
name|axq_qnum
argument_list|)
condition|)
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_cabq
argument_list|)
expr_stmt|;
if|if
condition|(
name|nacked
condition|)
name|sc
operator|->
name|sc_lastrx
operator|=
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
name|ath_led_event
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_txrix
argument_list|)
expr_stmt|;
name|ath_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deferred processing of transmit interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nacked
decl_stmt|;
comment|/* 	 * Process each active queue. 	 */
name|nacked
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
operator|&&
name|txqactive
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|i
argument_list|)
condition|)
name|nacked
operator|+=
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nacked
condition|)
name|sc
operator|->
name|sc_lastrx
operator|=
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
name|ath_led_event
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_txrix
argument_list|)
expr_stmt|;
name|ath_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tx_draintxq
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ATH_DEBUG
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
endif|#
directive|endif
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|u_int
name|ix
decl_stmt|;
comment|/* 	 * NB: this assumes output has been stopped and 	 *     we do not need to block ath_tx_proc 	 */
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bf
operator|=
name|STAILQ_LAST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|ath_buf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
name|bf
operator|->
name|bf_flags
operator|&=
operator|~
name|ATH_BUF_BUSY
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
condition|;
name|ix
operator|++
control|)
block|{
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|axq_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|txq
operator|->
name|axq_link
operator|=
name|NULL
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
break|break;
block|}
name|ATH_TXQ_REMOVE_HEAD
argument_list|(
name|txq
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_RESET
condition|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|sc
operator|->
name|sc_ifp
operator|->
name|if_l2com
decl_stmt|;
name|ath_printtxbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|ix
argument_list|,
name|ath_hal_txprocdesc
argument_list|(
name|ah
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_txstat
argument_list|)
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|,
specifier|const
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|bf
operator|->
name|bf_m
operator|->
name|m_len
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ATH_DEBUG */
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|ni
operator|=
name|bf
operator|->
name|bf_node
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Do any callback and reclaim the node reference. 			 */
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|->
name|m_flags
operator|&
name|M_TXCB
condition|)
name|ieee80211_process_callback
argument_list|(
name|ni
argument_list|,
name|bf
operator|->
name|bf_m
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|bf
operator|->
name|bf_flags
operator|&=
operator|~
name|ATH_BUF_BUSY
expr_stmt|;
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tx_stopdma
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: tx queue [%u] %p, link %p\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ath_hal_gettxbuf
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
argument_list|,
name|txq
operator|->
name|axq_link
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Drain the transmit queues and reclaim resources.  */
end_comment

begin_function
specifier|static
name|void
name|ath_draintxq
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* XXX return value */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
block|{
comment|/* don't touch the hardware if marked invalid */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: tx queue [%u] %p, link %p\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ath_hal_gettxbuf
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
condition|)
name|ath_tx_stopdma
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
condition|)
name|ath_tx_draintxq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_RESET
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
init|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
operator|&&
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
block|{
name|ath_printtxbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
literal|0
argument_list|,
name|ath_hal_txprocdesc
argument_list|(
name|ah
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_txstat
argument_list|)
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
name|ieee80211_dump_pkt
argument_list|(
name|ifp
operator|->
name|if_l2com
argument_list|,
name|mtod
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|,
specifier|const
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|bf
operator|->
name|bf_m
operator|->
name|m_len
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ATH_DEBUG */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Disable the receive h/w in preparation for a reset.  */
end_comment

begin_function
specifier|static
name|void
name|ath_stoprecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
define|#
directive|define
name|PA2DESC
parameter_list|(
name|_sc
parameter_list|,
name|_pa
parameter_list|)
define|\
value|((struct ath_desc *)((caddr_t)(_sc)->sc_rxdma.dd_desc + \ 		((_pa) - (_sc)->sc_rxdma.dd_desc_paddr)))
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|ath_hal_stoppcurecv
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* disable PCU */
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear recv filter */
name|ath_hal_stopdmarecv
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* disable DMA engine */
name|DELAY
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
comment|/* 3ms is long enough for 1 frame */
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
operator|(
name|ATH_DEBUG_RESET
operator||
name|ATH_DEBUG_FATAL
operator|)
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|u_int
name|ix
decl_stmt|;
name|printf
argument_list|(
literal|"%s: rx queue %p, link %p\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ath_hal_getrxbuf
argument_list|(
name|ah
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_rxlink
argument_list|)
expr_stmt|;
name|ix
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->sc_rxbuf
argument_list|,
argument|bf_list
argument_list|)
block|{
name|struct
name|ath_desc
modifier|*
name|ds
init|=
name|bf
operator|->
name|bf_desc
decl_stmt|;
name|struct
name|ath_rx_status
modifier|*
name|rs
init|=
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_rxstat
decl_stmt|;
name|HAL_STATUS
name|status
init|=
name|ath_hal_rxprocdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|,
name|PA2DESC
argument_list|(
name|sc
argument_list|,
name|ds
operator|->
name|ds_link
argument_list|)
argument_list|,
name|rs
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|HAL_OK
operator|||
operator|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_FATAL
operator|)
condition|)
name|ath_printrxbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|ix
argument_list|,
name|status
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
name|ix
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_rxpending
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_rxpending
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxpending
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|sc_rxlink
operator|=
name|NULL
expr_stmt|;
comment|/* just in case */
undef|#
directive|undef
name|PA2DESC
block|}
end_function

begin_comment
comment|/*  * Enable the receive h/w following a reset.  */
end_comment

begin_function
specifier|static
name|int
name|ath_startrecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|sc
operator|->
name|sc_rxlink
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_rxpending
operator|=
name|NULL
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->sc_rxbuf
argument_list|,
argument|bf_list
argument_list|)
block|{
name|int
name|error
init|=
name|ath_rxbuf_init
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RECV
argument_list|,
literal|"%s: ath_rxbuf_init failed %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
name|ath_hal_putrxbuf
argument_list|(
name|ah
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|ath_hal_rxena
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* enable recv descriptors */
name|ath_mode_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set filters, etc. */
name|ath_hal_startpcurecv
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* re-enable PCU/DMA engine */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   * Update internal state after a channel change.  */
end_comment

begin_function
specifier|static
name|void
name|ath_chan_change
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
comment|/* 	 * Change channels and update the h/w rate map 	 * if we're switching; e.g. 11a to 11b/g. 	 */
name|mode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|sc
operator|->
name|sc_curmode
condition|)
name|ath_setcurmode
argument_list|(
name|sc
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_curchan
operator|=
name|chan
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set/change channels.  If the channel is really being changed,  * it's done by reseting the chip.  To accomplish this we must  * first cleanup any pending DMA, then restart stuff after a la  * ath_init.  */
end_comment

begin_function
specifier|static
name|int
name|ath_chan_set
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: %u (%u MHz, flags 0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
name|sc
operator|->
name|sc_curchan
condition|)
block|{
name|HAL_STATUS
name|status
decl_stmt|;
comment|/* 		 * To switch channels clear any pending DMA operations; 		 * wait long enough for the RX fifo to drain, reset the 		 * hardware at the new frequency, and then re-enable 		 * the relevant bits of the h/w. 		 */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|ath_draintxq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* clear pending tx frames */
name|ath_stoprecv
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* turn off frame recv */
if|if
condition|(
operator|!
name|ath_hal_reset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_opmode
argument_list|,
name|chan
argument_list|,
name|AH_TRUE
argument_list|,
operator|&
name|status
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: unable to reset "
literal|"channel %u (%u Mhz, flags 0x%x), hal status %u\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|sc
operator|->
name|sc_diversity
operator|=
name|ath_hal_getdiversity
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 		 * Re-enable rx framework. 		 */
if|if
condition|(
name|ath_startrecv
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: unable to restart recv logic\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* 		 * Change channels and update the h/w rate map 		 * if we're switching; e.g. 11a to 11b/g. 		 */
name|ath_chan_change
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* 		 * Re-enable interrupts. 		 */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Periodically recalibrate the PHY to account  * for temperature/environment changes.  */
end_comment

begin_function
specifier|static
name|void
name|ath_calibrate
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|HAL_BOOL
name|longCal
decl_stmt|,
name|isCalDone
decl_stmt|;
name|int
name|nextcal
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
condition|)
comment|/* defer, off channel */
goto|goto
name|restart
goto|;
name|longCal
operator|=
operator|(
name|ticks
operator|-
name|sc
operator|->
name|sc_lastlongcal
operator|>=
name|ath_longcalinterval
operator|*
name|hz
operator|)
expr_stmt|;
if|if
condition|(
name|longCal
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_per_cal
operator|++
expr_stmt|;
if|if
condition|(
name|ath_hal_getrfgain
argument_list|(
name|ah
argument_list|)
operator|==
name|HAL_RFGAIN_NEED_CHANGE
condition|)
block|{
comment|/* 			 * Rfgain is out of bounds, reset the chip 			 * to load new gain values. 			 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_CALIBRATE
argument_list|,
literal|"%s: rfgain change\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_per_rfgain
operator|++
expr_stmt|;
name|ath_reset
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If this long cal is after an idle period, then 		 * reset the data collection state so we start fresh. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_resetcal
condition|)
block|{
operator|(
name|void
operator|)
name|ath_hal_calreset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_lastcalreset
operator|=
name|ticks
expr_stmt|;
name|sc
operator|->
name|sc_resetcal
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ath_hal_calibrateN
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|,
name|longCal
argument_list|,
operator|&
name|isCalDone
argument_list|)
condition|)
block|{
if|if
condition|(
name|longCal
condition|)
block|{
comment|/* 			 * Calibrate noise floor data again in case of change. 			 */
name|ath_hal_process_noisefloor
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: calibration of channel %u failed\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_curchan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_per_calfail
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isCalDone
condition|)
block|{
name|restart
label|:
comment|/* 		 * Use a shorter interval to potentially collect multiple 		 * data samples required to complete calibration.  Once 		 * we're told the work is done we drop back to a longer 		 * interval between requests.  We're more aggressive doing 		 * work when operating as an AP to improve operation right 		 * after startup. 		 */
name|nextcal
operator|=
operator|(
literal|1000
operator|*
name|ath_shortcalinterval
operator|)
operator|/
name|hz
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_opmode
operator|!=
name|HAL_M_HOSTAP
condition|)
name|nextcal
operator|*=
literal|10
expr_stmt|;
block|}
else|else
block|{
name|nextcal
operator|=
name|ath_longcalinterval
operator|*
name|hz
expr_stmt|;
name|sc
operator|->
name|sc_lastlongcal
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_lastcalreset
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_lastcalreset
operator|=
name|sc
operator|->
name|sc_lastlongcal
expr_stmt|;
elseif|else
if|if
condition|(
name|ticks
operator|-
name|sc
operator|->
name|sc_lastcalreset
operator|>=
name|ath_resetcalinterval
operator|*
name|hz
condition|)
name|sc
operator|->
name|sc_resetcal
operator|=
literal|1
expr_stmt|;
comment|/* setup reset next trip */
block|}
if|if
condition|(
name|nextcal
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_CALIBRATE
argument_list|,
literal|"%s: next +%u (%sisCalDone)\n"
argument_list|,
name|__func__
argument_list|,
name|nextcal
argument_list|,
name|isCalDone
condition|?
literal|""
else|:
literal|"!"
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|,
name|nextcal
argument_list|,
name|ath_calibrate
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_CALIBRATE
argument_list|,
literal|"%s: calibration disabled\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* NB: don't rearm timer */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
comment|/* XXX calibration timer? */
name|sc
operator|->
name|sc_scanning
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|0
expr_stmt|;
name|rfilt
operator|=
name|ath_calcrxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
name|ath_hal_setassocid
argument_list|(
name|ah
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"%s: RX filter 0x%x bssid %s aid 0\n"
argument_list|,
name|__func__
argument_list|,
name|rfilt
argument_list|,
name|ether_sprintf
argument_list|(
name|ifp
operator|->
name|if_broadcastaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
name|sc
operator|->
name|sc_scanning
operator|=
literal|0
expr_stmt|;
name|rfilt
operator|=
name|ath_calcrxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
name|ath_hal_setassocid
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_curbssid
argument_list|,
name|sc
operator|->
name|sc_curaid
argument_list|)
expr_stmt|;
name|ath_hal_process_noisefloor
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"%s: RX filter 0x%x bssid %s aid 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|rfilt
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|sc_curbssid
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_curaid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
operator|(
name|void
operator|)
name|ath_chan_set
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* 	 * If we are returning to our bss channel then mark state 	 * so the next recv'd beacon's tsf will be used to sync the 	 * beacon timers.  Note that since we only hear beacons in 	 * sta/ibss mode this has no effect in other operating modes. 	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_scanning
operator|&&
name|ic
operator|->
name|ic_curchan
operator|==
name|ic
operator|->
name|ic_bsschan
condition|)
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Walk the vap list and check if there any vap's in RUN state.  */
end_comment

begin_function
specifier|static
name|int
name|ath_isanyrunningvaps
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|this
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|this
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
if|if
condition|(
name|vap
operator|!=
name|this
operator|&&
name|vap
operator|->
name|iv_state
operator|>=
name|IEEE80211_S_RUN
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|stamode
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
specifier|static
specifier|const
name|HAL_LED_STATE
name|leds
index|[]
init|=
block|{
name|HAL_LED_INIT
block|,
comment|/* IEEE80211_S_INIT */
name|HAL_LED_SCAN
block|,
comment|/* IEEE80211_S_SCAN */
name|HAL_LED_AUTH
block|,
comment|/* IEEE80211_S_AUTH */
name|HAL_LED_ASSOC
block|,
comment|/* IEEE80211_S_ASSOC */
name|HAL_LED_RUN
block|,
comment|/* IEEE80211_S_CAC */
name|HAL_LED_RUN
block|,
comment|/* IEEE80211_S_RUN */
name|HAL_LED_RUN
block|,
comment|/* IEEE80211_S_CSA */
name|HAL_LED_RUN
block|,
comment|/* IEEE80211_S_SLEEP */
block|}
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"%s: %s -> %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_state
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|)
expr_stmt|;
name|ath_hal_setledstate
argument_list|(
name|ah
argument_list|,
name|leds
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
comment|/* set LED */
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_SCAN
condition|)
block|{
comment|/* 		 * Scanning: turn off beacon miss and don't beacon. 		 * Mark beacon state so when we reach RUN state we'll 		 * [re]setup beacons.  Unblock the task q thread so 		 * deferred interrupt processing is done. 		 */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
operator|&
operator|~
operator|(
name|HAL_INT_SWBA
operator||
name|HAL_INT_BMISS
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_imask
operator|&=
operator|~
operator|(
name|HAL_INT_SWBA
operator||
name|HAL_INT_BMISS
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_beacons
operator|=
literal|0
expr_stmt|;
name|taskqueue_unblock
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
block|}
name|ni
operator|=
name|vap
operator|->
name|iv_bss
expr_stmt|;
name|rfilt
operator|=
name|ath_calcrxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|stamode
operator|=
operator|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_AHDEMO
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
operator|)
expr_stmt|;
if|if
condition|(
name|stamode
operator|&&
name|nstate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
name|sc
operator|->
name|sc_curaid
operator|=
name|ni
operator|->
name|ni_associd
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|sc_curbssid
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|ath_hal_setassocid
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_curbssid
argument_list|,
name|sc
operator|->
name|sc_curaid
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"%s: RX filter 0x%x bssid %s aid 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|rfilt
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|sc_curbssid
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_curaid
argument_list|)
expr_stmt|;
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
comment|/* XXX is this to restore keycache on resume? */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_STA
operator|&&
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_PRIVACY
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_WEP_NKID
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ath_hal_keyisvalid
argument_list|(
name|ah
argument_list|,
name|i
argument_list|)
condition|)
name|ath_hal_keysetmac
argument_list|(
name|ah
argument_list|,
name|i
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Invoke the parent method to do net80211 work. 	 */
name|error
operator|=
name|avp
operator|->
name|av_newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* NB: collect bss node again, it may have changed */
name|ni
operator|=
name|vap
operator|->
name|iv_bss
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"%s(RUN): iv_flags 0x%08x bintvl %d bssid %s "
literal|"capinfo 0x%04x chan %d\n"
argument_list|,
name|__func__
argument_list|,
name|vap
operator|->
name|iv_flags
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|)
argument_list|,
name|ni
operator|->
name|ni_capinfo
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vap
operator|->
name|iv_opmode
condition|)
block|{
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
case|case
name|IEEE80211_M_AHDEMO
case|:
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* fall thru... */
endif|#
directive|endif
case|case
name|IEEE80211_M_HOSTAP
case|:
case|case
name|IEEE80211_M_IBSS
case|:
case|case
name|IEEE80211_M_MBSS
case|:
comment|/* 			 * Allocate and setup the beacon frame. 			 * 			 * Stop any previous beacon DMA.  This may be 			 * necessary, for example, when an ibss merge 			 * causes reconfiguration; there will be a state 			 * transition from RUN->RUN that means we may 			 * be called with beacon transmission active. 			 */
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
name|error
operator|=
name|ath_beacon_alloc
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* 			 * If joining an adhoc network defer beacon timer 			 * configuration to the next beacon frame so we 			 * have a current TSF to use.  Otherwise we're 			 * starting an ibss/bss so there's no need to delay; 			 * if this is the first vap moving to RUN state, then 			 * beacon state needs to be [re]configured. 			 */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
operator|&&
name|ni
operator|->
name|ni_tstamp
operator|.
name|tsf
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_beacons
condition|)
block|{
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
condition|)
name|ath_tdma_config
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ath_beacon_config
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_beacons
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_M_STA
case|:
comment|/* 			 * Defer beacon timer configuration to the next 			 * beacon frame so we have a current TSF to use 			 * (any TSF collected when scanning is likely old). 			 */
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
comment|/* 			 * Monitor mode vaps have only INIT->RUN and RUN->RUN 			 * transitions so we must re-enable interrupts here to 			 * handle the case of a single monitor mode vap. 			 */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_WDS
case|:
break|break;
default|default:
break|break;
block|}
comment|/* 		 * Let the hal process statistics collected during a 		 * scan so it can provide calibrated noise floor data. 		 */
name|ath_hal_process_noisefloor
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 		 * Reset rssi stats; maybe not the best place... 		 */
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgbrssi
operator|=
name|ATH_RSSI_DUMMY_MARKER
expr_stmt|;
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgrssi
operator|=
name|ATH_RSSI_DUMMY_MARKER
expr_stmt|;
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgtxrssi
operator|=
name|ATH_RSSI_DUMMY_MARKER
expr_stmt|;
comment|/* 		 * Finally, start any timers and the task q thread 		 * (in case we didn't go through SCAN state). 		 */
if|if
condition|(
name|ath_longcalinterval
operator|!=
literal|0
condition|)
block|{
comment|/* start periodic recalibration timer */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|,
literal|1
argument_list|,
name|ath_calibrate
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_CALIBRATE
argument_list|,
literal|"%s: calibration disabled\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|taskqueue_unblock
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_INIT
condition|)
block|{
comment|/* 		 * If there are no vaps left in RUN state then 		 * shutdown host/driver operation: 		 * o disable interrupts 		 * o disable the task queue thread 		 * o mark beacon processing as stopped 		 */
if|if
condition|(
operator|!
name|ath_isanyrunningvaps
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_imask
operator|&=
operator|~
operator|(
name|HAL_INT_SWBA
operator||
name|HAL_INT_BMISS
operator|)
expr_stmt|;
comment|/* disable interrupts  */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
operator|&
operator|~
name|HAL_INT_GLOBAL
argument_list|)
expr_stmt|;
name|taskqueue_block
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_beacons
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
name|ath_hal_setcca
argument_list|(
name|ah
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|bad
label|:
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a key cache slot to the station so we can  * setup a mapping from key index to node. The key cache  * slot is needed for managing antenna state and for  * compression when stations do not use crypto.  We do  * it uniliaterally here; if crypto is employed this slot  * will be reassigned.  */
end_comment

begin_function
specifier|static
name|void
name|ath_setup_stationkey
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|ieee80211_keyix
name|keyix
decl_stmt|,
name|rxkeyix
decl_stmt|;
if|if
condition|(
operator|!
name|ath_key_alloc
argument_list|(
name|vap
argument_list|,
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|,
operator|&
name|keyix
argument_list|,
operator|&
name|rxkeyix
argument_list|)
condition|)
block|{
comment|/* 		 * Key cache is full; we'll fall back to doing 		 * the more expensive lookup in software.  Note 		 * this also means no h/w compression. 		 */
comment|/* XXX msg+statistic */
block|}
else|else
block|{
comment|/* XXX locking? */
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_keyix
operator|=
name|keyix
expr_stmt|;
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_rxkeyix
operator|=
name|rxkeyix
expr_stmt|;
comment|/* NB: must mark device key to get called back on delete */
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_flags
operator||=
name|IEEE80211_KEY_DEVKEY
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_macaddr
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
comment|/* NB: this will create a pass-thru key entry */
name|ath_keyset
argument_list|(
name|sc
argument_list|,
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|,
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Setup driver-specific state for a newly associated node.  * Note that we're called also on a re-associate, the isnew  * param tells us if this is the first time or not.  */
end_comment

begin_function
specifier|static
name|void
name|ath_newassoc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|isnew
parameter_list|)
block|{
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
specifier|const
name|struct
name|ieee80211_txparam
modifier|*
name|tp
init|=
name|ni
operator|->
name|ni_txparms
decl_stmt|;
name|an
operator|->
name|an_mcastrix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|tp
operator|->
name|mcastrate
argument_list|)
expr_stmt|;
name|an
operator|->
name|an_mgmtrix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|tp
operator|->
name|mgmtrate
argument_list|)
expr_stmt|;
name|ath_rate_newassoc
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|isnew
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnew
operator|&&
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_PRIVACY
operator|)
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_hasclrkey
operator|&&
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_keyix
operator|==
name|IEEE80211_KEYIX_NONE
condition|)
name|ath_setup_stationkey
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_setregdomain
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_regdomain
modifier|*
name|reg
parameter_list|,
name|int
name|nchans
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: rd %u cc %u location %c%s\n"
argument_list|,
name|__func__
argument_list|,
name|reg
operator|->
name|regdomain
argument_list|,
name|reg
operator|->
name|country
argument_list|,
name|reg
operator|->
name|location
argument_list|,
name|reg
operator|->
name|ecm
condition|?
literal|" ecm"
else|:
literal|""
argument_list|)
expr_stmt|;
name|status
operator|=
name|ath_hal_set_channels
argument_list|(
name|ah
argument_list|,
name|chans
argument_list|,
name|nchans
argument_list|,
name|reg
operator|->
name|country
argument_list|,
name|reg
operator|->
name|regdomain
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|HAL_OK
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: failed, status %u\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
comment|/* XXX */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_getradiocaps
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: use rd %u cc %d\n"
argument_list|,
name|__func__
argument_list|,
name|SKU_DEBUG
argument_list|,
name|CTRY_DEFAULT
argument_list|)
expr_stmt|;
comment|/* XXX check return */
operator|(
name|void
operator|)
name|ath_hal_getchannels
argument_list|(
name|ah
argument_list|,
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|HAL_MODE_ALL
argument_list|,
name|CTRY_DEFAULT
argument_list|,
name|SKU_DEBUG
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_getchannels
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
comment|/* 	 * Collect channel set based on EEPROM contents. 	 */
name|status
operator|=
name|ath_hal_init_channels
argument_list|(
name|ah
argument_list|,
name|ic
operator|->
name|ic_channels
argument_list|,
name|IEEE80211_CHAN_MAX
argument_list|,
operator|&
name|ic
operator|->
name|ic_nchans
argument_list|,
name|HAL_MODE_ALL
argument_list|,
name|CTRY_DEFAULT
argument_list|,
name|SKU_NONE
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|HAL_OK
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: unable to collect channel list from hal, "
literal|"status %d\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
operator|(
name|void
operator|)
name|ath_hal_getregdomain
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_eerd
argument_list|)
expr_stmt|;
name|ath_hal_getcountrycode
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_eecc
argument_list|)
expr_stmt|;
comment|/* NB: cannot fail */
comment|/* XXX map Atheros sku's to net80211 SKU's */
comment|/* XXX net80211 types too small */
name|ic
operator|->
name|ic_regdomain
operator|.
name|regdomain
operator|=
operator|(
name|uint16_t
operator|)
name|sc
operator|->
name|sc_eerd
expr_stmt|;
name|ic
operator|->
name|ic_regdomain
operator|.
name|country
operator|=
operator|(
name|uint16_t
operator|)
name|sc
operator|->
name|sc_eecc
expr_stmt|;
name|ic
operator|->
name|ic_regdomain
operator|.
name|isocc
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* XXX don't know */
name|ic
operator|->
name|ic_regdomain
operator|.
name|isocc
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|ic
operator|->
name|ic_regdomain
operator|.
name|ecm
operator|=
literal|1
expr_stmt|;
name|ic
operator|->
name|ic_regdomain
operator|.
name|location
operator|=
literal|'I'
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: eeprom rd %u cc %u (mapped rd %u cc %u) location %c%s\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_eerd
argument_list|,
name|sc
operator|->
name|sc_eecc
argument_list|,
name|ic
operator|->
name|ic_regdomain
operator|.
name|regdomain
argument_list|,
name|ic
operator|->
name|ic_regdomain
operator|.
name|country
argument_list|,
name|ic
operator|->
name|ic_regdomain
operator|.
name|location
argument_list|,
name|ic
operator|->
name|ic_regdomain
operator|.
name|ecm
condition|?
literal|" ecm"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_led_done
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|sc
operator|->
name|sc_blinking
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Turn the LED off: flip the pin and then set a timer so no  * update will happen for the specified duration.  */
end_comment

begin_function
specifier|static
name|void
name|ath_led_off
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|ath_hal_gpioset
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
operator|!
name|sc
operator|->
name|sc_ledon
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_ledtimer
argument_list|,
name|sc
operator|->
name|sc_ledoff
argument_list|,
name|ath_led_done
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Blink the LED according to the specified on/off times.  */
end_comment

begin_function
specifier|static
name|void
name|ath_led_blink
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|on
parameter_list|,
name|int
name|off
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_LED
argument_list|,
literal|"%s: on %u off %u\n"
argument_list|,
name|__func__
argument_list|,
name|on
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|ath_hal_gpioset
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
name|sc
operator|->
name|sc_ledon
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_blinking
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_ledoff
operator|=
name|off
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_ledtimer
argument_list|,
name|on
argument_list|,
name|ath_led_off
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_led_event
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|rix
parameter_list|)
block|{
name|sc
operator|->
name|sc_ledevent
operator|=
name|ticks
expr_stmt|;
comment|/* time of last event */
if|if
condition|(
name|sc
operator|->
name|sc_blinking
condition|)
comment|/* don't interrupt active blink */
return|return;
name|ath_led_blink
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ledon
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ledoff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_rate_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|mode
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|IEEE80211_MODE_11A
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11A
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_HALF
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11A_HALF_RATE
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_QUARTER
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11A_QUARTER_RATE
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_11B
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11B
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_11G
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11G
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_TURBO_A
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_108A
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_TURBO_G
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_108G
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_STURBO_A
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_TURBO
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_11NA
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11NA_HT20
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_11NG
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11NG_HT20
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: invalid mode %u\n"
argument_list|,
name|__func__
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sc
operator|->
name|sc_rates
index|[
name|mode
index|]
operator|=
name|rt
expr_stmt|;
return|return
operator|(
name|rt
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_setcurmode
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|ieee80211_phymode
name|mode
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
comment|/* NB: on/off times from the Atheros NDIS driver, w/ permission */
specifier|static
specifier|const
struct|struct
block|{
name|u_int
name|rate
decl_stmt|;
comment|/* tx/rx 802.11 rate */
name|u_int16_t
name|timeOn
decl_stmt|;
comment|/* LED on time (ms) */
name|u_int16_t
name|timeOff
decl_stmt|;
comment|/* LED off time (ms) */
block|}
name|blinkrates
index|[]
init|=
block|{
block|{
literal|108
block|,
literal|40
block|,
literal|10
block|}
block|,
block|{
literal|96
block|,
literal|44
block|,
literal|11
block|}
block|,
block|{
literal|72
block|,
literal|50
block|,
literal|13
block|}
block|,
block|{
literal|48
block|,
literal|57
block|,
literal|14
block|}
block|,
block|{
literal|36
block|,
literal|67
block|,
literal|16
block|}
block|,
block|{
literal|24
block|,
literal|80
block|,
literal|20
block|}
block|,
block|{
literal|22
block|,
literal|100
block|,
literal|25
block|}
block|,
block|{
literal|18
block|,
literal|133
block|,
literal|34
block|}
block|,
block|{
literal|12
block|,
literal|160
block|,
literal|40
block|}
block|,
block|{
literal|10
block|,
literal|200
block|,
literal|50
block|}
block|,
block|{
literal|6
block|,
literal|240
block|,
literal|58
block|}
block|,
block|{
literal|4
block|,
literal|267
block|,
literal|66
block|}
block|,
block|{
literal|2
block|,
literal|400
block|,
literal|100
block|}
block|,
block|{
literal|0
block|,
literal|500
block|,
literal|130
block|}
block|,
comment|/* XXX half/quarter rates */
block|}
struct|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|sc_rixmap
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rixmap
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_rates
index|[
name|mode
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no h/w rate set for phy mode %u"
operator|,
name|mode
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rt
operator|->
name|rateCount
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
name|ieeerate
init|=
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|dot11Rate
operator|&
name|IEEE80211_RATE_VAL
decl_stmt|;
if|if
condition|(
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|phy
operator|!=
name|IEEE80211_T_HT
condition|)
name|sc
operator|->
name|sc_rixmap
index|[
name|ieeerate
index|]
operator|=
name|i
expr_stmt|;
else|else
name|sc
operator|->
name|sc_rixmap
index|[
name|ieeerate
operator||
name|IEEE80211_RATE_MCS
index|]
operator|=
name|i
expr_stmt|;
block|}
name|memset
argument_list|(
name|sc
operator|->
name|sc_hwmap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hwmap
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|sc
operator|->
name|sc_hwmap
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|rt
operator|->
name|rateCount
condition|)
block|{
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ledon
operator|=
operator|(
literal|500
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ledoff
operator|=
operator|(
literal|130
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ieeerate
operator|=
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|dot11Rate
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|phy
operator|==
name|IEEE80211_T_HT
condition|)
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ieeerate
operator||=
name|IEEE80211_RATE_MCS
expr_stmt|;
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|txflags
operator|=
name|IEEE80211_RADIOTAP_F_DATAPAD
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|shortPreamble
operator|||
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|phy
operator|==
name|IEEE80211_T_OFDM
condition|)
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|txflags
operator||=
name|IEEE80211_RADIOTAP_F_SHORTPRE
expr_stmt|;
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|rxflags
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|txflags
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N
argument_list|(
name|blinkrates
argument_list|)
operator|-
literal|1
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|blinkrates
index|[
name|j
index|]
operator|.
name|rate
operator|==
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ieeerate
condition|)
break|break;
comment|/* NB: this uses the last entry if the rate isn't found */
comment|/* XXX beware of overlow */
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ledon
operator|=
operator|(
name|blinkrates
index|[
name|j
index|]
operator|.
name|timeOn
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ledoff
operator|=
operator|(
name|blinkrates
index|[
name|j
index|]
operator|.
name|timeOff
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
block|}
name|sc
operator|->
name|sc_currates
operator|=
name|rt
expr_stmt|;
name|sc
operator|->
name|sc_curmode
operator|=
name|mode
expr_stmt|;
comment|/* 	 * All protection frames are transmited at 2Mb/s for 	 * 11g, otherwise at 1Mb/s. 	 */
if|if
condition|(
name|mode
operator|==
name|IEEE80211_MODE_11G
condition|)
name|sc
operator|->
name|sc_protrix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
literal|2
operator|*
literal|2
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|sc_protrix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
literal|2
operator|*
literal|1
argument_list|)
expr_stmt|;
comment|/* NB: caller is responsible for reseting rate control state */
undef|#
directive|undef
name|N
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|ath_printrxbuf
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|u_int
name|ix
parameter_list|,
name|int
name|done
parameter_list|)
block|{
specifier|const
name|struct
name|ath_rx_status
modifier|*
name|rs
init|=
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_rxstat
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
specifier|const
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ds
operator|=
name|bf
operator|->
name|bf_desc
init|;
name|i
operator|<
name|bf
operator|->
name|bf_nseg
condition|;
name|i
operator|++
operator|,
name|ds
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"R[%2u] (DS.V:%p DS.P:%p) L:%08x D:%08x%s\n"
literal|"      %08x %08x %08x %08x\n"
argument_list|,
name|ix
argument_list|,
name|ds
argument_list|,
operator|(
specifier|const
expr|struct
name|ath_desc
operator|*
operator|)
name|bf
operator|->
name|bf_daddr
operator|+
name|i
argument_list|,
name|ds
operator|->
name|ds_link
argument_list|,
name|ds
operator|->
name|ds_data
argument_list|,
operator|!
name|done
condition|?
literal|""
else|:
operator|(
name|rs
operator|->
name|rs_status
operator|==
literal|0
operator|)
condition|?
literal|" *"
else|:
literal|" !"
argument_list|,
name|ds
operator|->
name|ds_ctl0
argument_list|,
name|ds
operator|->
name|ds_ctl1
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|0
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ah
operator|->
name|ah_magic
operator|==
literal|0x20065416
condition|)
block|{
name|printf
argument_list|(
literal|"        %08x %08x %08x %08x %08x %08x %08x\n"
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|2
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|3
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|4
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|5
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|6
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|7
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_printtxbuf
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|u_int
name|qnum
parameter_list|,
name|u_int
name|ix
parameter_list|,
name|int
name|done
parameter_list|)
block|{
specifier|const
name|struct
name|ath_tx_status
modifier|*
name|ts
init|=
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_txstat
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
specifier|const
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"Q%u[%3u]"
argument_list|,
name|qnum
argument_list|,
name|ix
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ds
operator|=
name|bf
operator|->
name|bf_desc
init|;
name|i
operator|<
name|bf
operator|->
name|bf_nseg
condition|;
name|i
operator|++
operator|,
name|ds
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" (DS.V:%p DS.P:%p) L:%08x D:%08x F:04%x%s\n"
literal|"        %08x %08x %08x %08x %08x %08x\n"
argument_list|,
name|ds
argument_list|,
operator|(
specifier|const
expr|struct
name|ath_desc
operator|*
operator|)
name|bf
operator|->
name|bf_daddr
operator|+
name|i
argument_list|,
name|ds
operator|->
name|ds_link
argument_list|,
name|ds
operator|->
name|ds_data
argument_list|,
name|bf
operator|->
name|bf_txflags
argument_list|,
operator|!
name|done
condition|?
literal|""
else|:
operator|(
name|ts
operator|->
name|ts_status
operator|==
literal|0
operator|)
condition|?
literal|" *"
else|:
literal|" !"
argument_list|,
name|ds
operator|->
name|ds_ctl0
argument_list|,
name|ds
operator|->
name|ds_ctl1
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|0
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|1
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|2
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ah
operator|->
name|ah_magic
operator|==
literal|0x20065416
condition|)
block|{
name|printf
argument_list|(
literal|"        %08x %08x %08x %08x %08x %08x %08x %08x\n"
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|4
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|5
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|6
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|7
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|8
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|9
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|10
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        %08x %08x %08x %08x %08x %08x %08x %08x\n"
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|12
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|13
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|14
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|15
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|16
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|17
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|18
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|19
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATH_DEBUG */
end_comment

begin_function
specifier|static
name|void
name|ath_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_wd_timer
operator|!=
literal|0
operator|&&
operator|--
name|sc
operator|->
name|sc_wd_timer
operator|==
literal|0
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|uint32_t
name|hangs
decl_stmt|;
if|if
condition|(
name|ath_hal_gethangstate
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0xffff
argument_list|,
operator|&
name|hangs
argument_list|)
operator|&&
name|hangs
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s hang detected (0x%x)\n"
argument_list|,
name|hangs
operator|&
literal|0xff
condition|?
literal|"bb"
else|:
literal|"mac"
argument_list|,
name|hangs
argument_list|)
expr_stmt|;
block|}
else|else
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
name|ath_reset
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_watchdog
operator|++
expr_stmt|;
block|}
name|callout_schedule
argument_list|(
operator|&
name|sc
operator|->
name|sc_wd_ch
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_DIAGAPI
end_ifdef

begin_comment
comment|/*  * Diagnostic interface to the HAL.  This is used by various  * tools to do things like retrieve register contents for  * debugging.  The mechanism is intentionally opaque so that  * it can change frequently w/o concern for compatiblity.  */
end_comment

begin_function
specifier|static
name|int
name|ath_ioctl_diag
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_diag
modifier|*
name|ad
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|u_int
name|id
init|=
name|ad
operator|->
name|ad_id
operator|&
name|ATH_DIAG_ID
decl_stmt|;
name|void
modifier|*
name|indata
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|outdata
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|insize
init|=
name|ad
operator|->
name|ad_in_size
decl_stmt|;
name|u_int32_t
name|outsize
init|=
name|ad
operator|->
name|ad_out_size
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ad
operator|->
name|ad_id
operator|&
name|ATH_DIAG_IN
condition|)
block|{
comment|/* 		 * Copy in data. 		 */
name|indata
operator|=
name|malloc
argument_list|(
name|insize
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|indata
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|error
operator|=
name|copyin
argument_list|(
name|ad
operator|->
name|ad_in_data
argument_list|,
name|indata
argument_list|,
name|insize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|ad
operator|->
name|ad_id
operator|&
name|ATH_DIAG_DYN
condition|)
block|{
comment|/* 		 * Allocate a buffer for the results (otherwise the HAL 		 * returns a pointer to a buffer where we can read the 		 * results).  Note that we depend on the HAL leaving this 		 * pointer for us to use below in reclaiming the buffer; 		 * may want to be more defensive. 		 */
name|outdata
operator|=
name|malloc
argument_list|(
name|outsize
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|outdata
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|ath_hal_getdiagstate
argument_list|(
name|ah
argument_list|,
name|id
argument_list|,
name|indata
argument_list|,
name|insize
argument_list|,
operator|&
name|outdata
argument_list|,
operator|&
name|outsize
argument_list|)
condition|)
block|{
if|if
condition|(
name|outsize
operator|<
name|ad
operator|->
name|ad_out_size
condition|)
name|ad
operator|->
name|ad_out_size
operator|=
name|outsize
expr_stmt|;
if|if
condition|(
name|outdata
operator|!=
name|NULL
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|outdata
argument_list|,
name|ad
operator|->
name|ad_out_data
argument_list|,
name|ad
operator|->
name|ad_out_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|bad
label|:
if|if
condition|(
operator|(
name|ad
operator|->
name|ad_id
operator|&
name|ATH_DIAG_IN
operator|)
operator|&&
name|indata
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|indata
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ad
operator|->
name|ad_id
operator|&
name|ATH_DIAG_DYN
operator|)
operator|&&
name|outdata
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|outdata
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATH_DIAGAPI */
end_comment

begin_function
specifier|static
name|int
name|ath_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
define|#
directive|define
name|IS_RUNNING
parameter_list|(
name|ifp
parameter_list|)
define|\
value|((ifp->if_flags& IFF_UP)&& (ifp->if_drv_flags& IFF_DRV_RUNNING))
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_RUNNING
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
comment|/* 			 * To avoid rescanning another access point, 			 * do not call ath_init() here.  Instead, 			 * only reflect promisc mode settings. 			 */
name|ath_mode_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/* 			 * Beware of being called during attach/detach 			 * to reset promiscuous mode.  In that case we 			 * will still be marked UP but not RUNNING. 			 * However trying to re-init the interface 			 * is the wrong thing to do as we've already 			 * torn down much of our state.  There's 			 * probably a better way to deal with this. 			 */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
name|ath_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX lose error */
block|}
else|else
block|{
name|ath_stop_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* XXX must wakeup in places like ath_vap_delete */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
name|ath_hal_setpower
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_PM_FULL_SLEEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|ic
operator|->
name|ic_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGATHSTATS
case|:
comment|/* NB: embed these numbers to get a consistent view */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_packets
operator|=
name|ifp
operator|->
name|if_opackets
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_packets
operator|=
name|ifp
operator|->
name|if_ipackets
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_rssi
operator|=
name|ATH_RSSI
argument_list|(
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgtxrssi
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_rssi
operator|=
name|ATH_RSSI
argument_list|(
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgrssi
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tdma_tsfadjp
operator|=
name|TDMA_AVG
argument_list|(
name|sc
operator|->
name|sc_avgtsfdeltap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tdma_tsfadjm
operator|=
name|TDMA_AVG
argument_list|(
name|sc
operator|->
name|sc_avgtsfdeltam
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
comment|/* XXX HT rates */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_rate
operator|=
name|rt
operator|->
name|info
index|[
name|sc
operator|->
name|sc_txrix
index|]
operator|.
name|dot11Rate
operator|&
operator|~
name|IEEE80211_RATE_BASIC
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|sc
operator|->
name|sc_stats
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_stats
argument_list|)
argument_list|)
return|;
case|case
name|SIOCZATHSTATS
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|curthread
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|memset
argument_list|(
operator|&
name|sc
operator|->
name|sc_stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_stats
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|ATH_DIAGAPI
case|case
name|SIOCGATHDIAG
case|:
name|error
operator|=
name|ath_ioctl_diag
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|ath_diag
operator|*
operator|)
name|ifr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIOCGIFADDR
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
undef|#
directive|undef
name|IS_RUNNING
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_slottime
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|slottime
init|=
name|ath_hal_getslottime
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|slottime
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|!
name|ath_hal_setslottime
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|slottime
argument_list|)
condition|?
name|EINVAL
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_acktimeout
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|acktimeout
init|=
name|ath_hal_getacktimeout
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|acktimeout
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|!
name|ath_hal_setacktimeout
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|acktimeout
argument_list|)
condition|?
name|EINVAL
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_ctstimeout
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|ctstimeout
init|=
name|ath_hal_getctstimeout
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|ctstimeout
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|!
name|ath_hal_setctstimeout
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|ctstimeout
argument_list|)
condition|?
name|EINVAL
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_softled
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|softled
init|=
name|sc
operator|->
name|sc_softled
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|softled
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
name|softled
operator|=
operator|(
name|softled
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|softled
operator|!=
name|sc
operator|->
name|sc_softled
condition|)
block|{
if|if
condition|(
name|softled
condition|)
block|{
comment|/* NB: handle any sc_ledpin change */
name|ath_hal_gpioCfgOutput
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
name|HAL_GPIO_MUX_MAC_NETWORK_LED
argument_list|)
expr_stmt|;
name|ath_hal_gpioset
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
operator|!
name|sc
operator|->
name|sc_ledon
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_softled
operator|=
name|softled
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_ledpin
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|ledpin
init|=
name|sc
operator|->
name|sc_ledpin
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|ledpin
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
if|if
condition|(
name|ledpin
operator|!=
name|sc
operator|->
name|sc_ledpin
condition|)
block|{
name|sc
operator|->
name|sc_ledpin
operator|=
name|ledpin
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
block|{
name|ath_hal_gpioCfgOutput
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
name|HAL_GPIO_MUX_MAC_NETWORK_LED
argument_list|)
expr_stmt|;
name|ath_hal_gpioset
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
operator|!
name|sc
operator|->
name|sc_ledon
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_txantenna
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|txantenna
init|=
name|ath_hal_getantennaswitch
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|txantenna
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|req
operator|->
name|newptr
condition|)
block|{
comment|/* XXX assumes 2 antenna ports */
if|if
condition|(
name|txantenna
operator|<
name|HAL_ANT_VARIABLE
operator|||
name|txantenna
operator|>
name|HAL_ANT_FIXED_B
condition|)
return|return
name|EINVAL
return|;
name|ath_hal_setantennaswitch
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|txantenna
argument_list|)
expr_stmt|;
comment|/* 		 * NB: with the switch locked this isn't meaningful, 		 *     but set it anyway so things like radiotap get 		 *     consistent info in their data. 		 */
name|sc
operator|->
name|sc_txantenna
operator|=
name|txantenna
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_rxantenna
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|defantenna
init|=
name|ath_hal_getdefantenna
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|defantenna
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|req
operator|->
name|newptr
condition|)
name|ath_hal_setdefantenna
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|defantenna
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_diversity
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|diversity
init|=
name|ath_hal_getdiversity
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|diversity
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
name|ath_hal_setdiversity
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|diversity
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|sc
operator|->
name|sc_diversity
operator|=
name|diversity
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_diag
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int32_t
name|diag
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|ath_hal_getdiag
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|diag
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|diag
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|!
name|ath_hal_setdiag
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|diag
argument_list|)
condition|?
name|EINVAL
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_tpscale
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|u_int32_t
name|scale
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|(
name|void
operator|)
name|ath_hal_gettpscale
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|scale
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|scale
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|!
name|ath_hal_settpscale
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|scale
argument_list|)
condition|?
name|EINVAL
else|:
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|?
name|ath_reset
argument_list|(
name|ifp
argument_list|)
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_tpc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|tpc
init|=
name|ath_hal_gettpc
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|tpc
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|!
name|ath_hal_settpc
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|tpc
argument_list|)
condition|?
name|EINVAL
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_rfkill
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|u_int
name|rfkill
init|=
name|ath_hal_getrfkill
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|rfkill
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
if|if
condition|(
name|rfkill
operator|==
name|ath_hal_getrfkill
argument_list|(
name|ah
argument_list|)
condition|)
comment|/* unchanged */
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ath_hal_setrfkill
argument_list|(
name|ah
argument_list|,
name|rfkill
argument_list|)
condition|)
return|return
name|EINVAL
return|;
return|return
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|?
name|ath_reset
argument_list|(
name|ifp
argument_list|)
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_rfsilent
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|rfsilent
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|(
name|void
operator|)
name|ath_hal_getrfsilent
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|rfsilent
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|rfsilent
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
name|ath_hal_setrfsilent
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|rfsilent
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|sc
operator|->
name|sc_rfsilentpin
operator|=
name|rfsilent
operator|&
literal|0x1c
expr_stmt|;
name|sc
operator|->
name|sc_rfsilentpol
operator|=
operator|(
name|rfsilent
operator|&
literal|0x2
operator|)
operator|!=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_tpack
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int32_t
name|tpack
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|(
name|void
operator|)
name|ath_hal_gettpack
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|tpack
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|tpack
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|!
name|ath_hal_settpack
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|tpack
argument_list|)
condition|?
name|EINVAL
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_tpcts
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int32_t
name|tpcts
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|(
name|void
operator|)
name|ath_hal_gettpcts
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|tpcts
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|tpcts
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|!
name|ath_hal_settpcts
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|tpcts
argument_list|)
condition|?
name|EINVAL
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_intmit
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|intmit
decl_stmt|,
name|error
decl_stmt|;
name|intmit
operator|=
name|ath_hal_getintmit
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|intmit
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|!
name|ath_hal_setintmit
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|intmit
argument_list|)
condition|?
name|EINVAL
else|:
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_function
specifier|static
name|int
name|ath_sysctl_setcca
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|setcca
decl_stmt|,
name|error
decl_stmt|;
name|setcca
operator|=
name|sc
operator|->
name|sc_setcca
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|setcca
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
name|sc
operator|->
name|sc_setcca
operator|=
operator|(
name|setcca
operator|!=
literal|0
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IEEE80211_SUPPORT_TDMA */
end_comment

begin_function
specifier|static
name|void
name|ath_sysctlattach
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"countrycode"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|sc_eecc
argument_list|,
literal|0
argument_list|,
literal|"EEPROM country code"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"regdomain"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|sc_eerd
argument_list|,
literal|0
argument_list|,
literal|"EEPROM regdomain code"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_debug
argument_list|,
literal|0
argument_list|,
literal|"control debugging printfs"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"slottime"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_slottime
argument_list|,
literal|"I"
argument_list|,
literal|"802.11 slot time (us)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"acktimeout"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_acktimeout
argument_list|,
literal|"I"
argument_list|,
literal|"802.11 ACK timeout (us)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ctstimeout"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_ctstimeout
argument_list|,
literal|"I"
argument_list|,
literal|"802.11 CTS timeout (us)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"softled"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_softled
argument_list|,
literal|"I"
argument_list|,
literal|"enable/disable software LED support"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ledpin"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_ledpin
argument_list|,
literal|"I"
argument_list|,
literal|"GPIO pin connected to LED"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ledon"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_ledon
argument_list|,
literal|0
argument_list|,
literal|"setting to turn LED on"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ledidle"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_ledidle
argument_list|,
literal|0
argument_list|,
literal|"idle time for inactivity LED (ticks)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txantenna"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_txantenna
argument_list|,
literal|"I"
argument_list|,
literal|"antenna switch"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxantenna"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_rxantenna
argument_list|,
literal|"I"
argument_list|,
literal|"default/rx antenna"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_hal_hasdiversity
argument_list|(
name|ah
argument_list|)
condition|)
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"diversity"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_diversity
argument_list|,
literal|"I"
argument_list|,
literal|"antenna diversity"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txintrperiod
operator|=
name|ATH_TXINTR_PERIOD
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txintrperiod"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_txintrperiod
argument_list|,
literal|0
argument_list|,
literal|"tx descriptor batching"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"diag"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_diag
argument_list|,
literal|"I"
argument_list|,
literal|"h/w diagnostic control"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tpscale"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_tpscale
argument_list|,
literal|"I"
argument_list|,
literal|"tx power scaling"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_hal_hastpc
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tpc"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_tpc
argument_list|,
literal|"I"
argument_list|,
literal|"enable/disable per-packet TPC"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tpack"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_tpack
argument_list|,
literal|"I"
argument_list|,
literal|"tx power for ack frames"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tpcts"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_tpcts
argument_list|,
literal|"I"
argument_list|,
literal|"tx power for cts frames"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ath_hal_hasrfsilent
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rfsilent"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_rfsilent
argument_list|,
literal|"I"
argument_list|,
literal|"h/w RF silent config"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rfkill"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_rfkill
argument_list|,
literal|"I"
argument_list|,
literal|"enable/disable RF kill switch"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ath_hal_hasintmit
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"intmit"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_intmit
argument_list|,
literal|"I"
argument_list|,
literal|"interference mitigation"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_monpass
operator|=
name|HAL_RXERR_DECRYPT
operator||
name|HAL_RXERR_MIC
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"monpass"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_monpass
argument_list|,
literal|0
argument_list|,
literal|"mask of error frames to pass when monitoring"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|ath_hal_macversion
argument_list|(
name|ah
argument_list|)
operator|>
literal|0x78
condition|)
block|{
name|sc
operator|->
name|sc_tdmadbaprep
operator|=
literal|2
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dbaprep"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_tdmadbaprep
argument_list|,
literal|0
argument_list|,
literal|"TDMA DBA preparation time"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tdmaswbaprep
operator|=
literal|10
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"swbaprep"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_tdmaswbaprep
argument_list|,
literal|0
argument_list|,
literal|"TDMA SWBA preparation time"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"guardtime"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_tdmaguard
argument_list|,
literal|0
argument_list|,
literal|"TDMA slot guard time"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"superframe"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|sc_tdmabintval
argument_list|,
literal|0
argument_list|,
literal|"TDMA calculated super frame"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"setcca"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_setcca
argument_list|,
literal|"I"
argument_list|,
literal|"enable CCA control"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|ath_tx_raw_start
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ismcast
decl_stmt|,
name|ismrr
decl_stmt|;
name|int
name|keyix
decl_stmt|,
name|hdrlen
decl_stmt|,
name|pktlen
decl_stmt|,
name|try0
decl_stmt|,
name|txantenna
decl_stmt|;
name|u_int8_t
name|rix
decl_stmt|,
name|cix
decl_stmt|,
name|txrate
decl_stmt|,
name|ctsrate
decl_stmt|,
name|rate1
decl_stmt|,
name|rate2
decl_stmt|,
name|rate3
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|u_int
name|flags
decl_stmt|,
name|ctsduration
decl_stmt|;
name|HAL_PKT_TYPE
name|atype
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|u_int
name|pri
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ismcast
operator|=
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
comment|/* 	 * Packet length must not include any 	 * pad bytes; deduct them here. 	 */
comment|/* XXX honor IEEE80211_BPF_DATAPAD */
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|hdrlen
operator|&
literal|3
operator|)
operator|+
name|IEEE80211_CRC_LEN
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_CRYPTO
condition|)
block|{
specifier|const
name|struct
name|ieee80211_cipher
modifier|*
name|cip
decl_stmt|;
name|struct
name|ieee80211_key
modifier|*
name|k
decl_stmt|;
comment|/* 		 * Construct the 802.11 header+trailer for an encrypted 		 * frame. The only reason this can fail is because of an 		 * unknown or unsupported cipher/key type. 		 */
name|k
operator|=
name|ieee80211_crypto_encap
argument_list|(
name|ni
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * This can happen when the key is yanked after the 			 * frame was queued.  Just discard the frame; the 			 * 802.11 layer counts failures and provides 			 * debugging/diagnostics. 			 */
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* 		 * Adjust the packet + header lengths for the crypto 		 * additions and calculate the h/w key index.  When 		 * a s/w mic is done the frame will have had any mic 		 * added to it prior to entry so m0->m_pkthdr.len will 		 * account for it. Otherwise we need to add it to the 		 * packet length. 		 */
name|cip
operator|=
name|k
operator|->
name|wk_cipher
expr_stmt|;
name|hdrlen
operator|+=
name|cip
operator|->
name|ic_header
expr_stmt|;
name|pktlen
operator|+=
name|cip
operator|->
name|ic_header
operator|+
name|cip
operator|->
name|ic_trailer
expr_stmt|;
comment|/* NB: frags always have any TKIP MIC done in s/w */
if|if
condition|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWMIC
operator|)
operator|==
literal|0
condition|)
name|pktlen
operator|+=
name|cip
operator|->
name|ic_miclen
expr_stmt|;
name|keyix
operator|=
name|k
operator|->
name|wk_keyix
expr_stmt|;
comment|/* packet header may have moved, reset our local pointer */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_cipher
operator|==
operator|&
name|ieee80211_cipher_none
condition|)
block|{
comment|/* 		 * Use station key cache slot, if assigned. 		 */
name|keyix
operator|=
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_keyix
expr_stmt|;
if|if
condition|(
name|keyix
operator|==
name|IEEE80211_KEYIX_NONE
condition|)
name|keyix
operator|=
name|HAL_TXKEYIX_INVALID
expr_stmt|;
block|}
else|else
name|keyix
operator|=
name|HAL_TXKEYIX_INVALID
expr_stmt|;
name|error
operator|=
name|ath_tx_dmasetup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|m0
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
comment|/* NB: may have changed */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|ni
expr_stmt|;
comment|/* NB: held reference */
name|flags
operator|=
name|HAL_TXDESC_CLRDMASK
expr_stmt|;
comment|/* XXX needed for crypto errs */
name|flags
operator||=
name|HAL_TXDESC_INTREQ
expr_stmt|;
comment|/* force interrupt */
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_RTS
condition|)
name|flags
operator||=
name|HAL_TXDESC_RTSENA
expr_stmt|;
elseif|else
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_CTS
condition|)
name|flags
operator||=
name|HAL_TXDESC_CTSENA
expr_stmt|;
comment|/* XXX leave ismcast to injector? */
if|if
condition|(
operator|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_NOACK
operator|)
operator|||
name|ismcast
condition|)
name|flags
operator||=
name|HAL_TXDESC_NOACK
expr_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no rate table, mode %u"
operator|,
name|sc
operator|->
name|sc_curmode
operator|)
argument_list|)
expr_stmt|;
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate0
argument_list|)
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|sc
operator|->
name|sc_txrix
operator|=
name|rix
expr_stmt|;
name|try0
operator|=
name|params
operator|->
name|ibp_try0
expr_stmt|;
name|ismrr
operator|=
operator|(
name|params
operator|->
name|ibp_try1
operator|!=
literal|0
operator|)
expr_stmt|;
name|txantenna
operator|=
name|params
operator|->
name|ibp_pri
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|txantenna
operator|==
literal|0
condition|)
comment|/* XXX? */
name|txantenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
name|ctsduration
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|HAL_TXDESC_CTSENA
operator||
name|HAL_TXDESC_RTSENA
operator|)
condition|)
block|{
name|cix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_ctsrate
argument_list|)
expr_stmt|;
name|ctsrate
operator|=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
condition|)
block|{
name|ctsrate
operator||=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|shortPreamble
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_RTSENA
condition|)
comment|/* SIFS + CTS */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|spAckDuration
expr_stmt|;
name|ctsduration
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|pktlen
argument_list|,
name|rix
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
comment|/* SIFS + ACK */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|spAckDuration
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_RTSENA
condition|)
comment|/* SIFS + CTS */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|lpAckDuration
expr_stmt|;
name|ctsduration
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|pktlen
argument_list|,
name|rix
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
comment|/* SIFS + ACK */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|lpAckDuration
expr_stmt|;
block|}
name|ismrr
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
block|}
else|else
name|ctsrate
operator|=
literal|0
expr_stmt|;
name|pri
operator|=
name|params
operator|->
name|ibp_pri
operator|&
literal|3
expr_stmt|;
comment|/* 	 * NB: we mark all packets as type PSPOLL so the h/w won't 	 * set the sequence number, duration, etc. 	 */
name|atype
operator|=
name|HAL_PKT_TYPE_PSPOLL
expr_stmt|;
if|if
condition|(
name|IFF_DUMPPKTS
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|)
condition|)
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m0
operator|->
name|m_len
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|u_int64_t
name|tsf
init|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_tsf
operator|=
name|htole64
argument_list|(
name|tsf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|txflags
expr_stmt|;
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_WEP
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_FRAG
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_FRAG
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_rate
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_txpower
operator|=
name|ni
operator|->
name|ni_txpower
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_antenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Formulate first tx descriptor with tx controls. 	 */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
comment|/* XXX check return value? */
name|ath_hal_setuptxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|pktlen
comment|/* packet length */
argument_list|,
name|hdrlen
comment|/* header length */
argument_list|,
name|atype
comment|/* Atheros packet type */
argument_list|,
name|params
operator|->
name|ibp_power
comment|/* txpower */
argument_list|,
name|txrate
argument_list|,
name|try0
comment|/* series 0 rate/tries */
argument_list|,
name|keyix
comment|/* key cache index */
argument_list|,
name|txantenna
comment|/* antenna mode */
argument_list|,
name|flags
comment|/* flags */
argument_list|,
name|ctsrate
comment|/* rts/cts rate */
argument_list|,
name|ctsduration
comment|/* rts/cts duration */
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_txflags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|ismrr
condition|)
block|{
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate1
argument_list|)
expr_stmt|;
name|rate1
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
condition|)
name|rate1
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_try2
condition|)
block|{
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate2
argument_list|)
expr_stmt|;
name|rate2
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
condition|)
name|rate2
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
block|}
else|else
name|rate2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_try3
condition|)
block|{
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate3
argument_list|)
expr_stmt|;
name|rate3
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
condition|)
name|rate3
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
block|}
else|else
name|rate3
operator|=
literal|0
expr_stmt|;
name|ath_hal_setupxtxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|rate1
argument_list|,
name|params
operator|->
name|ibp_try1
comment|/* series 1 */
argument_list|,
name|rate2
argument_list|,
name|params
operator|->
name|ibp_try2
comment|/* series 2 */
argument_list|,
name|rate3
argument_list|,
name|params
operator|->
name|ibp_try3
comment|/* series 3 */
argument_list|)
expr_stmt|;
block|}
comment|/* NB: no buffered multicast in power save support */
name|ath_tx_handoff
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ac2q
index|[
name|pri
index|]
argument_list|,
name|bf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|sc_invalid
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: discard frame, %s"
argument_list|,
name|__func__
argument_list|,
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|?
literal|"!running"
else|:
literal|"invalid"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Grab a TX buffer and associated resources. 	 */
name|bf
operator|=
name|ath_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nobuf
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Legacy path; interpret frame contents to decide 		 * precisely how to send the frame. 		 */
if|if
condition|(
name|ath_tx_start
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
comment|/* XXX */
goto|goto
name|bad2
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * Caller supplied explicit parameters to use in 		 * sending the frame. 		 */
if|if
condition|(
name|ath_tx_raw_start
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m
argument_list|,
name|params
argument_list|)
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
comment|/* XXX */
goto|goto
name|bad2
goto|;
block|}
block|}
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|5
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_raw
operator|++
expr_stmt|;
return|return
literal|0
return|;
name|bad2
label|:
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bad
label|:
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_raw_fail
operator|++
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Announce various information on device/driver attach.  */
end_comment

begin_function
specifier|static
name|void
name|ath_announce
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"AR%s mac %d.%d RF%s phy %d.%d\n"
argument_list|,
name|ath_hal_mac_name
argument_list|(
name|ah
argument_list|)
argument_list|,
name|ah
operator|->
name|ah_macVersion
argument_list|,
name|ah
operator|->
name|ah_macRev
argument_list|,
name|ath_hal_rf_name
argument_list|(
name|ah
argument_list|)
argument_list|,
name|ah
operator|->
name|ah_phyRev
operator|>>
literal|4
argument_list|,
name|ah
operator|->
name|ah_phyRev
operator|&
literal|0xf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|WME_AC_VO
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ath_txq
modifier|*
name|txq
init|=
name|sc
operator|->
name|sc_ac2q
index|[
name|i
index|]
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Use hw queue %u for %s traffic\n"
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|ieee80211_wme_acnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Use hw queue %u for CAB traffic\n"
argument_list|,
name|sc
operator|->
name|sc_cabq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Use hw queue %u for beacons\n"
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ath_rxbuf
operator|!=
name|ATH_RXBUF
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"using %u rx buffers\n"
argument_list|,
name|ath_rxbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_txbuf
operator|!=
name|ATH_TXBUF
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"using %u tx buffers\n"
argument_list|,
name|ath_txbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_function
specifier|static
name|__inline
name|uint32_t
name|ath_hal_getnexttbtt
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
define|#
directive|define
name|AR_TIMER0
value|0x8028
return|return
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TIMER0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ath_hal_adjusttsf
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int32_t
name|tsfdelta
parameter_list|)
block|{
comment|/* XXX handle wrap/overflow */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|)
operator|+
name|tsfdelta
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tdma_settimers
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|nexttbtt
parameter_list|,
name|u_int32_t
name|bintval
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_BEACON_TIMERS
name|bt
decl_stmt|;
name|bt
operator|.
name|bt_intval
operator|=
name|bintval
operator||
name|HAL_BEACON_ENA
expr_stmt|;
name|bt
operator|.
name|bt_nexttbtt
operator|=
name|nexttbtt
expr_stmt|;
name|bt
operator|.
name|bt_nextdba
operator|=
operator|(
name|nexttbtt
operator|<<
literal|3
operator|)
operator|-
name|sc
operator|->
name|sc_tdmadbaprep
expr_stmt|;
name|bt
operator|.
name|bt_nextswba
operator|=
operator|(
name|nexttbtt
operator|<<
literal|3
operator|)
operator|-
name|sc
operator|->
name|sc_tdmaswbaprep
expr_stmt|;
name|bt
operator|.
name|bt_nextatim
operator|=
name|nexttbtt
operator|+
literal|1
expr_stmt|;
name|ath_hal_beaconsettimers
argument_list|(
name|ah
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Calculate the beacon interval.  This is periodic in the  * superframe for the bss.  We assume each station is configured  * identically wrt transmit rate so the guard time we calculate  * above will be the same on all stations.  Note we need to  * factor in the xmit time because the hardware will schedule  * a frame for transmit if the start of the frame is within  * the burst time.  When we get hardware that properly kills  * frames in the PCU we can reduce/eliminate the guard time.  *  * Roundup to 1024 is so we have 1 TU buffer in the guard time  * to deal with the granularity of the nexttbtt timer.  11n MAC's  * with 1us timer granularity should allow us to reduce/eliminate  * this.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tdma_bintvalsetup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ieee80211_tdma_state
modifier|*
name|tdma
parameter_list|)
block|{
comment|/* copy from vap state (XXX check all vaps have same value?) */
name|sc
operator|->
name|sc_tdmaslotlen
operator|=
name|tdma
operator|->
name|tdma_slotlen
expr_stmt|;
name|sc
operator|->
name|sc_tdmabintval
operator|=
name|roundup
argument_list|(
operator|(
name|sc
operator|->
name|sc_tdmaslotlen
operator|+
name|sc
operator|->
name|sc_tdmaguard
operator|)
operator|*
name|tdma
operator|->
name|tdma_slotcnt
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tdmabintval
operator|>>=
literal|10
expr_stmt|;
comment|/* TSF -> TU */
if|if
condition|(
name|sc
operator|->
name|sc_tdmabintval
operator|&
literal|1
condition|)
name|sc
operator|->
name|sc_tdmabintval
operator|++
expr_stmt|;
if|if
condition|(
name|tdma
operator|->
name|tdma_slot
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Only slot 0 beacons; other slots respond. 		 */
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_SWBA
expr_stmt|;
name|sc
operator|->
name|sc_tdmaswba
operator|=
literal|0
expr_stmt|;
comment|/* beacon immediately */
block|}
else|else
block|{
comment|/* XXX all vaps must be slot 0 or slot !0 */
name|sc
operator|->
name|sc_imask
operator|&=
operator|~
name|HAL_INT_SWBA
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Max 802.11 overhead.  This assumes no 4-address frames and  * the encapsulation done by ieee80211_encap (llc).  We also  * include potential crypto overhead.  */
end_comment

begin_define
define|#
directive|define
name|IEEE80211_MAXOVERHEAD
define|\
value|(sizeof(struct ieee80211_qosframe) \ 	 + sizeof(struct llc) \ 	 + IEEE80211_ADDR_LEN \ 	 + IEEE80211_WEP_IVLEN \ 	 + IEEE80211_WEP_KIDLEN \ 	 + IEEE80211_WEP_CRCLEN \ 	 + IEEE80211_WEP_MICLEN \ 	 + IEEE80211_CRC_LEN)
end_define

begin_comment
comment|/*  * Setup initially for tdma operation.  Start the beacon  * timers and enable SWBA if we are slot 0.  Otherwise  * we wait for slot 0 to arrive so we can sync up before  * starting to transmit.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tdma_config
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
specifier|const
name|struct
name|ieee80211_txparam
modifier|*
name|tp
decl_stmt|;
specifier|const
name|struct
name|ieee80211_tdma_state
modifier|*
name|tdma
init|=
name|NULL
decl_stmt|;
name|int
name|rix
decl_stmt|;
if|if
condition|(
name|vap
operator|==
name|NULL
condition|)
block|{
name|vap
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|vap
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: no vaps?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|tp
operator|=
name|vap
operator|->
name|iv_bss
operator|->
name|ni_txparms
expr_stmt|;
comment|/* 	 * Calculate the guard time for each slot.  This is the 	 * time to send a maximal-size frame according to the 	 * fixed/lowest transmit rate.  Note that the interface 	 * mtu does not include the 802.11 overhead so we must 	 * tack that on (ath_hal_computetxtime includes the 	 * preamble and plcp in it's calculation). 	 */
name|tdma
operator|=
name|vap
operator|->
name|iv_tdma
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|ucastrate
operator|!=
name|IEEE80211_FIXED_RATE_NONE
condition|)
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|tp
operator|->
name|ucastrate
argument_list|)
expr_stmt|;
else|else
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|tp
operator|->
name|mcastrate
argument_list|)
expr_stmt|;
comment|/* XXX short preamble assumed */
name|sc
operator|->
name|sc_tdmaguard
operator|=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_currates
argument_list|,
name|ifp
operator|->
name|if_mtu
operator|+
name|IEEE80211_MAXOVERHEAD
argument_list|,
name|rix
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ath_beaconq_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* setup h/w beacon q */
if|if
condition|(
name|sc
operator|->
name|sc_setcca
condition|)
name|ath_hal_setcca
argument_list|(
name|ah
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
comment|/* disable CCA */
name|ath_tdma_bintvalsetup
argument_list|(
name|sc
argument_list|,
name|tdma
argument_list|)
expr_stmt|;
comment|/* calculate beacon interval */
name|ath_tdma_settimers
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_tdmabintval
argument_list|,
name|sc
operator|->
name|sc_tdmabintval
operator||
name|HAL_BEACON_RESET_TSF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_avgtsfdeltap
operator|=
name|TDMA_DUMMY_MARKER
expr_stmt|;
name|sc
operator|->
name|sc_avgtsfdeltam
operator|=
name|TDMA_DUMMY_MARKER
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_TDMA
argument_list|,
literal|"%s: slot %u len %uus cnt %u "
literal|"bsched %u guard %uus bintval %u TU dba prep %u\n"
argument_list|,
name|__func__
argument_list|,
name|tdma
operator|->
name|tdma_slot
argument_list|,
name|tdma
operator|->
name|tdma_slotlen
argument_list|,
name|tdma
operator|->
name|tdma_slotcnt
argument_list|,
name|tdma
operator|->
name|tdma_bintval
argument_list|,
name|sc
operator|->
name|sc_tdmaguard
argument_list|,
name|sc
operator|->
name|sc_tdmabintval
argument_list|,
name|sc
operator|->
name|sc_tdmadbaprep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update tdma operation.  Called from the 802.11 layer  * when a beacon is received from the TDMA station operating  * in the slot immediately preceding us in the bss.  Use  * the rx timestamp for the beacon frame to update our  * beacon timers so we follow their schedule.  Note that  * by using the rx timestamp we implicitly include the  * propagation delay in our schedule.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tdma_update
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_tdma_param
modifier|*
name|tdma
parameter_list|,
name|int
name|changed
parameter_list|)
block|{
define|#
directive|define
name|TSF_TO_TU
parameter_list|(
name|_h
parameter_list|,
name|_l
parameter_list|)
define|\
value|((((u_int32_t)(_h))<< 22) | (((u_int32_t)(_l))>> 10))
define|#
directive|define
name|TU_TO_TSF
parameter_list|(
name|_tu
parameter_list|)
value|(((u_int64_t)(_tu))<< 10)
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
init|=
name|sc
operator|->
name|sc_currates
decl_stmt|;
name|u_int64_t
name|tsf
decl_stmt|,
name|rstamp
decl_stmt|,
name|nextslot
decl_stmt|;
name|u_int32_t
name|txtime
decl_stmt|,
name|nextslottu
decl_stmt|,
name|timer0
decl_stmt|;
name|int32_t
name|tudelta
decl_stmt|,
name|tsfdelta
decl_stmt|;
specifier|const
name|struct
name|ath_rx_status
modifier|*
name|rs
decl_stmt|;
name|int
name|rix
decl_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tdma_update
operator|++
expr_stmt|;
comment|/* 	 * Check for and adopt configuration changes. 	 */
if|if
condition|(
name|changed
operator|!=
literal|0
condition|)
block|{
specifier|const
name|struct
name|ieee80211_tdma_state
modifier|*
name|ts
init|=
name|vap
operator|->
name|iv_tdma
decl_stmt|;
name|ath_tdma_bintvalsetup
argument_list|(
name|sc
argument_list|,
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
operator|&
name|TDMA_UPDATE_SLOTLEN
condition|)
name|ath_wme_update
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_TDMA
argument_list|,
literal|"%s: adopt slot %u slotcnt %u slotlen %u us "
literal|"bintval %u TU\n"
argument_list|,
name|__func__
argument_list|,
name|ts
operator|->
name|tdma_slot
argument_list|,
name|ts
operator|->
name|tdma_slotcnt
argument_list|,
name|ts
operator|->
name|tdma_slotlen
argument_list|,
name|sc
operator|->
name|sc_tdmabintval
argument_list|)
expr_stmt|;
comment|/* XXX right? */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
comment|/* NB: beacon timers programmed below */
block|}
comment|/* extend rx timestamp to 64 bits */
name|rs
operator|=
name|sc
operator|->
name|sc_lastrs
expr_stmt|;
name|tsf
operator|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|rstamp
operator|=
name|ath_extend_tsf
argument_list|(
name|rs
operator|->
name|rs_tstamp
argument_list|,
name|tsf
argument_list|)
expr_stmt|;
comment|/* 	 * The rx timestamp is set by the hardware on completing 	 * reception (at the point where the rx descriptor is DMA'd 	 * to the host).  To find the start of our next slot we 	 * must adjust this time by the time required to send 	 * the packet just received. 	 */
name|rix
operator|=
name|rt
operator|->
name|rateCodeToIndex
index|[
name|rs
operator|->
name|rs_rate
index|]
expr_stmt|;
name|txtime
operator|=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|rs
operator|->
name|rs_datalen
argument_list|,
name|rix
argument_list|,
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
argument_list|)
expr_stmt|;
comment|/* NB:<< 9 is to cvt to TU and /2 */
name|nextslot
operator|=
operator|(
name|rstamp
operator|-
name|txtime
operator|)
operator|+
operator|(
name|sc
operator|->
name|sc_tdmabintval
operator|<<
literal|9
operator|)
expr_stmt|;
name|nextslottu
operator|=
name|TSF_TO_TU
argument_list|(
name|nextslot
operator|>>
literal|32
argument_list|,
name|nextslot
argument_list|)
operator|&
name|HAL_BEACON_PERIOD
expr_stmt|;
comment|/* 	 * TIMER0 is the h/w's idea of NextTBTT (in TU's).  Convert 	 * to usecs and calculate the difference between what the 	 * other station thinks and what we have programmed.  This 	 * lets us figure how to adjust our timers to match.  The 	 * adjustments are done by pulling the TSF forward and possibly 	 * rewriting the beacon timers. 	 */
name|timer0
operator|=
name|ath_hal_getnexttbtt
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|tsfdelta
operator|=
call|(
name|int32_t
call|)
argument_list|(
operator|(
name|nextslot
operator|%
name|TU_TO_TSF
argument_list|(
name|HAL_BEACON_PERIOD
operator|+
literal|1
argument_list|)
operator|)
operator|-
name|TU_TO_TSF
argument_list|(
name|timer0
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_TDMA_TIMER
argument_list|,
literal|"tsfdelta %d avg +%d/-%d\n"
argument_list|,
name|tsfdelta
argument_list|,
name|TDMA_AVG
argument_list|(
name|sc
operator|->
name|sc_avgtsfdeltap
argument_list|)
argument_list|,
name|TDMA_AVG
argument_list|(
name|sc
operator|->
name|sc_avgtsfdeltam
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsfdelta
operator|<
literal|0
condition|)
block|{
name|TDMA_SAMPLE
argument_list|(
name|sc
operator|->
name|sc_avgtsfdeltap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TDMA_SAMPLE
argument_list|(
name|sc
operator|->
name|sc_avgtsfdeltam
argument_list|,
operator|-
name|tsfdelta
argument_list|)
expr_stmt|;
name|tsfdelta
operator|=
operator|-
name|tsfdelta
operator|%
literal|1024
expr_stmt|;
name|nextslottu
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsfdelta
operator|>
literal|0
condition|)
block|{
name|TDMA_SAMPLE
argument_list|(
name|sc
operator|->
name|sc_avgtsfdeltap
argument_list|,
name|tsfdelta
argument_list|)
expr_stmt|;
name|TDMA_SAMPLE
argument_list|(
name|sc
operator|->
name|sc_avgtsfdeltam
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tsfdelta
operator|=
literal|1024
operator|-
operator|(
name|tsfdelta
operator|%
literal|1024
operator|)
expr_stmt|;
name|nextslottu
operator|++
expr_stmt|;
block|}
else|else
block|{
name|TDMA_SAMPLE
argument_list|(
name|sc
operator|->
name|sc_avgtsfdeltap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TDMA_SAMPLE
argument_list|(
name|sc
operator|->
name|sc_avgtsfdeltam
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|tudelta
operator|=
name|nextslottu
operator|-
name|timer0
expr_stmt|;
comment|/* 	 * Copy sender's timetstamp into tdma ie so they can 	 * calculate roundtrip time.  We submit a beacon frame 	 * below after any timer adjustment.  The frame goes out 	 * at the next TBTT so the sender can calculate the 	 * roundtrip by inspecting the tdma ie in our beacon frame. 	 * 	 * NB: This tstamp is subtlely preserved when 	 *     IEEE80211_BEACON_TDMA is marked (e.g. when the 	 *     slot position changes) because ieee80211_add_tdma 	 *     skips over the data. 	 */
name|memcpy
argument_list|(
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|av_boff
operator|.
name|bo_tdma
operator|+
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_tdma_param
argument_list|,
name|tdma_tstamp
argument_list|)
argument_list|,
operator|&
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|DPRINTF(sc, ATH_DEBUG_TDMA_TIMER, 	    "tsf %llu nextslot %llu (%d, %d) nextslottu %u timer0 %u (%d)\n", 	    (unsigned long long) tsf, (unsigned long long) nextslot, 	    (int)(nextslot - tsf), tsfdelta, 	    nextslottu, timer0, tudelta);
endif|#
directive|endif
comment|/* 	 * Adjust the beacon timers only when pulling them forward 	 * or when going back by less than the beacon interval. 	 * Negative jumps larger than the beacon interval seem to 	 * cause the timers to stop and generally cause instability. 	 * This basically filters out jumps due to missed beacons. 	 */
if|if
condition|(
name|tudelta
operator|!=
literal|0
operator|&&
operator|(
name|tudelta
operator|>
literal|0
operator|||
operator|-
name|tudelta
operator|<
name|sc
operator|->
name|sc_tdmabintval
operator|)
condition|)
block|{
name|ath_tdma_settimers
argument_list|(
name|sc
argument_list|,
name|nextslottu
argument_list|,
name|sc
operator|->
name|sc_tdmabintval
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tdma_timers
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tsfdelta
operator|>
literal|0
condition|)
block|{
name|ath_hal_adjusttsf
argument_list|(
name|ah
argument_list|,
name|tsfdelta
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tdma_tsf
operator|++
expr_stmt|;
block|}
name|ath_tdma_beacon_send
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
comment|/* prepare response */
undef|#
directive|undef
name|TU_TO_TSF
undef|#
directive|undef
name|TSF_TO_TU
block|}
end_function

begin_comment
comment|/*  * Transmit a beacon frame at SWBA.  Dynamic updates  * to the frame contents are done as needed.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tdma_beacon_send
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|int
name|otherant
decl_stmt|;
comment|/* 	 * Check if the previous beacon has gone out.  If 	 * not don't try to post another, skip this period 	 * and wait for the next.  Missed beacons indicate 	 * a problem and should not occur.  If we miss too 	 * many consecutive beacons reset the device. 	 */
if|if
condition|(
name|ath_hal_numtxpending
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_bmisscount
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: missed %u consecutive beacons\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bmisscount
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bmisscount
operator|>=
name|ath_bstuck_threshold
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_bstucktask
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_bmisscount
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: resume beacon xmit after %u misses\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bmisscount
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bmisscount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Check recent per-antenna transmit statistics and flip 	 * the default antenna if noticeably more frames went out 	 * on the non-default antenna. 	 * XXX assumes 2 anntenae 	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_diversity
condition|)
block|{
name|otherant
operator|=
name|sc
operator|->
name|sc_defant
operator|&
literal|1
condition|?
literal|2
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ant_tx
index|[
name|otherant
index|]
operator|>
name|sc
operator|->
name|sc_ant_tx
index|[
name|sc
operator|->
name|sc_defant
index|]
operator|+
literal|2
condition|)
name|ath_setdefantenna
argument_list|(
name|sc
argument_list|,
name|otherant
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ant_tx
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|sc_ant_tx
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|bf
operator|=
name|ath_beacon_generate
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Stop any current dma and put the new frame on the queue. 		 * This should never fail since we check above that no frames 		 * are still pending on the queue. 		 */
if|if
condition|(
operator|!
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: beacon queue %u did not stop?\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
comment|/* NB: the HAL still stops DMA, so proceed */
block|}
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|ath_hal_txstart
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_xmit
operator|++
expr_stmt|;
comment|/* XXX per-vap? */
comment|/* 		 * Record local TSF for our last send for use 		 * in arbitrating slot collisions. 		 */
name|vap
operator|->
name|iv_bss
operator|->
name|ni_tstamp
operator|.
name|tsf
operator|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IEEE80211_SUPPORT_TDMA */
end_comment

end_unit

