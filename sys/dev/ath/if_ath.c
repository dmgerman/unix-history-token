begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for the Atheros Wireless LAN controller.  *  * This software is derived from work of Atsushi Onoe; his contribution  * is greatly appreciated.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ath.h"
end_include

begin_comment
comment|/*  * This is needed for register operations which are performed  * by the driver - eg, calls to ath_hal_gettsf32().  *  * It's also required for any AH_DEBUG checks in here, eg the  * module dependencies.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_comment
comment|/* for mp_ncpus */
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_superg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_tdma.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ath/if_athvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/ath_hal/ah_devid.h>
end_include

begin_comment
comment|/* XXX for softled */
end_comment

begin_include
include|#
directive|include
file|<dev/ath/ath_hal/ah_diagcodes.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_misc.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tsf.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tx.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_led.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_keycache.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_rx.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_rx_edma.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tx_edma.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_beacon.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_btcoex.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_btcoex_mci.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_spectral.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_lna_div.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_athdfs.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_descdma.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
end_ifdef

begin_include
include|#
directive|include
file|<dev/ath/ath_tx99/ath_tx99.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_DEBUG_ALQ
end_ifdef

begin_include
include|#
directive|include
file|<dev/ath/if_ath_alq.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Only enable this if you're working on PS-POLL support.  */
end_comment

begin_define
define|#
directive|define
name|ATH_SW_PSQ
end_define

begin_comment
comment|/*  * ATH_BCBUF determines the number of vap's that can transmit  * beacons and also (currently) the number of vap's that can  * have unique mac addresses/bssid.  When staggering beacons  * 4 is probably a good max as otherwise the beacons become  * very closely spaced and there is limited time for cab q traffic  * to go out.  You can burst beacons instead but that is not good  * for stations in power save and at some point you really want  * another radio (and channel).  *  * The limit on the number of mac addresses is tied to our use of  * the U/L bit and tracking addresses in a byte; it would be  * worthwhile to allow more for applications like proxy sta.  */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
name|ATH_BCBUF
operator|<=
literal|8
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|ath_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
specifier|const
name|char
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
parameter_list|,
name|enum
name|ieee80211_opmode
parameter_list|,
name|int
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_stop
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_reset_vap
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_transmit
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_watchdog
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_parent
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_fatal_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_bmiss_vap
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_bmiss_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_key_update_begin
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_key_update_end
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_update_mcast_hw
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_update_mcast
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_update_promisc
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_updateslot
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_bstuck_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_reset_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_desc_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_desc_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|ath_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_node_cleanup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_node_free
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_node_getsignal
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int8_t
modifier|*
parameter_list|,
name|int8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_txq_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ath_txq
modifier|*
name|ath_txq_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|int
name|qtype
parameter_list|,
name|int
name|subtype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_tx_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_cleanupq
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ath_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_tx_processq
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|int
name|dosched
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_proc_q0
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_proc_q0123
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_txq_sched_tasklet
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_chan_set
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_chan_change
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_ENABLE_11N
end_ifdef

begin_function_decl
specifier|static
name|void
name|ath_update_chw
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATH_ENABLE_11N */
end_comment

begin_function_decl
specifier|static
name|int
name|ath_set_quiet_ie
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_calibrate
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_setup_stationkey
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_newassoc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_setregdomain
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|struct
name|ieee80211_regdomain
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ieee80211_channel
type|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_getradiocaps
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
type|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_getchannels
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_rate_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|u_int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_setcurmode
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|enum
name|ieee80211_phymode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_announce
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_dfs_tasklet
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_node_powersave
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_node_set_tim
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_node_recv_pspoll
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tdma.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_ath
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* XXX validate sysctl values */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ath_longcalinterval
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* long cals every 30 secs */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|longcal
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_longcalinterval
argument_list|,
literal|0
argument_list|,
literal|"long chip calibration interval (secs)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_shortcalinterval
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* short cals every 100 ms */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|shortcal
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_shortcalinterval
argument_list|,
literal|0
argument_list|,
literal|"short chip calibration interval (msecs)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_resetcalinterval
init|=
literal|20
operator|*
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reset cal state 20 mins */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|resetcal
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_resetcalinterval
argument_list|,
literal|0
argument_list|,
literal|"reset chip calibration results (secs)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_anicalinterval
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ANI calibration - 100 msec */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|anical
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_anicalinterval
argument_list|,
literal|0
argument_list|,
literal|"ANI calibration (msecs)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ath_rxbuf
init|=
name|ATH_RXBUF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # rx buffers to allocate */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|rxbuf
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|ath_rxbuf
argument_list|,
literal|0
argument_list|,
literal|"rx buffers allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ath_txbuf
init|=
name|ATH_TXBUF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # tx buffers to allocate */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|txbuf
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|ath_txbuf
argument_list|,
literal|0
argument_list|,
literal|"tx buffers allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ath_txbuf_mgmt
init|=
name|ATH_MGMT_TXBUF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # mgmt tx buffers to allocate */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|txbuf_mgmt
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|ath_txbuf_mgmt
argument_list|,
literal|0
argument_list|,
literal|"tx (mgmt) buffers allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ath_bstuck_threshold
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max missed beacons */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|bstuck
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_bstuck_threshold
argument_list|,
literal|0
argument_list|,
literal|"max missed beacon xmits before chip reset"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_ATHDEV
argument_list|,
literal|"athdev"
argument_list|,
literal|"ath driver dma buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|ath_legacy_attach_comp_func
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Special case certain configurations.  Note the 	 * CAB queue is handled by these specially so don't 	 * include them when checking the txq setup mask. 	 */
switch|switch
condition|(
name|sc
operator|->
name|sc_txqsetup
operator|&
operator|~
operator|(
literal|1
operator|<<
name|sc
operator|->
name|sc_cabq
operator|->
name|axq_qnum
operator|)
condition|)
block|{
case|case
literal|0x01
case|:
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txtask
argument_list|,
literal|0
argument_list|,
name|ath_tx_proc_q0
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0f
case|:
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txtask
argument_list|,
literal|0
argument_list|,
name|ath_tx_proc_q0123
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txtask
argument_list|,
literal|0
argument_list|,
name|ath_tx_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the target power mode.  *  * If this is called during a point in time where  * the hardware is being programmed elsewhere, it will  * simply store it away and update it when all current  * uses of the hardware are completed.  *  * If the chip is going into network sleep or power off, then  * we will wait until all uses of the chip are done before  * going into network sleep or power off.  *  * If the chip is being programmed full-awake, then immediately  * program it full-awake so we can actually stay awake rather than  * the chip potentially going to sleep underneath us.  */
end_comment

begin_function
name|void
name|_ath_power_setpower
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|power_state
parameter_list|,
name|int
name|selfgen
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|ATH_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_PWRSAVE
argument_list|,
literal|"%s: (%s:%d) state=%d, refcnt=%d, target=%d, cur=%d\n"
argument_list|,
name|__func__
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|power_state
argument_list|,
name|sc
operator|->
name|sc_powersave_refcnt
argument_list|,
name|sc
operator|->
name|sc_target_powerstate
argument_list|,
name|sc
operator|->
name|sc_cur_powerstate
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_target_powerstate
operator|=
name|power_state
expr_stmt|;
comment|/* 	 * Don't program the chip into network sleep if the chip 	 * is being programmed elsewhere. 	 * 	 * However, if the chip is being programmed /awake/, force 	 * the chip awake so we stay awake. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_powersave_refcnt
operator|==
literal|0
operator|||
name|power_state
operator|==
name|HAL_PM_AWAKE
operator|)
operator|&&
name|power_state
operator|!=
name|sc
operator|->
name|sc_cur_powerstate
condition|)
block|{
name|sc
operator|->
name|sc_cur_powerstate
operator|=
name|power_state
expr_stmt|;
name|ath_hal_setpower
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|power_state
argument_list|)
expr_stmt|;
comment|/* 		 * If the NIC is force-awake, then set the 		 * self-gen frame state appropriately. 		 * 		 * If the nic is in network sleep or full-sleep, 		 * we let the above call leave the self-gen 		 * state as "sleep". 		 */
if|if
condition|(
name|selfgen
operator|&&
name|sc
operator|->
name|sc_cur_powerstate
operator|==
name|HAL_PM_AWAKE
operator|&&
name|sc
operator|->
name|sc_target_selfgen_state
operator|!=
name|HAL_PM_AWAKE
condition|)
block|{
name|ath_hal_setselfgenpower
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_target_selfgen_state
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Set the current self-generated frames state.  *  * This is separate from the target power mode.  The chip may be  * awake but the desired state is "sleep", so frames sent to the  * destination has PWRMGT=1 in the 802.11 header.  The NIC also  * needs to know to set PWRMGT=1 in self-generated frames.  */
end_comment

begin_function
name|void
name|_ath_power_set_selfgen
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|power_state
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|ATH_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_PWRSAVE
argument_list|,
literal|"%s: (%s:%d) state=%d, refcnt=%d\n"
argument_list|,
name|__func__
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|power_state
argument_list|,
name|sc
operator|->
name|sc_target_selfgen_state
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_target_selfgen_state
operator|=
name|power_state
expr_stmt|;
comment|/* 	 * If the NIC is force-awake, then set the power state. 	 * Network-state and full-sleep will already transition it to 	 * mark self-gen frames as sleeping - and we can't 	 * guarantee the NIC is awake to program the self-gen frame 	 * setting anyway. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_cur_powerstate
operator|==
name|HAL_PM_AWAKE
condition|)
block|{
name|ath_hal_setselfgenpower
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|power_state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the hardware power mode and take a reference.  *  * This doesn't update the target power mode in the driver;  * it just updates the hardware power state.  *  * XXX it should only ever force the hardware awake; it should  * never be called to set it asleep.  */
end_comment

begin_function
name|void
name|_ath_power_set_power_state
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|power_state
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|ATH_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_PWRSAVE
argument_list|,
literal|"%s: (%s:%d) state=%d, refcnt=%d\n"
argument_list|,
name|__func__
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|power_state
argument_list|,
name|sc
operator|->
name|sc_powersave_refcnt
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_powersave_refcnt
operator|++
expr_stmt|;
comment|/* 	 * Only do the power state change if we're not programming 	 * it elsewhere. 	 */
if|if
condition|(
name|power_state
operator|!=
name|sc
operator|->
name|sc_cur_powerstate
condition|)
block|{
name|ath_hal_setpower
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|power_state
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cur_powerstate
operator|=
name|power_state
expr_stmt|;
comment|/* 		 * Adjust the self-gen powerstate if appropriate. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_cur_powerstate
operator|==
name|HAL_PM_AWAKE
operator|&&
name|sc
operator|->
name|sc_target_selfgen_state
operator|!=
name|HAL_PM_AWAKE
condition|)
block|{
name|ath_hal_setselfgenpower
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_target_selfgen_state
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Restore the power save mode to what it once was.  *  * This will decrement the reference counter and once it hits  * zero, it'll restore the powersave state.  */
end_comment

begin_function
name|void
name|_ath_power_restore_power_state
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|ATH_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_PWRSAVE
argument_list|,
literal|"%s: (%s:%d) refcnt=%d, target state=%d\n"
argument_list|,
name|__func__
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|sc
operator|->
name|sc_powersave_refcnt
argument_list|,
name|sc
operator|->
name|sc_target_powerstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_powersave_refcnt
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: refcnt=0?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|sc_powersave_refcnt
operator|--
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_powersave_refcnt
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_target_powerstate
operator|!=
name|sc
operator|->
name|sc_cur_powerstate
condition|)
block|{
name|sc
operator|->
name|sc_cur_powerstate
operator|=
name|sc
operator|->
name|sc_target_powerstate
expr_stmt|;
name|ath_hal_setpower
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_target_powerstate
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Adjust the self-gen powerstate if appropriate. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_cur_powerstate
operator|==
name|HAL_PM_AWAKE
operator|&&
name|sc
operator|->
name|sc_target_selfgen_state
operator|!=
name|HAL_PM_AWAKE
condition|)
block|{
name|ath_hal_setselfgenpower
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_target_selfgen_state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Configure the initial HAL configuration values based on bus  * specific parameters.  *  * Some PCI IDs and other information may need tweaking.  *  * XXX TODO: ath9k and the Atheros HAL only program comm2g_switch_enable  * if BT antenna diversity isn't enabled.  *  * So, let's also figure out how to enable BT diversity for AR9485.  */
end_comment

begin_function
specifier|static
name|void
name|ath_setup_hal_config
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|HAL_OPS_CONFIG
modifier|*
name|ah_config
parameter_list|)
block|{
comment|/* XXX TODO: only for PCI devices? */
if|if
condition|(
name|sc
operator|->
name|sc_pci_devinfo
operator|&
operator|(
name|ATH_PCI_CUS198
operator||
name|ATH_PCI_CUS230
operator|)
condition|)
block|{
name|ah_config
operator|->
name|ath_hal_ext_lna_ctl_gpio
operator|=
literal|0x200
expr_stmt|;
comment|/* bit 9 */
name|ah_config
operator|->
name|ath_hal_ext_atten_margin_cfg
operator|=
name|AH_TRUE
expr_stmt|;
name|ah_config
operator|->
name|ath_hal_min_gainidx
operator|=
name|AH_TRUE
expr_stmt|;
name|ah_config
operator|->
name|ath_hal_ant_ctrl_comm2g_switch_enable
operator|=
literal|0x000bbb88
expr_stmt|;
comment|/* XXX low_rssi_thresh */
comment|/* XXX fast_div_bias */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"configuring for %s\n"
argument_list|,
operator|(
name|sc
operator|->
name|sc_pci_devinfo
operator|&
name|ATH_PCI_CUS198
operator|)
condition|?
literal|"CUS198"
else|:
literal|"CUS230"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_pci_devinfo
operator|&
name|ATH_PCI_CUS217
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"CUS217 card detected\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_pci_devinfo
operator|&
name|ATH_PCI_CUS252
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"CUS252 card detected\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_pci_devinfo
operator|&
name|ATH_PCI_AR9565_1ANT
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"WB335 1-ANT card detected\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_pci_devinfo
operator|&
name|ATH_PCI_AR9565_2ANT
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"WB335 2-ANT card detected\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_pci_devinfo
operator|&
name|ATH_PCI_BT_ANT_DIV
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Bluetooth Antenna Diversity card detected\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_pci_devinfo
operator|&
name|ATH_PCI_KILLER
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Killer Wireless card detected\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/*          * Some WB335 cards do not support antenna diversity. Since          * we use a hardcoded value for AR9565 instead of using the          * EEPROM/OTP data, remove the combining feature from          * the HW capabilities bitmap.          */
block|if (sc->sc_pci_devinfo& (ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_AR9565_2ANT)) {                 if (!(sc->sc_pci_devinfo& ATH9K_PCI_BT_ANT_DIV))                         pCap->hw_caps&= ~ATH9K_HW_CAP_ANT_DIV_COMB;         }          if (sc->sc_pci_devinfo& ATH9K_PCI_BT_ANT_DIV) {                 pCap->hw_caps |= ATH9K_HW_CAP_BT_ANT_DIV;                 device_printf(sc->sc_dev, "Set BT/WLAN RX diversity capability\n");         }
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_pci_devinfo
operator|&
name|ATH_PCI_D3_L1_WAR
condition|)
block|{
name|ah_config
operator|->
name|ath_hal_pcie_waen
operator|=
literal|0x0040473b
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Enable WAR for ASPM D3/L1\n"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (sc->sc_pci_devinfo& ATH9K_PCI_NO_PLL_PWRSAVE) {                 ah->config.no_pll_pwrsave = true;                 device_printf(sc->sc_dev, "Disable PLL PowerSave\n");         }
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Attempt to fetch the MAC address from the kernel environment.  *  * Returns 0, macaddr in macaddr if successful; -1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ath_fetch_mac_kenv
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|macaddr
parameter_list|)
block|{
name|char
name|devid_str
index|[
literal|32
index|]
decl_stmt|;
name|int
name|local_mac
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|local_macstr
decl_stmt|;
comment|/* 	 * Fetch from the kenv rather than using hints. 	 * 	 * Hints would be nice but the transition to dynamic 	 * hints/kenv doesn't happen early enough for this 	 * to work reliably (eg on anything embedded.) 	 */
name|snprintf
argument_list|(
name|devid_str
argument_list|,
literal|32
argument_list|,
literal|"hint.%s.%d.macaddr"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|local_macstr
operator|=
name|kern_getenv
argument_list|(
name|devid_str
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|uint32_t
name|tmpmac
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Have a MAC address; should use it */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Overriding MAC address from environment: '%s'\n"
argument_list|,
name|local_macstr
argument_list|)
expr_stmt|;
comment|/* Extract out the MAC address */
name|count
operator|=
name|sscanf
argument_list|(
name|local_macstr
argument_list|,
literal|"%x%*c%x%*c%x%*c%x%*c%x%*c%x"
argument_list|,
operator|&
name|tmpmac
index|[
literal|0
index|]
argument_list|,
operator|&
name|tmpmac
index|[
literal|1
index|]
argument_list|,
operator|&
name|tmpmac
index|[
literal|2
index|]
argument_list|,
operator|&
name|tmpmac
index|[
literal|3
index|]
argument_list|,
operator|&
name|tmpmac
index|[
literal|4
index|]
argument_list|,
operator|&
name|tmpmac
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|6
condition|)
block|{
comment|/* Valid! */
name|local_mac
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|macaddr
index|[
name|i
index|]
operator|=
name|tmpmac
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Done! */
name|freeenv
argument_list|(
name|local_macstr
argument_list|)
expr_stmt|;
name|local_macstr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|local_mac
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HAL_MODE_HT20
value|(HAL_MODE_11NG_HT20 | HAL_MODE_11NA_HT20)
end_define

begin_define
define|#
directive|define
name|HAL_MODE_HT40
define|\
value|(HAL_MODE_11NG_HT40PLUS | HAL_MODE_11NG_HT40MINUS | \ 	HAL_MODE_11NA_HT40PLUS | HAL_MODE_11NA_HT40MINUS)
end_define

begin_function
name|int
name|ath_attach
parameter_list|(
name|u_int16_t
name|devid
parameter_list|,
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|NULL
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|u_int
name|wmodes
decl_stmt|;
name|int
name|rx_chainmask
decl_stmt|,
name|tx_chainmask
decl_stmt|;
name|HAL_OPS_CONFIG
name|ah_config
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: devid 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|devid
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_softc
operator|=
name|sc
expr_stmt|;
name|ic
operator|->
name|ic_name
operator|=
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
comment|/* 	 * Configure the initial configuration data. 	 * 	 * This is stuff that may be needed early during attach 	 * rather than done via configuration calls later. 	 */
name|bzero
argument_list|(
operator|&
name|ah_config
argument_list|,
sizeof|sizeof
argument_list|(
name|ah_config
argument_list|)
argument_list|)
expr_stmt|;
name|ath_setup_hal_config
argument_list|(
name|sc
argument_list|,
operator|&
name|ah_config
argument_list|)
expr_stmt|;
name|ah
operator|=
name|ath_hal_attach
argument_list|(
name|devid
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_sh
argument_list|,
name|sc
operator|->
name|sc_eepromdata
argument_list|,
operator|&
name|ah_config
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ah
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to attach hardware; HAL status %u\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|sc_ah
operator|=
name|ah
expr_stmt|;
name|sc
operator|->
name|sc_invalid
operator|=
literal|0
expr_stmt|;
comment|/* ready to go, enable interrupt handling */
ifdef|#
directive|ifdef
name|ATH_DEBUG
name|sc
operator|->
name|sc_debug
operator|=
name|ath_debug
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Force the chip awake during setup, just to keep 	 * the HAL/driver power tracking happy. 	 * 	 * There are some methods (eg ath_hal_setmac()) 	 * that poke the hardware. 	 */
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_setpower
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Setup the DMA/EDMA functions based on the current 	 * hardware support. 	 * 	 * This is required before the descriptors are allocated. 	 */
if|if
condition|(
name|ath_hal_hasedma
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_isedma
operator|=
literal|1
expr_stmt|;
name|ath_recv_setup_edma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_xmit_setup_edma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ath_recv_setup_legacy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_xmit_setup_legacy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ath_hal_hasmybeacon
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_do_mybeacon
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Check if the MAC has multi-rate retry support. 	 * We do this by trying to setup a fake extended 	 * descriptor.  MAC's that don't have support will 	 * return false w/o doing anything.  MAC's that do 	 * support it will return true w/o doing anything. 	 */
name|sc
operator|->
name|sc_mrretry
operator|=
name|ath_hal_setupxtxdesc
argument_list|(
name|ah
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Check if the device has hardware counters for PHY 	 * errors.  If so we need to enable the MIB interrupt 	 * so we can act on stat triggers. 	 */
if|if
condition|(
name|ath_hal_hwphycounters
argument_list|(
name|ah
argument_list|)
condition|)
name|sc
operator|->
name|sc_needmib
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Get the hardware key cache size. 	 */
name|sc
operator|->
name|sc_keymax
operator|=
name|ath_hal_keycachesize
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_keymax
operator|>
name|ATH_KEYMAX
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Warning, using only %u of %u key cache slots\n"
argument_list|,
name|ATH_KEYMAX
argument_list|,
name|sc
operator|->
name|sc_keymax
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_keymax
operator|=
name|ATH_KEYMAX
expr_stmt|;
block|}
comment|/* 	 * Reset the key cache since some parts do not 	 * reset the contents on initial power up. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_keymax
condition|;
name|i
operator|++
control|)
name|ath_hal_keyreset
argument_list|(
name|ah
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Collect the default channel list. 	 */
name|error
operator|=
name|ath_getchannels
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Setup rate tables for all potential media types. 	 */
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11A
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11B
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_TURBO_A
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_TURBO_G
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_STURBO_A
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11NA
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11NG
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_HALF
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_QUARTER
argument_list|)
expr_stmt|;
comment|/* NB: setup here so ath_rate_update is happy */
name|ath_setcurmode
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11A
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate TX descriptors and populate the lists. 	 */
name|error
operator|=
name|ath_desc_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to allocate TX descriptors: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|error
operator|=
name|ath_txdma_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to allocate TX descriptors: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Allocate RX descriptors and populate the lists. 	 */
name|error
operator|=
name|ath_rxdma_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to allocate RX descriptors: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_wd_ch
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ATH_TXBUF_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tq
operator|=
name|taskqueue_create
argument_list|(
literal|"ath_taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|sc_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxtask
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_rx
operator|.
name|recv_tasklet
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bmisstask
argument_list|,
literal|0
argument_list|,
name|ath_bmiss_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bstucktask
argument_list|,
literal|0
argument_list|,
name|ath_bstuck_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_resettask
argument_list|,
literal|0
argument_list|,
name|ath_reset_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txqtask
argument_list|,
literal|0
argument_list|,
name|ath_txq_sched_tasklet
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_fataltask
argument_list|,
literal|0
argument_list|,
name|ath_fatal_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate hardware transmit queues: one queue for 	 * beacon frames and one data queue for each QoS 	 * priority.  Note that the hal handles resetting 	 * these queues at the needed time. 	 * 	 * XXX PS-Poll 	 */
name|sc
operator|->
name|sc_bhalq
operator|=
name|ath_beaconq_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bhalq
operator|==
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to setup a beacon xmit queue!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|sc
operator|->
name|sc_cabq
operator|=
name|ath_txq_setup
argument_list|(
name|sc
argument_list|,
name|HAL_TX_QUEUE_CAB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cabq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to setup CAB xmit queue!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
comment|/* NB: insure BK queue is the lowest priority h/w queue */
if|if
condition|(
operator|!
name|ath_tx_setup
argument_list|(
name|sc
argument_list|,
name|WME_AC_BK
argument_list|,
name|HAL_WME_AC_BK
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to setup xmit queue for %s traffic!\n"
argument_list|,
name|ieee80211_wme_acnames
index|[
name|WME_AC_BK
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
if|if
condition|(
operator|!
name|ath_tx_setup
argument_list|(
name|sc
argument_list|,
name|WME_AC_BE
argument_list|,
name|HAL_WME_AC_BE
argument_list|)
operator|||
operator|!
name|ath_tx_setup
argument_list|(
name|sc
argument_list|,
name|WME_AC_VI
argument_list|,
name|HAL_WME_AC_VI
argument_list|)
operator|||
operator|!
name|ath_tx_setup
argument_list|(
name|sc
argument_list|,
name|WME_AC_VO
argument_list|,
name|HAL_WME_AC_VO
argument_list|)
condition|)
block|{
comment|/* 		 * Not enough hardware tx queues to properly do WME; 		 * just punt and assign them all to the same h/w queue. 		 * We could do a better job of this if, for example, 		 * we allocate queues when we switch from station to 		 * AP mode. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_VI
index|]
operator|!=
name|NULL
condition|)
name|ath_tx_cleanupq
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_VI
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BE
index|]
operator|!=
name|NULL
condition|)
name|ath_tx_cleanupq
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BE
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BE
index|]
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BK
index|]
expr_stmt|;
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_VI
index|]
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BK
index|]
expr_stmt|;
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_VO
index|]
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BK
index|]
expr_stmt|;
block|}
comment|/* 	 * Attach the TX completion function. 	 * 	 * The non-EDMA chips may have some special case optimisations; 	 * this method gives everyone a chance to attach cleanly. 	 */
name|sc
operator|->
name|sc_tx
operator|.
name|xmit_attach_comp_func
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Setup rate control.  Some rate control modules 	 * call back to change the anntena state so expose 	 * the necessary entry points. 	 * XXX maybe belongs in struct ath_ratectrl? 	 */
name|sc
operator|->
name|sc_setdefantenna
operator|=
name|ath_setdefantenna
expr_stmt|;
name|sc
operator|->
name|sc_rc
operator|=
name|ath_rate_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rc
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
comment|/* Attach DFS module */
if|if
condition|(
operator|!
name|ath_dfs_attach
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: unable to attach DFS\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
comment|/* Attach spectral module */
if|if
condition|(
name|ath_spectral_attach
argument_list|(
name|sc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: unable to attach spectral\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
comment|/* Attach bluetooth coexistence module */
if|if
condition|(
name|ath_btcoex_attach
argument_list|(
name|sc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: unable to attach bluetooth coexistence\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
comment|/* Attach LNA diversity module */
if|if
condition|(
name|ath_lna_div_attach
argument_list|(
name|sc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: unable to attach LNA diversity\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
comment|/* Start DFS processing tasklet */
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_dfstask
argument_list|,
literal|0
argument_list|,
name|ath_dfs_tasklet
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Configure LED state */
name|sc
operator|->
name|sc_blinking
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ledstate
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_ledon
operator|=
literal|0
expr_stmt|;
comment|/* low true */
name|sc
operator|->
name|sc_ledidle
operator|=
operator|(
literal|2700
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
comment|/* 2.7sec */
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_ledtimer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Don't setup hardware-based blinking. 	 * 	 * Although some NICs may have this configured in the 	 * default reset register values, the user may wish 	 * to alter which pins have which function. 	 * 	 * The reference driver attaches the MAC network LED to GPIO1 and 	 * the MAC power LED to GPIO2.  However, the DWA-552 cardbus 	 * NIC has these reversed. 	 */
name|sc
operator|->
name|sc_hardled
operator|=
operator|(
literal|1
operator|==
literal|0
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_led_net_pin
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_led_pwr_pin
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Auto-enable soft led processing for IBM cards and for 	 * 5211 minipci cards.  Users can also manually enable/disable 	 * support with a sysctl. 	 */
name|sc
operator|->
name|sc_softled
operator|=
operator|(
name|devid
operator|==
name|AR5212_DEVID_IBM
operator|||
name|devid
operator|==
name|AR5211_DEVID
operator|)
expr_stmt|;
name|ath_led_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_setledstate
argument_list|(
name|ah
argument_list|,
name|HAL_LED_INIT
argument_list|)
expr_stmt|;
comment|/* XXX not right but it's not used anywhere important */
name|ic
operator|->
name|ic_phytype
operator|=
name|IEEE80211_T_OFDM
expr_stmt|;
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_STA
expr_stmt|;
name|ic
operator|->
name|ic_caps
operator|=
name|IEEE80211_C_STA
comment|/* station mode */
operator||
name|IEEE80211_C_IBSS
comment|/* ibss, nee adhoc, mode */
operator||
name|IEEE80211_C_HOSTAP
comment|/* hostap mode */
operator||
name|IEEE80211_C_MONITOR
comment|/* monitor mode */
operator||
name|IEEE80211_C_AHDEMO
comment|/* adhoc demo mode */
operator||
name|IEEE80211_C_WDS
comment|/* 4-address traffic works */
operator||
name|IEEE80211_C_MBSS
comment|/* mesh point link mode */
operator||
name|IEEE80211_C_SHPREAMBLE
comment|/* short preamble supported */
operator||
name|IEEE80211_C_SHSLOT
comment|/* short slot time supported */
operator||
name|IEEE80211_C_WPA
comment|/* capable of WPA1+WPA2 */
ifndef|#
directive|ifndef
name|ATH_ENABLE_11N
operator||
name|IEEE80211_C_BGSCAN
comment|/* capable of bg scanning */
endif|#
directive|endif
operator||
name|IEEE80211_C_TXFRAG
comment|/* handle tx frags */
ifdef|#
directive|ifdef
name|ATH_ENABLE_DFS
operator||
name|IEEE80211_C_DFS
comment|/* Enable radar detection */
endif|#
directive|endif
operator||
name|IEEE80211_C_PMGT
comment|/* Station side power mgmt */
operator||
name|IEEE80211_C_SWSLEEP
expr_stmt|;
comment|/* 	 * Query the hal to figure out h/w crypto support. 	 */
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_WEP
argument_list|)
condition|)
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_WEP
expr_stmt|;
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_AES_OCB
argument_list|)
condition|)
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_AES_OCB
expr_stmt|;
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_AES_CCM
argument_list|)
condition|)
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_AES_CCM
expr_stmt|;
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_CKIP
argument_list|)
condition|)
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_CKIP
expr_stmt|;
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_TKIP
argument_list|)
condition|)
block|{
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_TKIP
expr_stmt|;
comment|/* 		 * Check if h/w does the MIC and/or whether the 		 * separate key cache entries are required to 		 * handle both tx+rx MIC keys. 		 */
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_MIC
argument_list|)
condition|)
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_TKIPMIC
expr_stmt|;
comment|/* 		 * If the h/w supports storing tx+rx MIC keys 		 * in one cache slot automatically enable use. 		 */
if|if
condition|(
name|ath_hal_hastkipsplit
argument_list|(
name|ah
argument_list|)
operator|||
operator|!
name|ath_hal_settkipsplit
argument_list|(
name|ah
argument_list|,
name|AH_FALSE
argument_list|)
condition|)
name|sc
operator|->
name|sc_splitmic
operator|=
literal|1
expr_stmt|;
comment|/* 		 * If the h/w can do TKIP MIC together with WME then 		 * we use it; otherwise we force the MIC to be done 		 * in software by the net80211 layer. 		 */
if|if
condition|(
name|ath_hal_haswmetkipmic
argument_list|(
name|ah
argument_list|)
condition|)
name|sc
operator|->
name|sc_wmetkipmic
operator|=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|sc_hasclrkey
operator|=
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_CLR
argument_list|)
expr_stmt|;
comment|/* 	 * Check for multicast key search support. 	 */
if|if
condition|(
name|ath_hal_hasmcastkeysearch
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
operator|&&
operator|!
name|ath_hal_getmcastkeysearch
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
condition|)
block|{
name|ath_hal_setmcastkeysearch
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_mcastkey
operator|=
name|ath_hal_getmcastkeysearch
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 	 * Mark key cache slots associated with global keys 	 * as in use.  If we knew TKIP was not to be used we 	 * could leave the +32, +64, and +32+64 slots free. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_WEP_NKID
condition|;
name|i
operator|++
control|)
block|{
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|i
operator|+
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_splitmic
condition|)
block|{
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|i
operator|+
literal|32
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|i
operator|+
literal|32
operator|+
literal|64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * TPC support can be done either with a global cap or 	 * per-packet support.  The latter is not available on 	 * all parts.  We're a bit pedantic here as all parts 	 * support a global cap. 	 */
if|if
condition|(
name|ath_hal_hastpc
argument_list|(
name|ah
argument_list|)
operator|||
name|ath_hal_hastxpowlimit
argument_list|(
name|ah
argument_list|)
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_TXPMGT
expr_stmt|;
comment|/* 	 * Mark WME capability only if we have sufficient 	 * hardware queues to do proper priority scheduling. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BE
index|]
operator|!=
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BK
index|]
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_WME
expr_stmt|;
comment|/* 	 * Check for misc other capabilities. 	 */
if|if
condition|(
name|ath_hal_hasbursting
argument_list|(
name|ah
argument_list|)
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_BURST
expr_stmt|;
name|sc
operator|->
name|sc_hasbmask
operator|=
name|ath_hal_hasbssidmask
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_hasbmatch
operator|=
name|ath_hal_hasbssidmatch
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_hastsfadd
operator|=
name|ath_hal_hastsfadjust
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxslink
operator|=
name|ath_hal_self_linked_final_rxdesc
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* XXX TODO: just make this a "store tx/rx timestamp length" operation */
if|if
condition|(
name|ath_hal_get_rx_tsf_prec
argument_list|(
name|ah
argument_list|,
operator|&
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|32
condition|)
block|{
name|sc
operator|->
name|sc_rxtsf32
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"RX timestamp: %d bits\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ath_hal_get_tx_tsf_prec
argument_list|(
name|ah
argument_list|,
operator|&
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"TX timestamp: %d bits\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_hasenforcetxop
operator|=
name|ath_hal_hasenforcetxop
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rx_lnamixer
operator|=
name|ath_hal_hasrxlnamixer
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_hasdivcomb
operator|=
name|ath_hal_hasdivantcomb
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 	 * Some WB335 cards do not support antenna diversity. Since 	 * we use a hardcoded value for AR9565 instead of using the 	 * EEPROM/OTP data, remove the combining feature from 	 * the HW capabilities bitmap. 	 */
comment|/* 	 * XXX TODO: check reference driver and ath9k for what to do 	 * here for WB335.  I think we have to actually disable the 	 * LNA div processing in the HAL and instead use the hard 	 * coded values; and then use BT diversity. 	 * 	 * .. but also need to setup MCI too for WB335.. 	 */
if|#
directive|if
literal|0
block|if (sc->sc_pci_devinfo& (ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_AR9565_2ANT)) { 		device_printf(sc->sc_dev, "%s: WB335: disabling LNA mixer diversity\n", 		    __func__); 		sc->sc_dolnadiv = 0; 	}
endif|#
directive|endif
if|if
condition|(
name|ath_hal_hasfastframes
argument_list|(
name|ah
argument_list|)
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_FF
expr_stmt|;
name|wmodes
operator|=
name|ath_hal_getwirelessmodes
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|wmodes
operator|&
operator|(
name|HAL_MODE_108G
operator||
name|HAL_MODE_TURBO
operator|)
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_TURBOP
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|ath_hal_macversion
argument_list|(
name|ah
argument_list|)
operator|>
literal|0x78
condition|)
block|{
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_TDMA
expr_stmt|;
comment|/* capable of TDMA */
name|ic
operator|->
name|ic_tdma_update
operator|=
name|ath_tdma_update
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * TODO: enforce that at least this many frames are available 	 * in the txbuf list before allowing data frames (raw or 	 * otherwise) to be transmitted. 	 */
name|sc
operator|->
name|sc_txq_data_minfree
operator|=
literal|10
expr_stmt|;
comment|/* 	 * Shorten this to 64 packets, or 1/4 ath_txbuf, whichever 	 * is smaller. 	 * 	 * Anything bigger can potentially see the cabq consume 	 * almost all buffers, starving everything else, only to 	 * see most fail to transmit in the given beacon interval. 	 */
name|sc
operator|->
name|sc_txq_mcastq_maxdepth
operator|=
name|MIN
argument_list|(
literal|64
argument_list|,
name|ath_txbuf
operator|/
literal|4
argument_list|)
expr_stmt|;
comment|/* 	 * How deep can the node software TX queue get whilst it's asleep. 	 */
name|sc
operator|->
name|sc_txq_node_psq_maxdepth
operator|=
literal|16
expr_stmt|;
comment|/* 	 * Default the maximum queue to to 1/4'th the TX buffers, or 	 * 64, whichever is smaller. 	 */
name|sc
operator|->
name|sc_txq_node_maxdepth
operator|=
name|MIN
argument_list|(
literal|64
argument_list|,
name|ath_txbuf
operator|/
literal|4
argument_list|)
expr_stmt|;
comment|/* Enable CABQ by default */
name|sc
operator|->
name|sc_cabq_enable
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Allow the TX and RX chainmasks to be overridden by 	 * environment variables and/or device.hints. 	 * 	 * This must be done early - before the hardware is 	 * calibrated or before the 802.11n stream calculation 	 * is done. 	 */
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"rx_chainmask"
argument_list|,
operator|&
name|rx_chainmask
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Setting RX chainmask to 0x%x\n"
argument_list|,
name|rx_chainmask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_hal_setrxchainmask
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|rx_chainmask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"tx_chainmask"
argument_list|,
operator|&
name|tx_chainmask
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Setting TX chainmask to 0x%x\n"
argument_list|,
name|tx_chainmask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_hal_settxchainmask
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|tx_chainmask
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Query the TX/RX chainmask configuration. 	 * 	 * This is only relevant for 11n devices. 	 */
name|ath_hal_getrxchainmask
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxchainmask
argument_list|)
expr_stmt|;
name|ath_hal_gettxchainmask
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_txchainmask
argument_list|)
expr_stmt|;
comment|/* 	 * Disable MRR with protected frames by default. 	 * Only 802.11n series NICs can handle this. 	 */
name|sc
operator|->
name|sc_mrrprot
operator|=
literal|0
expr_stmt|;
comment|/* XXX should be a capability */
comment|/* 	 * Query the enterprise mode information the HAL. 	 */
if|if
condition|(
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_ENTERPRISE_MODE
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_ent_cfg
argument_list|)
operator|==
name|HAL_OK
condition|)
name|sc
operator|->
name|sc_use_ent
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_ENABLE_11N
comment|/* 	 * Query HT capabilities 	 */
if|if
condition|(
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_HT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|==
name|HAL_OK
operator|&&
operator|(
name|wmodes
operator|&
operator|(
name|HAL_MODE_HT20
operator||
name|HAL_MODE_HT40
operator|)
operator|)
condition|)
block|{
name|uint32_t
name|rxs
decl_stmt|,
name|txs
decl_stmt|;
name|uint32_t
name|ldpc
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"[HT] enabling HT modes\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mrrprot
operator|=
literal|1
expr_stmt|;
comment|/* XXX should be a capability */
name|ic
operator|->
name|ic_htcaps
operator|=
name|IEEE80211_HTC_HT
comment|/* HT operation */
operator||
name|IEEE80211_HTC_AMPDU
comment|/* A-MPDU tx/rx */
operator||
name|IEEE80211_HTC_AMSDU
comment|/* A-MSDU tx/rx */
operator||
name|IEEE80211_HTCAP_MAXAMSDU_3839
comment|/* max A-MSDU length */
operator||
name|IEEE80211_HTCAP_SMPS_OFF
expr_stmt|;
comment|/* SM power save off */
comment|/* 		 * Enable short-GI for HT20 only if the hardware 		 * advertises support. 		 * Notably, anything earlier than the AR9287 doesn't. 		 */
if|if
condition|(
operator|(
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_HT20_SGI
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|==
name|HAL_OK
operator|)
operator|&&
operator|(
name|wmodes
operator|&
name|HAL_MODE_HT20
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"[HT] enabling short-GI in 20MHz mode\n"
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_htcaps
operator||=
name|IEEE80211_HTCAP_SHORTGI20
expr_stmt|;
block|}
if|if
condition|(
name|wmodes
operator|&
name|HAL_MODE_HT40
condition|)
name|ic
operator|->
name|ic_htcaps
operator||=
name|IEEE80211_HTCAP_CHWIDTH40
operator||
name|IEEE80211_HTCAP_SHORTGI40
expr_stmt|;
comment|/* 		 * TX/RX streams need to be taken into account when 		 * negotiating which MCS rates it'll receive and 		 * what MCS rates are available for TX. 		 */
operator|(
name|void
operator|)
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_STREAMS
argument_list|,
literal|0
argument_list|,
operator|&
name|txs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_STREAMS
argument_list|,
literal|1
argument_list|,
operator|&
name|rxs
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_txstream
operator|=
name|txs
expr_stmt|;
name|ic
operator|->
name|ic_rxstream
operator|=
name|rxs
expr_stmt|;
comment|/* 		 * Setup TX and RX STBC based on what the HAL allows and 		 * the currently configured chainmask set. 		 * Ie - don't enable STBC TX if only one chain is enabled. 		 * STBC RX is fine on a single RX chain; it just won't 		 * provide any real benefit. 		 */
if|if
condition|(
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_RX_STBC
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|==
name|HAL_OK
condition|)
block|{
name|sc
operator|->
name|sc_rx_stbc
operator|=
literal|1
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"[HT] 1 stream STBC receive enabled\n"
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_htcaps
operator||=
name|IEEE80211_HTCAP_RXSTBC_1STREAM
expr_stmt|;
block|}
if|if
condition|(
name|txs
operator|>
literal|1
operator|&&
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_TX_STBC
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|==
name|HAL_OK
condition|)
block|{
name|sc
operator|->
name|sc_tx_stbc
operator|=
literal|1
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"[HT] 1 stream STBC transmit enabled\n"
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_htcaps
operator||=
name|IEEE80211_HTCAP_TXSTBC
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_RTS_AGGR_LIMIT
argument_list|,
literal|1
argument_list|,
operator|&
name|sc
operator|->
name|sc_rts_aggr_limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rts_aggr_limit
operator|!=
operator|(
literal|64
operator|*
literal|1024
operator|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"[HT] RTS aggregates limited to %d KiB\n"
argument_list|,
name|sc
operator|->
name|sc_rts_aggr_limit
operator|/
literal|1024
argument_list|)
expr_stmt|;
comment|/* 		 * LDPC 		 */
if|if
condition|(
operator|(
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_LDPC
argument_list|,
literal|0
argument_list|,
operator|&
name|ldpc
argument_list|)
operator|)
operator|==
name|HAL_OK
operator|&&
operator|(
name|ldpc
operator|==
literal|1
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_has_ldpc
operator|=
literal|1
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"[HT] LDPC transmit/receive enabled\n"
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_htcaps
operator||=
name|IEEE80211_HTCAP_LDPC
operator||
name|IEEE80211_HTC_TXLDPC
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"[HT] %d RX streams; %d TX streams\n"
argument_list|,
name|rxs
argument_list|,
name|txs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Initial aggregation settings. 	 */
name|sc
operator|->
name|sc_hwq_limit_aggr
operator|=
name|ATH_AGGR_MIN_QDEPTH
expr_stmt|;
name|sc
operator|->
name|sc_hwq_limit_nonaggr
operator|=
name|ATH_NONAGGR_MIN_QDEPTH
expr_stmt|;
name|sc
operator|->
name|sc_tid_hwq_lo
operator|=
name|ATH_AGGR_SCHED_LOW
expr_stmt|;
name|sc
operator|->
name|sc_tid_hwq_hi
operator|=
name|ATH_AGGR_SCHED_HIGH
expr_stmt|;
name|sc
operator|->
name|sc_aggr_limit
operator|=
name|ATH_AGGR_MAXSIZE
expr_stmt|;
name|sc
operator|->
name|sc_delim_min_pad
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check if the hardware requires PCI register serialisation. 	 * Some of the Owl based MACs require this. 	 */
if|if
condition|(
name|mp_ncpus
operator|>
literal|1
operator|&&
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_SERIALISE_WAR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|==
name|HAL_OK
condition|)
block|{
name|sc
operator|->
name|sc_ah
operator|->
name|ah_config
operator|.
name|ah_serialise_reg_war
operator|=
literal|1
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Enabling register serialisation\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialise the deferred completed RX buffer list. 	 */
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_rxlist
index|[
name|HAL_RX_QUEUE_HP
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_rxlist
index|[
name|HAL_RX_QUEUE_LP
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Indicate we need the 802.11 header padded to a 	 * 32-bit boundary for 4-address and QoS frames. 	 */
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_DATAPAD
expr_stmt|;
comment|/* 	 * Query the hal about antenna support. 	 */
name|sc
operator|->
name|sc_defant
operator|=
name|ath_hal_getdefantenna
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 	 * Not all chips have the VEOL support we want to 	 * use with IBSS beacons; check here for it. 	 */
name|sc
operator|->
name|sc_hasveol
operator|=
name|ath_hal_hasveol
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* get mac address from kenv first, then hardware */
if|if
condition|(
name|ath_fetch_mac_kenv
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_macaddr
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Tell the HAL now about the new MAC */
name|ath_hal_setmac
argument_list|(
name|ah
argument_list|,
name|ic
operator|->
name|ic_macaddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ath_hal_getmac
argument_list|(
name|ah
argument_list|,
name|ic
operator|->
name|ic_macaddr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_hasbmask
condition|)
name|ath_hal_getbssidmask
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_hwbssidmask
argument_list|)
expr_stmt|;
comment|/* NB: used to size node table key mapping array */
name|ic
operator|->
name|ic_max_keyix
operator|=
name|sc
operator|->
name|sc_keymax
expr_stmt|;
comment|/* call MI attach routine. */
name|ieee80211_ifattach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_setregdomain
operator|=
name|ath_setregdomain
expr_stmt|;
name|ic
operator|->
name|ic_getradiocaps
operator|=
name|ath_getradiocaps
expr_stmt|;
name|sc
operator|->
name|sc_opmode
operator|=
name|HAL_M_STA
expr_stmt|;
comment|/* override default methods */
name|ic
operator|->
name|ic_ioctl
operator|=
name|ath_ioctl
expr_stmt|;
name|ic
operator|->
name|ic_parent
operator|=
name|ath_parent
expr_stmt|;
name|ic
operator|->
name|ic_transmit
operator|=
name|ath_transmit
expr_stmt|;
name|ic
operator|->
name|ic_newassoc
operator|=
name|ath_newassoc
expr_stmt|;
name|ic
operator|->
name|ic_updateslot
operator|=
name|ath_updateslot
expr_stmt|;
name|ic
operator|->
name|ic_wme
operator|.
name|wme_update
operator|=
name|ath_wme_update
expr_stmt|;
name|ic
operator|->
name|ic_vap_create
operator|=
name|ath_vap_create
expr_stmt|;
name|ic
operator|->
name|ic_vap_delete
operator|=
name|ath_vap_delete
expr_stmt|;
name|ic
operator|->
name|ic_raw_xmit
operator|=
name|ath_raw_xmit
expr_stmt|;
name|ic
operator|->
name|ic_update_mcast
operator|=
name|ath_update_mcast
expr_stmt|;
name|ic
operator|->
name|ic_update_promisc
operator|=
name|ath_update_promisc
expr_stmt|;
name|ic
operator|->
name|ic_node_alloc
operator|=
name|ath_node_alloc
expr_stmt|;
name|sc
operator|->
name|sc_node_free
operator|=
name|ic
operator|->
name|ic_node_free
expr_stmt|;
name|ic
operator|->
name|ic_node_free
operator|=
name|ath_node_free
expr_stmt|;
name|sc
operator|->
name|sc_node_cleanup
operator|=
name|ic
operator|->
name|ic_node_cleanup
expr_stmt|;
name|ic
operator|->
name|ic_node_cleanup
operator|=
name|ath_node_cleanup
expr_stmt|;
name|ic
operator|->
name|ic_node_getsignal
operator|=
name|ath_node_getsignal
expr_stmt|;
name|ic
operator|->
name|ic_scan_start
operator|=
name|ath_scan_start
expr_stmt|;
name|ic
operator|->
name|ic_scan_end
operator|=
name|ath_scan_end
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
operator|=
name|ath_set_channel
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_ENABLE_11N
comment|/* 802.11n specific - but just override anyway */
name|sc
operator|->
name|sc_addba_request
operator|=
name|ic
operator|->
name|ic_addba_request
expr_stmt|;
name|sc
operator|->
name|sc_addba_response
operator|=
name|ic
operator|->
name|ic_addba_response
expr_stmt|;
name|sc
operator|->
name|sc_addba_stop
operator|=
name|ic
operator|->
name|ic_addba_stop
expr_stmt|;
name|sc
operator|->
name|sc_bar_response
operator|=
name|ic
operator|->
name|ic_bar_response
expr_stmt|;
name|sc
operator|->
name|sc_addba_response_timeout
operator|=
name|ic
operator|->
name|ic_addba_response_timeout
expr_stmt|;
name|ic
operator|->
name|ic_addba_request
operator|=
name|ath_addba_request
expr_stmt|;
name|ic
operator|->
name|ic_addba_response
operator|=
name|ath_addba_response
expr_stmt|;
name|ic
operator|->
name|ic_addba_response_timeout
operator|=
name|ath_addba_response_timeout
expr_stmt|;
name|ic
operator|->
name|ic_addba_stop
operator|=
name|ath_addba_stop
expr_stmt|;
name|ic
operator|->
name|ic_bar_response
operator|=
name|ath_bar_response
expr_stmt|;
name|ic
operator|->
name|ic_update_chw
operator|=
name|ath_update_chw
expr_stmt|;
endif|#
directive|endif
comment|/* ATH_ENABLE_11N */
name|ic
operator|->
name|ic_set_quiet
operator|=
name|ath_set_quiet_ie
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_ENABLE_RADIOTAP_VENDOR_EXT
comment|/* 	 * There's one vendor bitmap entry in the RX radiotap 	 * header; make sure that's taken into account. 	 */
name|ieee80211_radiotap_attachv
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_tx_th
argument_list|)
argument_list|,
literal|0
argument_list|,
name|ATH_TX_RADIOTAP_PRESENT
argument_list|,
operator|&
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rx_th
argument_list|)
argument_list|,
literal|1
argument_list|,
name|ATH_RX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * No vendor bitmap/extensions are present. 	 */
name|ieee80211_radiotap_attach
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_tx_th
argument_list|)
argument_list|,
name|ATH_TX_RADIOTAP_PRESENT
argument_list|,
operator|&
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rx_th
argument_list|)
argument_list|,
name|ATH_RX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ATH_ENABLE_RADIOTAP_VENDOR_EXT */
comment|/* 	 * Setup the ALQ logging if required 	 */
ifdef|#
directive|ifdef
name|ATH_DEBUG_ALQ
name|if_ath_alq_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_alq
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|if_ath_alq_setcfg
argument_list|(
operator|&
name|sc
operator|->
name|sc_alq
argument_list|,
name|sc
operator|->
name|sc_ah
operator|->
name|ah_macVersion
argument_list|,
name|sc
operator|->
name|sc_ah
operator|->
name|ah_macRev
argument_list|,
name|sc
operator|->
name|sc_ah
operator|->
name|ah_phyRev
argument_list|,
name|sc
operator|->
name|sc_ah
operator|->
name|ah_magic
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Setup dynamic sysctl's now that country code and 	 * regdomain are available from the hal. 	 */
name|ath_sysctlattach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_sysctl_stats_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_sysctl_hal_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ieee80211_announce
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ath_announce
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Put it to sleep for now. 	 */
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_setpower
argument_list|(
name|sc
argument_list|,
name|HAL_PM_FULL_SLEEP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad2
label|:
name|ath_tx_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_desc_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_txdma_teardown
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_rxdma_teardown
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bad
label|:
if|if
condition|(
name|ah
condition|)
name|ath_hal_detach
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_invalid
operator|=
literal|1
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|ath_detach
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * NB: the order of these is important: 	 * o stop the chip so no more interrupts will fire 	 * o call the 802.11 layer before detaching the hal to 	 *   insure callbacks into the driver to delete global 	 *   key cache entries can be handled 	 * o free the taskqueue which drains any pending tasks 	 * o reclaim the tx queue data structures after calling 	 *   the 802.11 layer as we'll get called back to reclaim 	 *   node state and potentially want to use them 	 * o to cleanup the tx queues the hal is called, so detach 	 *   it last 	 * Other than that, it's straightforward... 	 */
comment|/* 	 * XXX Wake the hardware up first.  ath_stop() will still 	 * wake it up first, but I'd rather do it here just to 	 * ensure it's awake. 	 */
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ath_power_setpower
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Stop things cleanly. 	 */
name|ath_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_ifdetach
argument_list|(
operator|&
name|sc
operator|->
name|sc_ic
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
if|if
condition|(
name|sc
operator|->
name|sc_tx99
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_tx99
operator|->
name|detach
argument_list|(
name|sc
operator|->
name|sc_tx99
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ath_rate_detach
argument_list|(
name|sc
operator|->
name|sc_rc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG_ALQ
name|if_ath_alq_tidyup
argument_list|(
operator|&
name|sc
operator|->
name|sc_alq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ath_lna_div_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_btcoex_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_spectral_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_dfs_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_desc_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_txdma_teardown
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_rxdma_teardown
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_tx_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_detach
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
comment|/* NB: sets chip in full sleep */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * MAC address handling for multiple BSS on the same radio.  * The first vap uses the MAC address from the EEPROM.  For  * subsequent vap's we set the U/L bit (bit 1) in the MAC  * address and use the next six bits as an index.  */
end_comment

begin_function
specifier|static
name|void
name|assign_address
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|int
name|clone
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|clone
operator|&&
name|sc
operator|->
name|sc_hasbmask
condition|)
block|{
comment|/* NB: we only do this if h/w supports multiple bssid */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_bssidmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|mac
index|[
literal|0
index|]
operator||=
operator|(
name|i
operator|<<
literal|2
operator|)
operator||
literal|0x2
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_bssidmask
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
name|sc
operator|->
name|sc_hwbssidmask
index|[
literal|0
index|]
operator|&=
operator|~
name|mac
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_nbssid0
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reclaim_address
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|int
name|i
init|=
name|mac
index|[
literal|0
index|]
operator|>>
literal|2
decl_stmt|;
name|uint8_t
name|mask
decl_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|||
operator|--
name|sc
operator|->
name|sc_nbssid0
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_bssidmask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
comment|/* recalculate bssid mask from remaining addresses */
name|mask
operator|=
literal|0xff
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_bssidmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|mask
operator|&=
operator|~
operator|(
operator|(
name|i
operator|<<
literal|2
operator|)
operator||
literal|0x2
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_hwbssidmask
index|[
literal|0
index|]
operator||=
name|mask
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Assign a beacon xmit slot.  We try to space out  * assignments so when beacons are staggered the  * traffic coming out of the cab q has maximal time  * to go out before the next beacon is scheduled.  */
end_comment

begin_function
specifier|static
name|int
name|assign_bslot
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|slot
decl_stmt|,
name|free
decl_stmt|;
name|free
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|ATH_BCBUF
condition|;
name|slot
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_bslot
index|[
name|slot
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_bslot
index|[
operator|(
name|slot
operator|+
literal|1
operator|)
operator|%
name|ATH_BCBUF
index|]
operator|==
name|NULL
operator|&&
name|sc
operator|->
name|sc_bslot
index|[
operator|(
name|slot
operator|-
literal|1
operator|)
operator|%
name|ATH_BCBUF
index|]
operator|==
name|NULL
condition|)
return|return
name|slot
return|;
name|free
operator|=
name|slot
expr_stmt|;
comment|/* NB: keep looking for a double slot */
block|}
return|return
name|free
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|ath_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|enum
name|ieee80211_opmode
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac0
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|int
name|needbeacon
decl_stmt|,
name|error
decl_stmt|;
name|enum
name|ieee80211_opmode
name|ic_opmode
decl_stmt|;
name|avp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ath_vap
argument_list|)
argument_list|,
name|M_80211_VAP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|needbeacon
operator|=
literal|0
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|mac
argument_list|,
name|mac0
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ic_opmode
operator|=
name|opmode
expr_stmt|;
comment|/* default to opmode of new vap */
switch|switch
condition|(
name|opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
if|if
condition|(
name|sc
operator|->
name|sc_nstavaps
operator|!=
literal|0
condition|)
block|{
comment|/* XXX only 1 for now */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"only 1 sta vap supported\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
condition|)
block|{
comment|/* 			 * With multiple vaps we must fall back 			 * to s/w beacon miss handling. 			 */
name|flags
operator||=
name|IEEE80211_CLONE_NOBEACONS
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CLONE_NOBEACONS
condition|)
block|{
comment|/* 			 * Station mode w/o beacons are implemented w/ AP mode. 			 */
name|ic_opmode
operator|=
name|IEEE80211_M_HOSTAP
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_M_IBSS
case|:
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
operator|!=
literal|0
condition|)
block|{
comment|/* XXX only 1 for now */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"only 1 ibss vap supported\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|needbeacon
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_AHDEMO
case|:
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CLONE_TDMA
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"only 1 tdma vap supported\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|needbeacon
operator|=
literal|1
expr_stmt|;
name|flags
operator||=
name|IEEE80211_CLONE_NOBEACONS
expr_stmt|;
block|}
comment|/* fall thru... */
endif|#
directive|endif
case|case
name|IEEE80211_M_MONITOR
case|:
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
operator|!=
literal|0
operator|&&
name|ic
operator|->
name|ic_opmode
operator|!=
name|opmode
condition|)
block|{
comment|/* 			 * Adopt existing mode.  Adding a monitor or ahdemo 			 * vap to an existing configuration is of dubious 			 * value but should be ok. 			 */
comment|/* XXX not right for monitor mode */
name|ic_opmode
operator|=
name|ic
operator|->
name|ic_opmode
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_M_HOSTAP
case|:
case|case
name|IEEE80211_M_MBSS
case|:
name|needbeacon
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_WDS
case|:
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
operator|!=
literal|0
operator|&&
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"wds not supported in sta mode\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * Silently remove any request for a unique 		 * bssid; WDS vap's always share the local 		 * mac address. 		 */
name|flags
operator|&=
operator|~
name|IEEE80211_CLONE_BSSID
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
operator|==
literal|0
condition|)
name|ic_opmode
operator|=
name|IEEE80211_M_HOSTAP
expr_stmt|;
else|else
name|ic_opmode
operator|=
name|ic
operator|->
name|ic_opmode
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unknown opmode %d\n"
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Check that a beacon buffer is available; the code below assumes it. 	 */
if|if
condition|(
name|needbeacon
operator|&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"no beacon buffer available\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* STA, AHDEMO? */
if|if
condition|(
name|opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
name|assign_address
argument_list|(
name|sc
argument_list|,
name|mac
argument_list|,
name|flags
operator|&
name|IEEE80211_CLONE_BSSID
argument_list|)
expr_stmt|;
name|ath_hal_setbssidmask
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_hwbssidmask
argument_list|)
expr_stmt|;
block|}
name|vap
operator|=
operator|&
name|avp
operator|->
name|av_vap
expr_stmt|;
comment|/* XXX can't hold mutex across if_alloc */
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|ieee80211_vap_setup
argument_list|(
name|ic
argument_list|,
name|vap
argument_list|,
name|name
argument_list|,
name|unit
argument_list|,
name|opmode
argument_list|,
name|flags
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: error %d creating vap\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
comment|/* h/w crypto support */
name|vap
operator|->
name|iv_key_alloc
operator|=
name|ath_key_alloc
expr_stmt|;
name|vap
operator|->
name|iv_key_delete
operator|=
name|ath_key_delete
expr_stmt|;
name|vap
operator|->
name|iv_key_set
operator|=
name|ath_key_set
expr_stmt|;
name|vap
operator|->
name|iv_key_update_begin
operator|=
name|ath_key_update_begin
expr_stmt|;
name|vap
operator|->
name|iv_key_update_end
operator|=
name|ath_key_update_end
expr_stmt|;
comment|/* override various methods */
name|avp
operator|->
name|av_recv_mgmt
operator|=
name|vap
operator|->
name|iv_recv_mgmt
expr_stmt|;
name|vap
operator|->
name|iv_recv_mgmt
operator|=
name|ath_recv_mgmt
expr_stmt|;
name|vap
operator|->
name|iv_reset
operator|=
name|ath_reset_vap
expr_stmt|;
name|vap
operator|->
name|iv_update_beacon
operator|=
name|ath_beacon_update
expr_stmt|;
name|avp
operator|->
name|av_newstate
operator|=
name|vap
operator|->
name|iv_newstate
expr_stmt|;
name|vap
operator|->
name|iv_newstate
operator|=
name|ath_newstate
expr_stmt|;
name|avp
operator|->
name|av_bmiss
operator|=
name|vap
operator|->
name|iv_bmiss
expr_stmt|;
name|vap
operator|->
name|iv_bmiss
operator|=
name|ath_bmiss_vap
expr_stmt|;
name|avp
operator|->
name|av_node_ps
operator|=
name|vap
operator|->
name|iv_node_ps
expr_stmt|;
name|vap
operator|->
name|iv_node_ps
operator|=
name|ath_node_powersave
expr_stmt|;
name|avp
operator|->
name|av_set_tim
operator|=
name|vap
operator|->
name|iv_set_tim
expr_stmt|;
name|vap
operator|->
name|iv_set_tim
operator|=
name|ath_node_set_tim
expr_stmt|;
name|avp
operator|->
name|av_recv_pspoll
operator|=
name|vap
operator|->
name|iv_recv_pspoll
expr_stmt|;
name|vap
operator|->
name|iv_recv_pspoll
operator|=
name|ath_node_recv_pspoll
expr_stmt|;
comment|/* Set default parameters */
comment|/* 	 * Anything earlier than some AR9300 series MACs don't 	 * support a smaller MPDU density. 	 */
name|vap
operator|->
name|iv_ampdu_density
operator|=
name|IEEE80211_HTCAP_MPDUDENSITY_8
expr_stmt|;
comment|/* 	 * All NICs can handle the maximum size, however 	 * AR5416 based MACs can only TX aggregates w/ RTS 	 * protection when the total aggregate size is<= 8k. 	 * However, for now that's enforced by the TX path. 	 */
name|vap
operator|->
name|iv_ampdu_rxmax
operator|=
name|IEEE80211_HTCAP_MAXRXAMPDU_64K
expr_stmt|;
name|vap
operator|->
name|iv_ampdu_limit
operator|=
name|IEEE80211_HTCAP_MAXRXAMPDU_64K
expr_stmt|;
name|avp
operator|->
name|av_bslot
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|needbeacon
condition|)
block|{
comment|/* 		 * Allocate beacon state and setup the q for buffered 		 * multicast frames.  We know a beacon buffer is 		 * available because we checked above. 		 */
name|avp
operator|->
name|av_bcbuf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|,
name|avp
operator|->
name|av_bcbuf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|!=
name|IEEE80211_M_IBSS
operator|||
operator|!
name|sc
operator|->
name|sc_hasveol
condition|)
block|{
comment|/* 			 * Assign the vap to a beacon xmit slot.  As above 			 * this cannot fail to find a free one. 			 */
name|avp
operator|->
name|av_bslot
operator|=
name|assign_bslot
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_bslot
index|[
name|avp
operator|->
name|av_bslot
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"beacon slot %u not empty"
operator|,
name|avp
operator|->
name|av_bslot
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bslot
index|[
name|avp
operator|->
name|av_bslot
index|]
operator|=
name|vap
expr_stmt|;
name|sc
operator|->
name|sc_nbcnvaps
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_hastsfadd
operator|&&
name|sc
operator|->
name|sc_nbcnvaps
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Multple vaps are to transmit beacons and we 			 * have h/w support for TSF adjusting; enable 			 * use of staggered beacons. 			 */
name|sc
operator|->
name|sc_stagbeacons
operator|=
literal|1
expr_stmt|;
block|}
name|ath_txq_init
argument_list|(
name|sc
argument_list|,
operator|&
name|avp
operator|->
name|av_mcastq
argument_list|,
name|ATH_TXQ_SWQ
argument_list|)
expr_stmt|;
block|}
name|ic
operator|->
name|ic_opmode
operator|=
name|ic_opmode
expr_stmt|;
if|if
condition|(
name|opmode
operator|!=
name|IEEE80211_M_WDS
condition|)
block|{
name|sc
operator|->
name|sc_nvaps
operator|++
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|sc
operator|->
name|sc_nstavaps
operator|++
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
name|sc
operator|->
name|sc_nmeshvaps
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|ic_opmode
condition|)
block|{
case|case
name|IEEE80211_M_IBSS
case|:
name|sc
operator|->
name|sc_opmode
operator|=
name|HAL_M_IBSS
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_STA
case|:
name|sc
operator|->
name|sc_opmode
operator|=
name|HAL_M_STA
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_AHDEMO
case|:
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
condition|)
block|{
name|sc
operator|->
name|sc_tdma
operator|=
literal|1
expr_stmt|;
comment|/* NB: disable tsf adjust */
name|sc
operator|->
name|sc_stagbeacons
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * NB: adhoc demo mode is a pseudo mode; to the hal it's 		 * just ap mode. 		 */
comment|/* fall thru... */
endif|#
directive|endif
case|case
name|IEEE80211_M_HOSTAP
case|:
case|case
name|IEEE80211_M_MBSS
case|:
name|sc
operator|->
name|sc_opmode
operator|=
name|HAL_M_HOSTAP
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
name|sc
operator|->
name|sc_opmode
operator|=
name|HAL_M_MONITOR
expr_stmt|;
break|break;
default|default:
comment|/* XXX should not happen */
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_hastsfadd
condition|)
block|{
comment|/* 		 * Configure whether or not TSF adjust should be done. 		 */
name|ath_hal_settsfadjust
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_stagbeacons
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CLONE_NOBEACONS
condition|)
block|{
comment|/* 		 * Enable s/w beacon miss handling. 		 */
name|sc
operator|->
name|sc_swbmiss
operator|=
literal|1
expr_stmt|;
block|}
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* complete setup */
name|ieee80211_vap_attach
argument_list|(
name|vap
argument_list|,
name|ath_media_change
argument_list|,
name|ieee80211_media_status
argument_list|,
name|mac
argument_list|)
expr_stmt|;
return|return
name|vap
return|;
name|bad2
label|:
name|reclaim_address
argument_list|(
name|sc
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|ath_hal_setbssidmask
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_hwbssidmask
argument_list|)
expr_stmt|;
name|bad
label|:
name|free
argument_list|(
name|avp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_running
condition|)
block|{
comment|/* 		 * Quiesce the hardware while we remove the vap.  In 		 * particular we need to reclaim all references to 		 * the vap state by any frames pending on the tx queues. 		 */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
comment|/* XXX Do all frames from all vaps/nodes need draining here? */
name|ath_stoprecv
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* stop recv side */
name|ath_draintxq
argument_list|(
name|sc
argument_list|,
name|ATH_RESET_DEFAULT
argument_list|)
expr_stmt|;
comment|/* stop hw xmit side */
block|}
comment|/* .. leave the hardware awake for now. */
name|ieee80211_vap_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* 	 * XXX Danger Will Robinson! Danger! 	 * 	 * Because ieee80211_vap_detach() can queue a frame (the station 	 * diassociate message?) after we've drained the TXQ and 	 * flushed the software TXQ, we will end up with a frame queued 	 * to a node whose vap is about to be freed. 	 * 	 * To work around this, flush the hardware/software again. 	 * This may be racy - the ath task may be running and the packet 	 * may be being scheduled between sw->hw txq. Tsk. 	 * 	 * TODO: figure out why a new node gets allocated somewhere around 	 * here (after the ath_tx_swq() call; and after an ath_stop() 	 * call!) 	 */
name|ath_draintxq
argument_list|(
name|sc
argument_list|,
name|ATH_RESET_DEFAULT
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Reclaim beacon state.  Note this must be done before 	 * the vap instance is reclaimed as we may have a reference 	 * to it in the buffer for the beacon frame. 	 */
if|if
condition|(
name|avp
operator|->
name|av_bcbuf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|avp
operator|->
name|av_bslot
operator|!=
operator|-
literal|1
condition|)
block|{
name|sc
operator|->
name|sc_bslot
index|[
name|avp
operator|->
name|av_bslot
index|]
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_nbcnvaps
operator|--
expr_stmt|;
block|}
name|ath_beacon_return
argument_list|(
name|sc
argument_list|,
name|avp
operator|->
name|av_bcbuf
argument_list|)
expr_stmt|;
name|avp
operator|->
name|av_bcbuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nbcnvaps
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stagbeacons
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hastsfadd
condition|)
name|ath_hal_settsfadjust
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Reclaim any pending mcast frames for the vap. 		 */
name|ath_tx_draintxq
argument_list|(
name|sc
argument_list|,
operator|&
name|avp
operator|->
name|av_mcastq
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update bookkeeping. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
name|sc
operator|->
name|sc_nstavaps
operator|--
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nstavaps
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_swbmiss
condition|)
name|sc
operator|->
name|sc_swbmiss
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
name|reclaim_address
argument_list|(
name|sc
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|ath_hal_setbssidmask
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_hwbssidmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
name|sc
operator|->
name|sc_nmeshvaps
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_WDS
condition|)
name|sc
operator|->
name|sc_nvaps
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
comment|/* TDMA operation ceases when the last vap is destroyed */
if|if
condition|(
name|sc
operator|->
name|sc_tdma
operator|&&
name|sc
operator|->
name|sc_nvaps
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_tdma
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_swbmiss
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|free
argument_list|(
name|avp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_running
condition|)
block|{
comment|/* 		 * Restart rx+tx machines if still running (RUNNING will 		 * be reset if we just destroyed the last vap). 		 */
if|if
condition|(
name|ath_startrecv
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: unable to restart recv logic\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_beacons
condition|)
block|{
comment|/* restart beacons */
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|sc
operator|->
name|sc_tdma
condition|)
name|ath_tdma_config
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ath_beacon_config
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
block|}
comment|/* Ok, let the hardware asleep. */
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ath_suspend
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|sc
operator|->
name|sc_resume_up
operator|=
name|ic
operator|->
name|ic_nrunning
operator|!=
literal|0
expr_stmt|;
name|ieee80211_suspend_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * NB: don't worry about putting the chip in low power 	 * mode; pci will power off our socket on suspend and 	 * CardBus detaches the device. 	 * 	 * XXX TODO: well, that's great, except for non-cardbus 	 * devices! 	 */
comment|/* 	 * XXX This doesn't wait until all pending taskqueue 	 * items and parallel transmit/receive/other threads 	 * are running! 	 */
name|ath_hal_intrset
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|taskqueue_block
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * XXX ensure sc_invalid is 1 	 */
comment|/* Disable the PCIe PHY, complete with workarounds */
name|ath_hal_enablepcie
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the key cache since some parts do not reset the  * contents on resume.  First we clear all entries, then  * re-load keys that the 802.11 layer assumes are setup  * in h/w.  */
end_comment

begin_function
specifier|static
name|void
name|ath_reset_keycache
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_keymax
condition|;
name|i
operator|++
control|)
name|ath_hal_keyreset
argument_list|(
name|ah
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_crypto_reload_keys
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fetch the current chainmask configuration based on the current  * operating channel and options.  */
end_comment

begin_function
specifier|static
name|void
name|ath_update_chainmasks
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
comment|/* 	 * Set TX chainmask to the currently configured chainmask; 	 * the TX chainmask depends upon the current operating mode. 	 */
name|sc
operator|->
name|sc_cur_rxchainmask
operator|=
name|sc
operator|->
name|sc_rxchainmask
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_cur_txchainmask
operator|=
name|sc
operator|->
name|sc_txchainmask
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_cur_txchainmask
operator|=
literal|1
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: TX chainmask is now 0x%x, RX is now 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_cur_txchainmask
argument_list|,
name|sc
operator|->
name|sc_cur_rxchainmask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ath_resume
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|ath_hal_enablepcie
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Must reset the chip before we reload the 	 * keycache as we were powered down on suspend. 	 */
name|ath_update_chainmasks
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_curchan
operator|!=
name|NULL
condition|?
name|sc
operator|->
name|sc_curchan
else|:
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|ath_hal_setchainmasks
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_cur_txchainmask
argument_list|,
name|sc
operator|->
name|sc_cur_rxchainmask
argument_list|)
expr_stmt|;
comment|/* Ensure we set the current power state to on */
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_setselfgen
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ath_power_setpower
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_reset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_opmode
argument_list|,
name|sc
operator|->
name|sc_curchan
operator|!=
name|NULL
condition|?
name|sc
operator|->
name|sc_curchan
else|:
name|ic
operator|->
name|ic_curchan
argument_list|,
name|AH_FALSE
argument_list|,
name|HAL_RESET_NORMAL
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|ath_reset_keycache
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_RX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rx_stopped
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_rx_resetted
operator|=
literal|1
expr_stmt|;
name|ATH_RX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Let DFS at it in case it's a DFS channel */
name|ath_dfs_radar_enable
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* Let spectral at in case spectral is enabled */
name|ath_spectral_enable
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* 	 * Let bluetooth coexistence at in case it's needed for this channel 	 */
name|ath_btcoex_enable
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* 	 * If we're doing TDMA, enforce the TXOP limitation for chips that 	 * support it. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_hasenforcetxop
operator|&&
name|sc
operator|->
name|sc_tdma
condition|)
name|ath_hal_setenforcetxop
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|ath_hal_setenforcetxop
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Restore the LED configuration */
name|ath_led_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_setledstate
argument_list|(
name|ah
argument_list|,
name|HAL_LED_INIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_resume_up
condition|)
name|ieee80211_resume_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX beacons ? */
block|}
end_function

begin_function
name|void
name|ath_shutdown
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* NB: no point powering down chip as we're about to reboot */
block|}
end_function

begin_comment
comment|/*  * Interrupt handler.  Most of the actual processing is deferred.  */
end_comment

begin_function
name|void
name|ath_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_INT
name|status
init|=
literal|0
decl_stmt|;
name|uint32_t
name|txqs
decl_stmt|;
comment|/* 	 * If we're inside a reset path, just print a warning and 	 * clear the ISR. The reset routine will finish it for us. 	 */
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_inreset_cnt
condition|)
block|{
name|HAL_INT
name|status
decl_stmt|;
name|ath_hal_getisr
argument_list|(
name|ah
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* clear ISR */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable further intr's */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: in reset, ignoring: status=0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_invalid
condition|)
block|{
comment|/* 		 * The hardware is not ready/present, don't touch anything. 		 * Note this can happen early on if the IRQ is shared. 		 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: invalid; ignored\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ath_hal_intrpend
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* shared irq, not for us */
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ic
operator|.
name|ic_nrunning
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_running
operator|==
literal|0
condition|)
block|{
name|HAL_INT
name|status
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: ic_nrunning %d sc_running %d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_ic
operator|.
name|ic_nrunning
argument_list|,
name|sc
operator|->
name|sc_running
argument_list|)
expr_stmt|;
name|ath_hal_getisr
argument_list|(
name|ah
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* clear ISR */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable further intr's */
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Figure out the reason(s) for the interrupt.  Note 	 * that the hal returns a pseudo-ISR that may include 	 * bits we haven't explicitly enabled so we mask the 	 * value to insure we only process bits we requested. 	 */
name|ath_hal_getisr
argument_list|(
name|ah
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* NB: clears ISR too */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_INTR
argument_list|,
literal|"%s: status 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_INTERRUPTS
argument_list|,
literal|1
argument_list|,
literal|"ath_intr: mask=0x%.8x"
argument_list|,
name|status
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG_ALQ
name|if_ath_alq_post_intr
argument_list|(
operator|&
name|sc
operator|->
name|sc_alq
argument_list|,
name|status
argument_list|,
name|ah
operator|->
name|ah_intrstate
argument_list|,
name|ah
operator|->
name|ah_syncstate
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ATH_DEBUG_ALQ */
ifdef|#
directive|ifdef
name|ATH_KTR_INTR_DEBUG
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_INTERRUPTS
argument_list|,
literal|5
argument_list|,
literal|"ath_intr: ISR=0x%.8x, ISR_S0=0x%.8x, ISR_S1=0x%.8x, ISR_S2=0x%.8x, ISR_S5=0x%.8x"
argument_list|,
name|ah
operator|->
name|ah_intrstate
index|[
literal|0
index|]
argument_list|,
name|ah
operator|->
name|ah_intrstate
index|[
literal|1
index|]
argument_list|,
name|ah
operator|->
name|ah_intrstate
index|[
literal|2
index|]
argument_list|,
name|ah
operator|->
name|ah_intrstate
index|[
literal|3
index|]
argument_list|,
name|ah
operator|->
name|ah_intrstate
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Squirrel away SYNC interrupt debugging */
if|if
condition|(
name|ah
operator|->
name|ah_syncstate
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ah
operator|->
name|ah_syncstate
operator|&
operator|(
name|i
operator|<<
name|i
operator|)
condition|)
name|sc
operator|->
name|sc_intr_stats
operator|.
name|sync_intr
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
name|status
operator|&=
name|sc
operator|->
name|sc_imask
expr_stmt|;
comment|/* discard unasked for bits */
comment|/* Short-circuit un-handled interrupts */
if|if
condition|(
name|status
operator|==
literal|0x0
condition|)
block|{
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Take a note that we're inside the interrupt handler, so 	 * the reset routines know to wait. 	 */
name|sc
operator|->
name|sc_intr_cnt
operator|++
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Handle the interrupt. We won't run concurrent with the reset 	 * or channel change routines as they'll wait for sc_intr_cnt 	 * to be 0 before continuing. 	 */
if|if
condition|(
name|status
operator|&
name|HAL_INT_FATAL
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_hardware
operator|++
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable intr's until reset */
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_fataltask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|status
operator|&
name|HAL_INT_SWBA
condition|)
block|{
comment|/* 			 * Software beacon alert--time to send a beacon. 			 * Handle beacon transmission directly; deferring 			 * this is too slow to meet timing constraints 			 * under load. 			 */
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|sc
operator|->
name|sc_tdma
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_tdmaswba
operator|==
literal|0
condition|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|ath_tdma_beacon_send
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tdmaswba
operator|=
name|vap
operator|->
name|iv_tdma
operator|->
name|tdma_bintval
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_tdmaswba
operator|--
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|ath_beacon_proc
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
comment|/* 				 * Schedule the rx taskq in case there's no 				 * traffic so any frames held on the staging 				 * queue are aged and potentially flushed. 				 */
name|sc
operator|->
name|sc_rx
operator|.
name|recv_sched
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_RXEOL
condition|)
block|{
name|int
name|imask
decl_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_ERROR
argument_list|,
literal|0
argument_list|,
literal|"ath_intr: RXEOL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_isedma
condition|)
block|{
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 				 * NB: the hardware should re-read the link when 				 *     RXE bit is written, but it doesn't work at 				 *     least on older hardware revs. 				 */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rxeol
operator|++
expr_stmt|;
comment|/* 				 * Disable RXEOL/RXORN - prevent an interrupt 				 * storm until the PCU logic can be reset. 				 * In case the interface is reset some other 				 * way before "sc_kickpcu" is called, don't 				 * modify sc_imask - that way if it is reset 				 * by a call to ath_reset() somehow, the 				 * interrupt mask will be correctly reprogrammed. 				 */
name|imask
operator|=
name|sc
operator|->
name|sc_imask
expr_stmt|;
name|imask
operator|&=
operator|~
operator|(
name|HAL_INT_RXEOL
operator||
name|HAL_INT_RXORN
operator|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|imask
argument_list|)
expr_stmt|;
comment|/* 				 * Only blank sc_rxlink if we've not yet kicked 				 * the PCU. 				 * 				 * This isn't entirely correct - the correct solution 				 * would be to have a PCU lock and engage that for 				 * the duration of the PCU fiddling; which would include 				 * running the RX process. Otherwise we could end up 				 * messing up the RX descriptor chain and making the 				 * RX desc list much shorter. 				 */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_kickpcu
condition|)
name|sc
operator|->
name|sc_rxlink
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_kickpcu
operator|=
literal|1
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Enqueue an RX proc to handle whatever 			 * is in the RX queue. 			 * This will then kick the PCU if required. 			 */
name|sc
operator|->
name|sc_rx
operator|.
name|recv_sched
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_TXURN
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_txurn
operator|++
expr_stmt|;
comment|/* bump tx trigger level */
name|ath_hal_updatetxtriglevel
argument_list|(
name|ah
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Handle both the legacy and RX EDMA interrupt bits. 		 * Note that HAL_INT_RXLP is also HAL_INT_RXDESC. 		 */
if|if
condition|(
name|status
operator|&
operator|(
name|HAL_INT_RX
operator||
name|HAL_INT_RXHP
operator||
name|HAL_INT_RXLP
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_intr
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_rx
operator|.
name|recv_sched
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_TX
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_intr
operator|++
expr_stmt|;
comment|/* 			 * Grab all the currently set bits in the HAL txq bitmap 			 * and blank them. This is the only place we should be 			 * doing this. 			 */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_isedma
condition|)
block|{
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|txqs
operator|=
literal|0xffffffff
expr_stmt|;
name|ath_hal_gettxintrtxqs
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|txqs
argument_list|)
expr_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_INTERRUPTS
argument_list|,
literal|3
argument_list|,
literal|"ath_intr: TX; txqs=0x%08x, txq_active was 0x%08x, now 0x%08x"
argument_list|,
name|txqs
argument_list|,
name|sc
operator|->
name|sc_txq_active
argument_list|,
name|sc
operator|->
name|sc_txq_active
operator||
name|txqs
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txq_active
operator||=
name|txqs
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_txtask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_BMISS
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_bmiss
operator|++
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_bmisstask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_GTT
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_timeout
operator|++
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|HAL_INT_CST
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_cst
operator|++
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|HAL_INT_MIB
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_mib
operator|++
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 			 * Disable interrupts until we service the MIB 			 * interrupt; otherwise it will continue to fire. 			 */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Let the hal handle the event.  We assume it will 			 * clear whatever condition caused the interrupt. 			 */
name|ath_hal_mibevent
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_halstats
argument_list|)
expr_stmt|;
comment|/* 			 * Don't reset the interrupt if we've just 			 * kicked the PCU, or we may get a nested 			 * RXEOL before the rxproc has had a chance 			 * to run. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_kickpcu
operator|==
literal|0
condition|)
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_RXORN
condition|)
block|{
comment|/* NB: hal marks HAL_INT_FATAL when RXORN is fatal */
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_ERROR
argument_list|,
literal|0
argument_list|,
literal|"ath_intr: RXORN"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rxorn
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_TSFOOR
condition|)
block|{
comment|/* out of range beacon - wake the chip up, 			 * but don't modify self-gen frame config */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: TSFOOR\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|1
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_setpower
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_MCI
condition|)
block|{
name|ath_btcoex_mci_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_intr_cnt
operator|--
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_fatal_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|u_int32_t
modifier|*
name|state
decl_stmt|;
name|u_int32_t
name|len
decl_stmt|;
name|void
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_invalid
condition|)
return|return;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"hardware error; resetting\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Fatal errors are unrecoverable.  Typically these 	 * are caused by DMA errors.  Collect h/w state from 	 * the hal so we can diagnose what's going on. 	 */
if|if
condition|(
name|ath_hal_getfatalstate
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|sp
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|len
operator|>=
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
operator|(
literal|"len %u bytes"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|sp
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"0x%08x 0x%08x 0x%08x, 0x%08x 0x%08x 0x%08x\n"
argument_list|,
name|state
index|[
literal|0
index|]
argument_list|,
name|state
index|[
literal|1
index|]
argument_list|,
name|state
index|[
literal|2
index|]
argument_list|,
name|state
index|[
literal|3
index|]
argument_list|,
name|state
index|[
literal|4
index|]
argument_list|,
name|state
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
name|ath_reset
argument_list|(
name|sc
argument_list|,
name|ATH_RESET_NOLOSS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_bmiss_vap
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_softc
decl_stmt|;
comment|/* 	 * Workaround phantom bmiss interrupts by sanity-checking 	 * the time of our last rx'd frame.  If it is within the 	 * beacon miss interval then ignore the interrupt.  If it's 	 * truly a bmiss we'll get another interrupt soon and that'll 	 * be dispatched up for processing.  Note this applies only 	 * for h/w beacon miss events. 	 */
comment|/* 	 * XXX TODO: Just read the TSF during the interrupt path; 	 * that way we don't have to wake up again just to read it 	 * again. 	 */
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_SWBMISS
operator|)
operator|==
literal|0
condition|)
block|{
name|u_int64_t
name|lastrx
init|=
name|sc
operator|->
name|sc_lastrx
decl_stmt|;
name|u_int64_t
name|tsf
init|=
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
decl_stmt|;
comment|/* XXX should take a locked ref to iv_bss */
name|u_int
name|bmisstimeout
init|=
name|vap
operator|->
name|iv_bmissthreshold
operator|*
name|vap
operator|->
name|iv_bss
operator|->
name|ni_intval
operator|*
literal|1024
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: tsf %llu lastrx %lld (%llu) bmiss %u\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|tsf
argument_list|,
call|(
name|unsigned
name|long
name|long
call|)
argument_list|(
name|tsf
operator|-
name|lastrx
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|lastrx
argument_list|,
name|bmisstimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsf
operator|-
name|lastrx
operator|<=
name|bmisstimeout
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_bmiss_phantom
operator|++
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Keep the hardware awake if it's asleep (and leave self-gen 	 * frame config alone) until the next beacon, so we can resync 	 * against the next beacon. 	 * 	 * This handles three common beacon miss cases in STA powersave mode - 	 * (a) the beacon TBTT isnt a multiple of bintval; 	 * (b) the beacon was missed; and 	 * (c) the beacons are being delayed because the AP is busy and 	 *     isn't reliably able to meet its TBTT. 	 */
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_setpower
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: forced awake; force syncbeacon=1\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to force a beacon resync. 	 */
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|1
expr_stmt|;
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|av_bmiss
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX this needs a force wakeup! */
end_comment

begin_function
name|int
name|ath_hal_gethangstate
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|mask
parameter_list|,
name|uint32_t
modifier|*
name|hangs
parameter_list|)
block|{
name|uint32_t
name|rsize
decl_stmt|;
name|void
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|!
name|ath_hal_getdiagstate
argument_list|(
name|ah
argument_list|,
name|HAL_DIAG_CHECK_HANGS
argument_list|,
operator|&
name|mask
argument_list|,
sizeof|sizeof
argument_list|(
name|mask
argument_list|)
argument_list|,
operator|&
name|sp
argument_list|,
operator|&
name|rsize
argument_list|)
condition|)
return|return
literal|0
return|;
name|KASSERT
argument_list|(
name|rsize
operator|==
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
literal|"resultsize %u"
operator|,
name|rsize
operator|)
argument_list|)
expr_stmt|;
operator|*
name|hangs
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|sp
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_bmiss_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|uint32_t
name|hangs
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: pending %u\n"
argument_list|,
name|__func__
argument_list|,
name|pending
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_beacon_miss
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Do a reset upon any becaon miss event. 	 * 	 * It may be a non-recognised RX clear hang which needs a reset 	 * to clear. 	 */
if|if
condition|(
name|ath_hal_gethangstate
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0xff
argument_list|,
operator|&
name|hangs
argument_list|)
operator|&&
name|hangs
operator|!=
literal|0
condition|)
block|{
name|ath_reset
argument_list|(
name|sc
argument_list|,
name|ATH_RESET_NOLOSS
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"bb hang detected (0x%x), resetting\n"
argument_list|,
name|hangs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ath_reset
argument_list|(
name|sc
argument_list|,
name|ATH_RESET_NOLOSS
argument_list|)
expr_stmt|;
name|ieee80211_beacon_miss
argument_list|(
operator|&
name|sc
operator|->
name|sc_ic
argument_list|)
expr_stmt|;
block|}
comment|/* Force a beacon resync, in case they've drifted */
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|1
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle TKIP MIC setup to deal hardware that doesn't do MIC  * calcs together with WME.  If necessary disable the crypto  * hardware and mark the 802.11 state so keys will be setup  * with the MIC work done in software.  */
end_comment

begin_function
specifier|static
name|void
name|ath_settkipmic
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_cryptocaps
operator|&
name|IEEE80211_CRYPTO_TKIP
operator|)
operator|&&
operator|!
name|sc
operator|->
name|sc_wmetkipmic
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WME
condition|)
block|{
name|ath_hal_settkipmic
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_cryptocaps
operator|&=
operator|~
name|IEEE80211_CRYPTO_TKIPMIC
expr_stmt|;
block|}
else|else
block|{
name|ath_hal_settkipmic
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_TKIPMIC
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_vap_clear_quiet_ie
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
name|avp
operator|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* Quiet time handling - ensure we resync */
name|memset
argument_list|(
operator|&
name|avp
operator|->
name|quiet_ie
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|avp
operator|->
name|quiet_ie
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ath_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|ATH_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Force the sleep state awake. 	 */
name|ath_power_setselfgen
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ath_power_setpower
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Stop anything previously setup.  This is safe 	 * whether this is the first time through or not. 	 */
name|ath_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * The basic interface to setting the hardware in a good 	 * state is ``reset''.  On return the hardware is known to 	 * be powered up and with interrupts disabled.  This must 	 * be followed by initialization of the appropriate bits 	 * and then setup of the interrupt mask. 	 */
name|ath_settkipmic
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_update_chainmasks
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|ath_hal_setchainmasks
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_cur_txchainmask
argument_list|,
name|sc
operator|->
name|sc_cur_rxchainmask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_reset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_opmode
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|,
name|AH_FALSE
argument_list|,
name|HAL_RESET_NORMAL
argument_list|,
operator|&
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to reset hardware; hal status %u\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
name|ATH_RX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rx_stopped
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_rx_resetted
operator|=
literal|1
expr_stmt|;
name|ATH_RX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Clear quiet IE state for each VAP */
name|ath_vap_clear_quiet_ie
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_chan_change
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* Let DFS at it in case it's a DFS channel */
name|ath_dfs_radar_enable
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* Let spectral at in case spectral is enabled */
name|ath_spectral_enable
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* 	 * Let bluetooth coexistence at in case it's needed for this channel 	 */
name|ath_btcoex_enable
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* 	 * If we're doing TDMA, enforce the TXOP limitation for chips that 	 * support it. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_hasenforcetxop
operator|&&
name|sc
operator|->
name|sc_tdma
condition|)
name|ath_hal_setenforcetxop
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|ath_hal_setenforcetxop
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Likewise this is set during reset so update 	 * state cached in the driver. 	 */
name|sc
operator|->
name|sc_diversity
operator|=
name|ath_hal_getdiversity
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_lastlongcal
operator|=
name|ticks
expr_stmt|;
name|sc
operator|->
name|sc_resetcal
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_lastcalreset
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_lastani
operator|=
name|ticks
expr_stmt|;
name|sc
operator|->
name|sc_lastshortcal
operator|=
name|ticks
expr_stmt|;
name|sc
operator|->
name|sc_doresetcal
operator|=
name|AH_FALSE
expr_stmt|;
comment|/* 	 * Beacon timers were cleared here; give ath_newstate() 	 * a hint that the beacon timers should be poked when 	 * things transition to the RUN state. 	 */
name|sc
operator|->
name|sc_beacons
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Setup the hardware after reset: the key cache 	 * is filled as needed and the receive engine is 	 * set going.  Frame transmit is handled entirely 	 * in the frame output path; there's nothing to do 	 * here except setup the interrupt mask. 	 */
if|if
condition|(
name|ath_startrecv
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to start recv logic\n"
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* 	 * Enable interrupts. 	 */
name|sc
operator|->
name|sc_imask
operator|=
name|HAL_INT_RX
operator||
name|HAL_INT_TX
operator||
name|HAL_INT_RXORN
operator||
name|HAL_INT_TXURN
operator||
name|HAL_INT_FATAL
operator||
name|HAL_INT_GLOBAL
expr_stmt|;
comment|/* 	 * Enable RX EDMA bits.  Note these overlap with 	 * HAL_INT_RX and HAL_INT_RXDESC respectively. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_isedma
condition|)
name|sc
operator|->
name|sc_imask
operator||=
operator|(
name|HAL_INT_RXHP
operator||
name|HAL_INT_RXLP
operator|)
expr_stmt|;
comment|/* 	 * If we're an EDMA NIC, we don't care about RXEOL. 	 * Writing a new descriptor in will simply restart 	 * RX DMA. 	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_isedma
condition|)
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_RXEOL
expr_stmt|;
comment|/* 	 * Enable MCI interrupt for MCI devices. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_btcoex_mci
condition|)
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_MCI
expr_stmt|;
comment|/* 	 * Enable MIB interrupts when there are hardware phy counters. 	 * Note we only do this (at the moment) for station mode. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_needmib
operator|&&
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_MIB
expr_stmt|;
comment|/* 	 * XXX add capability for this. 	 * 	 * If we're in STA mode (and maybe IBSS?) then register for 	 * TSFOOR interrupts. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_TSFOOR
expr_stmt|;
comment|/* Enable global TX timeout and carrier sense timeout if available */
if|if
condition|(
name|ath_hal_gtxto_supported
argument_list|(
name|ah
argument_list|)
condition|)
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_GTT
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: imask=0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_running
operator|=
literal|1
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_wd_ch
argument_list|,
name|hz
argument_list|,
name|ath_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_stop
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|ATH_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Wake the hardware up before fiddling with it. 	 */
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_running
condition|)
block|{
comment|/* 		 * Shutdown the hardware and driver: 		 *    reset 802.11 state machine 		 *    turn off timers 		 *    disable interrupts 		 *    turn off the radio 		 *    clear transmit machinery 		 *    clear receive machinery 		 *    drain and release tx queues 		 *    reclaim beacon resources 		 *    power down hardware 		 * 		 * Note that some of this work is not possible if the 		 * hardware is gone (invalid). 		 */
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
if|if
condition|(
name|sc
operator|->
name|sc_tx99
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_tx99
operator|->
name|stop
argument_list|(
name|sc
operator|->
name|sc_tx99
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_wd_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_running
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_ledtimer
argument_list|)
expr_stmt|;
name|ath_hal_gpioset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
operator|!
name|sc
operator|->
name|sc_ledon
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_blinking
operator|=
literal|0
expr_stmt|;
block|}
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* XXX we should stop RX regardless of whether it's valid */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
block|{
name|ath_stoprecv
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ath_hal_phydisable
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_rxlink
operator|=
name|NULL
expr_stmt|;
name|ath_draintxq
argument_list|(
name|sc
argument_list|,
name|ATH_RESET_DEFAULT
argument_list|)
expr_stmt|;
name|ath_beacon_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX not needed */
block|}
comment|/* And now, restore the current power state */
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait until all pending TX/RX has completed.  *  * This waits until all existing transmit, receive and interrupts  * have completed.  It's assumed that the caller has first  * grabbed the reset lock so it doesn't try to do overlapping  * chip resets.  */
end_comment

begin_define
define|#
directive|define
name|MAX_TXRX_ITERATIONS
value|100
end_define

begin_function
specifier|static
name|void
name|ath_txrx_stop_locked
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
init|=
name|MAX_TXRX_ITERATIONS
decl_stmt|;
name|ATH_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Sleep until all the pending operations have completed. 	 * 	 * The caller must ensure that reset has been incremented 	 * or the pending operations may continue being queued. 	 */
while|while
condition|(
name|sc
operator|->
name|sc_rxproc_cnt
operator|||
name|sc
operator|->
name|sc_txproc_cnt
operator|||
name|sc
operator|->
name|sc_txstart_cnt
operator|||
name|sc
operator|->
name|sc_intr_cnt
condition|)
block|{
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_pcu_mtx
argument_list|,
literal|0
argument_list|,
literal|"ath_txrx_stop"
argument_list|,
name|msecs_to_ticks
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: didn't finish after %d iterations\n"
argument_list|,
name|__func__
argument_list|,
name|MAX_TXRX_ITERATIONS
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|MAX_TXRX_ITERATIONS
end_undef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void ath_txrx_stop(struct ath_softc *sc) { 	ATH_UNLOCK_ASSERT(sc); 	ATH_PCU_UNLOCK_ASSERT(sc);  	ATH_PCU_LOCK(sc); 	ath_txrx_stop_locked(sc); 	ATH_PCU_UNLOCK(sc); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ath_txrx_start
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|taskqueue_unblock
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Grab the reset lock, and wait around until no one else  * is trying to do anything with it.  *  * This is totally horrible but we can't hold this lock for  * long enough to do TX/RX or we end up with net80211/ip stack  * LORs and eventual deadlock.  *  * "dowait" signals whether to spin, waiting for the reset  * lock count to reach 0. This should (for now) only be used  * during the reset path, as the rest of the code may not  * be locking-reentrant enough to behave correctly.  *  * Another, cleaner way should be found to serialise all of  * these operations.  */
end_comment

begin_define
define|#
directive|define
name|MAX_RESET_ITERATIONS
value|25
end_define

begin_function
specifier|static
name|int
name|ath_reset_grablock
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dowait
parameter_list|)
block|{
name|int
name|w
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
name|MAX_RESET_ITERATIONS
decl_stmt|;
name|ATH_PCU_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|sc
operator|->
name|sc_inreset_cnt
operator|==
literal|0
condition|)
block|{
name|w
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dowait
operator|==
literal|0
condition|)
block|{
name|w
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * 1 tick is likely not enough time for long calibrations 		 * to complete.  So we should wait quite a while. 		 */
name|pause
argument_list|(
literal|"ath_reset_grablock"
argument_list|,
name|msecs_to_ticks
argument_list|(
literal|100
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|>
literal|0
condition|)
do|;
comment|/* 	 * We always increment the refcounter, regardless 	 * of whether we succeeded to get it in an exclusive 	 * way. 	 */
name|sc
operator|->
name|sc_inreset_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: didn't finish after %d iterations\n"
argument_list|,
name|__func__
argument_list|,
name|MAX_RESET_ITERATIONS
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: warning, recursive reset path!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|MAX_RESET_ITERATIONS
end_undef

begin_comment
comment|/*  * Reset the hardware w/o losing operational state.  This is  * basically a more efficient way of doing ath_stop, ath_init,  * followed by state transitions to the current 802.11  * operational state.  Used to recover from various errors and  * to reset or reload hardware state.  */
end_comment

begin_function
name|int
name|ath_reset
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ATH_RESET_TYPE
name|reset_type
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Ensure ATH_LOCK isn't held; ath_rx_proc can't be locked */
name|ATH_PCU_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Try to (stop any further TX/RX from occurring */
name|taskqueue_block
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
comment|/* 	 * Wake the hardware up. 	 */
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Grab the reset lock before TX/RX is stopped. 	 * 	 * This is needed to ensure that when the TX/RX actually does finish, 	 * no further TX/RX/reset runs in parallel with this. 	 */
if|if
condition|(
name|ath_reset_grablock
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: concurrent reset! Danger!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* disable interrupts */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Now, ensure that any in progress TX/RX completes before we 	 * continue. 	 */
name|ath_txrx_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Regardless of whether we're doing a no-loss flush or 	 * not, stop the PCU and handle what's in the RX queue. 	 * That way frames aren't dropped which shouldn't be. 	 */
name|ath_stoprecv
argument_list|(
name|sc
argument_list|,
operator|(
name|reset_type
operator|!=
name|ATH_RESET_NOLOSS
operator|)
argument_list|)
expr_stmt|;
name|ath_rx_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Should now wait for pending TX/RX to complete 	 * and block future ones from occurring. This needs to be 	 * done before the TX queue is drained. 	 */
name|ath_draintxq
argument_list|(
name|sc
argument_list|,
name|reset_type
argument_list|)
expr_stmt|;
comment|/* stop xmit side */
name|ath_settkipmic
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* configure TKIP MIC handling */
comment|/* NB: indicate channel change so we do a full reset */
name|ath_update_chainmasks
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|ath_hal_setchainmasks
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_cur_txchainmask
argument_list|,
name|sc
operator|->
name|sc_cur_rxchainmask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_reset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_opmode
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|,
name|AH_TRUE
argument_list|,
name|HAL_RESET_NORMAL
argument_list|,
operator|&
name|status
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: unable to reset hardware; hal status %u\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_diversity
operator|=
name|ath_hal_getdiversity
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ATH_RX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rx_stopped
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_rx_resetted
operator|=
literal|1
expr_stmt|;
name|ATH_RX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Quiet time handling - ensure we resync */
name|ath_vap_clear_quiet_ie
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Let DFS at it in case it's a DFS channel */
name|ath_dfs_radar_enable
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* Let spectral at in case spectral is enabled */
name|ath_spectral_enable
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* 	 * Let bluetooth coexistence at in case it's needed for this channel 	 */
name|ath_btcoex_enable
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* 	 * If we're doing TDMA, enforce the TXOP limitation for chips that 	 * support it. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_hasenforcetxop
operator|&&
name|sc
operator|->
name|sc_tdma
condition|)
name|ath_hal_setenforcetxop
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|ath_hal_setenforcetxop
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_startrecv
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
comment|/* restart recv */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: unable to start recv logic\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * We may be doing a reset in response to an ioctl 	 * that changes the channel so update any state that 	 * might change as a result. 	 */
name|ath_chan_change
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_beacons
condition|)
block|{
comment|/* restart beacons */
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|sc
operator|->
name|sc_tdma
condition|)
name|ath_tdma_config
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ath_beacon_config
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Release the reset lock and re-enable interrupts here. 	 * If an interrupt was being processed in ath_intr(), 	 * it would disable interrupts at this point. So we have 	 * to atomically enable interrupts and decrement the 	 * reset counter - this way ath_intr() doesn't end up 	 * disabling interrupts without a corresponding enable 	 * in the rest or channel change path. 	 * 	 * Grab the TX reference in case we need to transmit. 	 * That way a parallel transmit doesn't. 	 */
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_inreset_cnt
operator|--
expr_stmt|;
name|sc
operator|->
name|sc_txstart_cnt
operator|++
expr_stmt|;
comment|/* XXX only do this if sc_inreset_cnt == 0? */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * TX and RX can be started here. If it were started with 	 * sc_inreset_cnt> 0, the TX and RX path would abort. 	 * Thus if this is a nested call through the reset or 	 * channel change code, TX completion will occur but 	 * RX completion and ath_start / ath_tx_start will not 	 * run. 	 */
comment|/* Restart TX/RX as needed */
name|ath_txrx_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX TODO: we need to hold the tx refcount here! */
comment|/* Restart TX completion and pending TX */
if|if
condition|(
name|reset_type
operator|==
name|ATH_RESET_NOLOSS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|ATH_TXQ_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ath_txq_restart_dma
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_txq_sched
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txstart_cnt
operator|--
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Handle any frames in the TX queue */
comment|/* 	 * XXX should this be done by the caller, rather than 	 * ath_reset() ? 	 */
name|ath_tx_kick
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* restart xmit */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_reset_vap
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|u_long
name|cmd
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|IEEE80211_IOC_TXPOWER
case|:
comment|/* 		 * If per-packet TPC is enabled, then we have nothing 		 * to do; otherwise we need to force the global limit. 		 * All this can happen directly; no need to reset. 		 */
if|if
condition|(
operator|!
name|ath_hal_gettpc
argument_list|(
name|ah
argument_list|)
condition|)
name|ath_hal_settxpowlimit
argument_list|(
name|ah
argument_list|,
name|ic
operator|->
name|ic_txpowlimit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* XXX? Full or NOLOSS? */
return|return
name|ath_reset
argument_list|(
name|sc
argument_list|,
name|ATH_RESET_FULL
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|ath_buf
modifier|*
name|_ath_getbuf_locked
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ath_buf_type_t
name|btype
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|ATH_TXBUF_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|btype
operator|==
name|ATH_BUFTYPE_MGMT
condition|)
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf_mgmt
argument_list|)
expr_stmt|;
else|else
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_getnobuf
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_BUSY
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_getbusybuf
operator|++
expr_stmt|;
name|bf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bf
operator|!=
name|NULL
operator|&&
operator|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_BUSY
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|btype
operator|==
name|ATH_BUFTYPE_MGMT
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf_mgmt
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
else|else
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txbuf_cnt
operator|--
expr_stmt|;
comment|/* 			 * This shuldn't happen; however just to be 			 * safe print a warning and fudge the txbuf 			 * count. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_txbuf_cnt
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: sc_txbuf_cnt< 0?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txbuf_cnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
name|bf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
comment|/* XXX should check which list, mgmt or otherwise */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|__func__
argument_list|,
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|)
operator|==
name|NULL
condition|?
literal|"out of xmit buffers"
else|:
literal|"xmit buffer busy"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* XXX TODO: should do this at buffer list initialisation */
comment|/* XXX (then, ensure the buffer has the right flag set) */
name|bf
operator|->
name|bf_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|btype
operator|==
name|ATH_BUFTYPE_MGMT
condition|)
name|bf
operator|->
name|bf_flags
operator||=
name|ATH_BUF_MGMT
expr_stmt|;
else|else
name|bf
operator|->
name|bf_flags
operator|&=
operator|(
operator|~
name|ATH_BUF_MGMT
operator|)
expr_stmt|;
comment|/* Valid bf here; clear some basic fields */
name|bf
operator|->
name|bf_next
operator|=
name|NULL
expr_stmt|;
comment|/* XXX just to be sure */
name|bf
operator|->
name|bf_last
operator|=
name|NULL
expr_stmt|;
comment|/* XXX again, just to be sure */
name|bf
operator|->
name|bf_comp
operator|=
name|NULL
expr_stmt|;
comment|/* XXX again, just to be sure */
name|bzero
argument_list|(
operator|&
name|bf
operator|->
name|bf_state
argument_list|,
sizeof|sizeof
argument_list|(
name|bf
operator|->
name|bf_state
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Track the descriptor ID only if doing EDMA 	 */
if|if
condition|(
name|sc
operator|->
name|sc_isedma
condition|)
block|{
name|bf
operator|->
name|bf_descid
operator|=
name|sc
operator|->
name|sc_txbuf_descid
expr_stmt|;
name|sc
operator|->
name|sc_txbuf_descid
operator|++
expr_stmt|;
block|}
return|return
name|bf
return|;
block|}
end_function

begin_comment
comment|/*  * When retrying a software frame, buffers marked ATH_BUF_BUSY  * can't be thrown back on the queue as they could still be  * in use by the hardware.  *  * This duplicates the buffer, or returns NULL.  *  * The descriptor is also copied but the link pointers and  * the DMA segments aren't copied; this frame should thus  * be again passed through the descriptor setup/chain routines  * so the link is correct.  *  * The caller must free the buffer using ath_freebuf().  */
end_comment

begin_function
name|struct
name|ath_buf
modifier|*
name|ath_buf_clone
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|tbf
decl_stmt|;
name|tbf
operator|=
name|ath_getbuf
argument_list|(
name|sc
argument_list|,
operator|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_MGMT
operator|)
condition|?
name|ATH_BUFTYPE_MGMT
else|:
name|ATH_BUFTYPE_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbf
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* XXX failure? Why? */
comment|/* Copy basics */
name|tbf
operator|->
name|bf_next
operator|=
name|NULL
expr_stmt|;
name|tbf
operator|->
name|bf_nseg
operator|=
name|bf
operator|->
name|bf_nseg
expr_stmt|;
name|tbf
operator|->
name|bf_flags
operator|=
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_FLAGS_CLONE
expr_stmt|;
name|tbf
operator|->
name|bf_status
operator|=
name|bf
operator|->
name|bf_status
expr_stmt|;
name|tbf
operator|->
name|bf_m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
name|tbf
operator|->
name|bf_node
operator|=
name|bf
operator|->
name|bf_node
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bf
operator|->
name|bf_node
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"%s: bf_node=NULL!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* will be setup by the chain/setup function */
name|tbf
operator|->
name|bf_lastds
operator|=
name|NULL
expr_stmt|;
comment|/* for now, last == self */
name|tbf
operator|->
name|bf_last
operator|=
name|tbf
expr_stmt|;
name|tbf
operator|->
name|bf_comp
operator|=
name|bf
operator|->
name|bf_comp
expr_stmt|;
comment|/* NOTE: DMA segments will be setup by the setup/chain functions */
comment|/* The caller has to re-init the descriptor + links */
comment|/* 	 * Free the DMA mapping here, before we NULL the mbuf. 	 * We must only call bus_dmamap_unload() once per mbuf chain 	 * or behaviour is undefined. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * XXX is this POSTWRITE call required? 		 */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
block|}
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
comment|/* Copy state */
name|memcpy
argument_list|(
operator|&
name|tbf
operator|->
name|bf_state
argument_list|,
operator|&
name|bf
operator|->
name|bf_state
argument_list|,
sizeof|sizeof
argument_list|(
name|bf
operator|->
name|bf_state
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tbf
return|;
block|}
end_function

begin_function
name|struct
name|ath_buf
modifier|*
name|ath_getbuf
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ath_buf_type_t
name|btype
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bf
operator|=
name|_ath_getbuf_locked
argument_list|(
name|sc
argument_list|,
name|btype
argument_list|)
expr_stmt|;
comment|/* 	 * If a mgmt buffer was requested but we're out of those, 	 * try requesting a normal one. 	 */
if|if
condition|(
name|bf
operator|==
name|NULL
operator|&&
name|btype
operator|==
name|ATH_BUFTYPE_MGMT
condition|)
name|bf
operator|=
name|_ath_getbuf_locked
argument_list|(
name|sc
argument_list|,
name|ATH_BUFTYPE_NORMAL
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: stop queue\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_qstop
operator|++
expr_stmt|;
block|}
return|return
name|bf
return|;
block|}
end_function

begin_comment
comment|/*  * Transmit a single frame.  *  * net80211 will free the node reference if the transmit  * fails, so don't free the node reference here.  */
end_comment

begin_function
specifier|static
name|int
name|ath_transmit
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|ath_bufhead
name|frags
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* 	 * Tell the reset path that we're currently transmitting. 	 */
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_inreset_cnt
operator|>
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: sc_inreset_cnt> 0; bailing\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_qstop
operator|++
expr_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_TX
argument_list|,
literal|0
argument_list|,
literal|"ath_start_task: OACTIVE, finish"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/* XXX should be EINVAL or? */
block|}
name|sc
operator|->
name|sc_txstart_cnt
operator|++
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Wake the hardware up already */
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_TX
argument_list|,
literal|0
argument_list|,
literal|"ath_transmit: start"
argument_list|)
expr_stmt|;
comment|/* 	 * Grab the TX lock - it's ok to do this here; we haven't 	 * yet started transmitting. 	 */
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Node reference, if there's one. 	 */
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
comment|/* 	 * Enforce how deep a node queue can get. 	 * 	 * XXX it would be nicer if we kept an mbuf queue per 	 * node and only whacked them into ath_bufs when we 	 * are ready to schedule some traffic from them. 	 * .. that may come later. 	 * 	 * XXX we should also track the per-node hardware queue 	 * depth so it is easy to limit the _SUM_ of the swq and 	 * hwq frames.  Since we only schedule two HWQ frames 	 * at a time, this should be OK for now. 	 */
if|if
condition|(
operator|(
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EAPOL
operator|)
operator|)
operator|&&
operator|(
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
operator|->
name|an_swq_depth
operator|>
name|sc
operator|->
name|sc_txq_node_maxdepth
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nodeq_overflow
operator|++
expr_stmt|;
name|retval
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* 	 * Check how many TX buffers are available. 	 * 	 * If this is for non-EAPOL traffic, just leave some 	 * space free in order for buffer cloning and raw 	 * frame transmission to occur. 	 * 	 * If it's for EAPOL traffic, ignore this for now. 	 * Management traffic will be sent via the raw transmit 	 * method which bypasses this check. 	 * 	 * This is needed to ensure that EAPOL frames during 	 * (re) keying have a chance to go out. 	 * 	 * See kern/138379 for more information. 	 */
if|if
condition|(
operator|(
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EAPOL
operator|)
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_txbuf_cnt
operator|<=
name|sc
operator|->
name|sc_txq_data_minfree
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nobuf
operator|++
expr_stmt|;
name|retval
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* 	 * Grab a TX buffer and associated resources. 	 * 	 * If it's an EAPOL frame, allocate a MGMT ath_buf. 	 * That way even with temporary buffer exhaustion due to 	 * the data path doesn't leave us without the ability 	 * to transmit management frames. 	 * 	 * Otherwise allocate a normal buffer. 	 */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EAPOL
condition|)
name|bf
operator|=
name|ath_getbuf
argument_list|(
name|sc
argument_list|,
name|ATH_BUFTYPE_MGMT
argument_list|)
expr_stmt|;
else|else
name|bf
operator|=
name|ath_getbuf
argument_list|(
name|sc
argument_list|,
name|ATH_BUFTYPE_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If we failed to allocate a buffer, fail. 		 * 		 * We shouldn't fail normally, due to the check 		 * above. 		 */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nobuf
operator|++
expr_stmt|;
name|retval
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* 	 * At this point we have a buffer; so we need to free it 	 * if we hit any error conditions. 	 */
comment|/* 	 * Check for fragmentation.  If this frame 	 * has been broken up verify we have enough 	 * buffers to send all the fragments so all 	 * go out or none... 	 */
name|TAILQ_INIT
argument_list|(
operator|&
name|frags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_FRAG
operator|)
operator|&&
operator|!
name|ath_txfrag_setup
argument_list|(
name|sc
argument_list|,
operator|&
name|frags
argument_list|,
name|m
argument_list|,
name|ni
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: out of txfrag buffers\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nofrag
operator|++
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ni
operator|->
name|ni_vap
operator|->
name|iv_ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * XXXGL: is mbuf valid after ath_txfrag_setup? If yes, 		 * we shouldn't free it but return back. 		 */
name|ieee80211_free_mbuf
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * At this point if we have any TX fragments, then we will 	 * have bumped the node reference once for each of those. 	 */
comment|/* 	 * XXX Is there anything actually _enforcing_ that the 	 * fragments are being transmitted in one hit, rather than 	 * being interleaved with other transmissions on that 	 * hardware queue? 	 * 	 * The ATH TX output lock is the only thing serialising this 	 * right now. 	 */
comment|/* 	 * Calculate the "next fragment" length field in ath_buf 	 * in order to let the transmit path know enough about 	 * what to next write to the hardware. 	 */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_FRAG
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|fbf
init|=
name|bf
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|n_fbf
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|fm
init|=
name|m
operator|->
name|m_nextpkt
decl_stmt|;
comment|/* 		 * We need to walk the list of fragments and set 		 * the next size to the following buffer. 		 * However, the first buffer isn't in the frag 		 * list, so we have to do some gymnastics here. 		 */
name|TAILQ_FOREACH
argument_list|(
argument|n_fbf
argument_list|,
argument|&frags
argument_list|,
argument|bf_list
argument_list|)
block|{
name|fbf
operator|->
name|bf_nextfraglen
operator|=
name|fm
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|fbf
operator|=
name|n_fbf
expr_stmt|;
name|fm
operator|=
name|fm
operator|->
name|m_nextpkt
expr_stmt|;
block|}
block|}
name|nextfrag
label|:
comment|/* 	 * Pass the frame to the h/w for transmission. 	 * Fragmented frames have each frag chained together 	 * with m_nextpkt.  We know there are sufficient ath_buf's 	 * to send all the frags because of work done by 	 * ath_txfrag_setup.  We leave m_nextpkt set while 	 * calling ath_tx_start so it can use it to extend the 	 * the tx duration to cover the subsequent frag and 	 * so it can reclaim all the mbufs in case of an error; 	 * ath_tx_start clears m_nextpkt once it commits to 	 * handing the frame to the hardware. 	 * 	 * Note: if this fails, then the mbufs are freed but 	 * not the node reference. 	 * 	 * So, we now have to free the node reference ourselves here 	 * and return OK up to the stack. 	 */
name|next
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
if|if
condition|(
name|ath_tx_start
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|bad
label|:
name|if_inc_counter
argument_list|(
name|ni
operator|->
name|ni_vap
operator|->
name|iv_ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|reclaim
label|:
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_returnbuf_head
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* 		 * Free the rest of the node references and 		 * buffers for the fragment list. 		 */
name|ath_txfrag_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|frags
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * XXX: And free the node/return OK; ath_tx_start() may have 		 *      modified the buffer.  We currently have no way to 		 *      signify that the mbuf was freed but there was an error. 		 */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* 	 * Check here if the node is in power save state. 	 */
name|ath_tx_update_tim
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Beware of state changing between frags. 		 * XXX check sta power-save state? 		 */
if|if
condition|(
name|ni
operator|->
name|ni_vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: flush fragmented packet, state %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ni
operator|->
name|ni_vap
operator|->
name|iv_state
index|]
argument_list|)
expr_stmt|;
comment|/* XXX dmamap */
name|ieee80211_free_mbuf
argument_list|(
name|next
argument_list|)
expr_stmt|;
goto|goto
name|reclaim
goto|;
block|}
name|m
operator|=
name|next
expr_stmt|;
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|frags
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no buf for txfrag"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|frags
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
goto|goto
name|nextfrag
goto|;
block|}
comment|/* 	 * Bump watchdog timer. 	 */
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|5
expr_stmt|;
name|finish
label|:
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Finished transmitting! 	 */
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txstart_cnt
operator|--
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Sleep the hardware if required */
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_TX
argument_list|,
literal|0
argument_list|,
literal|"ath_transmit: finished"
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|error
init|=
name|ieee80211_media_change
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
comment|/* NB: only the fixed rate can change and that doesn't need a reset */
return|return
operator|(
name|error
operator|==
name|ENETRESET
condition|?
literal|0
else|:
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Block/unblock tx+rx processing while a key change is done.  * We assume the caller serializes key management operations  * so we only need to worry about synchronization with other  * uses that originate in the driver.  */
end_comment

begin_function
specifier|static
name|void
name|ath_key_update_begin
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_softc
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s:\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|taskqueue_block
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_key_update_end
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_softc
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s:\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|taskqueue_unblock
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_update_promisc
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
comment|/* configure rx filter */
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|rfilt
operator|=
name|ath_calcrxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_setrxfilter
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_MODE
argument_list|,
literal|"%s: RX filter 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Driver-internal mcast update call.  *  * Assumes the hardware is already awake.  */
end_comment

begin_function
specifier|static
name|void
name|ath_update_mcast_hw
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|u_int32_t
name|mfilt
index|[
literal|2
index|]
decl_stmt|;
comment|/* calculate and install multicast filter */
if|if
condition|(
name|ic
operator|->
name|ic_allmulti
operator|==
literal|0
condition|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
comment|/* 		 * Merge multicast addresses to form the hardware filter. 		 */
name|mfilt
index|[
literal|0
index|]
operator|=
name|mfilt
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
name|ifp
operator|=
name|vap
operator|->
name|iv_ifp
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
name|caddr_t
name|dl
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|uint8_t
name|pos
decl_stmt|;
comment|/* calculate XOR of eight 6bit values */
name|dl
operator|=
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
name|val
operator|=
name|le32dec
argument_list|(
name|dl
operator|+
literal|0
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|(
name|val
operator|>>
literal|18
operator|)
operator|^
operator|(
name|val
operator|>>
literal|12
operator|)
operator|^
operator|(
name|val
operator|>>
literal|6
operator|)
operator|^
name|val
expr_stmt|;
name|val
operator|=
name|le32dec
argument_list|(
name|dl
operator|+
literal|3
argument_list|)
expr_stmt|;
name|pos
operator|^=
operator|(
name|val
operator|>>
literal|18
operator|)
operator|^
operator|(
name|val
operator|>>
literal|12
operator|)
operator|^
operator|(
name|val
operator|>>
literal|6
operator|)
operator|^
name|val
expr_stmt|;
name|pos
operator|&=
literal|0x3f
expr_stmt|;
name|mfilt
index|[
name|pos
operator|/
literal|32
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|pos
operator|%
literal|32
operator|)
operator|)
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|mfilt
index|[
literal|0
index|]
operator|=
name|mfilt
index|[
literal|1
index|]
operator|=
operator|~
literal|0
expr_stmt|;
name|ath_hal_setmcastfilter
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|mfilt
index|[
literal|0
index|]
argument_list|,
name|mfilt
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_MODE
argument_list|,
literal|"%s: MC filter %08x:%08x\n"
argument_list|,
name|__func__
argument_list|,
name|mfilt
index|[
literal|0
index|]
argument_list|,
name|mfilt
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called from the net80211 layer - force the hardware  * awake before operating.  */
end_comment

begin_function
specifier|static
name|void
name|ath_update_mcast
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_update_mcast_hw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ath_mode_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
comment|/* XXX power state? */
comment|/* configure rx filter */
name|rfilt
operator|=
name|ath_calcrxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
comment|/* configure operational mode */
name|ath_hal_setopmode
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* handle any link-level address change */
name|ath_hal_setmac
argument_list|(
name|ah
argument_list|,
name|ic
operator|->
name|ic_macaddr
argument_list|)
expr_stmt|;
comment|/* calculate and install multicast filter */
name|ath_update_mcast_hw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the slot time based on the current setting.  */
end_comment

begin_function
name|void
name|ath_setslottime
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|u_int
name|usec
decl_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|usec
operator|=
literal|13
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|usec
operator|=
literal|21
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
block|{
comment|/* honor short/long slot time only in 11g */
comment|/* XXX shouldn't honor on pure g or turbo g channel */
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|)
name|usec
operator|=
name|HAL_SLOT_TIME_9
expr_stmt|;
else|else
name|usec
operator|=
name|HAL_SLOT_TIME_20
expr_stmt|;
block|}
else|else
name|usec
operator|=
name|HAL_SLOT_TIME_9
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: chan %u MHz flags 0x%x %s slot, %u usec\n"
argument_list|,
name|__func__
argument_list|,
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_freq
argument_list|,
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_flags
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|?
literal|"short"
else|:
literal|"long"
argument_list|,
name|usec
argument_list|)
expr_stmt|;
comment|/* Wake up the hardware first before updating the slot time */
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ath_hal_setslottime
argument_list|(
name|ah
argument_list|,
name|usec
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_updateslot
operator|=
name|OK
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from the 802.11 layer to update the  * slot time based on the current setting.  */
end_comment

begin_function
specifier|static
name|void
name|ath_updateslot
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
comment|/* 	 * When not coordinating the BSS, change the hardware 	 * immediately.  For other operation we defer the change 	 * until beacon updates have propagated to the stations. 	 * 	 * XXX sc_updateslot isn't changed behind a lock? 	 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
name|sc
operator|->
name|sc_updateslot
operator|=
name|UPDATE
expr_stmt|;
else|else
name|ath_setslottime
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append the contents of src to dst; both queues  * are assumed to be locked.  */
end_comment

begin_function
name|void
name|ath_txqmove
parameter_list|(
name|struct
name|ath_txq
modifier|*
name|dst
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|src
parameter_list|)
block|{
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|TAILQ_CONCAT
argument_list|(
operator|&
name|dst
operator|->
name|axq_q
argument_list|,
operator|&
name|src
operator|->
name|axq_q
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|dst
operator|->
name|axq_link
operator|=
name|src
operator|->
name|axq_link
expr_stmt|;
name|src
operator|->
name|axq_link
operator|=
name|NULL
expr_stmt|;
name|dst
operator|->
name|axq_depth
operator|+=
name|src
operator|->
name|axq_depth
expr_stmt|;
name|dst
operator|->
name|axq_aggr_depth
operator|+=
name|src
operator|->
name|axq_aggr_depth
expr_stmt|;
name|src
operator|->
name|axq_depth
operator|=
literal|0
expr_stmt|;
name|src
operator|->
name|axq_aggr_depth
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the hardware, with no loss.  *  * This can't be used for a general case reset.  */
end_comment

begin_function
specifier|static
name|void
name|ath_reset_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
if|#
directive|if
literal|0
block|device_printf(sc->sc_dev, "%s: resetting\n", __func__);
endif|#
directive|endif
name|ath_reset
argument_list|(
name|sc
argument_list|,
name|ATH_RESET_NOLOSS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the hardware after detecting beacons have stopped.  */
end_comment

begin_function
specifier|static
name|void
name|ath_bstuck_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|uint32_t
name|hangs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ath_hal_gethangstate
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0xff
argument_list|,
operator|&
name|hangs
argument_list|)
operator|&&
name|hangs
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"bb hang detected (0x%x)\n"
argument_list|,
name|hangs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG_ALQ
if|if
condition|(
name|if_ath_alq_checkdebug
argument_list|(
operator|&
name|sc
operator|->
name|sc_alq
argument_list|,
name|ATH_ALQ_STUCK_BEACON
argument_list|)
condition|)
name|if_ath_alq_post
argument_list|(
operator|&
name|sc
operator|->
name|sc_alq
argument_list|,
name|ATH_ALQ_STUCK_BEACON
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"stuck beacon; resetting (bmiss count %u)\n"
argument_list|,
name|sc
operator|->
name|sc_bmisscount
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_bstuck
operator|++
expr_stmt|;
comment|/* 	 * This assumes that there's no simultaneous channel mode change 	 * occurring. 	 */
name|ath_reset
argument_list|(
name|sc
argument_list|,
name|ATH_RESET_NOLOSS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_desc_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ath_descdma_setup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
literal|"tx"
argument_list|,
name|sc
operator|->
name|sc_tx_desclen
argument_list|,
name|ath_txbuf
argument_list|,
name|ATH_MAX_SCATTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
name|error
return|;
block|}
name|sc
operator|->
name|sc_txbuf_cnt
operator|=
name|ath_txbuf
expr_stmt|;
name|error
operator|=
name|ath_descdma_setup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txdma_mgmt
argument_list|,
operator|&
name|sc
operator|->
name|sc_txbuf_mgmt
argument_list|,
literal|"tx_mgmt"
argument_list|,
name|sc
operator|->
name|sc_tx_desclen
argument_list|,
name|ath_txbuf_mgmt
argument_list|,
name|ATH_TXDESC
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * XXX mark txbuf_mgmt frames with ATH_BUF_MGMT, so the 	 * flag doesn't have to be set in ath_getbuf_locked(). 	 */
name|error
operator|=
name|ath_descdma_setup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_bdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|,
literal|"beacon"
argument_list|,
name|sc
operator|->
name|sc_tx_desclen
argument_list|,
name|ATH_BCBUF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|)
expr_stmt|;
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txdma_mgmt
argument_list|,
operator|&
name|sc
operator|->
name|sc_txbuf_mgmt
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_desc_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_bdma
operator|.
name|dd_desc_len
operator|!=
literal|0
condition|)
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_bdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_txdma
operator|.
name|dd_desc_len
operator|!=
literal|0
condition|)
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_txdma_mgmt
operator|.
name|dd_desc_len
operator|!=
literal|0
condition|)
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txdma_mgmt
argument_list|,
operator|&
name|sc
operator|->
name|sc_txbuf_mgmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|ath_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
specifier|const
name|size_t
name|space
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ath_node
argument_list|)
operator|+
name|sc
operator|->
name|sc_rc
operator|->
name|arc_space
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
name|an
operator|=
name|malloc
argument_list|(
name|space
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|an
operator|==
name|NULL
condition|)
block|{
comment|/* XXX stat+msg */
return|return
name|NULL
return|;
block|}
name|ath_rate_node_init
argument_list|(
name|sc
argument_list|,
name|an
argument_list|)
expr_stmt|;
comment|/* Setup the mutex - there's no associd yet so set the name to NULL */
name|snprintf
argument_list|(
name|an
operator|->
name|an_name
argument_list|,
sizeof|sizeof
argument_list|(
name|an
operator|->
name|an_name
argument_list|)
argument_list|,
literal|"%s: node %p"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|an
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|an
operator|->
name|an_mtx
argument_list|,
name|an
operator|->
name|an_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* XXX setup ath_tid */
name|ath_tx_tid_init
argument_list|(
name|sc
argument_list|,
name|an
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE
argument_list|,
literal|"%s: %6D: an %p\n"
argument_list|,
name|__func__
argument_list|,
name|mac
argument_list|,
literal|":"
argument_list|,
name|an
argument_list|)
expr_stmt|;
return|return
operator|&
name|an
operator|->
name|an_node
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_node_cleanup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE
argument_list|,
literal|"%s: %6D: an %p\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cleanup ath_tid, free unused bufs, unlink bufs in TXQ */
name|ath_tx_node_flush
argument_list|(
name|sc
argument_list|,
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
name|ath_rate_node_cleanup
argument_list|(
name|sc
argument_list|,
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_node_cleanup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_node_free
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE
argument_list|,
literal|"%s: %6D: an %p\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
operator|->
name|an_mtx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_node_free
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_node_getsignal
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int8_t
modifier|*
name|rssi
parameter_list|,
name|int8_t
modifier|*
name|noise
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
operator|*
name|rssi
operator|=
name|ic
operator|->
name|ic_node_getrssi
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_chan
operator|!=
name|IEEE80211_CHAN_ANYC
condition|)
operator|*
name|noise
operator|=
name|ath_hal_getchannoise
argument_list|(
name|ah
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
else|else
operator|*
name|noise
operator|=
operator|-
literal|95
expr_stmt|;
comment|/* nominally correct */
block|}
end_function

begin_comment
comment|/*  * Set the default antenna.  */
end_comment

begin_function
name|void
name|ath_setdefantenna
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|antenna
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
comment|/* XXX block beacon interrupts */
name|ath_hal_setdefantenna
argument_list|(
name|ah
argument_list|,
name|antenna
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_defant
operator|!=
name|antenna
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_ant_defswitch
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_defant
operator|=
name|antenna
expr_stmt|;
name|sc
operator|->
name|sc_rxotherant
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_txq_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|int
name|qnum
parameter_list|)
block|{
name|txq
operator|->
name|axq_qnum
operator|=
name|qnum
expr_stmt|;
name|txq
operator|->
name|axq_ac
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|axq_depth
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|axq_aggr_depth
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|axq_intrcnt
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|axq_link
operator|=
name|NULL
expr_stmt|;
name|txq
operator|->
name|axq_softc
operator|=
name|sc
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|txq
operator|->
name|axq_q
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|txq
operator|->
name|axq_tidq
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|txq
operator|->
name|fifo
operator|.
name|axq_q
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK_INIT
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup a h/w transmit queue.  */
end_comment

begin_function
specifier|static
name|struct
name|ath_txq
modifier|*
name|ath_txq_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qtype
parameter_list|,
name|int
name|subtype
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_TXQ_INFO
name|qi
decl_stmt|;
name|int
name|qnum
decl_stmt|;
name|memset
argument_list|(
operator|&
name|qi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|qi
argument_list|)
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_subtype
operator|=
name|subtype
expr_stmt|;
name|qi
operator|.
name|tqi_aifs
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmin
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmax
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
comment|/* 	 * Enable interrupts only for EOL and DESC conditions. 	 * We mark tx descriptors to receive a DESC interrupt 	 * when a tx queue gets deep; otherwise waiting for the 	 * EOL to reap descriptors.  Note that this is done to 	 * reduce interrupt load and this only defers reaping 	 * descriptors, never transmitting frames.  Aside from 	 * reducing interrupts this also permits more concurrency. 	 * The only potential downside is if the tx queue backs 	 * up in which case the top half of the kernel may backup 	 * due to a lack of tx descriptors. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_isedma
condition|)
name|qi
operator|.
name|tqi_qflags
operator|=
name|HAL_TXQ_TXEOLINT_ENABLE
operator||
name|HAL_TXQ_TXOKINT_ENABLE
expr_stmt|;
else|else
name|qi
operator|.
name|tqi_qflags
operator|=
name|HAL_TXQ_TXEOLINT_ENABLE
operator||
name|HAL_TXQ_TXDESCINT_ENABLE
expr_stmt|;
name|qnum
operator|=
name|ath_hal_setuptxqueue
argument_list|(
name|ah
argument_list|,
name|qtype
argument_list|,
operator|&
name|qi
argument_list|)
expr_stmt|;
if|if
condition|(
name|qnum
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * NB: don't print a message, this happens 		 * normally on parts with too few tx queues 		 */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|qnum
operator|>=
name|nitems
argument_list|(
name|sc
operator|->
name|sc_txq
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"hal qnum %u out of range, max %zu!\n"
argument_list|,
name|qnum
argument_list|,
name|nitems
argument_list|(
name|sc
operator|->
name|sc_txq
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_releasetxqueue
argument_list|(
name|ah
argument_list|,
name|qnum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|qnum
argument_list|)
condition|)
block|{
name|ath_txq_init
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|qnum
index|]
argument_list|,
name|qnum
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txqsetup
operator||=
literal|1
operator|<<
name|qnum
expr_stmt|;
block|}
return|return
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|qnum
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Setup a hardware data transmit queue for the specified  * access control.  The hal may not support all requested  * queues in which case it will return a reference to a  * previously setup queue.  We record the mapping from ac's  * to h/w queues for use by ath_tx_start and also track  * the set of h/w queues being used to optimize work in the  * transmit interrupt handler and related routines.  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ac
parameter_list|,
name|int
name|haltype
parameter_list|)
block|{
name|struct
name|ath_txq
modifier|*
name|txq
decl_stmt|;
if|if
condition|(
name|ac
operator|>=
name|nitems
argument_list|(
name|sc
operator|->
name|sc_ac2q
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"AC %u out of range, max %zu!\n"
argument_list|,
name|ac
argument_list|,
name|nitems
argument_list|(
name|sc
operator|->
name|sc_ac2q
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|txq
operator|=
name|ath_txq_setup
argument_list|(
name|sc
argument_list|,
name|HAL_TX_QUEUE_DATA
argument_list|,
name|haltype
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|!=
name|NULL
condition|)
block|{
name|txq
operator|->
name|axq_ac
operator|=
name|ac
expr_stmt|;
name|sc
operator|->
name|sc_ac2q
index|[
name|ac
index|]
operator|=
name|txq
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Update WME parameters for a transmit queue.  */
end_comment

begin_function
specifier|static
name|int
name|ath_txq_update
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ac
parameter_list|)
block|{
define|#
directive|define
name|ATH_EXPONENT_TO_VALUE
parameter_list|(
name|v
parameter_list|)
value|((1<<v)-1)
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
init|=
name|sc
operator|->
name|sc_ac2q
index|[
name|ac
index|]
decl_stmt|;
name|struct
name|wmeParams
modifier|*
name|wmep
init|=
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|ac
index|]
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_TXQ_INFO
name|qi
decl_stmt|;
name|ath_hal_gettxqueueprops
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|&
name|qi
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|sc
operator|->
name|sc_tdma
condition|)
block|{
comment|/* 		 * AIFS is zero so there's no pre-transmit wait.  The 		 * burst time defines the slot duration and is configured 		 * through net80211.  The QCU is setup to not do post-xmit 		 * back off, lockout all lower-priority QCU's, and fire 		 * off the DMA beacon alert timer which is setup based 		 * on the slot configuration. 		 */
name|qi
operator|.
name|tqi_qflags
operator|=
name|HAL_TXQ_TXOKINT_ENABLE
operator||
name|HAL_TXQ_TXERRINT_ENABLE
operator||
name|HAL_TXQ_TXURNINT_ENABLE
operator||
name|HAL_TXQ_TXEOLINT_ENABLE
operator||
name|HAL_TXQ_DBA_GATED
operator||
name|HAL_TXQ_BACKOFF_DISABLE
operator||
name|HAL_TXQ_ARB_LOCKOUT_GLOBAL
expr_stmt|;
name|qi
operator|.
name|tqi_aifs
operator|=
literal|0
expr_stmt|;
comment|/* XXX +dbaprep? */
name|qi
operator|.
name|tqi_readyTime
operator|=
name|sc
operator|->
name|sc_tdmaslotlen
expr_stmt|;
name|qi
operator|.
name|tqi_burstTime
operator|=
name|qi
operator|.
name|tqi_readyTime
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* 		 * XXX shouldn't this just use the default flags 		 * used in the previous queue setup? 		 */
name|qi
operator|.
name|tqi_qflags
operator|=
name|HAL_TXQ_TXOKINT_ENABLE
operator||
name|HAL_TXQ_TXERRINT_ENABLE
operator||
name|HAL_TXQ_TXDESCINT_ENABLE
operator||
name|HAL_TXQ_TXURNINT_ENABLE
operator||
name|HAL_TXQ_TXEOLINT_ENABLE
expr_stmt|;
name|qi
operator|.
name|tqi_aifs
operator|=
name|wmep
operator|->
name|wmep_aifsn
expr_stmt|;
name|qi
operator|.
name|tqi_cwmin
operator|=
name|ATH_EXPONENT_TO_VALUE
argument_list|(
name|wmep
operator|->
name|wmep_logcwmin
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_cwmax
operator|=
name|ATH_EXPONENT_TO_VALUE
argument_list|(
name|wmep
operator|->
name|wmep_logcwmax
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_readyTime
operator|=
literal|0
expr_stmt|;
name|qi
operator|.
name|tqi_burstTime
operator|=
name|IEEE80211_TXOP_TO_US
argument_list|(
name|wmep
operator|->
name|wmep_txopLimit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
block|}
endif|#
directive|endif
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: Q%u qflags 0x%x aifs %u cwmin %u cwmax %u burstTime %u\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|qi
operator|.
name|tqi_qflags
argument_list|,
name|qi
operator|.
name|tqi_aifs
argument_list|,
name|qi
operator|.
name|tqi_cwmin
argument_list|,
name|qi
operator|.
name|tqi_cwmax
argument_list|,
name|qi
operator|.
name|tqi_burstTime
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_settxqueueprops
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|&
name|qi
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to update hardware queue "
literal|"parameters for %s traffic!\n"
argument_list|,
name|ieee80211_wme_acnames
index|[
name|ac
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|ath_hal_resettxqueue
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
comment|/* push to h/w */
return|return
literal|1
return|;
block|}
undef|#
directive|undef
name|ATH_EXPONENT_TO_VALUE
block|}
end_function

begin_comment
comment|/*  * Callback from the 802.11 layer to update WME parameters.  */
end_comment

begin_function
name|int
name|ath_wme_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
return|return
operator|!
name|ath_txq_update
argument_list|(
name|sc
argument_list|,
name|WME_AC_BE
argument_list|)
operator|||
operator|!
name|ath_txq_update
argument_list|(
name|sc
argument_list|,
name|WME_AC_BK
argument_list|)
operator|||
operator|!
name|ath_txq_update
argument_list|(
name|sc
argument_list|,
name|WME_AC_VI
argument_list|)
operator|||
operator|!
name|ath_txq_update
argument_list|(
name|sc
argument_list|,
name|WME_AC_VO
argument_list|)
condition|?
name|EIO
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Reclaim resources for a setup queue.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_cleanupq
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
name|ath_hal_releasetxqueue
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txqsetup
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|txq
operator|->
name|axq_qnum
operator|)
expr_stmt|;
name|ATH_TXQ_LOCK_DESTROY
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim all tx queue resources.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ATH_TXBUF_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
condition|)
name|ath_tx_cleanupq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return h/w rate index for an IEEE rate (w/o basic rate bit)  * using the current rates in sc_rixmap.  */
end_comment

begin_function
name|int
name|ath_tx_findrix
parameter_list|(
specifier|const
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|rate
parameter_list|)
block|{
name|int
name|rix
init|=
name|sc
operator|->
name|sc_rixmap
index|[
name|rate
index|]
decl_stmt|;
comment|/* NB: return lowest rix for invalid rate */
return|return
operator|(
name|rix
operator|==
literal|0xff
condition|?
literal|0
else|:
name|rix
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tx_update_stats
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tx_status
modifier|*
name|ts
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|int
name|sr
decl_stmt|,
name|lr
decl_stmt|,
name|pri
decl_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_status
operator|==
literal|0
condition|)
block|{
name|u_int8_t
name|txant
init|=
name|ts
operator|->
name|ts_antenna
decl_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_ant_tx
index|[
name|txant
index|]
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_ant_tx
index|[
name|txant
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_finaltsi
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_altrate
operator|++
expr_stmt|;
comment|/* XXX TODO: should do per-pri conuters */
name|pri
operator|=
name|M_WME_GETAC
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
if|if
condition|(
name|pri
operator|>=
name|WME_AC_VO
condition|)
name|ic
operator|->
name|ic_wme
operator|.
name|wme_hipri_traffic
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
name|ni
operator|->
name|ni_inact
operator|=
name|ni
operator|->
name|ni_inact_reload
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TXERR_XRETRY
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_xretries
operator|++
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TXERR_FIFO
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_fifoerr
operator|++
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TXERR_FILT
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_filtered
operator|++
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TXERR_XTXOP
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_xtxop
operator|++
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TXERR_TIMER_EXPIRED
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_timerexpired
operator|++
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|->
name|m_flags
operator|&
name|M_FF
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_ff_txerr
operator|++
expr_stmt|;
block|}
comment|/* XXX when is this valid? */
if|if
condition|(
name|ts
operator|->
name|ts_flags
operator|&
name|HAL_TX_DESC_CFG_ERR
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_desccfgerr
operator|++
expr_stmt|;
comment|/* 	 * This can be valid for successful frame transmission! 	 * If there's a TX FIFO underrun during aggregate transmission, 	 * the MAC will pad the rest of the aggregate with delimiters. 	 * If a BA is returned, the frame is marked as "OK" and it's up 	 * to the TX completion code to notice which frames weren't 	 * successfully transmitted. 	 */
if|if
condition|(
name|ts
operator|->
name|ts_flags
operator|&
name|HAL_TX_DATA_UNDERRUN
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_data_underrun
operator|++
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_flags
operator|&
name|HAL_TX_DELIM_UNDERRUN
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_delim_underrun
operator|++
expr_stmt|;
name|sr
operator|=
name|ts
operator|->
name|ts_shortretry
expr_stmt|;
name|lr
operator|=
name|ts
operator|->
name|ts_longretry
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_shortretry
operator|+=
name|sr
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_longretry
operator|+=
name|lr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The default completion. If fail is 1, this means  * "please don't retry the frame, and just return -1 status  * to the net80211 stack.  */
end_comment

begin_function
name|void
name|ath_tx_default_comp
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|int
name|fail
parameter_list|)
block|{
name|struct
name|ath_tx_status
modifier|*
name|ts
init|=
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_txstat
decl_stmt|;
name|int
name|st
decl_stmt|;
if|if
condition|(
name|fail
operator|==
literal|1
condition|)
name|st
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|st
operator|=
operator|(
operator|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
operator|)
condition|?
name|ts
operator|->
name|ts_status
else|:
name|HAL_TXERR_XRETRY
expr_stmt|;
if|#
directive|if
literal|0
block|if (bf->bf_state.bfs_dobaw) 		device_printf(sc->sc_dev, 		    "%s: bf %p: seqno %d: dobaw should've been cleared!\n", 		    __func__, 		    bf, 		    SEQNO(bf->bf_state.bfs_seqno));
endif|#
directive|endif
if|if
condition|(
name|bf
operator|->
name|bf_next
operator|!=
name|NULL
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bf %p: seqno %d: bf_next not NULL!\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check if the node software queue is empty; if so 	 * then clear the TIM. 	 * 	 * This needs to be done before the buffer is freed as 	 * otherwise the node reference will have been released 	 * and the node may not actually exist any longer. 	 * 	 * XXX I don't like this belonging here, but it's cleaner 	 * to do it here right now then all the other places 	 * where ath_tx_default_comp() is called. 	 * 	 * XXX TODO: during drain, ensure that the callback is 	 * being called so we get a chance to update the TIM. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_node
condition|)
block|{
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_tx_update_tim
argument_list|(
name|sc
argument_list|,
name|bf
operator|->
name|bf_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Do any tx complete callback.  Note this must 	 * be done before releasing the node reference. 	 * This will free the mbuf, release the net80211 	 * node and recycle the ath_buf. 	 */
name|ath_tx_freebuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|st
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update rate control with the given completion status.  */
end_comment

begin_function
name|void
name|ath_tx_update_ratectrl
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_rc_series
modifier|*
name|rc
parameter_list|,
name|struct
name|ath_tx_status
modifier|*
name|ts
parameter_list|,
name|int
name|frmlen
parameter_list|,
name|int
name|nframes
parameter_list|,
name|int
name|nbad
parameter_list|)
block|{
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
comment|/* Only for unicast frames */
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
return|return;
name|an
operator|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ATH_NODE_UNLOCK_ASSERT
argument_list|(
name|an
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TXERR_FILT
operator|)
operator|==
literal|0
condition|)
block|{
name|ATH_NODE_LOCK
argument_list|(
name|an
argument_list|)
expr_stmt|;
name|ath_rate_tx_complete
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|rc
argument_list|,
name|ts
argument_list|,
name|frmlen
argument_list|,
name|nframes
argument_list|,
name|nbad
argument_list|)
expr_stmt|;
name|ATH_NODE_UNLOCK
argument_list|(
name|an
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process the completion of the given buffer.  *  * This calls the rate control update and then the buffer completion.  * This will either free the buffer or requeue it.  In any case, the  * bf pointer should be treated as invalid after this function is called.  */
end_comment

begin_function
name|void
name|ath_tx_process_buf_completion
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|ath_tx_status
modifier|*
name|ts
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|ATH_TX_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* If unicast frame, update general statistics */
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
comment|/* update statistics */
name|ath_tx_update_stats
argument_list|(
name|sc
argument_list|,
name|ts
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Call the completion handler. 	 * The completion handler is responsible for 	 * calling the rate control code. 	 * 	 * Frames with no completion handler get the 	 * rate control code called here. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_comp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TXERR_FILT
operator|)
operator|==
literal|0
operator|&&
operator|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * XXX assume this isn't an aggregate 			 * frame. 			 */
name|ath_tx_update_ratectrl
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|,
name|ts
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
argument_list|,
literal|1
argument_list|,
operator|(
name|ts
operator|->
name|ts_status
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|bf
operator|->
name|bf_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process completed xmit descriptors from the specified queue.  * Kick the packet scheduler if needed. This can occur from this  * particular task.  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_processq
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|int
name|dosched
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|struct
name|ath_tx_status
modifier|*
name|ts
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
endif|#
directive|endif
comment|/* IEEE80211_SUPPORT_SUPERG */
name|int
name|nacked
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_TX_PROC
argument_list|,
literal|"%s: tx queue %u head %p link %p\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ath_hal_gettxbuf
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
argument_list|,
name|txq
operator|->
name|axq_link
argument_list|)
expr_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_TXCOMP
argument_list|,
literal|4
argument_list|,
literal|"ath_tx_processq: txq=%u head %p link %p depth %p"
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ath_hal_gettxbuf
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
argument_list|,
name|txq
operator|->
name|axq_link
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
name|nacked
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|txq
operator|->
name|axq_intrcnt
operator|=
literal|0
expr_stmt|;
comment|/* reset periodic desc intr count */
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|axq_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
break|break;
block|}
name|ds
operator|=
name|bf
operator|->
name|bf_lastds
expr_stmt|;
comment|/* XXX must be setup correctly! */
name|ts
operator|=
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_txstat
expr_stmt|;
name|status
operator|=
name|ath_hal_txprocdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|ts
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_XMIT_DESC
condition|)
name|ath_printtxbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
literal|0
argument_list|,
name|status
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_RESET
operator|)
operator|&&
operator|(
name|dosched
operator|==
literal|0
operator|)
condition|)
name|ath_printtxbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
literal|0
argument_list|,
name|status
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ATH_DEBUG_ALQ
if|if
condition|(
name|if_ath_alq_checkdebug
argument_list|(
operator|&
name|sc
operator|->
name|sc_alq
argument_list|,
name|ATH_ALQ_EDMA_TXSTATUS
argument_list|)
condition|)
block|{
name|if_ath_alq_post
argument_list|(
operator|&
name|sc
operator|->
name|sc_alq
argument_list|,
name|ATH_ALQ_EDMA_TXSTATUS
argument_list|,
name|sc
operator|->
name|sc_tx_statuslen
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ds
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|status
operator|==
name|HAL_EINPROGRESS
condition|)
block|{
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_TXCOMP
argument_list|,
literal|3
argument_list|,
literal|"ath_tx_processq: txq=%u, bf=%p ds=%p, HAL_EINPROGRESS"
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|bf
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
break|break;
block|}
name|ATH_TXQ_REMOVE
argument_list|(
name|txq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
comment|/* 		 * Sanity check. 		 */
if|if
condition|(
name|txq
operator|->
name|axq_qnum
operator|!=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tx_queue
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: TXQ=%d: bf=%p, bfs_tx_queue=%d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|bf
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tx_queue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|txq
operator|->
name|axq_qnum
operator|!=
name|bf
operator|->
name|bf_last
operator|->
name|bf_state
operator|.
name|bfs_tx_queue
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: TXQ=%d: bf_last=%p, bfs_tx_queue=%d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|bf
operator|->
name|bf_last
argument_list|,
name|bf
operator|->
name|bf_last
operator|->
name|bf_state
operator|.
name|bfs_tx_queue
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (txq->axq_depth> 0) {
comment|/* 			 * More frames follow.  Mark the buffer busy 			 * so it's not re-used while the hardware may 			 * still re-read the link field in the descriptor. 			 * 			 * Use the last buffer in an aggregate as that 			 * is where the hardware may be - intermediate 			 * descriptors won't be "busy". 			 */
block|bf->bf_last->bf_flags |= ATH_BUF_BUSY; 		} else 			txq->axq_link = NULL;
else|#
directive|else
name|bf
operator|->
name|bf_last
operator|->
name|bf_flags
operator||=
name|ATH_BUF_BUSY
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
condition|)
name|txq
operator|->
name|axq_aggr_depth
operator|--
expr_stmt|;
name|ni
operator|=
name|bf
operator|->
name|bf_node
expr_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_TXCOMP
argument_list|,
literal|5
argument_list|,
literal|"ath_tx_processq: txq=%u, bf=%p, ds=%p, ni=%p, ts_status=0x%08x"
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|bf
argument_list|,
name|ds
argument_list|,
name|ni
argument_list|,
name|ts
operator|->
name|ts_status
argument_list|)
expr_stmt|;
comment|/* 		 * If unicast frame was ack'd update RSSI, 		 * including the last rx time used to 		 * workaround phantom bmiss interrupts. 		 */
if|if
condition|(
name|ni
operator|!=
name|NULL
operator|&&
name|ts
operator|->
name|ts_status
operator|==
literal|0
operator|&&
operator|(
operator|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|nacked
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_rssi
operator|=
name|ts
operator|->
name|ts_rssi
expr_stmt|;
name|ATH_RSSI_LPF
argument_list|(
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgtxrssi
argument_list|,
name|ts
operator|->
name|ts_rssi
argument_list|)
expr_stmt|;
block|}
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* 		 * Update statistics and call completion 		 */
name|ath_tx_process_buf_completion
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|ts
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* XXX at this point, bf and ni may be totally invalid */
block|}
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
comment|/* 	 * Flush fast-frame staging queue when traffic slows. 	 */
if|if
condition|(
name|txq
operator|->
name|axq_depth
operator|<=
literal|1
condition|)
name|ieee80211_ff_flush
argument_list|(
name|ic
argument_list|,
name|txq
operator|->
name|axq_ac
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Kick the software TXQ scheduler */
if|if
condition|(
name|dosched
condition|)
block|{
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_txq_sched
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_TXCOMP
argument_list|,
literal|1
argument_list|,
literal|"ath_tx_processq: txq=%u: done"
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
return|return
name|nacked
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TXQACTIVE
parameter_list|(
name|t
parameter_list|,
name|q
parameter_list|)
value|( (t)& (1<< (q)))
end_define

begin_comment
comment|/*  * Deferred processing of transmit interrupt; special-cased  * for a single hardware transmit queue (e.g. 5210 and 5211).  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_proc_q0
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|uint32_t
name|txqs
decl_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txproc_cnt
operator|++
expr_stmt|;
name|txqs
operator|=
name|sc
operator|->
name|sc_txq_active
expr_stmt|;
name|sc
operator|->
name|sc_txq_active
operator|&=
operator|~
name|txqs
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_TXCOMP
argument_list|,
literal|1
argument_list|,
literal|"ath_tx_proc_q0: txqs=0x%08x"
argument_list|,
name|txqs
argument_list|)
expr_stmt|;
if|if
condition|(
name|TXQACTIVE
argument_list|(
name|txqs
argument_list|,
literal|0
argument_list|)
operator|&&
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
condition|)
comment|/* XXX why is lastrx updated in tx code? */
name|sc
operator|->
name|sc_lastrx
operator|=
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|TXQACTIVE
argument_list|(
name|txqs
argument_list|,
name|sc
operator|->
name|sc_cabq
operator|->
name|axq_qnum
argument_list|)
condition|)
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_cabq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
name|ath_led_event
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_txrix
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txproc_cnt
operator|--
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_tx_kick
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deferred processing of transmit interrupt; special-cased  * for four hardware queues, 0-3 (e.g. 5212 w/ WME support).  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_proc_q0123
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|nacked
decl_stmt|;
name|uint32_t
name|txqs
decl_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txproc_cnt
operator|++
expr_stmt|;
name|txqs
operator|=
name|sc
operator|->
name|sc_txq_active
expr_stmt|;
name|sc
operator|->
name|sc_txq_active
operator|&=
operator|~
name|txqs
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_TXCOMP
argument_list|,
literal|1
argument_list|,
literal|"ath_tx_proc_q0123: txqs=0x%08x"
argument_list|,
name|txqs
argument_list|)
expr_stmt|;
comment|/* 	 * Process each active queue. 	 */
name|nacked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TXQACTIVE
argument_list|(
name|txqs
argument_list|,
literal|0
argument_list|)
condition|)
name|nacked
operator|+=
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TXQACTIVE
argument_list|(
name|txqs
argument_list|,
literal|1
argument_list|)
condition|)
name|nacked
operator|+=
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TXQACTIVE
argument_list|(
name|txqs
argument_list|,
literal|2
argument_list|)
condition|)
name|nacked
operator|+=
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|2
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TXQACTIVE
argument_list|(
name|txqs
argument_list|,
literal|3
argument_list|)
condition|)
name|nacked
operator|+=
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|3
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TXQACTIVE
argument_list|(
name|txqs
argument_list|,
name|sc
operator|->
name|sc_cabq
operator|->
name|axq_qnum
argument_list|)
condition|)
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_cabq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nacked
condition|)
name|sc
operator|->
name|sc_lastrx
operator|=
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
name|ath_led_event
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_txrix
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txproc_cnt
operator|--
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_tx_kick
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deferred processing of transmit interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nacked
decl_stmt|;
name|uint32_t
name|txqs
decl_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txproc_cnt
operator|++
expr_stmt|;
name|txqs
operator|=
name|sc
operator|->
name|sc_txq_active
expr_stmt|;
name|sc
operator|->
name|sc_txq_active
operator|&=
operator|~
name|txqs
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_TXCOMP
argument_list|,
literal|1
argument_list|,
literal|"ath_tx_proc: txqs=0x%08x"
argument_list|,
name|txqs
argument_list|)
expr_stmt|;
comment|/* 	 * Process each active queue. 	 */
name|nacked
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
operator|&&
name|TXQACTIVE
argument_list|(
name|txqs
argument_list|,
name|i
argument_list|)
condition|)
name|nacked
operator|+=
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nacked
condition|)
name|sc
operator|->
name|sc_lastrx
operator|=
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
name|ath_led_event
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_txrix
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txproc_cnt
operator|--
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_tx_kick
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|TXQACTIVE
end_undef

begin_comment
comment|/*  * Deferred processing of TXQ rescheduling.  */
end_comment

begin_function
specifier|static
name|void
name|ath_txq_sched_tasklet
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* XXX is skipping ok? */
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (sc->sc_inreset_cnt> 0) { 		device_printf(sc->sc_dev, 		    "%s: sc_inreset_cnt> 0; skipping\n", __func__); 		ATH_PCU_UNLOCK(sc); 		return; 	}
endif|#
directive|endif
name|sc
operator|->
name|sc_txproc_cnt
operator|++
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|ath_txq_sched
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txproc_cnt
operator|--
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ath_returnbuf_tail
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|ATH_TXBUF_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_MGMT
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf_mgmt
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
else|else
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txbuf_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_txbuf_cnt
operator|>
name|ath_txbuf
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: sc_txbuf_cnt> %d?\n"
argument_list|,
name|__func__
argument_list|,
name|ath_txbuf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txbuf_cnt
operator|=
name|ath_txbuf
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ath_returnbuf_head
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|ATH_TXBUF_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_MGMT
condition|)
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf_mgmt
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
else|else
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txbuf_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_txbuf_cnt
operator|>
name|ATH_TXBUF
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: sc_txbuf_cnt> %d?\n"
argument_list|,
name|__func__
argument_list|,
name|ATH_TXBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txbuf_cnt
operator|=
name|ATH_TXBUF
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Free the holding buffer if it exists  */
end_comment

begin_function
name|void
name|ath_txq_freeholdingbuf
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
name|ATH_TXBUF_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|axq_holdingbf
operator|==
name|NULL
condition|)
return|return;
name|txq
operator|->
name|axq_holdingbf
operator|->
name|bf_flags
operator|&=
operator|~
name|ATH_BUF_BUSY
expr_stmt|;
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_returnbuf_tail
argument_list|(
name|sc
argument_list|,
name|txq
operator|->
name|axq_holdingbf
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|txq
operator|->
name|axq_holdingbf
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add this buffer to the holding queue, freeing the previous  * one if it exists.  */
end_comment

begin_function
specifier|static
name|void
name|ath_txq_addholdingbuf
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_txq
modifier|*
name|txq
decl_stmt|;
name|txq
operator|=
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tx_queue
index|]
expr_stmt|;
name|ATH_TXBUF_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* XXX assert ATH_BUF_BUSY is set */
comment|/* XXX assert the tx queue is under the max number */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tx_queue
operator|>
name|HAL_NUM_TX_QUEUES
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bf=%p: invalid tx queue (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tx_queue
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_flags
operator|&=
operator|~
name|ATH_BUF_BUSY
expr_stmt|;
name|ath_returnbuf_tail
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
return|return;
block|}
name|ath_txq_freeholdingbuf
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
name|txq
operator|->
name|axq_holdingbf
operator|=
name|bf
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return a buffer to the pool and update the 'busy' flag on the  * previous 'tail' entry.  *  * This _must_ only be called when the buffer is involved in a completed  * TX. The logic is that if it was part of an active TX, the previous  * buffer on the list is now not involved in a halted TX DMA queue, waiting  * for restart (eg for TDMA.)  *  * The caller must free the mbuf and recycle the node reference.  *  * XXX This method of handling busy / holding buffers is insanely stupid.  * It requires bf_state.bfs_tx_queue to be correctly assigned.  It would  * be much nicer if buffers in the processq() methods would instead be  * always completed there (pushed onto a txq or ath_bufhead) so we knew  * exactly what hardware queue they came from in the first place.  */
end_comment

begin_function
name|void
name|ath_freebuf
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_txq
modifier|*
name|txq
decl_stmt|;
name|txq
operator|=
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tx_queue
index|]
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bf
operator|->
name|bf_node
operator|==
name|NULL
operator|)
argument_list|,
operator|(
literal|"%s: bf->bf_node != NULL\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bf
operator|->
name|bf_m
operator|==
name|NULL
operator|)
argument_list|,
operator|(
literal|"%s: bf->bf_m != NULL\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If this buffer is busy, push it onto the holding queue. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_BUSY
condition|)
block|{
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|ath_txq_addholdingbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Not a busy buffer, so free normally 	 */
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_returnbuf_tail
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is currently used by ath_tx_draintxq() and  * ath_tx_tid_free_pkts().  *  * It recycles a single ath_buf.  */
end_comment

begin_function
name|void
name|ath_tx_freebuf
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
init|=
name|bf
operator|->
name|bf_m
decl_stmt|;
comment|/* 	 * Make sure that we only sync/unload if there's an mbuf. 	 * If not (eg we cloned a buffer), the unload will have already 	 * occurred. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
block|}
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
comment|/* Free the buffer, it's not needed any longer */
name|ath_freebuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* Pass the buffer back to net80211 - completing it */
name|ieee80211_tx_complete
argument_list|(
name|ni
argument_list|,
name|m0
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ath_buf
modifier|*
name|ath_tx_draintxq_get_one
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* 	 * Drain the FIFO queue first, then if it's 	 * empty, move to the normal frame queue. 	 */
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|fifo
operator|.
name|axq_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Is it the last buffer in this set? 		 * Decrement the FIFO counter. 		 */
if|if
condition|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_FIFOEND
condition|)
block|{
if|if
condition|(
name|txq
operator|->
name|axq_fifo_depth
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Q%d: fifo_depth=0, fifo.axq_depth=%d?\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|txq
operator|->
name|fifo
operator|.
name|axq_depth
argument_list|)
expr_stmt|;
block|}
else|else
name|txq
operator|->
name|axq_fifo_depth
operator|--
expr_stmt|;
block|}
name|ATH_TXQ_REMOVE
argument_list|(
operator|&
name|txq
operator|->
name|fifo
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|bf
operator|)
return|;
block|}
comment|/* 	 * Debugging! 	 */
if|if
condition|(
name|txq
operator|->
name|axq_fifo_depth
operator|!=
literal|0
operator|||
name|txq
operator|->
name|fifo
operator|.
name|axq_depth
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Q%d: fifo_depth=%d, fifo.axq_depth=%d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|txq
operator|->
name|axq_fifo_depth
argument_list|,
name|txq
operator|->
name|fifo
operator|.
name|axq_depth
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now drain the pending queue. 	 */
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|axq_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|txq
operator|->
name|axq_link
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ATH_TXQ_REMOVE
argument_list|(
name|txq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|bf
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ath_tx_draintxq
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ATH_DEBUG
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
endif|#
directive|endif
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|u_int
name|ix
decl_stmt|;
comment|/* 	 * NB: this assumes output has been stopped and 	 *     we do not need to block ath_tx_proc 	 */
for|for
control|(
name|ix
operator|=
literal|0
init|;
condition|;
name|ix
operator|++
control|)
block|{
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|bf
operator|=
name|ath_tx_draintxq_get_one
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
condition|)
name|txq
operator|->
name|axq_aggr_depth
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_RESET
condition|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
comment|/* 			 * EDMA operation has a TX completion FIFO 			 * separate from the TX descriptor, so this 			 * method of checking the "completion" status 			 * is wrong. 			 */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_isedma
condition|)
block|{
name|status
operator|=
operator|(
name|ath_hal_txprocdesc
argument_list|(
name|ah
argument_list|,
name|bf
operator|->
name|bf_lastds
argument_list|,
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_txstat
argument_list|)
operator|==
name|HAL_OK
operator|)
expr_stmt|;
block|}
name|ath_printtxbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|ix
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|,
specifier|const
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|bf
operator|->
name|bf_m
operator|->
name|m_len
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ATH_DEBUG */
comment|/* 		 * Since we're now doing magic in the completion 		 * functions, we -must- call it for aggregation 		 * destinations or BAW tracking will get upset. 		 */
comment|/* 		 * Clear ATH_BUF_BUSY; the completion handler 		 * will free the buffer. 		 */
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_flags
operator|&=
operator|~
name|ATH_BUF_BUSY
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_comp
condition|)
name|bf
operator|->
name|bf_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free the holding buffer if it exists 	 */
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|ath_txq_freeholdingbuf
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* 	 * Drain software queued frames which are on 	 * active TIDs. 	 */
name|ath_tx_txq_drain
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tx_stopdma
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: tx queue [%u] %p, active=%d, hwpending=%d, flags 0x%08x, "
literal|"link %p, holdingbf=%p\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ath_hal_gettxbuf
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|!
operator|!
name|ath_hal_txqenabled
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|ath_hal_numtxpending
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
argument_list|,
name|txq
operator|->
name|axq_flags
argument_list|,
name|txq
operator|->
name|axq_link
argument_list|,
name|txq
operator|->
name|axq_holdingbf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
comment|/* We've stopped TX DMA, so mark this as stopped. */
name|txq
operator|->
name|axq_flags
operator|&=
operator|~
name|ATH_TXQ_PUTRUNNING
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_RESET
operator|)
operator|&&
operator|(
name|txq
operator|->
name|axq_holdingbf
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ath_printtxbuf
argument_list|(
name|sc
argument_list|,
name|txq
operator|->
name|axq_holdingbf
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|ath_stoptxdma
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* XXX return value */
if|if
condition|(
name|sc
operator|->
name|sc_invalid
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
block|{
comment|/* don't touch the hardware if marked invalid */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: tx queue [%u] %p, link %p\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ath_hal_gettxbuf
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* stop the beacon queue */
operator|(
name|void
operator|)
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
comment|/* Stop the data queues */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|ATH_TXQ_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ath_tx_stopdma
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_DEBUG
end_ifdef

begin_function
name|void
name|ath_tx_dump
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_RESET
operator|)
condition|)
return|return;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Q%d: begin\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&txq->axq_q
argument_list|,
argument|bf_list
argument_list|)
block|{
name|ath_printtxbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|i
argument_list|,
name|ath_hal_txprocdesc
argument_list|(
name|ah
argument_list|,
name|bf
operator|->
name|bf_lastds
argument_list|,
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_txstat
argument_list|)
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Q%d: end\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATH_DEBUG */
end_comment

begin_comment
comment|/*  * Drain the transmit queues and reclaim resources.  */
end_comment

begin_function
name|void
name|ath_legacy_tx_drain
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ATH_RESET_TYPE
name|reset_type
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf_last
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|ath_stoptxdma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Dump the queue contents 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * XXX TODO: should we just handle the completed TX frames 		 * here, whether or not the reset is a full one or not? 		 */
if|if
condition|(
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_RESET
condition|)
name|ath_tx_dump
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ATH_DEBUG */
if|if
condition|(
name|reset_type
operator|==
name|ATH_RESET_NOLOSS
condition|)
block|{
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 				 * Free the holding buffer; DMA is now 				 * stopped. 				 */
name|ath_txq_freeholdingbuf
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 				 * Setup the link pointer to be the 				 * _last_ buffer/descriptor in the list. 				 * If there's nothing in the list, set it 				 * to NULL. 				 */
name|bf_last
operator|=
name|ATH_TXQ_LAST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|,
name|axq_q_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf_last
operator|!=
name|NULL
condition|)
block|{
name|ath_hal_gettxdesclinkptr
argument_list|(
name|ah
argument_list|,
name|bf_last
operator|->
name|bf_lastds
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
operator|.
name|axq_link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
operator|.
name|axq_link
operator|=
name|NULL
expr_stmt|;
block|}
name|ATH_TXQ_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|ath_tx_draintxq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_RESET
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
operator|&&
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
block|{
name|ath_printtxbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
literal|0
argument_list|,
name|ath_hal_txprocdesc
argument_list|(
name|ah
argument_list|,
name|bf
operator|->
name|bf_lastds
argument_list|,
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_txstat
argument_list|)
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
name|ieee80211_dump_pkt
argument_list|(
operator|&
name|sc
operator|->
name|sc_ic
argument_list|,
name|mtod
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|,
specifier|const
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|bf
operator|->
name|bf_m
operator|->
name|m_len
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ATH_DEBUG */
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update internal state after a channel change.  */
end_comment

begin_function
specifier|static
name|void
name|ath_chan_change
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
comment|/* 	 * Change channels and update the h/w rate map 	 * if we're switching; e.g. 11a to 11b/g. 	 */
name|mode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|sc
operator|->
name|sc_curmode
condition|)
name|ath_setcurmode
argument_list|(
name|sc
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_curchan
operator|=
name|chan
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set/change channels.  If the channel is really being changed,  * it's done by resetting the chip.  To accomplish this we must  * first cleanup any pending DMA, then restart stuff after a la  * ath_init.  */
end_comment

begin_function
specifier|static
name|int
name|ath_chan_set
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* Treat this as an interface reset */
name|ATH_PCU_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* (Try to) stop TX/RX from occurring */
name|taskqueue_block
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Disable interrupts */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stop new RX/TX/interrupt completion */
if|if
condition|(
name|ath_reset_grablock
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: concurrent reset! Danger!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* Stop pending RX/TX completion */
name|ath_txrx_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: %u (%u MHz, flags 0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
name|sc
operator|->
name|sc_curchan
condition|)
block|{
name|HAL_STATUS
name|status
decl_stmt|;
comment|/* 		 * To switch channels clear any pending DMA operations; 		 * wait long enough for the RX fifo to drain, reset the 		 * hardware at the new frequency, and then re-enable 		 * the relevant bits of the h/w. 		 */
if|#
directive|if
literal|0
block|ath_hal_intrset(ah, 0);
comment|/* disable interrupts */
endif|#
directive|endif
name|ath_stoprecv
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* turn off frame recv */
comment|/* 		 * First, handle completed TX/RX frames. 		 */
name|ath_rx_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_draintxq
argument_list|(
name|sc
argument_list|,
name|ATH_RESET_NOLOSS
argument_list|)
expr_stmt|;
comment|/* 		 * Next, flush the non-scheduled frames. 		 */
name|ath_draintxq
argument_list|(
name|sc
argument_list|,
name|ATH_RESET_FULL
argument_list|)
expr_stmt|;
comment|/* clear pending tx frames */
name|ath_update_chainmasks
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|ath_hal_setchainmasks
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_cur_txchainmask
argument_list|,
name|sc
operator|->
name|sc_cur_rxchainmask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_reset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_opmode
argument_list|,
name|chan
argument_list|,
name|AH_TRUE
argument_list|,
name|HAL_RESET_NORMAL
argument_list|,
operator|&
name|status
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: unable to reset "
literal|"channel %u (%u MHz, flags 0x%x), hal status %u\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EIO
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
name|sc
operator|->
name|sc_diversity
operator|=
name|ath_hal_getdiversity
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ATH_RX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rx_stopped
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_rx_resetted
operator|=
literal|1
expr_stmt|;
name|ATH_RX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Quiet time handling - ensure we resync */
name|ath_vap_clear_quiet_ie
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Let DFS at it in case it's a DFS channel */
name|ath_dfs_radar_enable
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* Let spectral at in case spectral is enabled */
name|ath_spectral_enable
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* 		 * Let bluetooth coexistence at in case it's needed for this 		 * channel 		 */
name|ath_btcoex_enable
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* 		 * If we're doing TDMA, enforce the TXOP limitation for chips 		 * that support it. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_hasenforcetxop
operator|&&
name|sc
operator|->
name|sc_tdma
condition|)
name|ath_hal_setenforcetxop
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|ath_hal_setenforcetxop
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Re-enable rx framework. 		 */
if|if
condition|(
name|ath_startrecv
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: unable to restart recv logic\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EIO
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* 		 * Change channels and update the h/w rate map 		 * if we're switching; e.g. 11a to 11b/g. 		 */
name|ath_chan_change
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* 		 * Reset clears the beacon timers; reset them 		 * here if needed. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_beacons
condition|)
block|{
comment|/* restart beacons */
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|sc
operator|->
name|sc_tdma
condition|)
name|ath_tdma_config
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ath_beacon_config
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Re-enable interrupts. 		 */
if|#
directive|if
literal|0
block|ath_hal_intrset(ah, sc->sc_imask);
endif|#
directive|endif
block|}
name|finish
label|:
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_inreset_cnt
operator|--
expr_stmt|;
comment|/* XXX only do this if sc_inreset_cnt == 0? */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_txrx_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX ath_start? */
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Periodically recalibrate the PHY to account  * for temperature/environment changes.  */
end_comment

begin_function
specifier|static
name|void
name|ath_calibrate
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|HAL_BOOL
name|longCal
decl_stmt|,
name|isCalDone
init|=
name|AH_TRUE
decl_stmt|;
name|HAL_BOOL
name|aniCal
decl_stmt|,
name|shortCal
init|=
name|AH_FALSE
decl_stmt|;
name|int
name|nextcal
decl_stmt|;
name|ATH_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Force the hardware awake for ANI work. 	 */
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
comment|/* Skip trying to do this if we're in reset */
if|if
condition|(
name|sc
operator|->
name|sc_inreset_cnt
condition|)
goto|goto
name|restart
goto|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
condition|)
comment|/* defer, off channel */
goto|goto
name|restart
goto|;
name|longCal
operator|=
operator|(
name|ticks
operator|-
name|sc
operator|->
name|sc_lastlongcal
operator|>=
name|ath_longcalinterval
operator|*
name|hz
operator|)
expr_stmt|;
name|aniCal
operator|=
operator|(
name|ticks
operator|-
name|sc
operator|->
name|sc_lastani
operator|>=
name|ath_anicalinterval
operator|*
name|hz
operator|/
literal|1000
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_doresetcal
condition|)
name|shortCal
operator|=
operator|(
name|ticks
operator|-
name|sc
operator|->
name|sc_lastshortcal
operator|>=
name|ath_shortcalinterval
operator|*
name|hz
operator|/
literal|1000
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_CALIBRATE
argument_list|,
literal|"%s: shortCal=%d; longCal=%d; aniCal=%d\n"
argument_list|,
name|__func__
argument_list|,
name|shortCal
argument_list|,
name|longCal
argument_list|,
name|aniCal
argument_list|)
expr_stmt|;
if|if
condition|(
name|aniCal
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_ani_cal
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_lastani
operator|=
name|ticks
expr_stmt|;
name|ath_hal_ani_poll
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|longCal
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_per_cal
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_lastlongcal
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|ath_hal_getrfgain
argument_list|(
name|ah
argument_list|)
operator|==
name|HAL_RFGAIN_NEED_CHANGE
condition|)
block|{
comment|/* 			 * Rfgain is out of bounds, reset the chip 			 * to load new gain values. 			 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_CALIBRATE
argument_list|,
literal|"%s: rfgain change\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_per_rfgain
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_resetcal
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_doresetcal
operator|=
name|AH_TRUE
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_resettask
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|,
literal|1
argument_list|,
name|ath_calibrate
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * If this long cal is after an idle period, then 		 * reset the data collection state so we start fresh. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_resetcal
condition|)
block|{
operator|(
name|void
operator|)
name|ath_hal_calreset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_lastcalreset
operator|=
name|ticks
expr_stmt|;
name|sc
operator|->
name|sc_lastshortcal
operator|=
name|ticks
expr_stmt|;
name|sc
operator|->
name|sc_resetcal
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_doresetcal
operator|=
name|AH_TRUE
expr_stmt|;
block|}
block|}
comment|/* Only call if we're doing a short/long cal, not for ANI calibration */
if|if
condition|(
name|shortCal
operator|||
name|longCal
condition|)
block|{
name|isCalDone
operator|=
name|AH_FALSE
expr_stmt|;
if|if
condition|(
name|ath_hal_calibrateN
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|,
name|longCal
argument_list|,
operator|&
name|isCalDone
argument_list|)
condition|)
block|{
if|if
condition|(
name|longCal
condition|)
block|{
comment|/* 				 * Calibrate noise floor data again in case of change. 				 */
name|ath_hal_process_noisefloor
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: calibration of channel %u failed\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_curchan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_per_calfail
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|shortCal
condition|)
name|sc
operator|->
name|sc_lastshortcal
operator|=
name|ticks
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isCalDone
condition|)
block|{
name|restart
label|:
comment|/* 		 * Use a shorter interval to potentially collect multiple 		 * data samples required to complete calibration.  Once 		 * we're told the work is done we drop back to a longer 		 * interval between requests.  We're more aggressive doing 		 * work when operating as an AP to improve operation right 		 * after startup. 		 */
name|sc
operator|->
name|sc_lastshortcal
operator|=
name|ticks
expr_stmt|;
name|nextcal
operator|=
name|ath_shortcalinterval
operator|*
name|hz
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_opmode
operator|!=
name|HAL_M_HOSTAP
condition|)
name|nextcal
operator|*=
literal|10
expr_stmt|;
name|sc
operator|->
name|sc_doresetcal
operator|=
name|AH_TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* nextcal should be the shortest time for next event */
name|nextcal
operator|=
name|ath_longcalinterval
operator|*
name|hz
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_lastcalreset
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_lastcalreset
operator|=
name|sc
operator|->
name|sc_lastlongcal
expr_stmt|;
elseif|else
if|if
condition|(
name|ticks
operator|-
name|sc
operator|->
name|sc_lastcalreset
operator|>=
name|ath_resetcalinterval
operator|*
name|hz
condition|)
name|sc
operator|->
name|sc_resetcal
operator|=
literal|1
expr_stmt|;
comment|/* setup reset next trip */
name|sc
operator|->
name|sc_doresetcal
operator|=
name|AH_FALSE
expr_stmt|;
block|}
comment|/* ANI calibration may occur more often than short/long/resetcal */
if|if
condition|(
name|ath_anicalinterval
operator|>
literal|0
condition|)
name|nextcal
operator|=
name|MIN
argument_list|(
name|nextcal
argument_list|,
name|ath_anicalinterval
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextcal
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_CALIBRATE
argument_list|,
literal|"%s: next +%u (%sisCalDone)\n"
argument_list|,
name|__func__
argument_list|,
name|nextcal
argument_list|,
name|isCalDone
condition|?
literal|""
else|:
literal|"!"
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|,
name|nextcal
argument_list|,
name|ath_calibrate
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_CALIBRATE
argument_list|,
literal|"%s: calibration disabled\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* NB: don't rearm timer */
block|}
comment|/* 	 * Restore power state now that we're done. 	 */
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
comment|/* XXX calibration timer? */
comment|/* XXXGL: is constant ieee80211broadcastaddr a correct choice? */
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_scanning
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|0
expr_stmt|;
name|rfilt
operator|=
name|ath_calcrxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
name|ath_hal_setassocid
argument_list|(
name|ah
argument_list|,
name|ieee80211broadcastaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"%s: RX filter 0x%x bssid %s aid 0\n"
argument_list|,
name|__func__
argument_list|,
name|rfilt
argument_list|,
name|ether_sprintf
argument_list|(
name|ieee80211broadcastaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_scanning
operator|=
literal|0
expr_stmt|;
name|rfilt
operator|=
name|ath_calcrxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
name|ath_hal_setassocid
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_curbssid
argument_list|,
name|sc
operator|->
name|sc_curaid
argument_list|)
expr_stmt|;
name|ath_hal_process_noisefloor
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"%s: RX filter 0x%x bssid %s aid 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|rfilt
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|sc_curbssid
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_curaid
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_ENABLE_11N
end_ifdef

begin_comment
comment|/*  * For now, just do a channel change.  *  * Later, we'll go through the hard slog of suspending tx/rx, changing rate  * control state and resetting the hardware without dropping frames out  * of the queue.  *  * The unfortunate trouble here is making absolutely sure that the  * channel width change has propagated enough so the hardware  * absolutely isn't handed bogus frames for it's current operating  * mode. (Eg, 40MHz frames in 20MHz mode.) Since TX and RX can and  * does occur in parallel, we need to make certain we've blocked  * any further ongoing TX (and RX, that can cause raw TX)  * before we do this.  */
end_comment

begin_function
specifier|static
name|void
name|ath_update_chw
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
comment|//DPRINTF(sc, ATH_DEBUG_STATE, "%s: called\n", __func__);
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * XXX TODO: schedule a tasklet that stops things without freeing, 	 * walks the now stopped TX queue(s) looking for frames to retry 	 * as if we TX filtered them (whch may mean dropping non-ampdu frames!) 	 * but okay) then place them back on the software queue so they 	 * can have the rate control lookup done again. 	 */
name|ath_set_channel
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATH_ENABLE_11N */
end_comment

begin_comment
comment|/*  * This is called by the beacon parsing routine in the receive  * path to update the current quiet time information provided by  * an AP.  *  * This is STA specific, it doesn't take the AP TBTT/beacon slot  * offset into account.  *  * The quiet IE doesn't control the /now/ beacon interval - it  * controls the upcoming beacon interval.  So, when tbtt=1,  * the quiet element programming shall be for the next beacon  * interval.  There's no tbtt=0 behaviour defined, so don't.  *  * Since we're programming the next quiet interval, we have  * to keep in mind what we will see when the next beacon  * is received with potentially a quiet IE.  For example, if  * quiet_period is 1, then we are always getting a quiet interval  * each TBTT - so if we just program it in upon each beacon received,  * it will constantly reflect the "next" TBTT and we will never  * let the counter stay programmed correctly.  *  * So:  * + the first time we see the quiet IE, program it and store  *   the details somewhere;  * + if the quiet parameters don't change (ie, period/duration/offset)  *   then just leave the programming enabled;  * + (we can "skip" beacons, so don't try to enforce tbttcount unless  *   you're willing to also do the skipped beacon math);  * + if the quiet IE is removed, then halt quiet time.  */
end_comment

begin_function
specifier|static
name|int
name|ath_set_quiet_ie
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
name|struct
name|ieee80211_quiet_ie
modifier|*
name|q
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_STA
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Verify we have a quiet time IE */
if|if
condition|(
name|ie
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_QUIETIE
argument_list|,
literal|"%s: called; NULL IE, disabling\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ath_hal_set_quiet
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|HAL_QUIET_DISABLE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|avp
operator|->
name|quiet_ie
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|avp
operator|->
name|quiet_ie
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* If we do, verify it's actually legit */
if|if
condition|(
name|ie
index|[
literal|0
index|]
operator|!=
name|IEEE80211_ELEMID_QUIET
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ie
index|[
literal|1
index|]
operator|!=
literal|6
condition|)
return|return
literal|0
return|;
comment|/* Note: this belongs in net80211, parsed out and everything */
name|q
operator|=
operator|(
name|void
operator|*
operator|)
name|ie
expr_stmt|;
comment|/* 	 * Compare what we have stored to what we last saw. 	 * If they're the same then don't program in anything. 	 */
if|if
condition|(
operator|(
name|q
operator|->
name|period
operator|==
name|avp
operator|->
name|quiet_ie
operator|.
name|period
operator|)
operator|&&
operator|(
name|le16dec
argument_list|(
operator|&
name|q
operator|->
name|duration
argument_list|)
operator|==
name|le16dec
argument_list|(
operator|&
name|avp
operator|->
name|quiet_ie
operator|.
name|duration
argument_list|)
operator|)
operator|&&
operator|(
name|le16dec
argument_list|(
operator|&
name|q
operator|->
name|offset
argument_list|)
operator|==
name|le16dec
argument_list|(
operator|&
name|avp
operator|->
name|quiet_ie
operator|.
name|offset
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_QUIETIE
argument_list|,
literal|"%s: called; tbttcount=%d, period=%d, duration=%d, offset=%d\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|q
operator|->
name|tbttcount
argument_list|,
operator|(
name|int
operator|)
name|q
operator|->
name|period
argument_list|,
operator|(
name|int
operator|)
name|le16dec
argument_list|(
operator|&
name|q
operator|->
name|duration
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|le16dec
argument_list|(
operator|&
name|q
operator|->
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Don't program in garbage values. 	 */
if|if
condition|(
operator|(
name|le16dec
argument_list|(
operator|&
name|q
operator|->
name|duration
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|le16dec
argument_list|(
operator|&
name|q
operator|->
name|duration
argument_list|)
operator|>=
name|ni
operator|->
name|ni_intval
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_QUIETIE
argument_list|,
literal|"%s: invalid duration (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|le16dec
argument_list|(
operator|&
name|q
operator|->
name|duration
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Can have a 0 offset, but not a duration - so just check 	 * they don't exceed the intval. 	 */
if|if
condition|(
name|le16dec
argument_list|(
operator|&
name|q
operator|->
name|duration
argument_list|)
operator|+
name|le16dec
argument_list|(
operator|&
name|q
operator|->
name|offset
argument_list|)
operator|>=
name|ni
operator|->
name|ni_intval
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_QUIETIE
argument_list|,
literal|"%s: invalid duration + offset (%d+%d)\n"
argument_list|,
name|__func__
argument_list|,
name|le16dec
argument_list|(
operator|&
name|q
operator|->
name|duration
argument_list|)
argument_list|,
name|le16dec
argument_list|(
operator|&
name|q
operator|->
name|offset
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|q
operator|->
name|tbttcount
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_QUIETIE
argument_list|,
literal|"%s: invalid tbttcount (0)\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|q
operator|->
name|period
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_QUIETIE
argument_list|,
literal|"%s: invalid period (0)\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * This is a new quiet time IE config, so wait until tbttcount 	 * is equal to 1, and program it in. 	 */
if|if
condition|(
name|q
operator|->
name|tbttcount
operator|==
literal|1
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_QUIETIE
argument_list|,
literal|"%s: programming\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ath_hal_set_quiet
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|q
operator|->
name|period
operator|*
name|ni
operator|->
name|ni_intval
argument_list|,
comment|/* convert to TU */
name|le16dec
argument_list|(
operator|&
name|q
operator|->
name|duration
argument_list|)
argument_list|,
comment|/* already in TU */
name|le16dec
argument_list|(
operator|&
name|q
operator|->
name|offset
argument_list|)
operator|+
name|ni
operator|->
name|ni_intval
argument_list|,
name|HAL_QUIET_ENABLE
operator||
name|HAL_QUIET_ADD_CURRENT_TSF
argument_list|)
expr_stmt|;
comment|/* 		 * Note: no HAL_QUIET_ADD_SWBA_RESP_TIME; as this is for 		 * STA mode 		 */
comment|/* Update local state */
name|memcpy
argument_list|(
operator|&
name|avp
operator|->
name|quiet_ie
argument_list|,
name|ie
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_quiet_ie
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_chan_set
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* 	 * If we are returning to our bss channel then mark state 	 * so the next recv'd beacon's tsf will be used to sync the 	 * beacon timers.  Note that since we only hear beacons in 	 * sta/ibss mode this has no effect in other operating modes. 	 */
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_scanning
operator|&&
name|ic
operator|->
name|ic_curchan
operator|==
name|ic
operator|->
name|ic_bsschan
condition|)
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|1
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Walk the vap list and check if there any vap's in RUN state.  */
end_comment

begin_function
specifier|static
name|int
name|ath_isanyrunningvaps
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|this
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|this
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
if|if
condition|(
name|vap
operator|!=
name|this
operator|&&
name|vap
operator|->
name|iv_state
operator|>=
name|IEEE80211_S_RUN
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|stamode
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
name|int
name|csa_run_transition
init|=
literal|0
decl_stmt|;
name|enum
name|ieee80211_state
name|ostate
init|=
name|vap
operator|->
name|iv_state
decl_stmt|;
specifier|static
specifier|const
name|HAL_LED_STATE
name|leds
index|[]
init|=
block|{
name|HAL_LED_INIT
block|,
comment|/* IEEE80211_S_INIT */
name|HAL_LED_SCAN
block|,
comment|/* IEEE80211_S_SCAN */
name|HAL_LED_AUTH
block|,
comment|/* IEEE80211_S_AUTH */
name|HAL_LED_ASSOC
block|,
comment|/* IEEE80211_S_ASSOC */
name|HAL_LED_RUN
block|,
comment|/* IEEE80211_S_CAC */
name|HAL_LED_RUN
block|,
comment|/* IEEE80211_S_RUN */
name|HAL_LED_RUN
block|,
comment|/* IEEE80211_S_CSA */
name|HAL_LED_RUN
block|,
comment|/* IEEE80211_S_SLEEP */
block|}
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"%s: %s -> %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ostate
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * net80211 _should_ have the comlock asserted at this point. 	 * There are some comments around the calls to vap->iv_newstate 	 * which indicate that it (newstate) may end up dropping the 	 * lock.  This and the subsequent lock assert check after newstate 	 * are an attempt to catch these and figure out how/why. 	 */
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* Before we touch the hardware - wake it up */
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If the NIC is in anything other than SLEEP state, 	 * we need to ensure that self-generated frames are 	 * set for PWRMGT=0.  Otherwise we may end up with 	 * strange situations. 	 * 	 * XXX TODO: is this actually the case? :-) 	 */
if|if
condition|(
name|nstate
operator|!=
name|IEEE80211_S_SLEEP
condition|)
name|ath_power_setselfgen
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
comment|/* 	 * Now, wake the thing up. 	 */
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
comment|/* 	 * And stop the calibration callout whilst we have 	 * ATH_LOCK held. 	 */
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ostate
operator|==
name|IEEE80211_S_CSA
operator|&&
name|nstate
operator|==
name|IEEE80211_S_RUN
condition|)
name|csa_run_transition
operator|=
literal|1
expr_stmt|;
name|ath_hal_setledstate
argument_list|(
name|ah
argument_list|,
name|leds
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
comment|/* set LED */
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_SCAN
condition|)
block|{
comment|/* 		 * Scanning: turn off beacon miss and don't beacon. 		 * Mark beacon state so when we reach RUN state we'll 		 * [re]setup beacons.  Unblock the task q thread so 		 * deferred interrupt processing is done. 		 */
comment|/* Ensure we stay awake during scan */
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_setselfgen
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ath_power_setpower
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
operator|&
operator|~
operator|(
name|HAL_INT_SWBA
operator||
name|HAL_INT_BMISS
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_imask
operator|&=
operator|~
operator|(
name|HAL_INT_SWBA
operator||
name|HAL_INT_BMISS
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_beacons
operator|=
literal|0
expr_stmt|;
name|taskqueue_unblock
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
block|}
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
name|rfilt
operator|=
name|ath_calcrxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|stamode
operator|=
operator|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_AHDEMO
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
operator|)
expr_stmt|;
comment|/* 	 * XXX Dont need to do this (and others) if we've transitioned 	 * from SLEEP->RUN. 	 */
if|if
condition|(
name|stamode
operator|&&
name|nstate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
name|sc
operator|->
name|sc_curaid
operator|=
name|ni
operator|->
name|ni_associd
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|sc_curbssid
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|ath_hal_setassocid
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_curbssid
argument_list|,
name|sc
operator|->
name|sc_curaid
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"%s: RX filter 0x%x bssid %s aid 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|rfilt
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|sc_curbssid
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_curaid
argument_list|)
expr_stmt|;
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
comment|/* XXX is this to restore keycache on resume? */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_STA
operator|&&
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_PRIVACY
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_WEP_NKID
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ath_hal_keyisvalid
argument_list|(
name|ah
argument_list|,
name|i
argument_list|)
condition|)
name|ath_hal_keysetmac
argument_list|(
name|ah
argument_list|,
name|i
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Invoke the parent method to do net80211 work. 	 */
name|error
operator|=
name|avp
operator|->
name|av_newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * See above: ensure av_newstate() doesn't drop the lock 	 * on us. 	 */
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * XXX TODO: if nstate is _S_CAC, then we should disable 	 * ACK processing until CAC is completed. 	 */
comment|/* 	 * XXX TODO: if we're on a passive channel, then we should 	 * not allow any ACKs or self-generated frames until we hear 	 * a beacon.  Unfortunately there isn't a notification from 	 * net80211 so perhaps we could slot that particular check 	 * into the mgmt receive path and just ensure that we clear 	 * it on RX of beacons in passive mode (and only clear it 	 * once, obviously.) 	 */
comment|/* 	 * XXX TODO: net80211 should be tracking whether channels 	 * have heard beacons and are thus considered "OK" for 	 * transmitting - and then inform the driver about this 	 * state change.  That way if we hear an AP go quiet 	 * (and nothing else is beaconing on a channel) the 	 * channel can go back to being passive until another 	 * beacon is heard. 	 */
comment|/* 	 * XXX TODO: if nstate is _S_CAC, then we should disable 	 * ACK processing until CAC is completed. 	 */
comment|/* 	 * XXX TODO: if we're on a passive channel, then we should 	 * not allow any ACKs or self-generated frames until we hear 	 * a beacon.  Unfortunately there isn't a notification from 	 * net80211 so perhaps we could slot that particular check 	 * into the mgmt receive path and just ensure that we clear 	 * it on RX of beacons in passive mode (and only clear it 	 * once, obviously.) 	 */
comment|/* 	 * XXX TODO: net80211 should be tracking whether channels 	 * have heard beacons and are thus considered "OK" for 	 * transmitting - and then inform the driver about this 	 * state change.  That way if we hear an AP go quiet 	 * (and nothing else is beaconing on a channel) the 	 * channel can go back to being passive until another 	 * beacon is heard. 	 */
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* NB: collect bss node again, it may have changed */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"%s(RUN): iv_flags 0x%08x bintvl %d bssid %s "
literal|"capinfo 0x%04x chan %d\n"
argument_list|,
name|__func__
argument_list|,
name|vap
operator|->
name|iv_flags
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|)
argument_list|,
name|ni
operator|->
name|ni_capinfo
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vap
operator|->
name|iv_opmode
condition|)
block|{
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
case|case
name|IEEE80211_M_AHDEMO
case|:
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* fall thru... */
endif|#
directive|endif
case|case
name|IEEE80211_M_HOSTAP
case|:
case|case
name|IEEE80211_M_IBSS
case|:
case|case
name|IEEE80211_M_MBSS
case|:
comment|/* 			 * TODO: Enable ACK processing (ie, clear AR_DIAG_ACK_DIS.) 			 * For channels that are in CAC, we may have disabled 			 * this during CAC to ensure we don't ACK frames 			 * sent to us. 			 */
comment|/* 			 * Allocate and setup the beacon frame. 			 * 			 * Stop any previous beacon DMA.  This may be 			 * necessary, for example, when an ibss merge 			 * causes reconfiguration; there will be a state 			 * transition from RUN->RUN that means we may 			 * be called with beacon transmission active. 			 */
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
name|error
operator|=
name|ath_beacon_alloc
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* 			 * If joining an adhoc network defer beacon timer 			 * configuration to the next beacon frame so we 			 * have a current TSF to use.  Otherwise we're 			 * starting an ibss/bss so there's no need to delay; 			 * if this is the first vap moving to RUN state, then 			 * beacon state needs to be [re]configured. 			 */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
operator|&&
name|ni
operator|->
name|ni_tstamp
operator|.
name|tsf
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_beacons
condition|)
block|{
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
condition|)
name|ath_tdma_config
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ath_beacon_config
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_beacons
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_M_STA
case|:
comment|/* 			 * Defer beacon timer configuration to the next 			 * beacon frame so we have a current TSF to use 			 * (any TSF collected when scanning is likely old). 			 * However if it's due to a CSA -> RUN transition, 			 * force a beacon update so we pick up a lack of 			 * beacons from an AP in CAC and thus force a 			 * scan. 			 * 			 * And, there's also corner cases here where 			 * after a scan, the AP may have disappeared. 			 * In that case, we may not receive an actual 			 * beacon to update the beacon timer and thus we 			 * won't get notified of the missing beacons. 			 */
if|if
condition|(
name|ostate
operator|!=
name|IEEE80211_S_RUN
operator|&&
name|ostate
operator|!=
name|IEEE80211_S_SLEEP
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: STA; syncbeacon=1\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|1
expr_stmt|;
comment|/* Quiet time handling - ensure we resync */
name|memset
argument_list|(
operator|&
name|avp
operator|->
name|quiet_ie
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|avp
operator|->
name|quiet_ie
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|csa_run_transition
condition|)
name|ath_beacon_config
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
comment|/* 			 * PR: kern/175227 			 * 			 * Reconfigure beacons during reset; as otherwise 			 * we won't get the beacon timers reprogrammed 			 * after a reset and thus we won't pick up a 			 * beacon miss interrupt. 			 * 			 * Hopefully we'll see a beacon before the BMISS 			 * timer fires (too often), leading to a STA 			 * disassociation. 			 */
name|sc
operator|->
name|sc_beacons
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
comment|/* 			 * Monitor mode vaps have only INIT->RUN and RUN->RUN 			 * transitions so we must re-enable interrupts here to 			 * handle the case of a single monitor mode vap. 			 */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_WDS
case|:
break|break;
default|default:
break|break;
block|}
comment|/* 		 * Let the hal process statistics collected during a 		 * scan so it can provide calibrated noise floor data. 		 */
name|ath_hal_process_noisefloor
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 		 * Reset rssi stats; maybe not the best place... 		 */
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgbrssi
operator|=
name|ATH_RSSI_DUMMY_MARKER
expr_stmt|;
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgrssi
operator|=
name|ATH_RSSI_DUMMY_MARKER
expr_stmt|;
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgtxrssi
operator|=
name|ATH_RSSI_DUMMY_MARKER
expr_stmt|;
comment|/* 		 * Force awake for RUN mode. 		 */
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_setselfgen
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ath_power_setpower
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Finally, start any timers and the task q thread 		 * (in case we didn't go through SCAN state). 		 */
if|if
condition|(
name|ath_longcalinterval
operator|!=
literal|0
condition|)
block|{
comment|/* start periodic recalibration timer */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|,
literal|1
argument_list|,
name|ath_calibrate
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_CALIBRATE
argument_list|,
literal|"%s: calibration disabled\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|taskqueue_unblock
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_INIT
condition|)
block|{
comment|/* Quiet time handling - ensure we resync */
name|memset
argument_list|(
operator|&
name|avp
operator|->
name|quiet_ie
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|avp
operator|->
name|quiet_ie
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * If there are no vaps left in RUN state then 		 * shutdown host/driver operation: 		 * o disable interrupts 		 * o disable the task queue thread 		 * o mark beacon processing as stopped 		 */
if|if
condition|(
operator|!
name|ath_isanyrunningvaps
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_imask
operator|&=
operator|~
operator|(
name|HAL_INT_SWBA
operator||
name|HAL_INT_BMISS
operator|)
expr_stmt|;
comment|/* disable interrupts  */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
operator|&
operator|~
name|HAL_INT_GLOBAL
argument_list|)
expr_stmt|;
name|taskqueue_block
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_beacons
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
name|ath_hal_setcca
argument_list|(
name|ah
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_SLEEP
condition|)
block|{
comment|/* We're going to sleep, so transition appropriately */
comment|/* For now, only do this if we're a single STA vap */
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
operator|==
literal|1
operator|&&
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: syncbeacon=%d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_syncbeacon
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 			 * Always at least set the self-generated 			 * frame config to set PWRMGT=1. 			 */
name|ath_power_setselfgen
argument_list|(
name|sc
argument_list|,
name|HAL_PM_NETWORK_SLEEP
argument_list|)
expr_stmt|;
comment|/* 			 * If we're not syncing beacons, transition 			 * to NETWORK_SLEEP. 			 * 			 * We stay awake if syncbeacon> 0 in case 			 * we need to listen for some beacons otherwise 			 * our beacon timer config may be wrong. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_syncbeacon
operator|==
literal|0
condition|)
block|{
name|ath_power_setpower
argument_list|(
name|sc
argument_list|,
name|HAL_PM_NETWORK_SLEEP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_SCAN
condition|)
block|{
comment|/* Quiet time handling - ensure we resync */
name|memset
argument_list|(
operator|&
name|avp
operator|->
name|quiet_ie
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|avp
operator|->
name|quiet_ie
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bad
label|:
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* 	 * Restore the power state - either to what it was, or 	 * to network_sleep if it's alright. 	 */
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a key cache slot to the station so we can  * setup a mapping from key index to node. The key cache  * slot is needed for managing antenna state and for  * compression when stations do not use crypto.  We do  * it uniliaterally here; if crypto is employed this slot  * will be reassigned.  */
end_comment

begin_function
specifier|static
name|void
name|ath_setup_stationkey
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_softc
decl_stmt|;
name|ieee80211_keyix
name|keyix
decl_stmt|,
name|rxkeyix
decl_stmt|;
comment|/* XXX should take a locked ref to vap->iv_bss */
if|if
condition|(
operator|!
name|ath_key_alloc
argument_list|(
name|vap
argument_list|,
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|,
operator|&
name|keyix
argument_list|,
operator|&
name|rxkeyix
argument_list|)
condition|)
block|{
comment|/* 		 * Key cache is full; we'll fall back to doing 		 * the more expensive lookup in software.  Note 		 * this also means no h/w compression. 		 */
comment|/* XXX msg+statistic */
block|}
else|else
block|{
comment|/* XXX locking? */
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_keyix
operator|=
name|keyix
expr_stmt|;
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_rxkeyix
operator|=
name|rxkeyix
expr_stmt|;
comment|/* NB: must mark device key to get called back on delete */
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_flags
operator||=
name|IEEE80211_KEY_DEVKEY
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_macaddr
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
comment|/* NB: this will create a pass-thru key entry */
name|ath_keyset
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|,
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|,
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Setup driver-specific state for a newly associated node.  * Note that we're called also on a re-associate, the isnew  * param tells us if this is the first time or not.  */
end_comment

begin_function
specifier|static
name|void
name|ath_newassoc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|isnew
parameter_list|)
block|{
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_softc
decl_stmt|;
specifier|const
name|struct
name|ieee80211_txparam
modifier|*
name|tp
init|=
name|ni
operator|->
name|ni_txparms
decl_stmt|;
name|an
operator|->
name|an_mcastrix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|tp
operator|->
name|mcastrate
argument_list|)
expr_stmt|;
name|an
operator|->
name|an_mgmtrix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|tp
operator|->
name|mgmtrate
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE
argument_list|,
literal|"%s: %6D: reassoc; isnew=%d, is_powersave=%d\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|isnew
argument_list|,
name|an
operator|->
name|an_is_powersave
argument_list|)
expr_stmt|;
name|ATH_NODE_LOCK
argument_list|(
name|an
argument_list|)
expr_stmt|;
name|ath_rate_newassoc
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|isnew
argument_list|)
expr_stmt|;
name|ATH_NODE_UNLOCK
argument_list|(
name|an
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnew
operator|&&
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_PRIVACY
operator|)
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_hasclrkey
operator|&&
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_keyix
operator|==
name|IEEE80211_KEYIX_NONE
condition|)
name|ath_setup_stationkey
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* 	 * If we're reassociating, make sure that any paused queues 	 * get unpaused. 	 * 	 * Now, we may have frames in the hardware queue for this node. 	 * So if we are reassociating and there are frames in the queue, 	 * we need to go through the cleanup path to ensure that they're 	 * marked as non-aggregate. 	 */
if|if
condition|(
operator|!
name|isnew
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE
argument_list|,
literal|"%s: %6D: reassoc; is_powersave=%d\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|an
operator|->
name|an_is_powersave
argument_list|)
expr_stmt|;
comment|/* XXX for now, we can't hold the lock across assoc */
name|ath_tx_node_reassoc
argument_list|(
name|sc
argument_list|,
name|an
argument_list|)
expr_stmt|;
comment|/* XXX for now, we can't hold the lock across wakeup */
if|if
condition|(
name|an
operator|->
name|an_is_powersave
condition|)
name|ath_tx_node_wakeup
argument_list|(
name|sc
argument_list|,
name|an
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ath_setregdomain
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_regdomain
modifier|*
name|reg
parameter_list|,
name|int
name|nchans
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: rd %u cc %u location %c%s\n"
argument_list|,
name|__func__
argument_list|,
name|reg
operator|->
name|regdomain
argument_list|,
name|reg
operator|->
name|country
argument_list|,
name|reg
operator|->
name|location
argument_list|,
name|reg
operator|->
name|ecm
condition|?
literal|" ecm"
else|:
literal|""
argument_list|)
expr_stmt|;
name|status
operator|=
name|ath_hal_set_channels
argument_list|(
name|ah
argument_list|,
name|chans
argument_list|,
name|nchans
argument_list|,
name|reg
operator|->
name|country
argument_list|,
name|reg
operator|->
name|regdomain
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|HAL_OK
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: failed, status %u\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
comment|/* XXX */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_getradiocaps
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: use rd %u cc %d\n"
argument_list|,
name|__func__
argument_list|,
name|SKU_DEBUG
argument_list|,
name|CTRY_DEFAULT
argument_list|)
expr_stmt|;
comment|/* XXX check return */
operator|(
name|void
operator|)
name|ath_hal_getchannels
argument_list|(
name|ah
argument_list|,
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|HAL_MODE_ALL
argument_list|,
name|CTRY_DEFAULT
argument_list|,
name|SKU_DEBUG
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_getchannels
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
comment|/* 	 * Collect channel set based on EEPROM contents. 	 */
name|status
operator|=
name|ath_hal_init_channels
argument_list|(
name|ah
argument_list|,
name|ic
operator|->
name|ic_channels
argument_list|,
name|IEEE80211_CHAN_MAX
argument_list|,
operator|&
name|ic
operator|->
name|ic_nchans
argument_list|,
name|HAL_MODE_ALL
argument_list|,
name|CTRY_DEFAULT
argument_list|,
name|SKU_NONE
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|HAL_OK
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: unable to collect channel list from hal, status %d\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
operator|(
name|void
operator|)
name|ath_hal_getregdomain
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_eerd
argument_list|)
expr_stmt|;
name|ath_hal_getcountrycode
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_eecc
argument_list|)
expr_stmt|;
comment|/* NB: cannot fail */
comment|/* XXX map Atheros sku's to net80211 SKU's */
comment|/* XXX net80211 types too small */
name|ic
operator|->
name|ic_regdomain
operator|.
name|regdomain
operator|=
operator|(
name|uint16_t
operator|)
name|sc
operator|->
name|sc_eerd
expr_stmt|;
name|ic
operator|->
name|ic_regdomain
operator|.
name|country
operator|=
operator|(
name|uint16_t
operator|)
name|sc
operator|->
name|sc_eecc
expr_stmt|;
name|ic
operator|->
name|ic_regdomain
operator|.
name|isocc
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* XXX don't know */
name|ic
operator|->
name|ic_regdomain
operator|.
name|isocc
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|ic
operator|->
name|ic_regdomain
operator|.
name|ecm
operator|=
literal|1
expr_stmt|;
name|ic
operator|->
name|ic_regdomain
operator|.
name|location
operator|=
literal|'I'
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: eeprom rd %u cc %u (mapped rd %u cc %u) location %c%s\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_eerd
argument_list|,
name|sc
operator|->
name|sc_eecc
argument_list|,
name|ic
operator|->
name|ic_regdomain
operator|.
name|regdomain
argument_list|,
name|ic
operator|->
name|ic_regdomain
operator|.
name|country
argument_list|,
name|ic
operator|->
name|ic_regdomain
operator|.
name|location
argument_list|,
name|ic
operator|->
name|ic_regdomain
operator|.
name|ecm
condition|?
literal|" ecm"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_rate_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|mode
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|IEEE80211_MODE_11A
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11A
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_HALF
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11A_HALF_RATE
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_QUARTER
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11A_QUARTER_RATE
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_11B
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11B
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_11G
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11G
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_TURBO_A
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_108A
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_TURBO_G
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_108G
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_STURBO_A
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_TURBO
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_11NA
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11NA_HT20
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_11NG
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11NG_HT20
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: invalid mode %u\n"
argument_list|,
name|__func__
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sc
operator|->
name|sc_rates
index|[
name|mode
index|]
operator|=
name|rt
expr_stmt|;
return|return
operator|(
name|rt
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_setcurmode
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|ieee80211_phymode
name|mode
parameter_list|)
block|{
comment|/* NB: on/off times from the Atheros NDIS driver, w/ permission */
specifier|static
specifier|const
struct|struct
block|{
name|u_int
name|rate
decl_stmt|;
comment|/* tx/rx 802.11 rate */
name|u_int16_t
name|timeOn
decl_stmt|;
comment|/* LED on time (ms) */
name|u_int16_t
name|timeOff
decl_stmt|;
comment|/* LED off time (ms) */
block|}
name|blinkrates
index|[]
init|=
block|{
block|{
literal|108
block|,
literal|40
block|,
literal|10
block|}
block|,
block|{
literal|96
block|,
literal|44
block|,
literal|11
block|}
block|,
block|{
literal|72
block|,
literal|50
block|,
literal|13
block|}
block|,
block|{
literal|48
block|,
literal|57
block|,
literal|14
block|}
block|,
block|{
literal|36
block|,
literal|67
block|,
literal|16
block|}
block|,
block|{
literal|24
block|,
literal|80
block|,
literal|20
block|}
block|,
block|{
literal|22
block|,
literal|100
block|,
literal|25
block|}
block|,
block|{
literal|18
block|,
literal|133
block|,
literal|34
block|}
block|,
block|{
literal|12
block|,
literal|160
block|,
literal|40
block|}
block|,
block|{
literal|10
block|,
literal|200
block|,
literal|50
block|}
block|,
block|{
literal|6
block|,
literal|240
block|,
literal|58
block|}
block|,
block|{
literal|4
block|,
literal|267
block|,
literal|66
block|}
block|,
block|{
literal|2
block|,
literal|400
block|,
literal|100
block|}
block|,
block|{
literal|0
block|,
literal|500
block|,
literal|130
block|}
block|,
comment|/* XXX half/quarter rates */
block|}
struct|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|sc_rixmap
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rixmap
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_rates
index|[
name|mode
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no h/w rate set for phy mode %u"
operator|,
name|mode
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rt
operator|->
name|rateCount
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
name|ieeerate
init|=
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|dot11Rate
operator|&
name|IEEE80211_RATE_VAL
decl_stmt|;
if|if
condition|(
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|phy
operator|!=
name|IEEE80211_T_HT
condition|)
name|sc
operator|->
name|sc_rixmap
index|[
name|ieeerate
index|]
operator|=
name|i
expr_stmt|;
else|else
name|sc
operator|->
name|sc_rixmap
index|[
name|ieeerate
operator||
name|IEEE80211_RATE_MCS
index|]
operator|=
name|i
expr_stmt|;
block|}
name|memset
argument_list|(
name|sc
operator|->
name|sc_hwmap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hwmap
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|sc_hwmap
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|rt
operator|->
name|rateCount
condition|)
block|{
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ledon
operator|=
operator|(
literal|500
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ledoff
operator|=
operator|(
literal|130
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ieeerate
operator|=
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|dot11Rate
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|phy
operator|==
name|IEEE80211_T_HT
condition|)
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ieeerate
operator||=
name|IEEE80211_RATE_MCS
expr_stmt|;
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|txflags
operator|=
name|IEEE80211_RADIOTAP_F_DATAPAD
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|shortPreamble
operator|||
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|phy
operator|==
name|IEEE80211_T_OFDM
condition|)
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|txflags
operator||=
name|IEEE80211_RADIOTAP_F_SHORTPRE
expr_stmt|;
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|rxflags
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|txflags
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nitems
argument_list|(
name|blinkrates
argument_list|)
operator|-
literal|1
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|blinkrates
index|[
name|j
index|]
operator|.
name|rate
operator|==
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ieeerate
condition|)
break|break;
comment|/* NB: this uses the last entry if the rate isn't found */
comment|/* XXX beware of overlow */
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ledon
operator|=
operator|(
name|blinkrates
index|[
name|j
index|]
operator|.
name|timeOn
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ledoff
operator|=
operator|(
name|blinkrates
index|[
name|j
index|]
operator|.
name|timeOff
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
block|}
name|sc
operator|->
name|sc_currates
operator|=
name|rt
expr_stmt|;
name|sc
operator|->
name|sc_curmode
operator|=
name|mode
expr_stmt|;
comment|/* 	 * All protection frames are transmitted at 2Mb/s for 	 * 11g, otherwise at 1Mb/s. 	 */
if|if
condition|(
name|mode
operator|==
name|IEEE80211_MODE_11G
condition|)
name|sc
operator|->
name|sc_protrix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
literal|2
operator|*
literal|2
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|sc_protrix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
literal|2
operator|*
literal|1
argument_list|)
expr_stmt|;
comment|/* NB: caller is responsible for resetting rate control state */
block|}
end_function

begin_function
specifier|static
name|void
name|ath_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|int
name|do_reset
init|=
literal|0
decl_stmt|;
name|ATH_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_wd_timer
operator|!=
literal|0
operator|&&
operator|--
name|sc
operator|->
name|sc_wd_timer
operator|==
literal|0
condition|)
block|{
name|uint32_t
name|hangs
decl_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_hal_gethangstate
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0xffff
argument_list|,
operator|&
name|hangs
argument_list|)
operator|&&
name|hangs
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s hang detected (0x%x)\n"
argument_list|,
name|hangs
operator|&
literal|0xff
condition|?
literal|"bb"
else|:
literal|"mac"
argument_list|,
name|hangs
argument_list|)
expr_stmt|;
block|}
else|else
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
name|do_reset
operator|=
literal|1
expr_stmt|;
name|counter_u64_add
argument_list|(
name|ic
operator|->
name|ic_oerrors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_watchdog
operator|++
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We can't hold the lock across the ath_reset() call. 	 * 	 * And since this routine can't hold a lock and sleep, 	 * do the reset deferred. 	 */
if|if
condition|(
name|do_reset
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_resettask
argument_list|)
expr_stmt|;
block|}
name|callout_schedule
argument_list|(
operator|&
name|sc
operator|->
name|sc_wd_ch
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_parent
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|error
init|=
name|EDOOFUS
decl_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_nrunning
operator|>
literal|0
condition|)
block|{
comment|/* 		 * To avoid rescanning another access point, 		 * do not call ath_init() here.  Instead, 		 * only reflect promisc mode settings. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_running
condition|)
block|{
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ath_mode_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
block|{
comment|/* 			 * Beware of being called during attach/detach 			 * to reset promiscuous mode.  In that case we 			 * will still be marked UP but not RUNNING. 			 * However trying to re-init the interface 			 * is the wrong thing to do as we've already 			 * torn down much of our state.  There's 			 * probably a better way to deal with this. 			 */
name|error
operator|=
name|ath_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ath_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
name|ath_power_setpower
argument_list|(
name|sc
argument_list|,
name|HAL_PM_FULL_SLEEP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
if|if
condition|(
name|sc
operator|->
name|sc_tx99
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_tx99
operator|->
name|start
argument_list|(
name|sc
operator|->
name|sc_tx99
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Announce various information on device/driver attach.  */
end_comment

begin_function
specifier|static
name|void
name|ath_announce
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s mac %d.%d RF%s phy %d.%d\n"
argument_list|,
name|ath_hal_mac_name
argument_list|(
name|ah
argument_list|)
argument_list|,
name|ah
operator|->
name|ah_macVersion
argument_list|,
name|ah
operator|->
name|ah_macRev
argument_list|,
name|ath_hal_rf_name
argument_list|(
name|ah
argument_list|)
argument_list|,
name|ah
operator|->
name|ah_phyRev
operator|>>
literal|4
argument_list|,
name|ah
operator|->
name|ah_phyRev
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"2GHz radio: 0x%.4x; 5GHz radio: 0x%.4x\n"
argument_list|,
name|ah
operator|->
name|ah_analog2GhzRev
argument_list|,
name|ah
operator|->
name|ah_analog5GhzRev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|WME_AC_VO
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ath_txq
modifier|*
name|txq
init|=
name|sc
operator|->
name|sc_ac2q
index|[
name|i
index|]
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Use hw queue %u for %s traffic\n"
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|ieee80211_wme_acnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Use hw queue %u for CAB traffic\n"
argument_list|,
name|sc
operator|->
name|sc_cabq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Use hw queue %u for beacons\n"
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ath_rxbuf
operator|!=
name|ATH_RXBUF
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"using %u rx buffers\n"
argument_list|,
name|ath_rxbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_txbuf
operator|!=
name|ATH_TXBUF
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"using %u tx buffers\n"
argument_list|,
name|ath_txbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mcastkey
operator|&&
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"using multicast key search\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_dfs_tasklet
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ath_softc
operator|*
operator|)
name|p
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
comment|/* 	 * If previous processing has found a radar event, 	 * signal this to the net80211 layer to begin DFS 	 * processing. 	 */
if|if
condition|(
name|ath_dfs_process_radar_event
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
condition|)
block|{
comment|/* DFS event found, initiate channel change */
comment|/* 		 * XXX TODO: immediately disable ACK processing 		 * on the current channel.  This would be done 		 * by setting AR_DIAG_ACK_DIS (AR5212; may be 		 * different for others) until we are out of 		 * CAC. 		 */
comment|/* 		 * XXX doesn't currently tell us whether the event 		 * XXX was found in the primary or extension 		 * XXX channel! 		 */
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_dfs_notify_radar
argument_list|(
name|ic
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Enable/disable power save.  This must be called with  * no TX driver locks currently held, so it should only  * be called from the RX path (which doesn't hold any  * TX driver locks.)  */
end_comment

begin_function
specifier|static
name|void
name|ath_node_powersave
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ATH_SW_PSQ
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|)
decl_stmt|;
comment|/* XXX and no TXQ locks should be held here */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE_PWRSAVE
argument_list|,
literal|"%s: %6D: enable=%d\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
operator|!
operator|!
name|enable
argument_list|)
expr_stmt|;
comment|/* Suspend or resume software queue handling */
if|if
condition|(
name|enable
condition|)
name|ath_tx_node_sleep
argument_list|(
name|sc
argument_list|,
name|an
argument_list|)
expr_stmt|;
else|else
name|ath_tx_node_wakeup
argument_list|(
name|sc
argument_list|,
name|an
argument_list|)
expr_stmt|;
comment|/* Update net80211 state */
name|avp
operator|->
name|av_node_ps
argument_list|(
name|ni
argument_list|,
name|enable
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|)
decl_stmt|;
comment|/* Update net80211 state */
name|avp
operator|->
name|av_node_ps
argument_list|(
name|ni
argument_list|,
name|enable
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ATH_SW_PSQ */
block|}
end_function

begin_comment
comment|/*  * Notification from net80211 that the powersave queue state has  * changed.  *  * Since the software queue also may have some frames:  *  * + if the node software queue has frames and the TID state  *   is 0, we set the TIM;  * + if the node and the stack are both empty, we clear the TIM bit.  * + If the stack tries to set the bit, always set it.  * + If the stack tries to clear the bit, only clear it if the  *   software queue in question is also cleared.  *  * TODO: this is called during node teardown; so let's ensure this  * is all correctly handled and that the TIM bit is cleared.  * It may be that the node flush is called _AFTER_ the net80211  * stack clears the TIM.  *  * Here is the racy part.  Since it's possible>1 concurrent,  * overlapping TXes will appear complete with a TX completion in  * another thread, it's possible that the concurrent TIM calls will  * clash.  We can't hold the node lock here because setting the  * TIM grabs the net80211 comlock and this may cause a LOR.  * The solution is either to totally serialise _everything_ at  * this point (ie, all TX, completion and any reset/flush go into  * one taskqueue) or a new "ath TIM lock" needs to be created that  * just wraps the driver state change and this call to avp->av_set_tim().  *  * The same race exists in the net80211 power save queue handling  * as well.  Since multiple transmitting threads may queue frames  * into the driver, as well as ps-poll and the driver transmitting  * frames (and thus clearing the psq), it's quite possible that  * a packet entering the PSQ and a ps-poll being handled will  * race, causing the TIM to be cleared and not re-set.  */
end_comment

begin_function
specifier|static
name|int
name|ath_node_set_tim
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ATH_SW_PSQ
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|)
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|an
operator|->
name|an_stack_psq
operator|=
name|enable
expr_stmt|;
comment|/* 	 * This will get called for all operating modes, 	 * even if avp->av_set_tim is unset. 	 * It's currently set for hostap/ibss modes; but 	 * the same infrastructure is used for both STA 	 * and AP/IBSS node power save. 	 */
if|if
condition|(
name|avp
operator|->
name|av_set_tim
operator|==
name|NULL
condition|)
block|{
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If setting the bit, always set it here. 	 * If clearing the bit, only clear it if the 	 * software queue is also empty. 	 * 	 * If the node has left power save, just clear the TIM 	 * bit regardless of the state of the power save queue. 	 * 	 * XXX TODO: although atomics are used, it's quite possible 	 * that a race will occur between this and setting/clearing 	 * in another thread.  TX completion will occur always in 	 * one thread, however setting/clearing the TIM bit can come 	 * from a variety of different process contexts! 	 */
if|if
condition|(
name|enable
operator|&&
name|an
operator|->
name|an_tim_set
operator|==
literal|1
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE_PWRSAVE
argument_list|,
literal|"%s: %6D: enable=%d, tim_set=1, ignoring\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|enable
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE_PWRSAVE
argument_list|,
literal|"%s: %6D: enable=%d, enabling TIM\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|an
operator|->
name|an_tim_set
operator|=
literal|1
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|changed
operator|=
name|avp
operator|->
name|av_set_tim
argument_list|(
name|ni
argument_list|,
name|enable
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|an
operator|->
name|an_swq_depth
operator|==
literal|0
condition|)
block|{
comment|/* disable */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE_PWRSAVE
argument_list|,
literal|"%s: %6D: enable=%d, an_swq_depth == 0, disabling\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|an
operator|->
name|an_tim_set
operator|=
literal|0
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|changed
operator|=
name|avp
operator|->
name|av_set_tim
argument_list|(
name|ni
argument_list|,
name|enable
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|an
operator|->
name|an_is_powersave
condition|)
block|{
comment|/* 		 * disable regardless; the node isn't in powersave now 		 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE_PWRSAVE
argument_list|,
literal|"%s: %6D: enable=%d, an_pwrsave=0, disabling\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|an
operator|->
name|an_tim_set
operator|=
literal|0
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|changed
operator|=
name|avp
operator|->
name|av_set_tim
argument_list|(
name|ni
argument_list|,
name|enable
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * psq disable, node is currently in powersave, node 		 * software queue isn't empty, so don't clear the TIM bit 		 * for now. 		 */
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE_PWRSAVE
argument_list|,
literal|"%s: %6D: enable=%d, an_swq_depth> 0, ignoring\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|changed
operator|)
return|;
else|#
directive|else
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|)
decl_stmt|;
comment|/* 	 * Some operating modes don't set av_set_tim(), so don't 	 * update it here. 	 */
if|if
condition|(
name|avp
operator|->
name|av_set_tim
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|avp
operator|->
name|av_set_tim
argument_list|(
name|ni
argument_list|,
name|enable
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* ATH_SW_PSQ */
block|}
end_function

begin_comment
comment|/*  * Set or update the TIM from the software queue.  *  * Check the software queue depth before attempting to do lock  * anything; that avoids trying to obtain the lock.  Then,  * re-check afterwards to ensure nothing has changed in the  * meantime.  *  * set:   This is designed to be called from the TX path, after  *        a frame has been queued; to see if the swq> 0.  *  * clear: This is designed to be called from the buffer completion point  *        (right now it's ath_tx_default_comp()) where the state of  *        a software queue has changed.  *  * It makes sense to place it at buffer free / completion rather  * than after each software queue operation, as there's no real  * point in churning the TIM bit as the last frames in the software  * queue are transmitted.  If they fail and we retry them, we'd  * just be setting the TIM bit again anyway.  */
end_comment

begin_function
name|void
name|ath_tx_update_tim
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ATH_SW_PSQ
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
decl_stmt|;
comment|/* Don't do this for broadcast/etc frames */
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
return|return;
name|an
operator|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|avp
operator|=
name|ATH_VAP
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|)
expr_stmt|;
comment|/* 	 * And for operating modes without the TIM handler set, let's 	 * just skip those. 	 */
if|if
condition|(
name|avp
operator|->
name|av_set_tim
operator|==
name|NULL
condition|)
return|return;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
if|if
condition|(
name|an
operator|->
name|an_is_powersave
operator|&&
name|an
operator|->
name|an_tim_set
operator|==
literal|0
operator|&&
name|an
operator|->
name|an_swq_depth
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE_PWRSAVE
argument_list|,
literal|"%s: %6D: swq_depth>0, tim_set=0, set!\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|an
operator|->
name|an_tim_set
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|avp
operator|->
name|av_set_tim
argument_list|(
name|ni
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Don't bother grabbing the lock unless the queue is empty. 		 */
if|if
condition|(
name|an
operator|->
name|an_swq_depth
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|an
operator|->
name|an_is_powersave
operator|&&
name|an
operator|->
name|an_stack_psq
operator|==
literal|0
operator|&&
name|an
operator|->
name|an_tim_set
operator|==
literal|1
operator|&&
name|an
operator|->
name|an_swq_depth
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE_PWRSAVE
argument_list|,
literal|"%s: %6D: swq_depth=0, tim_set=1, psq_set=0,"
literal|" clear!\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|an
operator|->
name|an_tim_set
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|avp
operator|->
name|av_set_tim
argument_list|(
name|ni
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
return|return;
endif|#
directive|endif
comment|/* ATH_SW_PSQ */
block|}
end_function

begin_comment
comment|/*  * Received a ps-poll frame from net80211.  *  * Here we get a chance to serve out a software-queued frame ourselves  * before we punt it to net80211 to transmit us one itself - either  * because there's traffic in the net80211 psq, or a NULL frame to  * indicate there's nothing else.  */
end_comment

begin_function
specifier|static
name|void
name|ath_node_recv_pspoll
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ATH_SW_PSQ
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|tid
decl_stmt|;
comment|/* Just paranoia */
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Unassociated (temporary node) station. 	 */
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * We do have an active node, so let's begin looking into it. 	 */
name|an
operator|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|avp
operator|=
name|ATH_VAP
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|)
expr_stmt|;
comment|/* 	 * For now, we just call the original ps-poll method. 	 * Once we're ready to flip this on: 	 * 	 * + Set leak to 1, as no matter what we're going to have 	 *   to send a frame; 	 * + Check the software queue and if there's something in it, 	 *   schedule the highest TID thas has traffic from this node. 	 *   Then make sure we schedule the software scheduler to 	 *   run so it picks up said frame. 	 * 	 * That way whatever happens, we'll at least send _a_ frame 	 * to the given node. 	 * 	 * Again, yes, it's crappy QoS if the node has multiple 	 * TIDs worth of traffic - but let's get it working first 	 * before we optimise it. 	 * 	 * Also yes, there's definitely latency here - we're not 	 * direct dispatching to the hardware in this path (and 	 * we're likely being called from the packet receive path, 	 * so going back into TX may be a little hairy!) but again 	 * I'd like to get this working first before optimising 	 * turn-around time. 	 */
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Legacy - we're called and the node isn't asleep. 	 * Immediately punt. 	 */
if|if
condition|(
operator|!
name|an
operator|->
name|an_is_powersave
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE_PWRSAVE
argument_list|,
literal|"%s: %6D: not in powersave?\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|avp
operator|->
name|av_recv_pspoll
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * We're in powersave. 	 * 	 * Leak a frame. 	 */
name|an
operator|->
name|an_leak_count
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Now, if there's no frames in the node, just punt to 	 * recv_pspoll. 	 * 	 * Don't bother checking if the TIM bit is set, we really 	 * only care if there are any frames here! 	 */
if|if
condition|(
name|an
operator|->
name|an_swq_depth
operator|==
literal|0
condition|)
block|{
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE_PWRSAVE
argument_list|,
literal|"%s: %6D: SWQ empty; punting to net80211\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|avp
operator|->
name|av_recv_pspoll
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Ok, let's schedule the highest TID that has traffic 	 * and then schedule something. 	 */
for|for
control|(
name|tid
operator|=
name|IEEE80211_TID_SIZE
operator|-
literal|1
init|;
name|tid
operator|>=
literal|0
condition|;
name|tid
operator|--
control|)
block|{
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
comment|/* 		 * No frames? Skip. 		 */
if|if
condition|(
name|atid
operator|->
name|axq_depth
operator|==
literal|0
condition|)
continue|continue;
name|ath_tx_tid_sched
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
comment|/* 		 * XXX we could do a direct call to the TXQ 		 * scheduler code here to optimise latency 		 * at the expense of a REALLY deep callstack. 		 */
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_txqtask
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE_PWRSAVE
argument_list|,
literal|"%s: %6D: leaking frame to TID %d\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
return|return;
block|}
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * XXX nothing in the TIDs at this point? Eek. 	 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE_PWRSAVE
argument_list|,
literal|"%s: %6D: TIDs empty, but ath_node showed traffic?!\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|avp
operator|->
name|av_recv_pspoll
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|avp
operator|->
name|av_recv_pspoll
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ATH_SW_PSQ */
block|}
end_function

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ath_main
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ath_main
argument_list|,
name|wlan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 802.11 media layer */
end_comment

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ath_main
argument_list|,
name|ath_rate
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ath_main
argument_list|,
name|ath_dfs
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ath_main
argument_list|,
name|ath_hal
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IEEE80211_ALQ
argument_list|)
operator|||
name|defined
argument_list|(
name|AH_DEBUG_ALQ
argument_list|)
operator|||
name|defined
argument_list|(
name|ATH_DEBUG_ALQ
argument_list|)
end_if

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ath_main
argument_list|,
name|alq
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

