begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for the Atheros Wireless LAN controller.  *  * This software is derived from work of Atsushi Onoe; his contribution  * is greatly appreciated.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ath.h"
end_include

begin_comment
comment|/*  * This is needed for register operations which are performed  * by the driver - eg, calls to ath_hal_gettsf32().  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_comment
comment|/* for mp_ncpus */
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_superg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_tdma.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ath/if_athvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/ath_hal/ah_devid.h>
end_include

begin_comment
comment|/* XXX for softled */
end_comment

begin_include
include|#
directive|include
file|<dev/ath/ath_hal/ah_diagcodes.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_misc.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tx.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_keycache.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_athdfs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
end_ifdef

begin_include
include|#
directive|include
file|<dev/ath/ath_tx99/ath_tx99.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ATH_KTR_INTR
value|KTR_SPARE4
end_define

begin_define
define|#
directive|define
name|ATH_KTR_ERR
value|KTR_SPARE3
end_define

begin_comment
comment|/*  * ATH_BCBUF determines the number of vap's that can transmit  * beacons and also (currently) the number of vap's that can  * have unique mac addresses/bssid.  When staggering beacons  * 4 is probably a good max as otherwise the beacons become  * very closely spaced and there is limited time for cab q traffic  * to go out.  You can burst beacons instead but that is not good  * for stations in power save and at some point you really want  * another radio (and channel).  *  * The limit on the number of mac addresses is tied to our use of  * the U/L bit and tracking addresses in a byte; it would be  * worthwhile to allow more for applications like proxy sta.  */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
name|ATH_BCBUF
operator|<=
literal|8
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|ath_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_stop_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_reset_vap
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_watchdog
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_fatal_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_bmiss_vap
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_bmiss_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_key_update_begin
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_key_update_end
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_update_mcast
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_update_promisc
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_mode_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_setslottime
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_updateslot
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_beaconq_setup
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_beacon_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_beacon_update
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|int
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_beacon_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ath_buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_beacon_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ath_buf
modifier|*
name|ath_beacon_generate
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_bstuck_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_beacon_return
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ath_buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_beacon_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_beacon_config
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_descdma_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_descdma
modifier|*
parameter_list|,
name|ath_bufhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_desc_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_desc_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|ath_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_node_cleanup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_node_free
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_node_getsignal
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int8_t
modifier|*
parameter_list|,
name|int8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_rxbuf_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ath_buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_recv_mgmt
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|subtype
parameter_list|,
name|int
name|rssi
parameter_list|,
name|int
name|nf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_setdefantenna
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_rx_proc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_rx_tasklet
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_txq_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ath_txq
modifier|*
name|ath_txq_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|int
name|qtype
parameter_list|,
name|int
name|subtype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_tx_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_wme_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_cleanupq
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ath_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_proc_q0
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_proc_q0123
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_chan_set
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_draintxq
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|ATH_RESET_TYPE
name|reset_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_stoprecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_startrecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_chan_change
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_calibrate
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_setup_stationkey
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_newassoc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_setregdomain
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|struct
name|ieee80211_regdomain
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ieee80211_channel
type|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_getradiocaps
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
type|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_getchannels
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_led_event
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_rate_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|u_int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_setcurmode
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|enum
name|ieee80211_phymode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_announce
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_dfs_tasklet
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_function_decl
specifier|static
name|void
name|ath_tdma_settimers
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|nexttbtt
parameter_list|,
name|u_int32_t
name|bintval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tdma_bintvalsetup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ieee80211_tdma_state
modifier|*
name|tdma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tdma_config
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tdma_update
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_tdma_param
modifier|*
name|tdma
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tdma_beacon_send
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|TDMA_EP_MULTIPLIER
value|(1<<10)
end_define

begin_comment
comment|/* pow2 to optimize out * and / */
end_comment

begin_define
define|#
directive|define
name|TDMA_LPF_LEN
value|6
end_define

begin_define
define|#
directive|define
name|TDMA_DUMMY_MARKER
value|0x127
end_define

begin_define
define|#
directive|define
name|TDMA_EP_MUL
parameter_list|(
name|x
parameter_list|,
name|mul
parameter_list|)
value|((x) * (mul))
end_define

begin_define
define|#
directive|define
name|TDMA_IN
parameter_list|(
name|x
parameter_list|)
value|(TDMA_EP_MUL((x), TDMA_EP_MULTIPLIER))
end_define

begin_define
define|#
directive|define
name|TDMA_LPF
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|len
parameter_list|)
define|\
value|((x != TDMA_DUMMY_MARKER) ? (((x) * ((len)-1) + (y)) / (len)) : (y))
end_define

begin_define
define|#
directive|define
name|TDMA_SAMPLE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|do {					\ 	x = TDMA_LPF((x), TDMA_IN(y), TDMA_LPF_LEN);		\ } while (0)
end_define

begin_define
define|#
directive|define
name|TDMA_EP_RND
parameter_list|(
name|x
parameter_list|,
name|mul
parameter_list|)
define|\
value|((((x)%(mul))>= ((mul)/2)) ? ((x) + ((mul) - 1)) / (mul) : (x)/(mul))
end_define

begin_define
define|#
directive|define
name|TDMA_AVG
parameter_list|(
name|x
parameter_list|)
value|TDMA_EP_RND(x, TDMA_EP_MULTIPLIER)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IEEE80211_SUPPORT_TDMA */
end_comment

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_ath
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* XXX validate sysctl values */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ath_longcalinterval
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* long cals every 30 secs */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|longcal
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_longcalinterval
argument_list|,
literal|0
argument_list|,
literal|"long chip calibration interval (secs)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_shortcalinterval
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* short cals every 100 ms */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|shortcal
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_shortcalinterval
argument_list|,
literal|0
argument_list|,
literal|"short chip calibration interval (msecs)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_resetcalinterval
init|=
literal|20
operator|*
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reset cal state 20 mins */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|resetcal
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_resetcalinterval
argument_list|,
literal|0
argument_list|,
literal|"reset chip calibration results (secs)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_anicalinterval
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ANI calibration - 100 msec */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|anical
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_anicalinterval
argument_list|,
literal|0
argument_list|,
literal|"ANI calibration (msecs)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_rxbuf
init|=
name|ATH_RXBUF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # rx buffers to allocate */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|rxbuf
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_rxbuf
argument_list|,
literal|0
argument_list|,
literal|"rx buffers allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ath.rxbuf"
argument_list|,
operator|&
name|ath_rxbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_txbuf
init|=
name|ATH_TXBUF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # tx buffers to allocate */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|txbuf
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_txbuf
argument_list|,
literal|0
argument_list|,
literal|"tx buffers allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ath.txbuf"
argument_list|,
operator|&
name|ath_txbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_bstuck_threshold
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max missed beacons */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|bstuck
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_bstuck_threshold
argument_list|,
literal|0
argument_list|,
literal|"max missed beacon xmits before chip reset"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_ATHDEV
argument_list|,
literal|"athdev"
argument_list|,
literal|"ath driver dma buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|HAL_MODE_HT20
value|(HAL_MODE_11NG_HT20 | HAL_MODE_11NA_HT20)
end_define

begin_define
define|#
directive|define
name|HAL_MODE_HT40
define|\
value|(HAL_MODE_11NG_HT40PLUS | HAL_MODE_11NG_HT40MINUS | \ 	HAL_MODE_11NA_HT40PLUS | HAL_MODE_11NA_HT40MINUS)
end_define

begin_function
name|int
name|ath_attach
parameter_list|(
name|u_int16_t
name|devid
parameter_list|,
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|NULL
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|u_int
name|wmodes
decl_stmt|;
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: devid 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|devid
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_IEEE80211
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can not if_alloc()\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ic
operator|=
name|ifp
operator|->
name|if_l2com
expr_stmt|;
comment|/* set these up early for if_printf use */
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|ah
operator|=
name|ath_hal_attach
argument_list|(
name|devid
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_sh
argument_list|,
name|sc
operator|->
name|sc_eepromdata
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ah
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to attach hardware; HAL status %u\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|sc_ah
operator|=
name|ah
expr_stmt|;
name|sc
operator|->
name|sc_invalid
operator|=
literal|0
expr_stmt|;
comment|/* ready to go, enable interrupt handling */
ifdef|#
directive|ifdef
name|ATH_DEBUG
name|sc
operator|->
name|sc_debug
operator|=
name|ath_debug
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Check if the MAC has multi-rate retry support. 	 * We do this by trying to setup a fake extended 	 * descriptor.  MAC's that don't have support will 	 * return false w/o doing anything.  MAC's that do 	 * support it will return true w/o doing anything. 	 */
name|sc
operator|->
name|sc_mrretry
operator|=
name|ath_hal_setupxtxdesc
argument_list|(
name|ah
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Check if the device has hardware counters for PHY 	 * errors.  If so we need to enable the MIB interrupt 	 * so we can act on stat triggers. 	 */
if|if
condition|(
name|ath_hal_hwphycounters
argument_list|(
name|ah
argument_list|)
condition|)
name|sc
operator|->
name|sc_needmib
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Get the hardware key cache size. 	 */
name|sc
operator|->
name|sc_keymax
operator|=
name|ath_hal_keycachesize
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_keymax
operator|>
name|ATH_KEYMAX
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Warning, using only %u of %u key cache slots\n"
argument_list|,
name|ATH_KEYMAX
argument_list|,
name|sc
operator|->
name|sc_keymax
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_keymax
operator|=
name|ATH_KEYMAX
expr_stmt|;
block|}
comment|/* 	 * Reset the key cache since some parts do not 	 * reset the contents on initial power up. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_keymax
condition|;
name|i
operator|++
control|)
name|ath_hal_keyreset
argument_list|(
name|ah
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Collect the default channel list. 	 */
name|error
operator|=
name|ath_getchannels
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Setup rate tables for all potential media types. 	 */
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11A
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11B
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_TURBO_A
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_TURBO_G
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_STURBO_A
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11NA
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11NG
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_HALF
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_QUARTER
argument_list|)
expr_stmt|;
comment|/* NB: setup here so ath_rate_update is happy */
name|ath_setcurmode
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11A
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate tx+rx descriptors and populate the lists. 	 */
name|error
operator|=
name|ath_desc_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"failed to allocate descriptors: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_wd_ch
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ATH_TXBUF_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tq
operator|=
name|taskqueue_create
argument_list|(
literal|"ath_taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|sc_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxtask
argument_list|,
literal|0
argument_list|,
name|ath_rx_tasklet
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bmisstask
argument_list|,
literal|0
argument_list|,
name|ath_bmiss_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bstucktask
argument_list|,
literal|0
argument_list|,
name|ath_bstuck_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate hardware transmit queues: one queue for 	 * beacon frames and one data queue for each QoS 	 * priority.  Note that the hal handles resetting 	 * these queues at the needed time. 	 * 	 * XXX PS-Poll 	 */
name|sc
operator|->
name|sc_bhalq
operator|=
name|ath_beaconq_setup
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bhalq
operator|==
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to setup a beacon xmit queue!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|sc
operator|->
name|sc_cabq
operator|=
name|ath_txq_setup
argument_list|(
name|sc
argument_list|,
name|HAL_TX_QUEUE_CAB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cabq
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to setup CAB xmit queue!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
comment|/* NB: insure BK queue is the lowest priority h/w queue */
if|if
condition|(
operator|!
name|ath_tx_setup
argument_list|(
name|sc
argument_list|,
name|WME_AC_BK
argument_list|,
name|HAL_WME_AC_BK
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to setup xmit queue for %s traffic!\n"
argument_list|,
name|ieee80211_wme_acnames
index|[
name|WME_AC_BK
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
if|if
condition|(
operator|!
name|ath_tx_setup
argument_list|(
name|sc
argument_list|,
name|WME_AC_BE
argument_list|,
name|HAL_WME_AC_BE
argument_list|)
operator|||
operator|!
name|ath_tx_setup
argument_list|(
name|sc
argument_list|,
name|WME_AC_VI
argument_list|,
name|HAL_WME_AC_VI
argument_list|)
operator|||
operator|!
name|ath_tx_setup
argument_list|(
name|sc
argument_list|,
name|WME_AC_VO
argument_list|,
name|HAL_WME_AC_VO
argument_list|)
condition|)
block|{
comment|/* 		 * Not enough hardware tx queues to properly do WME; 		 * just punt and assign them all to the same h/w queue. 		 * We could do a better job of this if, for example, 		 * we allocate queues when we switch from station to 		 * AP mode. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_VI
index|]
operator|!=
name|NULL
condition|)
name|ath_tx_cleanupq
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_VI
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BE
index|]
operator|!=
name|NULL
condition|)
name|ath_tx_cleanupq
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BE
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BE
index|]
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BK
index|]
expr_stmt|;
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_VI
index|]
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BK
index|]
expr_stmt|;
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_VO
index|]
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BK
index|]
expr_stmt|;
block|}
comment|/* 	 * Special case certain configurations.  Note the 	 * CAB queue is handled by these specially so don't 	 * include them when checking the txq setup mask. 	 */
switch|switch
condition|(
name|sc
operator|->
name|sc_txqsetup
operator|&
operator|~
operator|(
literal|1
operator|<<
name|sc
operator|->
name|sc_cabq
operator|->
name|axq_qnum
operator|)
condition|)
block|{
case|case
literal|0x01
case|:
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txtask
argument_list|,
literal|0
argument_list|,
name|ath_tx_proc_q0
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0f
case|:
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txtask
argument_list|,
literal|0
argument_list|,
name|ath_tx_proc_q0123
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txtask
argument_list|,
literal|0
argument_list|,
name|ath_tx_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Setup rate control.  Some rate control modules 	 * call back to change the anntena state so expose 	 * the necessary entry points. 	 * XXX maybe belongs in struct ath_ratectrl? 	 */
name|sc
operator|->
name|sc_setdefantenna
operator|=
name|ath_setdefantenna
expr_stmt|;
name|sc
operator|->
name|sc_rc
operator|=
name|ath_rate_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rc
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
comment|/* Attach DFS module */
if|if
condition|(
operator|!
name|ath_dfs_attach
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: unable to attach DFS\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
comment|/* Start DFS processing tasklet */
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_dfstask
argument_list|,
literal|0
argument_list|,
name|ath_dfs_tasklet
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_blinking
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ledstate
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_ledon
operator|=
literal|0
expr_stmt|;
comment|/* low true */
name|sc
operator|->
name|sc_ledidle
operator|=
operator|(
literal|2700
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
comment|/* 2.7sec */
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_ledtimer
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
comment|/* 	 * Auto-enable soft led processing for IBM cards and for 	 * 5211 minipci cards.  Users can also manually enable/disable 	 * support with a sysctl. 	 */
name|sc
operator|->
name|sc_softled
operator|=
operator|(
name|devid
operator|==
name|AR5212_DEVID_IBM
operator|||
name|devid
operator|==
name|AR5211_DEVID
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
block|{
name|ath_hal_gpioCfgOutput
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
name|HAL_GPIO_MUX_MAC_NETWORK_LED
argument_list|)
expr_stmt|;
name|ath_hal_gpioset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
operator|!
name|sc
operator|->
name|sc_ledon
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_SIMPLEX
operator||
name|IFF_BROADCAST
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ath_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ath_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ath_init
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifqmaxlen
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|ifqmaxlen
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_ifp
operator|=
name|ifp
expr_stmt|;
comment|/* XXX not right but it's not used anywhere important */
name|ic
operator|->
name|ic_phytype
operator|=
name|IEEE80211_T_OFDM
expr_stmt|;
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_STA
expr_stmt|;
name|ic
operator|->
name|ic_caps
operator|=
name|IEEE80211_C_STA
comment|/* station mode */
operator||
name|IEEE80211_C_IBSS
comment|/* ibss, nee adhoc, mode */
operator||
name|IEEE80211_C_HOSTAP
comment|/* hostap mode */
operator||
name|IEEE80211_C_MONITOR
comment|/* monitor mode */
operator||
name|IEEE80211_C_AHDEMO
comment|/* adhoc demo mode */
operator||
name|IEEE80211_C_WDS
comment|/* 4-address traffic works */
operator||
name|IEEE80211_C_MBSS
comment|/* mesh point link mode */
operator||
name|IEEE80211_C_SHPREAMBLE
comment|/* short preamble supported */
operator||
name|IEEE80211_C_SHSLOT
comment|/* short slot time supported */
operator||
name|IEEE80211_C_WPA
comment|/* capable of WPA1+WPA2 */
operator||
name|IEEE80211_C_BGSCAN
comment|/* capable of bg scanning */
operator||
name|IEEE80211_C_TXFRAG
comment|/* handle tx frags */
ifdef|#
directive|ifdef
name|ATH_ENABLE_DFS
operator||
name|IEEE80211_C_DFS
comment|/* Enable DFS radar detection */
endif|#
directive|endif
expr_stmt|;
comment|/* 	 * Query the hal to figure out h/w crypto support. 	 */
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_WEP
argument_list|)
condition|)
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_WEP
expr_stmt|;
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_AES_OCB
argument_list|)
condition|)
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_AES_OCB
expr_stmt|;
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_AES_CCM
argument_list|)
condition|)
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_AES_CCM
expr_stmt|;
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_CKIP
argument_list|)
condition|)
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_CKIP
expr_stmt|;
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_TKIP
argument_list|)
condition|)
block|{
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_TKIP
expr_stmt|;
comment|/* 		 * Check if h/w does the MIC and/or whether the 		 * separate key cache entries are required to 		 * handle both tx+rx MIC keys. 		 */
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_MIC
argument_list|)
condition|)
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_TKIPMIC
expr_stmt|;
comment|/* 		 * If the h/w supports storing tx+rx MIC keys 		 * in one cache slot automatically enable use. 		 */
if|if
condition|(
name|ath_hal_hastkipsplit
argument_list|(
name|ah
argument_list|)
operator|||
operator|!
name|ath_hal_settkipsplit
argument_list|(
name|ah
argument_list|,
name|AH_FALSE
argument_list|)
condition|)
name|sc
operator|->
name|sc_splitmic
operator|=
literal|1
expr_stmt|;
comment|/* 		 * If the h/w can do TKIP MIC together with WME then 		 * we use it; otherwise we force the MIC to be done 		 * in software by the net80211 layer. 		 */
if|if
condition|(
name|ath_hal_haswmetkipmic
argument_list|(
name|ah
argument_list|)
condition|)
name|sc
operator|->
name|sc_wmetkipmic
operator|=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|sc_hasclrkey
operator|=
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_CLR
argument_list|)
expr_stmt|;
comment|/* 	 * Check for multicast key search support. 	 */
if|if
condition|(
name|ath_hal_hasmcastkeysearch
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
operator|&&
operator|!
name|ath_hal_getmcastkeysearch
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
condition|)
block|{
name|ath_hal_setmcastkeysearch
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_mcastkey
operator|=
name|ath_hal_getmcastkeysearch
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 	 * Mark key cache slots associated with global keys 	 * as in use.  If we knew TKIP was not to be used we 	 * could leave the +32, +64, and +32+64 slots free. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_WEP_NKID
condition|;
name|i
operator|++
control|)
block|{
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|i
operator|+
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_splitmic
condition|)
block|{
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|i
operator|+
literal|32
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|i
operator|+
literal|32
operator|+
literal|64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * TPC support can be done either with a global cap or 	 * per-packet support.  The latter is not available on 	 * all parts.  We're a bit pedantic here as all parts 	 * support a global cap. 	 */
if|if
condition|(
name|ath_hal_hastpc
argument_list|(
name|ah
argument_list|)
operator|||
name|ath_hal_hastxpowlimit
argument_list|(
name|ah
argument_list|)
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_TXPMGT
expr_stmt|;
comment|/* 	 * Mark WME capability only if we have sufficient 	 * hardware queues to do proper priority scheduling. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BE
index|]
operator|!=
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BK
index|]
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_WME
expr_stmt|;
comment|/* 	 * Check for misc other capabilities. 	 */
if|if
condition|(
name|ath_hal_hasbursting
argument_list|(
name|ah
argument_list|)
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_BURST
expr_stmt|;
name|sc
operator|->
name|sc_hasbmask
operator|=
name|ath_hal_hasbssidmask
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_hasbmatch
operator|=
name|ath_hal_hasbssidmatch
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_hastsfadd
operator|=
name|ath_hal_hastsfadjust
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxslink
operator|=
name|ath_hal_self_linked_final_rxdesc
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxtsf32
operator|=
name|ath_hal_has_long_rxdesc_tsf
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_hal_hasfastframes
argument_list|(
name|ah
argument_list|)
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_FF
expr_stmt|;
name|wmodes
operator|=
name|ath_hal_getwirelessmodes
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|wmodes
operator|&
operator|(
name|HAL_MODE_108G
operator||
name|HAL_MODE_TURBO
operator|)
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_TURBOP
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|ath_hal_macversion
argument_list|(
name|ah
argument_list|)
operator|>
literal|0x78
condition|)
block|{
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_TDMA
expr_stmt|;
comment|/* capable of TDMA */
name|ic
operator|->
name|ic_tdma_update
operator|=
name|ath_tdma_update
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * The if_ath 11n support is completely not ready for normal use. 	 * Enabling this option will likely break everything and everything. 	 * Don't think of doing that unless you know what you're doing. 	 */
ifdef|#
directive|ifdef
name|ATH_ENABLE_11N
comment|/* 	 * Query HT capabilities 	 */
if|if
condition|(
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_HT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|==
name|HAL_OK
operator|&&
operator|(
name|wmodes
operator|&
operator|(
name|HAL_MODE_HT20
operator||
name|HAL_MODE_HT40
operator|)
operator|)
condition|)
block|{
name|int
name|rxs
decl_stmt|,
name|txs
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"[HT] enabling HT modes\n"
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_htcaps
operator|=
name|IEEE80211_HTC_HT
comment|/* HT operation */
operator||
name|IEEE80211_HTC_AMPDU
comment|/* A-MPDU tx/rx */
operator||
name|IEEE80211_HTC_AMSDU
comment|/* A-MSDU tx/rx */
operator||
name|IEEE80211_HTCAP_MAXAMSDU_3839
comment|/* max A-MSDU length */
operator||
name|IEEE80211_HTCAP_SMPS_OFF
expr_stmt|;
comment|/* SM power save off */
empty_stmt|;
comment|/* 		 * Enable short-GI for HT20 only if the hardware 		 * advertises support. 		 * Notably, anything earlier than the AR9287 doesn't. 		 */
if|if
condition|(
operator|(
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_HT20_SGI
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|==
name|HAL_OK
operator|)
operator|&&
operator|(
name|wmodes
operator|&
name|HAL_MODE_HT20
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"[HT] enabling short-GI in 20MHz mode\n"
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_htcaps
operator||=
name|IEEE80211_HTCAP_SHORTGI20
expr_stmt|;
block|}
if|if
condition|(
name|wmodes
operator|&
name|HAL_MODE_HT40
condition|)
name|ic
operator|->
name|ic_htcaps
operator||=
name|IEEE80211_HTCAP_CHWIDTH40
operator||
name|IEEE80211_HTCAP_SHORTGI40
expr_stmt|;
comment|/* 		 * rx/tx stream is not currently used anywhere; it needs to be taken 		 * into account when negotiating which MCS rates it'll receive and 		 * what MCS rates are available for TX. 		 */
operator|(
name|void
operator|)
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_STREAMS
argument_list|,
literal|0
argument_list|,
operator|&
name|rxs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_STREAMS
argument_list|,
literal|1
argument_list|,
operator|&
name|txs
argument_list|)
expr_stmt|;
name|ath_hal_getrxchainmask
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxchainmask
argument_list|)
expr_stmt|;
name|ath_hal_gettxchainmask
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_txchainmask
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_txstream
operator|=
name|txs
expr_stmt|;
name|ic
operator|->
name|ic_rxstream
operator|=
name|rxs
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"[HT] %d RX streams; %d TX streams\n"
argument_list|,
name|rxs
argument_list|,
name|txs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Check if the hardware requires PCI register serialisation. 	 * Some of the Owl based MACs require this. 	 */
if|if
condition|(
name|mp_ncpus
operator|>
literal|1
operator|&&
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_SERIALISE_WAR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|==
name|HAL_OK
condition|)
block|{
name|sc
operator|->
name|sc_ah
operator|->
name|ah_config
operator|.
name|ah_serialise_reg_war
operator|=
literal|1
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Enabling register serialisation\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Indicate we need the 802.11 header padded to a 	 * 32-bit boundary for 4-address and QoS frames. 	 */
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_DATAPAD
expr_stmt|;
comment|/* 	 * Query the hal about antenna support. 	 */
name|sc
operator|->
name|sc_defant
operator|=
name|ath_hal_getdefantenna
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 	 * Not all chips have the VEOL support we want to 	 * use with IBSS beacons; check here for it. 	 */
name|sc
operator|->
name|sc_hasveol
operator|=
name|ath_hal_hasveol
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* get mac address from hardware */
name|ath_hal_getmac
argument_list|(
name|ah
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hasbmask
condition|)
name|ath_hal_getbssidmask
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_hwbssidmask
argument_list|)
expr_stmt|;
comment|/* NB: used to size node table key mapping array */
name|ic
operator|->
name|ic_max_keyix
operator|=
name|sc
operator|->
name|sc_keymax
expr_stmt|;
comment|/* call MI attach routine. */
name|ieee80211_ifattach
argument_list|(
name|ic
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_setregdomain
operator|=
name|ath_setregdomain
expr_stmt|;
name|ic
operator|->
name|ic_getradiocaps
operator|=
name|ath_getradiocaps
expr_stmt|;
name|sc
operator|->
name|sc_opmode
operator|=
name|HAL_M_STA
expr_stmt|;
comment|/* override default methods */
name|ic
operator|->
name|ic_newassoc
operator|=
name|ath_newassoc
expr_stmt|;
name|ic
operator|->
name|ic_updateslot
operator|=
name|ath_updateslot
expr_stmt|;
name|ic
operator|->
name|ic_wme
operator|.
name|wme_update
operator|=
name|ath_wme_update
expr_stmt|;
name|ic
operator|->
name|ic_vap_create
operator|=
name|ath_vap_create
expr_stmt|;
name|ic
operator|->
name|ic_vap_delete
operator|=
name|ath_vap_delete
expr_stmt|;
name|ic
operator|->
name|ic_raw_xmit
operator|=
name|ath_raw_xmit
expr_stmt|;
name|ic
operator|->
name|ic_update_mcast
operator|=
name|ath_update_mcast
expr_stmt|;
name|ic
operator|->
name|ic_update_promisc
operator|=
name|ath_update_promisc
expr_stmt|;
name|ic
operator|->
name|ic_node_alloc
operator|=
name|ath_node_alloc
expr_stmt|;
name|sc
operator|->
name|sc_node_free
operator|=
name|ic
operator|->
name|ic_node_free
expr_stmt|;
name|ic
operator|->
name|ic_node_free
operator|=
name|ath_node_free
expr_stmt|;
name|sc
operator|->
name|sc_node_cleanup
operator|=
name|ic
operator|->
name|ic_node_cleanup
expr_stmt|;
name|ic
operator|->
name|ic_node_cleanup
operator|=
name|ath_node_cleanup
expr_stmt|;
name|ic
operator|->
name|ic_node_getsignal
operator|=
name|ath_node_getsignal
expr_stmt|;
name|ic
operator|->
name|ic_scan_start
operator|=
name|ath_scan_start
expr_stmt|;
name|ic
operator|->
name|ic_scan_end
operator|=
name|ath_scan_end
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
operator|=
name|ath_set_channel
expr_stmt|;
comment|/* 802.11n specific - but just override anyway */
name|sc
operator|->
name|sc_addba_request
operator|=
name|ic
operator|->
name|ic_addba_request
expr_stmt|;
name|sc
operator|->
name|sc_addba_response
operator|=
name|ic
operator|->
name|ic_addba_response
expr_stmt|;
name|sc
operator|->
name|sc_addba_stop
operator|=
name|ic
operator|->
name|ic_addba_stop
expr_stmt|;
name|sc
operator|->
name|sc_bar_response
operator|=
name|ic
operator|->
name|ic_bar_response
expr_stmt|;
name|sc
operator|->
name|sc_addba_response_timeout
operator|=
name|ic
operator|->
name|ic_addba_response_timeout
expr_stmt|;
name|ic
operator|->
name|ic_addba_request
operator|=
name|ath_addba_request
expr_stmt|;
name|ic
operator|->
name|ic_addba_response
operator|=
name|ath_addba_response
expr_stmt|;
name|ic
operator|->
name|ic_addba_response_timeout
operator|=
name|ath_addba_response_timeout
expr_stmt|;
name|ic
operator|->
name|ic_addba_stop
operator|=
name|ath_addba_stop
expr_stmt|;
name|ic
operator|->
name|ic_bar_response
operator|=
name|ath_bar_response
expr_stmt|;
name|ieee80211_radiotap_attach
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_tx_th
argument_list|)
argument_list|,
name|ATH_TX_RADIOTAP_PRESENT
argument_list|,
operator|&
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rx_th
argument_list|)
argument_list|,
name|ATH_RX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
comment|/* 	 * Setup dynamic sysctl's now that country code and 	 * regdomain are available from the hal. 	 */
name|ath_sysctlattach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_sysctl_stats_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_sysctl_hal_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ieee80211_announce
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ath_announce
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad2
label|:
name|ath_tx_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_desc_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bad
label|:
if|if
condition|(
name|ah
condition|)
name|ath_hal_detach
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_invalid
operator|=
literal|1
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|ath_detach
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: if_flags %x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
comment|/* 	 * NB: the order of these is important: 	 * o stop the chip so no more interrupts will fire 	 * o call the 802.11 layer before detaching the hal to 	 *   insure callbacks into the driver to delete global 	 *   key cache entries can be handled 	 * o free the taskqueue which drains any pending tasks 	 * o reclaim the tx queue data structures after calling 	 *   the 802.11 layer as we'll get called back to reclaim 	 *   node state and potentially want to use them 	 * o to cleanup the tx queues the hal is called, so detach 	 *   it last 	 * Other than that, it's straightforward... 	 */
name|ath_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ieee80211_ifdetach
argument_list|(
name|ifp
operator|->
name|if_l2com
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
if|if
condition|(
name|sc
operator|->
name|sc_tx99
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_tx99
operator|->
name|detach
argument_list|(
name|sc
operator|->
name|sc_tx99
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ath_rate_detach
argument_list|(
name|sc
operator|->
name|sc_rc
argument_list|)
expr_stmt|;
name|ath_dfs_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_desc_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_tx_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_detach
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
comment|/* NB: sets chip in full sleep */
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * MAC address handling for multiple BSS on the same radio.  * The first vap uses the MAC address from the EEPROM.  For  * subsequent vap's we set the U/L bit (bit 1) in the MAC  * address and use the next six bits as an index.  */
end_comment

begin_function
specifier|static
name|void
name|assign_address
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|int
name|clone
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|clone
operator|&&
name|sc
operator|->
name|sc_hasbmask
condition|)
block|{
comment|/* NB: we only do this if h/w supports multiple bssid */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_bssidmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|mac
index|[
literal|0
index|]
operator||=
operator|(
name|i
operator|<<
literal|2
operator|)
operator||
literal|0x2
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_bssidmask
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
name|sc
operator|->
name|sc_hwbssidmask
index|[
literal|0
index|]
operator|&=
operator|~
name|mac
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_nbssid0
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reclaim_address
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|int
name|i
init|=
name|mac
index|[
literal|0
index|]
operator|>>
literal|2
decl_stmt|;
name|uint8_t
name|mask
decl_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|||
operator|--
name|sc
operator|->
name|sc_nbssid0
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_bssidmask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
comment|/* recalculate bssid mask from remaining addresses */
name|mask
operator|=
literal|0xff
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_bssidmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|mask
operator|&=
operator|~
operator|(
operator|(
name|i
operator|<<
literal|2
operator|)
operator||
literal|0x2
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_hwbssidmask
index|[
literal|0
index|]
operator||=
name|mask
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Assign a beacon xmit slot.  We try to space out  * assignments so when beacons are staggered the  * traffic coming out of the cab q has maximal time  * to go out before the next beacon is scheduled.  */
end_comment

begin_function
specifier|static
name|int
name|assign_bslot
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|slot
decl_stmt|,
name|free
decl_stmt|;
name|free
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|ATH_BCBUF
condition|;
name|slot
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_bslot
index|[
name|slot
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_bslot
index|[
operator|(
name|slot
operator|+
literal|1
operator|)
operator|%
name|ATH_BCBUF
index|]
operator|==
name|NULL
operator|&&
name|sc
operator|->
name|sc_bslot
index|[
operator|(
name|slot
operator|-
literal|1
operator|)
operator|%
name|ATH_BCBUF
index|]
operator|==
name|NULL
condition|)
return|return
name|slot
return|;
name|free
operator|=
name|slot
expr_stmt|;
comment|/* NB: keep looking for a double slot */
block|}
return|return
name|free
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|ath_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac0
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|int
name|ic_opmode
decl_stmt|,
name|needbeacon
decl_stmt|,
name|error
decl_stmt|;
name|avp
operator|=
operator|(
expr|struct
name|ath_vap
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ath_vap
argument_list|)
argument_list|,
name|M_80211_VAP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|needbeacon
operator|=
literal|0
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|mac
argument_list|,
name|mac0
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ic_opmode
operator|=
name|opmode
expr_stmt|;
comment|/* default to opmode of new vap */
switch|switch
condition|(
name|opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
if|if
condition|(
name|sc
operator|->
name|sc_nstavaps
operator|!=
literal|0
condition|)
block|{
comment|/* XXX only 1 for now */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"only 1 sta vap supported\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
condition|)
block|{
comment|/* 			 * With multiple vaps we must fall back 			 * to s/w beacon miss handling. 			 */
name|flags
operator||=
name|IEEE80211_CLONE_NOBEACONS
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CLONE_NOBEACONS
condition|)
block|{
comment|/* 			 * Station mode w/o beacons are implemented w/ AP mode. 			 */
name|ic_opmode
operator|=
name|IEEE80211_M_HOSTAP
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_M_IBSS
case|:
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
operator|!=
literal|0
condition|)
block|{
comment|/* XXX only 1 for now */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"only 1 ibss vap supported\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|needbeacon
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_AHDEMO
case|:
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CLONE_TDMA
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"only 1 tdma vap supported\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|needbeacon
operator|=
literal|1
expr_stmt|;
name|flags
operator||=
name|IEEE80211_CLONE_NOBEACONS
expr_stmt|;
block|}
comment|/* fall thru... */
endif|#
directive|endif
case|case
name|IEEE80211_M_MONITOR
case|:
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
operator|!=
literal|0
operator|&&
name|ic
operator|->
name|ic_opmode
operator|!=
name|opmode
condition|)
block|{
comment|/* 			 * Adopt existing mode.  Adding a monitor or ahdemo 			 * vap to an existing configuration is of dubious 			 * value but should be ok. 			 */
comment|/* XXX not right for monitor mode */
name|ic_opmode
operator|=
name|ic
operator|->
name|ic_opmode
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_M_HOSTAP
case|:
case|case
name|IEEE80211_M_MBSS
case|:
name|needbeacon
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_WDS
case|:
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
operator|!=
literal|0
operator|&&
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"wds not supported in sta mode\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * Silently remove any request for a unique 		 * bssid; WDS vap's always share the local 		 * mac address. 		 */
name|flags
operator|&=
operator|~
name|IEEE80211_CLONE_BSSID
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
operator|==
literal|0
condition|)
name|ic_opmode
operator|=
name|IEEE80211_M_HOSTAP
expr_stmt|;
else|else
name|ic_opmode
operator|=
name|ic
operator|->
name|ic_opmode
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unknown opmode %d\n"
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Check that a beacon buffer is available; the code below assumes it. 	 */
if|if
condition|(
name|needbeacon
operator|&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"no beacon buffer available\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* STA, AHDEMO? */
if|if
condition|(
name|opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
name|assign_address
argument_list|(
name|sc
argument_list|,
name|mac
argument_list|,
name|flags
operator|&
name|IEEE80211_CLONE_BSSID
argument_list|)
expr_stmt|;
name|ath_hal_setbssidmask
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_hwbssidmask
argument_list|)
expr_stmt|;
block|}
name|vap
operator|=
operator|&
name|avp
operator|->
name|av_vap
expr_stmt|;
comment|/* XXX can't hold mutex across if_alloc */
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|ieee80211_vap_setup
argument_list|(
name|ic
argument_list|,
name|vap
argument_list|,
name|name
argument_list|,
name|unit
argument_list|,
name|opmode
argument_list|,
name|flags
argument_list|,
name|bssid
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: error %d creating vap\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
comment|/* h/w crypto support */
name|vap
operator|->
name|iv_key_alloc
operator|=
name|ath_key_alloc
expr_stmt|;
name|vap
operator|->
name|iv_key_delete
operator|=
name|ath_key_delete
expr_stmt|;
name|vap
operator|->
name|iv_key_set
operator|=
name|ath_key_set
expr_stmt|;
name|vap
operator|->
name|iv_key_update_begin
operator|=
name|ath_key_update_begin
expr_stmt|;
name|vap
operator|->
name|iv_key_update_end
operator|=
name|ath_key_update_end
expr_stmt|;
comment|/* override various methods */
name|avp
operator|->
name|av_recv_mgmt
operator|=
name|vap
operator|->
name|iv_recv_mgmt
expr_stmt|;
name|vap
operator|->
name|iv_recv_mgmt
operator|=
name|ath_recv_mgmt
expr_stmt|;
name|vap
operator|->
name|iv_reset
operator|=
name|ath_reset_vap
expr_stmt|;
name|vap
operator|->
name|iv_update_beacon
operator|=
name|ath_beacon_update
expr_stmt|;
name|avp
operator|->
name|av_newstate
operator|=
name|vap
operator|->
name|iv_newstate
expr_stmt|;
name|vap
operator|->
name|iv_newstate
operator|=
name|ath_newstate
expr_stmt|;
name|avp
operator|->
name|av_bmiss
operator|=
name|vap
operator|->
name|iv_bmiss
expr_stmt|;
name|vap
operator|->
name|iv_bmiss
operator|=
name|ath_bmiss_vap
expr_stmt|;
comment|/* Set default parameters */
comment|/* 	 * Anything earlier than some AR9300 series MACs don't 	 * support a smaller MPDU density. 	 */
name|vap
operator|->
name|iv_ampdu_density
operator|=
name|IEEE80211_HTCAP_MPDUDENSITY_8
expr_stmt|;
comment|/* 	 * All NICs can handle the maximum size, however 	 * AR5416 based MACs can only TX aggregates w/ RTS 	 * protection when the total aggregate size is<= 8k. 	 * However, for now that's enforced by the TX path. 	 */
name|vap
operator|->
name|iv_ampdu_rxmax
operator|=
name|IEEE80211_HTCAP_MAXRXAMPDU_64K
expr_stmt|;
name|avp
operator|->
name|av_bslot
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|needbeacon
condition|)
block|{
comment|/* 		 * Allocate beacon state and setup the q for buffered 		 * multicast frames.  We know a beacon buffer is 		 * available because we checked above. 		 */
name|avp
operator|->
name|av_bcbuf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|,
name|avp
operator|->
name|av_bcbuf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|!=
name|IEEE80211_M_IBSS
operator|||
operator|!
name|sc
operator|->
name|sc_hasveol
condition|)
block|{
comment|/* 			 * Assign the vap to a beacon xmit slot.  As above 			 * this cannot fail to find a free one. 			 */
name|avp
operator|->
name|av_bslot
operator|=
name|assign_bslot
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_bslot
index|[
name|avp
operator|->
name|av_bslot
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"beacon slot %u not empty"
operator|,
name|avp
operator|->
name|av_bslot
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bslot
index|[
name|avp
operator|->
name|av_bslot
index|]
operator|=
name|vap
expr_stmt|;
name|sc
operator|->
name|sc_nbcnvaps
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_hastsfadd
operator|&&
name|sc
operator|->
name|sc_nbcnvaps
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Multple vaps are to transmit beacons and we 			 * have h/w support for TSF adjusting; enable 			 * use of staggered beacons. 			 */
name|sc
operator|->
name|sc_stagbeacons
operator|=
literal|1
expr_stmt|;
block|}
name|ath_txq_init
argument_list|(
name|sc
argument_list|,
operator|&
name|avp
operator|->
name|av_mcastq
argument_list|,
name|ATH_TXQ_SWQ
argument_list|)
expr_stmt|;
block|}
name|ic
operator|->
name|ic_opmode
operator|=
name|ic_opmode
expr_stmt|;
if|if
condition|(
name|opmode
operator|!=
name|IEEE80211_M_WDS
condition|)
block|{
name|sc
operator|->
name|sc_nvaps
operator|++
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|sc
operator|->
name|sc_nstavaps
operator|++
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
name|sc
operator|->
name|sc_nmeshvaps
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|ic_opmode
condition|)
block|{
case|case
name|IEEE80211_M_IBSS
case|:
name|sc
operator|->
name|sc_opmode
operator|=
name|HAL_M_IBSS
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_STA
case|:
name|sc
operator|->
name|sc_opmode
operator|=
name|HAL_M_STA
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_AHDEMO
case|:
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
condition|)
block|{
name|sc
operator|->
name|sc_tdma
operator|=
literal|1
expr_stmt|;
comment|/* NB: disable tsf adjust */
name|sc
operator|->
name|sc_stagbeacons
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * NB: adhoc demo mode is a pseudo mode; to the hal it's 		 * just ap mode. 		 */
comment|/* fall thru... */
endif|#
directive|endif
case|case
name|IEEE80211_M_HOSTAP
case|:
case|case
name|IEEE80211_M_MBSS
case|:
name|sc
operator|->
name|sc_opmode
operator|=
name|HAL_M_HOSTAP
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
name|sc
operator|->
name|sc_opmode
operator|=
name|HAL_M_MONITOR
expr_stmt|;
break|break;
default|default:
comment|/* XXX should not happen */
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_hastsfadd
condition|)
block|{
comment|/* 		 * Configure whether or not TSF adjust should be done. 		 */
name|ath_hal_settsfadjust
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_stagbeacons
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CLONE_NOBEACONS
condition|)
block|{
comment|/* 		 * Enable s/w beacon miss handling. 		 */
name|sc
operator|->
name|sc_swbmiss
operator|=
literal|1
expr_stmt|;
block|}
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* complete setup */
name|ieee80211_vap_attach
argument_list|(
name|vap
argument_list|,
name|ath_media_change
argument_list|,
name|ieee80211_media_status
argument_list|)
expr_stmt|;
return|return
name|vap
return|;
name|bad2
label|:
name|reclaim_address
argument_list|(
name|sc
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|ath_hal_setbssidmask
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_hwbssidmask
argument_list|)
expr_stmt|;
name|bad
label|:
name|free
argument_list|(
name|avp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* 		 * Quiesce the hardware while we remove the vap.  In 		 * particular we need to reclaim all references to 		 * the vap state by any frames pending on the tx queues. 		 */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|ath_draintxq
argument_list|(
name|sc
argument_list|,
name|ATH_RESET_DEFAULT
argument_list|)
expr_stmt|;
comment|/* stop hw xmit side */
comment|/* XXX Do all frames from all vaps/nodes need draining here? */
name|ath_stoprecv
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* stop recv side */
block|}
name|ieee80211_vap_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* 	 * XXX Danger Will Robinson! Danger! 	 * 	 * Because ieee80211_vap_detach() can queue a frame (the station 	 * diassociate message?) after we've drained the TXQ and 	 * flushed the software TXQ, we will end up with a frame queued 	 * to a node whose vap is about to be freed. 	 * 	 * To work around this, flush the hardware/software again. 	 * This may be racy - the ath task may be running and the packet 	 * may be being scheduled between sw->hw txq. Tsk. 	 * 	 * TODO: figure out why a new node gets allocated somewhere around 	 * here (after the ath_tx_swq() call; and after an ath_stop_locked() 	 * call!) 	 */
name|ath_draintxq
argument_list|(
name|sc
argument_list|,
name|ATH_RESET_DEFAULT
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Reclaim beacon state.  Note this must be done before 	 * the vap instance is reclaimed as we may have a reference 	 * to it in the buffer for the beacon frame. 	 */
if|if
condition|(
name|avp
operator|->
name|av_bcbuf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|avp
operator|->
name|av_bslot
operator|!=
operator|-
literal|1
condition|)
block|{
name|sc
operator|->
name|sc_bslot
index|[
name|avp
operator|->
name|av_bslot
index|]
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_nbcnvaps
operator|--
expr_stmt|;
block|}
name|ath_beacon_return
argument_list|(
name|sc
argument_list|,
name|avp
operator|->
name|av_bcbuf
argument_list|)
expr_stmt|;
name|avp
operator|->
name|av_bcbuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nbcnvaps
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stagbeacons
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hastsfadd
condition|)
name|ath_hal_settsfadjust
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Reclaim any pending mcast frames for the vap. 		 */
name|ath_tx_draintxq
argument_list|(
name|sc
argument_list|,
operator|&
name|avp
operator|->
name|av_mcastq
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK_DESTROY
argument_list|(
operator|&
name|avp
operator|->
name|av_mcastq
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update bookkeeping. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
name|sc
operator|->
name|sc_nstavaps
operator|--
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nstavaps
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_swbmiss
condition|)
name|sc
operator|->
name|sc_swbmiss
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
name|reclaim_address
argument_list|(
name|sc
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|ath_hal_setbssidmask
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_hwbssidmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
name|sc
operator|->
name|sc_nmeshvaps
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_WDS
condition|)
name|sc
operator|->
name|sc_nvaps
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
comment|/* TDMA operation ceases when the last vap is destroyed */
if|if
condition|(
name|sc
operator|->
name|sc_tdma
operator|&&
name|sc
operator|->
name|sc_nvaps
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_tdma
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_swbmiss
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|free
argument_list|(
name|avp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* 		 * Restart rx+tx machines if still running (RUNNING will 		 * be reset if we just destroyed the last vap). 		 */
if|if
condition|(
name|ath_startrecv
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: unable to restart recv logic\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_beacons
condition|)
block|{
comment|/* restart beacons */
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|sc
operator|->
name|sc_tdma
condition|)
name|ath_tdma_config
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ath_beacon_config
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
block|}
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ath_suspend
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: if_flags %x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_resume_up
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|ath_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|else
name|ieee80211_suspend_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * NB: don't worry about putting the chip in low power 	 * mode; pci will power off our socket on suspend and 	 * CardBus detaches the device. 	 */
block|}
end_function

begin_comment
comment|/*  * Reset the key cache since some parts do not reset the  * contents on resume.  First we clear all entries, then  * re-load keys that the 802.11 layer assumes are setup  * in h/w.  */
end_comment

begin_function
specifier|static
name|void
name|ath_reset_keycache
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_keymax
condition|;
name|i
operator|++
control|)
name|ath_hal_keyreset
argument_list|(
name|ah
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ieee80211_crypto_reload_keys
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ath_resume
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: if_flags %x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
comment|/* 	 * Must reset the chip before we reload the 	 * keycache as we were powered down on suspend. 	 */
name|ath_hal_reset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_opmode
argument_list|,
name|sc
operator|->
name|sc_curchan
operator|!=
name|NULL
condition|?
name|sc
operator|->
name|sc_curchan
else|:
name|ic
operator|->
name|ic_curchan
argument_list|,
name|AH_FALSE
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|ath_reset_keycache
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Let DFS at it in case it's a DFS channel */
name|ath_dfs_radar_enable
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_resume_up
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
name|ath_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 			 * Program the beacon registers using the last rx'd 			 * beacon frame and enable sync on the next beacon 			 * we see.  This should handle the case where we 			 * wakeup and find the same AP and also the case where 			 * we wakeup and need to roam.  For the latter we 			 * should get bmiss events that trigger a roam. 			 */
name|ath_beacon_config
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|ieee80211_resume_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
block|{
name|ath_hal_gpioCfgOutput
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
name|HAL_GPIO_MUX_MAC_NETWORK_LED
argument_list|)
expr_stmt|;
name|ath_hal_gpioset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
operator|!
name|sc
operator|->
name|sc_ledon
argument_list|)
expr_stmt|;
block|}
comment|/* XXX beacons ? */
block|}
end_function

begin_function
name|void
name|ath_shutdown
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: if_flags %x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|ath_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* NB: no point powering down chip as we're about to reboot */
block|}
end_function

begin_comment
comment|/*  * Interrupt handler.  Most of the actual processing is deferred.  */
end_comment

begin_function
name|void
name|ath_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_INT
name|status
init|=
literal|0
decl_stmt|;
name|uint32_t
name|txqs
decl_stmt|;
comment|/* 	 * If we're inside a reset path, just print a warning and 	 * clear the ISR. The reset routine will finish it for us. 	 */
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_inreset_cnt
condition|)
block|{
name|HAL_INT
name|status
decl_stmt|;
name|ath_hal_getisr
argument_list|(
name|ah
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* clear ISR */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable further intr's */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: in reset, ignoring: status=0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_invalid
condition|)
block|{
comment|/* 		 * The hardware is not ready/present, don't touch anything. 		 * Note this can happen early on if the IRQ is shared. 		 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: invalid; ignored\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ath_hal_intrpend
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* shared irq, not for us */
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|||
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|HAL_INT
name|status
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: if_flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|ath_hal_getisr
argument_list|(
name|ah
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* clear ISR */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable further intr's */
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Figure out the reason(s) for the interrupt.  Note 	 * that the hal returns a pseudo-ISR that may include 	 * bits we haven't explicitly enabled so we mask the 	 * value to insure we only process bits we requested. 	 */
name|ath_hal_getisr
argument_list|(
name|ah
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* NB: clears ISR too */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_INTR
argument_list|,
literal|"%s: status 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|ATH_KTR_INTR
argument_list|,
literal|"ath_intr: mask=0x%.8x"
argument_list|,
name|status
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_KTR_INTR_DEBUG
name|CTR5
argument_list|(
name|ATH_KTR_INTR
argument_list|,
literal|"ath_intr: ISR=0x%.8x, ISR_S0=0x%.8x, ISR_S1=0x%.8x, ISR_S2=0x%.8x, ISR_S5=0x%.8x"
argument_list|,
name|ah
operator|->
name|ah_intrstate
index|[
literal|0
index|]
argument_list|,
name|ah
operator|->
name|ah_intrstate
index|[
literal|1
index|]
argument_list|,
name|ah
operator|->
name|ah_intrstate
index|[
literal|2
index|]
argument_list|,
name|ah
operator|->
name|ah_intrstate
index|[
literal|3
index|]
argument_list|,
name|ah
operator|->
name|ah_intrstate
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|status
operator|&=
name|sc
operator|->
name|sc_imask
expr_stmt|;
comment|/* discard unasked for bits */
comment|/* Short-circuit un-handled interrupts */
if|if
condition|(
name|status
operator|==
literal|0x0
condition|)
block|{
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Take a note that we're inside the interrupt handler, so 	 * the reset routines know to wait. 	 */
name|sc
operator|->
name|sc_intr_cnt
operator|++
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Handle the interrupt. We won't run concurrent with the reset 	 * or channel change routines as they'll wait for sc_intr_cnt 	 * to be 0 before continuing. 	 */
if|if
condition|(
name|status
operator|&
name|HAL_INT_FATAL
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_hardware
operator|++
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable intr's until reset */
name|ath_fatal_proc
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|status
operator|&
name|HAL_INT_SWBA
condition|)
block|{
comment|/* 			 * Software beacon alert--time to send a beacon. 			 * Handle beacon transmission directly; deferring 			 * this is too slow to meet timing constraints 			 * under load. 			 */
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|sc
operator|->
name|sc_tdma
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_tdmaswba
operator|==
literal|0
condition|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|ath_tdma_beacon_send
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tdmaswba
operator|=
name|vap
operator|->
name|iv_tdma
operator|->
name|tdma_bintval
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_tdmaswba
operator|--
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|ath_beacon_proc
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
comment|/* 				 * Schedule the rx taskq in case there's no 				 * traffic so any frames held on the staging 				 * queue are aged and potentially flushed. 				 */
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtask
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_RXEOL
condition|)
block|{
name|int
name|imask
decl_stmt|;
name|CTR0
argument_list|(
name|ATH_KTR_ERR
argument_list|,
literal|"ath_intr: RXEOL"
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 			 * NB: the hardware should re-read the link when 			 *     RXE bit is written, but it doesn't work at 			 *     least on older hardware revs. 			 */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rxeol
operator|++
expr_stmt|;
comment|/* 			 * Disable RXEOL/RXORN - prevent an interrupt 			 * storm until the PCU logic can be reset. 			 * In case the interface is reset some other 			 * way before "sc_kickpcu" is called, don't 			 * modify sc_imask - that way if it is reset 			 * by a call to ath_reset() somehow, the 			 * interrupt mask will be correctly reprogrammed. 			 */
name|imask
operator|=
name|sc
operator|->
name|sc_imask
expr_stmt|;
name|imask
operator|&=
operator|~
operator|(
name|HAL_INT_RXEOL
operator||
name|HAL_INT_RXORN
operator|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|imask
argument_list|)
expr_stmt|;
comment|/* 			 * Only blank sc_rxlink if we've not yet kicked 			 * the PCU. 			 * 			 * This isn't entirely correct - the correct solution 			 * would be to have a PCU lock and engage that for 			 * the duration of the PCU fiddling; which would include 			 * running the RX process. Otherwise we could end up 			 * messing up the RX descriptor chain and making the 			 * RX desc list much shorter. 			 */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_kickpcu
condition|)
name|sc
operator|->
name|sc_rxlink
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_kickpcu
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Enqueue an RX proc, to handled whatever 			 * is in the RX queue. 			 * This will then kick the PCU. 			 */
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtask
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_TXURN
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_txurn
operator|++
expr_stmt|;
comment|/* bump tx trigger level */
name|ath_hal_updatetxtriglevel
argument_list|(
name|ah
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_RX
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_intr
operator|++
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_TX
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_intr
operator|++
expr_stmt|;
comment|/* 			 * Grab all the currently set bits in the HAL txq bitmap 			 * and blank them. This is the only place we should be 			 * doing this. 			 */
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|txqs
operator|=
literal|0xffffffff
expr_stmt|;
name|ath_hal_gettxintrtxqs
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|txqs
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txq_active
operator||=
name|txqs
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_txtask
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_BMISS
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_bmiss
operator|++
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_bmisstask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_GTT
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_timeout
operator|++
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|HAL_INT_CST
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_cst
operator|++
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|HAL_INT_MIB
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_mib
operator|++
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 			 * Disable interrupts until we service the MIB 			 * interrupt; otherwise it will continue to fire. 			 */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Let the hal handle the event.  We assume it will 			 * clear whatever condition caused the interrupt. 			 */
name|ath_hal_mibevent
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_halstats
argument_list|)
expr_stmt|;
comment|/* 			 * Don't reset the interrupt if we've just 			 * kicked the PCU, or we may get a nested 			 * RXEOL before the rxproc has had a chance 			 * to run. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_kickpcu
operator|==
literal|0
condition|)
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_RXORN
condition|)
block|{
comment|/* NB: hal marks HAL_INT_FATAL when RXORN is fatal */
name|CTR0
argument_list|(
name|ATH_KTR_ERR
argument_list|,
literal|"ath_intr: RXORN"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rxorn
operator|++
expr_stmt|;
block|}
block|}
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_intr_cnt
operator|--
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_fatal_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|u_int32_t
modifier|*
name|state
decl_stmt|;
name|u_int32_t
name|len
decl_stmt|;
name|void
modifier|*
name|sp
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"hardware error; resetting\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Fatal errors are unrecoverable.  Typically these 	 * are caused by DMA errors.  Collect h/w state from 	 * the hal so we can diagnose what's going on. 	 */
if|if
condition|(
name|ath_hal_getfatalstate
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|sp
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|len
operator|>=
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
operator|(
literal|"len %u bytes"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|sp
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"0x%08x 0x%08x 0x%08x, 0x%08x 0x%08x 0x%08x\n"
argument_list|,
name|state
index|[
literal|0
index|]
argument_list|,
name|state
index|[
literal|1
index|]
argument_list|,
name|state
index|[
literal|2
index|]
argument_list|,
name|state
index|[
literal|3
index|]
argument_list|,
name|state
index|[
literal|4
index|]
argument_list|,
name|state
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
name|ath_reset
argument_list|(
name|ifp
argument_list|,
name|ATH_RESET_NOLOSS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_bmiss_vap
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
comment|/* 	 * Workaround phantom bmiss interrupts by sanity-checking 	 * the time of our last rx'd frame.  If it is within the 	 * beacon miss interval then ignore the interrupt.  If it's 	 * truly a bmiss we'll get another interrupt soon and that'll 	 * be dispatched up for processing.  Note this applies only 	 * for h/w beacon miss events. 	 */
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_SWBMISS
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u_int64_t
name|lastrx
init|=
name|sc
operator|->
name|sc_lastrx
decl_stmt|;
name|u_int64_t
name|tsf
init|=
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
decl_stmt|;
name|u_int
name|bmisstimeout
init|=
name|vap
operator|->
name|iv_bmissthreshold
operator|*
name|vap
operator|->
name|iv_bss
operator|->
name|ni_intval
operator|*
literal|1024
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: tsf %llu lastrx %lld (%llu) bmiss %u\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|tsf
argument_list|,
call|(
name|unsigned
name|long
name|long
call|)
argument_list|(
name|tsf
operator|-
name|lastrx
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|lastrx
argument_list|,
name|bmisstimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsf
operator|-
name|lastrx
operator|<=
name|bmisstimeout
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_bmiss_phantom
operator|++
expr_stmt|;
return|return;
block|}
block|}
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|av_bmiss
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_hal_gethangstate
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|mask
parameter_list|,
name|uint32_t
modifier|*
name|hangs
parameter_list|)
block|{
name|uint32_t
name|rsize
decl_stmt|;
name|void
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|!
name|ath_hal_getdiagstate
argument_list|(
name|ah
argument_list|,
name|HAL_DIAG_CHECK_HANGS
argument_list|,
operator|&
name|mask
argument_list|,
sizeof|sizeof
argument_list|(
name|mask
argument_list|)
argument_list|,
operator|&
name|sp
argument_list|,
operator|&
name|rsize
argument_list|)
condition|)
return|return
literal|0
return|;
name|KASSERT
argument_list|(
name|rsize
operator|==
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
literal|"resultsize %u"
operator|,
name|rsize
operator|)
argument_list|)
expr_stmt|;
operator|*
name|hangs
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|sp
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_bmiss_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|uint32_t
name|hangs
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: pending %u\n"
argument_list|,
name|__func__
argument_list|,
name|pending
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_hal_gethangstate
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0xff
argument_list|,
operator|&
name|hangs
argument_list|)
operator|&&
name|hangs
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"bb hang detected (0x%x), resetting\n"
argument_list|,
name|hangs
argument_list|)
expr_stmt|;
name|ath_reset
argument_list|(
name|ifp
argument_list|,
name|ATH_RESET_NOLOSS
argument_list|)
expr_stmt|;
block|}
else|else
name|ieee80211_beacon_miss
argument_list|(
name|ifp
operator|->
name|if_l2com
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle TKIP MIC setup to deal hardware that doesn't do MIC  * calcs together with WME.  If necessary disable the crypto  * hardware and mark the 802.11 state so keys will be setup  * with the MIC work done in software.  */
end_comment

begin_function
specifier|static
name|void
name|ath_settkipmic
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_cryptocaps
operator|&
name|IEEE80211_CRYPTO_TKIP
operator|)
operator|&&
operator|!
name|sc
operator|->
name|sc_wmetkipmic
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WME
condition|)
block|{
name|ath_hal_settkipmic
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_cryptocaps
operator|&=
operator|~
name|IEEE80211_CRYPTO_TKIPMIC
expr_stmt|;
block|}
else|else
block|{
name|ath_hal_settkipmic
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_TKIPMIC
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ath_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: if_flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Stop anything previously setup.  This is safe 	 * whether this is the first time through or not. 	 */
name|ath_stop_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * The basic interface to setting the hardware in a good 	 * state is ``reset''.  On return the hardware is known to 	 * be powered up and with interrupts disabled.  This must 	 * be followed by initialization of the appropriate bits 	 * and then setup of the interrupt mask. 	 */
name|ath_settkipmic
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_reset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_opmode
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|,
name|AH_FALSE
argument_list|,
operator|&
name|status
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to reset hardware; hal status %u\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|ath_chan_change
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* Let DFS at it in case it's a DFS channel */
name|ath_dfs_radar_enable
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* 	 * Likewise this is set during reset so update 	 * state cached in the driver. 	 */
name|sc
operator|->
name|sc_diversity
operator|=
name|ath_hal_getdiversity
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_lastlongcal
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_resetcal
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_lastcalreset
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_lastani
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_lastshortcal
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_doresetcal
operator|=
name|AH_FALSE
expr_stmt|;
comment|/* 	 * Beacon timers were cleared here; give ath_newstate() 	 * a hint that the beacon timers should be poked when 	 * things transition to the RUN state. 	 */
name|sc
operator|->
name|sc_beacons
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initial aggregation settings. 	 */
name|sc
operator|->
name|sc_hwq_limit
operator|=
name|ATH_AGGR_MIN_QDEPTH
expr_stmt|;
name|sc
operator|->
name|sc_tid_hwq_lo
operator|=
name|ATH_AGGR_SCHED_LOW
expr_stmt|;
name|sc
operator|->
name|sc_tid_hwq_hi
operator|=
name|ATH_AGGR_SCHED_HIGH
expr_stmt|;
comment|/* 	 * Setup the hardware after reset: the key cache 	 * is filled as needed and the receive engine is 	 * set going.  Frame transmit is handled entirely 	 * in the frame output path; there's nothing to do 	 * here except setup the interrupt mask. 	 */
if|if
condition|(
name|ath_startrecv
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to start recv logic\n"
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Enable interrupts. 	 */
name|sc
operator|->
name|sc_imask
operator|=
name|HAL_INT_RX
operator||
name|HAL_INT_TX
operator||
name|HAL_INT_RXEOL
operator||
name|HAL_INT_RXORN
operator||
name|HAL_INT_FATAL
operator||
name|HAL_INT_GLOBAL
expr_stmt|;
comment|/* 	 * Enable MIB interrupts when there are hardware phy counters. 	 * Note we only do this (at the moment) for station mode. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_needmib
operator|&&
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_MIB
expr_stmt|;
comment|/* Enable global TX timeout and carrier sense timeout if available */
if|if
condition|(
name|ath_hal_gtxto_supported
argument_list|(
name|ah
argument_list|)
condition|)
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_GTT
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: imask=0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_wd_ch
argument_list|,
name|hz
argument_list|,
name|ath_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
if|if
condition|(
name|sc
operator|->
name|sc_tx99
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_tx99
operator|->
name|start
argument_list|(
name|sc
operator|->
name|sc_tx99
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* start all vap's */
block|}
end_function

begin_function
specifier|static
name|void
name|ath_stop_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: invalid %u if_flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_invalid
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|ATH_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* 		 * Shutdown the hardware and driver: 		 *    reset 802.11 state machine 		 *    turn off timers 		 *    disable interrupts 		 *    turn off the radio 		 *    clear transmit machinery 		 *    clear receive machinery 		 *    drain and release tx queues 		 *    reclaim beacon resources 		 *    power down hardware 		 * 		 * Note that some of this work is not possible if the 		 * hardware is gone (invalid). 		 */
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
if|if
condition|(
name|sc
operator|->
name|sc_tx99
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_tx99
operator|->
name|stop
argument_list|(
name|sc
operator|->
name|sc_tx99
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_wd_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_ledtimer
argument_list|)
expr_stmt|;
name|ath_hal_gpioset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
operator|!
name|sc
operator|->
name|sc_ledon
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_blinking
operator|=
literal|0
expr_stmt|;
block|}
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ath_draintxq
argument_list|(
name|sc
argument_list|,
name|ATH_RESET_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
block|{
name|ath_stoprecv
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ath_hal_phydisable
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_rxlink
operator|=
name|NULL
expr_stmt|;
name|ath_beacon_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX not needed */
block|}
block|}
end_function

begin_define
define|#
directive|define
name|MAX_TXRX_ITERATIONS
value|1000
end_define

begin_function
specifier|static
name|void
name|ath_txrx_stop
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
init|=
name|MAX_TXRX_ITERATIONS
decl_stmt|;
name|ATH_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Stop any new TX/RX from occuring */
name|taskqueue_block
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Sleep until all the pending operations have completed. 	 * 	 * The caller must ensure that reset has been incremented 	 * or the pending operations may continue being queued. 	 */
while|while
condition|(
name|sc
operator|->
name|sc_rxproc_cnt
operator|||
name|sc
operator|->
name|sc_txproc_cnt
operator|||
name|sc
operator|->
name|sc_txstart_cnt
operator|||
name|sc
operator|->
name|sc_intr_cnt
condition|)
block|{
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|,
literal|"ath_txrx_stop"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: didn't finish after %d iterations\n"
argument_list|,
name|__func__
argument_list|,
name|MAX_TXRX_ITERATIONS
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|MAX_TXRX_ITERATIONS
end_undef

begin_function
specifier|static
name|void
name|ath_txrx_start
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|taskqueue_unblock
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_stop_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the hardware w/o losing operational state.  This is  * basically a more efficient way of doing ath_stop, ath_init,  * followed by state transitions to the current 802.11  * operational state.  Used to recover from various errors and  * to reset or reload hardware state.  */
end_comment

begin_function
name|int
name|ath_reset
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|ATH_RESET_TYPE
name|reset_type
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX ensure ATH_LOCK isn't held; ath_rx_proc can't be locked */
name|ATH_PCU_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX if we're already inside a reset, print out a big warning */
if|if
condition|(
name|sc
operator|->
name|sc_inreset_cnt
operator|>
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: concurrent ath_reset()! Danger!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_inreset_cnt
operator|++
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Should now wait for pending TX/RX to complete 	 * and block future ones from occuring. This needs to be 	 * done before the TX queue is drained. 	 */
name|ath_txrx_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_draintxq
argument_list|(
name|sc
argument_list|,
name|reset_type
argument_list|)
expr_stmt|;
comment|/* stop xmit side */
comment|/* 	 * Regardless of whether we're doing a no-loss flush or 	 * not, stop the PCU and handle what's in the RX queue. 	 * That way frames aren't dropped which shouldn't be. 	 */
name|ath_stoprecv
argument_list|(
name|sc
argument_list|,
operator|(
name|reset_type
operator|!=
name|ATH_RESET_NOLOSS
operator|)
argument_list|)
expr_stmt|;
name|ath_rx_proc
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ath_settkipmic
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* configure TKIP MIC handling */
comment|/* NB: indicate channel change so we do a full reset */
if|if
condition|(
operator|!
name|ath_hal_reset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_opmode
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|,
name|AH_TRUE
argument_list|,
operator|&
name|status
argument_list|)
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: unable to reset hardware; hal status %u\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_diversity
operator|=
name|ath_hal_getdiversity
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* Let DFS at it in case it's a DFS channel */
name|ath_dfs_radar_enable
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_startrecv
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
comment|/* restart recv */
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: unable to start recv logic\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * We may be doing a reset in response to an ioctl 	 * that changes the channel so update any state that 	 * might change as a result. 	 */
name|ath_chan_change
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_beacons
condition|)
block|{
comment|/* restart beacons */
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|sc
operator|->
name|sc_tdma
condition|)
name|ath_tdma_config
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ath_beacon_config
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Release the reset lock and re-enable interrupts here. 	 * If an interrupt was being processed in ath_intr(), 	 * it would disable interrupts at this point. So we have 	 * to atomically enable interrupts and decrement the 	 * reset counter - this way ath_intr() doesn't end up 	 * disabling interrupts without a corresponding enable 	 * in the rest or channel change path. 	 */
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_inreset_cnt
operator|--
expr_stmt|;
comment|/* XXX only do this if sc_inreset_cnt == 0? */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * TX and RX can be started here. If it were started with 	 * sc_inreset_cnt> 0, the TX and RX path would abort. 	 * Thus if this is a nested call through the reset or 	 * channel change code, TX completion will occur but 	 * RX completion and ath_start / ath_tx_start will not 	 * run. 	 */
comment|/* Restart TX/RX as needed */
name|ath_txrx_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX Restart TX completion and pending TX */
if|if
condition|(
name|reset_type
operator|==
name|ATH_RESET_NOLOSS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|ATH_TXQ_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ath_txq_restart_dma
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ath_txq_sched
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * This may have been set during an ath_start() call which 	 * set this once it detected a concurrent TX was going on. 	 * So, clear it. 	 */
comment|/* XXX do this inside of IF_LOCK? */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
comment|/* Handle any frames in the TX queue */
comment|/* 	 * XXX should this be done by the caller, rather than 	 * ath_reset() ? 	 */
name|ath_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* restart xmit */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_reset_vap
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|u_long
name|cmd
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|IEEE80211_IOC_TXPOWER
case|:
comment|/* 		 * If per-packet TPC is enabled, then we have nothing 		 * to do; otherwise we need to force the global limit. 		 * All this can happen directly; no need to reset. 		 */
if|if
condition|(
operator|!
name|ath_hal_gettpc
argument_list|(
name|ah
argument_list|)
condition|)
name|ath_hal_settxpowlimit
argument_list|(
name|ah
argument_list|,
name|ic
operator|->
name|ic_txpowlimit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* XXX? Full or NOLOSS? */
return|return
name|ath_reset
argument_list|(
name|ifp
argument_list|,
name|ATH_RESET_FULL
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|ath_buf
modifier|*
name|_ath_getbuf_locked
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|ATH_TXBUF_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_getnobuf
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_BUSY
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_getbusybuf
operator|++
expr_stmt|;
name|bf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bf
operator|!=
name|NULL
operator|&&
operator|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_BUSY
operator|)
operator|==
literal|0
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
else|else
name|bf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|__func__
argument_list|,
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|)
operator|==
name|NULL
condition|?
literal|"out of xmit buffers"
else|:
literal|"xmit buffer busy"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Valid bf here; clear some basic fields */
name|bf
operator|->
name|bf_next
operator|=
name|NULL
expr_stmt|;
comment|/* XXX just to be sure */
name|bf
operator|->
name|bf_last
operator|=
name|NULL
expr_stmt|;
comment|/* XXX again, just to be sure */
name|bf
operator|->
name|bf_comp
operator|=
name|NULL
expr_stmt|;
comment|/* XXX again, just to be sure */
name|bzero
argument_list|(
operator|&
name|bf
operator|->
name|bf_state
argument_list|,
sizeof|sizeof
argument_list|(
name|bf
operator|->
name|bf_state
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bf
return|;
block|}
end_function

begin_comment
comment|/*  * When retrying a software frame, buffers marked ATH_BUF_BUSY  * can't be thrown back on the queue as they could still be  * in use by the hardware.  *  * This duplicates the buffer, or returns NULL.  *  * The descriptor is also copied but the link pointers and  * the DMA segments aren't copied; this frame should thus  * be again passed through the descriptor setup/chain routines  * so the link is correct.  *  * The caller must free the buffer using ath_freebuf().  *  * XXX TODO: this call shouldn't fail as it'll cause packet loss  * XXX in the TX pathway when retries are needed.  * XXX Figure out how to keep some buffers free, or factor the  * XXX number of busy buffers into the xmit path (ath_start())  * XXX so we don't over-commit.  */
end_comment

begin_function
name|struct
name|ath_buf
modifier|*
name|ath_buf_clone
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|tbf
decl_stmt|;
name|tbf
operator|=
name|ath_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbf
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* XXX failure? Why? */
comment|/* Copy basics */
name|tbf
operator|->
name|bf_next
operator|=
name|NULL
expr_stmt|;
name|tbf
operator|->
name|bf_nseg
operator|=
name|bf
operator|->
name|bf_nseg
expr_stmt|;
name|tbf
operator|->
name|bf_txflags
operator|=
name|bf
operator|->
name|bf_txflags
expr_stmt|;
name|tbf
operator|->
name|bf_flags
operator|=
name|bf
operator|->
name|bf_flags
operator|&
operator|~
name|ATH_BUF_BUSY
expr_stmt|;
name|tbf
operator|->
name|bf_status
operator|=
name|bf
operator|->
name|bf_status
expr_stmt|;
name|tbf
operator|->
name|bf_m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
name|tbf
operator|->
name|bf_node
operator|=
name|bf
operator|->
name|bf_node
expr_stmt|;
comment|/* will be setup by the chain/setup function */
name|tbf
operator|->
name|bf_lastds
operator|=
name|NULL
expr_stmt|;
comment|/* for now, last == self */
name|tbf
operator|->
name|bf_last
operator|=
name|tbf
expr_stmt|;
name|tbf
operator|->
name|bf_comp
operator|=
name|bf
operator|->
name|bf_comp
expr_stmt|;
comment|/* NOTE: DMA segments will be setup by the setup/chain functions */
comment|/* The caller has to re-init the descriptor + links */
comment|/* Copy state */
name|memcpy
argument_list|(
operator|&
name|tbf
operator|->
name|bf_state
argument_list|,
operator|&
name|bf
operator|->
name|bf_state
argument_list|,
sizeof|sizeof
argument_list|(
name|bf
operator|->
name|bf_state
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tbf
return|;
block|}
end_function

begin_function
name|struct
name|ath_buf
modifier|*
name|ath_getbuf
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bf
operator|=
name|_ath_getbuf_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: stop queue\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_qstop
operator|++
expr_stmt|;
comment|/* XXX do this inside of IF_LOCK? */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|bf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|ath_bufhead
name|frags
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|sc_invalid
condition|)
return|return;
comment|/* XXX is it ok to hold the ATH_LOCK here? */
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_inreset_cnt
operator|>
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: sc_inreset_cnt> 0; bailing\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX do this inside of IF_LOCK? */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|sc_txstart_cnt
operator|++
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Grab a TX buffer and associated resources. 		 */
name|bf
operator|=
name|ath_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
break|break;
name|IFQ_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
comment|/* 		 * Check for fragmentation.  If this frame 		 * has been broken up verify we have enough 		 * buffers to send all the fragments so all 		 * go out or none... 		 */
name|TAILQ_INIT
argument_list|(
operator|&
name|frags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_FRAG
operator|)
operator|&&
operator|!
name|ath_txfrag_setup
argument_list|(
name|sc
argument_list|,
operator|&
name|frags
argument_list|,
name|m
argument_list|,
name|ni
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: out of txfrag buffers\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nofrag
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ath_freetx
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|nextfrag
label|:
comment|/* 		 * Pass the frame to the h/w for transmission. 		 * Fragmented frames have each frag chained together 		 * with m_nextpkt.  We know there are sufficient ath_buf's 		 * to send all the frags because of work done by 		 * ath_txfrag_setup.  We leave m_nextpkt set while 		 * calling ath_tx_start so it can use it to extend the 		 * the tx duration to cover the subsequent frag and 		 * so it can reclaim all the mbufs in case of an error; 		 * ath_tx_start clears m_nextpkt once it commits to 		 * handing the frame to the hardware. 		 */
name|next
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
if|if
condition|(
name|ath_tx_start
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|bad
label|:
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|reclaim
label|:
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_txfrag_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|frags
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Beware of state changing between frags. 			 * XXX check sta power-save state? 			 */
if|if
condition|(
name|ni
operator|->
name|ni_vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: flush fragmented packet, state %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ni
operator|->
name|ni_vap
operator|->
name|iv_state
index|]
argument_list|)
expr_stmt|;
name|ath_freetx
argument_list|(
name|next
argument_list|)
expr_stmt|;
goto|goto
name|reclaim
goto|;
block|}
name|m
operator|=
name|next
expr_stmt|;
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|frags
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no buf for txfrag"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|frags
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
goto|goto
name|nextfrag
goto|;
block|}
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|5
expr_stmt|;
block|}
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txstart_cnt
operator|--
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|error
init|=
name|ieee80211_media_change
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
comment|/* NB: only the fixed rate can change and that doesn't need a reset */
return|return
operator|(
name|error
operator|==
name|ENETRESET
condition|?
literal|0
else|:
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Block/unblock tx+rx processing while a key change is done.  * We assume the caller serializes key management operations  * so we only need to worry about synchronization with other  * uses that originate in the driver.  */
end_comment

begin_function
specifier|static
name|void
name|ath_key_update_begin
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s:\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|taskqueue_block
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|IF_LOCK
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/* NB: doesn't block mgmt frames */
block|}
end_function

begin_function
specifier|static
name|void
name|ath_key_update_end
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s:\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IF_UNLOCK
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|taskqueue_unblock
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Calculate the receive filter according to the  * operating mode and state:  *  * o always accept unicast, broadcast, and multicast traffic  * o accept PHY error frames when hardware doesn't have MIB support  *   to count and we need them for ANI (sta mode only until recently)  *   and we are not scanning (ANI is disabled)  *   NB: older hal's add rx filter bits out of sight and we need to  *	 blindly preserve them  * o probe request frames are accepted only when operating in  *   hostap, adhoc, mesh, or monitor modes  * o enable promiscuous mode  *   - when in monitor mode  *   - if interface marked PROMISC (assumes bridge setting is filtered)  * o accept beacons:  *   - when operating in station mode for collecting rssi data when  *     the station is otherwise quiet, or  *   - when operating in adhoc mode so the 802.11 layer creates  *     node table entries for peers,  *   - when scanning  *   - when doing s/w beacon miss (e.g. for ap+sta)  *   - when operating in ap mode in 11g to detect overlapping bss that  *     require protection  *   - when operating in mesh mode to detect neighbors  * o accept control frames:  *   - when in monitor mode  * XXX HT protection for 11n  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|ath_calcrxfilter
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
name|rfilt
operator|=
name|HAL_RX_FILTER_UCAST
operator||
name|HAL_RX_FILTER_BCAST
operator||
name|HAL_RX_FILTER_MCAST
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_needmib
operator|&&
operator|!
name|sc
operator|->
name|sc_scanning
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_PHYERR
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_STA
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_PROBEREQ
expr_stmt|;
comment|/* XXX ic->ic_monvaps != 0? */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_PROM
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|||
name|sc
operator|->
name|sc_swbmiss
operator|||
name|sc
operator|->
name|sc_scanning
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_BEACON
expr_stmt|;
comment|/* 	 * NB: We don't recalculate the rx filter when 	 * ic_protmode changes; otherwise we could do 	 * this only when ic_protmode != NONE. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|&&
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_BEACON
expr_stmt|;
comment|/* 	 * Enable hardware PS-POLL RX only for hostap mode; 	 * STA mode sends PS-POLL frames but never 	 * receives them. 	 */
if|if
condition|(
name|ath_hal_getcapability
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_CAP_PSPOLL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|==
name|HAL_OK
operator|&&
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_PSPOLL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nmeshvaps
condition|)
block|{
name|rfilt
operator||=
name|HAL_RX_FILTER_BEACON
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hasbmatch
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_BSSID
expr_stmt|;
else|else
name|rfilt
operator||=
name|HAL_RX_FILTER_PROM
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_CONTROL
expr_stmt|;
comment|/* 	 * Enable RX of compressed BAR frames only when doing 	 * 802.11n. Required for A-MPDU. 	 */
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_COMPBAR
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_MODE
argument_list|,
literal|"%s: RX filter 0x%x, %s if_flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|rfilt
argument_list|,
name|ieee80211_opmode_name
index|[
name|ic
operator|->
name|ic_opmode
index|]
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
return|return
name|rfilt
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_update_promisc
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
comment|/* configure rx filter */
name|rfilt
operator|=
name|ath_calcrxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_setrxfilter
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_MODE
argument_list|,
literal|"%s: RX filter 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_update_mcast
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u_int32_t
name|mfilt
index|[
literal|2
index|]
decl_stmt|;
comment|/* calculate and install multicast filter */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
comment|/* 		 * Merge multicast addresses to form the hardware filter. 		 */
name|mfilt
index|[
literal|0
index|]
operator|=
name|mfilt
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* XXX need some fiddling to remove? */
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
name|caddr_t
name|dl
decl_stmt|;
name|u_int32_t
name|val
decl_stmt|;
name|u_int8_t
name|pos
decl_stmt|;
comment|/* calculate XOR of eight 6bit values */
name|dl
operator|=
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
name|val
operator|=
name|LE_READ_4
argument_list|(
name|dl
operator|+
literal|0
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|(
name|val
operator|>>
literal|18
operator|)
operator|^
operator|(
name|val
operator|>>
literal|12
operator|)
operator|^
operator|(
name|val
operator|>>
literal|6
operator|)
operator|^
name|val
expr_stmt|;
name|val
operator|=
name|LE_READ_4
argument_list|(
name|dl
operator|+
literal|3
argument_list|)
expr_stmt|;
name|pos
operator|^=
operator|(
name|val
operator|>>
literal|18
operator|)
operator|^
operator|(
name|val
operator|>>
literal|12
operator|)
operator|^
operator|(
name|val
operator|>>
literal|6
operator|)
operator|^
name|val
expr_stmt|;
name|pos
operator|&=
literal|0x3f
expr_stmt|;
name|mfilt
index|[
name|pos
operator|/
literal|32
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|pos
operator|%
literal|32
operator|)
operator|)
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
name|mfilt
index|[
literal|0
index|]
operator|=
name|mfilt
index|[
literal|1
index|]
operator|=
operator|~
literal|0
expr_stmt|;
name|ath_hal_setmcastfilter
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|mfilt
index|[
literal|0
index|]
argument_list|,
name|mfilt
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_MODE
argument_list|,
literal|"%s: MC filter %08x:%08x\n"
argument_list|,
name|__func__
argument_list|,
name|mfilt
index|[
literal|0
index|]
argument_list|,
name|mfilt
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_mode_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
comment|/* configure rx filter */
name|rfilt
operator|=
name|ath_calcrxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
comment|/* configure operational mode */
name|ath_hal_setopmode
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* handle any link-level address change */
name|ath_hal_setmac
argument_list|(
name|ah
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* calculate and install multicast filter */
name|ath_update_mcast
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the slot time based on the current setting.  */
end_comment

begin_function
specifier|static
name|void
name|ath_setslottime
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|sc
operator|->
name|sc_ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|u_int
name|usec
decl_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|usec
operator|=
literal|13
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|usec
operator|=
literal|21
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
block|{
comment|/* honor short/long slot time only in 11g */
comment|/* XXX shouldn't honor on pure g or turbo g channel */
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|)
name|usec
operator|=
name|HAL_SLOT_TIME_9
expr_stmt|;
else|else
name|usec
operator|=
name|HAL_SLOT_TIME_20
expr_stmt|;
block|}
else|else
name|usec
operator|=
name|HAL_SLOT_TIME_9
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: chan %u MHz flags 0x%x %s slot, %u usec\n"
argument_list|,
name|__func__
argument_list|,
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_freq
argument_list|,
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_flags
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|?
literal|"short"
else|:
literal|"long"
argument_list|,
name|usec
argument_list|)
expr_stmt|;
name|ath_hal_setslottime
argument_list|(
name|ah
argument_list|,
name|usec
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_updateslot
operator|=
name|OK
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from the 802.11 layer to update the  * slot time based on the current setting.  */
end_comment

begin_function
specifier|static
name|void
name|ath_updateslot
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
comment|/* 	 * When not coordinating the BSS, change the hardware 	 * immediately.  For other operation we defer the change 	 * until beacon updates have propagated to the stations. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
name|sc
operator|->
name|sc_updateslot
operator|=
name|UPDATE
expr_stmt|;
else|else
name|ath_setslottime
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup a h/w transmit queue for beacons.  */
end_comment

begin_function
specifier|static
name|int
name|ath_beaconq_setup
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|HAL_TXQ_INFO
name|qi
decl_stmt|;
name|memset
argument_list|(
operator|&
name|qi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|qi
argument_list|)
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_aifs
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmin
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmax
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
comment|/* NB: for dynamic turbo, don't enable any other interrupts */
name|qi
operator|.
name|tqi_qflags
operator|=
name|HAL_TXQ_TXDESCINT_ENABLE
expr_stmt|;
return|return
name|ath_hal_setuptxqueue
argument_list|(
name|ah
argument_list|,
name|HAL_TX_QUEUE_BEACON
argument_list|,
operator|&
name|qi
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Setup the transmit queue parameters for the beacon queue.  */
end_comment

begin_function
specifier|static
name|int
name|ath_beaconq_config
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
define|#
directive|define
name|ATH_EXPONENT_TO_VALUE
parameter_list|(
name|v
parameter_list|)
value|((1<<(v))-1)
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|sc
operator|->
name|sc_ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_TXQ_INFO
name|qi
decl_stmt|;
name|ath_hal_gettxqueueprops
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
operator|&
name|qi
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
comment|/* 		 * Always burst out beacon and CAB traffic. 		 */
name|qi
operator|.
name|tqi_aifs
operator|=
name|ATH_BEACON_AIFS_DEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmin
operator|=
name|ATH_BEACON_CWMIN_DEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmax
operator|=
name|ATH_BEACON_CWMAX_DEFAULT
expr_stmt|;
block|}
else|else
block|{
name|struct
name|wmeParams
modifier|*
name|wmep
init|=
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|WME_AC_BE
index|]
decl_stmt|;
comment|/* 		 * Adhoc mode; important thing is to use 2x cwmin. 		 */
name|qi
operator|.
name|tqi_aifs
operator|=
name|wmep
operator|->
name|wmep_aifsn
expr_stmt|;
name|qi
operator|.
name|tqi_cwmin
operator|=
literal|2
operator|*
name|ATH_EXPONENT_TO_VALUE
argument_list|(
name|wmep
operator|->
name|wmep_logcwmin
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_cwmax
operator|=
name|ATH_EXPONENT_TO_VALUE
argument_list|(
name|wmep
operator|->
name|wmep_logcwmax
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ath_hal_settxqueueprops
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
operator|&
name|qi
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to update parameters for "
literal|"beacon hardware queue!\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|ath_hal_resettxqueue
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
comment|/* push to h/w */
return|return
literal|1
return|;
block|}
undef|#
directive|undef
name|ATH_EXPONENT_TO_VALUE
block|}
end_function

begin_comment
comment|/*  * Allocate and setup an initial beacon frame.  */
end_comment

begin_function
specifier|static
name|int
name|ath_beacon_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bf
operator|=
name|avp
operator|->
name|av_bcbuf
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_node
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * NB: the beacon data buffer must be 32-bit aligned; 	 * we assume the mbuf routines will return us something 	 * with this alignment (perhaps should assert). 	 */
name|m
operator|=
name|ieee80211_beacon_alloc
argument_list|(
name|ni
argument_list|,
operator|&
name|avp
operator|->
name|av_boff
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cannot get mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_nombuf
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cannot map mbuf, bus_dmamap_load_mbuf_sg returns %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Calculate a TSF adjustment factor required for staggered 	 * beacons.  Note that we assume the format of the beacon 	 * frame leaves the tstamp field immediately following the 	 * header. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_stagbeacons
operator|&&
name|avp
operator|->
name|av_bslot
operator|>
literal|0
condition|)
block|{
name|uint64_t
name|tsfadjust
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
comment|/* 		 * The beacon interval is in TU's; the TSF is in usecs. 		 * We figure out how many TU's to add to align the timestamp 		 * then convert to TSF units and handle byte swapping before 		 * inserting it in the frame.  The hardware will then add this 		 * each time a beacon frame is sent.  Note that we align vap's 		 * 1..N and leave vap 0 untouched.  This means vap 0 has a 		 * timestamp in one beacon interval while the others get a 		 * timstamp aligned to the next interval. 		 */
name|tsfadjust
operator|=
name|ni
operator|->
name|ni_intval
operator|*
operator|(
name|ATH_BCBUF
operator|-
name|avp
operator|->
name|av_bslot
operator|)
operator|/
name|ATH_BCBUF
expr_stmt|;
name|tsfadjust
operator|=
name|htole64
argument_list|(
name|tsfadjust
operator|<<
literal|10
argument_list|)
expr_stmt|;
comment|/* TU -> TSF */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: %s beacons bslot %d intval %u tsfadjust %llu\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_stagbeacons
condition|?
literal|"stagger"
else|:
literal|"burst"
argument_list|,
name|avp
operator|->
name|av_bslot
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|,
operator|(
name|long
name|long
name|unsigned
operator|)
name|le64toh
argument_list|(
name|tsfadjust
argument_list|)
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|wh
index|[
literal|1
index|]
argument_list|,
operator|&
name|tsfadjust
argument_list|,
sizeof|sizeof
argument_list|(
name|tsfadjust
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bf
operator|->
name|bf_m
operator|=
name|m
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Setup the beacon frame for transmit.  */
end_comment

begin_function
specifier|static
name|void
name|ath_beacon_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
define|#
directive|define
name|USE_SHPREAMBLE
parameter_list|(
name|_ic
parameter_list|)
define|\
value|(((_ic)->ic_flags& (IEEE80211_F_SHPREAMBLE | IEEE80211_F_USEBARKER))\ 		== IEEE80211_F_SHPREAMBLE)
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|bf
operator|->
name|bf_m
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|antenna
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|u_int8_t
name|rix
decl_stmt|,
name|rate
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON_PROC
argument_list|,
literal|"%s: m %p len %u\n"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
comment|/* setup descriptors */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|bf
operator|->
name|bf_last
operator|=
name|bf
expr_stmt|;
name|bf
operator|->
name|bf_lastds
operator|=
name|ds
expr_stmt|;
name|flags
operator|=
name|HAL_TXDESC_NOACK
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|&&
name|sc
operator|->
name|sc_hasveol
condition|)
block|{
name|ds
operator|->
name|ds_link
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
comment|/* self-linked */
name|flags
operator||=
name|HAL_TXDESC_VEOL
expr_stmt|;
comment|/* 		 * Let hardware handle antenna switching. 		 */
name|antenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
block|}
else|else
block|{
name|ds
operator|->
name|ds_link
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Switch antenna every 4 beacons. 		 * XXX assumes two antenna 		 */
if|if
condition|(
name|sc
operator|->
name|sc_txantenna
operator|!=
literal|0
condition|)
name|antenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_stagbeacons
operator|&&
name|sc
operator|->
name|sc_nbcnvaps
operator|!=
literal|0
condition|)
name|antenna
operator|=
operator|(
operator|(
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_xmit
operator|/
name|sc
operator|->
name|sc_nbcnvaps
operator|)
operator|&
literal|4
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
else|else
name|antenna
operator|=
operator|(
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_xmit
operator|&
literal|4
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|bf
operator|->
name|bf_nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"multi-segment beacon frame; nseg %u"
operator|,
name|bf
operator|->
name|bf_nseg
operator|)
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_data
operator|=
name|bf
operator|->
name|bf_segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
comment|/* 	 * Calculate rate code. 	 * XXX everything at min xmit rate 	 */
name|rix
operator|=
literal|0
expr_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
name|rate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|USE_SHPREAMBLE
argument_list|(
name|ic
argument_list|)
condition|)
name|rate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|ath_hal_setuptxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|m
operator|->
name|m_len
operator|+
name|IEEE80211_CRC_LEN
comment|/* frame length */
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
comment|/* header length */
argument_list|,
name|HAL_PKT_TYPE_BEACON
comment|/* Atheros packet type */
argument_list|,
name|ni
operator|->
name|ni_txpower
comment|/* txpower XXX */
argument_list|,
name|rate
argument_list|,
literal|1
comment|/* series 0 rate/tries */
argument_list|,
name|HAL_TXKEYIX_INVALID
comment|/* no encryption */
argument_list|,
name|antenna
comment|/* antenna mode */
argument_list|,
name|flags
comment|/* no ack, veol for beacons */
argument_list|,
literal|0
comment|/* rts/cts rate */
argument_list|,
literal|0
comment|/* rts/cts duration */
argument_list|)
expr_stmt|;
comment|/* NB: beacon's BufLen must be a multiple of 4 bytes */
name|ath_hal_filltxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|roundup
argument_list|(
name|m
operator|->
name|m_len
argument_list|,
literal|4
argument_list|)
comment|/* buffer length */
argument_list|,
name|AH_TRUE
comment|/* first segment */
argument_list|,
name|AH_TRUE
comment|/* last segment */
argument_list|,
name|ds
comment|/* first descriptor */
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|ath_desc_swap(ds);
endif|#
directive|endif
undef|#
directive|undef
name|USE_SHPREAMBLE
block|}
end_function

begin_function
specifier|static
name|void
name|ath_beacon_update
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|item
parameter_list|)
block|{
name|struct
name|ieee80211_beacon_offsets
modifier|*
name|bo
init|=
operator|&
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|av_boff
decl_stmt|;
name|setbit
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append the contents of src to dst; both queues  * are assumed to be locked.  */
end_comment

begin_function
specifier|static
name|void
name|ath_txqmove
parameter_list|(
name|struct
name|ath_txq
modifier|*
name|dst
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|src
parameter_list|)
block|{
name|TAILQ_CONCAT
argument_list|(
operator|&
name|dst
operator|->
name|axq_q
argument_list|,
operator|&
name|src
operator|->
name|axq_q
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|dst
operator|->
name|axq_link
operator|=
name|src
operator|->
name|axq_link
expr_stmt|;
name|src
operator|->
name|axq_link
operator|=
name|NULL
expr_stmt|;
name|dst
operator|->
name|axq_depth
operator|+=
name|src
operator|->
name|axq_depth
expr_stmt|;
name|dst
operator|->
name|axq_aggr_depth
operator|+=
name|src
operator|->
name|axq_aggr_depth
expr_stmt|;
name|src
operator|->
name|axq_depth
operator|=
literal|0
expr_stmt|;
name|src
operator|->
name|axq_aggr_depth
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Transmit a beacon frame at SWBA.  Dynamic updates to the  * frame contents are done as needed and the slot time is  * also adjusted based on current state.  */
end_comment

begin_function
specifier|static
name|void
name|ath_beacon_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|otherant
decl_stmt|;
name|uint32_t
name|bfaddr
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON_PROC
argument_list|,
literal|"%s: pending %u\n"
argument_list|,
name|__func__
argument_list|,
name|pending
argument_list|)
expr_stmt|;
comment|/* 	 * Check if the previous beacon has gone out.  If 	 * not don't try to post another, skip this period 	 * and wait for the next.  Missed beacons indicate 	 * a problem and should not occur.  If we miss too 	 * many consecutive beacons reset the device. 	 */
if|if
condition|(
name|ath_hal_numtxpending
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_bmisscount
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_missed
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: missed %u consecutive beacons\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bmisscount
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bmisscount
operator|>=
name|ath_bstuck_threshold
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_bstucktask
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_bmisscount
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: resume beacon xmit after %u misses\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bmisscount
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bmisscount
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_stagbeacons
condition|)
block|{
comment|/* staggered beacons */
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|sc
operator|->
name|sc_ifp
operator|->
name|if_l2com
decl_stmt|;
name|uint32_t
name|tsftu
decl_stmt|;
name|tsftu
operator|=
name|ath_hal_gettsf32
argument_list|(
name|ah
argument_list|)
operator|>>
literal|10
expr_stmt|;
comment|/* XXX lintval */
name|slot
operator|=
operator|(
operator|(
name|tsftu
operator|%
name|ic
operator|->
name|ic_lintval
operator|)
operator|*
name|ATH_BCBUF
operator|)
operator|/
name|ic
operator|->
name|ic_lintval
expr_stmt|;
name|vap
operator|=
name|sc
operator|->
name|sc_bslot
index|[
operator|(
name|slot
operator|+
literal|1
operator|)
operator|%
name|ATH_BCBUF
index|]
expr_stmt|;
name|bfaddr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vap
operator|!=
name|NULL
operator|&&
name|vap
operator|->
name|iv_state
operator|>=
name|IEEE80211_S_RUN
condition|)
block|{
name|bf
operator|=
name|ath_beacon_generate
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
name|bfaddr
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* burst'd beacons */
name|uint32_t
modifier|*
name|bflink
init|=
operator|&
name|bfaddr
decl_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|ATH_BCBUF
condition|;
name|slot
operator|++
control|)
block|{
name|vap
operator|=
name|sc
operator|->
name|sc_bslot
index|[
name|slot
index|]
expr_stmt|;
if|if
condition|(
name|vap
operator|!=
name|NULL
operator|&&
name|vap
operator|->
name|iv_state
operator|>=
name|IEEE80211_S_RUN
condition|)
block|{
name|bf
operator|=
name|ath_beacon_generate
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
block|{
operator|*
name|bflink
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
name|bflink
operator|=
operator|&
name|bf
operator|->
name|bf_desc
operator|->
name|ds_link
expr_stmt|;
block|}
block|}
block|}
operator|*
name|bflink
operator|=
literal|0
expr_stmt|;
comment|/* terminate list */
block|}
comment|/* 	 * Handle slot time change when a non-ERP station joins/leaves 	 * an 11g network.  The 802.11 layer notifies us via callback, 	 * we mark updateslot, then wait one beacon before effecting 	 * the change.  This gives associated stations at least one 	 * beacon interval to note the state change. 	 */
comment|/* XXX locking */
if|if
condition|(
name|sc
operator|->
name|sc_updateslot
operator|==
name|UPDATE
condition|)
block|{
name|sc
operator|->
name|sc_updateslot
operator|=
name|COMMIT
expr_stmt|;
comment|/* commit next beacon */
name|sc
operator|->
name|sc_slotupdate
operator|=
name|slot
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_updateslot
operator|==
name|COMMIT
operator|&&
name|sc
operator|->
name|sc_slotupdate
operator|==
name|slot
condition|)
name|ath_setslottime
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* commit change to h/w */
comment|/* 	 * Check recent per-antenna transmit statistics and flip 	 * the default antenna if noticeably more frames went out 	 * on the non-default antenna. 	 * XXX assumes 2 anntenae 	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_diversity
operator|&&
operator|(
operator|!
name|sc
operator|->
name|sc_stagbeacons
operator|||
name|slot
operator|==
literal|0
operator|)
condition|)
block|{
name|otherant
operator|=
name|sc
operator|->
name|sc_defant
operator|&
literal|1
condition|?
literal|2
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ant_tx
index|[
name|otherant
index|]
operator|>
name|sc
operator|->
name|sc_ant_tx
index|[
name|sc
operator|->
name|sc_defant
index|]
operator|+
literal|2
condition|)
name|ath_setdefantenna
argument_list|(
name|sc
argument_list|,
name|otherant
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ant_tx
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|sc_ant_tx
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bfaddr
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Stop any current dma and put the new frame on the queue. 		 * This should never fail since we check above that no frames 		 * are still pending on the queue. 		 */
if|if
condition|(
operator|!
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: beacon queue %u did not stop?\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
block|}
comment|/* NB: cabq traffic should already be queued and primed */
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
name|bfaddr
argument_list|)
expr_stmt|;
name|ath_hal_txstart
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_xmit
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|ath_buf
modifier|*
name|ath_beacon_generate
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|cabq
init|=
name|sc
operator|->
name|sc_cabq
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|nmcastq
decl_stmt|,
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_state
operator|>=
name|IEEE80211_S_RUN
argument_list|,
operator|(
literal|"not running, state %d"
operator|,
name|vap
operator|->
name|iv_state
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|avp
operator|->
name|av_bcbuf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no beacon buffer"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Update dynamic beacon contents.  If this returns 	 * non-zero then we need to remap the memory because 	 * the beacon frame changed size (probably because 	 * of the TIM bitmap). 	 */
name|bf
operator|=
name|avp
operator|->
name|av_bcbuf
expr_stmt|;
name|m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
name|nmcastq
operator|=
name|avp
operator|->
name|av_mcastq
operator|.
name|axq_depth
expr_stmt|;
if|if
condition|(
name|ieee80211_beacon_update
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|,
operator|&
name|avp
operator|->
name|av_boff
argument_list|,
name|m
argument_list|,
name|nmcastq
argument_list|)
condition|)
block|{
comment|/* XXX too conservative? */
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|vap
operator|->
name|iv_ifp
argument_list|,
literal|"%s: bus_dmamap_load_mbuf_sg failed, error %u\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
operator|(
name|avp
operator|->
name|av_boff
operator|.
name|bo_tim
index|[
literal|4
index|]
operator|&
literal|1
operator|)
operator|&&
name|cabq
operator|->
name|axq_depth
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: cabq did not drain, mcastq %u cabq %u\n"
argument_list|,
name|__func__
argument_list|,
name|nmcastq
argument_list|,
name|cabq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_cabq_busy
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nvaps
operator|>
literal|1
operator|&&
name|sc
operator|->
name|sc_stagbeacons
condition|)
block|{
comment|/* 			 * CABQ traffic from a previous vap is still pending. 			 * We must drain the q before this beacon frame goes 			 * out as otherwise this vap's stations will get cab 			 * frames from a different vap. 			 * XXX could be slow causing us to miss DBA 			 */
name|ath_tx_draintxq
argument_list|(
name|sc
argument_list|,
name|cabq
argument_list|)
expr_stmt|;
block|}
block|}
name|ath_beacon_setup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Enable the CAB queue before the beacon queue to 	 * insure cab frames are triggered by this beacon. 	 */
if|if
condition|(
name|avp
operator|->
name|av_boff
operator|.
name|bo_tim
index|[
literal|4
index|]
operator|&
literal|1
condition|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
comment|/* NB: only at DTIM */
name|ATH_TXQ_LOCK
argument_list|(
name|cabq
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK
argument_list|(
operator|&
name|avp
operator|->
name|av_mcastq
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmcastq
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|bfm
decl_stmt|;
comment|/* 			 * Move frames from the s/w mcast q to the h/w cab q. 			 * XXX MORE_DATA bit 			 */
name|bfm
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|avp
operator|->
name|av_mcastq
operator|.
name|axq_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|cabq
operator|->
name|axq_link
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cabq
operator|->
name|axq_link
operator|=
name|bfm
operator|->
name|bf_daddr
expr_stmt|;
block|}
else|else
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|cabq
operator|->
name|axq_qnum
argument_list|,
name|bfm
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|ath_txqmove
argument_list|(
name|cabq
argument_list|,
operator|&
name|avp
operator|->
name|av_mcastq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_cabq_xmit
operator|+=
name|nmcastq
expr_stmt|;
block|}
comment|/* NB: gated by beacon so safe to start here */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
operator|(
name|cabq
operator|->
name|axq_q
operator|)
argument_list|)
condition|)
name|ath_hal_txstart
argument_list|(
name|ah
argument_list|,
name|cabq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
operator|&
name|avp
operator|->
name|av_mcastq
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|cabq
argument_list|)
expr_stmt|;
block|}
return|return
name|bf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_beacon_start_adhoc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|avp
operator|->
name|av_bcbuf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no beacon buffer"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Update dynamic beacon contents.  If this returns 	 * non-zero then we need to remap the memory because 	 * the beacon frame changed size (probably because 	 * of the TIM bitmap). 	 */
name|bf
operator|=
name|avp
operator|->
name|av_bcbuf
expr_stmt|;
name|m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
if|if
condition|(
name|ieee80211_beacon_update
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|,
operator|&
name|avp
operator|->
name|av_boff
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* XXX too conservative? */
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|vap
operator|->
name|iv_ifp
argument_list|,
literal|"%s: bus_dmamap_load_mbuf_sg failed, error %u\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ath_beacon_setup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* NB: caller is known to have already stopped tx dma */
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|ath_hal_txstart
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the hardware after detecting beacons have stopped.  */
end_comment

begin_function
specifier|static
name|void
name|ath_bstuck_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|uint32_t
name|hangs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ath_hal_gethangstate
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0xff
argument_list|,
operator|&
name|hangs
argument_list|)
operator|&&
name|hangs
operator|!=
literal|0
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"bb hang detected (0x%x)\n"
argument_list|,
name|hangs
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"stuck beacon; resetting (bmiss count %u)\n"
argument_list|,
name|sc
operator|->
name|sc_bmisscount
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_bstuck
operator|++
expr_stmt|;
comment|/* 	 * This assumes that there's no simultaneous channel mode change 	 * occuring. 	 */
name|ath_reset
argument_list|(
name|ifp
argument_list|,
name|ATH_RESET_NOLOSS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim beacon resources and return buffer to the pool.  */
end_comment

begin_function
specifier|static
name|void
name|ath_beacon_return
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_node
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim beacon resources.  */
end_comment

begin_function
specifier|static
name|void
name|ath_beacon_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->sc_bbuf
argument_list|,
argument|bf_list
argument_list|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_node
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Configure the beacon and sleep timers.  *  * When operating as an AP this resets the TSF and sets  * up the hardware to notify us when we need to issue beacons.  *  * When operating in station mode this sets up the beacon  * timers according to the timestamp of the last received  * beacon and the current TSF, configures PCF and DTIM  * handling, programs the sleep registers so the hardware  * will wakeup in time to receive beacons, and configures  * the beacon miss handling so we'll receive a BMISS  * interrupt when we stop seeing beacons from the AP  * we've associated with.  */
end_comment

begin_function
specifier|static
name|void
name|ath_beacon_config
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
define|#
directive|define
name|TSF_TO_TU
parameter_list|(
name|_h
parameter_list|,
name|_l
parameter_list|)
define|\
value|((((u_int32_t)(_h))<< 22) | (((u_int32_t)(_l))>> 10))
define|#
directive|define
name|FUDGE
value|2
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|sc
operator|->
name|sc_ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|u_int32_t
name|nexttbtt
decl_stmt|,
name|intval
decl_stmt|,
name|tsftu
decl_stmt|;
name|u_int64_t
name|tsf
decl_stmt|;
if|if
condition|(
name|vap
operator|==
name|NULL
condition|)
name|vap
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
expr_stmt|;
comment|/* XXX */
name|ni
operator|=
name|vap
operator|->
name|iv_bss
expr_stmt|;
comment|/* extract tstamp from last beacon and convert to TU */
name|nexttbtt
operator|=
name|TSF_TO_TU
argument_list|(
name|LE_READ_4
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
operator|+
literal|4
argument_list|)
argument_list|,
name|LE_READ_4
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
comment|/* 		 * For multi-bss ap/mesh support beacons are either staggered 		 * evenly over N slots or burst together.  For the former 		 * arrange for the SWBA to be delivered for each slot. 		 * Slots that are not occupied will generate nothing. 		 */
comment|/* NB: the beacon interval is kept internally in TU's */
name|intval
operator|=
name|ni
operator|->
name|ni_intval
operator|&
name|HAL_BEACON_PERIOD
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_stagbeacons
condition|)
name|intval
operator|/=
name|ATH_BCBUF
expr_stmt|;
block|}
else|else
block|{
comment|/* NB: the beacon interval is kept internally in TU's */
name|intval
operator|=
name|ni
operator|->
name|ni_intval
operator|&
name|HAL_BEACON_PERIOD
expr_stmt|;
block|}
if|if
condition|(
name|nexttbtt
operator|==
literal|0
condition|)
comment|/* e.g. for ap mode */
name|nexttbtt
operator|=
name|intval
expr_stmt|;
elseif|else
if|if
condition|(
name|intval
condition|)
comment|/* NB: can be 0 for monitor mode */
name|nexttbtt
operator|=
name|roundup
argument_list|(
name|nexttbtt
argument_list|,
name|intval
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: nexttbtt %u intval %u (%u)\n"
argument_list|,
name|__func__
argument_list|,
name|nexttbtt
argument_list|,
name|intval
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
operator|!
name|sc
operator|->
name|sc_swbmiss
condition|)
block|{
name|HAL_BEACON_STATE
name|bs
decl_stmt|;
name|int
name|dtimperiod
decl_stmt|,
name|dtimcount
decl_stmt|;
name|int
name|cfpperiod
decl_stmt|,
name|cfpcount
decl_stmt|;
comment|/* 		 * Setup dtim and cfp parameters according to 		 * last beacon we received (which may be none). 		 */
name|dtimperiod
operator|=
name|ni
operator|->
name|ni_dtim_period
expr_stmt|;
if|if
condition|(
name|dtimperiod
operator|<=
literal|0
condition|)
comment|/* NB: 0 if not known */
name|dtimperiod
operator|=
literal|1
expr_stmt|;
name|dtimcount
operator|=
name|ni
operator|->
name|ni_dtim_count
expr_stmt|;
if|if
condition|(
name|dtimcount
operator|>=
name|dtimperiod
condition|)
comment|/* NB: sanity check */
name|dtimcount
operator|=
literal|0
expr_stmt|;
comment|/* XXX? */
name|cfpperiod
operator|=
literal|1
expr_stmt|;
comment|/* NB: no PCF support yet */
name|cfpcount
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Pull nexttbtt forward to reflect the current 		 * TSF and calculate dtim+cfp state for the result. 		 */
name|tsf
operator|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|tsftu
operator|=
name|TSF_TO_TU
argument_list|(
name|tsf
operator|>>
literal|32
argument_list|,
name|tsf
argument_list|)
operator|+
name|FUDGE
expr_stmt|;
do|do
block|{
name|nexttbtt
operator|+=
name|intval
expr_stmt|;
if|if
condition|(
operator|--
name|dtimcount
operator|<
literal|0
condition|)
block|{
name|dtimcount
operator|=
name|dtimperiod
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|--
name|cfpcount
operator|<
literal|0
condition|)
name|cfpcount
operator|=
name|cfpperiod
operator|-
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|nexttbtt
operator|<
name|tsftu
condition|)
do|;
name|memset
argument_list|(
operator|&
name|bs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bs
argument_list|)
argument_list|)
expr_stmt|;
name|bs
operator|.
name|bs_intval
operator|=
name|intval
expr_stmt|;
name|bs
operator|.
name|bs_nexttbtt
operator|=
name|nexttbtt
expr_stmt|;
name|bs
operator|.
name|bs_dtimperiod
operator|=
name|dtimperiod
operator|*
name|intval
expr_stmt|;
name|bs
operator|.
name|bs_nextdtim
operator|=
name|bs
operator|.
name|bs_nexttbtt
operator|+
name|dtimcount
operator|*
name|intval
expr_stmt|;
name|bs
operator|.
name|bs_cfpperiod
operator|=
name|cfpperiod
operator|*
name|bs
operator|.
name|bs_dtimperiod
expr_stmt|;
name|bs
operator|.
name|bs_cfpnext
operator|=
name|bs
operator|.
name|bs_nextdtim
operator|+
name|cfpcount
operator|*
name|bs
operator|.
name|bs_dtimperiod
expr_stmt|;
name|bs
operator|.
name|bs_cfpmaxduration
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 		 * The 802.11 layer records the offset to the DTIM 		 * bitmap while receiving beacons; use it here to 		 * enable h/w detection of our AID being marked in 		 * the bitmap vector (to indicate frames for us are 		 * pending at the AP). 		 * XXX do DTIM handling in s/w to WAR old h/w bugs 		 * XXX enable based on h/w rev for newer chips 		 */
block|bs.bs_timoffset = ni->ni_timoff;
endif|#
directive|endif
comment|/* 		 * Calculate the number of consecutive beacons to miss 		 * before taking a BMISS interrupt. 		 * Note that we clamp the result to at most 10 beacons. 		 */
name|bs
operator|.
name|bs_bmissthreshold
operator|=
name|vap
operator|->
name|iv_bmissthreshold
expr_stmt|;
if|if
condition|(
name|bs
operator|.
name|bs_bmissthreshold
operator|>
literal|10
condition|)
name|bs
operator|.
name|bs_bmissthreshold
operator|=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|bs
operator|.
name|bs_bmissthreshold
operator|<=
literal|0
condition|)
name|bs
operator|.
name|bs_bmissthreshold
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Calculate sleep duration.  The configuration is 		 * given in ms.  We insure a multiple of the beacon 		 * period is used.  Also, if the sleep duration is 		 * greater than the DTIM period then it makes senses 		 * to make it a multiple of that. 		 * 		 * XXX fixed at 100ms 		 */
name|bs
operator|.
name|bs_sleepduration
operator|=
name|roundup
argument_list|(
name|IEEE80211_MS_TO_TU
argument_list|(
literal|100
argument_list|)
argument_list|,
name|bs
operator|.
name|bs_intval
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs
operator|.
name|bs_sleepduration
operator|>
name|bs
operator|.
name|bs_dtimperiod
condition|)
name|bs
operator|.
name|bs_sleepduration
operator|=
name|roundup
argument_list|(
name|bs
operator|.
name|bs_sleepduration
argument_list|,
name|bs
operator|.
name|bs_dtimperiod
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: tsf %ju tsf:tu %u intval %u nexttbtt %u dtim %u nextdtim %u bmiss %u sleep %u cfp:period %u maxdur %u next %u timoffset %u\n"
argument_list|,
name|__func__
argument_list|,
name|tsf
argument_list|,
name|tsftu
argument_list|,
name|bs
operator|.
name|bs_intval
argument_list|,
name|bs
operator|.
name|bs_nexttbtt
argument_list|,
name|bs
operator|.
name|bs_dtimperiod
argument_list|,
name|bs
operator|.
name|bs_nextdtim
argument_list|,
name|bs
operator|.
name|bs_bmissthreshold
argument_list|,
name|bs
operator|.
name|bs_sleepduration
argument_list|,
name|bs
operator|.
name|bs_cfpperiod
argument_list|,
name|bs
operator|.
name|bs_cfpmaxduration
argument_list|,
name|bs
operator|.
name|bs_cfpnext
argument_list|,
name|bs
operator|.
name|bs_timoffset
argument_list|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ath_hal_beacontimers
argument_list|(
name|ah
argument_list|,
operator|&
name|bs
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_BMISS
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nexttbtt
operator|==
name|intval
condition|)
name|intval
operator||=
name|HAL_BEACON_RESET_TSF
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
comment|/* 			 * In IBSS mode enable the beacon timers but only 			 * enable SWBA interrupts if we need to manually 			 * prepare beacon frames.  Otherwise we use a 			 * self-linked tx descriptor and let the hardware 			 * deal with things. 			 */
name|intval
operator||=
name|HAL_BEACON_ENA
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_hasveol
condition|)
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_SWBA
expr_stmt|;
if|if
condition|(
operator|(
name|intval
operator|&
name|HAL_BEACON_RESET_TSF
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Pull nexttbtt forward to reflect 				 * the current TSF. 				 */
name|tsf
operator|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|tsftu
operator|=
name|TSF_TO_TU
argument_list|(
name|tsf
operator|>>
literal|32
argument_list|,
name|tsf
argument_list|)
operator|+
name|FUDGE
expr_stmt|;
do|do
block|{
name|nexttbtt
operator|+=
name|intval
expr_stmt|;
block|}
do|while
condition|(
name|nexttbtt
operator|<
name|tsftu
condition|)
do|;
block|}
name|ath_beaconq_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
comment|/* 			 * In AP/mesh mode we enable the beacon timers 			 * and SWBA interrupts to prepare beacon frames. 			 */
name|intval
operator||=
name|HAL_BEACON_ENA
expr_stmt|;
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_SWBA
expr_stmt|;
comment|/* beacon prepare */
name|ath_beaconq_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|ath_hal_beaconinit
argument_list|(
name|ah
argument_list|,
name|nexttbtt
argument_list|,
name|intval
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bmisscount
operator|=
literal|0
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
comment|/* 		 * When using a self-linked beacon descriptor in 		 * ibss mode load it once here. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|&&
name|sc
operator|->
name|sc_hasveol
condition|)
name|ath_beacon_start_adhoc
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|0
expr_stmt|;
undef|#
directive|undef
name|FUDGE
undef|#
directive|undef
name|TSF_TO_TU
block|}
end_function

begin_function
specifier|static
name|void
name|ath_load_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|paddr
init|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
decl_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"error %u on bus_dma callback"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
operator|*
name|paddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_descdma_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_descdma
modifier|*
name|dd
parameter_list|,
name|ath_bufhead
modifier|*
name|head
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nbuf
parameter_list|,
name|int
name|ndesc
parameter_list|)
block|{
define|#
directive|define
name|DS2PHYS
parameter_list|(
name|_dd
parameter_list|,
name|_ds
parameter_list|)
define|\
value|((_dd)->dd_desc_paddr + ((caddr_t)(_ds) - (caddr_t)(_dd)->dd_desc))
define|#
directive|define
name|ATH_DESC_4KB_BOUND_CHECK
parameter_list|(
name|_daddr
parameter_list|,
name|_len
parameter_list|)
define|\
value|((((u_int32_t)(_daddr)& 0xFFF)> (0x1000 - (_len))) ? 1 : 0)
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|uint8_t
modifier|*
name|ds
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bsize
decl_stmt|,
name|error
decl_stmt|;
name|int
name|desc_len
decl_stmt|;
name|desc_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ath_desc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: %s DMA: %u buffers %u desc/buf\n"
argument_list|,
name|__func__
argument_list|,
name|name
argument_list|,
name|nbuf
argument_list|,
name|ndesc
argument_list|)
expr_stmt|;
name|dd
operator|->
name|dd_name
operator|=
name|name
expr_stmt|;
name|dd
operator|->
name|dd_desc_len
operator|=
name|desc_len
operator|*
name|nbuf
operator|*
name|ndesc
expr_stmt|;
comment|/* 	 * Merlin work-around: 	 * Descriptors that cross the 4KB boundary can't be used. 	 * Assume one skipped descriptor per 4KB page. 	 */
if|if
condition|(
operator|!
name|ath_hal_split4ktrans
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
condition|)
block|{
name|int
name|numdescpage
init|=
literal|4096
operator|/
operator|(
name|desc_len
operator|*
name|ndesc
operator|)
decl_stmt|;
name|dd
operator|->
name|dd_desc_len
operator|=
operator|(
name|nbuf
operator|/
name|numdescpage
operator|+
literal|1
operator|)
operator|*
literal|4096
expr_stmt|;
block|}
comment|/* 	 * Setup DMA descriptor area. 	 */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
comment|/* parent */
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|dd
operator|->
name|dd_desc_len
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|dd
operator|->
name|dd_desc_len
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockarg */
operator|&
name|dd
operator|->
name|dd_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"cannot allocate %s DMA tag\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* allocate descriptors */
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to create dmamap for %s descriptors, "
literal|"error %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail0
goto|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dd
operator|->
name|dd_desc
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to alloc memory for %u %s descriptors, "
literal|"error %u\n"
argument_list|,
name|nbuf
operator|*
name|ndesc
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|,
name|dd
operator|->
name|dd_desc
argument_list|,
name|dd
operator|->
name|dd_desc_len
argument_list|,
name|ath_load_cb
argument_list|,
operator|&
name|dd
operator|->
name|dd_desc_paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to map %s descriptors, error %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|ds
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|dd
operator|->
name|dd_desc
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: %s DMA map: %p (%lu) -> %p (%lu)\n"
argument_list|,
name|__func__
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|ds
argument_list|,
operator|(
name|u_long
operator|)
name|dd
operator|->
name|dd_desc_len
argument_list|,
operator|(
name|caddr_t
operator|)
name|dd
operator|->
name|dd_desc_paddr
argument_list|,
comment|/*XXX*/
operator|(
name|u_long
operator|)
name|dd
operator|->
name|dd_desc_len
argument_list|)
expr_stmt|;
comment|/* allocate rx buffers */
name|bsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ath_buf
argument_list|)
operator|*
name|nbuf
expr_stmt|;
name|bf
operator|=
name|malloc
argument_list|(
name|bsize
argument_list|,
name|M_ATHDEV
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"malloc of %s buffers failed, size %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
name|dd
operator|->
name|dd_bufptr
operator|=
name|bf
expr_stmt|;
name|TAILQ_INIT
argument_list|(
name|head
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
operator|,
name|bf
operator|++
operator|,
name|ds
operator|+=
operator|(
name|ndesc
operator|*
name|desc_len
operator|)
control|)
block|{
name|bf
operator|->
name|bf_desc
operator|=
operator|(
expr|struct
name|ath_desc
operator|*
operator|)
name|ds
expr_stmt|;
name|bf
operator|->
name|bf_daddr
operator|=
name|DS2PHYS
argument_list|(
name|dd
argument_list|,
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_split4ktrans
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
condition|)
block|{
comment|/* 			 * Merlin WAR: Skip descriptor addresses which 			 * cause 4KB boundary crossing along any point 			 * in the descriptor. 			 */
if|if
condition|(
name|ATH_DESC_4KB_BOUND_CHECK
argument_list|(
name|bf
operator|->
name|bf_daddr
argument_list|,
name|desc_len
operator|*
name|ndesc
argument_list|)
condition|)
block|{
comment|/* Start at the next page */
name|ds
operator|+=
literal|0x1000
operator|-
operator|(
name|bf
operator|->
name|bf_daddr
operator|&
literal|0xFFF
operator|)
expr_stmt|;
name|bf
operator|->
name|bf_desc
operator|=
operator|(
expr|struct
name|ath_desc
operator|*
operator|)
name|ds
expr_stmt|;
name|bf
operator|->
name|bf_daddr
operator|=
name|DS2PHYS
argument_list|(
name|dd
argument_list|,
name|ds
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to create dmamap for %s "
literal|"buffer %u, error %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
name|dd
argument_list|,
name|head
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|bf
operator|->
name|bf_lastds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
comment|/* Just an initial value */
name|TAILQ_INSERT_TAIL
argument_list|(
name|head
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|fail3
label|:
name|bus_dmamap_unload
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|fail2
label|:
name|bus_dmamem_free
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_desc
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|fail1
label|:
name|bus_dmamap_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|fail0
label|:
name|bus_dma_tag_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
undef|#
directive|undef
name|DS2PHYS
undef|#
directive|undef
name|ATH_DESC_4KB_BOUND_CHECK
block|}
end_function

begin_function
specifier|static
name|void
name|ath_descdma_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_descdma
modifier|*
name|dd
parameter_list|,
name|ath_bufhead
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_desc
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|head
argument_list|,
argument|bf_list
argument_list|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_m
condition|)
block|{
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_dmamap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_dmamap
operator|=
name|NULL
expr_stmt|;
block|}
name|ni
operator|=
name|bf
operator|->
name|bf_node
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Reclaim node reference. 			 */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
name|TAILQ_INIT
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dd
operator|->
name|dd_bufptr
argument_list|,
name|M_ATHDEV
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_desc_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ath_descdma_setup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
literal|"rx"
argument_list|,
name|ath_rxbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|error
operator|=
name|ath_descdma_setup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
literal|"tx"
argument_list|,
name|ath_txbuf
argument_list|,
name|ATH_TXDESC
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|ath_descdma_setup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_bdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|,
literal|"beacon"
argument_list|,
name|ATH_BCBUF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|)
expr_stmt|;
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_desc_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_bdma
operator|.
name|dd_desc_len
operator|!=
literal|0
condition|)
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_bdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_txdma
operator|.
name|dd_desc_len
operator|!=
literal|0
condition|)
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rxdma
operator|.
name|dd_desc_len
operator|!=
literal|0
condition|)
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|ath_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
specifier|const
name|size_t
name|space
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ath_node
argument_list|)
operator|+
name|sc
operator|->
name|sc_rc
operator|->
name|arc_space
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
name|an
operator|=
name|malloc
argument_list|(
name|space
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|an
operator|==
name|NULL
condition|)
block|{
comment|/* XXX stat+msg */
return|return
name|NULL
return|;
block|}
name|ath_rate_node_init
argument_list|(
name|sc
argument_list|,
name|an
argument_list|)
expr_stmt|;
comment|/* Setup the mutex - there's no associd yet so set the name to NULL */
name|snprintf
argument_list|(
name|an
operator|->
name|an_name
argument_list|,
sizeof|sizeof
argument_list|(
name|an
operator|->
name|an_name
argument_list|)
argument_list|,
literal|"%s: node %p"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|an
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|an
operator|->
name|an_mtx
argument_list|,
name|an
operator|->
name|an_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* XXX setup ath_tid */
name|ath_tx_tid_init
argument_list|(
name|sc
argument_list|,
name|an
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE
argument_list|,
literal|"%s: an %p\n"
argument_list|,
name|__func__
argument_list|,
name|an
argument_list|)
expr_stmt|;
return|return
operator|&
name|an
operator|->
name|an_node
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_node_cleanup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
comment|/* Cleanup ath_tid, free unused bufs, unlink bufs in TXQ */
name|ath_tx_node_flush
argument_list|(
name|sc
argument_list|,
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
name|ath_rate_node_cleanup
argument_list|(
name|sc
argument_list|,
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_node_cleanup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_node_free
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE
argument_list|,
literal|"%s: ni %p\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
operator|->
name|an_mtx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_node_free
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_node_getsignal
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int8_t
modifier|*
name|rssi
parameter_list|,
name|int8_t
modifier|*
name|noise
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
operator|*
name|rssi
operator|=
name|ic
operator|->
name|ic_node_getrssi
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_chan
operator|!=
name|IEEE80211_CHAN_ANYC
condition|)
operator|*
name|noise
operator|=
name|ath_hal_getchannoise
argument_list|(
name|ah
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
else|else
operator|*
name|noise
operator|=
operator|-
literal|95
expr_stmt|;
comment|/* nominally correct */
block|}
end_function

begin_function
specifier|static
name|int
name|ath_rxbuf_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * NB: by assigning a page to the rx dma buffer we 		 * implicitly satisfy the Atheros requirement that 		 * this buffer be cache-line-aligned and sized to be 		 * multiple of the cache line size.  Not doing this 		 * causes weird stuff to happen (for the 5210 at least). 		 */
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: no mbuf/cluster\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_nombuf
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: bus_dmamap_load_mbuf_sg failed; error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_busdma
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|KASSERT
argument_list|(
name|bf
operator|->
name|bf_nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"multi-segment packet; nseg %u"
operator|,
name|bf
operator|->
name|bf_nseg
operator|)
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|m
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* 	 * Setup descriptors.  For receive we always terminate 	 * the descriptor list with a self-linked entry so we'll 	 * not get overrun under high load (as can happen with a 	 * 5212 when ANI processing enables PHY error frames). 	 * 	 * To insure the last descriptor is self-linked we create 	 * each descriptor as self-linked and add it to the end.  As 	 * each additional descriptor is added the previous self-linked 	 * entry is ``fixed'' naturally.  This should be safe even 	 * if DMA is happening.  When processing RX interrupts we 	 * never remove/process the last, self-linked, entry on the 	 * descriptor list.  This insures the hardware always has 	 * someplace to write a new frame. 	 */
comment|/* 	 * 11N: we can no longer afford to self link the last descriptor. 	 * MAC acknowledges BA status as long as it copies frames to host 	 * buffer (or rx fifo). This can incorrectly acknowledge packets 	 * to a sender if last desc is self-linked. 	 */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rxslink
condition|)
name|ds
operator|->
name|ds_link
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
comment|/* link to self */
else|else
name|ds
operator|->
name|ds_link
operator|=
literal|0
expr_stmt|;
comment|/* terminate the list */
name|ds
operator|->
name|ds_data
operator|=
name|bf
operator|->
name|bf_segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|ath_hal_setuprxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|m
operator|->
name|m_len
comment|/* buffer size */
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rxlink
operator|!=
name|NULL
condition|)
operator|*
name|sc
operator|->
name|sc_rxlink
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
name|sc
operator|->
name|sc_rxlink
operator|=
operator|&
name|ds
operator|->
name|ds_link
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Extend 15-bit time stamp from rx descriptor to  * a full 64-bit TSF using the specified TSF.  */
end_comment

begin_function
specifier|static
name|__inline
name|u_int64_t
name|ath_extend_tsf15
parameter_list|(
name|u_int32_t
name|rstamp
parameter_list|,
name|u_int64_t
name|tsf
parameter_list|)
block|{
if|if
condition|(
operator|(
name|tsf
operator|&
literal|0x7fff
operator|)
operator|<
name|rstamp
condition|)
name|tsf
operator|-=
literal|0x8000
expr_stmt|;
return|return
operator|(
operator|(
name|tsf
operator|&
operator|~
literal|0x7fff
operator|)
operator||
name|rstamp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Extend 32-bit time stamp from rx descriptor to  * a full 64-bit TSF using the specified TSF.  */
end_comment

begin_function
specifier|static
name|__inline
name|u_int64_t
name|ath_extend_tsf32
parameter_list|(
name|u_int32_t
name|rstamp
parameter_list|,
name|u_int64_t
name|tsf
parameter_list|)
block|{
name|u_int32_t
name|tsf_low
init|=
name|tsf
operator|&
literal|0xffffffff
decl_stmt|;
name|u_int64_t
name|tsf64
init|=
operator|(
name|tsf
operator|&
operator|~
literal|0xffffffffULL
operator|)
operator||
name|rstamp
decl_stmt|;
if|if
condition|(
name|rstamp
operator|>
name|tsf_low
operator|&&
operator|(
name|rstamp
operator|-
name|tsf_low
operator|>
literal|0x10000000
operator|)
condition|)
name|tsf64
operator|-=
literal|0x100000000ULL
expr_stmt|;
if|if
condition|(
name|rstamp
operator|<
name|tsf_low
operator|&&
operator|(
name|tsf_low
operator|-
name|rstamp
operator|>
literal|0x10000000
operator|)
condition|)
name|tsf64
operator|+=
literal|0x100000000ULL
expr_stmt|;
return|return
name|tsf64
return|;
block|}
end_function

begin_comment
comment|/*  * Extend the TSF from the RX descriptor to a full 64 bit TSF.  * Earlier hardware versions only wrote the low 15 bits of the  * TSF into the RX descriptor; later versions (AR5416 and up)  * include the 32 bit TSF value.  */
end_comment

begin_function
specifier|static
name|__inline
name|u_int64_t
name|ath_extend_tsf
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|rstamp
parameter_list|,
name|u_int64_t
name|tsf
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_rxtsf32
condition|)
return|return
name|ath_extend_tsf32
argument_list|(
name|rstamp
argument_list|,
name|tsf
argument_list|)
return|;
else|else
return|return
name|ath_extend_tsf15
argument_list|(
name|rstamp
argument_list|,
name|tsf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Intercept management frames to collect beacon rssi data  * and to do ibss merges.  */
end_comment

begin_function
specifier|static
name|void
name|ath_recv_mgmt
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|subtype
parameter_list|,
name|int
name|rssi
parameter_list|,
name|int
name|nf
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
comment|/* 	 * Call up first so subsequent work can use information 	 * potentially stored in the node (e.g. for ibss merge). 	 */
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|av_recv_mgmt
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|subtype
argument_list|,
name|rssi
argument_list|,
name|nf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_BEACON
case|:
comment|/* update rssi statistics for use by the hal */
name|ATH_RSSI_LPF
argument_list|(
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgbrssi
argument_list|,
name|rssi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_syncbeacon
operator|&&
name|ni
operator|==
name|vap
operator|->
name|iv_bss
operator|&&
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* 			 * Resync beacon timers using the tsf of the beacon 			 * frame we just received. 			 */
name|ath_beacon_config
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
comment|/* fall thru... */
case|case
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
case|:
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
operator|&&
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
name|uint32_t
name|rstamp
init|=
name|sc
operator|->
name|sc_lastrs
operator|->
name|rs_tstamp
decl_stmt|;
name|uint64_t
name|tsf
init|=
name|ath_extend_tsf
argument_list|(
name|sc
argument_list|,
name|rstamp
argument_list|,
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
argument_list|)
decl_stmt|;
comment|/* 			 * Handle ibss merge as needed; check the tsf on the 			 * frame before attempting the merge.  The 802.11 spec 			 * says the station should change it's bssid to match 			 * the oldest station with the same ssid, where oldest 			 * is determined by the tsf.  Note that hardware 			 * reconfiguration happens through callback to 			 * ath_newstate as the state machine will go from 			 * RUN -> RUN when this happens. 			 */
if|if
condition|(
name|le64toh
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|tsf
argument_list|)
operator|>=
name|tsf
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"ibss merge, rstamp %u tsf %ju "
literal|"tstamp %ju\n"
argument_list|,
name|rstamp
argument_list|,
operator|(
name|uintmax_t
operator|)
name|tsf
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ni
operator|->
name|ni_tstamp
operator|.
name|tsf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ieee80211_ibss_merge
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the default antenna.  */
end_comment

begin_function
specifier|static
name|void
name|ath_setdefantenna
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|antenna
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
comment|/* XXX block beacon interrupts */
name|ath_hal_setdefantenna
argument_list|(
name|ah
argument_list|,
name|antenna
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_defant
operator|!=
name|antenna
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_ant_defswitch
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_defant
operator|=
name|antenna
expr_stmt|;
name|sc
operator|->
name|sc_rxotherant
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_rx_tap
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ath_rx_status
modifier|*
name|rs
parameter_list|,
name|u_int64_t
name|tsf
parameter_list|,
name|int16_t
name|nf
parameter_list|)
block|{
define|#
directive|define
name|CHAN_HT20
value|htole32(IEEE80211_CHAN_HT20)
define|#
directive|define
name|CHAN_HT40U
value|htole32(IEEE80211_CHAN_HT40U)
define|#
directive|define
name|CHAN_HT40D
value|htole32(IEEE80211_CHAN_HT40D)
define|#
directive|define
name|CHAN_HT
value|(CHAN_HT20|CHAN_HT40U|CHAN_HT40D)
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|uint8_t
name|rix
decl_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no rate table, mode %u"
operator|,
name|sc
operator|->
name|sc_curmode
operator|)
argument_list|)
expr_stmt|;
name|rix
operator|=
name|rt
operator|->
name|rateCodeToIndex
index|[
name|rs
operator|->
name|rs_rate
index|]
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_rate
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_flags
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|rxflags
expr_stmt|;
ifdef|#
directive|ifdef
name|AH_SUPPORT_AR5416
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator|&=
operator|~
name|CHAN_HT
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_rate
operator|&
name|IEEE80211_RATE_MCS
condition|)
block|{
comment|/* HT rate */
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
if|if
condition|(
operator|(
name|rs
operator|->
name|rs_flags
operator|&
name|HAL_RX_2040
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator||=
name|CHAN_HT20
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator||=
name|CHAN_HT40U
expr_stmt|;
else|else
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator||=
name|CHAN_HT40D
expr_stmt|;
if|if
condition|(
operator|(
name|rs
operator|->
name|rs_flags
operator|&
name|HAL_RX_GI
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_flags
operator||=
name|IEEE80211_RADIOTAP_F_SHORTGI
expr_stmt|;
block|}
endif|#
directive|endif
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_tsf
operator|=
name|htole64
argument_list|(
name|ath_extend_tsf
argument_list|(
name|sc
argument_list|,
name|rs
operator|->
name|rs_tstamp
argument_list|,
name|tsf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_CRC
condition|)
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_flags
operator||=
name|IEEE80211_RADIOTAP_F_BADFCS
expr_stmt|;
comment|/* XXX propagate other error flags from descriptor */
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_antnoise
operator|=
name|nf
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_antsignal
operator|=
name|nf
operator|+
name|rs
operator|->
name|rs_rssi
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_antenna
operator|=
name|rs
operator|->
name|rs_antenna
expr_stmt|;
undef|#
directive|undef
name|CHAN_HT
undef|#
directive|undef
name|CHAN_HT20
undef|#
directive|undef
name|CHAN_HT40U
undef|#
directive|undef
name|CHAN_HT40D
block|}
end_function

begin_function
specifier|static
name|void
name|ath_handle_micerror
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
name|int
name|keyix
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
comment|/* XXX recheck MIC to deal w/ chips that lie */
comment|/* XXX discard MIC errors on !data frames */
name|ni
operator|=
name|ieee80211_find_rxnode
argument_list|(
name|ic
argument_list|,
operator|(
specifier|const
expr|struct
name|ieee80211_frame_min
operator|*
operator|)
name|wh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_notify_michael_failure
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|wh
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Only run the RX proc if it's not already running.  * Since this may get run as part of the reset/flush path,  * the task can't clash with an existing, running tasklet.  */
end_comment

begin_function
specifier|static
name|void
name|ath_rx_tasklet
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|CTR1
argument_list|(
name|ATH_KTR_INTR
argument_list|,
literal|"ath_rx_proc: pending=%d"
argument_list|,
name|npending
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RX_PROC
argument_list|,
literal|"%s: pending %u\n"
argument_list|,
name|__func__
argument_list|,
name|npending
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_inreset_cnt
operator|>
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: sc_inreset_cnt> 0; skipping\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_rx_proc
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_rx_proc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|resched
parameter_list|)
block|{
define|#
directive|define
name|PA2DESC
parameter_list|(
name|_sc
parameter_list|,
name|_pa
parameter_list|)
define|\
value|((struct ath_desc *)((caddr_t)(_sc)->sc_rxdma.dd_desc + \ 		((_pa) - (_sc)->sc_rxdma.dd_desc_paddr)))
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|struct
name|ath_rx_status
modifier|*
name|rs
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|len
decl_stmt|,
name|type
decl_stmt|,
name|ngood
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|int16_t
name|nf
decl_stmt|;
name|u_int64_t
name|tsf
decl_stmt|;
name|int
name|npkts
init|=
literal|0
decl_stmt|;
comment|/* XXX we must not hold the ATH_LOCK here */
name|ATH_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxproc_cnt
operator|++
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RX_PROC
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ngood
operator|=
literal|0
expr_stmt|;
name|nf
operator|=
name|ath_hal_getchannoise
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_noise
operator|=
name|nf
expr_stmt|;
name|tsf
operator|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
expr_stmt|;
do|do
block|{
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rxslink
operator|&&
name|bf
operator|==
name|NULL
condition|)
block|{
comment|/* NB: shouldn't happen */
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: no buffer!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * End of List: 			 * this can happen for non-self-linked RX chains 			 */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_hitqueueend
operator|++
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* NB: shouldn't happen */
comment|/* 			 * If mbuf allocation failed previously there 			 * will be no mbuf; try again to re-populate it. 			 */
comment|/* XXX make debug msg */
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: no mbuf!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
goto|goto
name|rx_next
goto|;
block|}
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_link
operator|==
name|bf
operator|->
name|bf_daddr
condition|)
block|{
comment|/* NB: never process the self-linked entry at the end */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_hitqueueend
operator|++
expr_stmt|;
break|break;
block|}
comment|/* XXX sync descriptor memory */
comment|/* 		 * Must provide the virtual address of the current 		 * descriptor, the physical address, and the virtual 		 * address of the next descriptor in the h/w chain. 		 * This allows the HAL to look ahead to see if the 		 * hardware is done with a descriptor by checking the 		 * done bit in the following descriptor and the address 		 * of the current descriptor the DMA engine is working 		 * on.  All this is necessary because of our use of 		 * a self-linked list to avoid rx overruns. 		 */
name|rs
operator|=
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_rxstat
expr_stmt|;
name|status
operator|=
name|ath_hal_rxprocdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|,
name|PA2DESC
argument_list|(
name|sc
argument_list|,
name|ds
operator|->
name|ds_link
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_RECV_DESC
condition|)
name|ath_printrxbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|,
name|status
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|==
name|HAL_EINPROGRESS
condition|)
break|break;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|npkts
operator|++
expr_stmt|;
comment|/* These aren't specifically errors */
if|if
condition|(
name|rs
operator|->
name|rs_flags
operator|&
name|HAL_RX_GI
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_halfgi
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_flags
operator|&
name|HAL_RX_2040
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_2040
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_flags
operator|&
name|HAL_RX_DELIM_CRC_PRE
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_pre_crc_err
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_flags
operator|&
name|HAL_RX_DELIM_CRC_POST
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_post_crc_err
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_flags
operator|&
name|HAL_RX_DECRYPT_BUSY
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_decrypt_busy_err
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_flags
operator|&
name|HAL_RX_HI_RX_CHAIN
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_hi_rx_chain
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_CRC
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_crcerr
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_FIFO
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_fifoerr
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_PHY
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_phyerr
operator|++
expr_stmt|;
comment|/* Process DFS radar events */
if|if
condition|(
operator|(
name|rs
operator|->
name|rs_phyerr
operator|==
name|HAL_PHYERR_RADAR
operator|)
operator|||
operator|(
name|rs
operator|->
name|rs_phyerr
operator|==
name|HAL_PHYERR_FALSE_RADAR_EXT
operator|)
condition|)
block|{
comment|/* Since we're touching the frame data, sync it */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* Now pass it to the radar processing code */
name|ath_dfs_process_phy_err
argument_list|(
name|sc
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|tsf
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
comment|/* Be suitably paranoid about receiving phy errors out of the stats array bounds */
if|if
condition|(
name|rs
operator|->
name|rs_phyerr
operator|<
literal|64
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_phy
index|[
name|rs
operator|->
name|rs_phyerr
index|]
operator|++
expr_stmt|;
goto|goto
name|rx_error
goto|;
comment|/* NB: don't count in ierrors */
block|}
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_DECRYPT
condition|)
block|{
comment|/* 				 * Decrypt error.  If the error occurred 				 * because there was no hardware key, then 				 * let the frame through so the upper layers 				 * can process it.  This is necessary for 5210 				 * parts which have no way to setup a ``clear'' 				 * key cache entry. 				 * 				 * XXX do key cache faulting 				 */
if|if
condition|(
name|rs
operator|->
name|rs_keyix
operator|==
name|HAL_RXKEYIX_INVALID
condition|)
goto|goto
name|rx_accept
goto|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_badcrypt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_MIC
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_badmic
operator|++
expr_stmt|;
comment|/* 				 * Do minimal work required to hand off 				 * the 802.11 header for notification. 				 */
comment|/* XXX frag's and qos frames */
name|len
operator|=
name|rs
operator|->
name|rs_datalen
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|ath_handle_micerror
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_splitmic
condition|?
name|rs
operator|->
name|rs_keyix
operator|-
literal|32
else|:
name|rs
operator|->
name|rs_keyix
argument_list|)
expr_stmt|;
block|}
block|}
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|rx_error
label|:
comment|/* 			 * Cleanup any pending partial frame. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_rxpending
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_rxpending
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxpending
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 			 * When a tap is present pass error frames 			 * that have been requested.  By default we 			 * pass decrypt+mic errors but others may be 			 * interesting (e.g. crc). 			 */
if|if
condition|(
name|ieee80211_radiotap_active
argument_list|(
name|ic
argument_list|)
operator|&&
operator|(
name|rs
operator|->
name|rs_status
operator|&
name|sc
operator|->
name|sc_monpass
operator|)
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* NB: bpf needs the mbuf length setup */
name|len
operator|=
name|rs
operator|->
name|rs_datalen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|ath_rx_tap
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|rs
argument_list|,
name|tsf
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|ieee80211_radiotap_rx_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* XXX pass MIC errors up for s/w reclaculation */
goto|goto
name|rx_next
goto|;
block|}
name|rx_accept
label|:
comment|/* 		 * Sync and unmap the frame.  At this point we're 		 * committed to passing the mbuf somewhere so clear 		 * bf_m; this means a new mbuf must be allocated 		 * when the rx descriptor is setup again to receive 		 * another frame. 		 */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
name|rs
operator|->
name|rs_datalen
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_more
condition|)
block|{
comment|/* 			 * Frame spans multiple descriptors; save 			 * it for the next completed descriptor, it 			 * will be used to construct a jumbogram. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_rxpending
operator|!=
name|NULL
condition|)
block|{
comment|/* NB: max frame size is currently 2 clusters */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_toobig
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_rxpending
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|sc
operator|->
name|sc_rxpending
operator|=
name|m
expr_stmt|;
goto|goto
name|rx_next
goto|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_rxpending
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * This is the second part of a jumbogram, 			 * chain it to the first mbuf, adjust the 			 * frame length, and clear the rxpending state. 			 */
name|sc
operator|->
name|sc_rxpending
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|sc
operator|->
name|sc_rxpending
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|len
expr_stmt|;
name|m
operator|=
name|sc
operator|->
name|sc_rxpending
expr_stmt|;
name|sc
operator|->
name|sc_rxpending
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Normal single-descriptor receive; setup 			 * the rcvif and packet length. 			 */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_ant_rx
index|[
name|rs
operator|->
name|rs_antenna
index|]
operator|++
expr_stmt|;
comment|/* 		 * Populate the rx status block.  When there are bpf 		 * listeners we do the additional work to provide 		 * complete status.  Otherwise we fill in only the 		 * material required by ieee80211_input.  Note that 		 * noise setting is filled in above. 		 */
if|if
condition|(
name|ieee80211_radiotap_active
argument_list|(
name|ic
argument_list|)
condition|)
name|ath_rx_tap
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|rs
argument_list|,
name|tsf
argument_list|,
name|nf
argument_list|)
expr_stmt|;
comment|/* 		 * From this point on we assume the frame is at least 		 * as large as ieee80211_frame_min; verify that. 		 */
if|if
condition|(
name|len
operator|<
name|IEEE80211_MIN_LEN
condition|)
block|{
if|if
condition|(
operator|!
name|ieee80211_radiotap_active
argument_list|(
name|ic
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RECV
argument_list|,
literal|"%s: short packet %d\n"
argument_list|,
name|__func__
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_tooshort
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* NB: in particular this captures ack's */
name|ieee80211_radiotap_rx_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|rx_next
goto|;
block|}
if|if
condition|(
name|IFF_DUMPPKTS
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RECV
argument_list|)
condition|)
block|{
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
init|=
name|sc
operator|->
name|sc_currates
decl_stmt|;
name|uint8_t
name|rix
init|=
name|rt
operator|->
name|rateCodeToIndex
index|[
name|rs
operator|->
name|rs_rate
index|]
decl_stmt|;
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
argument_list|,
name|rs
operator|->
name|rs_rssi
argument_list|)
expr_stmt|;
block|}
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|IEEE80211_CRC_LEN
argument_list|)
expr_stmt|;
comment|/* 		 * Locate the node for sender, track state, and then 		 * pass the (referenced) node up to the 802.11 layer 		 * for its use. 		 */
name|ni
operator|=
name|ieee80211_find_rxnode_withkey
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
expr|struct
name|ieee80211_frame_min
operator|*
argument_list|)
argument_list|,
name|rs
operator|->
name|rs_keyix
operator|==
name|HAL_RXKEYIX_INVALID
condition|?
name|IEEE80211_KEYIX_NONE
else|:
name|rs
operator|->
name|rs_keyix
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_lastrs
operator|=
name|rs
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_isaggr
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_agg
operator|++
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
comment|/*  			 * Only punt packets for ampdu reorder processing for 			 * 11n nodes; net80211 enforces that M_AMPDU is only 			 * set for 11n nodes.  			 */
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
condition|)
name|m
operator|->
name|m_flags
operator||=
name|M_AMPDU
expr_stmt|;
comment|/* 			 * Sending station is known, dispatch directly. 			 */
name|type
operator|=
name|ieee80211_input
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|rs
operator|->
name|rs_rssi
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* 			 * Arrange to update the last rx timestamp only for 			 * frames from our ap when operating in station mode. 			 * This assumes the rx key is always setup when 			 * associated. 			 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
name|rs
operator|->
name|rs_keyix
operator|!=
name|HAL_RXKEYIX_INVALID
condition|)
name|ngood
operator|++
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|ieee80211_input_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
name|rs
operator|->
name|rs_rssi
argument_list|,
name|nf
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Track rx rssi and do any rx antenna management. 		 */
name|ATH_RSSI_LPF
argument_list|(
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgrssi
argument_list|,
name|rs
operator|->
name|rs_rssi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_diversity
condition|)
block|{
comment|/* 			 * When using fast diversity, change the default rx 			 * antenna if diversity chooses the other antenna 3 			 * times in a row. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_defant
operator|!=
name|rs
operator|->
name|rs_antenna
condition|)
block|{
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_rxotherant
operator|>=
literal|3
condition|)
name|ath_setdefantenna
argument_list|(
name|sc
argument_list|,
name|rs
operator|->
name|rs_antenna
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_rxotherant
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Newer school diversity - kite specific for now */
comment|/* XXX perhaps migrate the normal diversity code to this? */
if|if
condition|(
operator|(
name|ah
operator|)
operator|->
name|ah_rxAntCombDiversity
condition|)
operator|(
operator|*
operator|(
name|ah
operator|)
operator|->
name|ah_rxAntCombDiversity
operator|)
operator|(
name|ah
operator|,
name|rs
operator|,
name|ticks
operator|,
name|hz
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
block|{
comment|/* 			 * Blink for any data frame.  Otherwise do a 			 * heartbeat-style blink when idle.  The latter 			 * is mainly for station mode where we depend on 			 * periodic beacon frames to trigger the poll event. 			 */
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_DATA
condition|)
block|{
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
init|=
name|sc
operator|->
name|sc_currates
decl_stmt|;
name|ath_led_event
argument_list|(
name|sc
argument_list|,
name|rt
operator|->
name|rateCodeToIndex
index|[
name|rs
operator|->
name|rs_rate
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ticks
operator|-
name|sc
operator|->
name|sc_ledevent
operator|>=
name|sc
operator|->
name|sc_ledidle
condition|)
name|ath_led_event
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|rx_next
label|:
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ath_rxbuf_init
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
operator|==
literal|0
condition|)
do|;
comment|/* rx signal state monitoring */
name|ath_hal_rxmonitor
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_halstats
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngood
condition|)
name|sc
operator|->
name|sc_lastrx
operator|=
name|tsf
expr_stmt|;
name|CTR2
argument_list|(
name|ATH_KTR_INTR
argument_list|,
literal|"ath_rx_proc: npkts=%d, ngood=%d"
argument_list|,
name|npkts
argument_list|,
name|ngood
argument_list|)
expr_stmt|;
comment|/* Queue DFS tasklet if needed */
if|if
condition|(
name|resched
operator|&&
name|ath_dfs_tasklet_needed
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_dfstask
argument_list|)
expr_stmt|;
comment|/* 	 * Now that all the RX frames were handled that 	 * need to be handled, kick the PCU if there's 	 * been an RXEOL condition. 	 */
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|resched
operator|&&
name|sc
operator|->
name|sc_kickpcu
condition|)
block|{
name|CTR0
argument_list|(
name|ATH_KTR_ERR
argument_list|,
literal|"ath_rx_proc: kickpcu"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: kickpcu; handled %d packets\n"
argument_list|,
name|__func__
argument_list|,
name|npkts
argument_list|)
expr_stmt|;
comment|/* XXX rxslink? */
comment|/* 		 * XXX can we hold the PCU lock here? 		 * Are there any net80211 buffer calls involved? 		 */
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
name|ath_hal_putrxbuf
argument_list|(
name|ah
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|ath_hal_rxena
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* enable recv descriptors */
name|ath_mode_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set filters, etc. */
name|ath_hal_startpcurecv
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* re-enable PCU/DMA engine */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_kickpcu
operator|=
literal|0
expr_stmt|;
block|}
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX check this inside of IF_LOCK? */
if|if
condition|(
name|resched
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
name|ieee80211_ff_age_all
argument_list|(
name|ic
argument_list|,
literal|100
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|IFQ_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|ath_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|PA2DESC
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxproc_cnt
operator|--
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_txq_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|int
name|qnum
parameter_list|)
block|{
name|txq
operator|->
name|axq_qnum
operator|=
name|qnum
expr_stmt|;
name|txq
operator|->
name|axq_ac
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|axq_depth
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|axq_aggr_depth
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|axq_intrcnt
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|axq_link
operator|=
name|NULL
expr_stmt|;
name|txq
operator|->
name|axq_softc
operator|=
name|sc
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|txq
operator|->
name|axq_q
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|txq
operator|->
name|axq_tidq
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK_INIT
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup a h/w transmit queue.  */
end_comment

begin_function
specifier|static
name|struct
name|ath_txq
modifier|*
name|ath_txq_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qtype
parameter_list|,
name|int
name|subtype
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_TXQ_INFO
name|qi
decl_stmt|;
name|int
name|qnum
decl_stmt|;
name|memset
argument_list|(
operator|&
name|qi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|qi
argument_list|)
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_subtype
operator|=
name|subtype
expr_stmt|;
name|qi
operator|.
name|tqi_aifs
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmin
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmax
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
comment|/* 	 * Enable interrupts only for EOL and DESC conditions. 	 * We mark tx descriptors to receive a DESC interrupt 	 * when a tx queue gets deep; otherwise waiting for the 	 * EOL to reap descriptors.  Note that this is done to 	 * reduce interrupt load and this only defers reaping 	 * descriptors, never transmitting frames.  Aside from 	 * reducing interrupts this also permits more concurrency. 	 * The only potential downside is if the tx queue backs 	 * up in which case the top half of the kernel may backup 	 * due to a lack of tx descriptors. 	 */
name|qi
operator|.
name|tqi_qflags
operator|=
name|HAL_TXQ_TXEOLINT_ENABLE
operator||
name|HAL_TXQ_TXDESCINT_ENABLE
expr_stmt|;
name|qnum
operator|=
name|ath_hal_setuptxqueue
argument_list|(
name|ah
argument_list|,
name|qtype
argument_list|,
operator|&
name|qi
argument_list|)
expr_stmt|;
if|if
condition|(
name|qnum
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * NB: don't print a message, this happens 		 * normally on parts with too few tx queues 		 */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|qnum
operator|>=
name|N
argument_list|(
name|sc
operator|->
name|sc_txq
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"hal qnum %u out of range, max %zu!\n"
argument_list|,
name|qnum
argument_list|,
name|N
argument_list|(
name|sc
operator|->
name|sc_txq
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_releasetxqueue
argument_list|(
name|ah
argument_list|,
name|qnum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|qnum
argument_list|)
condition|)
block|{
name|ath_txq_init
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|qnum
index|]
argument_list|,
name|qnum
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txqsetup
operator||=
literal|1
operator|<<
name|qnum
expr_stmt|;
block|}
return|return
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|qnum
index|]
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Setup a hardware data transmit queue for the specified  * access control.  The hal may not support all requested  * queues in which case it will return a reference to a  * previously setup queue.  We record the mapping from ac's  * to h/w queues for use by ath_tx_start and also track  * the set of h/w queues being used to optimize work in the  * transmit interrupt handler and related routines.  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ac
parameter_list|,
name|int
name|haltype
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|struct
name|ath_txq
modifier|*
name|txq
decl_stmt|;
if|if
condition|(
name|ac
operator|>=
name|N
argument_list|(
name|sc
operator|->
name|sc_ac2q
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"AC %u out of range, max %zu!\n"
argument_list|,
name|ac
argument_list|,
name|N
argument_list|(
name|sc
operator|->
name|sc_ac2q
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|txq
operator|=
name|ath_txq_setup
argument_list|(
name|sc
argument_list|,
name|HAL_TX_QUEUE_DATA
argument_list|,
name|haltype
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|!=
name|NULL
condition|)
block|{
name|txq
operator|->
name|axq_ac
operator|=
name|ac
expr_stmt|;
name|sc
operator|->
name|sc_ac2q
index|[
name|ac
index|]
operator|=
name|txq
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Update WME parameters for a transmit queue.  */
end_comment

begin_function
specifier|static
name|int
name|ath_txq_update
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ac
parameter_list|)
block|{
define|#
directive|define
name|ATH_EXPONENT_TO_VALUE
parameter_list|(
name|v
parameter_list|)
value|((1<<v)-1)
define|#
directive|define
name|ATH_TXOP_TO_US
parameter_list|(
name|v
parameter_list|)
value|(v<<5)
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
init|=
name|sc
operator|->
name|sc_ac2q
index|[
name|ac
index|]
decl_stmt|;
name|struct
name|wmeParams
modifier|*
name|wmep
init|=
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|ac
index|]
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_TXQ_INFO
name|qi
decl_stmt|;
name|ath_hal_gettxqueueprops
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|&
name|qi
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|sc
operator|->
name|sc_tdma
condition|)
block|{
comment|/* 		 * AIFS is zero so there's no pre-transmit wait.  The 		 * burst time defines the slot duration and is configured 		 * through net80211.  The QCU is setup to not do post-xmit 		 * back off, lockout all lower-priority QCU's, and fire 		 * off the DMA beacon alert timer which is setup based 		 * on the slot configuration. 		 */
name|qi
operator|.
name|tqi_qflags
operator|=
name|HAL_TXQ_TXOKINT_ENABLE
operator||
name|HAL_TXQ_TXERRINT_ENABLE
operator||
name|HAL_TXQ_TXURNINT_ENABLE
operator||
name|HAL_TXQ_TXEOLINT_ENABLE
operator||
name|HAL_TXQ_DBA_GATED
operator||
name|HAL_TXQ_BACKOFF_DISABLE
operator||
name|HAL_TXQ_ARB_LOCKOUT_GLOBAL
expr_stmt|;
name|qi
operator|.
name|tqi_aifs
operator|=
literal|0
expr_stmt|;
comment|/* XXX +dbaprep? */
name|qi
operator|.
name|tqi_readyTime
operator|=
name|sc
operator|->
name|sc_tdmaslotlen
expr_stmt|;
name|qi
operator|.
name|tqi_burstTime
operator|=
name|qi
operator|.
name|tqi_readyTime
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* 		 * XXX shouldn't this just use the default flags 		 * used in the previous queue setup? 		 */
name|qi
operator|.
name|tqi_qflags
operator|=
name|HAL_TXQ_TXOKINT_ENABLE
operator||
name|HAL_TXQ_TXERRINT_ENABLE
operator||
name|HAL_TXQ_TXDESCINT_ENABLE
operator||
name|HAL_TXQ_TXURNINT_ENABLE
operator||
name|HAL_TXQ_TXEOLINT_ENABLE
expr_stmt|;
name|qi
operator|.
name|tqi_aifs
operator|=
name|wmep
operator|->
name|wmep_aifsn
expr_stmt|;
name|qi
operator|.
name|tqi_cwmin
operator|=
name|ATH_EXPONENT_TO_VALUE
argument_list|(
name|wmep
operator|->
name|wmep_logcwmin
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_cwmax
operator|=
name|ATH_EXPONENT_TO_VALUE
argument_list|(
name|wmep
operator|->
name|wmep_logcwmax
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_readyTime
operator|=
literal|0
expr_stmt|;
name|qi
operator|.
name|tqi_burstTime
operator|=
name|ATH_TXOP_TO_US
argument_list|(
name|wmep
operator|->
name|wmep_txopLimit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
block|}
endif|#
directive|endif
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: Q%u qflags 0x%x aifs %u cwmin %u cwmax %u burstTime %u\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|qi
operator|.
name|tqi_qflags
argument_list|,
name|qi
operator|.
name|tqi_aifs
argument_list|,
name|qi
operator|.
name|tqi_cwmin
argument_list|,
name|qi
operator|.
name|tqi_cwmax
argument_list|,
name|qi
operator|.
name|tqi_burstTime
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_settxqueueprops
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|&
name|qi
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to update hardware queue "
literal|"parameters for %s traffic!\n"
argument_list|,
name|ieee80211_wme_acnames
index|[
name|ac
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|ath_hal_resettxqueue
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
comment|/* push to h/w */
return|return
literal|1
return|;
block|}
undef|#
directive|undef
name|ATH_TXOP_TO_US
undef|#
directive|undef
name|ATH_EXPONENT_TO_VALUE
block|}
end_function

begin_comment
comment|/*  * Callback from the 802.11 layer to update WME parameters.  */
end_comment

begin_function
specifier|static
name|int
name|ath_wme_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
return|return
operator|!
name|ath_txq_update
argument_list|(
name|sc
argument_list|,
name|WME_AC_BE
argument_list|)
operator|||
operator|!
name|ath_txq_update
argument_list|(
name|sc
argument_list|,
name|WME_AC_BK
argument_list|)
operator|||
operator|!
name|ath_txq_update
argument_list|(
name|sc
argument_list|,
name|WME_AC_VI
argument_list|)
operator|||
operator|!
name|ath_txq_update
argument_list|(
name|sc
argument_list|,
name|WME_AC_VO
argument_list|)
condition|?
name|EIO
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Reclaim resources for a setup queue.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_cleanupq
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
name|ath_hal_releasetxqueue
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK_DESTROY
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txqsetup
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|txq
operator|->
name|axq_qnum
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim all tx queue resources.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ATH_TXBUF_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
condition|)
name|ath_tx_cleanupq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return h/w rate index for an IEEE rate (w/o basic rate bit)  * using the current rates in sc_rixmap.  */
end_comment

begin_function
name|int
name|ath_tx_findrix
parameter_list|(
specifier|const
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|rate
parameter_list|)
block|{
name|int
name|rix
init|=
name|sc
operator|->
name|sc_rixmap
index|[
name|rate
index|]
decl_stmt|;
comment|/* NB: return lowest rix for invalid rate */
return|return
operator|(
name|rix
operator|==
literal|0xff
condition|?
literal|0
else|:
name|rix
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tx_update_stats
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tx_status
modifier|*
name|ts
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|int
name|sr
decl_stmt|,
name|lr
decl_stmt|,
name|pri
decl_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_status
operator|==
literal|0
condition|)
block|{
name|u_int8_t
name|txant
init|=
name|ts
operator|->
name|ts_antenna
decl_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_ant_tx
index|[
name|txant
index|]
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_ant_tx
index|[
name|txant
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_finaltsi
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_altrate
operator|++
expr_stmt|;
name|pri
operator|=
name|M_WME_GETAC
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
if|if
condition|(
name|pri
operator|>=
name|WME_AC_VO
condition|)
name|ic
operator|->
name|ic_wme
operator|.
name|wme_hipri_traffic
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|bf
operator|->
name|bf_txflags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
name|ni
operator|->
name|ni_inact
operator|=
name|ni
operator|->
name|ni_inact_reload
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TXERR_XRETRY
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_xretries
operator|++
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TXERR_FIFO
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_fifoerr
operator|++
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TXERR_FILT
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_filtered
operator|++
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TXERR_XTXOP
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_xtxop
operator|++
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TXERR_TIMER_EXPIRED
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_timerexpired
operator|++
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TX_DATA_UNDERRUN
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_data_underrun
operator|++
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TX_DELIM_UNDERRUN
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_delim_underrun
operator|++
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|->
name|m_flags
operator|&
name|M_FF
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_ff_txerr
operator|++
expr_stmt|;
block|}
comment|/* XXX when is this valid? */
if|if
condition|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TX_DESC_CFG_ERR
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_desccfgerr
operator|++
expr_stmt|;
name|sr
operator|=
name|ts
operator|->
name|ts_shortretry
expr_stmt|;
name|lr
operator|=
name|ts
operator|->
name|ts_longretry
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_shortretry
operator|+=
name|sr
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_longretry
operator|+=
name|lr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The default completion. If fail is 1, this means  * "please don't retry the frame, and just return -1 status  * to the net80211 stack.  */
end_comment

begin_function
name|void
name|ath_tx_default_comp
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|int
name|fail
parameter_list|)
block|{
name|struct
name|ath_tx_status
modifier|*
name|ts
init|=
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_txstat
decl_stmt|;
name|int
name|st
decl_stmt|;
if|if
condition|(
name|fail
operator|==
literal|1
condition|)
name|st
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|st
operator|=
operator|(
operator|(
name|bf
operator|->
name|bf_txflags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
operator|)
condition|?
name|ts
operator|->
name|ts_status
else|:
name|HAL_TXERR_XRETRY
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: dobaw should've been cleared!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_next
operator|!=
name|NULL
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bf_next not NULL!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * Do any tx complete callback.  Note this must 	 * be done before releasing the node reference. 	 * This will free the mbuf, release the net80211 	 * node and recycle the ath_buf. 	 */
name|ath_tx_freebuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|st
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update rate control with the given completion status.  */
end_comment

begin_function
name|void
name|ath_tx_update_ratectrl
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_rc_series
modifier|*
name|rc
parameter_list|,
name|struct
name|ath_tx_status
modifier|*
name|ts
parameter_list|,
name|int
name|frmlen
parameter_list|,
name|int
name|nframes
parameter_list|,
name|int
name|nbad
parameter_list|)
block|{
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
comment|/* Only for unicast frames */
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
return|return;
name|an
operator|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TXERR_FILT
operator|)
operator|==
literal|0
condition|)
block|{
name|ATH_NODE_LOCK
argument_list|(
name|an
argument_list|)
expr_stmt|;
name|ath_rate_tx_complete
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|rc
argument_list|,
name|ts
argument_list|,
name|frmlen
argument_list|,
name|nframes
argument_list|,
name|nbad
argument_list|)
expr_stmt|;
name|ATH_NODE_UNLOCK
argument_list|(
name|an
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Update the busy status of the last frame on the free list.  * When doing TDMA, the busy flag tracks whether the hardware  * currently points to this buffer or not, and thus gated DMA  * may restart by re-reading the last descriptor in this  * buffer.  *  * This should be called in the completion function once one  * of the buffers has been used.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_update_busy
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|last
decl_stmt|;
comment|/* 	 * Since the last frame may still be marked 	 * as ATH_BUF_BUSY, unmark it here before 	 * finishing the frame processing. 	 * Since we've completed a frame (aggregate 	 * or otherwise), the hardware has moved on 	 * and is no longer referencing the previous 	 * descriptor. 	 */
name|ATH_TXBUF_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|last
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|ath_bufhead_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|!=
name|NULL
condition|)
name|last
operator|->
name|bf_flags
operator|&=
operator|~
name|ATH_BUF_BUSY
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process completed xmit descriptors from the specified queue.  * Kick the packet scheduler if needed. This can occur from this  * particular task.  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_processq
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|int
name|dosched
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|struct
name|ath_tx_status
modifier|*
name|ts
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
name|int
name|nacked
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_TX_PROC
argument_list|,
literal|"%s: tx queue %u head %p link %p\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ath_hal_gettxbuf
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
argument_list|,
name|txq
operator|->
name|axq_link
argument_list|)
expr_stmt|;
name|nacked
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|txq
operator|->
name|axq_intrcnt
operator|=
literal|0
expr_stmt|;
comment|/* reset periodic desc intr count */
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|axq_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
break|break;
block|}
name|ds
operator|=
name|bf
operator|->
name|bf_lastds
expr_stmt|;
comment|/* XXX must be setup correctly! */
name|ts
operator|=
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_txstat
expr_stmt|;
name|status
operator|=
name|ath_hal_txprocdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|ts
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_XMIT_DESC
condition|)
name|ath_printtxbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
literal|0
argument_list|,
name|status
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|==
name|HAL_EINPROGRESS
condition|)
block|{
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
break|break;
block|}
name|ATH_TXQ_REMOVE
argument_list|(
name|txq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|txq
operator|->
name|axq_depth
operator|>
literal|0
condition|)
block|{
comment|/* 			 * More frames follow.  Mark the buffer busy 			 * so it's not re-used while the hardware may 			 * still re-read the link field in the descriptor. 			 * 			 * Use the last buffer in an aggregate as that 			 * is where the hardware may be - intermediate 			 * descriptors won't be "busy". 			 */
name|bf
operator|->
name|bf_last
operator|->
name|bf_flags
operator||=
name|ATH_BUF_BUSY
expr_stmt|;
block|}
elseif|else
else|#
directive|else
if|if
condition|(
name|txq
operator|->
name|axq_depth
operator|==
literal|0
condition|)
endif|#
directive|endif
name|txq
operator|->
name|axq_link
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
condition|)
name|txq
operator|->
name|axq_aggr_depth
operator|--
expr_stmt|;
name|ni
operator|=
name|bf
operator|->
name|bf_node
expr_stmt|;
comment|/* 		 * If unicast frame was ack'd update RSSI, 		 * including the last rx time used to 		 * workaround phantom bmiss interrupts. 		 */
if|if
condition|(
name|ni
operator|!=
name|NULL
operator|&&
name|ts
operator|->
name|ts_status
operator|==
literal|0
operator|&&
operator|(
operator|(
name|bf
operator|->
name|bf_txflags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|nacked
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_rssi
operator|=
name|ts
operator|->
name|ts_rssi
expr_stmt|;
name|ATH_RSSI_LPF
argument_list|(
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgtxrssi
argument_list|,
name|ts
operator|->
name|ts_rssi
argument_list|)
expr_stmt|;
block|}
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* If unicast frame, update general statistics */
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|an
operator|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* update statistics */
name|ath_tx_update_stats
argument_list|(
name|sc
argument_list|,
name|ts
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Call the completion handler. 		 * The completion handler is responsible for 		 * calling the rate control code. 		 * 		 * Frames with no completion handler get the 		 * rate control code called here. 		 */
if|if
condition|(
name|bf
operator|->
name|bf_comp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TXERR_FILT
operator|)
operator|==
literal|0
operator|&&
operator|(
name|bf
operator|->
name|bf_txflags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * XXX assume this isn't an aggregate 				 * frame. 				 */
name|ath_tx_update_ratectrl
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|,
name|ts
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
argument_list|,
literal|1
argument_list|,
operator|(
name|ts
operator|->
name|ts_status
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|bf
operator|->
name|bf_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
comment|/* 	 * Flush fast-frame staging queue when traffic slows. 	 */
if|if
condition|(
name|txq
operator|->
name|axq_depth
operator|<=
literal|1
condition|)
name|ieee80211_ff_flush
argument_list|(
name|ic
argument_list|,
name|txq
operator|->
name|axq_ac
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Kick the TXQ scheduler */
if|if
condition|(
name|dosched
condition|)
block|{
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|ath_txq_sched
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
return|return
name|nacked
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TXQACTIVE
parameter_list|(
name|t
parameter_list|,
name|q
parameter_list|)
value|( (t)& (1<< (q)))
end_define

begin_comment
comment|/*  * Deferred processing of transmit interrupt; special-cased  * for a single hardware transmit queue (e.g. 5210 and 5211).  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_proc_q0
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|uint32_t
name|txqs
decl_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txproc_cnt
operator|++
expr_stmt|;
name|txqs
operator|=
name|sc
operator|->
name|sc_txq_active
expr_stmt|;
name|sc
operator|->
name|sc_txq_active
operator|&=
operator|~
name|txqs
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|TXQACTIVE
argument_list|(
name|txqs
argument_list|,
literal|0
argument_list|)
operator|&&
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
condition|)
comment|/* XXX why is lastrx updated in tx code? */
name|sc
operator|->
name|sc_lastrx
operator|=
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|TXQACTIVE
argument_list|(
name|txqs
argument_list|,
name|sc
operator|->
name|sc_cabq
operator|->
name|axq_qnum
argument_list|)
condition|)
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_cabq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX check this inside of IF_LOCK? */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
name|ath_led_event
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_txrix
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txproc_cnt
operator|--
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deferred processing of transmit interrupt; special-cased  * for four hardware queues, 0-3 (e.g. 5212 w/ WME support).  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_proc_q0123
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|int
name|nacked
decl_stmt|;
name|uint32_t
name|txqs
decl_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txproc_cnt
operator|++
expr_stmt|;
name|txqs
operator|=
name|sc
operator|->
name|sc_txq_active
expr_stmt|;
name|sc
operator|->
name|sc_txq_active
operator|&=
operator|~
name|txqs
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Process each active queue. 	 */
name|nacked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TXQACTIVE
argument_list|(
name|txqs
argument_list|,
literal|0
argument_list|)
condition|)
name|nacked
operator|+=
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TXQACTIVE
argument_list|(
name|txqs
argument_list|,
literal|1
argument_list|)
condition|)
name|nacked
operator|+=
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TXQACTIVE
argument_list|(
name|txqs
argument_list|,
literal|2
argument_list|)
condition|)
name|nacked
operator|+=
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|2
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TXQACTIVE
argument_list|(
name|txqs
argument_list|,
literal|3
argument_list|)
condition|)
name|nacked
operator|+=
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|3
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TXQACTIVE
argument_list|(
name|txqs
argument_list|,
name|sc
operator|->
name|sc_cabq
operator|->
name|axq_qnum
argument_list|)
condition|)
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_cabq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nacked
condition|)
name|sc
operator|->
name|sc_lastrx
operator|=
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
comment|/* XXX check this inside of IF_LOCK? */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
name|ath_led_event
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_txrix
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txproc_cnt
operator|--
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deferred processing of transmit interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nacked
decl_stmt|;
name|uint32_t
name|txqs
decl_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txproc_cnt
operator|++
expr_stmt|;
name|txqs
operator|=
name|sc
operator|->
name|sc_txq_active
expr_stmt|;
name|sc
operator|->
name|sc_txq_active
operator|&=
operator|~
name|txqs
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Process each active queue. 	 */
name|nacked
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
operator|&&
name|TXQACTIVE
argument_list|(
name|txqs
argument_list|,
name|i
argument_list|)
condition|)
name|nacked
operator|+=
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nacked
condition|)
name|sc
operator|->
name|sc_lastrx
operator|=
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
comment|/* XXX check this inside of IF_LOCK? */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
name|ath_led_event
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_txrix
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txproc_cnt
operator|--
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|TXQACTIVE
end_undef

begin_comment
comment|/*  * Return a buffer to the pool and update the 'busy' flag on the  * previous 'tail' entry.  *  * This _must_ only be called when the buffer is involved in a completed  * TX. The logic is that if it was part of an active TX, the previous  * buffer on the list is now not involved in a halted TX DMA queue, waiting  * for restart (eg for TDMA.)  *  * The caller must free the mbuf and recycle the node reference.  */
end_comment

begin_function
name|void
name|ath_freebuf
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bf
operator|->
name|bf_node
operator|==
name|NULL
operator|)
argument_list|,
operator|(
literal|"%s: bf->bf_node != NULL\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bf
operator|->
name|bf_m
operator|==
name|NULL
operator|)
argument_list|,
operator|(
literal|"%s: bf->bf_m != NULL\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_tx_update_busy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is currently used by ath_tx_draintxq() and  * ath_tx_tid_free_pkts().  *  * It recycles a single ath_buf.  */
end_comment

begin_function
name|void
name|ath_tx_freebuf
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
init|=
name|bf
operator|->
name|bf_m
decl_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
comment|/* Free the buffer, it's not needed any longer */
name|ath_freebuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Do any callback and reclaim the node reference. 		 */
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_TXCB
condition|)
name|ieee80211_process_callback
argument_list|(
name|ni
argument_list|,
name|m0
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* 	 * XXX the buffer used to be freed -after-, but the DMA map was 	 * freed where ath_freebuf() now is. I've no idea what this 	 * will do. 	 */
block|}
end_function

begin_function
name|void
name|ath_tx_draintxq
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ATH_DEBUG
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
endif|#
directive|endif
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|u_int
name|ix
decl_stmt|;
comment|/* 	 * NB: this assumes output has been stopped and 	 *     we do not need to block ath_tx_proc 	 */
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bf
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|ath_bufhead_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
name|bf
operator|->
name|bf_flags
operator|&=
operator|~
name|ATH_BUF_BUSY
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
condition|;
name|ix
operator|++
control|)
block|{
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|axq_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|txq
operator|->
name|axq_link
operator|=
name|NULL
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
break|break;
block|}
name|ATH_TXQ_REMOVE
argument_list|(
name|txq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
condition|)
name|txq
operator|->
name|axq_aggr_depth
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_RESET
condition|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|sc
operator|->
name|sc_ifp
operator|->
name|if_l2com
decl_stmt|;
name|ath_printtxbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|ix
argument_list|,
name|ath_hal_txprocdesc
argument_list|(
name|ah
argument_list|,
name|bf
operator|->
name|bf_lastds
argument_list|,
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_txstat
argument_list|)
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|,
specifier|const
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|bf
operator|->
name|bf_m
operator|->
name|m_len
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ATH_DEBUG */
comment|/* 		 * Since we're now doing magic in the completion 		 * functions, we -must- call it for aggregation 		 * destinations or BAW tracking will get upset. 		 */
comment|/* 		 * Clear ATH_BUF_BUSY; the completion handler 		 * will free the buffer. 		 */
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_flags
operator|&=
operator|~
name|ATH_BUF_BUSY
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_comp
condition|)
name|bf
operator|->
name|bf_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Drain software queued frames which are on 	 * active TIDs. 	 */
name|ath_tx_txq_drain
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tx_stopdma
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: tx queue [%u] %p, link %p\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ath_hal_gettxbuf
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
argument_list|,
name|txq
operator|->
name|axq_link
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_stoptxdma
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* XXX return value */
if|if
condition|(
name|sc
operator|->
name|sc_invalid
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
block|{
comment|/* don't touch the hardware if marked invalid */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: tx queue [%u] %p, link %p\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ath_hal_gettxbuf
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
condition|)
name|ath_tx_stopdma
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Drain the transmit queues and reclaim resources.  */
end_comment

begin_function
specifier|static
name|void
name|ath_draintxq
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ATH_RESET_TYPE
name|reset_type
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ATH_DEBUG
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
endif|#
directive|endif
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|ath_stoptxdma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * XXX TODO: should we just handle the completed TX frames 		 * here, whether or not the reset is a full one or not? 		 */
if|if
condition|(
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|reset_type
operator|==
name|ATH_RESET_NOLOSS
condition|)
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ath_tx_draintxq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_RESET
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
operator|&&
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
block|{
name|ath_printtxbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
literal|0
argument_list|,
name|ath_hal_txprocdesc
argument_list|(
name|ah
argument_list|,
name|bf
operator|->
name|bf_lastds
argument_list|,
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_txstat
argument_list|)
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
name|ieee80211_dump_pkt
argument_list|(
name|ifp
operator|->
name|if_l2com
argument_list|,
name|mtod
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|,
specifier|const
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|bf
operator|->
name|bf_m
operator|->
name|m_len
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ATH_DEBUG */
comment|/* XXX check this inside of IF_LOCK? */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Disable the receive h/w in preparation for a reset.  */
end_comment

begin_function
specifier|static
name|void
name|ath_stoprecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dodelay
parameter_list|)
block|{
define|#
directive|define
name|PA2DESC
parameter_list|(
name|_sc
parameter_list|,
name|_pa
parameter_list|)
define|\
value|((struct ath_desc *)((caddr_t)(_sc)->sc_rxdma.dd_desc + \ 		((_pa) - (_sc)->sc_rxdma.dd_desc_paddr)))
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|ath_hal_stoppcurecv
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* disable PCU */
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear recv filter */
name|ath_hal_stopdmarecv
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* disable DMA engine */
if|if
condition|(
name|dodelay
condition|)
name|DELAY
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
comment|/* 3ms is long enough for 1 frame */
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
operator|(
name|ATH_DEBUG_RESET
operator||
name|ATH_DEBUG_FATAL
operator|)
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|u_int
name|ix
decl_stmt|;
name|printf
argument_list|(
literal|"%s: rx queue %p, link %p\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ath_hal_getrxbuf
argument_list|(
name|ah
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_rxlink
argument_list|)
expr_stmt|;
name|ix
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->sc_rxbuf
argument_list|,
argument|bf_list
argument_list|)
block|{
name|struct
name|ath_desc
modifier|*
name|ds
init|=
name|bf
operator|->
name|bf_desc
decl_stmt|;
name|struct
name|ath_rx_status
modifier|*
name|rs
init|=
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_rxstat
decl_stmt|;
name|HAL_STATUS
name|status
init|=
name|ath_hal_rxprocdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|,
name|PA2DESC
argument_list|(
name|sc
argument_list|,
name|ds
operator|->
name|ds_link
argument_list|)
argument_list|,
name|rs
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|HAL_OK
operator|||
operator|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_FATAL
operator|)
condition|)
name|ath_printrxbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|ix
argument_list|,
name|status
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
name|ix
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_rxpending
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_rxpending
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxpending
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|sc_rxlink
operator|=
name|NULL
expr_stmt|;
comment|/* just in case */
undef|#
directive|undef
name|PA2DESC
block|}
end_function

begin_comment
comment|/*  * Enable the receive h/w following a reset.  */
end_comment

begin_function
specifier|static
name|int
name|ath_startrecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|sc
operator|->
name|sc_rxlink
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_rxpending
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->sc_rxbuf
argument_list|,
argument|bf_list
argument_list|)
block|{
name|int
name|error
init|=
name|ath_rxbuf_init
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RECV
argument_list|,
literal|"%s: ath_rxbuf_init failed %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
name|ath_hal_putrxbuf
argument_list|(
name|ah
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|ath_hal_rxena
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* enable recv descriptors */
name|ath_mode_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set filters, etc. */
name|ath_hal_startpcurecv
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* re-enable PCU/DMA engine */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Update internal state after a channel change.  */
end_comment

begin_function
specifier|static
name|void
name|ath_chan_change
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
comment|/* 	 * Change channels and update the h/w rate map 	 * if we're switching; e.g. 11a to 11b/g. 	 */
name|mode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|sc
operator|->
name|sc_curmode
condition|)
name|ath_setcurmode
argument_list|(
name|sc
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_curchan
operator|=
name|chan
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set/change channels.  If the channel is really being changed,  * it's done by resetting the chip.  To accomplish this we must  * first cleanup any pending DMA, then restart stuff after a la  * ath_init.  */
end_comment

begin_function
specifier|static
name|int
name|ath_chan_set
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|dointr
init|=
literal|0
decl_stmt|;
comment|/* Treat this as an interface reset */
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_inreset_cnt
operator|>
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: danger! concurrent reset!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_inreset_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
name|sc
operator|->
name|sc_curchan
condition|)
block|{
name|dointr
operator|=
literal|1
expr_stmt|;
comment|/* XXX only do this if inreset_cnt is 1? */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_txrx_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: %u (%u MHz, flags 0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
name|sc
operator|->
name|sc_curchan
condition|)
block|{
name|HAL_STATUS
name|status
decl_stmt|;
comment|/* 		 * To switch channels clear any pending DMA operations; 		 * wait long enough for the RX fifo to drain, reset the 		 * hardware at the new frequency, and then re-enable 		 * the relevant bits of the h/w. 		 */
if|#
directive|if
literal|0
block|ath_hal_intrset(ah, 0);
comment|/* disable interrupts */
endif|#
directive|endif
name|ath_stoprecv
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* turn off frame recv */
comment|/* 		 * First, handle completed TX/RX frames. 		 */
name|ath_rx_proc
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ath_draintxq
argument_list|(
name|sc
argument_list|,
name|ATH_RESET_NOLOSS
argument_list|)
expr_stmt|;
comment|/* 		 * Next, flush the non-scheduled frames. 		 */
name|ath_draintxq
argument_list|(
name|sc
argument_list|,
name|ATH_RESET_FULL
argument_list|)
expr_stmt|;
comment|/* clear pending tx frames */
if|if
condition|(
operator|!
name|ath_hal_reset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_opmode
argument_list|,
name|chan
argument_list|,
name|AH_TRUE
argument_list|,
operator|&
name|status
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: unable to reset "
literal|"channel %u (%u MHz, flags 0x%x), hal status %u\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EIO
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
name|sc
operator|->
name|sc_diversity
operator|=
name|ath_hal_getdiversity
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* Let DFS at it in case it's a DFS channel */
name|ath_dfs_radar_enable
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* 		 * Re-enable rx framework. 		 */
if|if
condition|(
name|ath_startrecv
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: unable to restart recv logic\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EIO
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* 		 * Change channels and update the h/w rate map 		 * if we're switching; e.g. 11a to 11b/g. 		 */
name|ath_chan_change
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* 		 * Reset clears the beacon timers; reset them 		 * here if needed. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_beacons
condition|)
block|{
comment|/* restart beacons */
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|sc
operator|->
name|sc_tdma
condition|)
name|ath_tdma_config
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ath_beacon_config
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* 		 * Re-enable interrupts. 		 */
block|ath_hal_intrset(ah, sc->sc_imask);
endif|#
directive|endif
block|}
name|finish
label|:
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_inreset_cnt
operator|--
expr_stmt|;
comment|/* XXX only do this if sc_inreset_cnt == 0? */
if|if
condition|(
name|dointr
condition|)
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX do this inside of IF_LOCK? */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ath_txrx_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX ath_start? */
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Periodically recalibrate the PHY to account  * for temperature/environment changes.  */
end_comment

begin_function
specifier|static
name|void
name|ath_calibrate
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|HAL_BOOL
name|longCal
decl_stmt|,
name|isCalDone
decl_stmt|;
name|HAL_BOOL
name|aniCal
decl_stmt|,
name|shortCal
init|=
name|AH_FALSE
decl_stmt|;
name|int
name|nextcal
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
condition|)
comment|/* defer, off channel */
goto|goto
name|restart
goto|;
name|longCal
operator|=
operator|(
name|ticks
operator|-
name|sc
operator|->
name|sc_lastlongcal
operator|>=
name|ath_longcalinterval
operator|*
name|hz
operator|)
expr_stmt|;
name|aniCal
operator|=
operator|(
name|ticks
operator|-
name|sc
operator|->
name|sc_lastani
operator|>=
name|ath_anicalinterval
operator|*
name|hz
operator|/
literal|1000
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_doresetcal
condition|)
name|shortCal
operator|=
operator|(
name|ticks
operator|-
name|sc
operator|->
name|sc_lastshortcal
operator|>=
name|ath_shortcalinterval
operator|*
name|hz
operator|/
literal|1000
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_CALIBRATE
argument_list|,
literal|"%s: shortCal=%d; longCal=%d; aniCal=%d\n"
argument_list|,
name|__func__
argument_list|,
name|shortCal
argument_list|,
name|longCal
argument_list|,
name|aniCal
argument_list|)
expr_stmt|;
if|if
condition|(
name|aniCal
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_ani_cal
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_lastani
operator|=
name|ticks
expr_stmt|;
name|ath_hal_ani_poll
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|longCal
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_per_cal
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_lastlongcal
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|ath_hal_getrfgain
argument_list|(
name|ah
argument_list|)
operator|==
name|HAL_RFGAIN_NEED_CHANGE
condition|)
block|{
comment|/* 			 * Rfgain is out of bounds, reset the chip 			 * to load new gain values. 			 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_CALIBRATE
argument_list|,
literal|"%s: rfgain change\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_per_rfgain
operator|++
expr_stmt|;
comment|/* 			 * Drop lock - we can't hold it across the 			 * ath_reset() call. Instead, we'll drop 			 * out here, do a reset, then reschedule 			 * the callout. 			 */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|,
literal|1
argument_list|,
name|ath_calibrate
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_resetcal
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_doresetcal
operator|=
name|AH_TRUE
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_reset
argument_list|(
name|ifp
argument_list|,
name|ATH_RESET_NOLOSS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * If this long cal is after an idle period, then 		 * reset the data collection state so we start fresh. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_resetcal
condition|)
block|{
operator|(
name|void
operator|)
name|ath_hal_calreset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_lastcalreset
operator|=
name|ticks
expr_stmt|;
name|sc
operator|->
name|sc_lastshortcal
operator|=
name|ticks
expr_stmt|;
name|sc
operator|->
name|sc_resetcal
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_doresetcal
operator|=
name|AH_TRUE
expr_stmt|;
block|}
block|}
comment|/* Only call if we're doing a short/long cal, not for ANI calibration */
if|if
condition|(
name|shortCal
operator|||
name|longCal
condition|)
block|{
if|if
condition|(
name|ath_hal_calibrateN
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|,
name|longCal
argument_list|,
operator|&
name|isCalDone
argument_list|)
condition|)
block|{
if|if
condition|(
name|longCal
condition|)
block|{
comment|/* 				 * Calibrate noise floor data again in case of change. 				 */
name|ath_hal_process_noisefloor
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: calibration of channel %u failed\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_curchan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_per_calfail
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|shortCal
condition|)
name|sc
operator|->
name|sc_lastshortcal
operator|=
name|ticks
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isCalDone
condition|)
block|{
name|restart
label|:
comment|/* 		 * Use a shorter interval to potentially collect multiple 		 * data samples required to complete calibration.  Once 		 * we're told the work is done we drop back to a longer 		 * interval between requests.  We're more aggressive doing 		 * work when operating as an AP to improve operation right 		 * after startup. 		 */
name|sc
operator|->
name|sc_lastshortcal
operator|=
name|ticks
expr_stmt|;
name|nextcal
operator|=
name|ath_shortcalinterval
operator|*
name|hz
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_opmode
operator|!=
name|HAL_M_HOSTAP
condition|)
name|nextcal
operator|*=
literal|10
expr_stmt|;
name|sc
operator|->
name|sc_doresetcal
operator|=
name|AH_TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* nextcal should be the shortest time for next event */
name|nextcal
operator|=
name|ath_longcalinterval
operator|*
name|hz
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_lastcalreset
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_lastcalreset
operator|=
name|sc
operator|->
name|sc_lastlongcal
expr_stmt|;
elseif|else
if|if
condition|(
name|ticks
operator|-
name|sc
operator|->
name|sc_lastcalreset
operator|>=
name|ath_resetcalinterval
operator|*
name|hz
condition|)
name|sc
operator|->
name|sc_resetcal
operator|=
literal|1
expr_stmt|;
comment|/* setup reset next trip */
name|sc
operator|->
name|sc_doresetcal
operator|=
name|AH_FALSE
expr_stmt|;
block|}
comment|/* ANI calibration may occur more often than short/long/resetcal */
if|if
condition|(
name|ath_anicalinterval
operator|>
literal|0
condition|)
name|nextcal
operator|=
name|MIN
argument_list|(
name|nextcal
argument_list|,
name|ath_anicalinterval
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextcal
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_CALIBRATE
argument_list|,
literal|"%s: next +%u (%sisCalDone)\n"
argument_list|,
name|__func__
argument_list|,
name|nextcal
argument_list|,
name|isCalDone
condition|?
literal|""
else|:
literal|"!"
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|,
name|nextcal
argument_list|,
name|ath_calibrate
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_CALIBRATE
argument_list|,
literal|"%s: calibration disabled\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* NB: don't rearm timer */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
comment|/* XXX calibration timer? */
name|sc
operator|->
name|sc_scanning
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|0
expr_stmt|;
name|rfilt
operator|=
name|ath_calcrxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
name|ath_hal_setassocid
argument_list|(
name|ah
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"%s: RX filter 0x%x bssid %s aid 0\n"
argument_list|,
name|__func__
argument_list|,
name|rfilt
argument_list|,
name|ether_sprintf
argument_list|(
name|ifp
operator|->
name|if_broadcastaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
name|sc
operator|->
name|sc_scanning
operator|=
literal|0
expr_stmt|;
name|rfilt
operator|=
name|ath_calcrxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
name|ath_hal_setassocid
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_curbssid
argument_list|,
name|sc
operator|->
name|sc_curaid
argument_list|)
expr_stmt|;
name|ath_hal_process_noisefloor
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"%s: RX filter 0x%x bssid %s aid 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|rfilt
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|sc_curbssid
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_curaid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
operator|(
name|void
operator|)
name|ath_chan_set
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* 	 * If we are returning to our bss channel then mark state 	 * so the next recv'd beacon's tsf will be used to sync the 	 * beacon timers.  Note that since we only hear beacons in 	 * sta/ibss mode this has no effect in other operating modes. 	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_scanning
operator|&&
name|ic
operator|->
name|ic_curchan
operator|==
name|ic
operator|->
name|ic_bsschan
condition|)
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Walk the vap list and check if there any vap's in RUN state.  */
end_comment

begin_function
specifier|static
name|int
name|ath_isanyrunningvaps
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|this
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|this
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
if|if
condition|(
name|vap
operator|!=
name|this
operator|&&
name|vap
operator|->
name|iv_state
operator|>=
name|IEEE80211_S_RUN
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|stamode
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
name|int
name|csa_run_transition
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|HAL_LED_STATE
name|leds
index|[]
init|=
block|{
name|HAL_LED_INIT
block|,
comment|/* IEEE80211_S_INIT */
name|HAL_LED_SCAN
block|,
comment|/* IEEE80211_S_SCAN */
name|HAL_LED_AUTH
block|,
comment|/* IEEE80211_S_AUTH */
name|HAL_LED_ASSOC
block|,
comment|/* IEEE80211_S_ASSOC */
name|HAL_LED_RUN
block|,
comment|/* IEEE80211_S_CAC */
name|HAL_LED_RUN
block|,
comment|/* IEEE80211_S_RUN */
name|HAL_LED_RUN
block|,
comment|/* IEEE80211_S_CSA */
name|HAL_LED_RUN
block|,
comment|/* IEEE80211_S_SLEEP */
block|}
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"%s: %s -> %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_state
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_CSA
operator|&&
name|nstate
operator|==
name|IEEE80211_S_RUN
condition|)
name|csa_run_transition
operator|=
literal|1
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|)
expr_stmt|;
name|ath_hal_setledstate
argument_list|(
name|ah
argument_list|,
name|leds
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
comment|/* set LED */
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_SCAN
condition|)
block|{
comment|/* 		 * Scanning: turn off beacon miss and don't beacon. 		 * Mark beacon state so when we reach RUN state we'll 		 * [re]setup beacons.  Unblock the task q thread so 		 * deferred interrupt processing is done. 		 */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
operator|&
operator|~
operator|(
name|HAL_INT_SWBA
operator||
name|HAL_INT_BMISS
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_imask
operator|&=
operator|~
operator|(
name|HAL_INT_SWBA
operator||
name|HAL_INT_BMISS
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_beacons
operator|=
literal|0
expr_stmt|;
name|taskqueue_unblock
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
block|}
name|ni
operator|=
name|vap
operator|->
name|iv_bss
expr_stmt|;
name|rfilt
operator|=
name|ath_calcrxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|stamode
operator|=
operator|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_AHDEMO
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
operator|)
expr_stmt|;
if|if
condition|(
name|stamode
operator|&&
name|nstate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
name|sc
operator|->
name|sc_curaid
operator|=
name|ni
operator|->
name|ni_associd
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|sc_curbssid
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|ath_hal_setassocid
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_curbssid
argument_list|,
name|sc
operator|->
name|sc_curaid
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"%s: RX filter 0x%x bssid %s aid 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|rfilt
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|sc_curbssid
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_curaid
argument_list|)
expr_stmt|;
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
comment|/* XXX is this to restore keycache on resume? */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_STA
operator|&&
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_PRIVACY
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_WEP_NKID
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ath_hal_keyisvalid
argument_list|(
name|ah
argument_list|,
name|i
argument_list|)
condition|)
name|ath_hal_keysetmac
argument_list|(
name|ah
argument_list|,
name|i
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Invoke the parent method to do net80211 work. 	 */
name|error
operator|=
name|avp
operator|->
name|av_newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* NB: collect bss node again, it may have changed */
name|ni
operator|=
name|vap
operator|->
name|iv_bss
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"%s(RUN): iv_flags 0x%08x bintvl %d bssid %s "
literal|"capinfo 0x%04x chan %d\n"
argument_list|,
name|__func__
argument_list|,
name|vap
operator|->
name|iv_flags
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|)
argument_list|,
name|ni
operator|->
name|ni_capinfo
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vap
operator|->
name|iv_opmode
condition|)
block|{
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
case|case
name|IEEE80211_M_AHDEMO
case|:
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* fall thru... */
endif|#
directive|endif
case|case
name|IEEE80211_M_HOSTAP
case|:
case|case
name|IEEE80211_M_IBSS
case|:
case|case
name|IEEE80211_M_MBSS
case|:
comment|/* 			 * Allocate and setup the beacon frame. 			 * 			 * Stop any previous beacon DMA.  This may be 			 * necessary, for example, when an ibss merge 			 * causes reconfiguration; there will be a state 			 * transition from RUN->RUN that means we may 			 * be called with beacon transmission active. 			 */
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
name|error
operator|=
name|ath_beacon_alloc
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* 			 * If joining an adhoc network defer beacon timer 			 * configuration to the next beacon frame so we 			 * have a current TSF to use.  Otherwise we're 			 * starting an ibss/bss so there's no need to delay; 			 * if this is the first vap moving to RUN state, then 			 * beacon state needs to be [re]configured. 			 */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
operator|&&
name|ni
operator|->
name|ni_tstamp
operator|.
name|tsf
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_beacons
condition|)
block|{
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
condition|)
name|ath_tdma_config
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ath_beacon_config
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_beacons
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_M_STA
case|:
comment|/* 			 * Defer beacon timer configuration to the next 			 * beacon frame so we have a current TSF to use 			 * (any TSF collected when scanning is likely old). 			 * However if it's due to a CSA -> RUN transition, 			 * force a beacon update so we pick up a lack of 			 * beacons from an AP in CAC and thus force a 			 * scan. 			 */
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|csa_run_transition
condition|)
name|ath_beacon_config
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
comment|/* 			 * Monitor mode vaps have only INIT->RUN and RUN->RUN 			 * transitions so we must re-enable interrupts here to 			 * handle the case of a single monitor mode vap. 			 */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_WDS
case|:
break|break;
default|default:
break|break;
block|}
comment|/* 		 * Let the hal process statistics collected during a 		 * scan so it can provide calibrated noise floor data. 		 */
name|ath_hal_process_noisefloor
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 		 * Reset rssi stats; maybe not the best place... 		 */
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgbrssi
operator|=
name|ATH_RSSI_DUMMY_MARKER
expr_stmt|;
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgrssi
operator|=
name|ATH_RSSI_DUMMY_MARKER
expr_stmt|;
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgtxrssi
operator|=
name|ATH_RSSI_DUMMY_MARKER
expr_stmt|;
comment|/* 		 * Finally, start any timers and the task q thread 		 * (in case we didn't go through SCAN state). 		 */
if|if
condition|(
name|ath_longcalinterval
operator|!=
literal|0
condition|)
block|{
comment|/* start periodic recalibration timer */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|,
literal|1
argument_list|,
name|ath_calibrate
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_CALIBRATE
argument_list|,
literal|"%s: calibration disabled\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|taskqueue_unblock
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_INIT
condition|)
block|{
comment|/* 		 * If there are no vaps left in RUN state then 		 * shutdown host/driver operation: 		 * o disable interrupts 		 * o disable the task queue thread 		 * o mark beacon processing as stopped 		 */
if|if
condition|(
operator|!
name|ath_isanyrunningvaps
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_imask
operator|&=
operator|~
operator|(
name|HAL_INT_SWBA
operator||
name|HAL_INT_BMISS
operator|)
expr_stmt|;
comment|/* disable interrupts  */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
operator|&
operator|~
name|HAL_INT_GLOBAL
argument_list|)
expr_stmt|;
name|taskqueue_block
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_beacons
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
name|ath_hal_setcca
argument_list|(
name|ah
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|bad
label|:
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a key cache slot to the station so we can  * setup a mapping from key index to node. The key cache  * slot is needed for managing antenna state and for  * compression when stations do not use crypto.  We do  * it uniliaterally here; if crypto is employed this slot  * will be reassigned.  */
end_comment

begin_function
specifier|static
name|void
name|ath_setup_stationkey
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|ieee80211_keyix
name|keyix
decl_stmt|,
name|rxkeyix
decl_stmt|;
if|if
condition|(
operator|!
name|ath_key_alloc
argument_list|(
name|vap
argument_list|,
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|,
operator|&
name|keyix
argument_list|,
operator|&
name|rxkeyix
argument_list|)
condition|)
block|{
comment|/* 		 * Key cache is full; we'll fall back to doing 		 * the more expensive lookup in software.  Note 		 * this also means no h/w compression. 		 */
comment|/* XXX msg+statistic */
block|}
else|else
block|{
comment|/* XXX locking? */
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_keyix
operator|=
name|keyix
expr_stmt|;
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_rxkeyix
operator|=
name|rxkeyix
expr_stmt|;
comment|/* NB: must mark device key to get called back on delete */
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_flags
operator||=
name|IEEE80211_KEY_DEVKEY
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_macaddr
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
comment|/* NB: this will create a pass-thru key entry */
name|ath_keyset
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|,
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|,
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Setup driver-specific state for a newly associated node.  * Note that we're called also on a re-associate, the isnew  * param tells us if this is the first time or not.  */
end_comment

begin_function
specifier|static
name|void
name|ath_newassoc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|isnew
parameter_list|)
block|{
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
specifier|const
name|struct
name|ieee80211_txparam
modifier|*
name|tp
init|=
name|ni
operator|->
name|ni_txparms
decl_stmt|;
name|an
operator|->
name|an_mcastrix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|tp
operator|->
name|mcastrate
argument_list|)
expr_stmt|;
name|an
operator|->
name|an_mgmtrix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|tp
operator|->
name|mgmtrate
argument_list|)
expr_stmt|;
name|ath_rate_newassoc
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|isnew
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnew
operator|&&
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_PRIVACY
operator|)
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_hasclrkey
operator|&&
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_keyix
operator|==
name|IEEE80211_KEYIX_NONE
condition|)
name|ath_setup_stationkey
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_setregdomain
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_regdomain
modifier|*
name|reg
parameter_list|,
name|int
name|nchans
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: rd %u cc %u location %c%s\n"
argument_list|,
name|__func__
argument_list|,
name|reg
operator|->
name|regdomain
argument_list|,
name|reg
operator|->
name|country
argument_list|,
name|reg
operator|->
name|location
argument_list|,
name|reg
operator|->
name|ecm
condition|?
literal|" ecm"
else|:
literal|""
argument_list|)
expr_stmt|;
name|status
operator|=
name|ath_hal_set_channels
argument_list|(
name|ah
argument_list|,
name|chans
argument_list|,
name|nchans
argument_list|,
name|reg
operator|->
name|country
argument_list|,
name|reg
operator|->
name|regdomain
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|HAL_OK
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: failed, status %u\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
comment|/* XXX */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_getradiocaps
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: use rd %u cc %d\n"
argument_list|,
name|__func__
argument_list|,
name|SKU_DEBUG
argument_list|,
name|CTRY_DEFAULT
argument_list|)
expr_stmt|;
comment|/* XXX check return */
operator|(
name|void
operator|)
name|ath_hal_getchannels
argument_list|(
name|ah
argument_list|,
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|HAL_MODE_ALL
argument_list|,
name|CTRY_DEFAULT
argument_list|,
name|SKU_DEBUG
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_getchannels
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
comment|/* 	 * Collect channel set based on EEPROM contents. 	 */
name|status
operator|=
name|ath_hal_init_channels
argument_list|(
name|ah
argument_list|,
name|ic
operator|->
name|ic_channels
argument_list|,
name|IEEE80211_CHAN_MAX
argument_list|,
operator|&
name|ic
operator|->
name|ic_nchans
argument_list|,
name|HAL_MODE_ALL
argument_list|,
name|CTRY_DEFAULT
argument_list|,
name|SKU_NONE
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|HAL_OK
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: unable to collect channel list from hal, "
literal|"status %d\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
operator|(
name|void
operator|)
name|ath_hal_getregdomain
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_eerd
argument_list|)
expr_stmt|;
name|ath_hal_getcountrycode
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_eecc
argument_list|)
expr_stmt|;
comment|/* NB: cannot fail */
comment|/* XXX map Atheros sku's to net80211 SKU's */
comment|/* XXX net80211 types too small */
name|ic
operator|->
name|ic_regdomain
operator|.
name|regdomain
operator|=
operator|(
name|uint16_t
operator|)
name|sc
operator|->
name|sc_eerd
expr_stmt|;
name|ic
operator|->
name|ic_regdomain
operator|.
name|country
operator|=
operator|(
name|uint16_t
operator|)
name|sc
operator|->
name|sc_eecc
expr_stmt|;
name|ic
operator|->
name|ic_regdomain
operator|.
name|isocc
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* XXX don't know */
name|ic
operator|->
name|ic_regdomain
operator|.
name|isocc
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|ic
operator|->
name|ic_regdomain
operator|.
name|ecm
operator|=
literal|1
expr_stmt|;
name|ic
operator|->
name|ic_regdomain
operator|.
name|location
operator|=
literal|'I'
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_REGDOMAIN
argument_list|,
literal|"%s: eeprom rd %u cc %u (mapped rd %u cc %u) location %c%s\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_eerd
argument_list|,
name|sc
operator|->
name|sc_eecc
argument_list|,
name|ic
operator|->
name|ic_regdomain
operator|.
name|regdomain
argument_list|,
name|ic
operator|->
name|ic_regdomain
operator|.
name|country
argument_list|,
name|ic
operator|->
name|ic_regdomain
operator|.
name|location
argument_list|,
name|ic
operator|->
name|ic_regdomain
operator|.
name|ecm
condition|?
literal|" ecm"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_led_done
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|sc
operator|->
name|sc_blinking
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Turn the LED off: flip the pin and then set a timer so no  * update will happen for the specified duration.  */
end_comment

begin_function
specifier|static
name|void
name|ath_led_off
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|ath_hal_gpioset
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
operator|!
name|sc
operator|->
name|sc_ledon
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_ledtimer
argument_list|,
name|sc
operator|->
name|sc_ledoff
argument_list|,
name|ath_led_done
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Blink the LED according to the specified on/off times.  */
end_comment

begin_function
specifier|static
name|void
name|ath_led_blink
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|on
parameter_list|,
name|int
name|off
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_LED
argument_list|,
literal|"%s: on %u off %u\n"
argument_list|,
name|__func__
argument_list|,
name|on
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|ath_hal_gpioset
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
name|sc
operator|->
name|sc_ledon
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_blinking
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_ledoff
operator|=
name|off
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_ledtimer
argument_list|,
name|on
argument_list|,
name|ath_led_off
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_led_event
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|rix
parameter_list|)
block|{
name|sc
operator|->
name|sc_ledevent
operator|=
name|ticks
expr_stmt|;
comment|/* time of last event */
if|if
condition|(
name|sc
operator|->
name|sc_blinking
condition|)
comment|/* don't interrupt active blink */
return|return;
name|ath_led_blink
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ledon
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ledoff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_rate_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|mode
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|IEEE80211_MODE_11A
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11A
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_HALF
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11A_HALF_RATE
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_QUARTER
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11A_QUARTER_RATE
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_11B
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11B
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_11G
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11G
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_TURBO_A
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_108A
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_TURBO_G
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_108G
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_STURBO_A
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_TURBO
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_11NA
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11NA_HT20
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_11NG
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11NG_HT20
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: invalid mode %u\n"
argument_list|,
name|__func__
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sc
operator|->
name|sc_rates
index|[
name|mode
index|]
operator|=
name|rt
expr_stmt|;
return|return
operator|(
name|rt
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_setcurmode
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|ieee80211_phymode
name|mode
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
comment|/* NB: on/off times from the Atheros NDIS driver, w/ permission */
specifier|static
specifier|const
struct|struct
block|{
name|u_int
name|rate
decl_stmt|;
comment|/* tx/rx 802.11 rate */
name|u_int16_t
name|timeOn
decl_stmt|;
comment|/* LED on time (ms) */
name|u_int16_t
name|timeOff
decl_stmt|;
comment|/* LED off time (ms) */
block|}
name|blinkrates
index|[]
init|=
block|{
block|{
literal|108
block|,
literal|40
block|,
literal|10
block|}
block|,
block|{
literal|96
block|,
literal|44
block|,
literal|11
block|}
block|,
block|{
literal|72
block|,
literal|50
block|,
literal|13
block|}
block|,
block|{
literal|48
block|,
literal|57
block|,
literal|14
block|}
block|,
block|{
literal|36
block|,
literal|67
block|,
literal|16
block|}
block|,
block|{
literal|24
block|,
literal|80
block|,
literal|20
block|}
block|,
block|{
literal|22
block|,
literal|100
block|,
literal|25
block|}
block|,
block|{
literal|18
block|,
literal|133
block|,
literal|34
block|}
block|,
block|{
literal|12
block|,
literal|160
block|,
literal|40
block|}
block|,
block|{
literal|10
block|,
literal|200
block|,
literal|50
block|}
block|,
block|{
literal|6
block|,
literal|240
block|,
literal|58
block|}
block|,
block|{
literal|4
block|,
literal|267
block|,
literal|66
block|}
block|,
block|{
literal|2
block|,
literal|400
block|,
literal|100
block|}
block|,
block|{
literal|0
block|,
literal|500
block|,
literal|130
block|}
block|,
comment|/* XXX half/quarter rates */
block|}
struct|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|sc_rixmap
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rixmap
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_rates
index|[
name|mode
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no h/w rate set for phy mode %u"
operator|,
name|mode
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rt
operator|->
name|rateCount
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
name|ieeerate
init|=
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|dot11Rate
operator|&
name|IEEE80211_RATE_VAL
decl_stmt|;
if|if
condition|(
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|phy
operator|!=
name|IEEE80211_T_HT
condition|)
name|sc
operator|->
name|sc_rixmap
index|[
name|ieeerate
index|]
operator|=
name|i
expr_stmt|;
else|else
name|sc
operator|->
name|sc_rixmap
index|[
name|ieeerate
operator||
name|IEEE80211_RATE_MCS
index|]
operator|=
name|i
expr_stmt|;
block|}
name|memset
argument_list|(
name|sc
operator|->
name|sc_hwmap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hwmap
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|sc
operator|->
name|sc_hwmap
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|rt
operator|->
name|rateCount
condition|)
block|{
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ledon
operator|=
operator|(
literal|500
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ledoff
operator|=
operator|(
literal|130
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ieeerate
operator|=
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|dot11Rate
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|phy
operator|==
name|IEEE80211_T_HT
condition|)
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ieeerate
operator||=
name|IEEE80211_RATE_MCS
expr_stmt|;
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|txflags
operator|=
name|IEEE80211_RADIOTAP_F_DATAPAD
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|shortPreamble
operator|||
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|phy
operator|==
name|IEEE80211_T_OFDM
condition|)
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|txflags
operator||=
name|IEEE80211_RADIOTAP_F_SHORTPRE
expr_stmt|;
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|rxflags
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|txflags
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N
argument_list|(
name|blinkrates
argument_list|)
operator|-
literal|1
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|blinkrates
index|[
name|j
index|]
operator|.
name|rate
operator|==
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ieeerate
condition|)
break|break;
comment|/* NB: this uses the last entry if the rate isn't found */
comment|/* XXX beware of overlow */
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ledon
operator|=
operator|(
name|blinkrates
index|[
name|j
index|]
operator|.
name|timeOn
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ledoff
operator|=
operator|(
name|blinkrates
index|[
name|j
index|]
operator|.
name|timeOff
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
block|}
name|sc
operator|->
name|sc_currates
operator|=
name|rt
expr_stmt|;
name|sc
operator|->
name|sc_curmode
operator|=
name|mode
expr_stmt|;
comment|/* 	 * All protection frames are transmited at 2Mb/s for 	 * 11g, otherwise at 1Mb/s. 	 */
if|if
condition|(
name|mode
operator|==
name|IEEE80211_MODE_11G
condition|)
name|sc
operator|->
name|sc_protrix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
literal|2
operator|*
literal|2
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|sc_protrix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
literal|2
operator|*
literal|1
argument_list|)
expr_stmt|;
comment|/* NB: caller is responsible for resetting rate control state */
undef|#
directive|undef
name|N
block|}
end_function

begin_function
specifier|static
name|void
name|ath_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|do_reset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_wd_timer
operator|!=
literal|0
operator|&&
operator|--
name|sc
operator|->
name|sc_wd_timer
operator|==
literal|0
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|uint32_t
name|hangs
decl_stmt|;
if|if
condition|(
name|ath_hal_gethangstate
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0xffff
argument_list|,
operator|&
name|hangs
argument_list|)
operator|&&
name|hangs
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s hang detected (0x%x)\n"
argument_list|,
name|hangs
operator|&
literal|0xff
condition|?
literal|"bb"
else|:
literal|"mac"
argument_list|,
name|hangs
argument_list|)
expr_stmt|;
block|}
else|else
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
name|do_reset
operator|=
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_watchdog
operator|++
expr_stmt|;
block|}
comment|/* 	 * We can't hold the lock across the ath_reset() call. 	 */
if|if
condition|(
name|do_reset
condition|)
block|{
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_reset
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
name|ATH_RESET_NOLOSS
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|callout_schedule
argument_list|(
operator|&
name|sc
operator|->
name|sc_wd_ch
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_DIAGAPI
end_ifdef

begin_comment
comment|/*  * Diagnostic interface to the HAL.  This is used by various  * tools to do things like retrieve register contents for  * debugging.  The mechanism is intentionally opaque so that  * it can change frequently w/o concern for compatiblity.  */
end_comment

begin_function
specifier|static
name|int
name|ath_ioctl_diag
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_diag
modifier|*
name|ad
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|u_int
name|id
init|=
name|ad
operator|->
name|ad_id
operator|&
name|ATH_DIAG_ID
decl_stmt|;
name|void
modifier|*
name|indata
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|outdata
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|insize
init|=
name|ad
operator|->
name|ad_in_size
decl_stmt|;
name|u_int32_t
name|outsize
init|=
name|ad
operator|->
name|ad_out_size
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ad
operator|->
name|ad_id
operator|&
name|ATH_DIAG_IN
condition|)
block|{
comment|/* 		 * Copy in data. 		 */
name|indata
operator|=
name|malloc
argument_list|(
name|insize
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|indata
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|error
operator|=
name|copyin
argument_list|(
name|ad
operator|->
name|ad_in_data
argument_list|,
name|indata
argument_list|,
name|insize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|ad
operator|->
name|ad_id
operator|&
name|ATH_DIAG_DYN
condition|)
block|{
comment|/* 		 * Allocate a buffer for the results (otherwise the HAL 		 * returns a pointer to a buffer where we can read the 		 * results).  Note that we depend on the HAL leaving this 		 * pointer for us to use below in reclaiming the buffer; 		 * may want to be more defensive. 		 */
name|outdata
operator|=
name|malloc
argument_list|(
name|outsize
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|outdata
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|ath_hal_getdiagstate
argument_list|(
name|ah
argument_list|,
name|id
argument_list|,
name|indata
argument_list|,
name|insize
argument_list|,
operator|&
name|outdata
argument_list|,
operator|&
name|outsize
argument_list|)
condition|)
block|{
if|if
condition|(
name|outsize
operator|<
name|ad
operator|->
name|ad_out_size
condition|)
name|ad
operator|->
name|ad_out_size
operator|=
name|outsize
expr_stmt|;
if|if
condition|(
name|outdata
operator|!=
name|NULL
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|outdata
argument_list|,
name|ad
operator|->
name|ad_out_data
argument_list|,
name|ad
operator|->
name|ad_out_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|bad
label|:
if|if
condition|(
operator|(
name|ad
operator|->
name|ad_id
operator|&
name|ATH_DIAG_IN
operator|)
operator|&&
name|indata
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|indata
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ad
operator|->
name|ad_id
operator|&
name|ATH_DIAG_DYN
operator|)
operator|&&
name|outdata
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|outdata
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATH_DIAGAPI */
end_comment

begin_function
specifier|static
name|int
name|ath_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
define|#
directive|define
name|IS_RUNNING
parameter_list|(
name|ifp
parameter_list|)
define|\
value|((ifp->if_flags& IFF_UP)&& (ifp->if_drv_flags& IFF_DRV_RUNNING))
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_RUNNING
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
comment|/* 			 * To avoid rescanning another access point, 			 * do not call ath_init() here.  Instead, 			 * only reflect promisc mode settings. 			 */
name|ath_mode_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/* 			 * Beware of being called during attach/detach 			 * to reset promiscuous mode.  In that case we 			 * will still be marked UP but not RUNNING. 			 * However trying to re-init the interface 			 * is the wrong thing to do as we've already 			 * torn down much of our state.  There's 			 * probably a better way to deal with this. 			 */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
name|ath_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX lose error */
block|}
else|else
block|{
name|ath_stop_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* XXX must wakeup in places like ath_vap_delete */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
name|ath_hal_setpower
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_PM_FULL_SLEEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|ic
operator|->
name|ic_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGATHSTATS
case|:
comment|/* NB: embed these numbers to get a consistent view */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_packets
operator|=
name|ifp
operator|->
name|if_opackets
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_packets
operator|=
name|ifp
operator|->
name|if_ipackets
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_rssi
operator|=
name|ATH_RSSI
argument_list|(
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgtxrssi
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_rssi
operator|=
name|ATH_RSSI
argument_list|(
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgrssi
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tdma_tsfadjp
operator|=
name|TDMA_AVG
argument_list|(
name|sc
operator|->
name|sc_avgtsfdeltap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tdma_tsfadjm
operator|=
name|TDMA_AVG
argument_list|(
name|sc
operator|->
name|sc_avgtsfdeltam
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_rate
operator|=
name|rt
operator|->
name|info
index|[
name|sc
operator|->
name|sc_txrix
index|]
operator|.
name|dot11Rate
operator|&
operator|~
name|IEEE80211_RATE_BASIC
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|info
index|[
name|sc
operator|->
name|sc_txrix
index|]
operator|.
name|phy
operator|&
name|IEEE80211_T_HT
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_rate
operator||=
name|IEEE80211_RATE_MCS
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|sc
operator|->
name|sc_stats
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_stats
argument_list|)
argument_list|)
return|;
case|case
name|SIOCZATHSTATS
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|curthread
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|memset
argument_list|(
operator|&
name|sc
operator|->
name|sc_stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_stats
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|ATH_DIAGAPI
case|case
name|SIOCGATHDIAG
case|:
name|error
operator|=
name|ath_ioctl_diag
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|ath_diag
operator|*
operator|)
name|ifr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGATHPHYERR
case|:
name|error
operator|=
name|ath_ioctl_phyerr
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|ath_diag
operator|*
operator|)
name|ifr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIOCGIFADDR
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
undef|#
directive|undef
name|IS_RUNNING
block|}
end_function

begin_comment
comment|/*  * Announce various information on device/driver attach.  */
end_comment

begin_function
specifier|static
name|void
name|ath_announce
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"AR%s mac %d.%d RF%s phy %d.%d\n"
argument_list|,
name|ath_hal_mac_name
argument_list|(
name|ah
argument_list|)
argument_list|,
name|ah
operator|->
name|ah_macVersion
argument_list|,
name|ah
operator|->
name|ah_macRev
argument_list|,
name|ath_hal_rf_name
argument_list|(
name|ah
argument_list|)
argument_list|,
name|ah
operator|->
name|ah_phyRev
operator|>>
literal|4
argument_list|,
name|ah
operator|->
name|ah_phyRev
operator|&
literal|0xf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|WME_AC_VO
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ath_txq
modifier|*
name|txq
init|=
name|sc
operator|->
name|sc_ac2q
index|[
name|i
index|]
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Use hw queue %u for %s traffic\n"
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|ieee80211_wme_acnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Use hw queue %u for CAB traffic\n"
argument_list|,
name|sc
operator|->
name|sc_cabq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Use hw queue %u for beacons\n"
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ath_rxbuf
operator|!=
name|ATH_RXBUF
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"using %u rx buffers\n"
argument_list|,
name|ath_rxbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_txbuf
operator|!=
name|ATH_TXBUF
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"using %u tx buffers\n"
argument_list|,
name|ath_txbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mcastkey
operator|&&
name|bootverbose
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"using multicast key search\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_function
specifier|static
name|void
name|ath_tdma_settimers
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|nexttbtt
parameter_list|,
name|u_int32_t
name|bintval
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_BEACON_TIMERS
name|bt
decl_stmt|;
name|bt
operator|.
name|bt_intval
operator|=
name|bintval
operator||
name|HAL_BEACON_ENA
expr_stmt|;
name|bt
operator|.
name|bt_nexttbtt
operator|=
name|nexttbtt
expr_stmt|;
name|bt
operator|.
name|bt_nextdba
operator|=
operator|(
name|nexttbtt
operator|<<
literal|3
operator|)
operator|-
name|sc
operator|->
name|sc_tdmadbaprep
expr_stmt|;
name|bt
operator|.
name|bt_nextswba
operator|=
operator|(
name|nexttbtt
operator|<<
literal|3
operator|)
operator|-
name|sc
operator|->
name|sc_tdmaswbaprep
expr_stmt|;
name|bt
operator|.
name|bt_nextatim
operator|=
name|nexttbtt
operator|+
literal|1
expr_stmt|;
comment|/* Enables TBTT, DBA, SWBA timers by default */
name|bt
operator|.
name|bt_flags
operator|=
literal|0
expr_stmt|;
name|ath_hal_beaconsettimers
argument_list|(
name|ah
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Calculate the beacon interval.  This is periodic in the  * superframe for the bss.  We assume each station is configured  * identically wrt transmit rate so the guard time we calculate  * above will be the same on all stations.  Note we need to  * factor in the xmit time because the hardware will schedule  * a frame for transmit if the start of the frame is within  * the burst time.  When we get hardware that properly kills  * frames in the PCU we can reduce/eliminate the guard time.  *  * Roundup to 1024 is so we have 1 TU buffer in the guard time  * to deal with the granularity of the nexttbtt timer.  11n MAC's  * with 1us timer granularity should allow us to reduce/eliminate  * this.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tdma_bintvalsetup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ieee80211_tdma_state
modifier|*
name|tdma
parameter_list|)
block|{
comment|/* copy from vap state (XXX check all vaps have same value?) */
name|sc
operator|->
name|sc_tdmaslotlen
operator|=
name|tdma
operator|->
name|tdma_slotlen
expr_stmt|;
name|sc
operator|->
name|sc_tdmabintval
operator|=
name|roundup
argument_list|(
operator|(
name|sc
operator|->
name|sc_tdmaslotlen
operator|+
name|sc
operator|->
name|sc_tdmaguard
operator|)
operator|*
name|tdma
operator|->
name|tdma_slotcnt
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tdmabintval
operator|>>=
literal|10
expr_stmt|;
comment|/* TSF -> TU */
if|if
condition|(
name|sc
operator|->
name|sc_tdmabintval
operator|&
literal|1
condition|)
name|sc
operator|->
name|sc_tdmabintval
operator|++
expr_stmt|;
if|if
condition|(
name|tdma
operator|->
name|tdma_slot
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Only slot 0 beacons; other slots respond. 		 */
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_SWBA
expr_stmt|;
name|sc
operator|->
name|sc_tdmaswba
operator|=
literal|0
expr_stmt|;
comment|/* beacon immediately */
block|}
else|else
block|{
comment|/* XXX all vaps must be slot 0 or slot !0 */
name|sc
operator|->
name|sc_imask
operator|&=
operator|~
name|HAL_INT_SWBA
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Max 802.11 overhead.  This assumes no 4-address frames and  * the encapsulation done by ieee80211_encap (llc).  We also  * include potential crypto overhead.  */
end_comment

begin_define
define|#
directive|define
name|IEEE80211_MAXOVERHEAD
define|\
value|(sizeof(struct ieee80211_qosframe) \ 	 + sizeof(struct llc) \ 	 + IEEE80211_ADDR_LEN \ 	 + IEEE80211_WEP_IVLEN \ 	 + IEEE80211_WEP_KIDLEN \ 	 + IEEE80211_WEP_CRCLEN \ 	 + IEEE80211_WEP_MICLEN \ 	 + IEEE80211_CRC_LEN)
end_define

begin_comment
comment|/*  * Setup initially for tdma operation.  Start the beacon  * timers and enable SWBA if we are slot 0.  Otherwise  * we wait for slot 0 to arrive so we can sync up before  * starting to transmit.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tdma_config
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
specifier|const
name|struct
name|ieee80211_txparam
modifier|*
name|tp
decl_stmt|;
specifier|const
name|struct
name|ieee80211_tdma_state
modifier|*
name|tdma
init|=
name|NULL
decl_stmt|;
name|int
name|rix
decl_stmt|;
if|if
condition|(
name|vap
operator|==
name|NULL
condition|)
block|{
name|vap
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|vap
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: no vaps?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|tp
operator|=
name|vap
operator|->
name|iv_bss
operator|->
name|ni_txparms
expr_stmt|;
comment|/* 	 * Calculate the guard time for each slot.  This is the 	 * time to send a maximal-size frame according to the 	 * fixed/lowest transmit rate.  Note that the interface 	 * mtu does not include the 802.11 overhead so we must 	 * tack that on (ath_hal_computetxtime includes the 	 * preamble and plcp in it's calculation). 	 */
name|tdma
operator|=
name|vap
operator|->
name|iv_tdma
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|ucastrate
operator|!=
name|IEEE80211_FIXED_RATE_NONE
condition|)
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|tp
operator|->
name|ucastrate
argument_list|)
expr_stmt|;
else|else
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|tp
operator|->
name|mcastrate
argument_list|)
expr_stmt|;
comment|/* XXX short preamble assumed */
name|sc
operator|->
name|sc_tdmaguard
operator|=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_currates
argument_list|,
name|ifp
operator|->
name|if_mtu
operator|+
name|IEEE80211_MAXOVERHEAD
argument_list|,
name|rix
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ath_beaconq_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* setup h/w beacon q */
if|if
condition|(
name|sc
operator|->
name|sc_setcca
condition|)
name|ath_hal_setcca
argument_list|(
name|ah
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
comment|/* disable CCA */
name|ath_tdma_bintvalsetup
argument_list|(
name|sc
argument_list|,
name|tdma
argument_list|)
expr_stmt|;
comment|/* calculate beacon interval */
name|ath_tdma_settimers
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_tdmabintval
argument_list|,
name|sc
operator|->
name|sc_tdmabintval
operator||
name|HAL_BEACON_RESET_TSF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_avgtsfdeltap
operator|=
name|TDMA_DUMMY_MARKER
expr_stmt|;
name|sc
operator|->
name|sc_avgtsfdeltam
operator|=
name|TDMA_DUMMY_MARKER
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_TDMA
argument_list|,
literal|"%s: slot %u len %uus cnt %u "
literal|"bsched %u guard %uus bintval %u TU dba prep %u\n"
argument_list|,
name|__func__
argument_list|,
name|tdma
operator|->
name|tdma_slot
argument_list|,
name|tdma
operator|->
name|tdma_slotlen
argument_list|,
name|tdma
operator|->
name|tdma_slotcnt
argument_list|,
name|tdma
operator|->
name|tdma_bintval
argument_list|,
name|sc
operator|->
name|sc_tdmaguard
argument_list|,
name|sc
operator|->
name|sc_tdmabintval
argument_list|,
name|sc
operator|->
name|sc_tdmadbaprep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update tdma operation.  Called from the 802.11 layer  * when a beacon is received from the TDMA station operating  * in the slot immediately preceding us in the bss.  Use  * the rx timestamp for the beacon frame to update our  * beacon timers so we follow their schedule.  Note that  * by using the rx timestamp we implicitly include the  * propagation delay in our schedule.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tdma_update
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_tdma_param
modifier|*
name|tdma
parameter_list|,
name|int
name|changed
parameter_list|)
block|{
define|#
directive|define
name|TSF_TO_TU
parameter_list|(
name|_h
parameter_list|,
name|_l
parameter_list|)
define|\
value|((((u_int32_t)(_h))<< 22) | (((u_int32_t)(_l))>> 10))
define|#
directive|define
name|TU_TO_TSF
parameter_list|(
name|_tu
parameter_list|)
value|(((u_int64_t)(_tu))<< 10)
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
init|=
name|sc
operator|->
name|sc_currates
decl_stmt|;
name|u_int64_t
name|tsf
decl_stmt|,
name|rstamp
decl_stmt|,
name|nextslot
decl_stmt|,
name|nexttbtt
decl_stmt|;
name|u_int32_t
name|txtime
decl_stmt|,
name|nextslottu
decl_stmt|;
name|int32_t
name|tudelta
decl_stmt|,
name|tsfdelta
decl_stmt|;
specifier|const
name|struct
name|ath_rx_status
modifier|*
name|rs
decl_stmt|;
name|int
name|rix
decl_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tdma_update
operator|++
expr_stmt|;
comment|/* 	 * Check for and adopt configuration changes. 	 */
if|if
condition|(
name|changed
operator|!=
literal|0
condition|)
block|{
specifier|const
name|struct
name|ieee80211_tdma_state
modifier|*
name|ts
init|=
name|vap
operator|->
name|iv_tdma
decl_stmt|;
name|ath_tdma_bintvalsetup
argument_list|(
name|sc
argument_list|,
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
operator|&
name|TDMA_UPDATE_SLOTLEN
condition|)
name|ath_wme_update
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_TDMA
argument_list|,
literal|"%s: adopt slot %u slotcnt %u slotlen %u us "
literal|"bintval %u TU\n"
argument_list|,
name|__func__
argument_list|,
name|ts
operator|->
name|tdma_slot
argument_list|,
name|ts
operator|->
name|tdma_slotcnt
argument_list|,
name|ts
operator|->
name|tdma_slotlen
argument_list|,
name|sc
operator|->
name|sc_tdmabintval
argument_list|)
expr_stmt|;
comment|/* XXX right? */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
comment|/* NB: beacon timers programmed below */
block|}
comment|/* extend rx timestamp to 64 bits */
name|rs
operator|=
name|sc
operator|->
name|sc_lastrs
expr_stmt|;
name|tsf
operator|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|rstamp
operator|=
name|ath_extend_tsf
argument_list|(
name|sc
argument_list|,
name|rs
operator|->
name|rs_tstamp
argument_list|,
name|tsf
argument_list|)
expr_stmt|;
comment|/* 	 * The rx timestamp is set by the hardware on completing 	 * reception (at the point where the rx descriptor is DMA'd 	 * to the host).  To find the start of our next slot we 	 * must adjust this time by the time required to send 	 * the packet just received. 	 */
name|rix
operator|=
name|rt
operator|->
name|rateCodeToIndex
index|[
name|rs
operator|->
name|rs_rate
index|]
expr_stmt|;
name|txtime
operator|=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|rs
operator|->
name|rs_datalen
argument_list|,
name|rix
argument_list|,
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
argument_list|)
expr_stmt|;
comment|/* NB:<< 9 is to cvt to TU and /2 */
name|nextslot
operator|=
operator|(
name|rstamp
operator|-
name|txtime
operator|)
operator|+
operator|(
name|sc
operator|->
name|sc_tdmabintval
operator|<<
literal|9
operator|)
expr_stmt|;
name|nextslottu
operator|=
name|TSF_TO_TU
argument_list|(
name|nextslot
operator|>>
literal|32
argument_list|,
name|nextslot
argument_list|)
operator|&
name|HAL_BEACON_PERIOD
expr_stmt|;
comment|/* 	 * Retrieve the hardware NextTBTT in usecs 	 * and calculate the difference between what the 	 * other station thinks and what we have programmed.  This 	 * lets us figure how to adjust our timers to match.  The 	 * adjustments are done by pulling the TSF forward and possibly 	 * rewriting the beacon timers. 	 */
name|nexttbtt
operator|=
name|ath_hal_getnexttbtt
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|tsfdelta
operator|=
call|(
name|int32_t
call|)
argument_list|(
operator|(
name|nextslot
operator|%
name|TU_TO_TSF
argument_list|(
name|HAL_BEACON_PERIOD
operator|+
literal|1
argument_list|)
operator|)
operator|-
name|nexttbtt
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_TDMA_TIMER
argument_list|,
literal|"tsfdelta %d avg +%d/-%d\n"
argument_list|,
name|tsfdelta
argument_list|,
name|TDMA_AVG
argument_list|(
name|sc
operator|->
name|sc_avgtsfdeltap
argument_list|)
argument_list|,
name|TDMA_AVG
argument_list|(
name|sc
operator|->
name|sc_avgtsfdeltam
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsfdelta
operator|<
literal|0
condition|)
block|{
name|TDMA_SAMPLE
argument_list|(
name|sc
operator|->
name|sc_avgtsfdeltap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TDMA_SAMPLE
argument_list|(
name|sc
operator|->
name|sc_avgtsfdeltam
argument_list|,
operator|-
name|tsfdelta
argument_list|)
expr_stmt|;
name|tsfdelta
operator|=
operator|-
name|tsfdelta
operator|%
literal|1024
expr_stmt|;
name|nextslottu
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsfdelta
operator|>
literal|0
condition|)
block|{
name|TDMA_SAMPLE
argument_list|(
name|sc
operator|->
name|sc_avgtsfdeltap
argument_list|,
name|tsfdelta
argument_list|)
expr_stmt|;
name|TDMA_SAMPLE
argument_list|(
name|sc
operator|->
name|sc_avgtsfdeltam
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tsfdelta
operator|=
literal|1024
operator|-
operator|(
name|tsfdelta
operator|%
literal|1024
operator|)
expr_stmt|;
name|nextslottu
operator|++
expr_stmt|;
block|}
else|else
block|{
name|TDMA_SAMPLE
argument_list|(
name|sc
operator|->
name|sc_avgtsfdeltap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TDMA_SAMPLE
argument_list|(
name|sc
operator|->
name|sc_avgtsfdeltam
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|tudelta
operator|=
name|nextslottu
operator|-
name|TSF_TO_TU
argument_list|(
name|nexttbtt
operator|>>
literal|32
argument_list|,
name|nexttbtt
argument_list|)
expr_stmt|;
comment|/* 	 * Copy sender's timetstamp into tdma ie so they can 	 * calculate roundtrip time.  We submit a beacon frame 	 * below after any timer adjustment.  The frame goes out 	 * at the next TBTT so the sender can calculate the 	 * roundtrip by inspecting the tdma ie in our beacon frame. 	 * 	 * NB: This tstamp is subtlely preserved when 	 *     IEEE80211_BEACON_TDMA is marked (e.g. when the 	 *     slot position changes) because ieee80211_add_tdma 	 *     skips over the data. 	 */
name|memcpy
argument_list|(
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|av_boff
operator|.
name|bo_tdma
operator|+
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_tdma_param
argument_list|,
name|tdma_tstamp
argument_list|)
argument_list|,
operator|&
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|DPRINTF(sc, ATH_DEBUG_TDMA_TIMER, 	    "tsf %llu nextslot %llu (%d, %d) nextslottu %u nexttbtt %llu (%d)\n", 	    (unsigned long long) tsf, (unsigned long long) nextslot, 	    (int)(nextslot - tsf), tsfdelta, nextslottu, nexttbtt, tudelta);
endif|#
directive|endif
comment|/* 	 * Adjust the beacon timers only when pulling them forward 	 * or when going back by less than the beacon interval. 	 * Negative jumps larger than the beacon interval seem to 	 * cause the timers to stop and generally cause instability. 	 * This basically filters out jumps due to missed beacons. 	 */
if|if
condition|(
name|tudelta
operator|!=
literal|0
operator|&&
operator|(
name|tudelta
operator|>
literal|0
operator|||
operator|-
name|tudelta
operator|<
name|sc
operator|->
name|sc_tdmabintval
operator|)
condition|)
block|{
name|ath_tdma_settimers
argument_list|(
name|sc
argument_list|,
name|nextslottu
argument_list|,
name|sc
operator|->
name|sc_tdmabintval
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tdma_timers
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tsfdelta
operator|>
literal|0
condition|)
block|{
name|ath_hal_adjusttsf
argument_list|(
name|ah
argument_list|,
name|tsfdelta
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tdma_tsf
operator|++
expr_stmt|;
block|}
name|ath_tdma_beacon_send
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
comment|/* prepare response */
undef|#
directive|undef
name|TU_TO_TSF
undef|#
directive|undef
name|TSF_TO_TU
block|}
end_function

begin_comment
comment|/*  * Transmit a beacon frame at SWBA.  Dynamic updates  * to the frame contents are done as needed.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tdma_beacon_send
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|int
name|otherant
decl_stmt|;
comment|/* 	 * Check if the previous beacon has gone out.  If 	 * not don't try to post another, skip this period 	 * and wait for the next.  Missed beacons indicate 	 * a problem and should not occur.  If we miss too 	 * many consecutive beacons reset the device. 	 */
if|if
condition|(
name|ath_hal_numtxpending
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_bmisscount
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: missed %u consecutive beacons\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bmisscount
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bmisscount
operator|>=
name|ath_bstuck_threshold
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_bstucktask
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_bmisscount
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: resume beacon xmit after %u misses\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bmisscount
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bmisscount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Check recent per-antenna transmit statistics and flip 	 * the default antenna if noticeably more frames went out 	 * on the non-default antenna. 	 * XXX assumes 2 anntenae 	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_diversity
condition|)
block|{
name|otherant
operator|=
name|sc
operator|->
name|sc_defant
operator|&
literal|1
condition|?
literal|2
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ant_tx
index|[
name|otherant
index|]
operator|>
name|sc
operator|->
name|sc_ant_tx
index|[
name|sc
operator|->
name|sc_defant
index|]
operator|+
literal|2
condition|)
name|ath_setdefantenna
argument_list|(
name|sc
argument_list|,
name|otherant
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ant_tx
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|sc_ant_tx
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|bf
operator|=
name|ath_beacon_generate
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Stop any current dma and put the new frame on the queue. 		 * This should never fail since we check above that no frames 		 * are still pending on the queue. 		 */
if|if
condition|(
operator|!
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: beacon queue %u did not stop?\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
comment|/* NB: the HAL still stops DMA, so proceed */
block|}
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|ath_hal_txstart
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_xmit
operator|++
expr_stmt|;
comment|/* XXX per-vap? */
comment|/* 		 * Record local TSF for our last send for use 		 * in arbitrating slot collisions. 		 */
name|vap
operator|->
name|iv_bss
operator|->
name|ni_tstamp
operator|.
name|tsf
operator|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IEEE80211_SUPPORT_TDMA */
end_comment

begin_function
specifier|static
name|void
name|ath_dfs_tasklet
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ath_softc
operator|*
operator|)
name|p
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
comment|/* 	 * If previous processing has found a radar event, 	 * signal this to the net80211 layer to begin DFS 	 * processing. 	 */
if|if
condition|(
name|ath_dfs_process_radar_event
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
condition|)
block|{
comment|/* DFS event found, initiate channel change */
name|ieee80211_dfs_notify_radar
argument_list|(
name|ic
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|if_ath
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|if_ath
argument_list|,
name|wlan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 802.11 media layer */
end_comment

end_unit

